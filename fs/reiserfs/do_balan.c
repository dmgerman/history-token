multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
multiline_comment|/* Now we have all buffers that must be used in balancing of the tree &t;*/
multiline_comment|/* Further calculations can not cause schedule(), and thus the buffer &t;*/
multiline_comment|/* tree will be stable until the balancing will be finished &t;&t;*/
multiline_comment|/* balance the tree according to the analysis made before,&t;&t;*/
multiline_comment|/* and using buffers obtained after all above.&t;&t;&t;&t;*/
multiline_comment|/**&n; ** balance_leaf_when_delete&n; ** balance_leaf&n; ** do_balance&n; **&n; **/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#ifdef CONFIG_REISERFS_CHECK
DECL|variable|cur_tb
r_struct
id|tree_balance
op_star
id|cur_tb
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* detects whether more than one&n;                                        copy of tb exists as a means&n;                                        of checking whether schedule&n;                                        is interrupting do_balance */
macro_line|#endif
DECL|function|do_balance_mark_leaf_dirty
r_inline
r_void
id|do_balance_mark_leaf_dirty
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|flag
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|tb-&gt;tb_sb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
(brace
id|__mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tb-&gt;need_balance_dirty
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;do_balance&quot;
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
id|tb-&gt;transaction_handle
comma
id|tb-&gt;transaction_handle-&gt;t_super
comma
id|bh
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
)brace
)brace
DECL|macro|do_balance_mark_internal_dirty
mdefine_line|#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty
DECL|macro|do_balance_mark_sb_dirty
mdefine_line|#define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty
multiline_comment|/* summary: &n; if deleting something ( tb-&gt;insert_size[0] &lt; 0 )&n;   return(balance_leaf_when_delete()); (flag d handled here)&n; else&n;   if lnum is larger than 0 we put items into the left node&n;   if rnum is larger than 0 we put items into the right node&n;   if snum1 is larger than 0 we put items into the new node s1&n;   if snum2 is larger than 0 we put items into the new node s2 &n;Note that all *num* count new items being created.&n;&n;It would be easier to read balance_leaf() if each of these summary&n;lines was a separate procedure rather than being inlined.  I think&n;that there are many passages here and in balance_leaf_when_delete() in&n;which two calls to one procedure can replace two passages, and it&n;might save cache space and improve software maintenance costs to do so.  &n;&n;Vladimir made the perceptive comment that we should offload most of&n;the decision making in this function into fix_nodes/check_balance, and&n;then create some sort of structure in tb that says what actions should&n;be performed by do_balance.&n;&n;-Hans */
multiline_comment|/* Balance leaf node in case of delete or cut: insert_size[0] &lt; 0&n; *&n; * lnum, rnum can have values &gt;= -1&n; *&t;-1 means that the neighbor must be joined with S&n; *&t; 0 means that nothing should be done with the neighbor&n; *&t;&gt;0 means to shift entirely or partly the specified number of items to the neighbor&n; */
DECL|function|balance_leaf_when_delete
r_static
r_int
id|balance_leaf_when_delete
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|flag
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbS0
op_assign
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
r_int
id|item_pos
op_assign
id|PATH_LAST_POSITION
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
r_int
id|pos_in_item
op_assign
id|tb-&gt;tb_path-&gt;pos_in_item
suffix:semicolon
r_struct
id|buffer_info
id|bi
suffix:semicolon
r_int
id|n
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
id|RFALSE
c_func
(paren
id|tb-&gt;FR
(braket
l_int|0
)braket
op_logical_and
id|B_LEVEL
(paren
id|tb-&gt;FR
(braket
l_int|0
)braket
)paren
op_ne
id|DISK_LEAF_NODE_LEVEL
op_plus
l_int|1
comma
l_string|&quot;vs- 12000: level: wrong FR %z&bslash;n&quot;
comma
id|tb-&gt;FR
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|tb-&gt;blknum
(braket
l_int|0
)braket
OG
l_int|1
comma
l_string|&quot;PAP-12005: tb-&gt;blknum == %d, can not be &gt; 1&quot;
comma
id|tb-&gt;blknum
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|tb-&gt;blknum
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|PATH_H_PPARENT
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
comma
l_string|&quot;PAP-12010: tree can not be empty&quot;
)paren
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|tbS0
comma
id|item_pos
)paren
suffix:semicolon
multiline_comment|/* Delete or truncate the item */
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|M_DELETE
suffix:colon
multiline_comment|/* delete item in S[0] */
id|RFALSE
c_func
(paren
id|ih_item_len
c_func
(paren
id|ih
)paren
op_plus
id|IH_SIZE
op_ne
op_minus
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
l_string|&quot;vs-12013: mode Delete, insert size %d, ih to be deleted %h&quot;
comma
op_minus
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|ih
)paren
suffix:semicolon
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tbS0
suffix:semicolon
id|bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
suffix:semicolon
id|leaf_delete_items
(paren
op_amp
id|bi
comma
l_int|0
comma
id|item_pos
comma
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item_pos
op_logical_and
id|tb-&gt;CFL
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|B_NR_ITEMS
c_func
(paren
id|tbS0
)paren
)paren
(brace
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|tbS0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
)paren
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|PATH_H_PPARENT
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|RFALSE
c_func
(paren
op_logical_neg
id|item_pos
op_logical_and
op_logical_neg
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12020: tb-&gt;CFL[0]==%p, tb-&gt;L[0]==%p&quot;
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|M_CUT
suffix:colon
(brace
multiline_comment|/* cut item in S[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tbS0
suffix:semicolon
id|bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* UFS unlink semantics are such that you can only delete one directory entry at a time. */
multiline_comment|/* when we cut a directory tb-&gt;insert_size[0] means number of entries to be cut (always 1) */
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|leaf_cut_from_buffer
(paren
op_amp
id|bi
comma
id|item_pos
comma
id|pos_in_item
comma
op_minus
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|item_pos
op_logical_and
op_logical_neg
id|pos_in_item
op_logical_and
op_logical_neg
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12030: can not change delimiting key. CFL[0]=%p&quot;
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item_pos
op_logical_and
op_logical_neg
id|pos_in_item
op_logical_and
id|tb-&gt;CFL
(braket
l_int|0
)braket
)paren
(brace
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|tbS0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|leaf_cut_from_buffer
(paren
op_amp
id|bi
comma
id|item_pos
comma
id|pos_in_item
comma
op_minus
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|ih_item_len
c_func
(paren
id|ih
)paren
comma
l_string|&quot;PAP-12035: cut must leave non-zero dynamic length of item&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|print_cur_tb
(paren
l_string|&quot;12040&quot;
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12040: balance_leaf_when_delete: unexpectable mode: %s(%d)&quot;
comma
(paren
id|flag
op_eq
id|M_PASTE
)paren
ques
c_cond
l_string|&quot;PASTE&quot;
suffix:colon
(paren
(paren
id|flag
op_eq
id|M_INSERT
)paren
ques
c_cond
l_string|&quot;INSERT&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
comma
id|flag
)paren
suffix:semicolon
)brace
multiline_comment|/* the rule is that no shifting occurs unless by shifting a node can be freed */
id|n
op_assign
id|B_NR_ITEMS
c_func
(paren
id|tbS0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
)paren
multiline_comment|/* L[0] takes part in balancing */
(brace
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* L[0] must be joined with S[0] */
(brace
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* R[0] must be also joined with S[0] */
(brace
r_if
c_cond
(paren
id|tb-&gt;FR
(braket
l_int|0
)braket
op_eq
id|PATH_H_PPARENT
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* all contents of all the 3 buffers will be in L[0] */
r_if
c_cond
(paren
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
op_eq
l_int|0
op_logical_and
l_int|1
OL
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;FR
(braket
l_int|0
)braket
)paren
)paren
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|tb-&gt;FR
(braket
l_int|0
)braket
comma
l_int|1
)paren
suffix:semicolon
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_L
comma
id|tb
comma
id|n
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|leaf_move_items
(paren
id|LEAF_FROM_R_TO_L
comma
id|tb
comma
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
)paren
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tbS0
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tb-&gt;R
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* all contents of all the 3 buffers will be in R[0] */
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_R
comma
id|tb
comma
id|n
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|leaf_move_items
(paren
id|LEAF_FROM_L_TO_R
comma
id|tb
comma
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* right_delimiting_key is correct in R[0] */
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
comma
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tbS0
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_ne
l_int|0
comma
l_string|&quot;PAP-12045: rnum must be 0 (%d)&quot;
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* all contents of L[0] and S[0] will be in L[0] */
id|leaf_shift_left
c_func
(paren
id|tb
comma
id|n
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tbS0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */
id|RFALSE
c_func
(paren
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
OL
id|n
)paren
op_logical_or
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
OG
id|n
op_plus
l_int|1
)paren
comma
l_string|&quot;PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent&quot;
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|n
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_eq
id|n
)paren
op_logical_and
(paren
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
op_logical_or
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
comma
l_string|&quot;PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split&quot;
comma
id|tb-&gt;rbytes
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_eq
id|n
op_plus
l_int|1
)paren
op_logical_and
(paren
id|tb-&gt;lbytes
OL
l_int|1
op_logical_or
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
comma
l_string|&quot;PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split&quot;
comma
id|tb-&gt;rbytes
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
id|leaf_shift_left
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tbS0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* all contents of R[0] and S[0] will be in R[0] */
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|n
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tbS0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12065: bad rnum parameter must be 0 (%d)&quot;
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|balance_leaf
r_static
r_int
id|balance_leaf
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_struct
id|item_head
op_star
id|ih
comma
multiline_comment|/* item header of inserted item (this is on little endian) */
r_const
r_char
op_star
id|body
comma
multiline_comment|/* body  of inserted item or bytes to paste */
r_int
id|flag
comma
multiline_comment|/* i - insert, d - delete, c - cut, p - paste&n;&t;&t;&t;&t;&t;&t;&t;   (see comment to do_balance) */
r_struct
id|item_head
op_star
id|insert_key
comma
multiline_comment|/* in our processing of one level we sometimes determine what&n;&t;&t;&t;&t;&t;&t;&t;    must be inserted into the next higher level.  This insertion&n;&t;&t;&t;&t;&t;&t;&t;    consists of a key or two keys and their corresponding&n;&t;&t;&t;&t;&t;&t;&t;    pointers */
r_struct
id|buffer_head
op_star
op_star
id|insert_ptr
multiline_comment|/* inserted node-ptrs for the next level */
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbS0
op_assign
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
r_int
id|item_pos
op_assign
id|PATH_LAST_POSITION
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
multiline_comment|/*  index into the array of item headers in S[0] &n;&t;&t;&t;&t;&t;&t;&t;    of the affected item */
r_struct
id|buffer_info
id|bi
suffix:semicolon
r_struct
id|buffer_head
op_star
id|S_new
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* new nodes allocated to hold what could not fit into S */
r_int
id|snum
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* number of items that will be placed&n;                               into S_new (includes partially shifted&n;                               items) */
r_int
id|sbytes
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* if an item is partially shifted into S_new then &n;&t;&t;&t;       if it is a directory item &n;&t;&t;&t;       it is the number of entries from the item that are shifted into S_new&n;&t;&t;&t;       else&n;&t;&t;&t;       it is the number of bytes from the item that are shifted into S_new&n;&t;&t;&t;    */
r_int
id|n
comma
id|i
suffix:semicolon
r_int
id|ret_val
suffix:semicolon
r_int
id|pos_in_item
suffix:semicolon
r_int
id|zeros_num
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_mod
l_int|4
)paren
(brace
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;balance_leaf: wrong insert_size %d&quot;
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
id|PROC_INFO_INC
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|balance_at
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* Make balance in case insert_size[0] &lt; 0 */
r_if
c_cond
(paren
id|tb-&gt;insert_size
(braket
l_int|0
)braket
OL
l_int|0
)paren
r_return
id|balance_leaf_when_delete
(paren
id|tb
comma
id|flag
)paren
suffix:semicolon
id|zeros_num
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|M_INSERT
op_logical_and
id|body
op_eq
l_int|0
)paren
id|zeros_num
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|tb-&gt;tb_path-&gt;pos_in_item
suffix:semicolon
multiline_comment|/* for indirect item pos_in_item is measured in unformatted node&n;       pointers. Recalculate to bytes */
r_if
c_cond
(paren
id|flag
op_ne
id|M_INSERT
op_logical_and
id|is_indirect_le_ih
(paren
id|B_N_PITEM_HEAD
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
)paren
id|pos_in_item
op_mul_assign
id|UNFM_P_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
OG
l_int|0
)paren
(brace
multiline_comment|/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
r_if
c_cond
(paren
id|item_pos
OL
id|tb-&gt;lnum
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* new item or it part falls to L[0], shift it too */
id|n
op_assign
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|M_INSERT
suffix:colon
multiline_comment|/* insert item into L[0] */
r_if
c_cond
(paren
id|item_pos
op_eq
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_minus
l_int|1
op_logical_and
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* part of new item falls into L[0] */
r_int
id|new_item_len
suffix:semicolon
r_int
id|version
suffix:semicolon
id|RFALSE
(paren
op_logical_neg
id|is_direct_le_ih
(paren
id|ih
)paren
comma
l_string|&quot;PAP-12075: only direct inserted item can be broken. %h&quot;
comma
id|ih
)paren
suffix:semicolon
id|ret_val
op_assign
id|leaf_shift_left
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Calculate item length to insert to S[0] */
id|new_item_len
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
op_minus
id|tb-&gt;lbytes
suffix:semicolon
multiline_comment|/* Calculate and check item length to insert to L[0] */
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|ih_item_len
c_func
(paren
id|ih
)paren
op_minus
id|new_item_len
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|ih_item_len
c_func
(paren
id|ih
)paren
op_le
l_int|0
comma
l_string|&quot;PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d&quot;
comma
id|ih_item_len
c_func
(paren
id|ih
)paren
)paren
suffix:semicolon
multiline_comment|/* Insert new item into L[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_insert_into_buf
(paren
op_amp
id|bi
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
comma
id|ih
comma
id|body
comma
id|zeros_num
OG
id|ih_item_len
c_func
(paren
id|ih
)paren
ques
c_cond
id|ih_item_len
c_func
(paren
id|ih
)paren
suffix:colon
id|zeros_num
)paren
suffix:semicolon
id|version
op_assign
id|ih_version
(paren
id|ih
)paren
suffix:semicolon
multiline_comment|/* Calculate key component, item length and body to insert into S[0] */
id|set_le_ih_k_offset
c_func
(paren
id|ih
comma
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_plus
id|tb-&gt;lbytes
)paren
suffix:semicolon
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|new_item_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lbytes
OG
id|zeros_num
)paren
(brace
id|body
op_add_assign
(paren
id|tb-&gt;lbytes
op_minus
id|zeros_num
)paren
suffix:semicolon
id|zeros_num
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|zeros_num
op_sub_assign
id|tb-&gt;lbytes
suffix:semicolon
id|RFALSE
c_func
(paren
id|ih_item_len
c_func
(paren
id|ih
)paren
op_le
l_int|0
comma
l_string|&quot;PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d&quot;
comma
id|ih_item_len
c_func
(paren
id|ih
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* new item in whole falls into L[0] */
multiline_comment|/* Shift lnum[0]-1 items to L[0] */
id|ret_val
op_assign
id|leaf_shift_left
c_func
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_minus
l_int|1
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
multiline_comment|/* Insert new item into L[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_insert_into_buf
(paren
op_amp
id|bi
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
comma
id|ih
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|zeros_num
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|M_PASTE
suffix:colon
multiline_comment|/* append item in L[0] */
r_if
c_cond
(paren
id|item_pos
op_eq
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_minus
l_int|1
op_logical_and
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* we must shift the part of the appended item */
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|B_N_PITEM_HEAD
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
)paren
(brace
id|RFALSE
c_func
(paren
id|zeros_num
comma
l_string|&quot;PAP-12090: illegal parameter in case of a directory&quot;
)paren
suffix:semicolon
multiline_comment|/* directory item */
r_if
c_cond
(paren
id|tb-&gt;lbytes
OG
id|pos_in_item
)paren
(brace
multiline_comment|/* new directory entry falls into L[0] */
r_struct
id|item_head
op_star
id|pasted
suffix:semicolon
r_int
id|l_pos_in_item
op_assign
id|pos_in_item
suffix:semicolon
multiline_comment|/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
id|ret_val
op_assign
id|leaf_shift_left
c_func
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lbytes
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
op_logical_and
op_logical_neg
id|item_pos
)paren
(brace
id|pasted
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
comma
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|l_pos_in_item
op_add_assign
id|I_ENTRY_COUNT
c_func
(paren
id|pasted
)paren
op_minus
(paren
id|tb-&gt;lbytes
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Append given directory entry to directory item */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_paste_in_buffer
(paren
op_amp
id|bi
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
comma
id|l_pos_in_item
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
multiline_comment|/* previous string prepared space for pasting new entry, following string pastes this entry */
multiline_comment|/* when we have merge directory item, pos_in_item has been changed too */
multiline_comment|/* paste new directory entry. 1 is entry number */
id|leaf_paste_entries
(paren
id|bi.bi_bh
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
comma
id|l_pos_in_item
comma
l_int|1
comma
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|body
comma
id|body
op_plus
id|DEH_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* new directory item doesn&squot;t fall into L[0] */
multiline_comment|/* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
id|leaf_shift_left
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
)brace
multiline_comment|/* Calculate new position to append in item body */
id|pos_in_item
op_sub_assign
id|tb-&gt;lbytes
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* regular object */
id|RFALSE
c_func
(paren
id|tb-&gt;lbytes
op_le
l_int|0
comma
l_string|&quot;PAP-12095: there is nothing to shift to L[0]. lbytes=%d&quot;
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|pos_in_item
op_ne
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
comma
l_string|&quot;PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d&quot;
comma
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
comma
id|pos_in_item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lbytes
op_ge
id|pos_in_item
)paren
(brace
multiline_comment|/* appended item will be in L[0] in whole */
r_int
id|l_n
suffix:semicolon
multiline_comment|/* this bytes number must be appended to the last item of L[h] */
id|l_n
op_assign
id|tb-&gt;lbytes
op_minus
id|pos_in_item
suffix:semicolon
multiline_comment|/* Calculate new insert_size[0] */
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_sub_assign
id|l_n
suffix:semicolon
id|RFALSE
c_func
(paren
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_le
l_int|0
comma
l_string|&quot;PAP-12105: there is nothing to paste into L[0]. insert_size=%d&quot;
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ret_val
op_assign
id|leaf_shift_left
c_func
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Append to body of item in L[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_paste_in_buffer
c_func
(paren
op_amp
id|bi
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
comma
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
)paren
)paren
comma
id|l_n
comma
id|body
comma
id|zeros_num
OG
id|l_n
ques
c_cond
id|l_n
suffix:colon
id|zeros_num
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|l_n
op_logical_and
id|is_indirect_le_ih
c_func
(paren
id|B_N_PITEM_HEAD
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
)paren
)paren
comma
l_string|&quot;PAP-12110: pasting more than 1 unformatted node pointer into indirect item&quot;
)paren
suffix:semicolon
multiline_comment|/* 0-th item in S0 can be only of DIRECT type when l_n != 0*/
(brace
r_int
id|version
suffix:semicolon
id|version
op_assign
id|ih_version
(paren
id|B_N_PITEM_HEAD
(paren
id|tbS0
comma
l_int|0
)paren
)paren
suffix:semicolon
id|set_le_key_k_offset
(paren
id|version
comma
id|B_N_PKEY
(paren
id|tbS0
comma
l_int|0
)paren
comma
id|le_key_k_offset
(paren
id|version
comma
id|B_N_PKEY
(paren
id|tbS0
comma
l_int|0
)paren
)paren
op_plus
id|l_n
)paren
suffix:semicolon
id|version
op_assign
id|ih_version
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|set_le_key_k_offset
(paren
id|version
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
)paren
comma
id|le_key_k_offset
(paren
id|version
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
)paren
)paren
op_plus
id|l_n
)paren
suffix:semicolon
)brace
multiline_comment|/* Calculate new body, position in item and insert_size[0] */
r_if
c_cond
(paren
id|l_n
OG
id|zeros_num
)paren
(brace
id|body
op_add_assign
(paren
id|l_n
op_minus
id|zeros_num
)paren
suffix:semicolon
id|zeros_num
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|zeros_num
op_sub_assign
id|l_n
suffix:semicolon
id|pos_in_item
op_assign
l_int|0
suffix:semicolon
id|RFALSE
c_func
(paren
id|comp_short_le_keys
(paren
id|B_N_PKEY
c_func
(paren
id|tbS0
comma
l_int|0
)paren
comma
id|B_N_PKEY
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
comma
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
op_minus
l_int|1
)paren
)paren
op_logical_or
op_logical_neg
id|op_is_left_mergeable
(paren
id|B_N_PKEY
(paren
id|tbS0
comma
l_int|0
)paren
comma
id|tbS0-&gt;b_size
)paren
op_logical_or
op_logical_neg
id|op_is_left_mergeable
(paren
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
)paren
comma
id|tbS0-&gt;b_size
)paren
comma
l_string|&quot;PAP-12120: item must be merge-able with left neighboring item&quot;
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* only part of the appended item will be in L[0] */
(brace
multiline_comment|/* Calculate position in item for append in S[0] */
id|pos_in_item
op_sub_assign
id|tb-&gt;lbytes
suffix:semicolon
id|RFALSE
c_func
(paren
id|pos_in_item
op_le
l_int|0
comma
l_string|&quot;PAP-12125: no place for paste. pos_in_item=%d&quot;
comma
id|pos_in_item
)paren
suffix:semicolon
multiline_comment|/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
id|leaf_shift_left
c_func
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* appended item will be in L[0] in whole */
(brace
r_struct
id|item_head
op_star
id|pasted
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item_pos
op_logical_and
id|op_is_left_mergeable
(paren
id|B_N_PKEY
(paren
id|tbS0
comma
l_int|0
)paren
comma
id|tbS0-&gt;b_size
)paren
)paren
(brace
multiline_comment|/* if we paste into first item of S[0] and it is left mergable */
multiline_comment|/* then increment pos_in_item by the size of the last item in L[0] */
id|pasted
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
comma
id|n
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|pasted
)paren
)paren
id|pos_in_item
op_add_assign
id|ih_entry_count
c_func
(paren
id|pasted
)paren
suffix:semicolon
r_else
id|pos_in_item
op_add_assign
id|ih_item_len
c_func
(paren
id|pasted
)paren
suffix:semicolon
)brace
multiline_comment|/* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
id|ret_val
op_assign
id|leaf_shift_left
c_func
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
multiline_comment|/* Append to body of item in L[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_paste_in_buffer
(paren
op_amp
id|bi
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
comma
id|pos_in_item
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
multiline_comment|/* if appended item is directory, paste entry */
id|pasted
op_assign
id|B_N_PITEM_HEAD
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|pasted
)paren
)paren
id|leaf_paste_entries
(paren
id|bi.bi_bh
comma
id|n
op_plus
id|item_pos
op_minus
id|ret_val
comma
id|pos_in_item
comma
l_int|1
comma
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|body
comma
id|body
op_plus
id|DEH_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* if appended item is indirect item, put unformatted node into un list */
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|pasted
)paren
)paren
id|set_ih_free_space
(paren
id|pasted
comma
(paren
(paren
r_struct
id|unfm_nodeinfo
op_star
)paren
id|body
)paren
op_member_access_from_pointer
id|unfm_freespace
)paren
suffix:semicolon
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|zeros_num
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* cases d and t */
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12130: balance_leaf: lnum &gt; 0: unexpectable mode: %s(%d)&quot;
comma
(paren
id|flag
op_eq
id|M_DELETE
)paren
ques
c_cond
l_string|&quot;DELETE&quot;
suffix:colon
(paren
(paren
id|flag
op_eq
id|M_CUT
)paren
ques
c_cond
l_string|&quot;CUT&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
comma
id|flag
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* new item doesn&squot;t fall into L[0] */
id|leaf_shift_left
c_func
(paren
id|tb
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lbytes
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* tb-&gt;lnum[0] &gt; 0 */
multiline_comment|/* Calculate new item position */
id|item_pos
op_sub_assign
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_minus
(paren
(paren
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
OG
l_int|0
)paren
(brace
multiline_comment|/* shift rnum[0] items from S[0] to the right neighbor R[0] */
id|n
op_assign
id|B_NR_ITEMS
c_func
(paren
id|tbS0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|M_INSERT
suffix:colon
multiline_comment|/* insert item */
r_if
c_cond
(paren
id|n
op_minus
id|tb-&gt;rnum
(braket
l_int|0
)braket
OL
id|item_pos
)paren
(brace
multiline_comment|/* new item or its part falls to R[0] */
r_if
c_cond
(paren
id|item_pos
op_eq
id|n
op_minus
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_plus
l_int|1
op_logical_and
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* part of new item falls into R[0] */
r_int
id|old_key_comp
comma
id|old_len
comma
id|r_zeros_number
suffix:semicolon
r_const
r_char
op_star
id|r_body
suffix:semicolon
r_int
id|version
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|is_direct_le_ih
(paren
id|ih
)paren
comma
l_string|&quot;PAP-12135: only direct item can be split. (%h)&quot;
comma
id|ih
)paren
suffix:semicolon
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|version
op_assign
id|ih_version
c_func
(paren
id|ih
)paren
suffix:semicolon
multiline_comment|/* Remember key component and item length */
id|old_key_comp
op_assign
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
suffix:semicolon
id|old_len
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
suffix:semicolon
multiline_comment|/* Calculate key component and item length to insert into R[0] */
id|offset
op_assign
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_plus
(paren
id|old_len
op_minus
id|tb-&gt;rbytes
)paren
suffix:semicolon
id|set_le_ih_k_offset
c_func
(paren
id|ih
comma
id|offset
)paren
suffix:semicolon
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
multiline_comment|/* Insert part of the item into R[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_minus
id|old_key_comp
OG
id|zeros_num
)paren
(brace
id|r_zeros_number
op_assign
l_int|0
suffix:semicolon
id|r_body
op_assign
id|body
op_plus
id|offset
op_minus
id|old_key_comp
op_minus
id|zeros_num
suffix:semicolon
)brace
r_else
(brace
id|r_body
op_assign
id|body
suffix:semicolon
id|r_zeros_number
op_assign
id|zeros_num
op_minus
(paren
id|offset
op_minus
id|old_key_comp
)paren
suffix:semicolon
id|zeros_num
op_sub_assign
id|r_zeros_number
suffix:semicolon
)brace
id|leaf_insert_into_buf
(paren
op_amp
id|bi
comma
l_int|0
comma
id|ih
comma
id|r_body
comma
id|r_zeros_number
)paren
suffix:semicolon
multiline_comment|/* Replace right delimiting key by first key in R[0] */
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
comma
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Calculate key component and item length to insert into S[0] */
id|set_le_ih_k_offset
c_func
(paren
id|ih
comma
id|old_key_comp
)paren
suffix:semicolon
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|old_len
op_minus
id|tb-&gt;rbytes
)paren
suffix:semicolon
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_sub_assign
id|tb-&gt;rbytes
suffix:semicolon
)brace
r_else
multiline_comment|/* whole new item falls into R[0] */
(brace
multiline_comment|/* Shift rnum[0]-1 items to R[0] */
id|ret_val
op_assign
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_minus
l_int|1
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
multiline_comment|/* Insert new item into R[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_insert_into_buf
(paren
op_amp
id|bi
comma
id|item_pos
op_minus
id|n
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_minus
l_int|1
comma
id|ih
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item_pos
op_minus
id|n
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_minus
l_int|1
op_eq
l_int|0
)paren
(brace
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
comma
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|zeros_num
op_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* new item or part of it doesn&squot;t fall into R[0] */
(brace
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|M_PASTE
suffix:colon
multiline_comment|/* append item */
r_if
c_cond
(paren
id|n
op_minus
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_le
id|item_pos
)paren
multiline_comment|/* pasted item or part of it falls to R[0] */
(brace
r_if
c_cond
(paren
id|item_pos
op_eq
id|n
op_minus
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_logical_and
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* we must shift the part of the appended item */
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
)paren
(brace
multiline_comment|/* we append to directory item */
r_int
id|entry_count
suffix:semicolon
id|RFALSE
c_func
(paren
id|zeros_num
comma
l_string|&quot;PAP-12145: illegal parametr in case of a directory&quot;
)paren
suffix:semicolon
id|entry_count
op_assign
id|I_ENTRY_COUNT
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry_count
op_minus
id|tb-&gt;rbytes
OL
id|pos_in_item
)paren
multiline_comment|/* new directory entry falls into R[0] */
(brace
r_int
id|paste_entry_position
suffix:semicolon
id|RFALSE
c_func
(paren
id|tb-&gt;rbytes
op_minus
l_int|1
op_ge
id|entry_count
op_logical_or
op_logical_neg
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d&quot;
comma
id|tb-&gt;rbytes
comma
id|entry_count
)paren
suffix:semicolon
multiline_comment|/* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;rbytes
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Paste given directory entry to directory item */
id|paste_entry_position
op_assign
id|pos_in_item
op_minus
id|entry_count
op_plus
id|tb-&gt;rbytes
op_minus
l_int|1
suffix:semicolon
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_paste_in_buffer
(paren
op_amp
id|bi
comma
l_int|0
comma
id|paste_entry_position
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
multiline_comment|/* paste entry */
id|leaf_paste_entries
(paren
id|bi.bi_bh
comma
l_int|0
comma
id|paste_entry_position
comma
l_int|1
comma
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|body
comma
id|body
op_plus
id|DEH_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paste_entry_position
op_eq
l_int|0
)paren
(brace
multiline_comment|/* change delimiting keys */
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
comma
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pos_in_item
op_increment
suffix:semicolon
)brace
r_else
multiline_comment|/* new directory entry doesn&squot;t fall into R[0] */
(brace
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* regular object */
(brace
r_int
id|n_shift
comma
id|n_rem
comma
id|r_zeros_number
suffix:semicolon
r_const
r_char
op_star
id|r_body
suffix:semicolon
multiline_comment|/* Calculate number of bytes which must be shifted from appended item */
r_if
c_cond
(paren
(paren
id|n_shift
op_assign
id|tb-&gt;rbytes
op_minus
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
OL
l_int|0
)paren
id|n_shift
op_assign
l_int|0
suffix:semicolon
id|RFALSE
c_func
(paren
id|pos_in_item
op_ne
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
comma
l_string|&quot;PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d&quot;
comma
id|pos_in_item
comma
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
)paren
suffix:semicolon
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|n_shift
)paren
suffix:semicolon
multiline_comment|/* Calculate number of bytes which must remain in body after appending to R[0] */
r_if
c_cond
(paren
(paren
id|n_rem
op_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_minus
id|tb-&gt;rbytes
)paren
OL
l_int|0
)paren
id|n_rem
op_assign
l_int|0
suffix:semicolon
(brace
r_int
id|version
suffix:semicolon
id|version
op_assign
id|ih_version
(paren
id|B_N_PITEM_HEAD
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
)paren
suffix:semicolon
id|set_le_key_k_offset
(paren
id|version
comma
id|B_N_PKEY
c_func
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
comma
id|le_key_k_offset
(paren
id|version
comma
id|B_N_PKEY
c_func
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
)paren
op_plus
id|n_rem
)paren
suffix:semicolon
id|set_le_key_k_offset
(paren
id|version
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
)paren
comma
id|le_key_k_offset
(paren
id|version
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
)paren
)paren
op_plus
id|n_rem
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;&t;  k_offset (B_N_PKEY(tb-&gt;R[0],0)) += n_rem;&n;&t;&t;  k_offset (B_N_PDELIM_KEY(tb-&gt;CFR[0],tb-&gt;rkey[0])) += n_rem;*/
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Append part of body into R[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_rem
OG
id|zeros_num
)paren
(brace
id|r_zeros_number
op_assign
l_int|0
suffix:semicolon
id|r_body
op_assign
id|body
op_plus
id|n_rem
op_minus
id|zeros_num
suffix:semicolon
)brace
r_else
(brace
id|r_body
op_assign
id|body
suffix:semicolon
id|r_zeros_number
op_assign
id|zeros_num
op_minus
id|n_rem
suffix:semicolon
id|zeros_num
op_sub_assign
id|r_zeros_number
suffix:semicolon
)brace
id|leaf_paste_in_buffer
c_func
(paren
op_amp
id|bi
comma
l_int|0
comma
id|n_shift
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_minus
id|n_rem
comma
id|r_body
comma
id|r_zeros_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
)paren
)paren
(brace
id|RFALSE
c_func
(paren
id|n_rem
comma
l_string|&quot;PAP-12160: paste more than one unformatted node pointer&quot;
)paren
suffix:semicolon
id|set_ih_free_space
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
comma
(paren
(paren
r_struct
id|unfm_nodeinfo
op_star
)paren
id|body
)paren
op_member_access_from_pointer
id|unfm_freespace
)paren
suffix:semicolon
)brace
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
id|n_rem
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_rem
)paren
id|pos_in_item
op_increment
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* pasted item in whole falls into R[0] */
(brace
r_struct
id|item_head
op_star
id|pasted
suffix:semicolon
id|ret_val
op_assign
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
multiline_comment|/* append item in R[0] */
r_if
c_cond
(paren
id|pos_in_item
op_ge
l_int|0
)paren
(brace
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|leaf_paste_in_buffer
c_func
(paren
op_amp
id|bi
comma
id|item_pos
op_minus
id|n
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|pos_in_item
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
)brace
multiline_comment|/* paste new entry, if item is directory item */
id|pasted
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
id|item_pos
op_minus
id|n
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|pasted
)paren
op_logical_and
id|pos_in_item
op_ge
l_int|0
)paren
(brace
id|leaf_paste_entries
(paren
id|bi.bi_bh
comma
id|item_pos
op_minus
id|n
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|pos_in_item
comma
l_int|1
comma
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|body
comma
id|body
op_plus
id|DEH_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pos_in_item
)paren
(brace
id|RFALSE
c_func
(paren
id|item_pos
op_minus
id|n
op_plus
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12165: directory item must be first item of node when pasting is in 0th position&quot;
)paren
suffix:semicolon
multiline_comment|/* update delimiting keys */
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
comma
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|pasted
)paren
)paren
id|set_ih_free_space
(paren
id|pasted
comma
(paren
(paren
r_struct
id|unfm_nodeinfo
op_star
)paren
id|body
)paren
op_member_access_from_pointer
id|unfm_freespace
)paren
suffix:semicolon
id|zeros_num
op_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* new item doesn&squot;t fall into R[0] */
(brace
id|leaf_shift_right
c_func
(paren
id|tb
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* cases d and t */
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12175: balance_leaf: rnum &gt; 0: unexpectable mode: %s(%d)&quot;
comma
(paren
id|flag
op_eq
id|M_DELETE
)paren
ques
c_cond
l_string|&quot;DELETE&quot;
suffix:colon
(paren
(paren
id|flag
op_eq
id|M_CUT
)paren
ques
c_cond
l_string|&quot;CUT&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
comma
id|flag
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* tb-&gt;rnum[0] &gt; 0 */
id|RFALSE
c_func
(paren
id|tb-&gt;blknum
(braket
l_int|0
)braket
OG
l_int|3
comma
l_string|&quot;PAP-12180: blknum can not be %d. It must be &lt;= 3&quot;
comma
id|tb-&gt;blknum
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|tb-&gt;blknum
(braket
l_int|0
)braket
OL
l_int|0
comma
l_string|&quot;PAP-12185: blknum can not be %d. It must be &gt;= 0&quot;
comma
id|tb-&gt;blknum
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* if while adding to a node we discover that it is possible to split&n;       it in two, and merge the left part into the left neighbor and the&n;       right part into the right neighbor, eliminating the node */
r_if
c_cond
(paren
id|tb-&gt;blknum
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* node S[0] is empty now */
id|RFALSE
c_func
(paren
op_logical_neg
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_logical_or
op_logical_neg
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12190: lnum and rnum must not be zero&quot;
)paren
suffix:semicolon
multiline_comment|/* if insertion was done before 0-th position in R[0], right&n;&t;   delimiting key of the tb-&gt;L[0]&squot;s and left delimiting key are&n;&t;   not set correctly */
r_if
c_cond
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tb-&gt;CFR
(braket
l_int|0
)braket
)paren
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-12195: balance_leaf: CFR not initialized&quot;
)paren
suffix:semicolon
id|copy_key
(paren
id|B_N_PDELIM_KEY
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
)paren
comma
id|B_N_PDELIM_KEY
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
id|reiserfs_invalidate_buffer
c_func
(paren
id|tb
comma
id|tbS0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Fill new nodes that appear in place of S[0] */
multiline_comment|/* I am told that this copying is because we need an array to enable&n;       the looping code. -Hans */
id|snum
(braket
l_int|0
)braket
op_assign
id|tb-&gt;s1num
comma
id|snum
(braket
l_int|1
)braket
op_assign
id|tb-&gt;s2num
suffix:semicolon
id|sbytes
(braket
l_int|0
)braket
op_assign
id|tb-&gt;s1bytes
suffix:semicolon
id|sbytes
(braket
l_int|1
)braket
op_assign
id|tb-&gt;s2bytes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|tb-&gt;blknum
(braket
l_int|0
)braket
op_minus
l_int|2
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|snum
(braket
id|i
)braket
comma
l_string|&quot;PAP-12200: snum[%d] == %d. Must be &gt; 0&quot;
comma
id|i
comma
id|snum
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* here we shift from S to S_new nodes */
id|S_new
(braket
id|i
)braket
op_assign
id|get_FEB
c_func
(paren
id|tb
)paren
suffix:semicolon
multiline_comment|/* initialized block type and tree level */
id|set_blkh_level
c_func
(paren
id|B_BLK_HEAD
c_func
(paren
id|S_new
(braket
id|i
)braket
)paren
comma
id|DISK_LEAF_NODE_LEVEL
)paren
suffix:semicolon
id|n
op_assign
id|B_NR_ITEMS
c_func
(paren
id|tbS0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|M_INSERT
suffix:colon
multiline_comment|/* insert item */
r_if
c_cond
(paren
id|n
op_minus
id|snum
(braket
id|i
)braket
OL
id|item_pos
)paren
(brace
multiline_comment|/* new item or it&squot;s part falls to first new node S_new[i]*/
r_if
c_cond
(paren
id|item_pos
op_eq
id|n
op_minus
id|snum
(braket
id|i
)braket
op_plus
l_int|1
op_logical_and
id|sbytes
(braket
id|i
)braket
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* part of new item falls into S_new[i] */
r_int
id|old_key_comp
comma
id|old_len
comma
id|r_zeros_number
suffix:semicolon
r_const
r_char
op_star
id|r_body
suffix:semicolon
r_int
id|version
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|is_direct_le_ih
c_func
(paren
id|ih
)paren
comma
multiline_comment|/* The items which can be inserted are:&n;&t;&t;&t;   Stat_data item, direct item, indirect item and directory item which consist of only two entries &quot;.&quot; and &quot;..&quot;.&n;&t;&t;&t;   These items must not be broken except for a direct one. */
l_string|&quot;PAP-12205: non-direct item can not be broken when inserting&quot;
)paren
suffix:semicolon
multiline_comment|/* Move snum[i]-1 items from S[0] to S_new[i] */
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Remember key component and item length */
id|version
op_assign
id|ih_version
(paren
id|ih
)paren
suffix:semicolon
id|old_key_comp
op_assign
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
suffix:semicolon
id|old_len
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
suffix:semicolon
multiline_comment|/* Calculate key component and item length to insert into S_new[i] */
id|set_le_ih_k_offset
c_func
(paren
id|ih
comma
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_plus
(paren
id|old_len
op_minus
id|sbytes
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|sbytes
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Insert part of the item into S_new[i] before 0-th item */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|S_new
(braket
id|i
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
l_int|0
suffix:semicolon
id|bi.bi_position
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|le_ih_k_offset
(paren
id|ih
)paren
op_minus
id|old_key_comp
OG
id|zeros_num
)paren
(brace
id|r_zeros_number
op_assign
l_int|0
suffix:semicolon
id|r_body
op_assign
id|body
op_plus
(paren
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_minus
id|old_key_comp
)paren
op_minus
id|zeros_num
suffix:semicolon
)brace
r_else
(brace
id|r_body
op_assign
id|body
suffix:semicolon
id|r_zeros_number
op_assign
id|zeros_num
op_minus
(paren
id|le_ih_k_offset
(paren
id|ih
)paren
op_minus
id|old_key_comp
)paren
suffix:semicolon
id|zeros_num
op_sub_assign
id|r_zeros_number
suffix:semicolon
)brace
id|leaf_insert_into_buf
(paren
op_amp
id|bi
comma
l_int|0
comma
id|ih
comma
id|r_body
comma
id|r_zeros_number
)paren
suffix:semicolon
multiline_comment|/* Calculate key component and item length to insert into S[i] */
id|set_le_ih_k_offset
c_func
(paren
id|ih
comma
id|old_key_comp
)paren
suffix:semicolon
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|old_len
op_minus
id|sbytes
(braket
id|i
)braket
)paren
suffix:semicolon
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_sub_assign
id|sbytes
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
multiline_comment|/* whole new item falls into S_new[i] */
(brace
multiline_comment|/* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
op_minus
l_int|1
comma
id|sbytes
(braket
id|i
)braket
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Insert new item into S_new[i] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|S_new
(braket
id|i
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
l_int|0
suffix:semicolon
id|bi.bi_position
op_assign
l_int|0
suffix:semicolon
id|leaf_insert_into_buf
(paren
op_amp
id|bi
comma
id|item_pos
op_minus
id|n
op_plus
id|snum
(braket
id|i
)braket
op_minus
l_int|1
comma
id|ih
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
id|zeros_num
op_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* new item or it part don&squot;t falls into S_new[i] */
(brace
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
comma
id|sbytes
(braket
id|i
)braket
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|M_PASTE
suffix:colon
multiline_comment|/* append item */
r_if
c_cond
(paren
id|n
op_minus
id|snum
(braket
id|i
)braket
op_le
id|item_pos
)paren
multiline_comment|/* pasted item or part if it falls to S_new[i] */
(brace
r_if
c_cond
(paren
id|item_pos
op_eq
id|n
op_minus
id|snum
(braket
id|i
)braket
op_logical_and
id|sbytes
(braket
id|i
)braket
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* we must shift part of the appended item */
r_struct
id|item_head
op_star
id|aux_ih
suffix:semicolon
id|RFALSE
c_func
(paren
id|ih
comma
l_string|&quot;PAP-12210: ih must be 0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|aux_ih
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
)paren
(brace
multiline_comment|/* we append to directory item */
r_int
id|entry_count
suffix:semicolon
id|entry_count
op_assign
id|ih_entry_count
c_func
(paren
id|aux_ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry_count
op_minus
id|sbytes
(braket
id|i
)braket
OL
id|pos_in_item
op_logical_and
id|pos_in_item
op_le
id|entry_count
)paren
(brace
multiline_comment|/* new directory entry falls into S_new[i] */
id|RFALSE
c_func
(paren
op_logical_neg
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12215: insert_size is already 0&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|sbytes
(braket
id|i
)braket
op_minus
l_int|1
op_ge
id|entry_count
comma
l_string|&quot;PAP-12220: there are no so much entries (%d), only %d&quot;
comma
id|sbytes
(braket
id|i
)braket
op_minus
l_int|1
comma
id|entry_count
)paren
suffix:semicolon
multiline_comment|/* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
comma
id|sbytes
(braket
id|i
)braket
op_minus
l_int|1
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Paste given directory entry to directory item */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|S_new
(braket
id|i
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
l_int|0
suffix:semicolon
id|bi.bi_position
op_assign
l_int|0
suffix:semicolon
id|leaf_paste_in_buffer
(paren
op_amp
id|bi
comma
l_int|0
comma
id|pos_in_item
op_minus
id|entry_count
op_plus
id|sbytes
(braket
id|i
)braket
op_minus
l_int|1
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
multiline_comment|/* paste new directory entry */
id|leaf_paste_entries
(paren
id|bi.bi_bh
comma
l_int|0
comma
id|pos_in_item
op_minus
id|entry_count
op_plus
id|sbytes
(braket
id|i
)braket
op_minus
l_int|1
comma
l_int|1
comma
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|body
comma
id|body
op_plus
id|DEH_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pos_in_item
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* new directory entry doesn&squot;t fall into S_new[i] */
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
comma
id|sbytes
(braket
id|i
)braket
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* regular object */
(brace
r_int
id|n_shift
comma
id|n_rem
comma
id|r_zeros_number
suffix:semicolon
r_const
r_char
op_star
id|r_body
suffix:semicolon
id|RFALSE
c_func
(paren
id|pos_in_item
op_ne
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
)paren
op_logical_or
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_le
l_int|0
comma
l_string|&quot;PAP-12225: item too short or insert_size &lt;= 0&quot;
)paren
suffix:semicolon
multiline_comment|/* Calculate number of bytes which must be shifted from appended item */
id|n_shift
op_assign
id|sbytes
(braket
id|i
)braket
op_minus
id|tb-&gt;insert_size
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n_shift
OL
l_int|0
)paren
id|n_shift
op_assign
l_int|0
suffix:semicolon
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
comma
id|n_shift
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Calculate number of bytes which must remain in body after append to S_new[i] */
id|n_rem
op_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_minus
id|sbytes
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|n_rem
OL
l_int|0
)paren
id|n_rem
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Append part of body into S_new[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|S_new
(braket
id|i
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
l_int|0
suffix:semicolon
id|bi.bi_position
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n_rem
OG
id|zeros_num
)paren
(brace
id|r_zeros_number
op_assign
l_int|0
suffix:semicolon
id|r_body
op_assign
id|body
op_plus
id|n_rem
op_minus
id|zeros_num
suffix:semicolon
)brace
r_else
(brace
id|r_body
op_assign
id|body
suffix:semicolon
id|r_zeros_number
op_assign
id|zeros_num
op_minus
id|n_rem
suffix:semicolon
id|zeros_num
op_sub_assign
id|r_zeros_number
suffix:semicolon
)brace
id|leaf_paste_in_buffer
c_func
(paren
op_amp
id|bi
comma
l_int|0
comma
id|n_shift
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_minus
id|n_rem
comma
id|r_body
comma
id|r_zeros_number
)paren
suffix:semicolon
(brace
r_struct
id|item_head
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|S_new
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|n_rem
)paren
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12230: balance_leaf: invalid action with indirect item&quot;
)paren
suffix:semicolon
id|set_ih_free_space
(paren
id|tmp
comma
(paren
(paren
r_struct
id|unfm_nodeinfo
op_star
)paren
id|body
)paren
op_member_access_from_pointer
id|unfm_freespace
)paren
suffix:semicolon
)brace
id|set_le_ih_k_offset
c_func
(paren
id|tmp
comma
id|le_ih_k_offset
c_func
(paren
id|tmp
)paren
op_plus
id|n_rem
)paren
suffix:semicolon
)brace
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
id|n_rem
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_rem
)paren
id|pos_in_item
op_increment
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* item falls wholly into S_new[i] */
(brace
r_int
id|ret_val
suffix:semicolon
r_struct
id|item_head
op_star
id|pasted
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_struct
id|item_head
op_star
id|ih
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|tbS0
comma
id|item_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_direntry_le_ih
c_func
(paren
id|ih
)paren
op_logical_and
(paren
id|pos_in_item
op_ne
id|ih_item_len
c_func
(paren
id|ih
)paren
op_logical_or
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_le
l_int|0
)paren
)paren
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_REISERFS_CHECK */
id|ret_val
op_assign
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
comma
id|sbytes
(braket
id|i
)braket
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|ret_val
comma
l_string|&quot;PAP-12240: unexpected value returned by leaf_move_items (%d)&quot;
comma
id|ret_val
)paren
suffix:semicolon
multiline_comment|/* paste into item */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|S_new
(braket
id|i
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
l_int|0
suffix:semicolon
id|bi.bi_position
op_assign
l_int|0
suffix:semicolon
id|leaf_paste_in_buffer
c_func
(paren
op_amp
id|bi
comma
id|item_pos
op_minus
id|n
op_plus
id|snum
(braket
id|i
)braket
comma
id|pos_in_item
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
id|pasted
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|S_new
(braket
id|i
)braket
comma
id|item_pos
op_minus
id|n
op_plus
id|snum
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|pasted
)paren
)paren
(brace
id|leaf_paste_entries
(paren
id|bi.bi_bh
comma
id|item_pos
op_minus
id|n
op_plus
id|snum
(braket
id|i
)braket
comma
id|pos_in_item
comma
l_int|1
comma
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|body
comma
id|body
op_plus
id|DEH_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* if we paste to indirect item update ih_free_space */
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|pasted
)paren
)paren
id|set_ih_free_space
(paren
id|pasted
comma
(paren
(paren
r_struct
id|unfm_nodeinfo
op_star
)paren
id|body
)paren
op_member_access_from_pointer
id|unfm_freespace
)paren
suffix:semicolon
id|zeros_num
op_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* pasted item doesn&squot;t fall into S_new[i] */
(brace
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_SNEW
comma
id|tb
comma
id|snum
(braket
id|i
)braket
comma
id|sbytes
(braket
id|i
)braket
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* cases d and t */
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12245: balance_leaf: blknum &gt; 2: unexpectable mode: %s(%d)&quot;
comma
(paren
id|flag
op_eq
id|M_DELETE
)paren
ques
c_cond
l_string|&quot;DELETE&quot;
suffix:colon
(paren
(paren
id|flag
op_eq
id|M_CUT
)paren
ques
c_cond
l_string|&quot;CUT&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
comma
id|flag
)paren
suffix:semicolon
)brace
id|memcpy
(paren
id|insert_key
op_plus
id|i
comma
id|B_N_PKEY
c_func
(paren
id|S_new
(braket
id|i
)braket
comma
l_int|0
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
id|insert_ptr
(braket
id|i
)braket
op_assign
id|S_new
(braket
id|i
)braket
suffix:semicolon
id|RFALSE
c_func
(paren
(paren
id|atomic_read
(paren
op_amp
(paren
id|S_new
(braket
id|i
)braket
op_member_access_from_pointer
id|b_count
)paren
)paren
op_ne
l_int|1
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|S_new
(braket
id|i
)braket
op_member_access_from_pointer
id|b_count
)paren
)paren
op_ne
l_int|2
op_logical_or
op_logical_neg
(paren
id|buffer_journaled
c_func
(paren
id|S_new
(braket
id|i
)braket
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|S_new
(braket
id|i
)braket
)paren
)paren
)paren
comma
l_string|&quot;PAP-12247: S_new[%d] : (%b)&bslash;n&quot;
comma
id|i
comma
id|S_new
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the&n;       affected item which remains in S */
r_if
c_cond
(paren
l_int|0
op_le
id|item_pos
op_logical_and
id|item_pos
OL
id|tb-&gt;s0num
)paren
(brace
multiline_comment|/* if we must insert or append into buffer S[0] */
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|M_INSERT
suffix:colon
multiline_comment|/* insert item into S[0] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tbS0
suffix:semicolon
id|bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
suffix:semicolon
id|leaf_insert_into_buf
(paren
op_amp
id|bi
comma
id|item_pos
comma
id|ih
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
multiline_comment|/* If we insert the first key change the delimiting key */
r_if
c_cond
(paren
id|item_pos
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
)paren
multiline_comment|/* can be 0 in reiserfsck */
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|tbS0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|M_PASTE
suffix:colon
(brace
multiline_comment|/* append item in S[0] */
r_struct
id|item_head
op_star
id|pasted
suffix:semicolon
id|pasted
op_assign
id|B_N_PITEM_HEAD
(paren
id|tbS0
comma
id|item_pos
)paren
suffix:semicolon
multiline_comment|/* when directory, may be new entry already pasted */
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|pasted
)paren
)paren
(brace
r_if
c_cond
(paren
id|pos_in_item
op_ge
l_int|0
op_logical_and
id|pos_in_item
op_le
id|ih_entry_count
c_func
(paren
id|pasted
)paren
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12260: insert_size is 0 already&quot;
)paren
suffix:semicolon
multiline_comment|/* prepare space */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tbS0
suffix:semicolon
id|bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
suffix:semicolon
id|leaf_paste_in_buffer
c_func
(paren
op_amp
id|bi
comma
id|item_pos
comma
id|pos_in_item
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
multiline_comment|/* paste entry */
id|leaf_paste_entries
(paren
id|bi.bi_bh
comma
id|item_pos
comma
id|pos_in_item
comma
l_int|1
comma
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|body
comma
id|body
op_plus
id|DEH_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|item_pos
op_logical_and
op_logical_neg
id|pos_in_item
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|tb-&gt;CFL
(braket
l_int|0
)braket
op_logical_or
op_logical_neg
id|tb-&gt;L
(braket
l_int|0
)braket
comma
l_string|&quot;PAP-12270: CFL[0]/L[0] must be specified&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
)paren
(brace
id|replace_key
c_func
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|tbS0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* regular object */
r_if
c_cond
(paren
id|pos_in_item
op_eq
id|ih_item_len
c_func
(paren
id|pasted
)paren
)paren
(brace
id|RFALSE
c_func
(paren
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_le
l_int|0
comma
l_string|&quot;PAP-12275: insert size must not be %d&quot;
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tbS0
suffix:semicolon
id|bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
suffix:semicolon
id|leaf_paste_in_buffer
(paren
op_amp
id|bi
comma
id|item_pos
comma
id|pos_in_item
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|body
comma
id|zeros_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|pasted
)paren
)paren
(brace
id|RFALSE
c_func
(paren
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_ne
id|UNFM_P_SIZE
comma
l_string|&quot;PAP-12280: insert_size for indirect item must be %d, not %d&quot;
comma
id|UNFM_P_SIZE
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|set_ih_free_space
(paren
id|pasted
comma
(paren
(paren
r_struct
id|unfm_nodeinfo
op_star
)paren
id|body
)paren
op_member_access_from_pointer
id|unfm_freespace
)paren
suffix:semicolon
)brace
id|tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_else
(brace
r_if
c_cond
(paren
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;12285&quot;
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12285: balance_leaf: insert_size must be 0 (%d)&quot;
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_REISERFS_CHECK */
)brace
)brace
multiline_comment|/* case M_PASTE: */
)brace
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|flag
op_eq
id|M_PASTE
op_logical_and
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;12290&quot;
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12290: balance_leaf: insert_size is still not 0 (%d)&quot;
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_REISERFS_CHECK */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Leaf level of the tree is balanced (end of balance_leaf) */
multiline_comment|/* Make empty node */
DECL|function|make_empty_node
r_void
id|make_empty_node
(paren
r_struct
id|buffer_info
op_star
id|bi
)paren
(brace
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
id|RFALSE
c_func
(paren
id|bi-&gt;bi_bh
op_eq
l_int|NULL
comma
l_string|&quot;PAP-12295: pointer to the buffer is NULL&quot;
)paren
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|bi-&gt;bi_bh
)paren
suffix:semicolon
id|set_blkh_nr_item
c_func
(paren
id|blkh
comma
l_int|0
)paren
suffix:semicolon
id|set_blkh_free_space
c_func
(paren
id|blkh
comma
id|MAX_CHILD_SIZE
c_func
(paren
id|bi-&gt;bi_bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bi-&gt;bi_parent
)paren
id|B_N_CHILD
(paren
id|bi-&gt;bi_parent
comma
id|bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Endian safe if 0 */
)brace
multiline_comment|/* Get first empty buffer */
DECL|function|get_FEB
r_struct
id|buffer_head
op_star
id|get_FEB
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|first_b
suffix:semicolon
r_struct
id|buffer_info
id|bi
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_FEB_SIZE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|tb-&gt;FEB
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|MAX_FEB_SIZE
)paren
id|reiserfs_panic
c_func
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-12300: get_FEB: FEB list is empty&quot;
)paren
suffix:semicolon
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|first_b
op_assign
id|tb-&gt;FEB
(braket
id|i
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
l_int|0
suffix:semicolon
id|bi.bi_position
op_assign
l_int|0
suffix:semicolon
id|make_empty_node
(paren
op_amp
id|bi
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|first_b-&gt;b_state
)paren
suffix:semicolon
id|tb-&gt;FEB
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|tb-&gt;used
(braket
id|i
)braket
op_assign
id|first_b
suffix:semicolon
r_return
id|first_b
suffix:semicolon
)brace
multiline_comment|/* This is now used because reiserfs_free_block has to be able to&n;** schedule.&n;*/
DECL|function|store_thrown
r_static
r_void
id|store_thrown
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
(paren
id|bh
)paren
)paren
id|printk
(paren
l_string|&quot;store_thrown deals with dirty buffer&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|tb-&gt;thrown
)paren
op_div
r_sizeof
(paren
id|tb-&gt;thrown
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|tb-&gt;thrown
(braket
id|i
)braket
)paren
(brace
id|tb-&gt;thrown
(braket
id|i
)braket
op_assign
id|bh
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* free_thrown puts this */
r_return
suffix:semicolon
)brace
id|reiserfs_warning
(paren
l_string|&quot;store_thrown: too many thrown buffers&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|free_thrown
r_static
r_void
id|free_thrown
c_func
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|blocknr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|tb-&gt;thrown
)paren
op_div
r_sizeof
(paren
id|tb-&gt;thrown
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;thrown
(braket
id|i
)braket
)paren
(brace
id|blocknr
op_assign
id|tb-&gt;thrown
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
(paren
id|tb-&gt;thrown
(braket
id|i
)braket
)paren
)paren
id|printk
(paren
l_string|&quot;free_thrown deals with dirty buffer %ld&bslash;n&quot;
comma
id|blocknr
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|tb-&gt;thrown
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* incremented in store_thrown */
id|reiserfs_free_block
(paren
id|tb-&gt;transaction_handle
comma
id|blocknr
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|reiserfs_invalidate_buffer
r_void
id|reiserfs_invalidate_buffer
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|bh
)paren
suffix:semicolon
id|set_blkh_level
c_func
(paren
id|blkh
comma
id|FREE_LEVEL
)paren
suffix:semicolon
id|set_blkh_nr_item
c_func
(paren
id|blkh
comma
l_int|0
)paren
suffix:semicolon
id|mark_buffer_clean
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* reiserfs_free_block is no longer schedule safe &n;    reiserfs_free_block (tb-&gt;transaction_handle, tb-&gt;tb_sb, bh-&gt;b_blocknr);&n;    */
id|store_thrown
(paren
id|tb
comma
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* Replace n_dest&squot;th key in buffer dest by n_src&squot;th key of buffer src.*/
DECL|function|replace_key
r_void
id|replace_key
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_struct
id|buffer_head
op_star
id|dest
comma
r_int
id|n_dest
comma
r_struct
id|buffer_head
op_star
id|src
comma
r_int
id|n_src
)paren
(brace
id|RFALSE
c_func
(paren
id|dest
op_eq
l_int|NULL
op_logical_or
id|src
op_eq
l_int|NULL
comma
l_string|&quot;vs-12305: source or destination buffer is 0 (src=%p, dest=%p)&quot;
comma
id|src
comma
id|dest
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|B_IS_KEYS_LEVEL
(paren
id|dest
)paren
comma
l_string|&quot;vs-12310: invalid level (%z) for destination buffer. dest must be leaf&quot;
comma
id|dest
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_dest
OL
l_int|0
op_logical_or
id|n_src
OL
l_int|0
comma
l_string|&quot;vs-12315: src(%d) or dest(%d) key number &lt; 0&quot;
comma
id|n_src
comma
id|n_dest
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_dest
op_ge
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
op_logical_or
id|n_src
op_ge
id|B_NR_ITEMS
c_func
(paren
id|src
)paren
comma
l_string|&quot;vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big&quot;
comma
id|n_src
comma
id|B_NR_ITEMS
c_func
(paren
id|src
)paren
comma
id|n_dest
comma
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|B_IS_ITEMS_LEVEL
(paren
id|src
)paren
)paren
multiline_comment|/* source buffer contains leaf node */
id|memcpy
(paren
id|B_N_PDELIM_KEY
c_func
(paren
id|dest
comma
id|n_dest
)paren
comma
id|B_N_PITEM_HEAD
c_func
(paren
id|src
comma
id|n_src
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
r_else
id|memcpy
(paren
id|B_N_PDELIM_KEY
c_func
(paren
id|dest
comma
id|n_dest
)paren
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|src
comma
id|n_src
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|dest
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|get_left_neighbor_position
r_int
id|get_left_neighbor_position
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_int
id|Sh_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
op_eq
l_int|0
op_logical_or
id|tb-&gt;FL
(braket
id|h
)braket
op_eq
l_int|0
comma
l_string|&quot;vs-12325: FL[%d](%p) or F[%d](%p) does not exist&quot;
comma
id|h
comma
id|tb-&gt;FL
(braket
id|h
)braket
comma
id|h
comma
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sh_position
op_eq
l_int|0
)paren
r_return
id|B_NR_ITEMS
(paren
id|tb-&gt;FL
(braket
id|h
)braket
)paren
suffix:semicolon
r_else
r_return
id|Sh_position
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|get_right_neighbor_position
r_int
id|get_right_neighbor_position
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_int
id|Sh_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
op_eq
l_int|0
op_logical_or
id|tb-&gt;FR
(braket
id|h
)braket
op_eq
l_int|0
comma
l_string|&quot;vs-12330: F[%d](%p) or FR[%d](%p) does not exist&quot;
comma
id|h
comma
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
comma
id|h
comma
id|tb-&gt;FR
(braket
id|h
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Sh_position
op_eq
id|B_NR_ITEMS
(paren
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
id|Sh_position
op_plus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_int
id|is_reusable
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|block
comma
r_int
id|bit_value
)paren
suffix:semicolon
DECL|function|check_internal_node
r_static
r_void
id|check_internal_node
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_char
op_star
id|mes
)paren
(brace
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|bh
comma
l_string|&quot;PAP-12336: bh == 0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
op_logical_or
op_logical_neg
id|B_IS_IN_TREE
(paren
id|bh
)paren
)paren
r_return
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|buffer_dirty
(paren
id|bh
)paren
op_logical_and
op_logical_neg
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
comma
l_string|&quot;PAP-12337: buffer (%b) must be dirty&quot;
comma
id|bh
)paren
suffix:semicolon
id|dc
op_assign
id|B_N_CHILD
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|B_NR_ITEMS
(paren
id|bh
)paren
suffix:semicolon
id|i
op_increment
comma
id|dc
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_reusable
(paren
id|s
comma
id|dc_block_number
c_func
(paren
id|dc
)paren
comma
l_int|1
)paren
)paren
(brace
id|print_cur_tb
(paren
id|mes
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;PAP-12338: check_internal_node: invalid child pointer %y in %b&quot;
comma
id|dc
comma
id|bh
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|locked_or_not_in_tree
r_static
r_int
id|locked_or_not_in_tree
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_char
op_star
id|which
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|B_IS_IN_TREE
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-12339: locked_or_not_in_tree: %s (%b)&bslash;n&quot;
comma
id|which
comma
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_before_balancing
r_static
r_int
id|check_before_balancing
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cur_tb
)paren
(brace
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-12335: check_before_balancing: &quot;
l_string|&quot;suspect that schedule occurred based on cur_tb not being null at this point in code. &quot;
l_string|&quot;do_balance cannot properly handle schedule occuring while it runs.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* double check that buffers that we will modify are unlocked. (fix_nodes should already have&n;     prepped all of these for us). */
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
)paren
(brace
id|retval
op_or_assign
id|locked_or_not_in_tree
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
comma
l_string|&quot;L[0]&quot;
)paren
suffix:semicolon
id|retval
op_or_assign
id|locked_or_not_in_tree
(paren
id|tb-&gt;FL
(braket
l_int|0
)braket
comma
l_string|&quot;FL[0]&quot;
)paren
suffix:semicolon
id|retval
op_or_assign
id|locked_or_not_in_tree
(paren
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
l_string|&quot;CFL[0]&quot;
)paren
suffix:semicolon
id|check_leaf
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
)paren
(brace
id|retval
op_or_assign
id|locked_or_not_in_tree
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_string|&quot;R[0]&quot;
)paren
suffix:semicolon
id|retval
op_or_assign
id|locked_or_not_in_tree
(paren
id|tb-&gt;FR
(braket
l_int|0
)braket
comma
l_string|&quot;FR[0]&quot;
)paren
suffix:semicolon
id|retval
op_or_assign
id|locked_or_not_in_tree
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
l_string|&quot;CFR[0]&quot;
)paren
suffix:semicolon
id|check_leaf
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|retval
op_or_assign
id|locked_or_not_in_tree
(paren
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
comma
l_string|&quot;S[0]&quot;
)paren
suffix:semicolon
id|check_leaf
(paren
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|check_after_balance_leaf
r_void
id|check_after_balance_leaf
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|B_FREE_SPACE
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
op_ne
id|MAX_CHILD_SIZE
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|tb-&gt;FL
(braket
l_int|0
)braket
comma
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
)paren
)paren
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;12221&quot;
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12355: check_after_balance_leaf: shift to left was incorrect&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|B_FREE_SPACE
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
)paren
op_ne
id|MAX_CHILD_SIZE
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|tb-&gt;FR
(braket
l_int|0
)braket
comma
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
)paren
)paren
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;12222&quot;
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12360: check_after_balance_leaf: shift to right was incorrect&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
op_logical_and
(paren
id|B_FREE_SPACE
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
)paren
op_ne
(paren
id|MAX_CHILD_SIZE
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
comma
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
)paren
)paren
)paren
)paren
)paren
(brace
r_int
id|left
op_assign
id|B_FREE_SPACE
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
)paren
suffix:semicolon
r_int
id|right
op_assign
(paren
id|MAX_CHILD_SIZE
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
comma
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
)paren
)paren
)paren
suffix:semicolon
id|print_cur_tb
(paren
l_string|&quot;12223&quot;
)paren
suffix:semicolon
id|reiserfs_warning
c_func
(paren
l_string|&quot;B_FREE_SPACE (PATH_H_PBUFFER(tb-&gt;tb_path,0)) = %d; &quot;
l_string|&quot;MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d&bslash;n&quot;
comma
id|left
comma
id|MAX_CHILD_SIZE
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
)paren
comma
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
comma
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
comma
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
comma
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
)paren
)paren
comma
id|right
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;PAP-12365: check_after_balance_leaf: S is incorrect&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|check_leaf_level
r_void
id|check_leaf_level
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
id|check_leaf
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|check_leaf
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|check_leaf
(paren
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
)paren
suffix:semicolon
)brace
DECL|function|check_internal_levels
r_void
id|check_internal_levels
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_int
id|h
suffix:semicolon
multiline_comment|/* check all internal nodes */
r_for
c_loop
(paren
id|h
op_assign
l_int|1
suffix:semicolon
id|tb-&gt;insert_size
(braket
id|h
)braket
suffix:semicolon
id|h
op_increment
)paren
(brace
id|check_internal_node
(paren
id|tb-&gt;tb_sb
comma
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
comma
l_string|&quot;BAD BUFFER ON PATH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
)paren
id|check_internal_node
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;L
(braket
id|h
)braket
comma
l_string|&quot;BAD L&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
id|check_internal_node
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;R
(braket
id|h
)braket
comma
l_string|&quot;BAD R&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Now we have all of the buffers that must be used in balancing of&n;   the tree.  We rely on the assumption that schedule() will not occur&n;   while do_balance works. ( Only interrupt handlers are acceptable.)&n;   We balance the tree according to the analysis made before this,&n;   using buffers already obtained.  For SMP support it will someday be&n;   necessary to add ordered locking of tb. */
multiline_comment|/* Some interesting rules of balancing:&n;&n;   we delete a maximum of two nodes per level per balancing: we never&n;   delete R, when we delete two of three nodes L, S, R then we move&n;   them into R.&n;&n;   we only delete L if we are deleting two nodes, if we delete only&n;   one node we delete S&n;&n;   if we shift leaves then we shift as much as we can: this is a&n;   deliberate policy of extremism in node packing which results in&n;   higher average utilization after repeated random balance operations&n;   at the cost of more memory copies and more balancing as a result of&n;   small insertions to full nodes.&n;&n;   if we shift internal nodes we try to evenly balance the node&n;   utilization, with consequent less balancing at the cost of lower&n;   utilization.&n;&n;   one could argue that the policy for directories in leaves should be&n;   that of internal nodes, but we will wait until another day to&n;   evaluate this....  It would be nice to someday measure and prove&n;   these assumptions as to what is optimal....&n;&n;*/
DECL|function|do_balance_starts
r_static
r_inline
r_void
id|do_balance_starts
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
multiline_comment|/* use print_cur_tb() to see initial state of struct&n;       tree_balance */
multiline_comment|/* store_print_tb (tb); */
multiline_comment|/* do not delete, just comment it out */
multiline_comment|/*    print_tb(flag, PATH_LAST_POSITION(tb-&gt;tb_path), tb-&gt;tb_path-&gt;pos_in_item, tb, &n;&t;     &quot;check&quot;);*/
id|RFALSE
c_func
(paren
id|check_before_balancing
(paren
id|tb
)paren
comma
l_string|&quot;PAP-12340: locked buffers in TB&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|cur_tb
op_assign
id|tb
suffix:semicolon
macro_line|#endif
)brace
DECL|function|do_balance_completed
r_static
r_inline
r_void
id|do_balance_completed
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|check_leaf_level
(paren
id|tb
)paren
suffix:semicolon
id|check_internal_levels
(paren
id|tb
)paren
suffix:semicolon
id|cur_tb
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
multiline_comment|/* reiserfs_free_block is no longer schedule safe.  So, we need to&n;    ** put the buffers we want freed on the thrown list during do_balance,&n;    ** and then free them now&n;    */
id|tb-&gt;tb_sb-&gt;u.reiserfs_sb.s_do_balance
op_increment
suffix:semicolon
multiline_comment|/* release all nodes hold to perform the balancing */
id|unfix_nodes
c_func
(paren
id|tb
)paren
suffix:semicolon
id|free_thrown
c_func
(paren
id|tb
)paren
suffix:semicolon
)brace
DECL|function|do_balance
r_void
id|do_balance
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
multiline_comment|/* tree_balance structure */
r_struct
id|item_head
op_star
id|ih
comma
multiline_comment|/* item header of inserted item */
r_const
r_char
op_star
id|body
comma
multiline_comment|/* body  of inserted item or bytes to paste */
r_int
id|flag
)paren
multiline_comment|/* i - insert, d - delete&n;&t;&t;&t;       c - cut, p - paste&n;&t;&t;&t;&t;&t;&t;      &n;&t;&t;&t;       Cut means delete part of an item&n;&t;&t;&t;       (includes removing an entry from a&n;&t;&t;&t;       directory).&n;&t;&t;&t;&t;&t;&t;      &n;&t;&t;&t;       Delete means delete whole item.&n;&t;&t;&t;&t;&t;&t;      &n;&t;&t;&t;       Insert means add a new item into the&n;&t;&t;&t;       tree.&n;&t;&t;&t;&t;&t;&t;      &t;&t;&t;&t;&t;&t;      &n;&t;&t;&t;       Paste means to append to the end of an&n;&t;&t;&t;       existing file or to insert a directory&n;&t;&t;&t;       entry.  */
(brace
r_int
id|child_pos
comma
multiline_comment|/* position of a child node in its parent */
id|h
suffix:semicolon
multiline_comment|/* level of the tree being processed */
r_struct
id|item_head
id|insert_key
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* in our processing of one level&n;&t;&t;&t;&t;       we sometimes determine what&n;&t;&t;&t;&t;       must be inserted into the next&n;&t;&t;&t;&t;       higher level.  This insertion&n;&t;&t;&t;&t;       consists of a key or two keys&n;&t;&t;&t;&t;       and their corresponding&n;&t;&t;&t;&t;       pointers */
r_struct
id|buffer_head
op_star
id|insert_ptr
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* inserted node-ptrs for the next&n;&t;&t;&t;&t;&t;  level */
id|tb-&gt;tb_mode
op_assign
id|flag
suffix:semicolon
id|tb-&gt;need_balance_dirty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
c_func
(paren
id|tb
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;clm-6000: do_balance, fs generation has changed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* if we have no real work to do  */
r_if
c_cond
(paren
op_logical_neg
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;PAP-12350: do_balance: insert_size == 0, mode == %c&quot;
comma
id|flag
)paren
suffix:semicolon
id|unfix_nodes
c_func
(paren
id|tb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|atomic_inc
(paren
op_amp
(paren
id|fs_generation
(paren
id|tb-&gt;tb_sb
)paren
)paren
)paren
suffix:semicolon
id|do_balance_starts
(paren
id|tb
)paren
suffix:semicolon
multiline_comment|/* balance leaf returns 0 except if combining L R and S into&n;&t;   one node.  see balance_internal() for explanation of this&n;&t;   line of code.*/
id|child_pos
op_assign
id|PATH_H_B_ITEM_ORDER
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
op_plus
id|balance_leaf
(paren
id|tb
comma
id|ih
comma
id|body
comma
id|flag
comma
id|insert_key
comma
id|insert_ptr
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|check_after_balance_leaf
(paren
id|tb
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Balance internal level of the tree. */
r_for
c_loop
(paren
id|h
op_assign
l_int|1
suffix:semicolon
id|h
OL
id|MAX_HEIGHT
op_logical_and
id|tb-&gt;insert_size
(braket
id|h
)braket
suffix:semicolon
id|h
op_increment
)paren
id|child_pos
op_assign
id|balance_internal
(paren
id|tb
comma
id|h
comma
id|child_pos
comma
id|insert_key
comma
id|insert_ptr
)paren
suffix:semicolon
id|do_balance_completed
(paren
id|tb
)paren
suffix:semicolon
)brace
eof
