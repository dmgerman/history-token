multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#else
macro_line|#include &quot;nokernel.h&quot;
macro_line|#endif
r_extern
r_struct
id|key
id|MIN_KEY
suffix:semicolon
r_static
r_int
id|reiserfs_readdir
(paren
r_struct
id|file
op_star
comma
r_void
op_star
comma
id|filldir_t
)paren
suffix:semicolon
r_int
id|reiserfs_dir_fsync
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
suffix:semicolon
DECL|variable|reiserfs_dir_operations
r_struct
id|file_operations
id|reiserfs_dir_operations
op_assign
(brace
id|read
suffix:colon
id|generic_read_dir
comma
id|readdir
suffix:colon
id|reiserfs_readdir
comma
id|fsync
suffix:colon
id|reiserfs_dir_fsync
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * directories can handle most operations...&n; */
DECL|variable|reiserfs_dir_inode_operations
r_struct
id|inode_operations
id|reiserfs_dir_inode_operations
op_assign
(brace
singleline_comment|//&amp;reiserfs_dir_operations,&t;/* default_file_ops */
id|create
suffix:colon
id|reiserfs_create
comma
id|lookup
suffix:colon
id|reiserfs_lookup
comma
id|link
suffix:colon
id|reiserfs_link
comma
id|unlink
suffix:colon
id|reiserfs_unlink
comma
id|symlink
suffix:colon
id|reiserfs_symlink
comma
id|mkdir
suffix:colon
id|reiserfs_mkdir
comma
id|rmdir
suffix:colon
id|reiserfs_rmdir
comma
id|mknod
suffix:colon
id|reiserfs_mknod
comma
id|rename
suffix:colon
id|reiserfs_rename
comma
)brace
suffix:semicolon
DECL|function|reiserfs_dir_fsync
r_int
id|reiserfs_dir_fsync
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dentry-&gt;d_inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;dir_fsync&quot;
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|th.t_super
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|th.t_super
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|dentry-&gt;d_inode-&gt;i_sb
comma
id|SB_BUFFER_WITH_SB
(paren
id|dentry-&gt;d_inode-&gt;i_sb
)paren
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end_sync
c_func
(paren
op_amp
id|th
comma
id|dentry-&gt;d_inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|store_ih
mdefine_line|#define store_ih(where,what) copy_item_head (where, what)
singleline_comment|//
DECL|function|reiserfs_readdir
r_static
r_int
id|reiserfs_readdir
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|cpu_key
id|pos_key
suffix:semicolon
multiline_comment|/* key of current position in the directory (key of directory entry) */
id|INITIALIZE_PATH
(paren
id|path_to_entry
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|item_num
comma
id|entry_num
suffix:semicolon
r_struct
id|key
op_star
id|rkey
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
r_int
id|search_res
suffix:semicolon
r_char
op_star
id|local_buf
suffix:semicolon
id|loff_t
id|next_pos
suffix:semicolon
r_char
id|small_buf
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* avoid kmalloc if we can */
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;readdir&quot;
)paren
suffix:semicolon
multiline_comment|/* form key for search the next directory entry using f_pos field of&n;       file structure */
id|make_cpu_key
(paren
op_amp
id|pos_key
comma
id|inode
comma
(paren
id|filp-&gt;f_pos
)paren
ques
c_cond
(paren
id|filp-&gt;f_pos
)paren
suffix:colon
id|DOT_OFFSET
comma
id|TYPE_DIRENTRY
comma
l_int|3
)paren
suffix:semicolon
id|next_pos
op_assign
id|cpu_key_k_offset
(paren
op_amp
id|pos_key
)paren
suffix:semicolon
multiline_comment|/*  reiserfs_warning (&quot;reiserfs_readdir 1: f_pos = %Ld&bslash;n&quot;, filp-&gt;f_pos);*/
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|research
suffix:colon
multiline_comment|/* search the directory item, containing entry with specified key */
id|search_res
op_assign
id|search_by_entry_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|pos_key
comma
op_amp
id|path_to_entry
comma
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_res
op_eq
id|IO_ERROR
)paren
(brace
singleline_comment|// FIXME: we could just skip part of directory which could
singleline_comment|// not be read
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|entry_num
op_assign
id|de.de_entry_num
suffix:semicolon
id|bh
op_assign
id|de.de_bh
suffix:semicolon
id|item_num
op_assign
id|de.de_item_num
suffix:semicolon
id|ih
op_assign
id|de.de_ih
suffix:semicolon
id|store_ih
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
multiline_comment|/* we must have found item, that is item of this directory, */
r_if
c_cond
(paren
id|COMP_SHORT_KEYS
(paren
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
op_amp
id|pos_key
)paren
)paren
id|reiserfs_panic
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-9000: reiserfs_readdir: &quot;
l_string|&quot;found item %h does not match to dir we readdir %k&quot;
comma
id|ih
comma
op_amp
id|pos_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item_num
OG
id|B_NR_ITEMS
(paren
id|bh
)paren
op_minus
l_int|1
)paren
id|reiserfs_panic
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-9005: reiserfs_readdir: &quot;
l_string|&quot;item_num == %d, item amount == %d&quot;
comma
id|item_num
comma
id|B_NR_ITEMS
(paren
id|bh
)paren
)paren
suffix:semicolon
multiline_comment|/* and entry must be not more than number of entries in the item */
r_if
c_cond
(paren
id|I_ENTRY_COUNT
(paren
id|ih
)paren
OL
id|entry_num
)paren
id|reiserfs_panic
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-9010: reiserfs_readdir: &quot;
l_string|&quot;entry number is too big %d (%d)&quot;
comma
id|entry_num
comma
id|I_ENTRY_COUNT
(paren
id|ih
)paren
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_REISERFS_CHECK */
r_if
c_cond
(paren
id|search_res
op_eq
id|POSITION_FOUND
op_logical_or
id|entry_num
OL
id|I_ENTRY_COUNT
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* go through all entries in the directory item beginning from the entry, that has been found */
r_struct
id|reiserfs_de_head
op_star
id|deh
op_assign
id|B_I_DEH
(paren
id|bh
comma
id|ih
)paren
op_plus
id|entry_num
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|entry_num
OL
id|I_ENTRY_COUNT
(paren
id|ih
)paren
suffix:semicolon
id|entry_num
op_increment
comma
id|deh
op_increment
)paren
(brace
r_int
id|d_reclen
suffix:semicolon
r_char
op_star
id|d_name
suffix:semicolon
id|off_t
id|d_off
suffix:semicolon
id|ino_t
id|d_ino
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de_visible
(paren
id|deh
)paren
)paren
multiline_comment|/* it is hidden entry */
r_continue
suffix:semicolon
id|d_reclen
op_assign
id|entry_length
(paren
id|bh
comma
id|ih
comma
id|entry_num
)paren
suffix:semicolon
id|d_name
op_assign
id|B_I_DEH_ENTRY_FILE_NAME
(paren
id|bh
comma
id|ih
comma
id|deh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_name
(braket
id|d_reclen
op_minus
l_int|1
)braket
)paren
id|d_reclen
op_assign
id|strlen
(paren
id|d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_reclen
OG
id|REISERFS_MAX_NAME_LEN
c_func
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
)paren
(brace
multiline_comment|/* too big to send back to VFS */
r_continue
suffix:semicolon
)brace
id|d_off
op_assign
id|deh_offset
(paren
id|deh
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
id|d_off
suffix:semicolon
id|d_ino
op_assign
id|deh_objectid
(paren
id|deh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_reclen
op_le
l_int|32
)paren
(brace
id|local_buf
op_assign
id|small_buf
suffix:semicolon
)brace
r_else
(brace
id|local_buf
op_assign
id|kmalloc
c_func
(paren
id|d_reclen
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_buf
)paren
(brace
id|pathrelse
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path_to_entry
)paren
)paren
(brace
id|kfree
c_func
(paren
id|local_buf
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
)brace
singleline_comment|// Note, that we copy name to user space via temporary
singleline_comment|// buffer (local_buf) because filldir will block if
singleline_comment|// user space buffer is swapped out. At that time
singleline_comment|// entry can move to somewhere else
id|memcpy
(paren
id|local_buf
comma
id|d_name
comma
id|d_reclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filldir
(paren
id|dirent
comma
id|d_name
comma
id|d_reclen
comma
id|d_off
comma
id|d_ino
comma
id|DT_UNKNOWN
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|local_buf
op_ne
id|small_buf
)paren
(brace
id|kfree
c_func
(paren
id|local_buf
)paren
suffix:semicolon
)brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|local_buf
op_ne
id|small_buf
)paren
(brace
id|kfree
c_func
(paren
id|local_buf
)paren
suffix:semicolon
)brace
singleline_comment|// next entry should be looked for with such offset
id|next_pos
op_assign
id|deh_offset
(paren
id|deh
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path_to_entry
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-9020: reiserfs_readdir &quot;
l_string|&quot;things are moving under hands. Researching..&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
)brace
multiline_comment|/* for */
)brace
r_if
c_cond
(paren
id|item_num
op_ne
id|B_NR_ITEMS
(paren
id|bh
)paren
op_minus
l_int|1
)paren
singleline_comment|// end of directory has been reached
r_goto
id|end
suffix:semicolon
multiline_comment|/* item we went through is last item of node. Using right&n;&t;   delimiting key check is it directory end */
id|rkey
op_assign
id|get_rkey
(paren
op_amp
id|path_to_entry
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|comp_le_keys
(paren
id|rkey
comma
op_amp
id|MIN_KEY
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
(paren
l_string|&quot;vs-9025: reiserfs_readdir:&quot;
l_string|&quot;get_rkey failed. Researching..&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set pos_key to key, that is the smallest and greater&n;&t;       that key of the last entry in the item */
id|set_cpu_key_k_offset
(paren
op_amp
id|pos_key
comma
id|next_pos
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|COMP_SHORT_KEYS
(paren
id|rkey
comma
op_amp
id|pos_key
)paren
)paren
(brace
singleline_comment|// end of directory has been reached
r_goto
id|end
suffix:semicolon
)brace
multiline_comment|/* directory continues in the right neighboring block */
id|set_cpu_key_k_offset
(paren
op_amp
id|pos_key
comma
id|le_key_k_offset
(paren
id|ITEM_VERSION_1
comma
id|rkey
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* while */
id|end
suffix:colon
singleline_comment|// FIXME: ext2_readdir does not reset f_pos
id|filp-&gt;f_pos
op_assign
id|next_pos
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
