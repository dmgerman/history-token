multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
multiline_comment|/* args for the create parameter of reiserfs_get_block */
DECL|macro|GET_BLOCK_NO_CREATE
mdefine_line|#define GET_BLOCK_NO_CREATE 0 /* don&squot;t create new blocks or convert tails */
DECL|macro|GET_BLOCK_CREATE
mdefine_line|#define GET_BLOCK_CREATE 1    /* add anything you need to find block */
DECL|macro|GET_BLOCK_NO_HOLE
mdefine_line|#define GET_BLOCK_NO_HOLE 2   /* return -ENOENT for file holes */
DECL|macro|GET_BLOCK_READ_DIRECT
mdefine_line|#define GET_BLOCK_READ_DIRECT 4  /* read the tail if indirect item not found */
DECL|macro|GET_BLOCK_NO_ISEM
mdefine_line|#define GET_BLOCK_NO_ISEM     8 /* i_sem is not held, don&squot;t preallocate */
r_static
r_int
id|reiserfs_get_block
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// initially this function was derived from minix or ext2&squot;s analog and
singleline_comment|// evolved as the prototype did
singleline_comment|//
DECL|function|reiserfs_delete_inode
r_void
id|reiserfs_delete_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The = 0 happens when we abort creating a new inode for some reason like lack of space.. */
r_if
c_cond
(paren
id|INODE_PKEY
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
op_ne
l_int|0
)paren
(brace
multiline_comment|/* also handles bad_inode case */
id|down
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;delete_inode&quot;
)paren
suffix:semicolon
id|reiserfs_delete_object
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/* all items of file are deleted, so we can remove &quot;save&quot; link */
id|remove_save_link
(paren
id|inode
comma
l_int|0
multiline_comment|/* not truncate */
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no object items are in the tree */
suffix:semicolon
)brace
id|clear_inode
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* note this must go after the journal_end to prevent deadlock */
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|_make_cpu_key
r_static
r_void
id|_make_cpu_key
(paren
r_struct
id|cpu_key
op_star
id|key
comma
r_int
id|version
comma
id|__u32
id|dirid
comma
id|__u32
id|objectid
comma
id|loff_t
id|offset
comma
r_int
id|type
comma
r_int
id|length
)paren
(brace
id|key-&gt;version
op_assign
id|version
suffix:semicolon
id|key-&gt;on_disk_key.k_dir_id
op_assign
id|dirid
suffix:semicolon
id|key-&gt;on_disk_key.k_objectid
op_assign
id|objectid
suffix:semicolon
id|set_cpu_key_k_offset
(paren
id|key
comma
id|offset
)paren
suffix:semicolon
id|set_cpu_key_k_type
(paren
id|key
comma
id|type
)paren
suffix:semicolon
id|key-&gt;key_length
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* take base of inode_key (it comes from inode always) (dirid, objectid) and version from an inode, set&n;   offset and type of key */
DECL|function|make_cpu_key
r_void
id|make_cpu_key
(paren
r_struct
id|cpu_key
op_star
id|key
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|offset
comma
r_int
id|type
comma
r_int
id|length
)paren
(brace
id|_make_cpu_key
(paren
id|key
comma
id|get_inode_item_key_version
(paren
id|inode
)paren
comma
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
comma
id|offset
comma
id|type
comma
id|length
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// when key is 0, do not set version and short key
singleline_comment|//
DECL|function|make_le_item_head
r_inline
r_void
id|make_le_item_head
(paren
r_struct
id|item_head
op_star
id|ih
comma
r_const
r_struct
id|cpu_key
op_star
id|key
comma
r_int
id|version
comma
id|loff_t
id|offset
comma
r_int
id|type
comma
r_int
id|length
comma
r_int
id|entry_count
multiline_comment|/*or ih_free_space*/
)paren
(brace
r_if
c_cond
(paren
id|key
)paren
(brace
id|ih-&gt;ih_key.k_dir_id
op_assign
id|cpu_to_le32
(paren
id|key-&gt;on_disk_key.k_dir_id
)paren
suffix:semicolon
id|ih-&gt;ih_key.k_objectid
op_assign
id|cpu_to_le32
(paren
id|key-&gt;on_disk_key.k_objectid
)paren
suffix:semicolon
)brace
id|put_ih_version
c_func
(paren
id|ih
comma
id|version
)paren
suffix:semicolon
id|set_le_ih_k_offset
(paren
id|ih
comma
id|offset
)paren
suffix:semicolon
id|set_le_ih_k_type
(paren
id|ih
comma
id|type
)paren
suffix:semicolon
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|length
)paren
suffix:semicolon
multiline_comment|/*    set_ih_free_space (ih, 0);*/
singleline_comment|// for directory items it is entry count, for directs and stat
singleline_comment|// datas - 0xffff, for indirects - 0
id|put_ih_entry_count
c_func
(paren
id|ih
comma
id|entry_count
)paren
suffix:semicolon
)brace
DECL|function|add_to_flushlist
r_static
r_void
id|add_to_flushlist
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|list_head
op_star
id|list
op_assign
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_dirty_buffers
)paren
suffix:semicolon
id|buffer_insert_list
c_func
(paren
id|bh
comma
id|list
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// FIXME: we might cache recently accessed indirect item (or at least
singleline_comment|// first 15 pointers just like ext2 does
singleline_comment|// Ugh.  Not too eager for that....
singleline_comment|//  I cut the code until such time as I see a convincing argument (benchmark).
singleline_comment|// I don&squot;t want a bloated inode struct..., and I don&squot;t like code complexity....
multiline_comment|/* cutting the code is fine, since it really isn&squot;t in use yet and is easy&n;** to add back in.  But, Vladimir has a really good idea here.  Think&n;** about what happens for reading a file.  For each page,&n;** The VFS layer calls reiserfs_readpage, who searches the tree to find&n;** an indirect item.  This indirect item has X number of pointers, where&n;** X is a big number if we&squot;ve done the block allocation right.  But,&n;** we only use one or two of these pointers during each call to readpage,&n;** needlessly researching again later on.&n;**&n;** The size of the cache could be dynamic based on the size of the file.&n;**&n;** I&squot;d also like to see us cache the location the stat data item, since&n;** we are needlessly researching for that frequently.&n;**&n;** --chris&n;*/
multiline_comment|/* If this page has a file tail in it, and&n;** it was read in by get_block_create_0, the page data is valid,&n;** but tail is still sitting in a direct item, and we can&squot;t write to&n;** it.  So, look through this page, and check all the mapped buffers&n;** to make sure they have valid block numbers.  Any that don&squot;t need&n;** to be unmapped, so that block_prepare_write will correctly call&n;** reiserfs_get_block to convert the tail into an unformatted node&n;*/
DECL|function|fix_tail_page_for_writing
r_static
r_inline
r_void
id|fix_tail_page_for_writing
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|next
comma
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|page
op_logical_and
id|page-&gt;buffers
)paren
(brace
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_eq
l_int|0
)paren
(brace
id|reiserfs_unmap_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* we need to allocate a block for new unformatted node.  Try to figure out&n;   what point in bitmap reiserfs_new_blocknrs should start from. */
DECL|function|find_tag
r_static
id|b_blocknr_t
id|find_tag
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|item_head
op_star
id|ih
comma
id|__u32
op_star
id|item
comma
r_int
id|pos_in_item
)paren
(brace
id|__u32
id|block
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_indirect_le_ih
(paren
id|ih
)paren
)paren
multiline_comment|/* something more complicated could be here */
r_return
id|bh-&gt;b_blocknr
suffix:semicolon
multiline_comment|/* for indirect item: go to left and look for the first non-hole entry in&n;&t;  the indirect item */
r_if
c_cond
(paren
id|pos_in_item
op_eq
id|I_UNFM_NUM
(paren
id|ih
)paren
)paren
id|pos_in_item
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|pos_in_item
op_ge
l_int|0
)paren
(brace
id|block
op_assign
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
)paren
r_return
id|block
suffix:semicolon
id|pos_in_item
op_decrement
suffix:semicolon
)brace
r_return
id|bh-&gt;b_blocknr
suffix:semicolon
)brace
multiline_comment|/* reiserfs_get_block does not need to allocate a block only if it has been&n;   done already or non-hole position has been found in the indirect item */
DECL|function|allocation_needed
r_static
r_inline
r_int
id|allocation_needed
(paren
r_int
id|retval
comma
id|b_blocknr_t
id|allocated
comma
r_struct
id|item_head
op_star
id|ih
comma
id|__u32
op_star
id|item
comma
r_int
id|pos_in_item
)paren
(brace
r_if
c_cond
(paren
id|allocated
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|POSITION_FOUND
op_logical_and
id|is_indirect_le_ih
(paren
id|ih
)paren
op_logical_and
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|indirect_item_found
r_static
r_inline
r_int
id|indirect_item_found
(paren
r_int
id|retval
comma
r_struct
id|item_head
op_star
id|ih
)paren
(brace
r_return
(paren
id|retval
op_eq
id|POSITION_FOUND
)paren
op_logical_and
id|is_indirect_le_ih
(paren
id|ih
)paren
suffix:semicolon
)brace
DECL|function|set_block_dev_mapped
r_static
r_inline
r_void
id|set_block_dev_mapped
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
id|b_blocknr_t
id|block
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|map_bh
c_func
(paren
id|bh
comma
id|inode-&gt;i_sb
comma
id|block
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// files which were created in the earlier version can not be longer,
singleline_comment|// than 2 gb
singleline_comment|//
DECL|function|file_capable
r_static
r_int
id|file_capable
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
)paren
(brace
r_if
c_cond
(paren
id|get_inode_item_key_version
(paren
id|inode
)paren
op_ne
id|KEY_FORMAT_3_5
op_logical_or
singleline_comment|// it is new file.
id|block
OL
(paren
l_int|1
op_lshift
(paren
l_int|31
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
)paren
)paren
singleline_comment|// old file, but &squot;block&squot; is inside of 2gb
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restart_transaction
multiline_comment|/*static*/
r_void
id|restart_transaction
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
r_int
id|len
op_assign
id|th-&gt;t_blocks_allocated
suffix:semicolon
id|pathrelse
c_func
(paren
id|path
)paren
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
id|journal_end
c_func
(paren
id|th
comma
id|s
comma
id|len
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
id|th
comma
id|s
comma
id|len
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
singleline_comment|// it is called by get_block when create == 0. Returns block number
singleline_comment|// for &squot;block&squot;-th logical block of file. When it hits direct item it
singleline_comment|// returns 0 (being called from bmap) or read direct item into piece
singleline_comment|// of page (bh_result)
singleline_comment|// Please improve the english/clarity in the comment above, as it is
singleline_comment|// hard to understand.
DECL|function|_get_block_create_0
r_static
r_int
id|_get_block_create_0
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|args
)paren
(brace
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_int
id|blocknr
suffix:semicolon
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
id|chars
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
singleline_comment|// prepare the key to look for the &squot;block&squot;-th block of file
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
(paren
id|loff_t
)paren
id|block
op_star
id|inode-&gt;i_sb-&gt;s_blocksize
op_plus
l_int|1
comma
id|TYPE_ANY
comma
l_int|3
)paren
suffix:semicolon
id|research
suffix:colon
r_if
c_cond
(paren
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
op_ne
id|POSITION_FOUND
)paren
(brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
singleline_comment|// We do not return -ENOENT if there is a hole but page is uptodate, because it means
singleline_comment|// That there is some MMAPED data associated with it that is yet to be written to disk.
r_if
c_cond
(paren
(paren
id|args
op_amp
id|GET_BLOCK_NO_HOLE
)paren
op_logical_and
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|bh_result-&gt;b_page
)paren
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|ih
)paren
)paren
(brace
id|__u32
op_star
id|ind_item
op_assign
(paren
id|__u32
op_star
)paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* FIXME: here we could cache indirect item or part of it in&n;&t;   the inode to avoid search_by_key in case of subsequent&n;&t;   access to file */
id|blocknr
op_assign
id|get_block_num
c_func
(paren
id|ind_item
comma
id|path.pos_in_item
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blocknr
)paren
(brace
id|map_bh
c_func
(paren
id|bh_result
comma
id|inode-&gt;i_sb
comma
id|blocknr
)paren
suffix:semicolon
)brace
r_else
singleline_comment|// We do not return -ENOENT if there is a hole but page is uptodate, because it means
singleline_comment|// That there is some MMAPED data associated with it that is yet to  be written to disk.
r_if
c_cond
(paren
(paren
id|args
op_amp
id|GET_BLOCK_NO_HOLE
)paren
op_logical_and
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|bh_result-&gt;b_page
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
singleline_comment|// requested data are in direct item(s)
r_if
c_cond
(paren
op_logical_neg
(paren
id|args
op_amp
id|GET_BLOCK_READ_DIRECT
)paren
)paren
(brace
singleline_comment|// we are called by bmap. FIXME: we can not map block of file
singleline_comment|// when it is stored in direct item(s)
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/* if we&squot;ve got a direct item, and the buffer was uptodate,&n;    ** we don&squot;t want to pull data off disk again.  skip to the&n;    ** end, where we map the buffer and return&n;    */
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh_result
)paren
)paren
(brace
r_goto
id|finished
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;** grab_tail_page can trigger calls to reiserfs_get_block on up to date&n;&t;** pages without any buffers.  If the page is up to date, we don&squot;t want&n;&t;** read old data off disk.  Set the up to date bit on the buffer instead&n;&t;** and jump to the end&n;&t;*/
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|bh_result-&gt;b_page
)paren
)paren
(brace
id|mark_buffer_uptodate
c_func
(paren
id|bh_result
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
singleline_comment|// read file tail into part of page
id|offset
op_assign
(paren
id|cpu_key_k_offset
c_func
(paren
op_amp
id|key
)paren
op_minus
l_int|1
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|copy_item_head
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* we only want to kmap if we are reading the tail into the page.&n;    ** this is not the common case, so we don&squot;t kmap until we are&n;    ** sure we need to.  But, this means the item might move if&n;    ** kmap schedules&n;    */
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
r_goto
id|research
suffix:semicolon
)brace
)brace
id|p
op_add_assign
id|offset
suffix:semicolon
id|memset
(paren
id|p
comma
l_int|0
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_direct_le_ih
(paren
id|ih
)paren
)paren
(brace
id|BUG
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* make sure we don&squot;t read more bytes than actually exist in&n;&t;** the file.  This can happen in odd cases where i_size isn&squot;t&n;&t;** correct, and when direct item padding results in a few &n;&t;** extra bytes at the end of the direct item&n;&t;*/
r_if
c_cond
(paren
(paren
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_plus
id|path.pos_in_item
)paren
OG
id|inode-&gt;i_size
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_minus
l_int|1
op_plus
id|ih_item_len
c_func
(paren
id|ih
)paren
)paren
OG
id|inode-&gt;i_size
)paren
(brace
id|chars
op_assign
id|inode-&gt;i_size
op_minus
(paren
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_minus
l_int|1
)paren
op_minus
id|path.pos_in_item
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|chars
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
op_minus
id|path.pos_in_item
suffix:semicolon
)brace
id|memcpy
(paren
id|p
comma
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
op_plus
id|path.pos_in_item
comma
id|chars
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
r_break
suffix:semicolon
id|p
op_add_assign
id|chars
suffix:semicolon
r_if
c_cond
(paren
id|PATH_LAST_POSITION
(paren
op_amp
id|path
)paren
op_ne
(paren
id|B_NR_ITEMS
(paren
id|bh
)paren
op_minus
l_int|1
)paren
)paren
singleline_comment|// we done, if read direct item is not the last item of
singleline_comment|// node FIXME: we could try to check right delimiting key
singleline_comment|// to see whether direct item continues in the right
singleline_comment|// neighbor or rely on i_size
r_break
suffix:semicolon
singleline_comment|// update key to look for the next piece
id|set_cpu_key_k_offset
(paren
op_amp
id|key
comma
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
op_plus
id|chars
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
op_ne
id|POSITION_FOUND
)paren
singleline_comment|// we read something from tail, even if now we got IO_ERROR
r_break
suffix:semicolon
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|finished
suffix:colon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
multiline_comment|/* I _really_ doubt that you want it.  Chris? */
id|map_bh
c_func
(paren
id|bh_result
comma
id|inode-&gt;i_sb
comma
l_int|0
)paren
suffix:semicolon
id|mark_buffer_uptodate
(paren
id|bh_result
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// this is called to create file map. So, _get_block_create_0 will not
singleline_comment|// read direct item
DECL|function|reiserfs_bmap
r_int
id|reiserfs_bmap
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|file_capable
(paren
id|inode
comma
id|block
)paren
)paren
r_return
op_minus
id|EFBIG
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* do not read the direct item */
id|_get_block_create_0
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
l_int|0
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* special version of get_block that is only used by grab_tail_page right&n;** now.  It is sent to block_prepare_write, and when you try to get a&n;** block past the end of the file (or a block from a hole) it returns&n;** -ENOENT instead of a valid buffer.  block_prepare_write expects to&n;** be able to do i/o on the buffers returned, unless an error value&n;** is also returned.&n;** &n;** So, this allows block_prepare_write to be used for reading a single block&n;** in a page.  Where it does not produce a valid page for holes, or past the&n;** end of the file.  This turns out to be exactly what we need for reading&n;** tails for conversion.&n;**&n;** The point of the wrapper is forcing a certain value for create, even&n;** though the VFS layer is calling this function with create==1.  If you &n;** don&squot;t want to send create == GET_BLOCK_NO_HOLE to reiserfs_get_block, &n;** don&squot;t use this function.&n;*/
DECL|function|reiserfs_get_block_create_0
r_static
r_int
id|reiserfs_get_block_create_0
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_return
id|reiserfs_get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
id|GET_BLOCK_NO_HOLE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** helper function for when reiserfs_get_block is called for a hole&n;** but the file tail is still in a direct item&n;** bh_result is the buffer head for the hole&n;** tail_offset is the offset of the start of the tail in the file&n;**&n;** This calls prepare_write, which will start a new transaction&n;** you should not be in a transaction, or have any paths held when you&n;** call this.&n;*/
DECL|function|convert_tail_for_hole
r_static
r_int
id|convert_tail_for_hole
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
id|loff_t
id|tail_offset
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
r_int
r_int
id|tail_end
suffix:semicolon
r_int
r_int
id|tail_start
suffix:semicolon
r_struct
id|page
op_star
id|tail_page
suffix:semicolon
r_struct
id|page
op_star
id|hole_page
op_assign
id|bh_result-&gt;b_page
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tail_offset
op_amp
(paren
id|bh_result-&gt;b_size
op_minus
l_int|1
)paren
)paren
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* always try to read until the end of the block */
id|tail_start
op_assign
id|tail_offset
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tail_end
op_assign
(paren
id|tail_start
op_or
(paren
id|bh_result-&gt;b_size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|index
op_assign
id|tail_offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ne
id|hole_page-&gt;index
)paren
(brace
id|tail_page
op_assign
id|grab_cache_page
c_func
(paren
id|inode-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tail_page
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|tail_page
op_assign
id|hole_page
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t have to make sure the conversion did not happen while&n;    ** we were locking the page because anyone that could convert&n;    ** must first take i_sem.&n;    **&n;    ** We must fix the tail page for writing because it might have buffers&n;    ** that are mapped, but have a block number of 0.  This indicates tail&n;    ** data that has been read directly into the page, and block_prepare_write&n;    ** won&squot;t trigger a get_block in this case.&n;    */
id|fix_tail_page_for_writing
c_func
(paren
id|tail_page
)paren
suffix:semicolon
id|retval
op_assign
id|block_prepare_write
c_func
(paren
id|tail_page
comma
id|tail_start
comma
id|tail_end
comma
id|reiserfs_get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|unlock
suffix:semicolon
multiline_comment|/* tail conversion might change the data in the page */
id|flush_dcache_page
c_func
(paren
id|tail_page
)paren
suffix:semicolon
id|retval
op_assign
id|generic_commit_write
c_func
(paren
l_int|NULL
comma
id|tail_page
comma
id|tail_start
comma
id|tail_end
)paren
suffix:semicolon
id|unlock
suffix:colon
r_if
c_cond
(paren
id|tail_page
op_ne
id|hole_page
)paren
(brace
id|UnlockPage
c_func
(paren
id|tail_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|tail_page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|_allocate_block
r_static
r_inline
r_int
id|_allocate_block
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
id|b_blocknr_t
op_star
id|allocated_block_nr
comma
r_int
r_int
id|tag
comma
r_int
id|flags
)paren
(brace
macro_line|#ifdef REISERFS_PREALLOCATE
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|GET_BLOCK_NO_ISEM
)paren
)paren
(brace
r_return
id|reiserfs_new_unf_blocknrs2
c_func
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
id|tag
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|reiserfs_new_unf_blocknrs
(paren
id|th
comma
id|allocated_block_nr
comma
id|tag
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// initially this function was derived from ext2&squot;s analog and evolved
singleline_comment|// as the prototype did.  You&squot;ll need to look at the ext2 version to
singleline_comment|// determine which parts are derivative, if any, understanding that
singleline_comment|// there are only so many ways to code to a given interface.
singleline_comment|//
DECL|function|reiserfs_get_block
r_int
id|reiserfs_get_block
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_int
id|repeat
comma
id|retval
suffix:semicolon
r_int
r_int
id|tag
suffix:semicolon
id|b_blocknr_t
id|allocated_block_nr
op_assign
l_int|0
suffix:semicolon
singleline_comment|// b_blocknr_t is unsigned long
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|pos_in_item
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|unbh
op_assign
l_int|0
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
id|__u32
op_star
id|item
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
multiline_comment|/* space reserved in transaction batch: &n;        . 3 balancings in direct-&gt;indirect conversion&n;        . 1 block involved into reiserfs_update_sd()&n;       XXX in practically impossible worst case direct2indirect()&n;       can incur (much) more that 3 balancings. */
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
op_plus
l_int|1
suffix:semicolon
r_int
id|version
suffix:semicolon
r_int
id|transaction_started
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|new_offset
op_assign
(paren
(paren
(paren
id|loff_t
)paren
id|block
)paren
op_lshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* bad.... */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|th.t_trans_id
op_assign
l_int|0
suffix:semicolon
id|version
op_assign
id|get_inode_item_key_version
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
OL
l_int|0
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|file_capable
(paren
id|inode
comma
id|block
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
multiline_comment|/* if !create, we aren&squot;t changing the FS, so we don&squot;t need to&n;    ** log anything, so we don&squot;t need to start a transaction&n;    */
r_if
c_cond
(paren
op_logical_neg
(paren
id|create
op_amp
id|GET_BLOCK_CREATE
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* find number of block-th logical block of the file */
id|ret
op_assign
id|_get_block_create_0
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
id|create
op_or
id|GET_BLOCK_READ_DIRECT
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_pack_on_close_mask
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_get_block&quot;
)paren
suffix:semicolon
multiline_comment|/* set the key of the first byte in the &squot;block&squot;-th block of file */
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
id|new_offset
comma
id|TYPE_ANY
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_offset
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
OG
id|inode-&gt;i_size
)paren
(brace
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|transaction_started
op_assign
l_int|1
suffix:semicolon
)brace
id|research
suffix:colon
id|retval
op_assign
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|path.pos_in_item
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|copy_item_head
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allocation_needed
(paren
id|retval
comma
id|allocated_block_nr
comma
id|ih
comma
id|item
comma
id|pos_in_item
)paren
)paren
(brace
multiline_comment|/* we have to allocate block for the unformatted node */
id|tag
op_assign
id|find_tag
(paren
id|bh
comma
id|ih
comma
id|item
comma
id|pos_in_item
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction_started
)paren
(brace
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|transaction_started
op_assign
l_int|1
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
id|repeat
op_assign
id|_allocate_block
c_func
(paren
op_amp
id|th
comma
id|inode
comma
op_amp
id|allocated_block_nr
comma
id|tag
comma
id|create
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repeat
op_eq
id|NO_DISK_SPACE
)paren
(brace
multiline_comment|/* restart the transaction to give the journal a chance to free&n;&t;    ** some blocks.  releases the path, so we have to go back to&n;&t;    ** research if we succeed on the second try&n;&t;    */
id|restart_transaction
c_func
(paren
op_amp
id|th
comma
id|inode
comma
op_amp
id|path
)paren
suffix:semicolon
id|repeat
op_assign
id|_allocate_block
c_func
(paren
op_amp
id|th
comma
id|inode
comma
op_amp
id|allocated_block_nr
comma
id|tag
comma
id|create
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repeat
op_ne
id|NO_DISK_SPACE
)paren
(brace
r_goto
id|research
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
r_goto
id|research
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|indirect_item_found
(paren
id|retval
comma
id|ih
)paren
)paren
(brace
id|b_blocknr_t
id|unfm_ptr
suffix:semicolon
multiline_comment|/* &squot;block&squot;-th block is in the file already (there is&n;&t;   corresponding cell in some indirect item). But it may be&n;&t;   zero unformatted node pointer (hole) */
id|unfm_ptr
op_assign
id|get_block_num
(paren
id|item
comma
id|pos_in_item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unfm_ptr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* use allocated block to plug the hole */
id|reiserfs_prepare_for_journal
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
id|bh_result-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_New
)paren
suffix:semicolon
id|put_block_num
c_func
(paren
id|item
comma
id|pos_in_item
comma
id|allocated_block_nr
)paren
suffix:semicolon
id|unfm_ptr
op_assign
id|allocated_block_nr
suffix:semicolon
id|journal_mark_dirty
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_add_assign
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_div
l_int|512
)paren
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
)brace
id|set_block_dev_mapped
c_func
(paren
id|bh_result
comma
id|unfm_ptr
comma
id|inode
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transaction_started
)paren
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* the item was found, so new blocks were not added to the file&n;&t;** there is no need to make sure the inode is updated with this &n;&t;** transaction&n;&t;*/
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|transaction_started
)paren
(brace
multiline_comment|/* if we don&squot;t pathrelse, we could vs-3050 on the buffer if&n;&t;** someone is waiting for it (they can&squot;t finish until the buffer&n;&t;** is released, we can start a new transaction until they finish)&n;&t;*/
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|transaction_started
op_assign
l_int|1
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
multiline_comment|/* desired position is not found or is in the direct item. We have&n;       to append file with holes up to &squot;block&squot;-th block converting&n;       direct items to indirect one if necessary */
id|done
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|is_statdata_le_ih
(paren
id|ih
)paren
)paren
(brace
id|__u32
id|unp
op_assign
l_int|0
suffix:semicolon
r_struct
id|cpu_key
id|tmp_key
suffix:semicolon
multiline_comment|/* indirect item has to be inserted */
id|make_le_item_head
(paren
op_amp
id|tmp_ih
comma
op_amp
id|key
comma
id|version
comma
l_int|1
comma
id|TYPE_INDIRECT
comma
id|UNFM_P_SIZE
comma
l_int|0
multiline_comment|/* free_space */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* we are going to add &squot;block&squot;-th block to the file. Use&n;&t;&t;   allocated block for that */
id|unp
op_assign
id|cpu_to_le32
(paren
id|allocated_block_nr
)paren
suffix:semicolon
id|set_block_dev_mapped
(paren
id|bh_result
comma
id|allocated_block_nr
comma
id|inode
)paren
suffix:semicolon
id|bh_result-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_New
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|tmp_key
op_assign
id|key
suffix:semicolon
singleline_comment|// ;)
id|set_cpu_key_k_offset
(paren
op_amp
id|tmp_key
comma
l_int|1
)paren
suffix:semicolon
id|PATH_LAST_POSITION
c_func
(paren
op_amp
id|path
)paren
op_increment
suffix:semicolon
id|retval
op_assign
id|reiserfs_insert_item
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
id|tmp_key
comma
op_amp
id|tmp_ih
comma
(paren
r_char
op_star
)paren
op_amp
id|unp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|reiserfs_free_block
(paren
op_amp
id|th
comma
id|allocated_block_nr
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
singleline_comment|// retval == -ENOSPC or -EIO or -EEXIST
)brace
r_if
c_cond
(paren
id|unp
)paren
id|inode-&gt;i_blocks
op_add_assign
id|inode-&gt;i_sb-&gt;s_blocksize
op_div
l_int|512
suffix:semicolon
singleline_comment|//mark_tail_converted (inode);
)brace
r_else
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* direct item has to be converted */
id|loff_t
id|tail_offset
suffix:semicolon
id|tail_offset
op_assign
(paren
(paren
id|le_ih_k_offset
(paren
id|ih
)paren
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tail_offset
op_eq
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
)paren
(brace
multiline_comment|/* direct item we just found fits into block we have&n;                   to map. Convert it into unformatted node: use&n;                   bh_result for the conversion */
id|set_block_dev_mapped
(paren
id|bh_result
comma
id|allocated_block_nr
comma
id|inode
)paren
suffix:semicolon
id|unbh
op_assign
id|bh_result
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we have to padd file tail stored in direct item(s)&n;&t;&t;   up to block size and convert it to unformatted&n;&t;&t;   node. FIXME: this should also get into page cache */
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|transaction_started
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|convert_tail_for_hole
c_func
(paren
id|inode
comma
id|bh_result
comma
id|tail_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENOSPC
)paren
id|printk
c_func
(paren
l_string|&quot;clm-6004: convert tail failed inode %lu, error %d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allocated_block_nr
)paren
id|reiserfs_free_block
(paren
op_amp
id|th
comma
id|allocated_block_nr
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_goto
id|research
suffix:semicolon
)brace
id|retval
op_assign
id|direct2indirect
(paren
op_amp
id|th
comma
id|inode
comma
op_amp
id|path
comma
id|unbh
comma
id|tail_offset
)paren
suffix:semicolon
multiline_comment|/* it is important the mark_buffer_uptodate is done after&n;&t;    ** the direct2indirect.  The buffer might contain valid&n;&t;    ** data newer than the data on disk (read by readpage, changed,&n;&t;    ** and then sent here by writepage).  direct2indirect needs&n;&t;    ** to know if unbh was already up to date, so it can decide&n;&t;    ** if the data in unbh needs to be replaced with data from&n;&t;    ** the disk&n;&t;    */
id|mark_buffer_uptodate
(paren
id|unbh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|reiserfs_free_block
(paren
op_amp
id|th
comma
id|allocated_block_nr
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve converted the tail, so we must &n;&t;    ** flush unbh before the transaction commits&n;&t;    */
id|add_to_flushlist
c_func
(paren
id|inode
comma
id|unbh
)paren
suffix:semicolon
multiline_comment|/* mark it dirty now to prevent commit_write from adding&n;&t;    ** this buffer to the inode&squot;s dirty buffer list&n;&t;    */
id|__mark_buffer_dirty
c_func
(paren
id|unbh
)paren
suffix:semicolon
singleline_comment|//inode-&gt;i_blocks += inode-&gt;i_sb-&gt;s_blocksize / 512;
singleline_comment|//mark_tail_converted (inode);
)brace
r_else
(brace
multiline_comment|/* append indirect item with holes if needed, when appending&n;&t;       pointer to &squot;block&squot;-th block use block, which is already&n;&t;       allocated */
r_struct
id|cpu_key
id|tmp_key
suffix:semicolon
r_struct
id|unfm_nodeinfo
id|un
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|RFALSE
c_func
(paren
id|pos_in_item
op_ne
id|ih_item_len
c_func
(paren
id|ih
)paren
op_div
id|UNFM_P_SIZE
comma
l_string|&quot;vs-804: invalid position for append&quot;
)paren
suffix:semicolon
multiline_comment|/* indirect item has to be appended, set up key of that position */
id|make_cpu_key
(paren
op_amp
id|tmp_key
comma
id|inode
comma
id|le_key_k_offset
(paren
id|version
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
op_plus
id|op_bytes_number
(paren
id|ih
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
comma
singleline_comment|//pos_in_item * inode-&gt;i_sb-&gt;s_blocksize,
id|TYPE_INDIRECT
comma
l_int|3
)paren
suffix:semicolon
singleline_comment|// key type is unimportant
r_if
c_cond
(paren
id|cpu_key_k_offset
(paren
op_amp
id|tmp_key
)paren
op_eq
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
)paren
(brace
multiline_comment|/* we are going to add target block to the file. Use allocated&n;&t;&t;   block for that */
id|un.unfm_nodenum
op_assign
id|cpu_to_le32
(paren
id|allocated_block_nr
)paren
suffix:semicolon
id|set_block_dev_mapped
(paren
id|bh_result
comma
id|allocated_block_nr
comma
id|inode
)paren
suffix:semicolon
id|bh_result-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_New
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* paste hole to the indirect item */
)brace
id|retval
op_assign
id|reiserfs_paste_into_item
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
id|tmp_key
comma
(paren
r_char
op_star
)paren
op_amp
id|un
comma
id|UNFM_P_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|reiserfs_free_block
(paren
op_amp
id|th
comma
id|allocated_block_nr
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|un.unfm_nodenum
)paren
id|inode-&gt;i_blocks
op_add_assign
id|inode-&gt;i_sb-&gt;s_blocksize
op_div
l_int|512
suffix:semicolon
singleline_comment|//mark_tail_converted (inode);
)brace
r_if
c_cond
(paren
id|done
op_eq
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* this loop could log more blocks than we had originally asked&n;&t;** for.  So, we have to allow the transaction to end if it is&n;&t;** too big or too full.  Update the inode so things are &n;&t;** consistent if we crash before the function returns&n;&t;**&n;&t;** release the path so that anybody waiting on the path before&n;&t;** ending their transaction will be able to continue.&n;&t;*/
r_if
c_cond
(paren
id|journal_transaction_should_end
c_func
(paren
op_amp
id|th
comma
id|th.t_blocks_allocated
)paren
)paren
(brace
id|restart_transaction
c_func
(paren
op_amp
id|th
comma
id|inode
comma
op_amp
id|path
)paren
suffix:semicolon
)brace
multiline_comment|/* inserting indirect pointers for a hole can take a &n;&t;** long time.  reschedule if needed&n;&t;*/
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|POSITION_FOUND
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-825: reiserfs_get_block: &quot;
l_string|&quot;%K should not be found&bslash;n&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|allocated_block_nr
)paren
id|reiserfs_free_block
(paren
op_amp
id|th
comma
id|allocated_block_nr
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|path.pos_in_item
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|failure
suffix:colon
r_if
c_cond
(paren
id|transaction_started
)paren
(brace
id|reiserfs_update_sd
c_func
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
)brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// BAD: new directories have stat data of new type and all other items
singleline_comment|// of old type. Version stored in the inode says about body items, so
singleline_comment|// in update_stat_data we can not rely on inode, but have to check
singleline_comment|// item version directly
singleline_comment|//
singleline_comment|// called by read_inode
DECL|function|init_inode
r_static
r_void
id|init_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
id|__u32
id|rdev
suffix:semicolon
singleline_comment|//int version = ITEM_VERSION_1;
id|bh
op_assign
id|PATH_PLAST_BUFFER
(paren
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|PATH_PITEM_HEAD
(paren
id|path
)paren
suffix:semicolon
id|copy_key
(paren
id|INODE_PKEY
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_SIZE
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_list
)paren
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nopack = 0, by default */
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_nopack_mask
suffix:semicolon
r_if
c_cond
(paren
id|stat_data_v1
(paren
id|ih
)paren
)paren
(brace
r_struct
id|stat_data_v1
op_star
id|sd
op_assign
(paren
r_struct
id|stat_data_v1
op_star
)paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_5
)paren
suffix:semicolon
id|set_inode_sd_version
(paren
id|inode
comma
id|STAT_DATA_V1
)paren
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|sd_v1_mode
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
id|sd_v1_nlink
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|sd_v1_uid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|sd_v1_gid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|sd_v1_size
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|sd_v1_atime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|sd_v1_mtime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|sd_v1_ctime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
id|sd_v1_blocks
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
id|blocks
op_assign
(paren
id|inode-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
suffix:semicolon
id|blocks
op_assign
id|_ROUND_UP
(paren
id|blocks
comma
id|inode-&gt;i_blksize
op_rshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_blocks
OG
id|blocks
)paren
(brace
singleline_comment|// there was a bug in &lt;=3.5.23 when i_blocks could take negative
singleline_comment|// values. Starting from 3.5.17 this value could even be stored in
singleline_comment|// stat data. For such files we set i_blocks based on file
singleline_comment|// size. Just 2 notes: this can be wrong for sparce files. On-disk value will be
singleline_comment|// only updated if file&squot;s inode will ever change
id|inode-&gt;i_blocks
op_assign
id|blocks
suffix:semicolon
)brace
id|rdev
op_assign
id|sd_v1_rdev
c_func
(paren
id|sd
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
op_assign
id|sd_v1_first_direct_byte
c_func
(paren
id|sd
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// new stat data found, but object may have old items
singleline_comment|// (directories and symlinks)
r_struct
id|stat_data
op_star
id|sd
op_assign
(paren
r_struct
id|stat_data
op_star
)paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* both old and new directories have old keys */
singleline_comment|//version = (S_ISDIR (sd-&gt;sd_mode) ? ITEM_VERSION_1 : ITEM_VERSION_2);
id|inode-&gt;i_mode
op_assign
id|sd_v2_mode
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
id|sd_v2_nlink
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|sd_v2_uid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|sd_v2_size
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|sd_v2_gid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|sd_v2_mtime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|sd_v2_atime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|sd_v2_ctime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
id|sd_v2_blocks
c_func
(paren
id|sd
)paren
suffix:semicolon
id|rdev
op_assign
id|sd_v2_rdev
c_func
(paren
id|sd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_mode
)paren
)paren
(brace
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
)brace
r_else
id|inode-&gt;i_generation
op_assign
id|sd_v2_generation
c_func
(paren
id|sd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISLNK
(paren
id|inode-&gt;i_mode
)paren
)paren
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_5
)paren
suffix:semicolon
r_else
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_6
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
op_assign
l_int|0
suffix:semicolon
)brace
id|pathrelse
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_file_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|reiserfs_file_operations
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|reiserfs_address_space_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|reiserfs_dir_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|page_symlink_inode_operations
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|reiserfs_address_space_operations
suffix:semicolon
)brace
r_else
(brace
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|init_special_inode
c_func
(paren
id|inode
comma
id|inode-&gt;i_mode
comma
id|rdev
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// update new stat data with inode fields
DECL|function|inode2sd
r_static
r_void
id|inode2sd
(paren
r_void
op_star
id|sd
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|stat_data
op_star
id|sd_v2
op_assign
(paren
r_struct
id|stat_data
op_star
)paren
id|sd
suffix:semicolon
id|set_sd_v2_mode
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_mode
)paren
suffix:semicolon
id|set_sd_v2_nlink
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_nlink
)paren
suffix:semicolon
id|set_sd_v2_uid
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_uid
)paren
suffix:semicolon
id|set_sd_v2_size
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|set_sd_v2_gid
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_gid
)paren
suffix:semicolon
id|set_sd_v2_mtime
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_mtime
)paren
suffix:semicolon
id|set_sd_v2_atime
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_atime
)paren
suffix:semicolon
id|set_sd_v2_ctime
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_ctime
)paren
suffix:semicolon
id|set_sd_v2_blocks
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|set_sd_v2_rdev
c_func
(paren
id|sd_v2
comma
id|kdev_t_to_nr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_sd_v2_generation
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_generation
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// used to copy inode&squot;s fields to old stat data
DECL|function|inode2sd_v1
r_static
r_void
id|inode2sd_v1
(paren
r_void
op_star
id|sd
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|stat_data_v1
op_star
id|sd_v1
op_assign
(paren
r_struct
id|stat_data_v1
op_star
)paren
id|sd
suffix:semicolon
id|set_sd_v1_mode
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_mode
)paren
suffix:semicolon
id|set_sd_v1_uid
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_uid
)paren
suffix:semicolon
id|set_sd_v1_gid
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_gid
)paren
suffix:semicolon
id|set_sd_v1_nlink
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_nlink
)paren
suffix:semicolon
id|set_sd_v1_size
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|set_sd_v1_atime
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_atime
)paren
suffix:semicolon
id|set_sd_v1_ctime
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_ctime
)paren
suffix:semicolon
id|set_sd_v1_mtime
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_mtime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|set_sd_v1_rdev
c_func
(paren
id|sd_v1
comma
id|kdev_t_to_nr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_else
id|set_sd_v1_blocks
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_blocks
)paren
suffix:semicolon
singleline_comment|// Sigh. i_first_direct_byte is back
id|set_sd_v1_first_direct_byte
c_func
(paren
id|sd_v1
comma
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE, you must prepare the buffer head before sending it here,&n;** and then log it after the call&n;*/
DECL|function|update_stat_data
r_static
r_void
id|update_stat_data
(paren
r_struct
id|path
op_star
id|path
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
id|bh
op_assign
id|PATH_PLAST_BUFFER
(paren
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|PATH_PITEM_HEAD
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_statdata_le_ih
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-13065: update_stat_data: key %k, found item %h&quot;
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat_data_v1
(paren
id|ih
)paren
)paren
(brace
singleline_comment|// path points to old stat data
id|inode2sd_v1
(paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
comma
id|inode
)paren
suffix:semicolon
)brace
r_else
(brace
id|inode2sd
(paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
comma
id|inode
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|reiserfs_update_sd
r_void
id|reiserfs_update_sd
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|cpu_key
id|key
suffix:semicolon
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
l_int|3
)paren
suffix:semicolon
singleline_comment|//key type is unimportant
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|pos
suffix:semicolon
multiline_comment|/* look for the object&squot;s stat data */
id|retval
op_assign
id|search_item
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-13050: reiserfs_update_sd: &quot;
l_string|&quot;i/o failure occurred trying to update %K stat data&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_NOT_FOUND
)paren
(brace
id|pos
op_assign
id|PATH_LAST_POSITION
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_eq
l_int|0
)paren
(brace
multiline_comment|/*printk (&quot;vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found&bslash;n&quot;);*/
r_return
suffix:semicolon
)brace
id|reiserfs_warning
(paren
l_string|&quot;vs-13060: reiserfs_update_sd: &quot;
l_string|&quot;stat data of object %k (nlink == %d) not found (pos %d)&bslash;n&quot;
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|inode-&gt;i_nlink
comma
id|pos
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* sigh, prepare_for_journal might schedule.  When it schedules the&n;&t;** FS might change.  We have to detect that, and loop back to the&n;&t;** search if the stat data item has moved&n;&t;*/
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|copy_item_head
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
c_func
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* Stat_data item has been moved after scheduling. */
)brace
r_break
suffix:semicolon
)brace
id|update_stat_data
(paren
op_amp
id|path
comma
id|inode
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|th-&gt;t_super
comma
id|bh
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|reiserfs_read_inode
r_void
id|reiserfs_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// initially this function was derived from minix or ext2&squot;s analog and
singleline_comment|// evolved as the prototype did
singleline_comment|//
multiline_comment|/* looks for stat data in the tree, and fills up the fields of in-core&n;   inode stat data fields */
DECL|function|reiserfs_read_inode2
r_void
id|reiserfs_read_inode2
(paren
r_struct
id|inode
op_star
id|inode
comma
r_void
op_star
id|p
)paren
(brace
id|INITIALIZE_PATH
(paren
id|path_to_sd
)paren
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|reiserfs_iget4_args
op_star
id|args
op_assign
(paren
r_struct
id|reiserfs_iget4_args
op_star
)paren
id|p
suffix:semicolon
r_int
r_int
id|dirino
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dirino
op_assign
id|args-&gt;objectid
suffix:semicolon
multiline_comment|/* set version 1, version 2 could be used too, because stat data&n;       key is the same in both versions */
id|key.version
op_assign
id|KEY_FORMAT_3_5
suffix:semicolon
id|key.on_disk_key.k_dir_id
op_assign
id|dirino
suffix:semicolon
id|key.on_disk_key.k_objectid
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|key.on_disk_key.u.k_offset_v1.k_offset
op_assign
id|SD_OFFSET
suffix:semicolon
id|key.on_disk_key.u.k_offset_v1.k_uniqueness
op_assign
id|SD_UNIQUENESS
suffix:semicolon
multiline_comment|/* look for the object&squot;s stat data */
id|retval
op_assign
id|search_item
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path_to_sd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-13070: reiserfs_read_inode2: &quot;
l_string|&quot;i/o failure occurred trying to find stat data of %K&bslash;n&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_ne
id|ITEM_FOUND
)paren
(brace
multiline_comment|/* a stale NFS handle can trigger this without it being an error */
id|pathrelse
(paren
op_amp
id|path_to_sd
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|init_inode
(paren
id|inode
comma
op_amp
id|path_to_sd
)paren
suffix:semicolon
multiline_comment|/* It is possible that knfsd is trying to access inode of a file&n;       that is being removed from the disk by some other thread. As we&n;       update sd on unlink all that is required is to check for nlink&n;       here. This bug was first found by Sizif when debugging&n;       SquidNG/Butterfly, forgotten, and found again after Philippe&n;       Gramoulle &lt;philippe.gramoulle@mmania.com&gt; reproduced it. &n;&n;       More logical fix would require changes in fs/inode.c:iput() to&n;       remove inode from hash-table _after_ fs cleaned disk stuff up and&n;       in iget() to return NULL if I_FREEING inode is found in&n;       hash-table. */
multiline_comment|/* Currently there is one place where it&squot;s ok to meet inode with&n;       nlink==0: processing of open-unlinked and half-truncated files&n;       during mount (fs/reiserfs/super.c:finish_unfinished()). */
r_if
c_cond
(paren
(paren
id|inode
op_member_access_from_pointer
id|i_nlink
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|inode
op_member_access_from_pointer
id|i_sb
op_member_access_from_pointer
id|u.reiserfs_sb.s_is_unlinked_ok
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;vs-13075: reiserfs_read_inode2: &quot;
l_string|&quot;dead inode read from disk %K. &quot;
l_string|&quot;This is likely to be race with knfsd. Ignore&bslash;n&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_sd
)paren
suffix:semicolon
multiline_comment|/* init inode should be relsing */
)brace
multiline_comment|/**&n; * reiserfs_find_actor() - &quot;find actor&quot; reiserfs supplies to iget4().&n; *&n; * @inode:    inode from hash table to check&n; * @inode_no: inode number we are looking for&n; * @opaque:   &quot;cookie&quot; passed to iget4(). This is &amp;reiserfs_iget4_args.&n; *&n; * This function is called by iget4() to distinguish reiserfs inodes&n; * having the same inode numbers. Such inodes can only exist due to some&n; * error condition. One of them should be bad. Inodes with identical&n; * inode numbers (objectids) are distinguished by parent directory ids.&n; *&n; */
DECL|function|reiserfs_find_actor
r_static
r_int
id|reiserfs_find_actor
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|inode_no
comma
r_void
op_star
id|opaque
)paren
(brace
r_struct
id|reiserfs_iget4_args
op_star
id|args
suffix:semicolon
id|args
op_assign
id|opaque
suffix:semicolon
r_return
id|INODE_PKEY
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
op_eq
id|args
op_member_access_from_pointer
id|objectid
suffix:semicolon
)brace
DECL|function|reiserfs_iget
r_struct
id|inode
op_star
id|reiserfs_iget
(paren
r_struct
id|super_block
op_star
id|s
comma
r_const
r_struct
id|cpu_key
op_star
id|key
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|reiserfs_iget4_args
id|args
suffix:semicolon
id|args.objectid
op_assign
id|key-&gt;on_disk_key.k_dir_id
suffix:semicolon
id|inode
op_assign
id|iget4
(paren
id|s
comma
id|key-&gt;on_disk_key.k_objectid
comma
id|reiserfs_find_actor
comma
(paren
r_void
op_star
)paren
(paren
op_amp
id|args
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|comp_short_keys
(paren
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|key
)paren
op_logical_or
id|is_bad_inode
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* either due to i/o error or a stale NFS handle */
id|iput
(paren
id|inode
)paren
suffix:semicolon
id|inode
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|inode
suffix:semicolon
)brace
DECL|function|reiserfs_fh_to_dentry
r_struct
id|dentry
op_star
id|reiserfs_fh_to_dentry
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|__u32
op_star
id|data
comma
r_int
id|len
comma
r_int
id|fhtype
comma
r_int
id|parent
)paren
(brace
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|lp
suffix:semicolon
r_struct
id|dentry
op_star
id|result
suffix:semicolon
multiline_comment|/* fhtype happens to reflect the number of u32s encoded.&n;     * due to a bug in earlier code, fhtype might indicate there&n;     * are more u32s then actually fitted.&n;     * so if fhtype seems to be more than len, reduce fhtype.&n;     * Valid types are:&n;     *   2 - objectid + dir_id - legacy support&n;     *   3 - objectid + dir_id + generation&n;     *   4 - objectid + dir_id + objectid and dirid of parent - legacy&n;     *   5 - objectid + dir_id + generation + objectid and dirid of parent&n;     *   6 - as above plus generation of directory&n;     * 6 does not fit in NFSv2 handles&n;     */
r_if
c_cond
(paren
id|fhtype
OG
id|len
)paren
(brace
r_if
c_cond
(paren
id|fhtype
op_ne
l_int|6
op_logical_or
id|len
op_ne
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd/reiserfs, fhtype=%d, len=%d - odd&bslash;n&quot;
comma
id|fhtype
comma
id|len
)paren
suffix:semicolon
id|fhtype
op_assign
l_int|5
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fhtype
OL
l_int|2
op_logical_or
(paren
id|parent
op_logical_and
id|fhtype
OL
l_int|4
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
multiline_comment|/* this works for handles from old kernels because the default&n;&t;    ** reiserfs generation number is the packing locality.&n;&t;    */
id|key.on_disk_key.k_objectid
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
id|key.on_disk_key.k_dir_id
op_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
id|inode
op_assign
id|reiserfs_iget
c_func
(paren
id|sb
comma
op_amp
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
op_logical_neg
id|IS_ERR
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|fhtype
op_eq
l_int|3
op_logical_or
id|fhtype
op_ge
l_int|5
)paren
op_logical_and
id|data
(braket
l_int|2
)braket
op_ne
id|inode-&gt;i_generation
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|key.on_disk_key.k_objectid
op_assign
id|data
(braket
id|fhtype
op_ge
l_int|5
ques
c_cond
l_int|3
suffix:colon
l_int|2
)braket
suffix:semicolon
id|key.on_disk_key.k_dir_id
op_assign
id|data
(braket
id|fhtype
op_ge
l_int|5
ques
c_cond
l_int|4
suffix:colon
l_int|3
)braket
suffix:semicolon
id|inode
op_assign
id|reiserfs_iget
c_func
(paren
id|sb
comma
op_amp
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
op_logical_neg
id|IS_ERR
c_func
(paren
id|inode
)paren
op_logical_and
id|fhtype
op_eq
l_int|6
op_logical_and
id|data
(braket
l_int|5
)braket
op_ne
id|inode-&gt;i_generation
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|inode
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
id|PTR_ERR
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ESTALE
)paren
suffix:semicolon
multiline_comment|/* now to find a dentry.&n;     * If possible, get a well-connected one&n;     */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lp
op_assign
id|inode-&gt;i_dentry.next
suffix:semicolon
id|lp
op_ne
op_amp
id|inode-&gt;i_dentry
suffix:semicolon
id|lp
op_assign
id|lp-&gt;next
)paren
(brace
id|result
op_assign
id|list_entry
c_func
(paren
id|lp
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|result-&gt;d_flags
op_amp
id|DCACHE_NFSD_DISCONNECTED
)paren
)paren
(brace
id|dget_locked
c_func
(paren
id|result
)paren
suffix:semicolon
id|result-&gt;d_vfs_flags
op_or_assign
id|DCACHE_REFERENCED
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|result
op_assign
id|d_alloc_root
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|NULL
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|result-&gt;d_flags
op_or_assign
id|DCACHE_NFSD_DISCONNECTED
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|reiserfs_dentry_to_fh
r_int
id|reiserfs_dentry_to_fh
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
id|__u32
op_star
id|data
comma
r_int
op_star
id|lenp
comma
r_int
id|need_parent
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|maxlen
op_assign
op_star
id|lenp
suffix:semicolon
r_if
c_cond
(paren
id|maxlen
OL
l_int|3
)paren
r_return
l_int|255
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
id|inode-&gt;i_generation
suffix:semicolon
op_star
id|lenp
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* no room for directory info? return what we&squot;ve stored so far */
r_if
c_cond
(paren
id|maxlen
OL
l_int|5
op_logical_or
op_logical_neg
id|need_parent
)paren
r_return
l_int|3
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|dparent_lock
)paren
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|data
(braket
l_int|4
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
op_star
id|lenp
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|maxlen
op_ge
l_int|6
)paren
(brace
id|data
(braket
l_int|5
)braket
op_assign
id|inode-&gt;i_generation
suffix:semicolon
op_star
id|lenp
op_assign
l_int|6
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|dparent_lock
)paren
suffix:semicolon
r_return
op_star
id|lenp
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// initially this function was derived from minix or ext2&squot;s analog and
singleline_comment|// evolved as the prototype did
singleline_comment|//
multiline_comment|/* looks for stat data, then copies fields to it, marks the buffer&n;   containing stat data as dirty */
multiline_comment|/* reiserfs inodes are never really dirty, since the dirty inode call&n;** always logs them.  This call allows the VFS inode marking routines&n;** to properly mark inodes for datasync and such, but only actually&n;** does something when called for a synchronous update.&n;*/
DECL|function|reiserfs_write_inode
r_void
id|reiserfs_write_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|do_sync
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-6005: writing inode %lu on readonly FS&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* memory pressure can sometimes initiate write_inode calls with sync == 1,&n;    ** these cases are just when the system needs ram, not when the &n;    ** inode needs to reach disk for safety, and they can safely be&n;    ** ignored because the altered inode has already been logged.&n;    */
r_if
c_cond
(paren
id|do_sync
op_logical_and
op_logical_neg
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|journal_end_sync
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* FIXME: no need any more. right? */
DECL|function|reiserfs_sync_inode
r_int
id|reiserfs_sync_inode
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|reiserfs_update_sd
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* stat data of new object is inserted already, this inserts the item&n;   containing &quot;.&quot; and &quot;..&quot; entries */
DECL|function|reiserfs_new_directory
r_static
r_int
id|reiserfs_new_directory
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|item_head
op_star
id|ih
comma
r_struct
id|path
op_star
id|path
comma
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|th-&gt;t_super
suffix:semicolon
r_char
id|empty_dir
(braket
id|EMPTY_DIR_SIZE
)braket
suffix:semicolon
r_char
op_star
id|body
op_assign
id|empty_dir
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|_make_cpu_key
(paren
op_amp
id|key
comma
id|KEY_FORMAT_3_5
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_objectid
)paren
comma
id|DOT_OFFSET
comma
id|TYPE_DIRENTRY
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
multiline_comment|/* compose item head for new item. Directories consist of items of&n;       old type (ITEM_VERSION_1). Do not set key (second arg is 0), it&n;       is done by reiserfs_new_inode */
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
(brace
id|make_le_item_head
(paren
id|ih
comma
l_int|0
comma
id|KEY_FORMAT_3_5
comma
id|DOT_OFFSET
comma
id|TYPE_DIRENTRY
comma
id|EMPTY_DIR_SIZE_V1
comma
l_int|2
)paren
suffix:semicolon
id|make_empty_dir_item_v1
(paren
id|body
comma
id|ih-&gt;ih_key.k_dir_id
comma
id|ih-&gt;ih_key.k_objectid
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_dir_id
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
)brace
r_else
(brace
id|make_le_item_head
(paren
id|ih
comma
l_int|0
comma
id|KEY_FORMAT_3_5
comma
id|DOT_OFFSET
comma
id|TYPE_DIRENTRY
comma
id|EMPTY_DIR_SIZE
comma
l_int|2
)paren
suffix:semicolon
id|make_empty_dir_item
(paren
id|body
comma
id|ih-&gt;ih_key.k_dir_id
comma
id|ih-&gt;ih_key.k_objectid
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_dir_id
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
)brace
multiline_comment|/* look for place in the tree for new item */
id|retval
op_assign
id|search_item
(paren
id|sb
comma
op_amp
id|key
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-13080: reiserfs_new_directory: &quot;
l_string|&quot;i/o failure occurred creating new directory&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|pathrelse
(paren
id|path
)paren
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;vs-13070: reiserfs_new_directory: &quot;
l_string|&quot;object with this key exists (%k)&quot;
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* insert item, that is empty directory item */
r_return
id|reiserfs_insert_item
(paren
id|th
comma
id|path
comma
op_amp
id|key
comma
id|ih
comma
id|body
)paren
suffix:semicolon
)brace
multiline_comment|/* stat data of object has been inserted, this inserts the item&n;   containing the body of symlink */
DECL|function|reiserfs_new_symlink
r_static
r_int
id|reiserfs_new_symlink
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|item_head
op_star
id|ih
comma
r_struct
id|path
op_star
id|path
comma
r_const
r_char
op_star
id|symname
comma
r_int
id|item_len
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|th-&gt;t_super
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|_make_cpu_key
(paren
op_amp
id|key
comma
id|KEY_FORMAT_3_5
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_objectid
)paren
comma
l_int|1
comma
id|TYPE_DIRECT
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
id|make_le_item_head
(paren
id|ih
comma
l_int|0
comma
id|KEY_FORMAT_3_5
comma
l_int|1
comma
id|TYPE_DIRECT
comma
id|item_len
comma
l_int|0
multiline_comment|/*free_space*/
)paren
suffix:semicolon
multiline_comment|/* look for place in the tree for new item */
id|retval
op_assign
id|search_item
(paren
id|sb
comma
op_amp
id|key
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-13080: reiserfs_new_symlinik: &quot;
l_string|&quot;i/o failure occurred creating new symlink&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|pathrelse
(paren
id|path
)paren
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;vs-13080: reiserfs_new_symlink: &quot;
l_string|&quot;object with this key exists (%k)&quot;
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* insert item, that is body of symlink */
r_return
id|reiserfs_insert_item
(paren
id|th
comma
id|path
comma
op_amp
id|key
comma
id|ih
comma
id|symname
)paren
suffix:semicolon
)brace
multiline_comment|/* inserts the stat data into the tree, and then calls&n;   reiserfs_new_directory (to insert &quot;.&quot;, &quot;..&quot; item if new object is&n;   directory) or reiserfs_new_symlink (to insert symlink body if new&n;   object is symlink) or nothing (if new object is regular file) */
DECL|function|reiserfs_new_inode
r_struct
id|inode
op_star
id|reiserfs_new_inode
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|dir
comma
r_int
id|mode
comma
r_const
r_char
op_star
id|symname
comma
r_int
id|i_size
comma
multiline_comment|/* 0 for regular, EMTRY_DIR_SIZE for dirs,&n;&t;&t;&t;&t;&t;&t;  strlen (symname) for symlinks)*/
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
op_star
id|err
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path_to_key
)paren
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|item_head
id|ih
suffix:semicolon
r_struct
id|stat_data
id|sd
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|dir-&gt;i_nlink
)paren
(brace
op_star
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|sb
op_assign
id|dir-&gt;i_sb
suffix:semicolon
id|inode-&gt;i_flags
op_assign
l_int|0
suffix:semicolon
singleline_comment|//inode-&gt;i_sb-&gt;s_flags;
multiline_comment|/* item head of new item */
id|ih.ih_key.k_dir_id
op_assign
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_objectid
suffix:semicolon
id|ih.ih_key.k_objectid
op_assign
id|cpu_to_le32
(paren
id|reiserfs_get_unused_objectid
(paren
id|th
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ih.ih_key.k_objectid
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
multiline_comment|/* not a perfect generation count, as object ids can be reused, but this&n;      ** is as good as reiserfs can do right now.&n;      ** note that the private part of inode isn&squot;t filled in yet, we have&n;      ** to use the directory.&n;      */
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
r_else
macro_line|#if defined( USE_INODE_GENERATION_COUNTER )
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
c_func
(paren
id|sb
op_member_access_from_pointer
id|u.reiserfs_sb.s_rs
op_member_access_from_pointer
id|s_inode_generation
)paren
suffix:semicolon
macro_line|#else
id|inode-&gt;i_generation
op_assign
op_increment
id|event
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
id|make_le_item_head
(paren
op_amp
id|ih
comma
l_int|0
comma
id|KEY_FORMAT_3_5
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
id|SD_V1_SIZE
comma
id|MAX_US_INT
)paren
suffix:semicolon
r_else
id|make_le_item_head
(paren
op_amp
id|ih
comma
l_int|0
comma
id|KEY_FORMAT_3_6
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
id|SD_SIZE
comma
id|MAX_US_INT
)paren
suffix:semicolon
multiline_comment|/* key to search for correct place for new stat data */
id|_make_cpu_key
(paren
op_amp
id|key
comma
id|KEY_FORMAT_3_6
comma
id|le32_to_cpu
(paren
id|ih.ih_key.k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|ih.ih_key.k_objectid
)paren
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
multiline_comment|/* find proper place for inserting of stat data */
id|retval
op_assign
id|search_item
(paren
id|sb
comma
op_amp
id|key
comma
op_amp
id|path_to_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|iput
(paren
id|inode
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|pathrelse
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* fill stat data */
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
(paren
id|S_ISDIR
(paren
id|mode
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
(brace
id|inode-&gt;i_gid
op_assign
id|dir-&gt;i_gid
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
id|inode-&gt;i_mode
op_or_assign
id|S_ISGID
suffix:semicolon
)brace
r_else
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|i_size
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
(paren
id|inode-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
op_assign
id|S_ISLNK
c_func
(paren
id|mode
)paren
ques
c_cond
l_int|1
suffix:colon
id|U32_MAX
multiline_comment|/*NO_BYTES_IN_DIRECT_ITEM*/
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_list
)paren
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_uid
op_amp
op_complement
l_int|0xffff
op_logical_or
id|inode-&gt;i_gid
op_amp
op_complement
l_int|0xffff
)paren
(brace
id|pathrelse
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
multiline_comment|/* i_uid or i_gid is too big to be stored in stat data v3.5 */
id|iput
(paren
id|inode
)paren
suffix:semicolon
op_star
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|inode2sd_v1
(paren
op_amp
id|sd
comma
id|inode
)paren
suffix:semicolon
)brace
r_else
id|inode2sd
(paren
op_amp
id|sd
comma
id|inode
)paren
suffix:semicolon
singleline_comment|// these do not go to on-disk stat data
id|inode-&gt;i_ino
op_assign
id|le32_to_cpu
(paren
id|ih.ih_key.k_objectid
)paren
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_SIZE
suffix:semicolon
singleline_comment|// store in in-core inode the key of stat data and version all
singleline_comment|// object items will have (directory items will have old offset
singleline_comment|// format, other new objects will consist of new items)
id|memcpy
(paren
id|INODE_PKEY
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih.ih_key
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_5
)paren
suffix:semicolon
r_else
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
id|set_inode_sd_version
(paren
id|inode
comma
id|STAT_DATA_V1
)paren
suffix:semicolon
r_else
id|set_inode_sd_version
(paren
id|inode
comma
id|STAT_DATA_V2
)paren
suffix:semicolon
multiline_comment|/* insert the stat data into the tree */
id|retval
op_assign
id|reiserfs_insert_item
(paren
id|th
comma
op_amp
id|path_to_key
comma
op_amp
id|key
comma
op_amp
id|ih
comma
(paren
r_char
op_star
)paren
(paren
op_amp
id|sd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|iput
(paren
id|inode
)paren
suffix:semicolon
op_star
id|err
op_assign
id|retval
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
(brace
multiline_comment|/* insert item with &quot;.&quot; and &quot;..&quot; */
id|retval
op_assign
id|reiserfs_new_directory
(paren
id|th
comma
op_amp
id|ih
comma
op_amp
id|path_to_key
comma
id|dir
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
(brace
multiline_comment|/* insert body of symlink */
r_if
c_cond
(paren
op_logical_neg
id|old_format_only
(paren
id|sb
)paren
)paren
id|i_size
op_assign
id|ROUND_UP
c_func
(paren
id|i_size
)paren
suffix:semicolon
id|retval
op_assign
id|reiserfs_new_symlink
(paren
id|th
comma
op_amp
id|ih
comma
op_amp
id|path_to_key
comma
id|symname
comma
id|i_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
(brace
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
op_star
id|err
op_assign
id|retval
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|insert_inode_hash
(paren
id|inode
)paren
suffix:semicolon
singleline_comment|// we do not mark inode dirty: on disk content matches to the
singleline_comment|// in-core one
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
r_return
id|inode
suffix:semicolon
)brace
multiline_comment|/*&n;** finds the tail page in the page cache,&n;** reads the last block in.&n;**&n;** On success, page_result is set to a locked, pinned page, and bh_result&n;** is set to an up to date buffer for the last block in the file.  returns 0.&n;**&n;** tail conversion is not done, so bh_result might not be valid for writing&n;** check buffer_mapped(bh_result) and bh_result-&gt;b_blocknr != 0 before&n;** trying to write the block.&n;**&n;** on failure, nonzero is returned, page_result and bh_result are untouched.&n;*/
DECL|function|grab_tail_page
r_static
r_int
id|grab_tail_page
c_func
(paren
r_struct
id|inode
op_star
id|p_s_inode
comma
r_struct
id|page
op_star
op_star
id|page_result
comma
r_struct
id|buffer_head
op_star
op_star
id|bh_result
)paren
(brace
multiline_comment|/* we want the page with the last byte in the file,&n;    ** not the page that will hold the next byte for appending&n;    */
r_int
r_int
id|index
op_assign
(paren
id|p_s_inode-&gt;i_size
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|p_s_inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_int
r_int
id|offset
op_assign
(paren
id|p_s_inode-&gt;i_size
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|head
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* we know that we are only called with inode-&gt;i_size &gt; 0.&n;    ** we also know that a file tail can never be as big as a block&n;    ** If i_size % blocksize == 0, our file is currently block aligned&n;    ** and it won&squot;t need converting or zeroing after a truncate.&n;    */
r_if
c_cond
(paren
(paren
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|p_s_inode-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* start within the page of the last block in the file */
id|start
op_assign
(paren
id|offset
op_div
id|blocksize
)paren
op_star
id|blocksize
suffix:semicolon
id|error
op_assign
id|block_prepare_write
c_func
(paren
id|page
comma
id|start
comma
id|offset
comma
id|reiserfs_get_block_create_0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|unlock
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* mapped by block_prepare_write */
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|pos
op_ge
id|start
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|pos
op_add_assign
id|blocksize
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* note, this should never happen, prepare_write should&n;&t;** be taking care of this for us.  If the buffer isn&squot;t up to date,&n;&t;** I&squot;ve screwed up the code to find the buffer, or the code to&n;&t;** call prepare_write&n;&t;*/
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-6000: error reading block %lu on dev %s&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|p_s_inode-&gt;i_sb-&gt;s_id
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
op_star
id|bh_result
op_assign
id|bh
suffix:semicolon
op_star
id|page_result
op_assign
id|page
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|unlock
suffix:colon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;** vfs version of truncate file.  Must NOT be called with&n;** a transaction already started.&n;**&n;** some code taken from block_truncate_page&n;*/
DECL|function|reiserfs_truncate_file
r_void
id|reiserfs_truncate_file
c_func
(paren
r_struct
id|inode
op_star
id|p_s_inode
comma
r_int
id|update_timestamps
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|windex
suffix:semicolon
multiline_comment|/* we want the offset for the first byte after the end of the file */
r_int
r_int
id|offset
op_assign
id|p_s_inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|blocksize
op_assign
id|p_s_inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p_s_inode-&gt;i_size
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|grab_tail_page
c_func
(paren
id|p_s_inode
comma
op_amp
id|page
comma
op_amp
id|bh
)paren
)paren
)paren
(brace
singleline_comment|// -ENOENT means we truncated past the end of the file, 
singleline_comment|// and get_block_create_0 could not find a block to read in,
singleline_comment|// which is ok.
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|ENOENT
)paren
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-6001: grab_tail_page failed %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
id|page
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* so, if page != NULL, we have a buffer head for the offset at &n;    ** the end of the file. if the bh is mapped, and bh-&gt;b_blocknr != 0, &n;    ** then we have an unformatted node.  Otherwise, we have a direct item, &n;    ** and no zeroing is required on disk.  We zero after the truncate, &n;    ** because the truncate might pack the item anyway &n;    ** (it will unmap bh if it packs).&n;    */
multiline_comment|/* it is enough to reserve space in transaction for 2 balancings:&n;       one for &quot;save&quot; link adding and another for the first&n;       cut_from_item. 1 is for update_sd */
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|p_s_inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|p_s_inode
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_vfs_truncate_file&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_timestamps
)paren
multiline_comment|/* we are doing real truncate: if the system crashes before the last&n;              transaction of truncating gets committed - on reboot the file&n;              either appears truncated properly or not truncated at all */
id|add_save_link
(paren
op_amp
id|th
comma
id|p_s_inode
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_do_truncate
(paren
op_amp
id|th
comma
id|p_s_inode
comma
id|page
comma
id|update_timestamps
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|p_s_inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_timestamps
)paren
id|remove_save_link
(paren
id|p_s_inode
comma
l_int|1
multiline_comment|/* truncate */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|length
op_assign
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if we are not on a block boundary */
r_if
c_cond
(paren
id|length
)paren
(brace
id|length
op_assign
id|blocksize
op_minus
id|length
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
l_int|0
comma
id|length
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_ne
l_int|0
)paren
(brace
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|map_block_for_writepage
r_static
r_int
id|map_block_for_writepage
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_struct
id|item_head
id|tmp_ih
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|__u32
op_star
id|item
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|pos_in_item
suffix:semicolon
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
id|loff_t
id|byte_offset
op_assign
(paren
id|block
op_lshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|use_get_block
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_copied
op_assign
l_int|0
suffix:semicolon
r_int
id|copy_size
suffix:semicolon
id|kmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|start_over
suffix:colon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|make_cpu_key
c_func
(paren
op_amp
id|key
comma
id|inode
comma
id|byte_offset
comma
id|TYPE_ANY
comma
l_int|3
)paren
suffix:semicolon
id|research
suffix:colon
id|retval
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|POSITION_FOUND
)paren
(brace
id|use_get_block
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|path.pos_in_item
suffix:semicolon
multiline_comment|/* we&squot;ve found an unformatted node */
r_if
c_cond
(paren
id|indirect_item_found
c_func
(paren
id|retval
comma
id|ih
)paren
)paren
(brace
r_if
c_cond
(paren
id|bytes_copied
OG
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-6002: bytes_copied %d&bslash;n&quot;
comma
id|bytes_copied
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
)paren
(brace
multiline_comment|/* crap, we are writing to a hole */
id|use_get_block
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|set_block_dev_mapped
c_func
(paren
id|bh_result
comma
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
comma
id|inode
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh_result
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_direct_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
id|page_address
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|p
op_add_assign
(paren
id|byte_offset
op_minus
l_int|1
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|copy_size
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
op_minus
id|pos_in_item
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|copy_item_head
c_func
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|B_I_PITEM
c_func
(paren
id|bh
comma
id|ih
)paren
op_plus
id|pos_in_item
comma
id|p
op_plus
id|bytes_copied
comma
id|copy_size
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
id|bytes_copied
op_add_assign
id|copy_size
suffix:semicolon
id|set_block_dev_mapped
c_func
(paren
id|bh_result
comma
l_int|0
comma
id|inode
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh_result
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* are there still bytes left? */
r_if
c_cond
(paren
id|bytes_copied
OL
id|bh_result-&gt;b_size
op_logical_and
(paren
id|byte_offset
op_plus
id|bytes_copied
)paren
OL
id|inode-&gt;i_size
)paren
(brace
id|set_cpu_key_k_offset
c_func
(paren
op_amp
id|key
comma
id|cpu_key_k_offset
c_func
(paren
op_amp
id|key
)paren
op_plus
id|copy_size
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
)brace
r_else
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-6003: bad item inode %lu, device %s&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_sb-&gt;s_id
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this is where we fill in holes in the file. */
r_if
c_cond
(paren
id|use_get_block
)paren
(brace
id|retval
op_assign
id|reiserfs_get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
id|GET_BLOCK_CREATE
op_or
id|GET_BLOCK_NO_ISEM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh_result
)paren
op_logical_or
id|bh_result-&gt;b_blocknr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* get_block failed to find a mapped unformatted node. */
id|use_get_block
op_assign
l_int|0
suffix:semicolon
r_goto
id|start_over
suffix:semicolon
)brace
)brace
)brace
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* helper func to get a buffer head ready for writepage to send to&n;** ll_rw_block&n;*/
DECL|function|submit_bh_for_writepage
r_static
r_inline
r_void
id|submit_bh_for_writepage
c_func
(paren
r_struct
id|buffer_head
op_star
op_star
id|bhp
comma
r_int
id|nr
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|bhp
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|set_buffer_async_io
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* submit_bh doesn&squot;t care if the buffer is dirty, but nobody&n;&t;** later on in the call chain will be cleaning it.  So, we&n;&t;** clean the buffer here, it still gets written either way.&n;&t;*/
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
)brace
)brace
DECL|function|reiserfs_write_full_page
r_static
r_int
id|reiserfs_write_full_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
r_int
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|last_offset
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
id|cur_offset
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
suffix:semicolon
r_int
id|partial
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|arr
(braket
id|PAGE_CACHE_SIZE
op_div
l_int|512
)braket
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
(brace
id|block_prepare_write
c_func
(paren
id|page
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* last page in the file, zero out any contents past the&n;    ** last byte in the file&n;    */
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
)paren
(brace
id|last_offset
op_assign
id|inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no file contents in this page */
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
op_plus
l_int|1
op_logical_or
op_logical_neg
id|last_offset
)paren
(brace
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|last_offset
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|last_offset
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
id|block
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* if this offset in the page is outside the file */
r_if
c_cond
(paren
id|cur_offset
op_ge
id|last_offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|partial
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* fast path, buffer mapped to an unformatted node */
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_ne
l_int|0
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* buffer not mapped yet, or points to a direct item.&n;&t;&t;** search and dirty or log&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|error
op_assign
id|map_block_for_writepage
c_func
(paren
id|inode
comma
id|bh
comma
id|block
)paren
)paren
)paren
(brace
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* map_block_for_writepage either found an unformatted node&n;&t;&t;** and mapped it for us, or it found a direct item&n;&t;&t;** and logged the changes.  &n;&t;&t;*/
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_ne
l_int|0
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
)brace
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|cur_offset
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|block
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* if this page only had a direct item, it is very possible for&n;    ** nr == 0 without there being any kind of error.&n;    */
r_if
c_cond
(paren
id|nr
)paren
(brace
id|submit_bh_for_writepage
c_func
(paren
id|arr
comma
id|nr
)paren
suffix:semicolon
)brace
r_else
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|nr
)paren
(brace
id|submit_bh_for_writepage
c_func
(paren
id|arr
comma
id|nr
)paren
suffix:semicolon
)brace
r_else
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// this is exactly what 2.3.99-pre9&squot;s ext2_readpage is
singleline_comment|//
DECL|function|reiserfs_readpage
r_static
r_int
id|reiserfs_readpage
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|block_read_full_page
(paren
id|page
comma
id|reiserfs_get_block
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// modified from ext2_writepage is
singleline_comment|//
DECL|function|reiserfs_writepage
r_static
r_int
id|reiserfs_writepage
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|reiserfs_write_full_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// from ext2_prepare_write, but modified
singleline_comment|//
DECL|function|reiserfs_prepare_write
r_int
id|reiserfs_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|fix_tail_page_for_writing
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|block_prepare_write
c_func
(paren
id|page
comma
id|from
comma
id|to
comma
id|reiserfs_get_block
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// this is exactly what 2.3.99-pre9&squot;s ext2_bmap is
singleline_comment|//
DECL|function|reiserfs_aop_bmap
r_static
r_int
id|reiserfs_aop_bmap
c_func
(paren
r_struct
id|address_space
op_star
id|as
comma
r_int
id|block
)paren
(brace
r_return
id|generic_block_bmap
c_func
(paren
id|as
comma
id|block
comma
id|reiserfs_bmap
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_commit_write
r_static
r_int
id|reiserfs_commit_write
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|loff_t
id|pos
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* generic_commit_write does this for us, but does not update the&n;    ** transaction tracking stuff when the size changes.  So, we have&n;    ** to do the i_size updates here.&n;    */
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|pos
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|generic_commit_write
c_func
(paren
id|f
comma
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
multiline_comment|/* we test for O_SYNC here so we can commit the transaction&n;    ** for any packed tails the file might have had&n;    */
r_if
c_cond
(paren
id|f
op_logical_and
(paren
id|f-&gt;f_flags
op_amp
id|O_SYNC
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|reiserfs_commit_for_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|reiserfs_address_space_operations
r_struct
id|address_space_operations
id|reiserfs_address_space_operations
op_assign
(brace
id|writepage
suffix:colon
id|reiserfs_writepage
comma
id|readpage
suffix:colon
id|reiserfs_readpage
comma
id|sync_page
suffix:colon
id|block_sync_page
comma
id|prepare_write
suffix:colon
id|reiserfs_prepare_write
comma
id|commit_write
suffix:colon
id|reiserfs_commit_write
comma
id|bmap
suffix:colon
id|reiserfs_aop_bmap
)brace
suffix:semicolon
eof
