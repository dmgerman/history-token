multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/reiserfs_acl.h&gt;
macro_line|#include &lt;linux/reiserfs_xattr.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/mpage.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
r_extern
r_int
id|reiserfs_default_io_size
suffix:semicolon
multiline_comment|/* default io size devuned in super.c */
r_static
r_int
id|reiserfs_commit_write
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
suffix:semicolon
r_static
r_int
id|reiserfs_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
suffix:semicolon
DECL|function|reiserfs_delete_inode
r_void
id|reiserfs_delete_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
multiline_comment|/* We need blocks for transaction + (user+group) quota update (possibly delete) */
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
op_plus
l_int|2
op_star
id|REISERFS_QUOTA_INIT_BLOCKS
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* The = 0 happens when we abort creating a new inode for some reason like lack of space.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode-&gt;i_state
op_amp
id|I_NEW
)paren
op_logical_and
id|INODE_PKEY
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
op_ne
l_int|0
)paren
(brace
multiline_comment|/* also handles bad_inode case */
id|down
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|reiserfs_delete_xattrs
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
)paren
(brace
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_delete_object
(paren
op_amp
id|th
comma
id|inode
)paren
)paren
(brace
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Do quota update inside a transaction for journaled quotas. We must do that&n;&t; * after delete_object so that quota updates go into the same transaction as&n;&t; * stat data deletion */
id|DQUOT_FREE_INODE
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
)paren
(brace
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/* all items of file are deleted, so we can remove &quot;save&quot; link */
id|remove_save_link
(paren
id|inode
comma
l_int|0
multiline_comment|/* not truncate */
)paren
suffix:semicolon
multiline_comment|/* we can&squot;t do anything&n;                                                        * about an error here */
)brace
r_else
(brace
multiline_comment|/* no object items are in the tree */
suffix:semicolon
)brace
id|out
suffix:colon
id|clear_inode
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* note this must go after the journal_end to prevent deadlock */
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
DECL|function|_make_cpu_key
r_static
r_void
id|_make_cpu_key
(paren
r_struct
id|cpu_key
op_star
id|key
comma
r_int
id|version
comma
id|__u32
id|dirid
comma
id|__u32
id|objectid
comma
id|loff_t
id|offset
comma
r_int
id|type
comma
r_int
id|length
)paren
(brace
id|key-&gt;version
op_assign
id|version
suffix:semicolon
id|key-&gt;on_disk_key.k_dir_id
op_assign
id|dirid
suffix:semicolon
id|key-&gt;on_disk_key.k_objectid
op_assign
id|objectid
suffix:semicolon
id|set_cpu_key_k_offset
(paren
id|key
comma
id|offset
)paren
suffix:semicolon
id|set_cpu_key_k_type
(paren
id|key
comma
id|type
)paren
suffix:semicolon
id|key-&gt;key_length
op_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* take base of inode_key (it comes from inode always) (dirid, objectid) and version from an inode, set&n;   offset and type of key */
DECL|function|make_cpu_key
r_void
id|make_cpu_key
(paren
r_struct
id|cpu_key
op_star
id|key
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|offset
comma
r_int
id|type
comma
r_int
id|length
)paren
(brace
id|_make_cpu_key
(paren
id|key
comma
id|get_inode_item_key_version
(paren
id|inode
)paren
comma
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
comma
id|offset
comma
id|type
comma
id|length
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// when key is 0, do not set version and short key
singleline_comment|//
DECL|function|make_le_item_head
r_inline
r_void
id|make_le_item_head
(paren
r_struct
id|item_head
op_star
id|ih
comma
r_const
r_struct
id|cpu_key
op_star
id|key
comma
r_int
id|version
comma
id|loff_t
id|offset
comma
r_int
id|type
comma
r_int
id|length
comma
r_int
id|entry_count
multiline_comment|/*or ih_free_space*/
)paren
(brace
r_if
c_cond
(paren
id|key
)paren
(brace
id|ih-&gt;ih_key.k_dir_id
op_assign
id|cpu_to_le32
(paren
id|key-&gt;on_disk_key.k_dir_id
)paren
suffix:semicolon
id|ih-&gt;ih_key.k_objectid
op_assign
id|cpu_to_le32
(paren
id|key-&gt;on_disk_key.k_objectid
)paren
suffix:semicolon
)brace
id|put_ih_version
c_func
(paren
id|ih
comma
id|version
)paren
suffix:semicolon
id|set_le_ih_k_offset
(paren
id|ih
comma
id|offset
)paren
suffix:semicolon
id|set_le_ih_k_type
(paren
id|ih
comma
id|type
)paren
suffix:semicolon
id|put_ih_item_len
c_func
(paren
id|ih
comma
id|length
)paren
suffix:semicolon
multiline_comment|/*    set_ih_free_space (ih, 0);*/
singleline_comment|// for directory items it is entry count, for directs and stat
singleline_comment|// datas - 0xffff, for indirects - 0
id|put_ih_entry_count
c_func
(paren
id|ih
comma
id|entry_count
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// FIXME: we might cache recently accessed indirect item
singleline_comment|// Ugh.  Not too eager for that....
singleline_comment|//  I cut the code until such time as I see a convincing argument (benchmark).
singleline_comment|// I don&squot;t want a bloated inode struct..., and I don&squot;t like code complexity....
multiline_comment|/* cutting the code is fine, since it really isn&squot;t in use yet and is easy&n;** to add back in.  But, Vladimir has a really good idea here.  Think&n;** about what happens for reading a file.  For each page,&n;** The VFS layer calls reiserfs_readpage, who searches the tree to find&n;** an indirect item.  This indirect item has X number of pointers, where&n;** X is a big number if we&squot;ve done the block allocation right.  But,&n;** we only use one or two of these pointers during each call to readpage,&n;** needlessly researching again later on.&n;**&n;** The size of the cache could be dynamic based on the size of the file.&n;**&n;** I&squot;d also like to see us cache the location the stat data item, since&n;** we are needlessly researching for that frequently.&n;**&n;** --chris&n;*/
multiline_comment|/* If this page has a file tail in it, and&n;** it was read in by get_block_create_0, the page data is valid,&n;** but tail is still sitting in a direct item, and we can&squot;t write to&n;** it.  So, look through this page, and check all the mapped buffers&n;** to make sure they have valid block numbers.  Any that don&squot;t need&n;** to be unmapped, so that block_prepare_write will correctly call&n;** reiserfs_get_block to convert the tail into an unformatted node&n;*/
DECL|function|fix_tail_page_for_writing
r_static
r_inline
r_void
id|fix_tail_page_for_writing
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|next
comma
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|page
op_logical_and
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_eq
l_int|0
)paren
(brace
id|reiserfs_unmap_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* reiserfs_get_block does not need to allocate a block only if it has been&n;   done already or non-hole position has been found in the indirect item */
DECL|function|allocation_needed
r_static
r_inline
r_int
id|allocation_needed
(paren
r_int
id|retval
comma
id|b_blocknr_t
id|allocated
comma
r_struct
id|item_head
op_star
id|ih
comma
id|__u32
op_star
id|item
comma
r_int
id|pos_in_item
)paren
(brace
r_if
c_cond
(paren
id|allocated
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|POSITION_FOUND
op_logical_and
id|is_indirect_le_ih
(paren
id|ih
)paren
op_logical_and
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|indirect_item_found
r_static
r_inline
r_int
id|indirect_item_found
(paren
r_int
id|retval
comma
r_struct
id|item_head
op_star
id|ih
)paren
(brace
r_return
(paren
id|retval
op_eq
id|POSITION_FOUND
)paren
op_logical_and
id|is_indirect_le_ih
(paren
id|ih
)paren
suffix:semicolon
)brace
DECL|function|set_block_dev_mapped
r_static
r_inline
r_void
id|set_block_dev_mapped
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
id|b_blocknr_t
id|block
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|map_bh
c_func
(paren
id|bh
comma
id|inode-&gt;i_sb
comma
id|block
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// files which were created in the earlier version can not be longer,
singleline_comment|// than 2 gb
singleline_comment|//
DECL|function|file_capable
r_static
r_int
id|file_capable
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
)paren
(brace
r_if
c_cond
(paren
id|get_inode_item_key_version
(paren
id|inode
)paren
op_ne
id|KEY_FORMAT_3_5
op_logical_or
singleline_comment|// it is new file.
id|block
OL
(paren
l_int|1
op_lshift
(paren
l_int|31
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
)paren
)paren
singleline_comment|// old file, but &squot;block&squot; is inside of 2gb
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|restart_transaction
multiline_comment|/*static*/
r_int
id|restart_transaction
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
r_int
id|len
op_assign
id|th-&gt;t_blocks_allocated
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_refcount
)paren
suffix:semicolon
multiline_comment|/* we cannot restart while nested */
r_if
c_cond
(paren
id|th-&gt;t_refcount
OG
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|pathrelse
c_func
(paren
id|path
)paren
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
id|err
op_assign
id|journal_end
c_func
(paren
id|th
comma
id|s
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|err
op_assign
id|journal_begin
c_func
(paren
id|th
comma
id|s
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
singleline_comment|// it is called by get_block when create == 0. Returns block number
singleline_comment|// for &squot;block&squot;-th logical block of file. When it hits direct item it
singleline_comment|// returns 0 (being called from bmap) or read direct item into piece
singleline_comment|// of page (bh_result)
singleline_comment|// Please improve the english/clarity in the comment above, as it is
singleline_comment|// hard to understand.
DECL|function|_get_block_create_0
r_static
r_int
id|_get_block_create_0
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|args
)paren
(brace
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_int
id|blocknr
suffix:semicolon
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
id|chars
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
singleline_comment|// prepare the key to look for the &squot;block&squot;-th block of file
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
(paren
id|loff_t
)paren
id|block
op_star
id|inode-&gt;i_sb-&gt;s_blocksize
op_plus
l_int|1
comma
id|TYPE_ANY
comma
l_int|3
)paren
suffix:semicolon
id|research
suffix:colon
r_if
c_cond
(paren
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
op_ne
id|POSITION_FOUND
)paren
(brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
singleline_comment|// We do not return -ENOENT if there is a hole but page is uptodate, because it means
singleline_comment|// That there is some MMAPED data associated with it that is yet to be written to disk.
r_if
c_cond
(paren
(paren
id|args
op_amp
id|GET_BLOCK_NO_HOLE
)paren
op_logical_and
op_logical_neg
id|PageUptodate
c_func
(paren
id|bh_result-&gt;b_page
)paren
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|ih
)paren
)paren
(brace
id|__u32
op_star
id|ind_item
op_assign
(paren
id|__u32
op_star
)paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* FIXME: here we could cache indirect item or part of it in&n;&t;   the inode to avoid search_by_key in case of subsequent&n;&t;   access to file */
id|blocknr
op_assign
id|get_block_num
c_func
(paren
id|ind_item
comma
id|path.pos_in_item
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blocknr
)paren
(brace
id|map_bh
c_func
(paren
id|bh_result
comma
id|inode-&gt;i_sb
comma
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path.pos_in_item
op_eq
(paren
(paren
id|ih_item_len
c_func
(paren
id|ih
)paren
op_div
id|UNFM_P_SIZE
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|set_buffer_boundary
c_func
(paren
id|bh_result
)paren
suffix:semicolon
)brace
)brace
r_else
singleline_comment|// We do not return -ENOENT if there is a hole but page is uptodate, because it means
singleline_comment|// That there is some MMAPED data associated with it that is yet to  be written to disk.
r_if
c_cond
(paren
(paren
id|args
op_amp
id|GET_BLOCK_NO_HOLE
)paren
op_logical_and
op_logical_neg
id|PageUptodate
c_func
(paren
id|bh_result-&gt;b_page
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
singleline_comment|// requested data are in direct item(s)
r_if
c_cond
(paren
op_logical_neg
(paren
id|args
op_amp
id|GET_BLOCK_READ_DIRECT
)paren
)paren
(brace
singleline_comment|// we are called by bmap. FIXME: we can not map block of file
singleline_comment|// when it is stored in direct item(s)
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/* if we&squot;ve got a direct item, and the buffer or page was uptodate,&n;    ** we don&squot;t want to pull data off disk again.  skip to the&n;    ** end, where we map the buffer and return&n;    */
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh_result
)paren
)paren
(brace
r_goto
id|finished
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;** grab_tail_page can trigger calls to reiserfs_get_block on up to date&n;&t;** pages without any buffers.  If the page is up to date, we don&squot;t want&n;&t;** read old data off disk.  Set the up to date bit on the buffer instead&n;&t;** and jump to the end&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|bh_result-&gt;b_page
op_logical_or
id|PageUptodate
c_func
(paren
id|bh_result-&gt;b_page
)paren
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh_result
)paren
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
singleline_comment|// read file tail into part of page
id|offset
op_assign
(paren
id|cpu_key_k_offset
c_func
(paren
op_amp
id|key
)paren
op_minus
l_int|1
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|copy_item_head
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* we only want to kmap if we are reading the tail into the page.&n;    ** this is not the common case, so we don&squot;t kmap until we are&n;    ** sure we need to.  But, this means the item might move if&n;    ** kmap schedules&n;    */
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|p
op_assign
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
r_goto
id|research
suffix:semicolon
)brace
)brace
id|p
op_add_assign
id|offset
suffix:semicolon
id|memset
(paren
id|p
comma
l_int|0
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_direct_le_ih
(paren
id|ih
)paren
)paren
(brace
id|BUG
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* make sure we don&squot;t read more bytes than actually exist in&n;&t;** the file.  This can happen in odd cases where i_size isn&squot;t&n;&t;** correct, and when direct item padding results in a few &n;&t;** extra bytes at the end of the direct item&n;&t;*/
r_if
c_cond
(paren
(paren
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_plus
id|path.pos_in_item
)paren
OG
id|inode-&gt;i_size
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_minus
l_int|1
op_plus
id|ih_item_len
c_func
(paren
id|ih
)paren
)paren
OG
id|inode-&gt;i_size
)paren
(brace
id|chars
op_assign
id|inode-&gt;i_size
op_minus
(paren
id|le_ih_k_offset
c_func
(paren
id|ih
)paren
op_minus
l_int|1
)paren
op_minus
id|path.pos_in_item
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|chars
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
op_minus
id|path.pos_in_item
suffix:semicolon
)brace
id|memcpy
(paren
id|p
comma
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
op_plus
id|path.pos_in_item
comma
id|chars
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
r_break
suffix:semicolon
id|p
op_add_assign
id|chars
suffix:semicolon
r_if
c_cond
(paren
id|PATH_LAST_POSITION
(paren
op_amp
id|path
)paren
op_ne
(paren
id|B_NR_ITEMS
(paren
id|bh
)paren
op_minus
l_int|1
)paren
)paren
singleline_comment|// we done, if read direct item is not the last item of
singleline_comment|// node FIXME: we could try to check right delimiting key
singleline_comment|// to see whether direct item continues in the right
singleline_comment|// neighbor or rely on i_size
r_break
suffix:semicolon
singleline_comment|// update key to look for the next piece
id|set_cpu_key_k_offset
(paren
op_amp
id|key
comma
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
op_plus
id|chars
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
op_ne
id|POSITION_FOUND
)paren
singleline_comment|// we read something from tail, even if now we got IO_ERROR
r_break
suffix:semicolon
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|finished
suffix:colon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
multiline_comment|/* this buffer has valid data, but isn&squot;t valid for io.  mapping it to&n;     * block #0 tells the rest of reiserfs it just has a tail in it&n;     */
id|map_bh
c_func
(paren
id|bh_result
comma
id|inode-&gt;i_sb
comma
l_int|0
)paren
suffix:semicolon
id|set_buffer_uptodate
(paren
id|bh_result
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// this is called to create file map. So, _get_block_create_0 will not
singleline_comment|// read direct item
DECL|function|reiserfs_bmap
r_static
r_int
id|reiserfs_bmap
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|file_capable
(paren
id|inode
comma
id|block
)paren
)paren
r_return
op_minus
id|EFBIG
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* do not read the direct item */
id|_get_block_create_0
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
l_int|0
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* special version of get_block that is only used by grab_tail_page right&n;** now.  It is sent to block_prepare_write, and when you try to get a&n;** block past the end of the file (or a block from a hole) it returns&n;** -ENOENT instead of a valid buffer.  block_prepare_write expects to&n;** be able to do i/o on the buffers returned, unless an error value&n;** is also returned.&n;** &n;** So, this allows block_prepare_write to be used for reading a single block&n;** in a page.  Where it does not produce a valid page for holes, or past the&n;** end of the file.  This turns out to be exactly what we need for reading&n;** tails for conversion.&n;**&n;** The point of the wrapper is forcing a certain value for create, even&n;** though the VFS layer is calling this function with create==1.  If you &n;** don&squot;t want to send create == GET_BLOCK_NO_HOLE to reiserfs_get_block, &n;** don&squot;t use this function.&n;*/
DECL|function|reiserfs_get_block_create_0
r_static
r_int
id|reiserfs_get_block_create_0
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_return
id|reiserfs_get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
id|GET_BLOCK_NO_HOLE
)paren
suffix:semicolon
)brace
multiline_comment|/* This is special helper for reiserfs_get_block in case we are executing&n;   direct_IO request. */
DECL|function|reiserfs_get_blocks_direct_io
r_static
r_int
id|reiserfs_get_blocks_direct_io
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|iblock
comma
r_int
r_int
id|max_blocks
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_int
id|ret
suffix:semicolon
id|bh_result-&gt;b_page
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We set the b_size before reiserfs_get_block call since it is&n;       referenced in convert_tail_for_hole() that may be called from&n;       reiserfs_get_block() */
id|bh_result-&gt;b_size
op_assign
(paren
l_int|1
op_lshift
id|inode-&gt;i_blkbits
)paren
suffix:semicolon
id|ret
op_assign
id|reiserfs_get_block
c_func
(paren
id|inode
comma
id|iblock
comma
id|bh_result
comma
id|create
op_or
id|GET_BLOCK_NO_DANGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* don&squot;t allow direct io onto tail pages */
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh_result
)paren
op_logical_and
id|bh_result-&gt;b_blocknr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* make sure future calls to the direct io funcs for this offset&n;        ** in the file fail by unmapping the buffer&n;        */
id|clear_buffer_mapped
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Possible unpacked tail. Flush the data before pages have&n;       disappeared */
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_pack_on_close_mask
)paren
(brace
r_int
id|err
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|reiserfs_commit_for_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_pack_on_close_mask
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
id|ret
op_assign
id|err
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;** helper function for when reiserfs_get_block is called for a hole&n;** but the file tail is still in a direct item&n;** bh_result is the buffer head for the hole&n;** tail_offset is the offset of the start of the tail in the file&n;**&n;** This calls prepare_write, which will start a new transaction&n;** you should not be in a transaction, or have any paths held when you&n;** call this.&n;*/
DECL|function|convert_tail_for_hole
r_static
r_int
id|convert_tail_for_hole
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
id|loff_t
id|tail_offset
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
r_int
r_int
id|tail_end
suffix:semicolon
r_int
r_int
id|tail_start
suffix:semicolon
r_struct
id|page
op_star
id|tail_page
suffix:semicolon
r_struct
id|page
op_star
id|hole_page
op_assign
id|bh_result-&gt;b_page
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tail_offset
op_amp
(paren
id|bh_result-&gt;b_size
op_minus
l_int|1
)paren
)paren
op_ne
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* always try to read until the end of the block */
id|tail_start
op_assign
id|tail_offset
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tail_end
op_assign
(paren
id|tail_start
op_or
(paren
id|bh_result-&gt;b_size
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|index
op_assign
id|tail_offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* hole_page can be zero in case of direct_io, we are sure&n;       that we cannot get here if we write with O_DIRECT into&n;       tail page */
r_if
c_cond
(paren
op_logical_neg
id|hole_page
op_logical_or
id|index
op_ne
id|hole_page-&gt;index
)paren
(brace
id|tail_page
op_assign
id|grab_cache_page
c_func
(paren
id|inode-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tail_page
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|tail_page
op_assign
id|hole_page
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t have to make sure the conversion did not happen while&n;    ** we were locking the page because anyone that could convert&n;    ** must first take i_sem.&n;    **&n;    ** We must fix the tail page for writing because it might have buffers&n;    ** that are mapped, but have a block number of 0.  This indicates tail&n;    ** data that has been read directly into the page, and block_prepare_write&n;    ** won&squot;t trigger a get_block in this case.&n;    */
id|fix_tail_page_for_writing
c_func
(paren
id|tail_page
)paren
suffix:semicolon
id|retval
op_assign
id|reiserfs_prepare_write
c_func
(paren
l_int|NULL
comma
id|tail_page
comma
id|tail_start
comma
id|tail_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|unlock
suffix:semicolon
multiline_comment|/* tail conversion might change the data in the page */
id|flush_dcache_page
c_func
(paren
id|tail_page
)paren
suffix:semicolon
id|retval
op_assign
id|reiserfs_commit_write
c_func
(paren
l_int|NULL
comma
id|tail_page
comma
id|tail_start
comma
id|tail_end
)paren
suffix:semicolon
id|unlock
suffix:colon
r_if
c_cond
(paren
id|tail_page
op_ne
id|hole_page
)paren
(brace
id|unlock_page
c_func
(paren
id|tail_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|tail_page
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|_allocate_block
r_static
r_inline
r_int
id|_allocate_block
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
id|block
comma
r_struct
id|inode
op_star
id|inode
comma
id|b_blocknr_t
op_star
id|allocated_block_nr
comma
r_struct
id|path
op_star
id|path
comma
r_int
id|flags
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
macro_line|#ifdef REISERFS_PREALLOCATE
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|GET_BLOCK_NO_ISEM
)paren
)paren
(brace
r_return
id|reiserfs_new_unf_blocknrs2
c_func
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
id|path
comma
id|block
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|reiserfs_new_unf_blocknrs
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
id|path
comma
id|block
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_get_block
r_int
id|reiserfs_get_block
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_int
id|repeat
comma
id|retval
op_assign
l_int|0
suffix:semicolon
id|b_blocknr_t
id|allocated_block_nr
op_assign
l_int|0
suffix:semicolon
singleline_comment|// b_blocknr_t is (unsigned) 32 bit int
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|pos_in_item
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|unbh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
id|__u32
op_star
id|item
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
op_star
id|th
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* space reserved in transaction batch: &n;        . 3 balancings in direct-&gt;indirect conversion&n;        . 1 block involved into reiserfs_update_sd()&n;       XXX in practically impossible worst case direct2indirect()&n;       can incur (much) more than 3 balancings.&n;       quota update for user, group */
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
op_plus
l_int|1
op_plus
l_int|2
op_star
id|REISERFS_QUOTA_TRANS_BLOCKS
suffix:semicolon
r_int
id|version
suffix:semicolon
r_int
id|dangle
op_assign
l_int|1
suffix:semicolon
id|loff_t
id|new_offset
op_assign
(paren
(paren
(paren
id|loff_t
)paren
id|block
)paren
op_lshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* bad.... */
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|version
op_assign
id|get_inode_item_key_version
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
OL
l_int|0
)paren
(brace
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|file_capable
(paren
id|inode
comma
id|block
)paren
)paren
(brace
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
multiline_comment|/* if !create, we aren&squot;t changing the FS, so we don&squot;t need to&n;    ** log anything, so we don&squot;t need to start a transaction&n;    */
r_if
c_cond
(paren
op_logical_neg
(paren
id|create
op_amp
id|GET_BLOCK_CREATE
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* find number of block-th logical block of the file */
id|ret
op_assign
id|_get_block_create_0
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
id|create
op_or
id|GET_BLOCK_READ_DIRECT
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;     * if we&squot;re already in a transaction, make sure to close&n;     * any new transactions we start in this func&n;     */
r_if
c_cond
(paren
(paren
id|create
op_amp
id|GET_BLOCK_NO_DANGLE
)paren
op_logical_or
id|reiserfs_transaction_running
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
id|dangle
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If file is of such a size, that it might have a tail and tails are enabled&n;    ** we should mark it as possibly needing tail packing on close&n;    */
r_if
c_cond
(paren
(paren
id|have_large_tails
(paren
id|inode-&gt;i_sb
)paren
op_logical_and
id|inode-&gt;i_size
OL
id|i_block_size
(paren
id|inode
)paren
op_star
l_int|4
)paren
op_logical_or
(paren
id|have_small_tails
(paren
id|inode-&gt;i_sb
)paren
op_logical_and
id|inode-&gt;i_size
OL
id|i_block_size
c_func
(paren
id|inode
)paren
)paren
)paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_pack_on_close_mask
suffix:semicolon
multiline_comment|/* set the key of the first byte in the &squot;block&squot;-th block of file */
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
id|new_offset
comma
id|TYPE_ANY
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_offset
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
OG
id|inode-&gt;i_size
)paren
(brace
id|start_trans
suffix:colon
id|th
op_assign
id|reiserfs_persistent_transaction
c_func
(paren
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|research
suffix:colon
id|retval
op_assign
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|path.pos_in_item
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|copy_item_head
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allocation_needed
(paren
id|retval
comma
id|allocated_block_nr
comma
id|ih
comma
id|item
comma
id|pos_in_item
)paren
)paren
(brace
multiline_comment|/* we have to allocate block for the unformatted node */
r_if
c_cond
(paren
op_logical_neg
id|th
)paren
(brace
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_goto
id|start_trans
suffix:semicolon
)brace
id|repeat
op_assign
id|_allocate_block
c_func
(paren
id|th
comma
id|block
comma
id|inode
comma
op_amp
id|allocated_block_nr
comma
op_amp
id|path
comma
id|create
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repeat
op_eq
id|NO_DISK_SPACE
op_logical_or
id|repeat
op_eq
id|QUOTA_EXCEEDED
)paren
(brace
multiline_comment|/* restart the transaction to give the journal a chance to free&n;&t;    ** some blocks.  releases the path, so we have to go back to&n;&t;    ** research if we succeed on the second try&n;&t;    */
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
op_assign
l_int|1
suffix:semicolon
id|retval
op_assign
id|restart_transaction
c_func
(paren
id|th
comma
id|inode
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|failure
suffix:semicolon
id|repeat
op_assign
id|_allocate_block
c_func
(paren
id|th
comma
id|block
comma
id|inode
comma
op_amp
id|allocated_block_nr
comma
l_int|NULL
comma
id|create
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repeat
op_ne
id|NO_DISK_SPACE
op_logical_and
id|repeat
op_ne
id|QUOTA_EXCEEDED
)paren
(brace
r_goto
id|research
suffix:semicolon
)brace
r_if
c_cond
(paren
id|repeat
op_eq
id|QUOTA_EXCEEDED
)paren
id|retval
op_assign
op_minus
id|EDQUOT
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
r_goto
id|research
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|indirect_item_found
(paren
id|retval
comma
id|ih
)paren
)paren
(brace
id|b_blocknr_t
id|unfm_ptr
suffix:semicolon
multiline_comment|/* &squot;block&squot;-th block is in the file already (there is&n;&t;   corresponding cell in some indirect item). But it may be&n;&t;   zero unformatted node pointer (hole) */
id|unfm_ptr
op_assign
id|get_block_num
(paren
id|item
comma
id|pos_in_item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unfm_ptr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* use allocated block to plug the hole */
id|reiserfs_prepare_for_journal
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
id|set_buffer_new
c_func
(paren
id|bh_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh_result
)paren
op_logical_and
id|reiserfs_data_ordered
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
id|reiserfs_add_ordered_list
c_func
(paren
id|inode
comma
id|bh_result
)paren
suffix:semicolon
id|put_block_num
c_func
(paren
id|item
comma
id|pos_in_item
comma
id|allocated_block_nr
)paren
suffix:semicolon
id|unfm_ptr
op_assign
id|allocated_block_nr
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
)brace
id|set_block_dev_mapped
c_func
(paren
id|bh_result
comma
id|unfm_ptr
comma
id|inode
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dangle
op_logical_and
id|th
)paren
id|retval
op_assign
id|reiserfs_end_persistent_transaction
c_func
(paren
id|th
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* the item was found, so new blocks were not added to the file&n;&t;** there is no need to make sure the inode is updated with this &n;&t;** transaction&n;&t;*/
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|th
)paren
(brace
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_goto
id|start_trans
suffix:semicolon
)brace
multiline_comment|/* desired position is not found or is in the direct item. We have&n;       to append file with holes up to &squot;block&squot;-th block converting&n;       direct items to indirect one if necessary */
id|done
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|is_statdata_le_ih
(paren
id|ih
)paren
)paren
(brace
id|__u32
id|unp
op_assign
l_int|0
suffix:semicolon
r_struct
id|cpu_key
id|tmp_key
suffix:semicolon
multiline_comment|/* indirect item has to be inserted */
id|make_le_item_head
(paren
op_amp
id|tmp_ih
comma
op_amp
id|key
comma
id|version
comma
l_int|1
comma
id|TYPE_INDIRECT
comma
id|UNFM_P_SIZE
comma
l_int|0
multiline_comment|/* free_space */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* we are going to add &squot;block&squot;-th block to the file. Use&n;&t;&t;   allocated block for that */
id|unp
op_assign
id|cpu_to_le32
(paren
id|allocated_block_nr
)paren
suffix:semicolon
id|set_block_dev_mapped
(paren
id|bh_result
comma
id|allocated_block_nr
comma
id|inode
)paren
suffix:semicolon
id|set_buffer_new
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
id|tmp_key
op_assign
id|key
suffix:semicolon
singleline_comment|// ;)
id|set_cpu_key_k_offset
(paren
op_amp
id|tmp_key
comma
l_int|1
)paren
suffix:semicolon
id|PATH_LAST_POSITION
c_func
(paren
op_amp
id|path
)paren
op_increment
suffix:semicolon
id|retval
op_assign
id|reiserfs_insert_item
(paren
id|th
comma
op_amp
id|path
comma
op_amp
id|tmp_key
comma
op_amp
id|tmp_ih
comma
id|inode
comma
(paren
r_char
op_star
)paren
op_amp
id|unp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|reiserfs_free_block
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
singleline_comment|// retval == -ENOSPC, -EDQUOT or -EIO or -EEXIST
)brace
singleline_comment|//mark_tail_converted (inode);
)brace
r_else
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* direct item has to be converted */
id|loff_t
id|tail_offset
suffix:semicolon
id|tail_offset
op_assign
(paren
(paren
id|le_ih_k_offset
(paren
id|ih
)paren
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tail_offset
op_eq
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
)paren
(brace
multiline_comment|/* direct item we just found fits into block we have&n;                   to map. Convert it into unformatted node: use&n;                   bh_result for the conversion */
id|set_block_dev_mapped
(paren
id|bh_result
comma
id|allocated_block_nr
comma
id|inode
)paren
suffix:semicolon
id|unbh
op_assign
id|bh_result
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we have to padd file tail stored in direct item(s)&n;&t;&t;   up to block size and convert it to unformatted&n;&t;&t;   node. FIXME: this should also get into page cache */
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ugly, but we can only end the transaction if&n;&t;&t; * we aren&squot;t nested&n;&t;&t; */
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_refcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_refcount
op_eq
l_int|1
)paren
(brace
id|retval
op_assign
id|reiserfs_end_persistent_transaction
c_func
(paren
id|th
)paren
suffix:semicolon
id|th
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|failure
suffix:semicolon
)brace
id|retval
op_assign
id|convert_tail_for_hole
c_func
(paren
id|inode
comma
id|bh_result
comma
id|tail_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENOSPC
)paren
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;clm-6004: convert tail failed inode %lu, error %d&quot;
comma
id|inode-&gt;i_ino
comma
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|allocated_block_nr
)paren
(brace
multiline_comment|/* the bitmap, the super, and the stat data == 3 */
r_if
c_cond
(paren
op_logical_neg
id|th
)paren
id|th
op_assign
id|reiserfs_persistent_transaction
c_func
(paren
id|inode-&gt;i_sb
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th
)paren
id|reiserfs_free_block
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
l_int|1
)paren
suffix:semicolon
)brace
r_goto
id|failure
suffix:semicolon
)brace
r_goto
id|research
suffix:semicolon
)brace
id|retval
op_assign
id|direct2indirect
(paren
id|th
comma
id|inode
comma
op_amp
id|path
comma
id|unbh
comma
id|tail_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|reiserfs_unmap_buffer
c_func
(paren
id|unbh
)paren
suffix:semicolon
id|reiserfs_free_block
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* it is important the set_buffer_uptodate is done after&n;&t;    ** the direct2indirect.  The buffer might contain valid&n;&t;    ** data newer than the data on disk (read by readpage, changed,&n;&t;    ** and then sent here by writepage).  direct2indirect needs&n;&t;    ** to know if unbh was already up to date, so it can decide&n;&t;    ** if the data in unbh needs to be replaced with data from&n;&t;    ** the disk&n;&t;    */
id|set_buffer_uptodate
(paren
id|unbh
)paren
suffix:semicolon
multiline_comment|/* unbh-&gt;b_page == NULL in case of DIRECT_IO request, this means&n;&t;       buffer will disappear shortly, so it should not be added to&n;&t;     */
r_if
c_cond
(paren
id|unbh-&gt;b_page
)paren
(brace
multiline_comment|/* we&squot;ve converted the tail, so we must&n;&t;&t;** flush unbh before the transaction commits&n;&t;&t;*/
id|reiserfs_add_tail_list
c_func
(paren
id|inode
comma
id|unbh
)paren
suffix:semicolon
multiline_comment|/* mark it dirty now to prevent commit_write from adding&n;&t;&t;** this buffer to the inode&squot;s dirty buffer list&n;&t;&t;*/
multiline_comment|/*&n;&t;&t; * AKPM: changed __mark_buffer_dirty to mark_buffer_dirty().&n;&t;&t; * It&squot;s still atomic, but it sets the page dirty too,&n;&t;&t; * which makes it eligible for writeback at any time by the&n;&t;&t; * VM (which was also the case with __mark_buffer_dirty())&n;&t;&t; */
id|mark_buffer_dirty
c_func
(paren
id|unbh
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* append indirect item with holes if needed, when appending&n;&t;       pointer to &squot;block&squot;-th block use block, which is already&n;&t;       allocated */
r_struct
id|cpu_key
id|tmp_key
suffix:semicolon
id|unp_t
id|unf_single
op_assign
l_int|0
suffix:semicolon
singleline_comment|// We use this in case we need to allocate only
singleline_comment|// one block which is a fastpath
id|unp_t
op_star
id|un
suffix:semicolon
id|__u64
id|max_to_insert
op_assign
id|MAX_ITEM_LEN
c_func
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
op_div
id|UNFM_P_SIZE
suffix:semicolon
id|__u64
id|blocks_needed
suffix:semicolon
id|RFALSE
c_func
(paren
id|pos_in_item
op_ne
id|ih_item_len
c_func
(paren
id|ih
)paren
op_div
id|UNFM_P_SIZE
comma
l_string|&quot;vs-804: invalid position for append&quot;
)paren
suffix:semicolon
multiline_comment|/* indirect item has to be appended, set up key of that position */
id|make_cpu_key
(paren
op_amp
id|tmp_key
comma
id|inode
comma
id|le_key_k_offset
(paren
id|version
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
op_plus
id|op_bytes_number
(paren
id|ih
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
comma
singleline_comment|//pos_in_item * inode-&gt;i_sb-&gt;s_blocksize,
id|TYPE_INDIRECT
comma
l_int|3
)paren
suffix:semicolon
singleline_comment|// key type is unimportant
id|blocks_needed
op_assign
l_int|1
op_plus
(paren
(paren
id|cpu_key_k_offset
(paren
op_amp
id|key
)paren
op_minus
id|cpu_key_k_offset
(paren
op_amp
id|tmp_key
)paren
)paren
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|blocks_needed
OL
l_int|0
comma
l_string|&quot;green-805: invalid offset&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks_needed
op_eq
l_int|1
)paren
(brace
id|un
op_assign
op_amp
id|unf_single
suffix:semicolon
)brace
r_else
(brace
id|un
op_assign
id|kmalloc
c_func
(paren
id|min
c_func
(paren
id|blocks_needed
comma
id|max_to_insert
)paren
op_star
id|UNFM_P_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
singleline_comment|// We need to avoid scheduling.
r_if
c_cond
(paren
op_logical_neg
id|un
)paren
(brace
id|un
op_assign
op_amp
id|unf_single
suffix:semicolon
id|blocks_needed
op_assign
l_int|1
suffix:semicolon
id|max_to_insert
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
id|un
comma
l_int|0
comma
id|UNFM_P_SIZE
op_star
id|min
c_func
(paren
id|blocks_needed
comma
id|max_to_insert
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks_needed
op_le
id|max_to_insert
)paren
(brace
multiline_comment|/* we are going to add target block to the file. Use allocated&n;&t;&t;   block for that */
id|un
(braket
id|blocks_needed
op_minus
l_int|1
)braket
op_assign
id|cpu_to_le32
(paren
id|allocated_block_nr
)paren
suffix:semicolon
id|set_block_dev_mapped
(paren
id|bh_result
comma
id|allocated_block_nr
comma
id|inode
)paren
suffix:semicolon
id|set_buffer_new
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* paste hole to the indirect item */
multiline_comment|/* If kmalloc failed, max_to_insert becomes zero and it means we&n;&t;&t;   only have space for one block */
id|blocks_needed
op_assign
id|max_to_insert
ques
c_cond
id|max_to_insert
suffix:colon
l_int|1
suffix:semicolon
)brace
id|retval
op_assign
id|reiserfs_paste_into_item
(paren
id|th
comma
op_amp
id|path
comma
op_amp
id|tmp_key
comma
id|inode
comma
(paren
r_char
op_star
)paren
id|un
comma
id|UNFM_P_SIZE
op_star
id|blocks_needed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks_needed
op_ne
l_int|1
)paren
id|kfree
c_func
(paren
id|un
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|reiserfs_free_block
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
multiline_comment|/* We need to mark new file size in case this function will be&n;&t;&t;   interrupted/aborted later on. And we may do this only for&n;&t;&t;   holes. */
id|inode-&gt;i_size
op_add_assign
id|inode-&gt;i_sb-&gt;s_blocksize
op_star
id|blocks_needed
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|done
op_eq
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* this loop could log more blocks than we had originally asked&n;&t;** for.  So, we have to allow the transaction to end if it is&n;&t;** too big or too full.  Update the inode so things are &n;&t;** consistent if we crash before the function returns&n;&t;**&n;&t;** release the path so that anybody waiting on the path before&n;&t;** ending their transaction will be able to continue.&n;&t;*/
r_if
c_cond
(paren
id|journal_transaction_should_end
c_func
(paren
id|th
comma
id|th-&gt;t_blocks_allocated
)paren
)paren
(brace
id|retval
op_assign
id|restart_transaction
c_func
(paren
id|th
comma
id|inode
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|failure
suffix:semicolon
)brace
multiline_comment|/* inserting indirect pointers for a hole can take a &n;&t;** long time.  reschedule if needed&n;&t;*/
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|POSITION_FOUND
)paren
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-825: reiserfs_get_block: &quot;
l_string|&quot;%K should not be found&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|allocated_block_nr
)paren
id|reiserfs_free_block
(paren
id|th
comma
id|inode
comma
id|allocated_block_nr
comma
l_int|1
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_goto
id|failure
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|path.pos_in_item
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|failure
suffix:colon
r_if
c_cond
(paren
id|th
op_logical_and
(paren
op_logical_neg
id|dangle
op_logical_or
(paren
id|retval
op_logical_and
op_logical_neg
id|th-&gt;t_trans_id
)paren
)paren
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_trans_id
)paren
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
id|err
op_assign
id|reiserfs_end_persistent_transaction
c_func
(paren
id|th
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|retval
op_assign
id|err
suffix:semicolon
)brace
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
DECL|function|reiserfs_readpages
id|reiserfs_readpages
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|list_head
op_star
id|pages
comma
r_int
id|nr_pages
)paren
(brace
r_return
id|mpage_readpages
c_func
(paren
id|mapping
comma
id|pages
comma
id|nr_pages
comma
id|reiserfs_get_block
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute real number of used bytes by file&n; * Following three functions can go away when we&squot;ll have enough space in stat item&n; */
DECL|function|real_space_diff
r_static
r_int
id|real_space_diff
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|sd_size
)paren
(brace
r_int
id|bytes
suffix:semicolon
id|loff_t
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
id|sd_size
suffix:semicolon
multiline_comment|/* End of file is also in full block with indirect reference, so round&n;    ** up to the next block.&n;    **&n;    ** there is just no way to know if the tail is actually packed&n;    ** on the file, so we have to assume it isn&squot;t.  When we pack the&n;    ** tail, we add 4 bytes to pretend there really is an unformatted&n;    ** node pointer&n;    */
id|bytes
op_assign
(paren
(paren
id|inode-&gt;i_size
op_plus
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
op_star
id|UNFM_P_SIZE
op_plus
id|sd_size
suffix:semicolon
r_return
id|bytes
suffix:semicolon
)brace
DECL|function|to_real_used_space
r_static
r_inline
id|loff_t
id|to_real_used_space
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|ulong
id|blocks
comma
r_int
id|sd_size
)paren
(brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_return
id|inode-&gt;i_size
op_plus
(paren
id|loff_t
)paren
(paren
id|real_space_diff
c_func
(paren
id|inode
comma
id|sd_size
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
(paren
id|loff_t
)paren
id|real_space_diff
c_func
(paren
id|inode
comma
id|sd_size
)paren
)paren
op_plus
(paren
(paren
(paren
id|loff_t
)paren
id|blocks
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute number of blocks used by file in ReiserFS counting */
DECL|function|to_fake_used_blocks
r_static
r_inline
id|ulong
id|to_fake_used_blocks
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|sd_size
)paren
(brace
id|loff_t
id|bytes
op_assign
id|inode_get_bytes
c_func
(paren
id|inode
)paren
suffix:semicolon
id|loff_t
id|real_space
op_assign
id|real_space_diff
c_func
(paren
id|inode
comma
id|sd_size
)paren
suffix:semicolon
multiline_comment|/* keeps fsck and non-quota versions of reiserfs happy */
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|bytes
op_add_assign
(paren
id|loff_t
)paren
l_int|511
suffix:semicolon
)brace
multiline_comment|/* files from before the quota patch might i_blocks such that&n;    ** bytes &lt; real_space.  Deal with that here to prevent it from&n;    ** going negative.&n;    */
r_if
c_cond
(paren
id|bytes
OL
id|real_space
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|bytes
op_minus
id|real_space
)paren
op_rshift
l_int|9
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// BAD: new directories have stat data of new type and all other items
singleline_comment|// of old type. Version stored in the inode says about body items, so
singleline_comment|// in update_stat_data we can not rely on inode, but have to check
singleline_comment|// item version directly
singleline_comment|//
singleline_comment|// called by read_locked_inode
DECL|function|init_inode
r_static
r_void
id|init_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
id|__u32
id|rdev
suffix:semicolon
singleline_comment|//int version = ITEM_VERSION_1;
id|bh
op_assign
id|PATH_PLAST_BUFFER
(paren
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|PATH_PITEM_HEAD
(paren
id|path
)paren
suffix:semicolon
id|copy_key
(paren
id|INODE_PKEY
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|reiserfs_default_io_size
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_list
)paren
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_jl
op_assign
l_int|NULL
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_access
op_assign
l_int|NULL
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_default
op_assign
l_int|NULL
suffix:semicolon
id|init_rwsem
(paren
op_amp
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat_data_v1
(paren
id|ih
)paren
)paren
(brace
r_struct
id|stat_data_v1
op_star
id|sd
op_assign
(paren
r_struct
id|stat_data_v1
op_star
)paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_5
)paren
suffix:semicolon
id|set_inode_sd_version
(paren
id|inode
comma
id|STAT_DATA_V1
)paren
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|sd_v1_mode
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
id|sd_v1_nlink
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|sd_v1_uid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|sd_v1_gid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|sd_v1_size
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_atime.tv_sec
op_assign
id|sd_v1_atime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_mtime.tv_sec
op_assign
id|sd_v1_mtime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_ctime.tv_sec
op_assign
id|sd_v1_ctime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_atime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_ctime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_mtime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
id|sd_v1_blocks
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
id|blocks
op_assign
(paren
id|inode-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
suffix:semicolon
id|blocks
op_assign
id|_ROUND_UP
(paren
id|blocks
comma
id|inode-&gt;i_sb-&gt;s_blocksize
op_rshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_blocks
OG
id|blocks
)paren
(brace
singleline_comment|// there was a bug in &lt;=3.5.23 when i_blocks could take negative
singleline_comment|// values. Starting from 3.5.17 this value could even be stored in
singleline_comment|// stat data. For such files we set i_blocks based on file
singleline_comment|// size. Just 2 notes: this can be wrong for sparce files. On-disk value will be
singleline_comment|// only updated if file&squot;s inode will ever change
id|inode-&gt;i_blocks
op_assign
id|blocks
suffix:semicolon
)brace
id|rdev
op_assign
id|sd_v1_rdev
c_func
(paren
id|sd
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
op_assign
id|sd_v1_first_direct_byte
c_func
(paren
id|sd
)paren
suffix:semicolon
multiline_comment|/* an early bug in the quota code can give us an odd number for the&n;&t;** block count.  This is incorrect, fix it here.&n;&t;*/
r_if
c_cond
(paren
id|inode-&gt;i_blocks
op_amp
l_int|1
)paren
(brace
id|inode-&gt;i_blocks
op_increment
suffix:semicolon
)brace
id|inode_set_bytes
c_func
(paren
id|inode
comma
id|to_real_used_space
c_func
(paren
id|inode
comma
id|inode-&gt;i_blocks
comma
id|SD_V1_SIZE
)paren
)paren
suffix:semicolon
multiline_comment|/* nopack is initially zero for v1 objects. For v2 objects,&n;&t;   nopack is initialised from sd_attrs */
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_nopack_mask
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// new stat data found, but object may have old items
singleline_comment|// (directories and symlinks)
r_struct
id|stat_data
op_star
id|sd
op_assign
(paren
r_struct
id|stat_data
op_star
)paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|sd_v2_mode
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
id|sd_v2_nlink
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|sd_v2_uid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|sd_v2_size
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|sd_v2_gid
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_mtime.tv_sec
op_assign
id|sd_v2_mtime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_atime.tv_sec
op_assign
id|sd_v2_atime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_ctime.tv_sec
op_assign
id|sd_v2_ctime
c_func
(paren
id|sd
)paren
suffix:semicolon
id|inode-&gt;i_ctime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_mtime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_atime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
id|sd_v2_blocks
c_func
(paren
id|sd
)paren
suffix:semicolon
id|rdev
op_assign
id|sd_v2_rdev
c_func
(paren
id|sd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_mode
)paren
)paren
(brace
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
)brace
r_else
id|inode-&gt;i_generation
op_assign
id|sd_v2_generation
c_func
(paren
id|sd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISLNK
(paren
id|inode-&gt;i_mode
)paren
)paren
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_5
)paren
suffix:semicolon
r_else
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_6
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
op_assign
l_int|0
suffix:semicolon
id|set_inode_sd_version
(paren
id|inode
comma
id|STAT_DATA_V2
)paren
suffix:semicolon
id|inode_set_bytes
c_func
(paren
id|inode
comma
id|to_real_used_space
c_func
(paren
id|inode
comma
id|inode-&gt;i_blocks
comma
id|SD_V2_SIZE
)paren
)paren
suffix:semicolon
multiline_comment|/* read persistent inode attributes from sd and initalise&n;&t;   generic inode flags from them */
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_attrs
op_assign
id|sd_v2_attrs
c_func
(paren
id|sd
)paren
suffix:semicolon
id|sd_attrs_to_i_attrs
c_func
(paren
id|sd_v2_attrs
c_func
(paren
id|sd
)paren
comma
id|inode
)paren
suffix:semicolon
)brace
id|pathrelse
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_file_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|reiserfs_file_operations
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|reiserfs_address_space_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|reiserfs_dir_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_symlink_inode_operations
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|reiserfs_address_space_operations
suffix:semicolon
)brace
r_else
(brace
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_special_inode_operations
suffix:semicolon
id|init_special_inode
c_func
(paren
id|inode
comma
id|inode-&gt;i_mode
comma
id|new_decode_dev
c_func
(paren
id|rdev
)paren
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// update new stat data with inode fields
DECL|function|inode2sd
r_static
r_void
id|inode2sd
(paren
r_void
op_star
id|sd
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|size
)paren
(brace
r_struct
id|stat_data
op_star
id|sd_v2
op_assign
(paren
r_struct
id|stat_data
op_star
)paren
id|sd
suffix:semicolon
id|__u16
id|flags
suffix:semicolon
id|set_sd_v2_mode
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_mode
)paren
suffix:semicolon
id|set_sd_v2_nlink
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_nlink
)paren
suffix:semicolon
id|set_sd_v2_uid
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_uid
)paren
suffix:semicolon
id|set_sd_v2_size
c_func
(paren
id|sd_v2
comma
id|size
)paren
suffix:semicolon
id|set_sd_v2_gid
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_gid
)paren
suffix:semicolon
id|set_sd_v2_mtime
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_mtime.tv_sec
)paren
suffix:semicolon
id|set_sd_v2_atime
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_atime.tv_sec
)paren
suffix:semicolon
id|set_sd_v2_ctime
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_ctime.tv_sec
)paren
suffix:semicolon
id|set_sd_v2_blocks
c_func
(paren
id|sd_v2
comma
id|to_fake_used_blocks
c_func
(paren
id|inode
comma
id|SD_V2_SIZE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|set_sd_v2_rdev
c_func
(paren
id|sd_v2
comma
id|new_encode_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_else
id|set_sd_v2_generation
c_func
(paren
id|sd_v2
comma
id|inode-&gt;i_generation
)paren
suffix:semicolon
id|flags
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_attrs
suffix:semicolon
id|i_attrs_to_sd_attrs
c_func
(paren
id|inode
comma
op_amp
id|flags
)paren
suffix:semicolon
id|set_sd_v2_attrs
c_func
(paren
id|sd_v2
comma
id|flags
)paren
suffix:semicolon
)brace
singleline_comment|// used to copy inode&squot;s fields to old stat data
DECL|function|inode2sd_v1
r_static
r_void
id|inode2sd_v1
(paren
r_void
op_star
id|sd
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|size
)paren
(brace
r_struct
id|stat_data_v1
op_star
id|sd_v1
op_assign
(paren
r_struct
id|stat_data_v1
op_star
)paren
id|sd
suffix:semicolon
id|set_sd_v1_mode
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_mode
)paren
suffix:semicolon
id|set_sd_v1_uid
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_uid
)paren
suffix:semicolon
id|set_sd_v1_gid
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_gid
)paren
suffix:semicolon
id|set_sd_v1_nlink
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_nlink
)paren
suffix:semicolon
id|set_sd_v1_size
c_func
(paren
id|sd_v1
comma
id|size
)paren
suffix:semicolon
id|set_sd_v1_atime
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_atime.tv_sec
)paren
suffix:semicolon
id|set_sd_v1_ctime
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_ctime.tv_sec
)paren
suffix:semicolon
id|set_sd_v1_mtime
c_func
(paren
id|sd_v1
comma
id|inode-&gt;i_mtime.tv_sec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|set_sd_v1_rdev
c_func
(paren
id|sd_v1
comma
id|new_encode_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_else
id|set_sd_v1_blocks
c_func
(paren
id|sd_v1
comma
id|to_fake_used_blocks
c_func
(paren
id|inode
comma
id|SD_V1_SIZE
)paren
)paren
suffix:semicolon
singleline_comment|// Sigh. i_first_direct_byte is back
id|set_sd_v1_first_direct_byte
c_func
(paren
id|sd_v1
comma
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
)paren
suffix:semicolon
)brace
multiline_comment|/* NOTE, you must prepare the buffer head before sending it here,&n;** and then log it after the call&n;*/
DECL|function|update_stat_data
r_static
r_void
id|update_stat_data
(paren
r_struct
id|path
op_star
id|path
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
id|bh
op_assign
id|PATH_PLAST_BUFFER
(paren
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|PATH_PITEM_HEAD
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_statdata_le_ih
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-13065: update_stat_data: key %k, found item %h&quot;
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat_data_v1
(paren
id|ih
)paren
)paren
(brace
singleline_comment|// path points to old stat data
id|inode2sd_v1
(paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
comma
id|inode
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|inode2sd
(paren
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
comma
id|inode
comma
id|size
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|reiserfs_update_sd_size
r_void
id|reiserfs_update_sd_size
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|size
)paren
(brace
r_struct
id|cpu_key
id|key
suffix:semicolon
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
l_int|3
)paren
suffix:semicolon
singleline_comment|//key type is unimportant
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|pos
suffix:semicolon
multiline_comment|/* look for the object&squot;s stat data */
id|retval
op_assign
id|search_item
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-13050: reiserfs_update_sd: &quot;
l_string|&quot;i/o failure occurred trying to update %K stat data&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_NOT_FOUND
)paren
(brace
id|pos
op_assign
id|PATH_LAST_POSITION
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_eq
l_int|0
)paren
(brace
multiline_comment|/*reiserfs_warning (inode-&gt;i_sb, &quot;vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found&quot;);*/
r_return
suffix:semicolon
)brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-13060: reiserfs_update_sd: &quot;
l_string|&quot;stat data of object %k (nlink == %d) not found (pos %d)&quot;
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|inode-&gt;i_nlink
comma
id|pos
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* sigh, prepare_for_journal might schedule.  When it schedules the&n;&t;** FS might change.  We have to detect that, and loop back to the&n;&t;** search if the stat data item has moved&n;&t;*/
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|copy_item_head
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
c_func
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* Stat_data item has been moved after scheduling. */
)brace
r_break
suffix:semicolon
)brace
id|update_stat_data
(paren
op_amp
id|path
comma
id|inode
comma
id|size
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|th-&gt;t_super
comma
id|bh
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* reiserfs_read_locked_inode is called to read the inode off disk, and it&n;** does a make_bad_inode when things go wrong.  But, we need to make sure&n;** and clear the key in the private portion of the inode, otherwise a&n;** corresponding iput might try to delete whatever object the inode last&n;** represented.&n;*/
DECL|function|reiserfs_make_bad_inode
r_static
r_void
id|reiserfs_make_bad_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|memset
c_func
(paren
id|INODE_PKEY
c_func
(paren
id|inode
)paren
comma
l_int|0
comma
id|KEY_SIZE
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// initially this function was derived from minix or ext2&squot;s analog and
singleline_comment|// evolved as the prototype did
singleline_comment|//
DECL|function|reiserfs_init_locked_inode
r_int
id|reiserfs_init_locked_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_void
op_star
id|p
)paren
(brace
r_struct
id|reiserfs_iget_args
op_star
id|args
op_assign
(paren
r_struct
id|reiserfs_iget_args
op_star
)paren
id|p
suffix:semicolon
id|inode-&gt;i_ino
op_assign
id|args-&gt;objectid
suffix:semicolon
id|INODE_PKEY
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
op_assign
id|cpu_to_le32
c_func
(paren
id|args-&gt;dirid
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* looks for stat data in the tree, and fills up the fields of in-core&n;   inode stat data fields */
DECL|function|reiserfs_read_locked_inode
r_void
id|reiserfs_read_locked_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|reiserfs_iget_args
op_star
id|args
)paren
(brace
id|INITIALIZE_PATH
(paren
id|path_to_sd
)paren
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_int
r_int
id|dirino
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|dirino
op_assign
id|args-&gt;dirid
suffix:semicolon
multiline_comment|/* set version 1, version 2 could be used too, because stat data&n;       key is the same in both versions */
id|key.version
op_assign
id|KEY_FORMAT_3_5
suffix:semicolon
id|key.on_disk_key.k_dir_id
op_assign
id|dirino
suffix:semicolon
id|key.on_disk_key.k_objectid
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|key.on_disk_key.u.k_offset_v1.k_offset
op_assign
id|SD_OFFSET
suffix:semicolon
id|key.on_disk_key.u.k_offset_v1.k_uniqueness
op_assign
id|SD_UNIQUENESS
suffix:semicolon
multiline_comment|/* look for the object&squot;s stat data */
id|retval
op_assign
id|search_item
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path_to_sd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-13070: reiserfs_read_locked_inode: &quot;
l_string|&quot;i/o failure occurred trying to find stat data of %K&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
id|reiserfs_make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_ne
id|ITEM_FOUND
)paren
(brace
multiline_comment|/* a stale NFS handle can trigger this without it being an error */
id|pathrelse
(paren
op_amp
id|path_to_sd
)paren
suffix:semicolon
id|reiserfs_make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|init_inode
(paren
id|inode
comma
op_amp
id|path_to_sd
)paren
suffix:semicolon
multiline_comment|/* It is possible that knfsd is trying to access inode of a file&n;       that is being removed from the disk by some other thread. As we&n;       update sd on unlink all that is required is to check for nlink&n;       here. This bug was first found by Sizif when debugging&n;       SquidNG/Butterfly, forgotten, and found again after Philippe&n;       Gramoulle &lt;philippe.gramoulle@mmania.com&gt; reproduced it. &n;&n;       More logical fix would require changes in fs/inode.c:iput() to&n;       remove inode from hash-table _after_ fs cleaned disk stuff up and&n;       in iget() to return NULL if I_FREEING inode is found in&n;       hash-table. */
multiline_comment|/* Currently there is one place where it&squot;s ok to meet inode with&n;       nlink==0: processing of open-unlinked and half-truncated files&n;       during mount (fs/reiserfs/super.c:finish_unfinished()). */
r_if
c_cond
(paren
(paren
id|inode
op_member_access_from_pointer
id|i_nlink
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|REISERFS_SB
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_sb
)paren
op_member_access_from_pointer
id|s_is_unlinked_ok
)paren
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-13075: reiserfs_read_locked_inode: &quot;
l_string|&quot;dead inode read from disk %K. &quot;
l_string|&quot;This is likely to be race with knfsd. Ignore&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
id|reiserfs_make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_sd
)paren
suffix:semicolon
multiline_comment|/* init inode should be relsing */
)brace
multiline_comment|/**&n; * reiserfs_find_actor() - &quot;find actor&quot; reiserfs supplies to iget5_locked().&n; *&n; * @inode:    inode from hash table to check&n; * @opaque:   &quot;cookie&quot; passed to iget5_locked(). This is &amp;reiserfs_iget_args.&n; *&n; * This function is called by iget5_locked() to distinguish reiserfs inodes&n; * having the same inode numbers. Such inodes can only exist due to some&n; * error condition. One of them should be bad. Inodes with identical&n; * inode numbers (objectids) are distinguished by parent directory ids.&n; *&n; */
DECL|function|reiserfs_find_actor
r_int
id|reiserfs_find_actor
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_void
op_star
id|opaque
)paren
(brace
r_struct
id|reiserfs_iget_args
op_star
id|args
suffix:semicolon
id|args
op_assign
id|opaque
suffix:semicolon
multiline_comment|/* args is already in CPU order */
r_return
(paren
id|inode-&gt;i_ino
op_eq
id|args-&gt;objectid
)paren
op_logical_and
(paren
id|le32_to_cpu
c_func
(paren
id|INODE_PKEY
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
op_eq
id|args-&gt;dirid
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_iget
r_struct
id|inode
op_star
id|reiserfs_iget
(paren
r_struct
id|super_block
op_star
id|s
comma
r_const
r_struct
id|cpu_key
op_star
id|key
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|reiserfs_iget_args
id|args
suffix:semicolon
id|args.objectid
op_assign
id|key-&gt;on_disk_key.k_objectid
suffix:semicolon
id|args.dirid
op_assign
id|key-&gt;on_disk_key.k_dir_id
suffix:semicolon
id|inode
op_assign
id|iget5_locked
(paren
id|s
comma
id|key-&gt;on_disk_key.k_objectid
comma
id|reiserfs_find_actor
comma
id|reiserfs_init_locked_inode
comma
(paren
r_void
op_star
)paren
(paren
op_amp
id|args
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|reiserfs_read_locked_inode
c_func
(paren
id|inode
comma
op_amp
id|args
)paren
suffix:semicolon
id|unlock_new_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|comp_short_keys
(paren
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|key
)paren
op_logical_or
id|is_bad_inode
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* either due to i/o error or a stale NFS handle */
id|iput
(paren
id|inode
)paren
suffix:semicolon
id|inode
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|inode
suffix:semicolon
)brace
DECL|function|reiserfs_get_dentry
r_struct
id|dentry
op_star
id|reiserfs_get_dentry
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|vobjp
)paren
(brace
id|__u32
op_star
id|data
op_assign
id|vobjp
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|dentry
op_star
id|result
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|key.on_disk_key.k_objectid
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
id|key.on_disk_key.k_dir_id
op_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|sb
)paren
suffix:semicolon
id|inode
op_assign
id|reiserfs_iget
c_func
(paren
id|sb
comma
op_amp
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
op_logical_neg
id|IS_ERR
c_func
(paren
id|inode
)paren
op_logical_and
id|data
(braket
l_int|2
)braket
op_ne
l_int|0
op_logical_and
id|data
(braket
l_int|2
)braket
op_ne
id|inode-&gt;i_generation
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode
op_assign
l_int|NULL
suffix:semicolon
)brace
id|reiserfs_write_unlock
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
id|inode
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ESTALE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|inode
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
id|PTR_ERR
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
id|result
op_assign
id|d_alloc_anon
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|reiserfs_decode_fh
r_struct
id|dentry
op_star
id|reiserfs_decode_fh
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|__u32
op_star
id|data
comma
r_int
id|len
comma
r_int
id|fhtype
comma
r_int
(paren
op_star
id|acceptable
)paren
(paren
r_void
op_star
id|contect
comma
r_struct
id|dentry
op_star
id|de
)paren
comma
r_void
op_star
id|context
)paren
(brace
id|__u32
id|obj
(braket
l_int|3
)braket
comma
id|parent
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* fhtype happens to reflect the number of u32s encoded.&n;     * due to a bug in earlier code, fhtype might indicate there&n;     * are more u32s then actually fitted.&n;     * so if fhtype seems to be more than len, reduce fhtype.&n;     * Valid types are:&n;     *   2 - objectid + dir_id - legacy support&n;     *   3 - objectid + dir_id + generation&n;     *   4 - objectid + dir_id + objectid and dirid of parent - legacy&n;     *   5 - objectid + dir_id + generation + objectid and dirid of parent&n;     *   6 - as above plus generation of directory&n;     * 6 does not fit in NFSv2 handles&n;     */
r_if
c_cond
(paren
id|fhtype
OG
id|len
)paren
(brace
r_if
c_cond
(paren
id|fhtype
op_ne
l_int|6
op_logical_or
id|len
op_ne
l_int|5
)paren
id|reiserfs_warning
(paren
id|sb
comma
l_string|&quot;nfsd/reiserfs, fhtype=%d, len=%d - odd&quot;
comma
id|fhtype
comma
id|len
)paren
suffix:semicolon
id|fhtype
op_assign
l_int|5
suffix:semicolon
)brace
id|obj
(braket
l_int|0
)braket
op_assign
id|data
(braket
l_int|0
)braket
suffix:semicolon
id|obj
(braket
l_int|1
)braket
op_assign
id|data
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fhtype
op_eq
l_int|3
op_logical_or
id|fhtype
op_ge
l_int|5
)paren
id|obj
(braket
l_int|2
)braket
op_assign
id|data
(braket
l_int|2
)braket
suffix:semicolon
r_else
id|obj
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* generation number */
r_if
c_cond
(paren
id|fhtype
op_ge
l_int|4
)paren
(brace
id|parent
(braket
l_int|0
)braket
op_assign
id|data
(braket
id|fhtype
op_ge
l_int|5
ques
c_cond
l_int|3
suffix:colon
l_int|2
)braket
suffix:semicolon
id|parent
(braket
l_int|1
)braket
op_assign
id|data
(braket
id|fhtype
op_ge
l_int|5
ques
c_cond
l_int|4
suffix:colon
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fhtype
op_eq
l_int|6
)paren
id|parent
(braket
l_int|2
)braket
op_assign
id|data
(braket
l_int|5
)braket
suffix:semicolon
r_else
id|parent
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|sb-&gt;s_export_op
op_member_access_from_pointer
id|find_exported_dentry
c_func
(paren
id|sb
comma
id|obj
comma
id|fhtype
OL
l_int|4
ques
c_cond
l_int|NULL
suffix:colon
id|parent
comma
id|acceptable
comma
id|context
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_encode_fh
r_int
id|reiserfs_encode_fh
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
id|__u32
op_star
id|data
comma
r_int
op_star
id|lenp
comma
r_int
id|need_parent
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|maxlen
op_assign
op_star
id|lenp
suffix:semicolon
r_if
c_cond
(paren
id|maxlen
OL
l_int|3
)paren
r_return
l_int|255
suffix:semicolon
id|data
(braket
l_int|0
)braket
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|data
(braket
l_int|1
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
id|data
(braket
l_int|2
)braket
op_assign
id|inode-&gt;i_generation
suffix:semicolon
op_star
id|lenp
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* no room for directory info? return what we&squot;ve stored so far */
r_if
c_cond
(paren
id|maxlen
OL
l_int|5
op_logical_or
op_logical_neg
id|need_parent
)paren
r_return
l_int|3
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
id|data
(braket
l_int|3
)braket
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|data
(braket
l_int|4
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
op_star
id|lenp
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|maxlen
op_ge
l_int|6
)paren
(brace
id|data
(braket
l_int|5
)braket
op_assign
id|inode-&gt;i_generation
suffix:semicolon
op_star
id|lenp
op_assign
l_int|6
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dentry-&gt;d_lock
)paren
suffix:semicolon
r_return
op_star
id|lenp
suffix:semicolon
)brace
multiline_comment|/* looks for stat data, then copies fields to it, marks the buffer&n;   containing stat data as dirty */
multiline_comment|/* reiserfs inodes are never really dirty, since the dirty inode call&n;** always logs them.  This call allows the VFS inode marking routines&n;** to properly mark inodes for datasync and such, but only actually&n;** does something when called for a synchronous update.&n;*/
DECL|function|reiserfs_write_inode
r_int
id|reiserfs_write_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|do_sync
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/* memory pressure can sometimes initiate write_inode calls with sync == 1,&n;    ** these cases are just when the system needs ram, not when the &n;    ** inode needs to reach disk for safety, and they can safely be&n;    ** ignored because the altered inode has already been logged.&n;    */
r_if
c_cond
(paren
id|do_sync
op_logical_and
op_logical_neg
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
)paren
(brace
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
)paren
(brace
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|journal_end_sync
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
)brace
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* stat data of new object is inserted already, this inserts the item&n;   containing &quot;.&quot; and &quot;..&quot; entries */
DECL|function|reiserfs_new_directory
r_static
r_int
id|reiserfs_new_directory
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|item_head
op_star
id|ih
comma
r_struct
id|path
op_star
id|path
comma
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|th-&gt;t_super
suffix:semicolon
r_char
id|empty_dir
(braket
id|EMPTY_DIR_SIZE
)braket
suffix:semicolon
r_char
op_star
id|body
op_assign
id|empty_dir
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|_make_cpu_key
(paren
op_amp
id|key
comma
id|KEY_FORMAT_3_5
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_objectid
)paren
comma
id|DOT_OFFSET
comma
id|TYPE_DIRENTRY
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
multiline_comment|/* compose item head for new item. Directories consist of items of&n;       old type (ITEM_VERSION_1). Do not set key (second arg is 0), it&n;       is done by reiserfs_new_inode */
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
(brace
id|make_le_item_head
(paren
id|ih
comma
l_int|NULL
comma
id|KEY_FORMAT_3_5
comma
id|DOT_OFFSET
comma
id|TYPE_DIRENTRY
comma
id|EMPTY_DIR_SIZE_V1
comma
l_int|2
)paren
suffix:semicolon
id|make_empty_dir_item_v1
(paren
id|body
comma
id|ih-&gt;ih_key.k_dir_id
comma
id|ih-&gt;ih_key.k_objectid
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_dir_id
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
)brace
r_else
(brace
id|make_le_item_head
(paren
id|ih
comma
l_int|NULL
comma
id|KEY_FORMAT_3_5
comma
id|DOT_OFFSET
comma
id|TYPE_DIRENTRY
comma
id|EMPTY_DIR_SIZE
comma
l_int|2
)paren
suffix:semicolon
id|make_empty_dir_item
(paren
id|body
comma
id|ih-&gt;ih_key.k_dir_id
comma
id|ih-&gt;ih_key.k_objectid
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_dir_id
comma
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
)brace
multiline_comment|/* look for place in the tree for new item */
id|retval
op_assign
id|search_item
(paren
id|sb
comma
op_amp
id|key
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
id|sb
comma
l_string|&quot;vs-13080: reiserfs_new_directory: &quot;
l_string|&quot;i/o failure occurred creating new directory&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|pathrelse
(paren
id|path
)paren
suffix:semicolon
id|reiserfs_warning
(paren
id|sb
comma
l_string|&quot;vs-13070: reiserfs_new_directory: &quot;
l_string|&quot;object with this key exists (%k)&quot;
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* insert item, that is empty directory item */
r_return
id|reiserfs_insert_item
(paren
id|th
comma
id|path
comma
op_amp
id|key
comma
id|ih
comma
id|inode
comma
id|body
)paren
suffix:semicolon
)brace
multiline_comment|/* stat data of object has been inserted, this inserts the item&n;   containing the body of symlink */
DECL|function|reiserfs_new_symlink
r_static
r_int
id|reiserfs_new_symlink
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
multiline_comment|/* Inode of symlink */
r_struct
id|item_head
op_star
id|ih
comma
r_struct
id|path
op_star
id|path
comma
r_const
r_char
op_star
id|symname
comma
r_int
id|item_len
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|th-&gt;t_super
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|_make_cpu_key
(paren
op_amp
id|key
comma
id|KEY_FORMAT_3_5
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_objectid
)paren
comma
l_int|1
comma
id|TYPE_DIRECT
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
id|make_le_item_head
(paren
id|ih
comma
l_int|NULL
comma
id|KEY_FORMAT_3_5
comma
l_int|1
comma
id|TYPE_DIRECT
comma
id|item_len
comma
l_int|0
multiline_comment|/*free_space*/
)paren
suffix:semicolon
multiline_comment|/* look for place in the tree for new item */
id|retval
op_assign
id|search_item
(paren
id|sb
comma
op_amp
id|key
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
id|sb
comma
l_string|&quot;vs-13080: reiserfs_new_symlinik: &quot;
l_string|&quot;i/o failure occurred creating new symlink&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|pathrelse
(paren
id|path
)paren
suffix:semicolon
id|reiserfs_warning
(paren
id|sb
comma
l_string|&quot;vs-13080: reiserfs_new_symlink: &quot;
l_string|&quot;object with this key exists (%k)&quot;
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
multiline_comment|/* insert item, that is body of symlink */
r_return
id|reiserfs_insert_item
(paren
id|th
comma
id|path
comma
op_amp
id|key
comma
id|ih
comma
id|inode
comma
id|symname
)paren
suffix:semicolon
)brace
multiline_comment|/* inserts the stat data into the tree, and then calls&n;   reiserfs_new_directory (to insert &quot;.&quot;, &quot;..&quot; item if new object is&n;   directory) or reiserfs_new_symlink (to insert symlink body if new&n;   object is symlink) or nothing (if new object is regular file) &n;&n;   NOTE! uid and gid must already be set in the inode.  If we return&n;   non-zero due to an error, we have to drop the quota previously allocated&n;   for the fresh inode.  This can only be done outside a transaction, so&n;   if we return non-zero, we also end the transaction.  */
DECL|function|reiserfs_new_inode
r_int
id|reiserfs_new_inode
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|dir
comma
r_int
id|mode
comma
r_const
r_char
op_star
id|symname
comma
multiline_comment|/* 0 for regular, EMTRY_DIR_SIZE for dirs, &n;&t;&t;&t;   strlen (symname) for symlinks)*/
id|loff_t
id|i_size
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path_to_key
)paren
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|item_head
id|ih
suffix:semicolon
r_struct
id|stat_data
id|sd
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DQUOT_ALLOC_INODE
c_func
(paren
id|inode
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EDQUOT
suffix:semicolon
r_goto
id|out_end_trans
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|dir-&gt;i_nlink
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out_bad_inode
suffix:semicolon
)brace
id|sb
op_assign
id|dir-&gt;i_sb
suffix:semicolon
multiline_comment|/* item head of new item */
id|ih.ih_key.k_dir_id
op_assign
id|reiserfs_choose_packing
c_func
(paren
id|dir
)paren
suffix:semicolon
id|ih.ih_key.k_objectid
op_assign
id|cpu_to_le32
(paren
id|reiserfs_get_unused_objectid
(paren
id|th
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ih.ih_key.k_objectid
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out_bad_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
multiline_comment|/* not a perfect generation count, as object ids can be reused, but &n;&t;** this is as good as reiserfs can do right now.&n;&t;** note that the private part of inode isn&squot;t filled in yet, we have&n;&t;** to use the directory.&n;&t;*/
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|dir
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
r_else
macro_line|#if defined( USE_INODE_GENERATION_COUNTER )
id|inode-&gt;i_generation
op_assign
id|le32_to_cpu
c_func
(paren
id|REISERFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|s_rs-&gt;s_inode_generation
)paren
suffix:semicolon
macro_line|#else
id|inode-&gt;i_generation
op_assign
op_increment
id|event
suffix:semicolon
macro_line|#endif
multiline_comment|/* fill stat data */
id|inode-&gt;i_nlink
op_assign
(paren
id|S_ISDIR
(paren
id|mode
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
suffix:semicolon
multiline_comment|/* uid and gid must already be set by the caller for quota init */
multiline_comment|/* symlink cannot be immutable or append only, right? */
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_mode
)paren
)paren
(brace
id|inode
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
(paren
id|S_IMMUTABLE
op_or
id|S_APPEND
)paren
suffix:semicolon
)brace
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME_SEC
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|i_size
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_bytes
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
op_assign
id|S_ISLNK
c_func
(paren
id|mode
)paren
ques
c_cond
l_int|1
suffix:colon
id|U32_MAX
multiline_comment|/*NO_BYTES_IN_DIRECT_ITEM*/
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_list
)paren
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_assign
l_int|0
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_jl
op_assign
l_int|NULL
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_attrs
op_assign
id|REISERFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|i_attrs
op_amp
id|REISERFS_INHERIT_MASK
suffix:semicolon
id|sd_attrs_to_i_attrs
c_func
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_attrs
comma
id|inode
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_access
op_assign
l_int|NULL
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_default
op_assign
l_int|NULL
suffix:semicolon
id|init_rwsem
(paren
op_amp
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|xattr_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
id|make_le_item_head
(paren
op_amp
id|ih
comma
l_int|NULL
comma
id|KEY_FORMAT_3_5
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
id|SD_V1_SIZE
comma
id|MAX_US_INT
)paren
suffix:semicolon
r_else
id|make_le_item_head
(paren
op_amp
id|ih
comma
l_int|NULL
comma
id|KEY_FORMAT_3_6
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
id|SD_SIZE
comma
id|MAX_US_INT
)paren
suffix:semicolon
multiline_comment|/* key to search for correct place for new stat data */
id|_make_cpu_key
(paren
op_amp
id|key
comma
id|KEY_FORMAT_3_6
comma
id|le32_to_cpu
(paren
id|ih.ih_key.k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|ih.ih_key.k_objectid
)paren
comma
id|SD_OFFSET
comma
id|TYPE_STAT_DATA
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
multiline_comment|/* find proper place for inserting of stat data */
id|retval
op_assign
id|search_item
(paren
id|sb
comma
op_amp
id|key
comma
op_amp
id|path_to_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_bad_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|pathrelse
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|out_bad_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_uid
op_amp
op_complement
l_int|0xffff
op_logical_or
id|inode-&gt;i_gid
op_amp
op_complement
l_int|0xffff
)paren
(brace
id|pathrelse
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
multiline_comment|/* i_uid or i_gid is too big to be stored in stat data v3.5 */
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_bad_inode
suffix:semicolon
)brace
id|inode2sd_v1
(paren
op_amp
id|sd
comma
id|inode
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|inode2sd
(paren
op_amp
id|sd
comma
id|inode
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
)brace
singleline_comment|// these do not go to on-disk stat data
id|inode-&gt;i_ino
op_assign
id|le32_to_cpu
(paren
id|ih.ih_key.k_objectid
)paren
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|reiserfs_default_io_size
suffix:semicolon
singleline_comment|// store in in-core inode the key of stat data and version all
singleline_comment|// object items will have (directory items will have old offset
singleline_comment|// format, other new objects will consist of new items)
id|memcpy
(paren
id|INODE_PKEY
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih.ih_key
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_5
)paren
suffix:semicolon
r_else
id|set_inode_item_key_version
(paren
id|inode
comma
id|KEY_FORMAT_3_6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
(paren
id|sb
)paren
)paren
id|set_inode_sd_version
(paren
id|inode
comma
id|STAT_DATA_V1
)paren
suffix:semicolon
r_else
id|set_inode_sd_version
(paren
id|inode
comma
id|STAT_DATA_V2
)paren
suffix:semicolon
multiline_comment|/* insert the stat data into the tree */
macro_line|#ifdef DISPLACE_NEW_PACKING_LOCALITIES
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|new_packing_locality
)paren
id|th-&gt;displace_new_blocks
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|retval
op_assign
id|reiserfs_insert_item
(paren
id|th
comma
op_amp
id|path_to_key
comma
op_amp
id|key
comma
op_amp
id|ih
comma
id|inode
comma
(paren
r_char
op_star
)paren
(paren
op_amp
id|sd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|err
op_assign
id|retval
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
r_goto
id|out_bad_inode
suffix:semicolon
)brace
macro_line|#ifdef DISPLACE_NEW_PACKING_LOCALITIES
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;displace_new_blocks
)paren
id|REISERFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|new_packing_locality
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
(brace
multiline_comment|/* insert item with &quot;.&quot; and &quot;..&quot; */
id|retval
op_assign
id|reiserfs_new_directory
(paren
id|th
comma
id|inode
comma
op_amp
id|ih
comma
op_amp
id|path_to_key
comma
id|dir
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
(brace
multiline_comment|/* insert body of symlink */
r_if
c_cond
(paren
op_logical_neg
id|old_format_only
(paren
id|sb
)paren
)paren
id|i_size
op_assign
id|ROUND_UP
c_func
(paren
id|i_size
)paren
suffix:semicolon
id|retval
op_assign
id|reiserfs_new_symlink
(paren
id|th
comma
id|inode
comma
op_amp
id|ih
comma
op_amp
id|path_to_key
comma
id|symname
comma
id|i_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
(brace
id|err
op_assign
id|retval
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
id|journal_end
c_func
(paren
id|th
comma
id|th-&gt;t_super
comma
id|th-&gt;t_blocks_allocated
)paren
suffix:semicolon
r_goto
id|out_inserted_sd
suffix:semicolon
)brace
multiline_comment|/* XXX CHECK THIS */
r_if
c_cond
(paren
id|reiserfs_posixacl
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
id|retval
op_assign
id|reiserfs_inherit_default_acl
(paren
id|dir
comma
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|err
op_assign
id|retval
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
id|journal_end
c_func
(paren
id|th
comma
id|th-&gt;t_super
comma
id|th-&gt;t_blocks_allocated
)paren
suffix:semicolon
r_goto
id|out_inserted_sd
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;s_flags
op_amp
id|MS_POSIXACL
)paren
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ACLs aren&squot;t enabled in the fs, &quot;
l_string|&quot;but vfs thinks they are!&quot;
)paren
suffix:semicolon
)brace
id|insert_inode_hash
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path_to_key
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* it looks like you can easily compress these two goto targets into&n; * one.  Keeping it like this doesn&squot;t actually hurt anything, and they&n; * are place holders for what the quota code actually needs.&n; */
id|out_bad_inode
suffix:colon
multiline_comment|/* Invalidate the object, nothing was inserted yet */
id|INODE_PKEY
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Quota change must be inside a transaction for journaling */
id|DQUOT_FREE_INODE
c_func
(paren
id|inode
)paren
suffix:semicolon
id|out_end_trans
suffix:colon
id|journal_end
c_func
(paren
id|th
comma
id|th-&gt;t_super
comma
id|th-&gt;t_blocks_allocated
)paren
suffix:semicolon
multiline_comment|/* Drop can be outside and it needs more credits so it&squot;s better to have it outside */
id|DQUOT_DROP
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_flags
op_or_assign
id|S_NOQUOTA
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|out_inserted_sd
suffix:colon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|th-&gt;t_trans_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* so the caller can&squot;t use this handle later */
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;** finds the tail page in the page cache,&n;** reads the last block in.&n;**&n;** On success, page_result is set to a locked, pinned page, and bh_result&n;** is set to an up to date buffer for the last block in the file.  returns 0.&n;**&n;** tail conversion is not done, so bh_result might not be valid for writing&n;** check buffer_mapped(bh_result) and bh_result-&gt;b_blocknr != 0 before&n;** trying to write the block.&n;**&n;** on failure, nonzero is returned, page_result and bh_result are untouched.&n;*/
DECL|function|grab_tail_page
r_static
r_int
id|grab_tail_page
c_func
(paren
r_struct
id|inode
op_star
id|p_s_inode
comma
r_struct
id|page
op_star
op_star
id|page_result
comma
r_struct
id|buffer_head
op_star
op_star
id|bh_result
)paren
(brace
multiline_comment|/* we want the page with the last byte in the file,&n;    ** not the page that will hold the next byte for appending&n;    */
r_int
r_int
id|index
op_assign
(paren
id|p_s_inode-&gt;i_size
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
r_int
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|start
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|p_s_inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_int
r_int
id|offset
op_assign
(paren
id|p_s_inode-&gt;i_size
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|head
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* we know that we are only called with inode-&gt;i_size &gt; 0.&n;    ** we also know that a file tail can never be as big as a block&n;    ** If i_size % blocksize == 0, our file is currently block aligned&n;    ** and it won&squot;t need converting or zeroing after a truncate.&n;    */
r_if
c_cond
(paren
(paren
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|p_s_inode-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* start within the page of the last block in the file */
id|start
op_assign
(paren
id|offset
op_div
id|blocksize
)paren
op_star
id|blocksize
suffix:semicolon
id|error
op_assign
id|block_prepare_write
c_func
(paren
id|page
comma
id|start
comma
id|offset
comma
id|reiserfs_get_block_create_0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|unlock
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|pos
op_ge
id|start
)paren
(brace
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|pos
op_add_assign
id|blocksize
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* note, this should never happen, prepare_write should&n;&t;** be taking care of this for us.  If the buffer isn&squot;t up to date,&n;&t;** I&squot;ve screwed up the code to find the buffer, or the code to&n;&t;** call prepare_write&n;&t;*/
id|reiserfs_warning
(paren
id|p_s_inode-&gt;i_sb
comma
l_string|&quot;clm-6000: error reading block %lu on dev %s&quot;
comma
id|bh-&gt;b_blocknr
comma
id|reiserfs_bdevname
(paren
id|p_s_inode-&gt;i_sb
)paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
op_star
id|bh_result
op_assign
id|bh
suffix:semicolon
op_star
id|page_result
op_assign
id|page
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|unlock
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;** vfs version of truncate file.  Must NOT be called with&n;** a transaction already started.&n;**&n;** some code taken from block_truncate_page&n;*/
DECL|function|reiserfs_truncate_file
r_int
id|reiserfs_truncate_file
c_func
(paren
r_struct
id|inode
op_star
id|p_s_inode
comma
r_int
id|update_timestamps
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
multiline_comment|/* we want the offset for the first byte after the end of the file */
r_int
r_int
id|offset
op_assign
id|p_s_inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|blocksize
op_assign
id|p_s_inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_int
id|length
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|p_s_inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p_s_inode-&gt;i_size
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|grab_tail_page
c_func
(paren
id|p_s_inode
comma
op_amp
id|page
comma
op_amp
id|bh
)paren
)paren
)paren
(brace
singleline_comment|// -ENOENT means we truncated past the end of the file, 
singleline_comment|// and get_block_create_0 could not find a block to read in,
singleline_comment|// which is ok.
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|ENOENT
)paren
id|reiserfs_warning
(paren
id|p_s_inode-&gt;i_sb
comma
l_string|&quot;clm-6001: grab_tail_page failed %d&quot;
comma
id|error
)paren
suffix:semicolon
id|page
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* so, if page != NULL, we have a buffer head for the offset at &n;    ** the end of the file. if the bh is mapped, and bh-&gt;b_blocknr != 0, &n;    ** then we have an unformatted node.  Otherwise, we have a direct item, &n;    ** and no zeroing is required on disk.  We zero after the truncate, &n;    ** because the truncate might pack the item anyway &n;    ** (it will unmap bh if it packs).&n;    */
multiline_comment|/* it is enough to reserve space in transaction for 2 balancings:&n;       one for &quot;save&quot; link adding and another for the first&n;       cut_from_item. 1 is for update_sd */
id|error
op_assign
id|journal_begin
(paren
op_amp
id|th
comma
id|p_s_inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|p_s_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_timestamps
)paren
multiline_comment|/* we are doing real truncate: if the system crashes before the last&n;&t;       transaction of truncating gets committed - on reboot the file&n;&t;       either appears truncated properly or not truncated at all */
id|add_save_link
(paren
op_amp
id|th
comma
id|p_s_inode
comma
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|reiserfs_do_truncate
(paren
op_amp
id|th
comma
id|p_s_inode
comma
id|page
comma
id|update_timestamps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|journal_end
(paren
op_amp
id|th
comma
id|p_s_inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|update_timestamps
)paren
(brace
id|error
op_assign
id|remove_save_link
(paren
id|p_s_inode
comma
l_int|1
multiline_comment|/* truncate */
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
)paren
(brace
id|length
op_assign
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if we are not on a block boundary */
r_if
c_cond
(paren
id|length
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
id|length
op_assign
id|blocksize
op_minus
id|length
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|offset
comma
l_int|0
comma
id|length
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_ne
l_int|0
)paren
(brace
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|reiserfs_write_unlock
c_func
(paren
id|p_s_inode-&gt;i_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|page
)paren
(brace
id|unlock_page
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
(paren
id|page
)paren
suffix:semicolon
)brace
id|reiserfs_write_unlock
c_func
(paren
id|p_s_inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|map_block_for_writepage
r_static
r_int
id|map_block_for_writepage
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
r_struct
id|item_head
id|tmp_ih
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|__u32
op_star
id|item
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
r_int
id|pos_in_item
suffix:semicolon
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
id|loff_t
id|byte_offset
op_assign
(paren
id|block
op_lshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
op_plus
l_int|1
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|use_get_block
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_copied
op_assign
l_int|0
suffix:semicolon
r_int
id|copy_size
suffix:semicolon
r_int
id|trans_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* catch places below that try to log something without starting a trans */
id|th.t_trans_id
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh_result
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|kmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|start_over
suffix:colon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|make_cpu_key
c_func
(paren
op_amp
id|key
comma
id|inode
comma
id|byte_offset
comma
id|TYPE_ANY
comma
l_int|3
)paren
suffix:semicolon
id|research
suffix:colon
id|retval
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|POSITION_FOUND
)paren
(brace
id|use_get_block
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|path.pos_in_item
suffix:semicolon
multiline_comment|/* we&squot;ve found an unformatted node */
r_if
c_cond
(paren
id|indirect_item_found
c_func
(paren
id|retval
comma
id|ih
)paren
)paren
(brace
r_if
c_cond
(paren
id|bytes_copied
OG
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;clm-6002: bytes_copied %d&quot;
comma
id|bytes_copied
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
)paren
(brace
multiline_comment|/* crap, we are writing to a hole */
id|use_get_block
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|set_block_dev_mapped
c_func
(paren
id|bh_result
comma
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
comma
id|inode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_direct_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
id|page_address
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
id|p
op_add_assign
(paren
id|byte_offset
op_minus
l_int|1
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|copy_size
op_assign
id|ih_item_len
c_func
(paren
id|ih
)paren
op_minus
id|pos_in_item
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|copy_item_head
c_func
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|trans_running
)paren
(brace
multiline_comment|/* vs-3050 is gone, no need to drop the path */
id|retval
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|trans_running
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
c_func
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
c_func
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
)brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|B_I_PITEM
c_func
(paren
id|bh
comma
id|ih
)paren
op_plus
id|pos_in_item
comma
id|p
op_plus
id|bytes_copied
comma
id|copy_size
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
id|bytes_copied
op_add_assign
id|copy_size
suffix:semicolon
id|set_block_dev_mapped
c_func
(paren
id|bh_result
comma
l_int|0
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/* are there still bytes left? */
r_if
c_cond
(paren
id|bytes_copied
OL
id|bh_result-&gt;b_size
op_logical_and
(paren
id|byte_offset
op_plus
id|bytes_copied
)paren
OL
id|inode-&gt;i_size
)paren
(brace
id|set_cpu_key_k_offset
c_func
(paren
op_amp
id|key
comma
id|cpu_key_k_offset
c_func
(paren
op_amp
id|key
)paren
op_plus
id|copy_size
)paren
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
)brace
r_else
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;clm-6003: bad item inode %lu, device %s&quot;
comma
id|inode-&gt;i_ino
comma
id|reiserfs_bdevname
(paren
id|inode-&gt;i_sb
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trans_running
)paren
(brace
r_int
id|err
op_assign
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|retval
op_assign
id|err
suffix:semicolon
id|trans_running
op_assign
l_int|0
suffix:semicolon
)brace
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* this is where we fill in holes in the file. */
r_if
c_cond
(paren
id|use_get_block
)paren
(brace
id|retval
op_assign
id|reiserfs_get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh_result
comma
id|GET_BLOCK_CREATE
op_or
id|GET_BLOCK_NO_ISEM
op_or
id|GET_BLOCK_NO_DANGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh_result
)paren
op_logical_or
id|bh_result-&gt;b_blocknr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* get_block failed to find a mapped unformatted node. */
id|use_get_block
op_assign
l_int|0
suffix:semicolon
r_goto
id|start_over
suffix:semicolon
)brace
)brace
)brace
id|kunmap
c_func
(paren
id|bh_result-&gt;b_page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|buffer_mapped
c_func
(paren
id|bh_result
)paren
op_logical_and
id|bh_result-&gt;b_blocknr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* we&squot;ve copied data from the page into the direct item, so the&n;&t; * buffer in the page is now clean, mark it to reflect that.&n;&t; */
id|lock_buffer
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh_result
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* &n; * mason@suse.com: updated in 2.5.54 to follow the same general io &n; * start/recovery path as __block_write_full_page, along with special&n; * code to handle reiserfs tails.&n; */
DECL|function|reiserfs_write_full_page
r_static
r_int
id|reiserfs_write_full_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
r_int
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
suffix:semicolon
r_int
id|partial
op_assign
l_int|0
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_int
id|checked
op_assign
id|PageChecked
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_struct
id|super_block
op_star
id|s
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_int
id|bh_per_page
op_assign
id|PAGE_CACHE_SIZE
op_div
id|s-&gt;s_blocksize
suffix:semicolon
id|th.t_trans_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The page dirty bit is cleared before writepage is called, which&n;     * means we have to tell create_empty_buffers to make dirty buffers&n;     * The page really should be up to date at this point, so tossing&n;     * in the BH_Uptodate is just a sanity check.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|create_empty_buffers
c_func
(paren
id|page
comma
id|s-&gt;s_blocksize
comma
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Uptodate
)paren
)paren
suffix:semicolon
)brace
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* last page in the file, zero out any contents past the&n;    ** last byte in the file&n;    */
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
)paren
(brace
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|last_offset
suffix:semicolon
id|last_offset
op_assign
id|inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no file contents in this page */
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
op_plus
l_int|1
op_logical_or
op_logical_neg
id|last_offset
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|last_offset
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|last_offset
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|head
suffix:semicolon
id|block
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|s-&gt;s_blocksize_bits
)paren
suffix:semicolon
multiline_comment|/* first map all the buffers, logging any direct items we find */
r_do
(brace
r_if
c_cond
(paren
(paren
id|checked
op_logical_or
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_or
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* not mapped yet, or it points to a direct item, search&n;&t;     * the btree for the mapping info, and log any direct&n;&t;     * items found&n;&t;     */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|map_block_for_writepage
c_func
(paren
id|inode
comma
id|bh
comma
id|block
)paren
)paren
)paren
(brace
r_goto
id|fail
suffix:semicolon
)brace
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|block
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/*&n;     * we start the transaction after map_block_for_writepage,&n;     * because it can create holes in the file (an unbounded operation).&n;     * starting it here, we can make a reliable estimate for how many&n;     * blocks we&squot;re going to log&n;     */
r_if
c_cond
(paren
id|checked
)paren
(brace
id|ClearPageChecked
c_func
(paren
id|page
)paren
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|s
)paren
suffix:semicolon
id|error
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|bh_per_page
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|reiserfs_write_unlock
c_func
(paren
id|s
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/* now go through and lock any dirty buffers on the page */
r_do
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|checked
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* from this point on, we know the buffer is mapped to a&n;&t; * real block and not a direct item&n;&t; */
r_if
c_cond
(paren
id|wbc-&gt;sync_mode
op_ne
id|WB_SYNC_NONE
op_logical_or
op_logical_neg
id|wbc-&gt;nonblocking
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|test_set_buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|mark_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|checked
)paren
(brace
id|error
op_assign
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|bh_per_page
op_plus
l_int|1
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|fail
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;     * since any buffer might be the only dirty buffer on the page, &n;     * the first submit_bh can bring the page out of writeback.&n;     * be careful with the buffers.&n;     */
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_write
c_func
(paren
id|bh
)paren
)paren
(brace
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|nr
op_increment
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|nr
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;         * if this page only had a direct item, it is very possible for&n;         * no io to be required without there being an error.  Or, &n;&t; * someone else could have locked them and sent them down the &n;&t; * pipe without locking the page&n;&t; */
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|partial
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|fail
suffix:colon
multiline_comment|/* catches various errors, we need to make sure any valid dirty blocks&n;     * get to the media.  The page is currently locked and not marked for &n;     * writeback&n;     */
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;     * clear any dirty bits that might have come from getting&n;&t;     * attached to a dirty page&n;&t;     */
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_write
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|nr
op_increment
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
(brace
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
)brace
DECL|function|reiserfs_readpage
r_static
r_int
id|reiserfs_readpage
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|block_read_full_page
(paren
id|page
comma
id|reiserfs_get_block
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_writepage
r_static
r_int
id|reiserfs_writepage
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|reiserfs_write_full_page
c_func
(paren
id|page
comma
id|wbc
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_prepare_write
r_static
r_int
id|reiserfs_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|old_ref
op_assign
l_int|0
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|fix_tail_page_for_writing
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_transaction_running
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
r_struct
id|reiserfs_transaction_handle
op_star
id|th
suffix:semicolon
id|th
op_assign
(paren
r_struct
id|reiserfs_transaction_handle
op_star
)paren
id|current-&gt;journal_info
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_refcount
)paren
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|old_ref
op_assign
id|th-&gt;t_refcount
suffix:semicolon
id|th-&gt;t_refcount
op_increment
suffix:semicolon
)brace
id|ret
op_assign
id|block_prepare_write
c_func
(paren
id|page
comma
id|from
comma
id|to
comma
id|reiserfs_get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|reiserfs_transaction_running
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
r_struct
id|reiserfs_transaction_handle
op_star
id|th
op_assign
id|current-&gt;journal_info
suffix:semicolon
multiline_comment|/* this gets a little ugly.  If reiserfs_get_block returned an&n;&t; * error and left a transacstion running, we&squot;ve got to close it,&n;&t; * and we&squot;ve got to free handle if it was a persistent transaction.&n;&t; *&n;&t; * But, if we had nested into an existing transaction, we need&n;&t; * to just drop the ref count on the handle.&n;&t; *&n;&t; * If old_ref == 0, the transaction is from reiserfs_get_block,&n;&t; * and it was a persistent trans.  Otherwise, it was nested above.&n;&t; */
r_if
c_cond
(paren
id|th-&gt;t_refcount
OG
id|old_ref
)paren
(brace
r_if
c_cond
(paren
id|old_ref
)paren
id|th-&gt;t_refcount
op_decrement
suffix:semicolon
r_else
(brace
r_int
id|err
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|err
op_assign
id|reiserfs_end_persistent_transaction
c_func
(paren
id|th
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|ret
op_assign
id|err
suffix:semicolon
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|reiserfs_aop_bmap
r_static
id|sector_t
id|reiserfs_aop_bmap
c_func
(paren
r_struct
id|address_space
op_star
id|as
comma
id|sector_t
id|block
)paren
(brace
r_return
id|generic_block_bmap
c_func
(paren
id|as
comma
id|block
comma
id|reiserfs_bmap
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_commit_write
r_static
r_int
id|reiserfs_commit_write
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|loff_t
id|pos
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|update_sd
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
op_star
id|th
op_assign
l_int|NULL
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_transaction_running
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
id|th
op_assign
id|current-&gt;journal_info
suffix:semicolon
)brace
id|reiserfs_commit_page
c_func
(paren
id|inode
comma
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
multiline_comment|/* generic_commit_write does this for us, but does not update the&n;    ** transaction tracking stuff when the size changes.  So, we have&n;    ** to do the i_size updates here.&n;    */
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|myth
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* If the file have grown beyond the border where it&n;&t;   can have a tail, unmark it as needing a tail&n;&t;   packing */
r_if
c_cond
(paren
(paren
id|have_large_tails
(paren
id|inode-&gt;i_sb
)paren
op_logical_and
id|inode-&gt;i_size
OG
id|i_block_size
(paren
id|inode
)paren
op_star
l_int|4
)paren
op_logical_or
(paren
id|have_small_tails
(paren
id|inode-&gt;i_sb
)paren
op_logical_and
id|inode-&gt;i_size
OG
id|i_block_size
c_func
(paren
id|inode
)paren
)paren
)paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_pack_on_close_mask
suffix:semicolon
id|ret
op_assign
id|journal_begin
c_func
(paren
op_amp
id|myth
comma
id|inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_goto
id|journal_error
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|pos
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
op_amp
id|myth
comma
id|inode
)paren
suffix:semicolon
id|update_sd
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|journal_end
c_func
(paren
op_amp
id|myth
comma
id|inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|journal_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th
)paren
(brace
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|update_sd
)paren
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
id|ret
op_assign
id|reiserfs_end_persistent_transaction
c_func
(paren
id|th
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* we test for O_SYNC here so we can commit the transaction&n;    ** for any packed tails the file might have had&n;    */
r_if
c_cond
(paren
id|f
op_logical_and
(paren
id|f-&gt;f_flags
op_amp
id|O_SYNC
)paren
)paren
(brace
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|ret
op_assign
id|reiserfs_commit_for_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
id|journal_error
suffix:colon
r_if
c_cond
(paren
id|th
)paren
(brace
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|update_sd
)paren
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
id|ret
op_assign
id|reiserfs_end_persistent_transaction
c_func
(paren
id|th
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sd_attrs_to_i_attrs
r_void
id|sd_attrs_to_i_attrs
c_func
(paren
id|__u16
id|sd_attrs
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_attrs
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_sb
)paren
)paren
(brace
r_if
c_cond
(paren
id|sd_attrs
op_amp
id|REISERFS_SYNC_FL
)paren
(brace
id|inode
op_member_access_from_pointer
id|i_flags
op_or_assign
id|S_SYNC
suffix:semicolon
)brace
r_else
id|inode
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|S_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|sd_attrs
op_amp
id|REISERFS_IMMUTABLE_FL
)paren
(brace
id|inode
op_member_access_from_pointer
id|i_flags
op_or_assign
id|S_IMMUTABLE
suffix:semicolon
)brace
r_else
id|inode
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|S_IMMUTABLE
suffix:semicolon
r_if
c_cond
(paren
id|sd_attrs
op_amp
id|REISERFS_APPEND_FL
)paren
(brace
id|inode
op_member_access_from_pointer
id|i_flags
op_or_assign
id|S_APPEND
suffix:semicolon
)brace
r_else
id|inode
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|S_APPEND
suffix:semicolon
r_if
c_cond
(paren
id|sd_attrs
op_amp
id|REISERFS_NOATIME_FL
)paren
(brace
id|inode
op_member_access_from_pointer
id|i_flags
op_or_assign
id|S_NOATIME
suffix:semicolon
)brace
r_else
id|inode
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|S_NOATIME
suffix:semicolon
r_if
c_cond
(paren
id|sd_attrs
op_amp
id|REISERFS_NOTAIL_FL
)paren
(brace
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_nopack_mask
suffix:semicolon
)brace
r_else
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_nopack_mask
suffix:semicolon
)brace
)brace
DECL|function|i_attrs_to_sd_attrs
r_void
id|i_attrs_to_sd_attrs
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|__u16
op_star
id|sd_attrs
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_attrs
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_sb
)paren
)paren
(brace
r_if
c_cond
(paren
id|inode
op_member_access_from_pointer
id|i_flags
op_amp
id|S_IMMUTABLE
)paren
(brace
op_star
id|sd_attrs
op_or_assign
id|REISERFS_IMMUTABLE_FL
suffix:semicolon
)brace
r_else
op_star
id|sd_attrs
op_and_assign
op_complement
id|REISERFS_IMMUTABLE_FL
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_member_access_from_pointer
id|i_flags
op_amp
id|S_SYNC
)paren
(brace
op_star
id|sd_attrs
op_or_assign
id|REISERFS_SYNC_FL
suffix:semicolon
)brace
r_else
op_star
id|sd_attrs
op_and_assign
op_complement
id|REISERFS_SYNC_FL
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_member_access_from_pointer
id|i_flags
op_amp
id|S_NOATIME
)paren
(brace
op_star
id|sd_attrs
op_or_assign
id|REISERFS_NOATIME_FL
suffix:semicolon
)brace
r_else
op_star
id|sd_attrs
op_and_assign
op_complement
id|REISERFS_NOATIME_FL
suffix:semicolon
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_nopack_mask
)paren
(brace
op_star
id|sd_attrs
op_or_assign
id|REISERFS_NOTAIL_FL
suffix:semicolon
)brace
r_else
op_star
id|sd_attrs
op_and_assign
op_complement
id|REISERFS_NOTAIL_FL
suffix:semicolon
)brace
)brace
multiline_comment|/* decide if this buffer needs to stay around for data logging or ordered&n;** write purposes&n;*/
DECL|function|invalidatepage_can_drop
r_static
r_int
id|invalidatepage_can_drop
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|j
op_assign
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
r_goto
id|free_jh
suffix:semicolon
)brace
multiline_comment|/* the page is locked, and the only places that log a data buffer&n;     * also lock the page.&n;     */
r_if
c_cond
(paren
id|reiserfs_file_data_log
c_func
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/*&n;&t; * very conservative, leave the buffer pinned if&n;&t; * anyone might need it.&n;&t; */
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_struct
id|reiserfs_jh
op_star
id|jh
op_assign
id|bh-&gt;b_private
suffix:semicolon
multiline_comment|/* why is this safe?&n;&t; * reiserfs_setattr updates i_size in the on disk&n;&t; * stat data before allowing vmtruncate to be called.&n;&t; *&n;&t; * If buffer was put onto the ordered list for this&n;&t; * transaction, we know for sure either this transaction&n;&t; * or an older one already has updated i_size on disk,&n;&t; * and this ordered data won&squot;t be referenced in the file&n;&t; * if we crash.&n;&t; *&n;&t; * if the buffer was put onto the ordered list for an older&n;&t; * transaction, we need to leave it around&n;&t; */
r_if
c_cond
(paren
id|jh
op_logical_and
(paren
id|jl
op_assign
id|jh-&gt;jl
)paren
op_logical_and
id|jl
op_ne
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_current_jl
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|free_jh
suffix:colon
r_if
c_cond
(paren
id|ret
op_logical_and
id|bh-&gt;b_private
)paren
(brace
id|reiserfs_free_jh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* clm -- taken from fs/buffer.c:block_invalidate_page */
DECL|function|reiserfs_invalidatepage
r_static
r_int
id|reiserfs_invalidatepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
r_int
id|curr_off
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
l_int|0
)paren
id|ClearPageChecked
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_int
r_int
id|next_off
op_assign
id|curr_off
op_plus
id|bh-&gt;b_size
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
multiline_comment|/*&n;&t; * is this block fully invalidated?&n;&t; */
r_if
c_cond
(paren
id|offset
op_le
id|curr_off
)paren
(brace
r_if
c_cond
(paren
id|invalidatepage_can_drop
c_func
(paren
id|inode
comma
id|bh
)paren
)paren
id|reiserfs_unmap_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_else
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|curr_off
op_assign
id|next_off
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/*&n;     * We release buffers only if the entire page is being invalidated.&n;     * The get_block cached value has been unconditionally invalidated,&n;     * so real IO is not possible anymore.&n;     */
r_if
c_cond
(paren
op_logical_neg
id|offset
op_logical_and
id|ret
)paren
id|ret
op_assign
id|try_to_release_page
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|reiserfs_set_page_dirty
r_static
r_int
id|reiserfs_set_page_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_file_data_log
c_func
(paren
id|inode
)paren
)paren
(brace
id|SetPageChecked
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|__set_page_dirty_nobuffers
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|__set_page_dirty_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns 1 if the page&squot;s buffers were dropped.  The page is locked.&n; *&n; * Takes j_dirty_buffers_lock to protect the b_assoc_buffers list_heads&n; * in the buffers at page_buffers(page).&n; *&n; * even in -o notail mode, we can&squot;t be sure an old mount without -o notail&n; * didn&squot;t create files with tails.&n; */
DECL|function|reiserfs_releasepage
r_static
r_int
id|reiserfs_releasepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|unused_gfp_flags
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|j
op_assign
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|head
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|WARN_ON
c_func
(paren
id|PageChecked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|bh-&gt;b_private
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_free_jh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|ret
op_assign
id|try_to_free_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* We thank Mingming Cao for helping us understand in great detail what&n;   to do in this section of the code. */
DECL|function|reiserfs_direct_IO
r_static
id|ssize_t
id|reiserfs_direct_IO
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
id|loff_t
id|offset
comma
r_int
r_int
id|nr_segs
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_mapping-&gt;host
suffix:semicolon
r_return
id|blockdev_direct_IO
c_func
(paren
id|rw
comma
id|iocb
comma
id|inode
comma
id|inode-&gt;i_sb-&gt;s_bdev
comma
id|iov
comma
id|offset
comma
id|nr_segs
comma
id|reiserfs_get_blocks_direct_io
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_setattr
r_int
id|reiserfs_setattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
r_int
id|ia_valid
op_assign
id|attr-&gt;ia_valid
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
(brace
multiline_comment|/* version 2 items will be caught by the s_maxbytes check&n;&t;** done for us in vmtruncate&n;&t;*/
r_if
c_cond
(paren
id|get_inode_item_key_version
c_func
(paren
id|inode
)paren
op_eq
id|KEY_FORMAT_3_5
op_logical_and
id|attr-&gt;ia_size
OG
id|MAX_NON_LFS
)paren
(brace
id|error
op_assign
op_minus
id|EFBIG
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* fill in hole pointers in the expanding truncate case. */
r_if
c_cond
(paren
id|attr-&gt;ia_size
OG
id|inode-&gt;i_size
)paren
(brace
id|error
op_assign
id|generic_cont_expand
c_func
(paren
id|inode
comma
id|attr-&gt;ia_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
OG
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
multiline_comment|/* we&squot;re changing at most 2 bitmaps, inode + super */
id|err
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|reiserfs_discard_prealloc
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|err
op_assign
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
id|error
op_assign
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
(paren
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
op_logical_and
(paren
id|attr-&gt;ia_uid
op_amp
op_complement
l_int|0xffff
)paren
)paren
op_logical_or
(paren
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
op_logical_and
(paren
id|attr-&gt;ia_gid
op_amp
op_complement
l_int|0xffff
)paren
)paren
)paren
op_logical_and
(paren
id|get_inode_sd_version
(paren
id|inode
)paren
op_eq
id|STAT_DATA_V1
)paren
)paren
(brace
multiline_comment|/* stat data of format v3.5 has 16 bit uid and gid */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|ia_valid
op_amp
id|ATTR_UID
op_logical_and
id|attr-&gt;ia_uid
op_ne
id|inode-&gt;i_uid
)paren
op_logical_or
(paren
id|ia_valid
op_amp
id|ATTR_GID
op_logical_and
id|attr-&gt;ia_gid
op_ne
id|inode-&gt;i_gid
)paren
)paren
(brace
id|error
op_assign
id|reiserfs_chown_xattrs
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
multiline_comment|/* (user+group)*(old+new) structure - we count quota info and , inode write (sb, inode) */
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|4
op_star
id|REISERFS_QUOTA_INIT_BLOCKS
op_plus
l_int|2
)paren
suffix:semicolon
id|error
op_assign
id|DQUOT_TRANSFER
c_func
(paren
id|inode
comma
id|attr
)paren
ques
c_cond
op_minus
id|EDQUOT
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|4
op_star
id|REISERFS_QUOTA_INIT_BLOCKS
op_plus
l_int|2
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Update corresponding info in inode so that everything is in&n;&t;&t;     * one transaction */
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
id|inode-&gt;i_uid
op_assign
id|attr-&gt;ia_uid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
id|inode-&gt;i_gid
op_assign
id|attr-&gt;ia_gid
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|4
op_star
id|REISERFS_QUOTA_INIT_BLOCKS
op_plus
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|inode_setattr
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|reiserfs_posixacl
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
id|error
op_assign
id|reiserfs_acl_chmod
(paren
id|inode
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|reiserfs_address_space_operations
r_struct
id|address_space_operations
id|reiserfs_address_space_operations
op_assign
(brace
dot
id|writepage
op_assign
id|reiserfs_writepage
comma
dot
id|readpage
op_assign
id|reiserfs_readpage
comma
dot
id|readpages
op_assign
id|reiserfs_readpages
comma
dot
id|releasepage
op_assign
id|reiserfs_releasepage
comma
dot
id|invalidatepage
op_assign
id|reiserfs_invalidatepage
comma
dot
id|sync_page
op_assign
id|block_sync_page
comma
dot
id|prepare_write
op_assign
id|reiserfs_prepare_write
comma
dot
id|commit_write
op_assign
id|reiserfs_commit_write
comma
dot
id|bmap
op_assign
id|reiserfs_aop_bmap
comma
dot
id|direct_IO
op_assign
id|reiserfs_direct_IO
comma
dot
id|set_page_dirty
op_assign
id|reiserfs_set_page_dirty
comma
)brace
suffix:semicolon
eof
