multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
multiline_comment|/*&n;** We pack the tails of files on file close, not at the time they are written.&n;** This implies an unnecessary copy of the tail and an unnecessary indirect item&n;** insertion/balancing, for files that are written in one write.&n;** It avoids unnecessary tail packings (balances) for files that are written in&n;** multiple writes and are small enough to have tails.&n;** &n;** file_release is called by the VFS layer when the file is closed.  If&n;** this is the last open file descriptor, and the file&n;** small enough to have a tail, and the tail is currently in an&n;** unformatted node, the tail is converted back into a direct item.&n;** &n;** We use reiserfs_truncate_file to pack the tail, since it already has&n;** all the conditions coded.  &n;*/
DECL|function|reiserfs_file_release
r_static
r_int
id|reiserfs_file_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
(paren
id|inode-&gt;i_mode
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
multiline_comment|/* fast out for when nothing needs to be done */
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
op_logical_or
op_logical_neg
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_pack_on_close_mask
)paren
op_logical_or
op_logical_neg
id|tail_has_to_be_packed
c_func
(paren
id|inode
)paren
)paren
op_logical_and
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|down
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
macro_line|#ifdef REISERFS_PREALLOCATE
id|reiserfs_discard_prealloc
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
macro_line|#endif
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
op_le
l_int|1
op_logical_and
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_pack_on_close_mask
)paren
op_logical_and
id|tail_has_to_be_packed
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* if regular file is released by last holder and it has been&n;&t;   appended (we append by unformatted node only) or its direct&n;&t;   item(s) had to be converted, then it may have to be&n;&t;   indirect2direct converted */
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;file_release&quot;
)paren
suffix:semicolon
id|reiserfs_truncate_file
c_func
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
)brace
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_vfs_truncate_file
r_static
r_void
id|reiserfs_vfs_truncate_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|reiserfs_truncate_file
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Sync a reiserfs file. */
multiline_comment|/*&n; * FIXME: sync_mapping_buffers() never has anything to sync.  Can&n; * be removed...&n; */
DECL|function|reiserfs_sync_file
r_static
r_int
id|reiserfs_sync_file
c_func
(paren
r_struct
id|file
op_star
id|p_s_filp
comma
r_struct
id|dentry
op_star
id|p_s_dentry
comma
r_int
id|datasync
)paren
(brace
r_struct
id|inode
op_star
id|p_s_inode
op_assign
id|p_s_dentry-&gt;d_inode
suffix:semicolon
r_int
id|n_err
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|p_s_inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|p_s_inode-&gt;i_mode
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
id|n_err
op_assign
id|sync_mapping_buffers
c_func
(paren
id|p_s_inode-&gt;i_mapping
)paren
suffix:semicolon
id|reiserfs_commit_for_inode
c_func
(paren
id|p_s_inode
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|p_s_inode-&gt;i_sb
)paren
suffix:semicolon
r_return
(paren
id|n_err
OL
l_int|0
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_setattr
r_static
r_int
id|reiserfs_setattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|error
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
(brace
multiline_comment|/* version 2 items will be caught by the s_maxbytes check&n;&t;** done for us in vmtruncate&n;&t;*/
r_if
c_cond
(paren
id|get_inode_item_key_version
c_func
(paren
id|inode
)paren
op_eq
id|KEY_FORMAT_3_5
op_logical_and
id|attr-&gt;ia_size
OG
id|MAX_NON_LFS
)paren
(brace
id|error
op_assign
op_minus
id|EFBIG
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* fill in hole pointers in the expanding truncate case. */
r_if
c_cond
(paren
id|attr-&gt;ia_size
OG
id|inode-&gt;i_size
)paren
(brace
id|error
op_assign
id|generic_cont_expand
c_func
(paren
id|inode
comma
id|attr-&gt;ia_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
OG
l_int|0
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
multiline_comment|/* we&squot;re changing at most 2 bitmaps, inode + super */
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|4
)paren
suffix:semicolon
id|reiserfs_discard_prealloc
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|4
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
(paren
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
op_logical_and
(paren
id|attr-&gt;ia_uid
op_amp
op_complement
l_int|0xffff
)paren
)paren
op_logical_or
(paren
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
op_logical_and
(paren
id|attr-&gt;ia_gid
op_amp
op_complement
l_int|0xffff
)paren
)paren
)paren
op_logical_and
(paren
id|get_inode_sd_version
(paren
id|inode
)paren
op_eq
id|STAT_DATA_V1
)paren
)paren
(brace
multiline_comment|/* stat data of format v3.5 has 16 bit uid and gid */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode_setattr
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
id|out
suffix:colon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* I really do not want to play with memory shortage right now, so&n;   to simplify the code, we are not going to write more than this much pages at&n;   a time. This still should considerably improve performance compared to 4k&n;   at a time case. This is 32 pages of 4k size. */
DECL|macro|REISERFS_WRITE_PAGES_AT_A_TIME
mdefine_line|#define REISERFS_WRITE_PAGES_AT_A_TIME (128 * 1024) / PAGE_CACHE_SIZE
multiline_comment|/* Allocates blocks for a file to fulfil write request.&n;   Maps all unmapped but prepared pages from the list.&n;   Updates metadata with newly allocated blocknumbers as needed */
DECL|function|reiserfs_allocate_blocks_for_region
r_int
id|reiserfs_allocate_blocks_for_region
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
multiline_comment|/* Inode we work with */
id|loff_t
id|pos
comma
multiline_comment|/* Writing position */
r_int
id|num_pages
comma
multiline_comment|/* number of pages write going&n;&t;&t;&t;&t;&t;&t;  to touch */
r_int
id|write_bytes
comma
multiline_comment|/* amount of bytes to write */
r_struct
id|page
op_star
op_star
id|prepared_pages
comma
multiline_comment|/* array of&n;&t;&t;&t;&t;&t;&t;&t;         prepared pages&n;&t;&t;&t;&t;&t;&t;&t;       */
r_int
id|blocks_to_allocate
multiline_comment|/* Amount of blocks we&n;&t;&t;&t;&t;&t;&t;&t;  need to allocate to&n;&t;&t;&t;&t;&t;&t;&t;  fit the data into file&n;&t;&t;&t;&t;&t;&t;&t; */
)paren
(brace
r_struct
id|cpu_key
id|key
suffix:semicolon
singleline_comment|// cpu key of item that we are going to deal with
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
singleline_comment|// pointer to item head that we are going to deal with
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
singleline_comment|// Buffer head that contains items that we are going to deal with
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
singleline_comment|// transaction handle for transaction we are going to create.
id|__u32
op_star
id|item
suffix:semicolon
singleline_comment|// pointer to item we are going to deal with
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
singleline_comment|// path to item, that we are going to deal with.
id|b_blocknr_t
id|allocated_blocks
(braket
id|blocks_to_allocate
)braket
suffix:semicolon
singleline_comment|// Pointer to a place where allocated blocknumbers would be stored. Right now statically allocated, later that will change.
id|reiserfs_blocknr_hint_t
id|hint
suffix:semicolon
singleline_comment|// hint structure for block allocator.
r_int
id|res
suffix:semicolon
singleline_comment|// return value of various functions that we call.
r_int
id|curr_block
suffix:semicolon
singleline_comment|// current block used to keep track of unmapped blocks.
r_int
id|i
suffix:semicolon
singleline_comment|// loop counter
r_int
id|itempos
suffix:semicolon
singleline_comment|// position in item
r_int
r_int
id|from
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
singleline_comment|// writing position in
singleline_comment|// first page
r_int
r_int
id|to
op_assign
(paren
(paren
id|pos
op_plus
id|write_bytes
op_minus
l_int|1
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* last modified byte offset in last page */
id|__u64
id|hole_size
suffix:semicolon
singleline_comment|// amount of blocks for a file hole, if it needed to be created.
r_int
id|modifying_this_item
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Flag for items traversal code to keep track
singleline_comment|// of the fact that we already prepared
singleline_comment|// current block for journal
id|RFALSE
c_func
(paren
op_logical_neg
id|blocks_to_allocate
comma
l_string|&quot;green-9004: tried to allocate zero blocks?&quot;
)paren
suffix:semicolon
multiline_comment|/* First we compose a key to point at the writing position, we want to do&n;       that outside of any locking region. */
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
id|pos
op_plus
l_int|1
comma
id|TYPE_ANY
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
multiline_comment|/* If we came here, it means we absolutely need to open a transaction,&n;       since we need to allocate some blocks */
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
singleline_comment|// Journaling stuff and we need that.
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
op_plus
l_int|1
)paren
suffix:semicolon
singleline_comment|// Wish I know if this number enough
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* Look for the in-tree position of our write, need path for block allocator */
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|IO_ERROR
)paren
(brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_exit
suffix:semicolon
)brace
multiline_comment|/* Allocate blocks */
multiline_comment|/* First fill in &quot;hint&quot; structure for block allocator */
id|hint.th
op_assign
op_amp
id|th
suffix:semicolon
singleline_comment|// transaction handle.
id|hint.path
op_assign
op_amp
id|path
suffix:semicolon
singleline_comment|// Path, so that block allocator can determine packing locality or whatever it needs to determine.
id|hint.inode
op_assign
id|inode
suffix:semicolon
singleline_comment|// Inode is needed by block allocator too.
id|hint.search_start
op_assign
l_int|0
suffix:semicolon
singleline_comment|// We have no hint on where to search free blocks for block allocator.
id|hint.key
op_assign
id|key.on_disk_key
suffix:semicolon
singleline_comment|// on disk key of file.
id|hint.block
op_assign
id|inode-&gt;i_blocks
op_rshift
(paren
id|inode-&gt;i_sb-&gt;s_blocksize_bits
op_minus
l_int|9
)paren
suffix:semicolon
singleline_comment|// Number of disk blocks this file occupies already.
id|hint.formatted_node
op_assign
l_int|0
suffix:semicolon
singleline_comment|// We are allocating blocks for unformatted node.
id|hint.preallocate
op_assign
l_int|0
suffix:semicolon
singleline_comment|// We do not do any preallocation for now.
multiline_comment|/* Call block allocator to allocate blocks */
id|res
op_assign
id|reiserfs_allocate_blocknrs
c_func
(paren
op_amp
id|hint
comma
id|allocated_blocks
comma
id|blocks_to_allocate
comma
id|blocks_to_allocate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|CARRY_ON
)paren
(brace
r_if
c_cond
(paren
id|res
op_eq
id|NO_DISK_SPACE
)paren
(brace
multiline_comment|/* We flush the transaction in case of no space. This way some&n;&t;       blocks might become free */
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|1
suffix:semicolon
id|restart_transaction
c_func
(paren
op_amp
id|th
comma
id|inode
comma
op_amp
id|path
)paren
suffix:semicolon
multiline_comment|/* We might have scheduled, so search again */
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|IO_ERROR
)paren
(brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_exit
suffix:semicolon
)brace
multiline_comment|/* update changed info for hint structure. */
id|res
op_assign
id|reiserfs_allocate_blocknrs
c_func
(paren
op_amp
id|hint
comma
id|allocated_blocks
comma
id|blocks_to_allocate
comma
id|blocks_to_allocate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|CARRY_ON
)paren
(brace
id|res
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_goto
id|error_exit
suffix:semicolon
)brace
)brace
r_else
(brace
id|res
op_assign
op_minus
id|ENOSPC
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_goto
id|error_exit
suffix:semicolon
)brace
)brace
macro_line|#ifdef __BIG_ENDIAN
singleline_comment|// Too bad, I have not found any way to convert a given region from
singleline_comment|// cpu format to little endian format
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|blocks_to_allocate
suffix:semicolon
id|i
op_increment
)paren
id|allocated_blocks
(braket
id|i
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|allocated_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Blocks allocating well might have scheduled and tree might have changed,&n;       let&squot;s search the tree again */
multiline_comment|/* find where in the tree our write should go */
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|IO_ERROR
)paren
(brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
singleline_comment|// Get a bufferhead for last element in path.
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
singleline_comment|// Get a pointer to last item head in path.
id|item
op_assign
id|get_item
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
singleline_comment|// Get a pointer to last item in path
multiline_comment|/* Let&squot;s see what we have found */
r_if
c_cond
(paren
id|res
op_ne
id|POSITION_FOUND
)paren
(brace
multiline_comment|/* position not found, this means that we&n;&t;&t;&t;&t;      might need to append file with holes&n;&t;&t;&t;&t;      first */
singleline_comment|// Since we are writing past the file&squot;s end, we need to find out if
singleline_comment|// there is a hole that needs to be inserted before our writing
singleline_comment|// position, and how many blocks it is going to cover (we need to
singleline_comment|//  populate pointers to file blocks representing the hole with zeros)
id|hole_size
op_assign
(paren
id|pos
op_plus
l_int|1
op_minus
(paren
id|le_key_k_offset
c_func
(paren
id|get_inode_item_key_version
c_func
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
op_plus
id|op_bytes_number
c_func
(paren
id|ih
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
)paren
)paren
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
id|hole_size
OG
l_int|0
)paren
(brace
r_int
id|to_paste
op_assign
id|min_t
c_func
(paren
id|__u64
comma
id|hole_size
comma
id|MAX_ITEM_LEN
c_func
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
op_div
id|UNFM_P_SIZE
)paren
suffix:semicolon
singleline_comment|// How much data to insert first time.
multiline_comment|/* area filled with zeroes, to supply as list of zero blocknumbers&n;&t;       We allocate it outside of loop just in case loop would spin for&n;&t;       several iterations. */
r_char
op_star
id|zeros
op_assign
id|kmalloc
c_func
(paren
id|to_paste
op_star
id|UNFM_P_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
singleline_comment|// We cannot insert more than MAX_ITEM_LEN bytes anyway.
r_if
c_cond
(paren
op_logical_neg
id|zeros
)paren
(brace
id|res
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
id|memset
(paren
id|zeros
comma
l_int|0
comma
id|to_paste
op_star
id|UNFM_P_SIZE
)paren
suffix:semicolon
r_do
(brace
id|to_paste
op_assign
id|min_t
c_func
(paren
id|__u64
comma
id|hole_size
comma
id|MAX_ITEM_LEN
c_func
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
op_div
id|UNFM_P_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* Ok, there is existing indirect item already. Need to append it */
multiline_comment|/* Calculate position past inserted item */
id|make_cpu_key
c_func
(paren
op_amp
id|key
comma
id|inode
comma
id|le_key_k_offset
c_func
(paren
id|get_inode_item_key_version
c_func
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
op_plus
id|op_bytes_number
c_func
(paren
id|ih
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
comma
id|TYPE_INDIRECT
comma
l_int|3
)paren
suffix:semicolon
id|res
op_assign
id|reiserfs_paste_into_item
c_func
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
id|key
comma
(paren
r_char
op_star
)paren
id|zeros
comma
id|UNFM_P_SIZE
op_star
id|to_paste
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|kfree
c_func
(paren
id|zeros
)paren
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|is_statdata_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* No existing item, create it */
multiline_comment|/* item head for new item */
r_struct
id|item_head
id|ins_ih
suffix:semicolon
multiline_comment|/* create a key for our new item */
id|make_cpu_key
c_func
(paren
op_amp
id|key
comma
id|inode
comma
l_int|1
comma
id|TYPE_INDIRECT
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Create new item head for our new item */
id|make_le_item_head
(paren
op_amp
id|ins_ih
comma
op_amp
id|key
comma
id|key.version
comma
l_int|1
comma
id|TYPE_INDIRECT
comma
id|to_paste
op_star
id|UNFM_P_SIZE
comma
l_int|0
multiline_comment|/* free space */
)paren
suffix:semicolon
multiline_comment|/* Find where such item should live in the tree */
id|res
op_assign
id|search_item
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|ITEM_NOT_FOUND
)paren
(brace
multiline_comment|/* item should not exist, otherwise we have error */
r_if
c_cond
(paren
id|res
op_ne
op_minus
id|ENOSPC
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;green-9008: search_by_key (%K) returned %d&bslash;n&quot;
comma
op_amp
id|key
comma
id|res
)paren
suffix:semicolon
)brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
id|kfree
c_func
(paren
id|zeros
)paren
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
id|res
op_assign
id|reiserfs_insert_item
c_func
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
id|key
comma
op_amp
id|ins_ih
comma
(paren
r_char
op_star
)paren
id|zeros
)paren
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-9011: Unexpected key type %K&bslash;n&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res
)paren
(brace
id|kfree
c_func
(paren
id|zeros
)paren
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
multiline_comment|/* Now we want to check if transaction is too full, and if it is&n;&t;&t;   we restart it. This will also free the path. */
r_if
c_cond
(paren
id|journal_transaction_should_end
c_func
(paren
op_amp
id|th
comma
id|th.t_blocks_allocated
)paren
)paren
id|restart_transaction
c_func
(paren
op_amp
id|th
comma
id|inode
comma
op_amp
id|path
)paren
suffix:semicolon
multiline_comment|/* Well, need to recalculate path and stuff */
id|set_cpu_key_k_offset
c_func
(paren
op_amp
id|key
comma
id|cpu_key_k_offset
c_func
(paren
op_amp
id|key
)paren
op_plus
(paren
id|to_paste
op_lshift
id|inode-&gt;i_blkbits
)paren
)paren
suffix:semicolon
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|IO_ERROR
)paren
(brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
id|kfree
c_func
(paren
id|zeros
)paren
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|hole_size
op_sub_assign
id|to_paste
suffix:semicolon
)brace
r_while
c_loop
(paren
id|hole_size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|zeros
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// Go through existing indirect items first
singleline_comment|// replace all zeroes with blocknumbers from list
singleline_comment|// Note that if no corresponding item was found, by previous search,
singleline_comment|// it means there are no existing in-tree representation for file area
singleline_comment|// we are going to overwrite, so there is nothing to scan through for holes.
r_for
c_loop
(paren
id|curr_block
op_assign
l_int|0
comma
id|itempos
op_assign
id|path.pos_in_item
suffix:semicolon
id|curr_block
OL
id|blocks_to_allocate
op_logical_and
id|res
op_eq
id|POSITION_FOUND
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|itempos
op_ge
id|ih_item_len
c_func
(paren
id|ih
)paren
op_div
id|UNFM_P_SIZE
)paren
(brace
multiline_comment|/* We run out of data in this indirect item, let&squot;s look for another&n;&t;       one. */
multiline_comment|/* First if we are already modifying current item, log it */
r_if
c_cond
(paren
id|modifying_this_item
)paren
(brace
id|journal_mark_dirty
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
id|modifying_this_item
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Then set the key to look for a new indirect item (offset of old&n;&t;       item is added to old item length */
id|set_cpu_key_k_offset
c_func
(paren
op_amp
id|key
comma
id|le_key_k_offset
c_func
(paren
id|get_inode_item_key_version
c_func
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
op_plus
id|op_bytes_number
c_func
(paren
id|ih
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
)paren
suffix:semicolon
multiline_comment|/* Search ofor position of new key in the tree. */
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|IO_ERROR
)paren
(brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|itempos
op_assign
id|path.pos_in_item
suffix:semicolon
r_continue
suffix:semicolon
singleline_comment|// loop to check all kinds of conditions and so on.
)brace
multiline_comment|/* Ok, we have correct position in item now, so let&squot;s see if it is&n;&t;   representing file hole (blocknumber is zero) and fill it if needed */
r_if
c_cond
(paren
op_logical_neg
id|item
(braket
id|itempos
)braket
)paren
(brace
multiline_comment|/* Ok, a hole. Now we need to check if we already prepared this&n;&t;       block to be journaled */
r_while
c_loop
(paren
op_logical_neg
id|modifying_this_item
)paren
(brace
singleline_comment|// loop until succeed
multiline_comment|/* Well, this item is not journaled yet, so we must prepare&n;&t;&t;   it for journal first, before we can change it */
r_struct
id|item_head
id|tmp_ih
suffix:semicolon
singleline_comment|// We copy item head of found item,
singleline_comment|// here to detect if fs changed under
singleline_comment|// us while we were preparing for
singleline_comment|// journal.
r_int
id|fs_gen
suffix:semicolon
singleline_comment|// We store fs generation here to find if someone
singleline_comment|// changes fs under our feet
id|copy_item_head
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
singleline_comment|// Remember itemhead
id|fs_gen
op_assign
id|get_generation
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
singleline_comment|// remember fs generation
id|reiserfs_prepare_for_journal
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// Prepare a buffer within which indirect item is stored for changing.
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|inode-&gt;i_sb
)paren
op_logical_and
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path
)paren
)paren
(brace
singleline_comment|// Sigh, fs was changed under us, we need to look for new
singleline_comment|// location of item we are working with
multiline_comment|/* unmark prepaerd area as journaled and search for it&squot;s&n;&t;&t;       new position */
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|IO_ERROR
)paren
(brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
singleline_comment|// Itempos is still the same
r_continue
suffix:semicolon
)brace
id|modifying_this_item
op_assign
l_int|1
suffix:semicolon
)brace
id|item
(braket
id|itempos
)braket
op_assign
id|allocated_blocks
(braket
id|curr_block
)braket
suffix:semicolon
singleline_comment|// Assign new block
id|curr_block
op_increment
suffix:semicolon
)brace
id|itempos
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|modifying_this_item
)paren
(brace
singleline_comment|// We need to log last-accessed block, if it
singleline_comment|// was modified, but not logged yet.
id|journal_mark_dirty
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curr_block
OL
id|blocks_to_allocate
)paren
(brace
singleline_comment|// Oh, well need to append to indirect item, or to create indirect item
singleline_comment|// if there weren&squot;t any
r_if
c_cond
(paren
id|is_indirect_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
singleline_comment|// Existing indirect item - append. First calculate key for append
singleline_comment|// position. We do not need to recalculate path as it should
singleline_comment|// already point to correct place.
id|make_cpu_key
c_func
(paren
op_amp
id|key
comma
id|inode
comma
id|le_key_k_offset
c_func
(paren
id|get_inode_item_key_version
c_func
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
op_plus
id|op_bytes_number
c_func
(paren
id|ih
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
comma
id|TYPE_INDIRECT
comma
l_int|3
)paren
suffix:semicolon
id|res
op_assign
id|reiserfs_paste_into_item
c_func
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
id|key
comma
(paren
r_char
op_star
)paren
(paren
id|allocated_blocks
op_plus
id|curr_block
)paren
comma
id|UNFM_P_SIZE
op_star
(paren
id|blocks_to_allocate
op_minus
id|curr_block
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|is_statdata_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
singleline_comment|// Last found item was statdata. That means we need to create indirect item.
r_struct
id|item_head
id|ins_ih
suffix:semicolon
multiline_comment|/* itemhead for new item */
multiline_comment|/* create a key for our new item */
id|make_cpu_key
c_func
(paren
op_amp
id|key
comma
id|inode
comma
l_int|1
comma
id|TYPE_INDIRECT
comma
l_int|3
)paren
suffix:semicolon
singleline_comment|// Position one,
singleline_comment|// because that&squot;s
singleline_comment|// where first
singleline_comment|// indirect item
singleline_comment|// begins
multiline_comment|/* Create new item head for our new item */
id|make_le_item_head
(paren
op_amp
id|ins_ih
comma
op_amp
id|key
comma
id|key.version
comma
l_int|1
comma
id|TYPE_INDIRECT
comma
(paren
id|blocks_to_allocate
op_minus
id|curr_block
)paren
op_star
id|UNFM_P_SIZE
comma
l_int|0
multiline_comment|/* free space */
)paren
suffix:semicolon
multiline_comment|/* Find where such item should live in the tree */
id|res
op_assign
id|search_item
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|ITEM_NOT_FOUND
)paren
(brace
multiline_comment|/* Well, if we have found such item already, or some error&n;&t;&t;   occured, we need to warn user and return error */
r_if
c_cond
(paren
id|res
op_ne
op_minus
id|ENOSPC
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;green-9009: search_by_key (%K) returned %d&bslash;n&quot;
comma
op_amp
id|key
comma
id|res
)paren
suffix:semicolon
)brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_exit_free_blocks
suffix:semicolon
)brace
multiline_comment|/* Insert item into the tree with the data as its body */
id|res
op_assign
id|reiserfs_insert_item
c_func
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
id|key
comma
op_amp
id|ins_ih
comma
(paren
r_char
op_star
)paren
(paren
id|allocated_blocks
op_plus
id|curr_block
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-9010: unexpected item type for key %K&bslash;n&quot;
comma
op_amp
id|key
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Now the final thing, if we have grew the file, we must update it&squot;s size*/
r_if
c_cond
(paren
id|pos
op_plus
id|write_bytes
OG
id|inode-&gt;i_size
)paren
(brace
id|inode-&gt;i_size
op_assign
id|pos
op_plus
id|write_bytes
suffix:semicolon
singleline_comment|// Set new size
)brace
multiline_comment|/* Amount of on-disk blocks used by file have changed, update it */
id|inode-&gt;i_blocks
op_add_assign
id|blocks_to_allocate
op_lshift
(paren
id|inode-&gt;i_blkbits
op_minus
l_int|9
)paren
suffix:semicolon
id|reiserfs_update_sd
c_func
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
singleline_comment|// And update on-disk metadata
singleline_comment|// finish all journal stuff now, We are not going to play with metadata
singleline_comment|// anymore.
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
op_plus
l_int|1
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
singleline_comment|// go through all the pages/buffers and map the buffers to newly allocated
singleline_comment|// blocks (so that system knows where to write these pages later).
id|curr_block
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|prepared_pages
(braket
id|i
)braket
suffix:semicolon
singleline_comment|//current page
r_struct
id|buffer_head
op_star
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
singleline_comment|// first buffer for a page
r_int
id|block_start
comma
id|block_end
suffix:semicolon
singleline_comment|// in-page offsets for buffers.
r_if
c_cond
(paren
op_logical_neg
id|page_buffers
c_func
(paren
id|page
)paren
)paren
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-9005: No buffers for prepared page???&quot;
)paren
suffix:semicolon
multiline_comment|/* For each buffer in page */
r_for
c_loop
(paren
id|bh
op_assign
id|head
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-9006: Allocated but absent buffer for a page?&quot;
)paren
suffix:semicolon
id|block_end
op_assign
id|block_start
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|block_end
op_le
id|from
)paren
multiline_comment|/* if this buffer is before requested data to map, skip it */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|num_pages
op_minus
l_int|1
op_logical_and
id|block_start
op_ge
id|to
)paren
multiline_comment|/* If this buffer is after requested data to map, abort&n;&t;&t;   processing of current page */
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
singleline_comment|// Ok, unmapped buffer, need to map it
id|map_bh
c_func
(paren
id|bh
comma
id|inode-&gt;i_sb
comma
id|le32_to_cpu
c_func
(paren
id|allocated_blocks
(braket
id|curr_block
)braket
)paren
)paren
suffix:semicolon
id|curr_block
op_increment
suffix:semicolon
)brace
)brace
)brace
id|RFALSE
c_func
(paren
id|curr_block
OG
id|blocks_to_allocate
comma
l_string|&quot;green-9007: Used too many blocks? weird&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
singleline_comment|// Need to deal with transaction here.
id|error_exit_free_blocks
suffix:colon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
singleline_comment|// free blocks
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|blocks_to_allocate
suffix:semicolon
id|i
op_increment
)paren
(brace
id|reiserfs_free_block
c_func
(paren
op_amp
id|th
comma
id|le32_to_cpu
c_func
(paren
id|allocated_blocks
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|error_exit
suffix:colon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
op_plus
l_int|1
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Unlock pages prepared by reiserfs_prepare_file_region_for_write */
DECL|function|reiserfs_unprepare_pages
r_void
id|reiserfs_unprepare_pages
c_func
(paren
r_struct
id|page
op_star
op_star
id|prepared_pages
comma
multiline_comment|/* list of locked pages */
r_int
id|num_pages
multiline_comment|/* amount of pages */
)paren
(brace
r_int
id|i
suffix:semicolon
singleline_comment|// loop counter
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|prepared_pages
(braket
id|i
)braket
suffix:semicolon
id|try_to_free_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This function will copy data from userspace to specified pages within&n;   supplied byte range */
DECL|function|reiserfs_copy_from_user_to_file_region
r_int
id|reiserfs_copy_from_user_to_file_region
c_func
(paren
id|loff_t
id|pos
comma
multiline_comment|/* In-file position */
r_int
id|num_pages
comma
multiline_comment|/* Number of pages affected */
r_int
id|write_bytes
comma
multiline_comment|/* Amount of bytes to write */
r_struct
id|page
op_star
op_star
id|prepared_pages
comma
multiline_comment|/* pointer to &n;&t;&t;&t;&t;&t;&t;&t;&t; array to&n;&t;&t;&t;&t;&t;&t;&t;&t; prepared pages&n;&t;&t;&t;&t;&t;&t;&t;&t;*/
r_const
r_char
op_star
id|buf
multiline_comment|/* Pointer to user-supplied&n;&t;&t;&t;&t;&t;&t;   data*/
)paren
(brace
r_int
id|page_fault
op_assign
l_int|0
suffix:semicolon
singleline_comment|// status of copy_from_user.
r_int
id|i
suffix:semicolon
singleline_comment|// loop counter.
r_int
id|offset
suffix:semicolon
singleline_comment|// offset in page
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
id|i
op_increment
comma
id|offset
op_assign
l_int|0
)paren
(brace
r_int
id|count
op_assign
id|min_t
c_func
(paren
r_int
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
comma
id|write_bytes
)paren
suffix:semicolon
singleline_comment|// How much of bytes to write to this page
r_struct
id|page
op_star
id|page
op_assign
id|prepared_pages
(braket
id|i
)braket
suffix:semicolon
singleline_comment|// Current page we process.
id|fault_in_pages_readable
c_func
(paren
id|buf
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Copy data from userspace to the current page */
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_fault
op_assign
id|__copy_from_user
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
id|buf
comma
id|count
)paren
suffix:semicolon
singleline_comment|// Copy the data.
multiline_comment|/* Flush processor&squot;s dcache for this page */
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|buf
op_add_assign
id|count
suffix:semicolon
id|write_bytes
op_sub_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|page_fault
)paren
r_break
suffix:semicolon
singleline_comment|// Was there a fault? abort.
)brace
r_return
id|page_fault
ques
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Submit pages for write. This was separated from actual file copying&n;   because we might want to allocate block numbers in-between.&n;   This function assumes that caller will adjust file size to correct value. */
DECL|function|reiserfs_submit_file_region_for_write
r_int
id|reiserfs_submit_file_region_for_write
c_func
(paren
id|loff_t
id|pos
comma
multiline_comment|/* Writing position offset */
r_int
id|num_pages
comma
multiline_comment|/* Number of pages to write */
r_int
id|write_bytes
comma
multiline_comment|/* number of bytes to write */
r_struct
id|page
op_star
op_star
id|prepared_pages
multiline_comment|/* list of pages */
)paren
(brace
r_int
id|status
suffix:semicolon
singleline_comment|// return status of block_commit_write.
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Return value we are going to return.
r_int
id|i
suffix:semicolon
singleline_comment|// loop counter
r_int
id|offset
suffix:semicolon
singleline_comment|// Writing offset in page.
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
id|i
op_increment
comma
id|offset
op_assign
l_int|0
)paren
(brace
r_int
id|count
op_assign
id|min_t
c_func
(paren
r_int
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
comma
id|write_bytes
)paren
suffix:semicolon
singleline_comment|// How much of bytes to write to this page
r_struct
id|page
op_star
id|page
op_assign
id|prepared_pages
(braket
id|i
)braket
suffix:semicolon
singleline_comment|// Current page we process.
id|status
op_assign
id|block_commit_write
c_func
(paren
id|page
comma
id|offset
comma
id|offset
op_plus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|retval
op_assign
id|status
suffix:semicolon
singleline_comment|// To not overcomplicate matters We are going to
singleline_comment|// submit all the pages even if there was error.
singleline_comment|// we only remember error status to report it on
singleline_comment|// exit.
id|write_bytes
op_sub_assign
id|count
suffix:semicolon
id|SetPageReferenced
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
singleline_comment|// We unlock the page as it was locked by earlier call
singleline_comment|// to grab_cache_page
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Look if passed writing region is going to touch file&squot;s tail&n;   (if it is present). And if it is, convert the tail to unformatted node */
DECL|function|reiserfs_check_for_tail_and_convert
r_int
id|reiserfs_check_for_tail_and_convert
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
multiline_comment|/* inode to deal with */
id|loff_t
id|pos
comma
multiline_comment|/* Writing position */
r_int
id|write_bytes
multiline_comment|/* amount of bytes to write */
)paren
(brace
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
singleline_comment|// needed for search_for_position
r_struct
id|cpu_key
id|key
suffix:semicolon
singleline_comment|// Key that would represent last touched writing byte.
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
singleline_comment|// item header of found block;
r_int
id|res
suffix:semicolon
singleline_comment|// Return value of various functions we call.
r_int
id|cont_expand_offset
suffix:semicolon
singleline_comment|// We will put offset for generic_cont_expand here
singleline_comment|// This can be int just because tails are created
singleline_comment|// only for small files.
multiline_comment|/* this embodies a dependency on a particular tail policy */
r_if
c_cond
(paren
id|inode-&gt;i_size
op_ge
id|inode-&gt;i_sb-&gt;s_blocksize
op_star
l_int|4
)paren
(brace
multiline_comment|/* such a big files do not have tails, so we won&squot;t bother ourselves&n;&t;   to look for tails, simply return */
r_return
l_int|0
suffix:semicolon
)brace
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* find the item containing the last byte to be written, or if&n;     * writing past the end of the file then the last item of the&n;     * file (and then we check its type). */
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
id|pos
op_plus
id|write_bytes
op_plus
l_int|1
comma
id|TYPE_ANY
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_direct_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* Ok, closest item is file tail (tails are stored in &quot;direct&quot;&n;&t; * items), so we need to unpack it. */
multiline_comment|/* To not overcomplicate matters, we just call generic_cont_expand&n;&t;   which will in turn call other stuff and finally will boil down to&n;&t;    reiserfs_get_block() that would do necessary conversion. */
id|cont_expand_offset
op_assign
id|le_key_k_offset
c_func
(paren
id|get_inode_item_key_version
c_func
(paren
id|inode
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|res
op_assign
id|generic_cont_expand
c_func
(paren
id|inode
comma
id|cont_expand_offset
)paren
suffix:semicolon
)brace
r_else
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* This function locks pages starting from @pos for @inode.&n;   @num_pages pages are locked and stored in&n;   @prepared_pages array. Also buffers are allocated for these pages.&n;   First and last page of the region is read if it is overwritten only&n;   partially. If last page did not exist before write (file hole or file&n;   append), it is zeroed, then. &n;   Returns number of unallocated blocks that should be allocated to cover&n;   new file data.*/
DECL|function|reiserfs_prepare_file_region_for_write
r_int
id|reiserfs_prepare_file_region_for_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
multiline_comment|/* Inode of the file */
comma
id|loff_t
id|pos
comma
multiline_comment|/* position in the file */
r_int
id|num_pages
comma
multiline_comment|/* number of pages to&n;&t;&t;&t;&t;&t;          prepare */
r_int
id|write_bytes
comma
multiline_comment|/* Amount of bytes to be&n;&t;&t;&t;&t;&t;&t;    overwritten from&n;&t;&t;&t;&t;&t;&t;    @pos */
r_struct
id|page
op_star
op_star
id|prepared_pages
multiline_comment|/* pointer to array&n;&t;&t;&t;&t;&t;&t;&t;       where to store&n;&t;&t;&t;&t;&t;&t;&t;       prepared pages */
)paren
(brace
r_int
id|res
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Return values of different functions we call.
r_int
r_int
id|index
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
singleline_comment|// Offset in file in pages.
r_int
id|from
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
singleline_comment|// Writing offset in first page
r_int
id|to
op_assign
(paren
(paren
id|pos
op_plus
id|write_bytes
op_minus
l_int|1
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* offset of last modified byte in last&n;&t;&t;&t;&t;            page */
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
singleline_comment|// Pages are mapped here.
r_int
id|i
suffix:semicolon
singleline_comment|// Simple counter
r_int
id|blocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Return value (blocks that should be allocated) */
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
singleline_comment|// Current bufferhead and first bufferhead
singleline_comment|// of a page.
r_int
id|block_start
comma
id|block_end
suffix:semicolon
singleline_comment|// Starting and ending offsets of current
singleline_comment|// buffer in the page.
r_struct
id|buffer_head
op_star
id|wait
(braket
l_int|2
)braket
comma
op_star
op_star
id|wait_bh
op_assign
id|wait
suffix:semicolon
singleline_comment|// Buffers for page, if
singleline_comment|// Page appeared to be not up
singleline_comment|// to date. Note how we have
singleline_comment|// at most 2 buffers, this is
singleline_comment|// because we at most may
singleline_comment|// partially overwrite two
singleline_comment|// buffers for one page. One at                                                 // the beginning of write area
singleline_comment|// and one at the end.
singleline_comment|// Everything inthe middle gets                                                 // overwritten totally.
r_struct
id|cpu_key
id|key
suffix:semicolon
singleline_comment|// cpu key of item that we are going to deal with
r_struct
id|item_head
op_star
id|ih
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// pointer to item head that we are going to deal with
r_struct
id|buffer_head
op_star
id|itembuf
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// Buffer head that contains items that we are going to deal with
id|INITIALIZE_PATH
c_func
(paren
id|path
)paren
suffix:semicolon
singleline_comment|// path to item, that we are going to deal with.
id|__u32
op_star
id|item
op_assign
l_int|0
suffix:semicolon
singleline_comment|// pointer to item we are going to deal with
r_int
id|item_pos
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Position in indirect item */
r_if
c_cond
(paren
id|num_pages
OL
l_int|1
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;green-9001: reiserfs_prepare_file_region_for_write called with zero number of pages to process&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* We have 2 loops for pages. In first loop we grab and lock the pages, so&n;       that nobody would touch these until we release the pages. Then&n;       we&squot;d start to deal with mapping buffers to blocks. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|prepared_pages
(braket
id|i
)braket
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
op_plus
id|i
)paren
suffix:semicolon
singleline_comment|// locks the page
r_if
c_cond
(paren
op_logical_neg
id|prepared_pages
(braket
id|i
)braket
)paren
(brace
id|res
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|failed_page_grabbing
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|prepared_pages
(braket
id|i
)braket
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|prepared_pages
(braket
id|i
)braket
comma
id|inode-&gt;i_sb-&gt;s_blocksize
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Let&squot;s count amount of blocks for a case where all the blocks&n;       overwritten are new (we will substract already allocated blocks later)*/
r_if
c_cond
(paren
id|num_pages
OG
l_int|2
)paren
multiline_comment|/* These are full-overwritten pages so we count all the blocks in&n;&t;   these pages are counted as needed to be allocated */
id|blocks
op_assign
(paren
id|num_pages
op_minus
l_int|2
)paren
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_blkbits
)paren
suffix:semicolon
multiline_comment|/* count blocks needed for first page (possibly partially written) */
id|blocks
op_add_assign
(paren
(paren
id|PAGE_CACHE_SIZE
op_minus
id|from
)paren
op_rshift
id|inode-&gt;i_blkbits
)paren
op_plus
op_logical_neg
op_logical_neg
(paren
id|from
op_amp
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* roundup */
multiline_comment|/* Now we account for last page. If last page == first page (we&n;       overwrite only one page), we substract all the blocks past the&n;       last writing position in a page out of already calculated number&n;       of blocks */
id|blocks
op_add_assign
(paren
(paren
id|num_pages
OG
l_int|1
)paren
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_blkbits
)paren
)paren
op_minus
(paren
(paren
id|PAGE_CACHE_SIZE
op_minus
id|to
)paren
op_rshift
id|inode-&gt;i_blkbits
)paren
suffix:semicolon
multiline_comment|/* Note how we do not roundup here since partial blocks still&n;&t;&t;   should be allocated */
multiline_comment|/* Now if all the write area lies past the file end, no point in&n;       maping blocks, since there is none, so we just zero out remaining&n;       parts of first and last pages in write area (if needed) */
r_if
c_cond
(paren
(paren
id|pos
op_amp
op_complement
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
OG
id|inode-&gt;i_size
)paren
(brace
r_if
c_cond
(paren
id|from
op_ne
l_int|0
)paren
(brace
multiline_comment|/* First page needs to be partially zeroed */
r_char
op_star
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|prepared_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
comma
l_int|0
comma
id|from
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|to
op_ne
id|PAGE_CACHE_SIZE
)paren
(brace
multiline_comment|/* Last page needs to be partially zeroed */
r_char
op_star
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|prepared_pages
(braket
id|num_pages
op_minus
l_int|1
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|to
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|to
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
multiline_comment|/* Since all blocks are new - use already calculated value */
r_return
id|blocks
suffix:semicolon
)brace
multiline_comment|/* Well, since we write somewhere into the middle of a file, there is&n;       possibility we are writing over some already allocated blocks, so&n;       let&squot;s map these blocks and substract number of such blocks out of blocks&n;       we need to allocate (calculated above) */
multiline_comment|/* Mask write position to start on blocksize, we do it out of the&n;       loop for performance reasons */
id|pos
op_and_assign
op_complement
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set cpu key to the starting position in a file (on left block boundary)*/
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
l_int|1
op_plus
(paren
(paren
id|pos
)paren
op_amp
op_complement
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
comma
id|TYPE_ANY
comma
l_int|3
multiline_comment|/*key length*/
)paren
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
singleline_comment|// We need that for at least search_by_key()
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_pages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|head
op_assign
id|page_buffers
c_func
(paren
id|prepared_pages
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* For each buffer in the page */
r_for
c_loop
(paren
id|bh
op_assign
id|head
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-9002: Allocated but absent buffer for a page?&quot;
)paren
suffix:semicolon
multiline_comment|/* Find where this buffer ends */
id|block_end
op_assign
id|block_start
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_and
id|block_end
op_le
id|from
)paren
multiline_comment|/* if this buffer is before requested data to map, skip it*/
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|num_pages
op_minus
l_int|1
op_logical_and
id|block_start
op_ge
id|to
)paren
(brace
multiline_comment|/* If this buffer is after requested data to map, abort&n;&t;&t;       processing of current page */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|bh-&gt;b_blocknr
op_ne
l_int|0
)paren
(brace
multiline_comment|/* This is optimisation for a case where buffer is mapped&n;&t;&t;       and have blocknumber assigned. In case significant amount&n;&t;&t;       of such buffers are present, we may avoid some amount&n;&t;&t;       of search_by_key calls.&n;&t;&t;       Probably it would be possible to move parts of this code&n;&t;&t;       out of BKL, but I afraid that would overcomplicate code&n;&t;&t;       without any noticeable benefit.&n;&t;&t;    */
id|item_pos
op_increment
suffix:semicolon
multiline_comment|/* Update the key */
id|set_cpu_key_k_offset
c_func
(paren
op_amp
id|key
comma
id|cpu_key_k_offset
c_func
(paren
op_amp
id|key
)paren
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
singleline_comment|// Decrease the amount of blocks that need to be
singleline_comment|// allocated
r_continue
suffix:semicolon
singleline_comment|// Go to the next buffer
)brace
r_if
c_cond
(paren
op_logical_neg
id|itembuf
op_logical_or
multiline_comment|/* if first iteration */
id|item_pos
op_ge
id|ih_item_len
c_func
(paren
id|ih
)paren
op_div
id|UNFM_P_SIZE
)paren
(brace
multiline_comment|/* or if we progressed past the&n;&t;&t;&t;&t;&t;&t;  current unformatted_item */
multiline_comment|/* Try to find next item */
id|res
op_assign
id|search_for_position_by_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
multiline_comment|/* Abort if no more items */
r_if
c_cond
(paren
id|res
op_ne
id|POSITION_FOUND
)paren
r_break
suffix:semicolon
multiline_comment|/* Update information about current indirect item */
id|itembuf
op_assign
id|get_last_bh
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item
op_assign
id|get_item
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item_pos
op_assign
id|path.pos_in_item
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|is_indirect_le_ih
(paren
id|ih
)paren
comma
l_string|&quot;green-9003: indirect item expected&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* See if there is some block associated with the file&n;&t;&t;   at that position, map the buffer to this block */
r_if
c_cond
(paren
id|get_block_num
c_func
(paren
id|item
comma
id|item_pos
)paren
)paren
(brace
id|map_bh
c_func
(paren
id|bh
comma
id|inode-&gt;i_sb
comma
id|get_block_num
c_func
(paren
id|item
comma
id|item_pos
)paren
)paren
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
singleline_comment|// Decrease the amount of blocks that need to be
singleline_comment|// allocated
)brace
id|item_pos
op_increment
suffix:semicolon
multiline_comment|/* Update the key */
id|set_cpu_key_k_offset
c_func
(paren
op_amp
id|key
comma
id|cpu_key_k_offset
c_func
(paren
op_amp
id|key
)paren
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
)brace
)brace
id|pathrelse
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
singleline_comment|// Free the path
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* Now zero out unmappend buffers for the first and last pages of&n;&t;   write area or issue read requests if page is mapped. */
multiline_comment|/* First page, see if it is not uptodate */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|prepared_pages
(braket
l_int|0
)braket
)paren
)paren
(brace
id|head
op_assign
id|page_buffers
c_func
(paren
id|prepared_pages
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* For each buffer in page */
r_for
c_loop
(paren
id|bh
op_assign
id|head
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-9002: Allocated but absent buffer for a page?&quot;
)paren
suffix:semicolon
multiline_comment|/* Find where this buffer ends */
id|block_end
op_assign
id|block_start
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
)paren
multiline_comment|/* if this buffer is before requested data to map, skip it*/
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|block_start
OL
id|from
)paren
(brace
multiline_comment|/* Aha, our partial buffer */
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* If it is mapped, we need to&n;&t;&t;&t;&t;&t;&t;  issue READ request for it to&n;&t;&t;&t;&t;&t;&t;  not loose data */
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
op_star
id|wait_bh
op_increment
op_assign
id|bh
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not mapped, zero it */
r_char
op_star
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|prepared_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|from
op_minus
id|block_start
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Last page, see if it is not uptodate, or if the last page is past the end of the file. */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|prepared_pages
(braket
id|num_pages
op_minus
l_int|1
)braket
)paren
op_logical_or
(paren
(paren
id|pos
op_plus
id|write_bytes
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
OG
(paren
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
id|head
op_assign
id|page_buffers
c_func
(paren
id|prepared_pages
(braket
id|num_pages
op_minus
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* for each buffer in page */
r_for
c_loop
(paren
id|bh
op_assign
id|head
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-9002: Allocated but absent buffer for a page?&quot;
)paren
suffix:semicolon
multiline_comment|/* Find where this buffer ends */
id|block_end
op_assign
id|block_start
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_start
op_ge
id|to
)paren
multiline_comment|/* if this buffer is after requested data to map, skip it*/
r_break
suffix:semicolon
r_if
c_cond
(paren
id|block_end
OG
id|to
)paren
(brace
multiline_comment|/* Aha, our partial buffer */
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* If it is mapped, we need to&n;&t;&t;&t;&t;&t;&t;  issue READ request for it to&n;&t;&t;&t;&t;&t;&t;  not loose data */
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
op_star
id|wait_bh
op_increment
op_assign
id|bh
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Not mapped, zero it */
r_char
op_star
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|prepared_pages
(braket
id|num_pages
op_minus
l_int|1
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|to
comma
l_int|0
comma
id|block_end
op_minus
id|to
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* Wait for read requests we made to happen, if necessary */
r_while
c_loop
(paren
id|wait_bh
OG
id|wait
)paren
(brace
id|wait_on_buffer
c_func
(paren
op_star
op_decrement
id|wait_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
op_star
id|wait_bh
)paren
)paren
(brace
id|res
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|failed_read
suffix:semicolon
)brace
)brace
r_return
id|blocks
suffix:semicolon
id|failed_page_grabbing
suffix:colon
id|num_pages
op_assign
id|i
suffix:semicolon
id|failed_read
suffix:colon
id|reiserfs_unprepare_pages
c_func
(paren
id|prepared_pages
comma
id|num_pages
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Write @count bytes at position @ppos in a file indicated by @file&n;   from the buffer @buf.  &n;&n;   generic_file_write() is only appropriate for filesystems that are not seeking to optimize performance and want&n;   something simple that works.  It is not for serious use by general purpose filesystems, excepting the one that it was&n;   written for (ext2/3).  This is for several reasons:&n;&n;   * It has no understanding of any filesystem specific optimizations.&n;&n;   * It enters the filesystem repeatedly for each page that is written.&n;&n;   * It depends on reiserfs_get_block() function which if implemented by reiserfs performs costly search_by_key&n;   * operation for each page it is supplied with. By contrast reiserfs_file_write() feeds as much as possible at a time&n;   * to reiserfs which allows for fewer tree traversals.&n;&n;   * Each indirect pointer insertion takes a lot of cpu, because it involves memory moves inside of blocks.&n;&n;   * Asking the block allocation code for blocks one at a time is slightly less efficient.&n;&n;   All of these reasons for not using only generic file write were understood back when reiserfs was first miscoded to&n;   use it, but we were in a hurry to make code freeze, and so it couldn&squot;t be revised then.  This new code should make&n;   things right finally.&n;&n;   Future Features: providing search_by_key with hints.&n;&n;*/
DECL|function|reiserfs_file_write
id|ssize_t
id|reiserfs_file_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
multiline_comment|/* the file we are going to write into */
r_const
r_char
op_star
id|buf
comma
multiline_comment|/*  pointer to user supplied data&n;(in userspace) */
r_int
id|count
comma
multiline_comment|/* amount of bytes to write */
id|loff_t
op_star
id|ppos
multiline_comment|/* pointer to position in file that we start writing at. Should be updated to&n;                                           * new current position before returning. */
)paren
(brace
r_int
id|already_written
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Number of bytes already written to the file.
id|loff_t
id|pos
suffix:semicolon
singleline_comment|// Current position in the file.
r_int
id|res
suffix:semicolon
singleline_comment|// return value of various functions that we call.
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
singleline_comment|// Inode of the file that we are writing to.
r_struct
id|page
op_star
id|prepared_pages
(braket
id|REISERFS_WRITE_PAGES_AT_A_TIME
)braket
suffix:semicolon
multiline_comment|/* To simplify coding at this time, we store&n;&t;&t;&t;&t;   locked pages in array for now */
r_if
c_cond
(paren
id|count
op_le
id|PAGE_CACHE_SIZE
op_logical_or
id|file-&gt;f_flags
op_amp
id|O_DIRECT
)paren
r_return
id|generic_file_write
c_func
(paren
id|file
comma
id|buf
comma
id|count
comma
id|ppos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|ssize_t
)paren
id|count
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
singleline_comment|// locks the entire file for just us
id|pos
op_assign
op_star
id|ppos
suffix:semicolon
multiline_comment|/* Check if we can write to specified region of file, file&n;       is not overly big and this kind of stuff. Adjust pos and&n;       count, if needed */
id|res
op_assign
id|generic_write_checks
c_func
(paren
id|inode
comma
id|file
comma
op_amp
id|pos
comma
op_amp
id|count
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|remove_suid
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
id|inode_update_time
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Both mtime and ctime */
singleline_comment|// Ok, we are done with all the checks.
singleline_comment|// Now we should start real work
multiline_comment|/* If we are going to write past the file&squot;s packed tail or if we are going&n;       to overwrite part of the tail, we need that tail to be converted into&n;       unformatted node */
id|res
op_assign
id|reiserfs_check_for_tail_and_convert
c_func
(paren
id|inode
comma
id|pos
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/* This is the main loop in which we running until some error occures&n;&t;   or until we write all of the data. */
r_int
id|num_pages
suffix:semicolon
multiline_comment|/* amount of pages we are going to write this iteration */
r_int
id|write_bytes
suffix:semicolon
multiline_comment|/* amount of bytes to write during this iteration */
r_int
id|blocks_to_allocate
suffix:semicolon
multiline_comment|/* how much blocks we need to allocate for&n;&t;&t;&t;&t;   this iteration */
multiline_comment|/*  (pos &amp; (PAGE_CACHE_SIZE-1)) is an idiom for offset into a page of pos*/
id|num_pages
op_assign
op_logical_neg
op_logical_neg
(paren
(paren
id|pos
op_plus
id|count
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
op_plus
multiline_comment|/* round up partial&n;&t;&t;&t;&t;&t;&t;&t;  pages */
(paren
(paren
id|count
op_plus
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
multiline_comment|/* convert size to amount of&n;&t;&t;&t;&t;&t;&t;   pages */
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_pages
OG
id|REISERFS_WRITE_PAGES_AT_A_TIME
op_logical_or
id|num_pages
OG
id|reiserfs_can_fit_pages
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
multiline_comment|/* If we were asked to write more data than we want to or if there&n;&t;       is not that much space, then we shorten amount of data to write&n;&t;       for this iteration. */
id|num_pages
op_assign
id|min_t
c_func
(paren
r_int
comma
id|REISERFS_WRITE_PAGES_AT_A_TIME
comma
id|reiserfs_can_fit_pages
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
suffix:semicolon
multiline_comment|/* Also we should not forget to set size in bytes accordingly */
id|write_bytes
op_assign
(paren
id|num_pages
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_minus
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* If position is not on the&n;&t;&t;&t;&t;&t;    start of the page, we need&n;&t;&t;&t;&t;&t;    to substract the offset&n;&t;&t;&t;&t;&t;    within page */
)brace
r_else
id|write_bytes
op_assign
id|count
suffix:semicolon
multiline_comment|/* reserve the blocks to be allocated later, so that later on&n;&t;   we still have the space to write the blocks to */
id|reiserfs_claim_blocks_to_be_allocated
c_func
(paren
id|inode-&gt;i_sb
comma
id|num_pages
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_blkbits
)paren
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|num_pages
)paren
(brace
multiline_comment|/* If we do not have enough space even for */
id|res
op_assign
op_minus
id|ENOSPC
suffix:semicolon
multiline_comment|/* single page, return -ENOSPC */
r_if
c_cond
(paren
id|pos
OG
(paren
id|inode-&gt;i_size
op_amp
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
)paren
r_break
suffix:semicolon
singleline_comment|// In case we are writing past the file end, break.
singleline_comment|// Otherwise we are possibly overwriting the file, so
singleline_comment|// let&squot;s set write size to be equal or less than blocksize.
singleline_comment|// This way we get it correctly for file holes.
singleline_comment|// But overwriting files on absolutelly full volumes would not
singleline_comment|// be very efficient. Well, people are not supposed to fill
singleline_comment|// 100% of disk space anyway.
id|write_bytes
op_assign
id|min_t
c_func
(paren
r_int
comma
id|count
comma
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
(paren
id|pos
op_amp
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|num_pages
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Prepare for writing into the region, read in all the&n;&t;   partially overwritten pages, if needed. And lock the pages,&n;&t;   so that nobody else can access these until we are done.&n;&t;   We get number of actual blocks needed as a result.*/
id|blocks_to_allocate
op_assign
id|reiserfs_prepare_file_region_for_write
c_func
(paren
id|inode
comma
id|pos
comma
id|num_pages
comma
id|write_bytes
comma
id|prepared_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks_to_allocate
OL
l_int|0
)paren
(brace
id|res
op_assign
id|blocks_to_allocate
suffix:semicolon
id|reiserfs_release_claimed_blocks
c_func
(paren
id|inode-&gt;i_sb
comma
id|num_pages
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_blkbits
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* First we correct our estimate of how many blocks we need */
id|reiserfs_release_claimed_blocks
c_func
(paren
id|inode-&gt;i_sb
comma
(paren
id|num_pages
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
)paren
op_minus
id|blocks_to_allocate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks_to_allocate
OG
l_int|0
)paren
(brace
multiline_comment|/*We only allocate blocks if we need to*/
multiline_comment|/* Fill in all the possible holes and append the file if needed */
id|res
op_assign
id|reiserfs_allocate_blocks_for_region
c_func
(paren
id|inode
comma
id|pos
comma
id|num_pages
comma
id|write_bytes
comma
id|prepared_pages
comma
id|blocks_to_allocate
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pos
op_plus
id|write_bytes
OG
id|inode-&gt;i_size
)paren
(brace
multiline_comment|/* File might have grown even though no new blocks were added */
id|inode-&gt;i_size
op_assign
id|pos
op_plus
id|write_bytes
suffix:semicolon
id|inode-&gt;i_sb-&gt;s_op
op_member_access_from_pointer
id|dirty_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/* well, we have allocated the blocks, so it is time to free&n;&t;   the reservation we made earlier. */
id|reiserfs_release_claimed_blocks
c_func
(paren
id|inode-&gt;i_sb
comma
id|blocks_to_allocate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|reiserfs_unprepare_pages
c_func
(paren
id|prepared_pages
comma
id|num_pages
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* NOTE that allocating blocks and filling blocks can be done in reverse order&n;   and probably we would do that just to get rid of garbage in files after a&n;   crash */
multiline_comment|/* Copy data from user-supplied buffer to file&squot;s pages */
id|res
op_assign
id|reiserfs_copy_from_user_to_file_region
c_func
(paren
id|pos
comma
id|num_pages
comma
id|write_bytes
comma
id|prepared_pages
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|reiserfs_unprepare_pages
c_func
(paren
id|prepared_pages
comma
id|num_pages
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Send the pages to disk and unlock them. */
id|res
op_assign
id|reiserfs_submit_file_region_for_write
c_func
(paren
id|pos
comma
id|num_pages
comma
id|write_bytes
comma
id|prepared_pages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
r_break
suffix:semicolon
id|already_written
op_add_assign
id|write_bytes
suffix:semicolon
id|buf
op_add_assign
id|write_bytes
suffix:semicolon
op_star
id|ppos
op_assign
id|pos
op_add_assign
id|write_bytes
suffix:semicolon
id|count
op_sub_assign
id|write_bytes
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_SYNC
)paren
op_logical_or
id|IS_SYNC
c_func
(paren
id|inode
)paren
)paren
id|res
op_assign
id|generic_osync_inode
c_func
(paren
id|inode
comma
id|OSYNC_METADATA
op_or
id|OSYNC_DATA
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
(paren
id|already_written
op_ne
l_int|0
)paren
ques
c_cond
id|already_written
suffix:colon
id|res
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
singleline_comment|// unlock the file on exit.
r_return
id|res
suffix:semicolon
)brace
DECL|variable|reiserfs_file_operations
r_struct
id|file_operations
id|reiserfs_file_operations
op_assign
(brace
dot
id|read
op_assign
id|generic_file_read
comma
dot
id|write
op_assign
id|reiserfs_file_write
comma
dot
id|ioctl
op_assign
id|reiserfs_ioctl
comma
dot
id|mmap
op_assign
id|generic_file_mmap
comma
dot
id|release
op_assign
id|reiserfs_file_release
comma
dot
id|fsync
op_assign
id|reiserfs_sync_file
comma
dot
id|sendfile
op_assign
id|generic_file_sendfile
comma
)brace
suffix:semicolon
DECL|variable|reiserfs_file_inode_operations
r_struct
id|inode_operations
id|reiserfs_file_inode_operations
op_assign
(brace
dot
id|truncate
op_assign
id|reiserfs_vfs_truncate_file
comma
dot
id|setattr
op_assign
id|reiserfs_setattr
comma
)brace
suffix:semicolon
eof
