multiline_comment|/*&n; * linux/fs/reiserfs/xattr.c&n; *&n; * Copyright (c) 2002 by Jeff Mahoney, &lt;jeffm@suse.com&gt;&n; *&n; */
multiline_comment|/*&n; * In order to implement EA/ACLs in a clean, backwards compatible manner,&n; * they are implemented as files in a &quot;private&quot; directory.&n; * Each EA is in it&squot;s own file, with the directory layout like so (/ is assumed&n; * to be relative to fs root). Inside the /.reiserfs_priv/xattrs directory,&n; * directories named using the capital-hex form of the objectid and&n; * generation number are used. Inside each directory are individual files&n; * named with the name of the extended attribute.&n; *&n; * So, for objectid 12648430, we could have:&n; * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_access&n; * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_default&n; * /.reiserfs_priv/xattrs/C0FFEE.0/user.Content-Type&n; * .. or similar.&n; *&n; * The file contents are the text of the EA. The size is known based on the&n; * stat data describing the file.&n; *&n; * In the case of system.posix_acl_access and system.posix_acl_default, since&n; * these are special cases for filesystem ACLs, they are interpreted by the&n; * kernel, in addition, they are negatively and positively cached and attached&n; * to the inode so that unnecessary lookups are avoided.&n; */
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/xattr.h&gt;
macro_line|#include &lt;linux/reiserfs_xattr.h&gt;
macro_line|#include &lt;linux/reiserfs_acl.h&gt;
macro_line|#include &lt;linux/mbcache.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/checksum.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
DECL|macro|FL_READONLY
mdefine_line|#define FL_READONLY 128
DECL|macro|FL_DIR_SEM_HELD
mdefine_line|#define FL_DIR_SEM_HELD 256
DECL|macro|PRIVROOT_NAME
mdefine_line|#define PRIVROOT_NAME &quot;.reiserfs_priv&quot;
DECL|macro|XAROOT_NAME
mdefine_line|#define XAROOT_NAME   &quot;xattrs&quot;
r_static
r_struct
id|reiserfs_xattr_handler
op_star
id|find_xattr_handler_prefix
(paren
r_const
r_char
op_star
id|prefix
)paren
suffix:semicolon
r_static
r_struct
id|dentry
op_star
DECL|function|create_xa_root
id|create_xa_root
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|dentry
op_star
id|privroot
op_assign
id|dget
(paren
id|REISERFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|priv_root
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|xaroot
suffix:semicolon
multiline_comment|/* This needs to be created at mount-time */
r_if
c_cond
(paren
op_logical_neg
id|privroot
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EOPNOTSUPP
)paren
suffix:semicolon
id|xaroot
op_assign
id|lookup_one_len
(paren
id|XAROOT_NAME
comma
id|privroot
comma
id|strlen
(paren
id|XAROOT_NAME
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xaroot
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|xaroot-&gt;d_inode
)paren
(brace
r_int
id|err
suffix:semicolon
id|down
(paren
op_amp
id|privroot-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|privroot-&gt;d_inode-&gt;i_op-&gt;mkdir
(paren
id|privroot-&gt;d_inode
comma
id|xaroot
comma
l_int|0700
)paren
suffix:semicolon
id|up
(paren
op_amp
id|privroot-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|dput
(paren
id|xaroot
)paren
suffix:semicolon
id|dput
(paren
id|privroot
)paren
suffix:semicolon
r_return
id|ERR_PTR
(paren
id|err
)paren
suffix:semicolon
)brace
id|REISERFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|xattr_root
op_assign
id|dget
(paren
id|xaroot
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|dput
(paren
id|privroot
)paren
suffix:semicolon
r_return
id|xaroot
suffix:semicolon
)brace
multiline_comment|/* This will return a dentry, or error, refering to the xa root directory.&n; * If the xa root doesn&squot;t exist yet, the dentry will be returned without&n; * an associated inode. This dentry can be used with -&gt;mkdir to create&n; * the xa directory. */
r_static
r_struct
id|dentry
op_star
DECL|function|__get_xa_root
id|__get_xa_root
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|dentry
op_star
id|privroot
op_assign
id|dget
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|priv_root
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|xaroot
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|privroot
)paren
op_logical_or
op_logical_neg
id|privroot
)paren
r_return
id|privroot
suffix:semicolon
id|xaroot
op_assign
id|lookup_one_len
(paren
id|XAROOT_NAME
comma
id|privroot
comma
id|strlen
(paren
id|XAROOT_NAME
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xaroot
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|xaroot-&gt;d_inode
)paren
(brace
id|dput
(paren
id|xaroot
)paren
suffix:semicolon
id|xaroot
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|xattr_root
op_assign
id|dget
(paren
id|xaroot
)paren
suffix:semicolon
id|out
suffix:colon
id|dput
(paren
id|privroot
)paren
suffix:semicolon
r_return
id|xaroot
suffix:semicolon
)brace
multiline_comment|/* Returns the dentry (or NULL) referring to the root of the extended&n; * attribute directory tree. If it has already been retreived, it is used.&n; * Otherwise, we attempt to retreive it from disk. It may also return&n; * a pointer-encoded error.&n; */
r_static
r_inline
r_struct
id|dentry
op_star
DECL|function|get_xa_root
id|get_xa_root
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|dget
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|xattr_root
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
id|dentry
op_assign
id|__get_xa_root
(paren
id|s
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/* Opens the directory corresponding to the inode&squot;s extended attribute store.&n; * If flags allow, the tree to the directory may be created. If creation is&n; * prohibited, -ENODATA is returned. */
r_static
r_struct
id|dentry
op_star
DECL|function|open_xa_dir
id|open_xa_dir
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|xaroot
comma
op_star
id|xadir
suffix:semicolon
r_char
id|namebuf
(braket
l_int|17
)braket
suffix:semicolon
id|xaroot
op_assign
id|get_xa_root
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xaroot
)paren
)paren
(brace
r_return
id|xaroot
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|xaroot
)paren
(brace
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
op_logical_or
id|flags
op_amp
id|XATTR_CREATE
)paren
(brace
id|xaroot
op_assign
id|create_xa_root
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xaroot
)paren
)paren
r_return
id|xaroot
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xaroot
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|ENODATA
)paren
suffix:semicolon
)brace
multiline_comment|/* ok, we have xaroot open */
id|snprintf
(paren
id|namebuf
comma
r_sizeof
(paren
id|namebuf
)paren
comma
l_string|&quot;%X.%X&quot;
comma
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
comma
id|inode-&gt;i_generation
)paren
suffix:semicolon
id|xadir
op_assign
id|lookup_one_len
(paren
id|namebuf
comma
id|xaroot
comma
id|strlen
(paren
id|namebuf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xadir
)paren
)paren
(brace
id|dput
(paren
id|xaroot
)paren
suffix:semicolon
r_return
id|xadir
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xadir-&gt;d_inode
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
op_logical_or
id|flags
op_amp
id|XATTR_CREATE
)paren
(brace
multiline_comment|/* Although there is nothing else trying to create this directory,&n;             * another directory with the same hash may be created, so we need&n;             * to protect against that */
id|err
op_assign
id|xaroot-&gt;d_inode-&gt;i_op-&gt;mkdir
(paren
id|xaroot-&gt;d_inode
comma
id|xadir
comma
l_int|0700
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|dput
(paren
id|xaroot
)paren
suffix:semicolon
id|dput
(paren
id|xadir
)paren
suffix:semicolon
r_return
id|ERR_PTR
(paren
id|err
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|xadir-&gt;d_inode
)paren
(brace
id|dput
(paren
id|xaroot
)paren
suffix:semicolon
id|dput
(paren
id|xadir
)paren
suffix:semicolon
r_return
id|ERR_PTR
(paren
op_minus
id|ENODATA
)paren
suffix:semicolon
)brace
multiline_comment|/* Newly created object.. Need to mark it private */
id|REISERFS_I
c_func
(paren
id|xadir-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_priv_object
suffix:semicolon
)brace
id|dput
(paren
id|xaroot
)paren
suffix:semicolon
r_return
id|xadir
suffix:semicolon
)brace
multiline_comment|/* Returns a dentry corresponding to a specific extended attribute file&n; * for the inode. If flags allow, the file is created. Otherwise, a&n; * valid or negative dentry, or an error is returned. */
r_static
r_struct
id|dentry
op_star
DECL|function|get_xa_file_dentry
id|get_xa_file_dentry
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|xadir
comma
op_star
id|xafile
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|xadir
op_assign
id|open_xa_dir
(paren
id|inode
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xadir
)paren
)paren
(brace
r_return
id|ERR_PTR
(paren
id|PTR_ERR
(paren
id|xadir
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xadir
op_logical_and
op_logical_neg
id|xadir-&gt;d_inode
)paren
(brace
id|dput
(paren
id|xadir
)paren
suffix:semicolon
r_return
id|ERR_PTR
(paren
op_minus
id|ENODATA
)paren
suffix:semicolon
)brace
id|xafile
op_assign
id|lookup_one_len
(paren
id|name
comma
id|xadir
comma
id|strlen
(paren
id|name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xafile
)paren
)paren
(brace
id|dput
(paren
id|xadir
)paren
suffix:semicolon
r_return
id|ERR_PTR
(paren
id|PTR_ERR
(paren
id|xafile
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xafile-&gt;d_inode
)paren
(brace
multiline_comment|/* file exists */
r_if
c_cond
(paren
id|flags
op_amp
id|XATTR_CREATE
)paren
(brace
id|err
op_assign
op_minus
id|EEXIST
suffix:semicolon
id|dput
(paren
id|xafile
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|XATTR_REPLACE
op_logical_or
id|flags
op_amp
id|FL_READONLY
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* inode-&gt;i_sem is down, so nothing else can try to create&n;         * the same xattr */
id|err
op_assign
id|xadir-&gt;d_inode-&gt;i_op-&gt;create
(paren
id|xadir-&gt;d_inode
comma
id|xafile
comma
l_int|0700
op_or
id|S_IFREG
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|dput
(paren
id|xafile
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Newly created object.. Need to mark it private */
id|REISERFS_I
c_func
(paren
id|xafile-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_priv_object
suffix:semicolon
)brace
id|out
suffix:colon
id|dput
(paren
id|xadir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|xafile
op_assign
id|ERR_PTR
(paren
id|err
)paren
suffix:semicolon
r_return
id|xafile
suffix:semicolon
)brace
multiline_comment|/* Opens a file pointer to the attribute associated with inode */
r_static
r_struct
id|file
op_star
DECL|function|open_xa_file
id|open_xa_file
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|xafile
suffix:semicolon
r_struct
id|file
op_star
id|fp
suffix:semicolon
id|xafile
op_assign
id|get_xa_file_dentry
(paren
id|inode
comma
id|name
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xafile
)paren
)paren
r_return
id|ERR_PTR
(paren
id|PTR_ERR
(paren
id|xafile
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|xafile-&gt;d_inode
)paren
(brace
id|dput
(paren
id|xafile
)paren
suffix:semicolon
r_return
id|ERR_PTR
(paren
op_minus
id|ENODATA
)paren
suffix:semicolon
)brace
id|fp
op_assign
id|dentry_open
(paren
id|xafile
comma
l_int|NULL
comma
id|O_RDWR
)paren
suffix:semicolon
multiline_comment|/* dentry_open dputs the dentry if it fails */
r_return
id|fp
suffix:semicolon
)brace
multiline_comment|/*&n; * this is very similar to fs/reiserfs/dir.c:reiserfs_readdir, but&n; * we need to drop the path before calling the filldir struct.  That&n; * would be a big performance hit to the non-xattr case, so I&squot;ve copied&n; * the whole thing for now. --clm&n; *&n; * the big difference is that I go backwards through the directory,&n; * and don&squot;t mess with f-&gt;f_pos, but the idea is the same.  Do some&n; * action on each and every entry in the directory.&n; *&n; * we&squot;re called with i_sem held, so there are no worries about the directory&n; * changing underneath us.&n; */
DECL|function|__xattr_readdir
r_static
r_int
id|__xattr_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|cpu_key
id|pos_key
suffix:semicolon
multiline_comment|/* key of current position in the directory (key of directory entry) */
id|INITIALIZE_PATH
(paren
id|path_to_entry
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|entry_num
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
comma
id|tmp_ih
suffix:semicolon
r_int
id|search_res
suffix:semicolon
r_char
op_star
id|local_buf
suffix:semicolon
id|loff_t
id|next_pos
suffix:semicolon
r_char
id|small_buf
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* avoid kmalloc if we can */
r_struct
id|reiserfs_de_head
op_star
id|deh
suffix:semicolon
r_int
id|d_reclen
suffix:semicolon
r_char
op_star
id|d_name
suffix:semicolon
id|off_t
id|d_off
suffix:semicolon
id|ino_t
id|d_ino
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
multiline_comment|/* form key for search the next directory entry using f_pos field of&n;       file structure */
id|next_pos
op_assign
id|max_reiserfs_offset
c_func
(paren
id|inode
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|research
suffix:colon
r_if
c_cond
(paren
id|next_pos
op_le
id|DOT_DOT_OFFSET
)paren
r_break
suffix:semicolon
id|make_cpu_key
(paren
op_amp
id|pos_key
comma
id|inode
comma
id|next_pos
comma
id|TYPE_DIRENTRY
comma
l_int|3
)paren
suffix:semicolon
id|search_res
op_assign
id|search_by_entry_key
c_func
(paren
id|inode-&gt;i_sb
comma
op_amp
id|pos_key
comma
op_amp
id|path_to_entry
comma
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_res
op_eq
id|IO_ERROR
)paren
(brace
singleline_comment|// FIXME: we could just skip part of directory which could
singleline_comment|// not be read
id|pathrelse
c_func
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|search_res
op_eq
id|NAME_NOT_FOUND
)paren
id|de.de_entry_num
op_decrement
suffix:semicolon
id|set_de_name_and_namelen
c_func
(paren
op_amp
id|de
)paren
suffix:semicolon
id|entry_num
op_assign
id|de.de_entry_num
suffix:semicolon
id|deh
op_assign
op_amp
(paren
id|de.de_deh
(braket
id|entry_num
)braket
)paren
suffix:semicolon
id|bh
op_assign
id|de.de_bh
suffix:semicolon
id|ih
op_assign
id|de.de_ih
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_direntry_le_ih
c_func
(paren
id|ih
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;not direntry %h&quot;
comma
id|ih
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|copy_item_head
c_func
(paren
op_amp
id|tmp_ih
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* we must have found item, that is item of this directory, */
id|RFALSE
c_func
(paren
id|COMP_SHORT_KEYS
(paren
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
op_amp
id|pos_key
)paren
comma
l_string|&quot;vs-9000: found item %h does not match to dir we readdir %K&quot;
comma
id|ih
comma
op_amp
id|pos_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deh_offset
c_func
(paren
id|deh
)paren
op_le
id|DOT_DOT_OFFSET
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* look for the previous entry in the directory */
id|next_pos
op_assign
id|deh_offset
(paren
id|deh
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de_visible
(paren
id|deh
)paren
)paren
multiline_comment|/* it is hidden entry */
r_continue
suffix:semicolon
id|d_reclen
op_assign
id|entry_length
c_func
(paren
id|bh
comma
id|ih
comma
id|entry_num
)paren
suffix:semicolon
id|d_name
op_assign
id|B_I_DEH_ENTRY_FILE_NAME
(paren
id|bh
comma
id|ih
comma
id|deh
)paren
suffix:semicolon
id|d_off
op_assign
id|deh_offset
(paren
id|deh
)paren
suffix:semicolon
id|d_ino
op_assign
id|deh_objectid
(paren
id|deh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_name
(braket
id|d_reclen
op_minus
l_int|1
)braket
)paren
id|d_reclen
op_assign
id|strlen
(paren
id|d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_reclen
OG
id|REISERFS_MAX_NAME
c_func
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
)paren
(brace
multiline_comment|/* too big to send back to VFS */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Ignore the .reiserfs_priv entry */
r_if
c_cond
(paren
id|reiserfs_xattrs
(paren
id|inode-&gt;i_sb
)paren
op_logical_and
op_logical_neg
id|old_format_only
c_func
(paren
id|inode-&gt;i_sb
)paren
op_logical_and
id|deh_objectid
(paren
id|deh
)paren
op_eq
id|le32_to_cpu
(paren
id|INODE_PKEY
c_func
(paren
id|REISERFS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|priv_root-&gt;d_inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|d_reclen
op_le
l_int|32
)paren
(brace
id|local_buf
op_assign
id|small_buf
suffix:semicolon
)brace
r_else
(brace
id|local_buf
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|d_reclen
comma
id|GFP_NOFS
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|local_buf
)paren
(brace
id|pathrelse
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|item_moved
(paren
op_amp
id|tmp_ih
comma
op_amp
id|path_to_entry
)paren
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|local_buf
comma
id|d_reclen
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* sigh, must retry.  Do this same offset again */
id|next_pos
op_assign
id|d_off
suffix:semicolon
r_goto
id|research
suffix:semicolon
)brace
)brace
singleline_comment|// Note, that we copy name to user space via temporary
singleline_comment|// buffer (local_buf) because filldir will block if
singleline_comment|// user space buffer is swapped out. At that time
singleline_comment|// entry can move to somewhere else
id|memcpy
(paren
id|local_buf
comma
id|d_name
comma
id|d_reclen
)paren
suffix:semicolon
multiline_comment|/* the filldir function might need to start transactions,&n;&t; * or do who knows what.  Release the path now that we&squot;ve&n;&t; * copied all the important stuff out of the deh&n;&t; */
id|pathrelse
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filldir
(paren
id|dirent
comma
id|local_buf
comma
id|d_reclen
comma
id|d_off
comma
id|d_ino
comma
id|DT_UNKNOWN
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|local_buf
op_ne
id|small_buf
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|local_buf
comma
id|d_reclen
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
r_goto
id|end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|local_buf
op_ne
id|small_buf
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|local_buf
comma
id|d_reclen
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* while */
id|end
suffix:colon
id|pathrelse
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * this could be done with dedicated readdir ops for the xattr files,&n; * but I want to get something working asap&n; * this is stolen from vfs_readdir&n; *&n; */
r_static
DECL|function|xattr_readdir
r_int
id|xattr_readdir
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|filldir_t
id|filler
comma
r_void
op_star
id|buf
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|res
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;readdir
)paren
r_goto
id|out
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
singleline_comment|//        down(&amp;inode-&gt;i_zombie);
id|res
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_DEADDIR
c_func
(paren
id|inode
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|__xattr_readdir
c_func
(paren
id|file
comma
id|buf
comma
id|filler
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
singleline_comment|//        up(&amp;inode-&gt;i_zombie);
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* Internal operations on file data */
r_static
r_inline
r_void
DECL|function|reiserfs_put_page
id|reiserfs_put_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_static
r_struct
id|page
op_star
DECL|function|reiserfs_get_page
id|reiserfs_get_page
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_int
r_int
id|n
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|dir-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
multiline_comment|/* We can deadlock if we try to free dentries,&n;           and an unlink/rmdir has just occured - GFP_NOFS avoids this */
id|mapping-&gt;flags
op_assign
(paren
id|mapping-&gt;flags
op_amp
op_complement
id|__GFP_BITS_MASK
)paren
op_or
id|GFP_NOFS
suffix:semicolon
id|page
op_assign
id|read_cache_page
(paren
id|mapping
comma
id|n
comma
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|wait_on_page_locked
c_func
(paren
id|page
)paren
suffix:semicolon
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|PageError
c_func
(paren
id|page
)paren
)paren
r_goto
id|fail
suffix:semicolon
)brace
r_return
id|page
suffix:semicolon
id|fail
suffix:colon
id|reiserfs_put_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
r_static
r_inline
id|__u32
DECL|function|xattr_hash
id|xattr_hash
(paren
r_const
r_char
op_star
id|msg
comma
r_int
id|len
)paren
(brace
r_return
id|csum_partial
(paren
id|msg
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Generic extended attribute operations that can be used by xa plugins */
multiline_comment|/*&n; * inode-&gt;i_sem: down&n; */
r_int
DECL|function|reiserfs_xattr_set
id|reiserfs_xattr_set
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|buffer
comma
r_int
id|buffer_size
comma
r_int
id|flags
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|file
op_star
id|fp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_int
id|file_pos
op_assign
l_int|0
suffix:semicolon
r_int
id|buffer_pos
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|xinode
suffix:semicolon
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|__u32
id|xahash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_IMMUTABLE
(paren
id|inode
)paren
op_logical_or
id|IS_APPEND
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|get_inode_sd_version
(paren
id|inode
)paren
op_eq
id|STAT_DATA_V1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Empty xattrs are ok, they&squot;re just empty files, no hash */
r_if
c_cond
(paren
id|buffer
op_logical_and
id|buffer_size
)paren
id|xahash
op_assign
id|xattr_hash
(paren
id|buffer
comma
id|buffer_size
)paren
suffix:semicolon
id|open_file
suffix:colon
id|fp
op_assign
id|open_xa_file
(paren
id|inode
comma
id|name
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|fp
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|fp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|xinode
op_assign
id|fp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_has_xattr_dir
suffix:semicolon
multiline_comment|/* we need to copy it off.. */
r_if
c_cond
(paren
id|xinode-&gt;i_nlink
OG
l_int|1
)paren
(brace
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
id|err
op_assign
id|reiserfs_xattr_del
(paren
id|inode
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We just killed the old one, we&squot;re not replacing anymore */
r_if
c_cond
(paren
id|flags
op_amp
id|XATTR_REPLACE
)paren
id|flags
op_and_assign
op_complement
id|XATTR_REPLACE
suffix:semicolon
r_goto
id|open_file
suffix:semicolon
)brace
multiline_comment|/* Resize it so we&squot;re ok to write there */
id|newattrs.ia_size
op_assign
id|buffer_size
suffix:semicolon
id|newattrs.ia_valid
op_assign
id|ATTR_SIZE
op_or
id|ATTR_CTIME
suffix:semicolon
id|down
(paren
op_amp
id|xinode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|notify_change
c_func
(paren
id|fp-&gt;f_dentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_filp
suffix:semicolon
id|mapping
op_assign
id|xinode-&gt;i_mapping
suffix:semicolon
r_while
c_loop
(paren
id|buffer_pos
OL
id|buffer_size
op_logical_or
id|buffer_pos
op_eq
l_int|0
)paren
(brace
r_int
id|chunk
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_int
id|page_offset
op_assign
(paren
id|file_pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_size
op_minus
id|buffer_pos
OG
id|PAGE_CACHE_SIZE
)paren
id|chunk
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_else
id|chunk
op_assign
id|buffer_size
op_minus
id|buffer_pos
suffix:semicolon
id|page
op_assign
id|reiserfs_get_page
(paren
id|xinode
comma
id|file_pos
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|page
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out_filp
suffix:semicolon
)brace
id|lock_page
(paren
id|page
)paren
suffix:semicolon
id|data
op_assign
id|page_address
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_pos
op_eq
l_int|0
)paren
(brace
r_struct
id|reiserfs_xattr_header
op_star
id|rxh
suffix:semicolon
id|skip
op_assign
id|file_pos
op_assign
r_sizeof
(paren
r_struct
id|reiserfs_xattr_header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chunk
op_plus
id|skip
OG
id|PAGE_CACHE_SIZE
)paren
id|chunk
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|skip
suffix:semicolon
id|rxh
op_assign
(paren
r_struct
id|reiserfs_xattr_header
op_star
)paren
id|data
suffix:semicolon
id|rxh-&gt;h_magic
op_assign
id|cpu_to_le32
(paren
id|REISERFS_XATTR_MAGIC
)paren
suffix:semicolon
id|rxh-&gt;h_hash
op_assign
id|cpu_to_le32
(paren
id|xahash
)paren
suffix:semicolon
)brace
id|err
op_assign
id|mapping-&gt;a_ops-&gt;prepare_write
(paren
id|fp
comma
id|page
comma
id|page_offset
comma
id|page_offset
op_plus
id|chunk
op_plus
id|skip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_if
c_cond
(paren
id|buffer
)paren
id|memcpy
(paren
id|data
op_plus
id|skip
comma
id|buffer
op_plus
id|buffer_pos
comma
id|chunk
)paren
suffix:semicolon
id|err
op_assign
id|mapping-&gt;a_ops-&gt;commit_write
(paren
id|fp
comma
id|page
comma
id|page_offset
comma
id|page_offset
op_plus
id|chunk
op_plus
id|skip
)paren
suffix:semicolon
)brace
id|unlock_page
(paren
id|page
)paren
suffix:semicolon
id|reiserfs_put_page
(paren
id|page
)paren
suffix:semicolon
id|buffer_pos
op_add_assign
id|chunk
suffix:semicolon
id|file_pos
op_add_assign
id|chunk
suffix:semicolon
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|buffer_size
op_eq
l_int|0
op_logical_or
op_logical_neg
id|buffer
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* We can&squot;t mark the inode dirty if it&squot;s not hashed. This is the case&n;     * when we&squot;re inheriting the default ACL. If we dirty it, the inode&n;     * gets marked dirty, but won&squot;t (ever) make it onto the dirty list until&n;     * it&squot;s synced explicitly to clear I_DIRTY. This is bad. */
r_if
c_cond
(paren
op_logical_neg
id|hlist_unhashed
c_func
(paren
op_amp
id|inode-&gt;i_hash
)paren
)paren
(brace
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME_SEC
suffix:semicolon
id|mark_inode_dirty
(paren
id|inode
)paren
suffix:semicolon
)brace
id|out_filp
suffix:colon
id|up
(paren
op_amp
id|xinode-&gt;i_sem
)paren
suffix:semicolon
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * inode-&gt;i_sem: down&n; */
r_int
DECL|function|reiserfs_xattr_get
id|reiserfs_xattr_get
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|buffer
comma
r_int
id|buffer_size
)paren
(brace
id|ssize_t
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|file
op_star
id|fp
suffix:semicolon
r_int
id|isize
suffix:semicolon
r_int
id|file_pos
op_assign
l_int|0
suffix:semicolon
r_int
id|buffer_pos
op_assign
l_int|0
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|inode
op_star
id|xinode
suffix:semicolon
id|__u32
id|hash
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* We can&squot;t have xattrs attached to v1 items since they don&squot;t have&n;     * generation numbers */
r_if
c_cond
(paren
id|get_inode_sd_version
(paren
id|inode
)paren
op_eq
id|STAT_DATA_V1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|fp
op_assign
id|open_xa_file
(paren
id|inode
comma
id|name
comma
id|FL_READONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|fp
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|fp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|xinode
op_assign
id|fp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|isize
op_assign
id|xinode-&gt;i_size
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_has_xattr_dir
suffix:semicolon
multiline_comment|/* Just return the size needed */
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|err
op_assign
id|isize
op_minus
r_sizeof
(paren
r_struct
id|reiserfs_xattr_header
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_size
OL
id|isize
op_minus
r_sizeof
(paren
r_struct
id|reiserfs_xattr_header
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
r_while
c_loop
(paren
id|file_pos
OL
id|isize
)paren
(brace
r_int
id|chunk
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|isize
op_minus
id|file_pos
OG
id|PAGE_CACHE_SIZE
)paren
id|chunk
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_else
id|chunk
op_assign
id|isize
op_minus
id|file_pos
suffix:semicolon
id|page
op_assign
id|reiserfs_get_page
(paren
id|xinode
comma
id|file_pos
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|page
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|lock_page
(paren
id|page
)paren
suffix:semicolon
id|data
op_assign
id|page_address
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_pos
op_eq
l_int|0
)paren
(brace
r_struct
id|reiserfs_xattr_header
op_star
id|rxh
op_assign
(paren
r_struct
id|reiserfs_xattr_header
op_star
)paren
id|data
suffix:semicolon
id|skip
op_assign
id|file_pos
op_assign
r_sizeof
(paren
r_struct
id|reiserfs_xattr_header
)paren
suffix:semicolon
id|chunk
op_sub_assign
id|skip
suffix:semicolon
multiline_comment|/* Magic doesn&squot;t match up.. */
r_if
c_cond
(paren
id|rxh-&gt;h_magic
op_ne
id|cpu_to_le32
(paren
id|REISERFS_XATTR_MAGIC
)paren
)paren
(brace
id|unlock_page
(paren
id|page
)paren
suffix:semicolon
id|reiserfs_put_page
(paren
id|page
)paren
suffix:semicolon
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;Invalid magic for xattr (%s) &quot;
l_string|&quot;associated with %k&quot;
comma
id|name
comma
id|INODE_PKEY
(paren
id|inode
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|hash
op_assign
id|le32_to_cpu
(paren
id|rxh-&gt;h_hash
)paren
suffix:semicolon
)brace
id|memcpy
(paren
id|buffer
op_plus
id|buffer_pos
comma
id|data
op_plus
id|skip
comma
id|chunk
)paren
suffix:semicolon
id|unlock_page
(paren
id|page
)paren
suffix:semicolon
id|reiserfs_put_page
(paren
id|page
)paren
suffix:semicolon
id|file_pos
op_add_assign
id|chunk
suffix:semicolon
id|buffer_pos
op_add_assign
id|chunk
suffix:semicolon
id|skip
op_assign
l_int|0
suffix:semicolon
)brace
id|err
op_assign
id|isize
op_minus
r_sizeof
(paren
r_struct
id|reiserfs_xattr_header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xattr_hash
(paren
id|buffer
comma
id|isize
op_minus
r_sizeof
(paren
r_struct
id|reiserfs_xattr_header
)paren
)paren
op_ne
id|hash
)paren
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;Invalid hash for xattr (%s) associated &quot;
l_string|&quot;with %k&quot;
comma
id|name
comma
id|INODE_PKEY
(paren
id|inode
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|out_dput
suffix:colon
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|__reiserfs_xattr_del
id|__reiserfs_xattr_del
(paren
r_struct
id|dentry
op_star
id|xadir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|xadir-&gt;d_inode
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|dentry
op_assign
id|lookup_one_len
(paren
id|name
comma
id|xadir
comma
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|dentry
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
id|err
op_assign
op_minus
id|ENODATA
suffix:semicolon
r_goto
id|out_file
suffix:semicolon
)brace
multiline_comment|/* Skip directories.. */
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
r_goto
id|out_file
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_reiserfs_priv_object
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|dir-&gt;i_sb
comma
l_string|&quot;OID %08x [%.*s/%.*s] doesn&squot;t have &quot;
l_string|&quot;priv flag set [parent is %sset].&quot;
comma
id|le32_to_cpu
(paren
id|INODE_PKEY
(paren
id|dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
comma
id|xadir-&gt;d_name.len
comma
id|xadir-&gt;d_name.name
comma
id|namelen
comma
id|name
comma
id|is_reiserfs_priv_object
(paren
id|xadir-&gt;d_inode
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|err
op_assign
id|dir-&gt;i_op-&gt;unlink
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|d_delete
(paren
id|dentry
)paren
suffix:semicolon
id|out_file
suffix:colon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
r_int
DECL|function|reiserfs_xattr_del
id|reiserfs_xattr_del
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|dir
op_assign
id|open_xa_dir
(paren
id|inode
comma
id|FL_READONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|dir
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|dir
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|__reiserfs_xattr_del
(paren
id|dir
comma
id|name
comma
id|strlen
(paren
id|name
)paren
)paren
suffix:semicolon
id|dput
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME_SEC
suffix:semicolon
id|mark_inode_dirty
(paren
id|inode
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* The following are side effects of other operations that aren&squot;t explicitly&n; * modifying extended attributes. This includes operations such as permissions&n; * or ownership changes, object deletions, etc. */
r_static
r_int
DECL|function|reiserfs_delete_xattrs_filler
id|reiserfs_delete_xattrs_filler
(paren
r_void
op_star
id|buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|loff_t
id|offset
comma
id|ino_t
id|ino
comma
r_int
r_int
id|d_type
)paren
(brace
r_struct
id|dentry
op_star
id|xadir
op_assign
(paren
r_struct
id|dentry
op_star
)paren
id|buf
suffix:semicolon
r_return
id|__reiserfs_xattr_del
(paren
id|xadir
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
)brace
multiline_comment|/* This is called w/ inode-&gt;i_sem downed */
r_int
DECL|function|reiserfs_delete_xattrs
id|reiserfs_delete_xattrs
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|file
op_star
id|fp
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
comma
op_star
id|root
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip out, an xattr has no xattrs associated with it */
r_if
c_cond
(paren
id|is_reiserfs_priv_object
(paren
id|inode
)paren
op_logical_or
id|get_inode_sd_version
(paren
id|inode
)paren
op_eq
id|STAT_DATA_V1
op_logical_or
op_logical_neg
id|reiserfs_xattrs
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|reiserfs_read_lock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|dir
op_assign
id|open_xa_dir
(paren
id|inode
comma
id|FL_READONLY
)paren
suffix:semicolon
id|reiserfs_read_unlock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|dir
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|dir
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode
)paren
(brace
id|dput
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fp
op_assign
id|dentry_open
(paren
id|dir
comma
l_int|NULL
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|fp
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|fp
)paren
suffix:semicolon
multiline_comment|/* dentry_open dputs the dentry if it fails */
r_goto
id|out
suffix:semicolon
)brace
id|lock_kernel
(paren
)paren
suffix:semicolon
id|err
op_assign
id|xattr_readdir
(paren
id|fp
comma
id|reiserfs_delete_xattrs_filler
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|unlock_kernel
(paren
)paren
suffix:semicolon
r_goto
id|out_dir
suffix:semicolon
)brace
multiline_comment|/* Leftovers besides . and .. -- that&squot;s not good. */
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_nlink
op_le
l_int|2
)paren
(brace
id|root
op_assign
id|get_xa_root
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|reiserfs_write_lock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|err
op_assign
id|vfs_rmdir
(paren
id|root-&gt;d_inode
comma
id|dir
)paren
suffix:semicolon
id|reiserfs_write_unlock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|dput
(paren
id|root
)paren
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;Couldn&squot;t remove all entries in directory&quot;
)paren
suffix:semicolon
)brace
id|unlock_kernel
(paren
)paren
suffix:semicolon
id|out_dir
suffix:colon
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
op_complement
id|i_has_xattr_dir
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|struct|reiserfs_chown_buf
r_struct
id|reiserfs_chown_buf
(brace
DECL|member|inode
r_struct
id|inode
op_star
id|inode
suffix:semicolon
DECL|member|xadir
r_struct
id|dentry
op_star
id|xadir
suffix:semicolon
DECL|member|attrs
r_struct
id|iattr
op_star
id|attrs
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* XXX: If there is a better way to do this, I&squot;d love to hear about it */
r_static
r_int
DECL|function|reiserfs_chown_xattrs_filler
id|reiserfs_chown_xattrs_filler
(paren
r_void
op_star
id|buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|loff_t
id|offset
comma
id|ino_t
id|ino
comma
r_int
r_int
id|d_type
)paren
(brace
r_struct
id|reiserfs_chown_buf
op_star
id|chown_buf
op_assign
(paren
r_struct
id|reiserfs_chown_buf
op_star
)paren
id|buf
suffix:semicolon
r_struct
id|dentry
op_star
id|xafile
comma
op_star
id|xadir
op_assign
id|chown_buf-&gt;xadir
suffix:semicolon
r_struct
id|iattr
op_star
id|attrs
op_assign
id|chown_buf-&gt;attrs
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|xafile
op_assign
id|lookup_one_len
(paren
id|name
comma
id|xadir
comma
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|xafile
)paren
)paren
r_return
id|PTR_ERR
(paren
id|xafile
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|xafile-&gt;d_inode
)paren
(brace
id|dput
(paren
id|xafile
)paren
suffix:semicolon
r_return
op_minus
id|ENODATA
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|xafile-&gt;d_inode-&gt;i_mode
)paren
)paren
id|err
op_assign
id|notify_change
(paren
id|xafile
comma
id|attrs
)paren
suffix:semicolon
id|dput
(paren
id|xafile
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_int
DECL|function|reiserfs_chown_xattrs
id|reiserfs_chown_xattrs
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|attrs
)paren
(brace
r_struct
id|file
op_star
id|fp
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_chown_buf
id|buf
suffix:semicolon
r_int
r_int
id|ia_valid
op_assign
id|attrs-&gt;ia_valid
suffix:semicolon
multiline_comment|/* Skip out, an xattr has no xattrs associated with it */
r_if
c_cond
(paren
id|is_reiserfs_priv_object
(paren
id|inode
)paren
op_logical_or
id|get_inode_sd_version
(paren
id|inode
)paren
op_eq
id|STAT_DATA_V1
op_logical_or
op_logical_neg
id|reiserfs_xattrs
c_func
(paren
id|inode-&gt;i_sb
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|reiserfs_read_lock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|dir
op_assign
id|open_xa_dir
(paren
id|inode
comma
id|FL_READONLY
)paren
suffix:semicolon
id|reiserfs_read_unlock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|dir
)paren
)paren
(brace
r_if
c_cond
(paren
id|PTR_ERR
(paren
id|dir
)paren
op_ne
op_minus
id|ENODATA
)paren
id|err
op_assign
id|PTR_ERR
(paren
id|dir
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode
)paren
(brace
id|dput
(paren
id|dir
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|fp
op_assign
id|dentry_open
(paren
id|dir
comma
l_int|NULL
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|fp
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|fp
)paren
suffix:semicolon
multiline_comment|/* dentry_open dputs the dentry if it fails */
r_goto
id|out
suffix:semicolon
)brace
id|lock_kernel
(paren
)paren
suffix:semicolon
id|attrs-&gt;ia_valid
op_and_assign
(paren
id|ATTR_UID
op_or
id|ATTR_GID
op_or
id|ATTR_CTIME
)paren
suffix:semicolon
id|buf.xadir
op_assign
id|dir
suffix:semicolon
id|buf.attrs
op_assign
id|attrs
suffix:semicolon
id|buf.inode
op_assign
id|inode
suffix:semicolon
id|err
op_assign
id|xattr_readdir
(paren
id|fp
comma
id|reiserfs_chown_xattrs_filler
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|unlock_kernel
(paren
)paren
suffix:semicolon
r_goto
id|out_dir
suffix:semicolon
)brace
id|err
op_assign
id|notify_change
(paren
id|dir
comma
id|attrs
)paren
suffix:semicolon
id|unlock_kernel
(paren
)paren
suffix:semicolon
id|out_dir
suffix:colon
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
id|out
suffix:colon
id|attrs-&gt;ia_valid
op_assign
id|ia_valid
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Actual operations that are exported to VFS-land */
multiline_comment|/*&n; * Inode operation getxattr()&n; * Preliminary locking: we down dentry-&gt;d_inode-&gt;i_sem&n; */
id|ssize_t
DECL|function|reiserfs_getxattr
id|reiserfs_getxattr
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_struct
id|reiserfs_xattr_handler
op_star
id|xah
op_assign
id|find_xattr_handler_prefix
(paren
id|name
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xah
op_logical_or
op_logical_neg
id|reiserfs_xattrs
c_func
(paren
id|dentry-&gt;d_sb
)paren
op_logical_or
id|get_inode_sd_version
(paren
id|dentry-&gt;d_inode
)paren
op_eq
id|STAT_DATA_V1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|reiserfs_read_lock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|reiserfs_read_lock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
id|err
op_assign
id|xah-&gt;get
(paren
id|dentry-&gt;d_inode
comma
id|name
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
id|reiserfs_read_unlock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
id|reiserfs_read_unlock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Inode operation setxattr()&n; *&n; * dentry-&gt;d_inode-&gt;i_sem down&n; */
r_int
DECL|function|reiserfs_setxattr
id|reiserfs_setxattr
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_struct
id|reiserfs_xattr_handler
op_star
id|xah
op_assign
id|find_xattr_handler_prefix
(paren
id|name
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|lock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xah
op_logical_or
op_logical_neg
id|reiserfs_xattrs
c_func
(paren
id|dentry-&gt;d_sb
)paren
op_logical_or
id|get_inode_sd_version
(paren
id|dentry-&gt;d_inode
)paren
op_eq
id|STAT_DATA_V1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
(paren
id|dentry-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_IMMUTABLE
(paren
id|dentry-&gt;d_inode
)paren
op_logical_or
id|IS_APPEND
(paren
id|dentry-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|reiserfs_write_lock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|lock
op_assign
op_logical_neg
id|has_xattr_dir
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
)paren
id|reiserfs_write_lock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
r_else
id|reiserfs_read_lock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
id|err
op_assign
id|xah-&gt;set
(paren
id|dentry-&gt;d_inode
comma
id|name
comma
id|value
comma
id|size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
)paren
id|reiserfs_write_unlock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
r_else
id|reiserfs_read_unlock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
id|reiserfs_write_unlock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Inode operation removexattr()&n; *&n; * dentry-&gt;d_inode-&gt;i_sem down&n; */
r_int
DECL|function|reiserfs_removexattr
id|reiserfs_removexattr
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|reiserfs_xattr_handler
op_star
id|xah
op_assign
id|find_xattr_handler_prefix
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xah
op_logical_or
op_logical_neg
id|reiserfs_xattrs
c_func
(paren
id|dentry-&gt;d_sb
)paren
op_logical_or
id|get_inode_sd_version
(paren
id|dentry-&gt;d_inode
)paren
op_eq
id|STAT_DATA_V1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
(paren
id|dentry-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_IMMUTABLE
(paren
id|dentry-&gt;d_inode
)paren
op_logical_or
id|IS_APPEND
(paren
id|dentry-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|reiserfs_write_lock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|reiserfs_read_lock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
multiline_comment|/* Deletion pre-operation */
r_if
c_cond
(paren
id|xah-&gt;del
)paren
(brace
id|err
op_assign
id|xah-&gt;del
(paren
id|dentry-&gt;d_inode
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|reiserfs_xattr_del
(paren
id|dentry-&gt;d_inode
comma
id|name
)paren
suffix:semicolon
id|dentry-&gt;d_inode-&gt;i_ctime
op_assign
id|CURRENT_TIME_SEC
suffix:semicolon
id|mark_inode_dirty
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|out
suffix:colon
id|reiserfs_read_unlock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
id|reiserfs_write_unlock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* This is what filldir will use:&n; * r_pos will always contain the amount of space required for the entire&n; * list. If r_pos becomes larger than r_size, we need more space and we&n; * return an error indicating this. If r_pos is less than r_size, then we&squot;ve&n; * filled the buffer successfully and we return success */
DECL|struct|reiserfs_listxattr_buf
r_struct
id|reiserfs_listxattr_buf
(brace
DECL|member|r_pos
r_int
id|r_pos
suffix:semicolon
DECL|member|r_size
r_int
id|r_size
suffix:semicolon
DECL|member|r_buf
r_char
op_star
id|r_buf
suffix:semicolon
DECL|member|r_inode
r_struct
id|inode
op_star
id|r_inode
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
DECL|function|reiserfs_listxattr_filler
id|reiserfs_listxattr_filler
(paren
r_void
op_star
id|buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|loff_t
id|offset
comma
id|ino_t
id|ino
comma
r_int
r_int
id|d_type
)paren
(brace
r_struct
id|reiserfs_listxattr_buf
op_star
id|b
op_assign
(paren
r_struct
id|reiserfs_listxattr_buf
op_star
)paren
id|buf
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
op_logical_or
(paren
id|namelen
op_ne
l_int|1
op_logical_and
(paren
id|name
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
op_logical_or
id|namelen
op_ne
l_int|2
)paren
)paren
)paren
(brace
r_struct
id|reiserfs_xattr_handler
op_star
id|xah
op_assign
id|find_xattr_handler_prefix
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xah
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Unsupported xattr name, skip it */
multiline_comment|/* We call -&gt;list() twice because the operation isn&squot;t required to just&n;         * return the name back - we want to make sure we have enough space */
id|len
op_add_assign
id|xah-&gt;list
(paren
id|b-&gt;r_inode
comma
id|name
comma
id|namelen
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;r_pos
op_plus
id|len
op_plus
l_int|1
op_le
id|b-&gt;r_size
)paren
(brace
r_char
op_star
id|p
op_assign
id|b-&gt;r_buf
op_plus
id|b-&gt;r_pos
suffix:semicolon
id|p
op_add_assign
id|xah-&gt;list
(paren
id|b-&gt;r_inode
comma
id|name
comma
id|namelen
comma
id|p
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|b-&gt;r_pos
op_add_assign
id|len
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Inode operation listxattr()&n; *&n; * Preliminary locking: we down dentry-&gt;d_inode-&gt;i_sem&n; */
id|ssize_t
DECL|function|reiserfs_listxattr
id|reiserfs_listxattr
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|size
)paren
(brace
r_struct
id|file
op_star
id|fp
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_listxattr_buf
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_xattrs
c_func
(paren
id|dentry-&gt;d_sb
)paren
op_logical_or
id|get_inode_sd_version
(paren
id|dentry-&gt;d_inode
)paren
op_eq
id|STAT_DATA_V1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|reiserfs_read_lock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|reiserfs_read_lock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
id|dir
op_assign
id|open_xa_dir
(paren
id|dentry-&gt;d_inode
comma
id|FL_READONLY
)paren
suffix:semicolon
id|reiserfs_read_unlock_xattrs
(paren
id|dentry-&gt;d_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|dir
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENODATA
)paren
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not an error if there aren&squot;t any xattrs */
r_goto
id|out
suffix:semicolon
)brace
id|fp
op_assign
id|dentry_open
(paren
id|dir
comma
l_int|NULL
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|fp
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
(paren
id|fp
)paren
suffix:semicolon
multiline_comment|/* dentry_open dputs the dentry if it fails */
r_goto
id|out
suffix:semicolon
)brace
id|buf.r_buf
op_assign
id|buffer
suffix:semicolon
id|buf.r_size
op_assign
id|buffer
ques
c_cond
id|size
suffix:colon
l_int|0
suffix:semicolon
id|buf.r_pos
op_assign
l_int|0
suffix:semicolon
id|buf.r_inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_has_xattr_dir
suffix:semicolon
id|err
op_assign
id|xattr_readdir
(paren
id|fp
comma
id|reiserfs_listxattr_filler
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_dir
suffix:semicolon
r_if
c_cond
(paren
id|buf.r_pos
OG
id|buf.r_size
op_logical_and
id|buffer
op_ne
l_int|NULL
)paren
id|err
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_else
id|err
op_assign
id|buf.r_pos
suffix:semicolon
id|out_dir
suffix:colon
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
id|out
suffix:colon
id|reiserfs_read_unlock_xattr_i
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* This is the implementation for the xattr plugin infrastructure */
DECL|variable|xattr_handlers
r_static
r_struct
id|list_head
id|xattr_handlers
op_assign
id|LIST_HEAD_INIT
(paren
id|xattr_handlers
)paren
suffix:semicolon
r_static
id|DEFINE_RWLOCK
c_func
(paren
id|handler_lock
)paren
suffix:semicolon
r_static
r_struct
id|reiserfs_xattr_handler
op_star
DECL|function|find_xattr_handler_prefix
id|find_xattr_handler_prefix
(paren
r_const
r_char
op_star
id|prefix
)paren
(brace
r_struct
id|reiserfs_xattr_handler
op_star
id|xah
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|read_lock
(paren
op_amp
id|handler_lock
)paren
suffix:semicolon
id|list_for_each
(paren
id|p
comma
op_amp
id|xattr_handlers
)paren
(brace
id|xah
op_assign
id|list_entry
(paren
id|p
comma
r_struct
id|reiserfs_xattr_handler
comma
id|handlers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|xah-&gt;prefix
comma
id|prefix
comma
id|strlen
(paren
id|xah-&gt;prefix
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|xah
op_assign
l_int|NULL
suffix:semicolon
)brace
id|read_unlock
(paren
op_amp
id|handler_lock
)paren
suffix:semicolon
r_return
id|xah
suffix:semicolon
)brace
r_static
r_void
DECL|function|__unregister_handlers
id|__unregister_handlers
(paren
r_void
)paren
(brace
r_struct
id|reiserfs_xattr_handler
op_star
id|xah
suffix:semicolon
r_struct
id|list_head
op_star
id|p
comma
op_star
id|tmp
suffix:semicolon
id|list_for_each_safe
(paren
id|p
comma
id|tmp
comma
op_amp
id|xattr_handlers
)paren
(brace
id|xah
op_assign
id|list_entry
(paren
id|p
comma
r_struct
id|reiserfs_xattr_handler
comma
id|handlers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xah
op_member_access_from_pointer
m_exit
)paren
id|xah
op_member_access_from_pointer
m_exit
(paren
)paren
suffix:semicolon
id|list_del_init
(paren
id|p
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
(paren
op_amp
id|xattr_handlers
)paren
suffix:semicolon
)brace
r_int
id|__init
DECL|function|reiserfs_xattr_register_handlers
id|reiserfs_xattr_register_handlers
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_xattr_handler
op_star
id|xah
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|write_lock
(paren
op_amp
id|handler_lock
)paren
suffix:semicolon
multiline_comment|/* If we&squot;re already initialized, nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
(paren
op_amp
id|xattr_handlers
)paren
)paren
(brace
id|write_unlock
(paren
op_amp
id|handler_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Add the handlers */
id|list_add_tail
(paren
op_amp
id|user_handler.handlers
comma
op_amp
id|xattr_handlers
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|trusted_handler.handlers
comma
op_amp
id|xattr_handlers
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_FS_SECURITY
id|list_add_tail
(paren
op_amp
id|security_handler.handlers
comma
op_amp
id|xattr_handlers
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_REISERFS_FS_POSIX_ACL
id|list_add_tail
(paren
op_amp
id|posix_acl_access_handler.handlers
comma
op_amp
id|xattr_handlers
)paren
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|posix_acl_default_handler.handlers
comma
op_amp
id|xattr_handlers
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Run initializers, if available */
id|list_for_each
(paren
id|p
comma
op_amp
id|xattr_handlers
)paren
(brace
id|xah
op_assign
id|list_entry
(paren
id|p
comma
r_struct
id|reiserfs_xattr_handler
comma
id|handlers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xah-&gt;init
)paren
(brace
id|err
op_assign
id|xah-&gt;init
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|list_del_init
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Clean up other handlers, if any failed */
r_if
c_cond
(paren
id|err
)paren
id|__unregister_handlers
(paren
)paren
suffix:semicolon
id|write_unlock
(paren
op_amp
id|handler_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_void
DECL|function|reiserfs_xattr_unregister_handlers
id|reiserfs_xattr_unregister_handlers
(paren
r_void
)paren
(brace
id|write_lock
(paren
op_amp
id|handler_lock
)paren
suffix:semicolon
id|__unregister_handlers
(paren
)paren
suffix:semicolon
id|write_unlock
(paren
op_amp
id|handler_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* This will catch lookups from the fs root to .reiserfs_priv */
r_static
r_int
DECL|function|xattr_lookup_poison
id|xattr_lookup_poison
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|qstr
op_star
id|q1
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|priv_root
op_assign
id|REISERFS_SB
c_func
(paren
id|dentry-&gt;d_sb
)paren
op_member_access_from_pointer
id|priv_root
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;len
op_eq
id|priv_root-&gt;d_name.len
op_logical_and
id|name-&gt;hash
op_eq
id|priv_root-&gt;d_name.hash
op_logical_and
op_logical_neg
id|memcmp
(paren
id|name-&gt;name
comma
id|priv_root-&gt;d_name.name
comma
id|name-&gt;len
)paren
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|q1-&gt;len
op_eq
id|name-&gt;len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|q1-&gt;name
comma
id|name-&gt;name
comma
id|name-&gt;len
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|xattr_lookup_poison_ops
r_static
r_struct
id|dentry_operations
id|xattr_lookup_poison_ops
op_assign
(brace
dot
id|d_compare
op_assign
id|xattr_lookup_poison
comma
)brace
suffix:semicolon
multiline_comment|/* We need to take a copy of the mount flags since things like&n; * MS_RDONLY don&squot;t get set until *after* we&squot;re called.&n; * mount_flags != mount_options */
r_int
DECL|function|reiserfs_xattr_init
id|reiserfs_xattr_init
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|mount_flags
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We need generation numbers to ensure that the oid mapping is correct&n;   * v3.5 filesystems don&squot;t have them. */
r_if
c_cond
(paren
op_logical_neg
id|old_format_only
(paren
id|s
)paren
)paren
(brace
id|set_bit
(paren
id|REISERFS_XATTRS
comma
op_amp
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_xattrs_optional
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* Old format filesystem, but optional xattrs have been enabled&n;     * at mount time. Error out. */
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;xattrs/ACLs not supported on pre v3.6 &quot;
l_string|&quot;format filesystem. Failing mount.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Old format filesystem, but no optional xattrs have been enabled. This&n;     * means we silently disable xattrs on the filesystem. */
id|clear_bit
(paren
id|REISERFS_XATTRS
comma
op_amp
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If we don&squot;t have the privroot located yet - go find it */
r_if
c_cond
(paren
id|reiserfs_xattrs
(paren
id|s
)paren
op_logical_and
op_logical_neg
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|priv_root
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_one_len
(paren
id|PRIVROOT_NAME
comma
id|s-&gt;s_root
comma
id|strlen
(paren
id|PRIVROOT_NAME
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mount_flags
op_amp
id|MS_RDONLY
)paren
op_logical_and
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
id|down
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|inode-&gt;i_op-&gt;mkdir
(paren
id|inode
comma
id|dentry
comma
l_int|0700
)paren
suffix:semicolon
id|up
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|dput
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dentry
op_logical_and
id|dentry-&gt;d_inode
)paren
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;Created %s on %s - reserved for &quot;
l_string|&quot;xattr storage.&quot;
comma
id|PRIVROOT_NAME
comma
id|reiserfs_bdevname
(paren
id|inode-&gt;i_sb
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
id|dput
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
id|err
op_assign
id|PTR_ERR
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|dentry
)paren
(brace
id|s-&gt;s_root-&gt;d_op
op_assign
op_amp
id|xattr_lookup_poison_ops
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_priv_object
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|priv_root
op_assign
id|dentry
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|mount_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
multiline_comment|/* xattrs are unavailable */
multiline_comment|/* If we&squot;re read-only it just means that the dir hasn&squot;t been&n;           * created. Not an error -- just no xattrs on the fs. We&squot;ll&n;           * check again if we go read-write */
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;xattrs/ACLs enabled and couldn&squot;t &quot;
l_string|&quot;find/create .reiserfs_priv. Failing mount.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
id|error
suffix:colon
multiline_comment|/* This is only nonzero if there was an error initializing the xattr&n;    * directory or if there is a condition where we don&squot;t support them. */
r_if
c_cond
(paren
id|err
)paren
(brace
id|clear_bit
(paren
id|REISERFS_XATTRS
comma
op_amp
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
)paren
)paren
suffix:semicolon
id|clear_bit
(paren
id|REISERFS_XATTRS_USER
comma
op_amp
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
)paren
)paren
suffix:semicolon
id|clear_bit
(paren
id|REISERFS_POSIXACL
comma
op_amp
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
id|s-&gt;s_flags
op_assign
id|s-&gt;s_flags
op_amp
op_complement
id|MS_POSIXACL
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_posixacl
(paren
id|s
)paren
)paren
id|s-&gt;s_flags
op_or_assign
id|MS_POSIXACL
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_static
r_int
DECL|function|__reiserfs_permission
id|__reiserfs_permission
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
comma
r_struct
id|nameidata
op_star
id|nd
comma
r_int
id|need_lock
)paren
(brace
id|umode_t
id|mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MAY_WRITE
)paren
(brace
multiline_comment|/*&n;&t;&t; * Nobody gets write access to a read-only fs.&n;&t;&t; */
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Nobody gets write access to an immutable file.&n;&t;&t; */
r_if
c_cond
(paren
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* We don&squot;t do permission checks on the internal objects.&n;&t;* Permissions are determined by the &quot;owning&quot; object. */
r_if
c_cond
(paren
id|is_reiserfs_priv_object
(paren
id|inode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_eq
id|inode-&gt;i_uid
)paren
(brace
id|mode
op_rshift_assign
l_int|6
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_FS_POSIX_ACL
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_posixacl
c_func
(paren
id|inode-&gt;i_sb
)paren
op_logical_and
id|get_inode_sd_version
(paren
id|inode
)paren
op_ne
id|STAT_DATA_V1
)paren
(brace
r_struct
id|posix_acl
op_star
id|acl
suffix:semicolon
multiline_comment|/* ACL can&squot;t contain additional permissions if&n;&t;&t;   the ACL_MASK entry is 0 */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mode
op_amp
id|S_IRWXG
)paren
)paren
r_goto
id|check_groups
suffix:semicolon
r_if
c_cond
(paren
id|need_lock
)paren
(brace
id|reiserfs_read_lock_xattr_i
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_read_lock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
id|acl
op_assign
id|reiserfs_get_acl
(paren
id|inode
comma
id|ACL_TYPE_ACCESS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_lock
)paren
(brace
id|reiserfs_read_unlock_xattrs
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|reiserfs_read_unlock_xattr_i
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ERR
(paren
id|acl
)paren
)paren
(brace
r_if
c_cond
(paren
id|PTR_ERR
(paren
id|acl
)paren
op_eq
op_minus
id|ENODATA
)paren
r_goto
id|check_groups
suffix:semicolon
r_return
id|PTR_ERR
(paren
id|acl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|acl
)paren
(brace
r_int
id|err
op_assign
id|posix_acl_permission
(paren
id|inode
comma
id|acl
comma
id|mask
)paren
suffix:semicolon
id|posix_acl_release
(paren
id|acl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EACCES
)paren
(brace
r_goto
id|check_capabilities
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_else
(brace
r_goto
id|check_groups
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
id|check_groups
suffix:colon
r_if
c_cond
(paren
id|in_group_p
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
id|mode
op_rshift_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the DACs are ok we don&squot;t need any capability check.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|mode
op_amp
id|mask
op_amp
(paren
id|MAY_READ
op_or
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_eq
id|mask
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|check_capabilities
suffix:colon
multiline_comment|/*&n;&t; * Read/write DACs are always overridable.&n;&t; * Executable DACs are overridable if at least one exec bit is set.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|MAY_EXEC
)paren
op_logical_or
(paren
id|inode-&gt;i_mode
op_amp
id|S_IXUGO
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_DAC_OVERRIDE
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Searching includes executable on directories, else just read.&n;&t; */
r_if
c_cond
(paren
id|mask
op_eq
id|MAY_READ
op_logical_or
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
(paren
id|mask
op_amp
id|MAY_WRITE
)paren
)paren
)paren
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_DAC_READ_SEARCH
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_int
DECL|function|reiserfs_permission
id|reiserfs_permission
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_return
id|__reiserfs_permission
(paren
id|inode
comma
id|mask
comma
id|nd
comma
l_int|1
)paren
suffix:semicolon
)brace
r_int
DECL|function|reiserfs_permission_locked
id|reiserfs_permission_locked
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_return
id|__reiserfs_permission
(paren
id|inode
comma
id|mask
comma
id|nd
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
