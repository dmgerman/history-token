multiline_comment|/*&n; *  Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
multiline_comment|/*&n; *  Written by Anatoly P. Pinchuk pap@namesys.botik.ru&n; *  Programm System Institute&n; *  Pereslavl-Zalessky Russia&n; */
multiline_comment|/*&n; *  This file contains functions dealing with S+tree&n; *&n; * B_IS_IN_TREE&n; * copy_short_key&n; * copy_item_head&n; * comp_short_keys&n; * comp_keys&n; * comp_cpu_keys&n; * comp_short_le_keys&n; * comp_short_cpu_keys&n; * cpu_key2cpu_key&n; * le_key2cpu_key&n; * comp_le_keys&n; * bin_search&n; * get_lkey&n; * get_rkey&n; * key_in_buffer&n; * decrement_bcount&n; * decrement_counters_in_path&n; * reiserfs_check_path&n; * pathrelse_and_restore&n; * pathrelse&n; * search_by_key_reada&n; * search_by_key&n; * search_for_position_by_key&n; * comp_items&n; * prepare_for_direct_item&n; * prepare_for_direntry_item&n; * prepare_for_delete_or_cut&n; * calc_deleted_bytes_number&n; * init_tb_struct&n; * padd_item&n; * reiserfs_delete_item&n; * reiserfs_delete_solid_item&n; * reiserfs_delete_object&n; * maybe_indirect_to_direct&n; * indirect_to_direct_roll_back&n; * reiserfs_cut_from_item&n; * truncate_directory&n; * reiserfs_do_truncate&n; * reiserfs_paste_into_item&n; * reiserfs_insert_item&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
multiline_comment|/* Does the buffer contain a disk block which is in the tree. */
DECL|function|B_IS_IN_TREE
r_inline
r_int
id|B_IS_IN_TREE
(paren
r_const
r_struct
id|buffer_head
op_star
id|p_s_bh
)paren
(brace
id|RFALSE
c_func
(paren
id|B_LEVEL
(paren
id|p_s_bh
)paren
OG
id|MAX_HEIGHT
comma
l_string|&quot;PAP-1010: block (%b) has too big level (%z)&quot;
comma
id|p_s_bh
comma
id|p_s_bh
)paren
suffix:semicolon
r_return
(paren
id|B_LEVEL
(paren
id|p_s_bh
)paren
op_ne
id|FREE_LEVEL
)paren
suffix:semicolon
)brace
DECL|function|copy_short_key
r_inline
r_void
id|copy_short_key
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
)paren
(brace
id|memcpy
(paren
id|to
comma
id|from
comma
id|SHORT_KEY_SIZE
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// to gets item head in le form
singleline_comment|//
DECL|function|copy_item_head
r_inline
r_void
id|copy_item_head
c_func
(paren
r_struct
id|item_head
op_star
id|p_v_to
comma
r_const
r_struct
id|item_head
op_star
id|p_v_from
)paren
(brace
id|memcpy
(paren
id|p_v_to
comma
id|p_v_from
comma
id|IH_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* k1 is pointer to on-disk structure which is stored in little-endian&n;   form. k2 is pointer to cpu variable. For key of items of the same&n;   object this returns 0.&n;   Returns: -1 if key1 &lt; key2 &n;   0 if key1 == key2&n;   1 if key1 &gt; key2 */
DECL|function|comp_short_keys
r_inline
r_int
id|comp_short_keys
(paren
r_const
r_struct
id|key
op_star
id|le_key
comma
r_const
r_struct
id|cpu_key
op_star
id|cpu_key
)paren
(brace
id|__u32
op_star
id|p_s_le_u32
comma
op_star
id|p_s_cpu_u32
suffix:semicolon
r_int
id|n_key_length
op_assign
id|REISERFS_SHORT_KEY_LEN
suffix:semicolon
id|p_s_le_u32
op_assign
(paren
id|__u32
op_star
)paren
id|le_key
suffix:semicolon
id|p_s_cpu_u32
op_assign
(paren
id|__u32
op_star
)paren
op_amp
id|cpu_key-&gt;on_disk_key
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n_key_length
op_decrement
suffix:semicolon
op_increment
id|p_s_le_u32
comma
op_increment
id|p_s_cpu_u32
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
(paren
op_star
id|p_s_le_u32
)paren
OL
op_star
id|p_s_cpu_u32
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
(paren
op_star
id|p_s_le_u32
)paren
OG
op_star
id|p_s_cpu_u32
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* k1 is pointer to on-disk structure which is stored in little-endian&n;   form. k2 is pointer to cpu variable.&n;   Compare keys using all 4 key fields.&n;   Returns: -1 if key1 &lt; key2 0&n;   if key1 = key2 1 if key1 &gt; key2 */
DECL|function|comp_keys
r_inline
r_int
id|comp_keys
(paren
r_const
r_struct
id|key
op_star
id|le_key
comma
r_const
r_struct
id|cpu_key
op_star
id|cpu_key
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|comp_short_keys
(paren
id|le_key
comma
id|cpu_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_offset
(paren
id|le_key_version
c_func
(paren
id|le_key
)paren
comma
id|le_key
)paren
OL
id|cpu_key_k_offset
(paren
id|cpu_key
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_offset
(paren
id|le_key_version
c_func
(paren
id|le_key
)paren
comma
id|le_key
)paren
OG
id|cpu_key_k_offset
(paren
id|cpu_key
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key-&gt;key_length
op_eq
l_int|3
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* this part is needed only when tail conversion is in progress */
r_if
c_cond
(paren
id|le_key_k_type
(paren
id|le_key_version
c_func
(paren
id|le_key
)paren
comma
id|le_key
)paren
OL
id|cpu_key_k_type
(paren
id|cpu_key
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_type
(paren
id|le_key_version
c_func
(paren
id|le_key
)paren
comma
id|le_key
)paren
OG
id|cpu_key_k_type
(paren
id|cpu_key
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// FIXME: not used yet
singleline_comment|//
DECL|function|comp_cpu_keys
r_inline
r_int
id|comp_cpu_keys
(paren
r_const
r_struct
id|cpu_key
op_star
id|key1
comma
r_const
r_struct
id|cpu_key
op_star
id|key2
)paren
(brace
r_if
c_cond
(paren
id|key1-&gt;on_disk_key.k_dir_id
OL
id|key2-&gt;on_disk_key.k_dir_id
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|key1-&gt;on_disk_key.k_dir_id
OG
id|key2-&gt;on_disk_key.k_dir_id
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|key1-&gt;on_disk_key.k_objectid
OL
id|key2-&gt;on_disk_key.k_objectid
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|key1-&gt;on_disk_key.k_objectid
OG
id|key2-&gt;on_disk_key.k_objectid
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_offset
(paren
id|key1
)paren
OL
id|cpu_key_k_offset
(paren
id|key2
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_offset
(paren
id|key1
)paren
OG
id|cpu_key_k_offset
(paren
id|key2
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;comp_cpu_keys: type are compared for %K and %K&bslash;n&quot;
comma
id|key1
comma
id|key2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_type
(paren
id|key1
)paren
OL
id|cpu_key_k_type
(paren
id|key2
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_type
(paren
id|key1
)paren
OG
id|cpu_key_k_type
(paren
id|key2
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|comp_short_le_keys
r_inline
r_int
id|comp_short_le_keys
(paren
r_const
r_struct
id|key
op_star
id|key1
comma
r_const
r_struct
id|key
op_star
id|key2
)paren
(brace
id|__u32
op_star
id|p_s_1_u32
comma
op_star
id|p_s_2_u32
suffix:semicolon
r_int
id|n_key_length
op_assign
id|REISERFS_SHORT_KEY_LEN
suffix:semicolon
id|p_s_1_u32
op_assign
(paren
id|__u32
op_star
)paren
id|key1
suffix:semicolon
id|p_s_2_u32
op_assign
(paren
id|__u32
op_star
)paren
id|key2
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n_key_length
op_decrement
suffix:semicolon
op_increment
id|p_s_1_u32
comma
op_increment
id|p_s_2_u32
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
(paren
op_star
id|p_s_1_u32
)paren
OL
id|le32_to_cpu
(paren
op_star
id|p_s_2_u32
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
(paren
op_star
id|p_s_1_u32
)paren
OG
id|le32_to_cpu
(paren
op_star
id|p_s_2_u32
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|comp_short_cpu_keys
r_inline
r_int
id|comp_short_cpu_keys
(paren
r_const
r_struct
id|cpu_key
op_star
id|key1
comma
r_const
r_struct
id|cpu_key
op_star
id|key2
)paren
(brace
id|__u32
op_star
id|p_s_1_u32
comma
op_star
id|p_s_2_u32
suffix:semicolon
r_int
id|n_key_length
op_assign
id|REISERFS_SHORT_KEY_LEN
suffix:semicolon
id|p_s_1_u32
op_assign
(paren
id|__u32
op_star
)paren
id|key1
suffix:semicolon
id|p_s_2_u32
op_assign
(paren
id|__u32
op_star
)paren
id|key2
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n_key_length
op_decrement
suffix:semicolon
op_increment
id|p_s_1_u32
comma
op_increment
id|p_s_2_u32
)paren
(brace
r_if
c_cond
(paren
op_star
id|p_s_1_u32
OL
op_star
id|p_s_2_u32
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p_s_1_u32
OG
op_star
id|p_s_2_u32
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cpu_key2cpu_key
r_inline
r_void
id|cpu_key2cpu_key
(paren
r_struct
id|cpu_key
op_star
id|to
comma
r_const
r_struct
id|cpu_key
op_star
id|from
)paren
(brace
id|memcpy
(paren
id|to
comma
id|from
comma
r_sizeof
(paren
r_struct
id|cpu_key
)paren
)paren
suffix:semicolon
)brace
DECL|function|le_key2cpu_key
r_inline
r_void
id|le_key2cpu_key
(paren
r_struct
id|cpu_key
op_star
id|to
comma
r_const
r_struct
id|key
op_star
id|from
)paren
(brace
id|to-&gt;on_disk_key.k_dir_id
op_assign
id|le32_to_cpu
(paren
id|from-&gt;k_dir_id
)paren
suffix:semicolon
id|to-&gt;on_disk_key.k_objectid
op_assign
id|le32_to_cpu
(paren
id|from-&gt;k_objectid
)paren
suffix:semicolon
singleline_comment|// find out version of the key
id|to-&gt;version
op_assign
id|le_key_version
(paren
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to-&gt;version
op_eq
id|KEY_FORMAT_3_5
)paren
(brace
id|to-&gt;on_disk_key.u.k_offset_v1.k_offset
op_assign
id|le32_to_cpu
(paren
id|from-&gt;u.k_offset_v1.k_offset
)paren
suffix:semicolon
id|to-&gt;on_disk_key.u.k_offset_v1.k_uniqueness
op_assign
id|le32_to_cpu
(paren
id|from-&gt;u.k_offset_v1.k_uniqueness
)paren
suffix:semicolon
)brace
r_else
(brace
id|to-&gt;on_disk_key.u.k_offset_v2.k_offset
op_assign
id|offset_v2_k_offset
c_func
(paren
op_amp
id|from-&gt;u.k_offset_v2
)paren
suffix:semicolon
id|to-&gt;on_disk_key.u.k_offset_v2.k_type
op_assign
id|offset_v2_k_type
c_func
(paren
op_amp
id|from-&gt;u.k_offset_v2
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// this does not say which one is bigger, it only returns 1 if keys
singleline_comment|// are not equal, 0 otherwise
DECL|function|comp_le_keys
r_inline
r_int
id|comp_le_keys
(paren
r_const
r_struct
id|key
op_star
id|k1
comma
r_const
r_struct
id|key
op_star
id|k2
)paren
(brace
r_return
id|memcmp
(paren
id|k1
comma
id|k2
comma
r_sizeof
(paren
r_struct
id|key
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *  Binary search toolkit function                                        *&n; *  Search for an item in the array by the item key                       *&n; *  Returns:    1 if found,  0 if not found;                              *&n; *        *p_n_pos = number of the searched element if found, else the    *&n; *        number of the first element that is larger than p_v_key.        *&n; **************************************************************************/
multiline_comment|/* For those not familiar with binary search: n_lbound is the leftmost item that it&n; could be, n_rbound the rightmost item that it could be.  We examine the item&n; halfway between n_lbound and n_rbound, and that tells us either that we can increase&n; n_lbound, or decrease n_rbound, or that we have found it, or if n_lbound &lt;= n_rbound that&n; there are no possible items, and we have not found it. With each examination we&n; cut the number of possible items it could be by one more than half rounded down,&n; or we find it. */
DECL|function|bin_search
r_inline
r_int
id|bin_search
(paren
r_const
r_void
op_star
id|p_v_key
comma
multiline_comment|/* Key to search for.                   */
r_const
r_void
op_star
id|p_v_base
comma
multiline_comment|/* First item in the array.             */
r_int
id|p_n_num
comma
multiline_comment|/* Number of items in the array.        */
r_int
id|p_n_width
comma
multiline_comment|/* Item size in the array.&n;&t;&t;&t;&t;       searched. Lest the reader be&n;&t;&t;&t;&t;       confused, note that this is crafted&n;&t;&t;&t;&t;       as a general function, and when it&n;&t;&t;&t;&t;       is applied specifically to the array&n;&t;&t;&t;&t;       of item headers in a node, p_n_width&n;&t;&t;&t;&t;       is actually the item header size not&n;&t;&t;&t;&t;       the item size.                      */
r_int
op_star
id|p_n_pos
multiline_comment|/* Number of the searched for element. */
)paren
(brace
r_int
id|n_rbound
comma
id|n_lbound
comma
id|n_j
suffix:semicolon
r_for
c_loop
(paren
id|n_j
op_assign
(paren
(paren
id|n_rbound
op_assign
id|p_n_num
op_minus
l_int|1
)paren
op_plus
(paren
id|n_lbound
op_assign
l_int|0
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|n_lbound
op_le
id|n_rbound
suffix:semicolon
id|n_j
op_assign
(paren
id|n_rbound
op_plus
id|n_lbound
)paren
op_div
l_int|2
)paren
r_switch
c_cond
(paren
id|COMP_KEYS
c_func
(paren
(paren
r_struct
id|key
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|p_v_base
op_plus
id|n_j
op_star
id|p_n_width
)paren
comma
(paren
r_struct
id|cpu_key
op_star
)paren
id|p_v_key
)paren
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
id|n_lbound
op_assign
id|n_j
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|1
suffix:colon
id|n_rbound
op_assign
id|n_j
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|0
suffix:colon
op_star
id|p_n_pos
op_assign
id|n_j
suffix:semicolon
r_return
id|ITEM_FOUND
suffix:semicolon
multiline_comment|/* Key found in the array.  */
)brace
multiline_comment|/* bin_search did not find given key, it returns position of key,&n;        that is minimal and greater than the given one. */
op_star
id|p_n_pos
op_assign
id|n_lbound
suffix:semicolon
r_return
id|ITEM_NOT_FOUND
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_extern
r_struct
id|tree_balance
op_star
id|cur_tb
suffix:semicolon
macro_line|#endif
multiline_comment|/* Minimal possible key. It is never in the tree. */
DECL|variable|MIN_KEY
r_const
r_struct
id|key
id|MIN_KEY
op_assign
(brace
l_int|0
comma
l_int|0
comma
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
)brace
suffix:semicolon
multiline_comment|/* Maximal possible key. It is never in the tree. */
DECL|variable|MAX_KEY
r_const
r_struct
id|key
id|MAX_KEY
op_assign
(brace
l_int|0xffffffff
comma
l_int|0xffffffff
comma
(brace
(brace
l_int|0xffffffff
comma
l_int|0xffffffff
)brace
comma
)brace
)brace
suffix:semicolon
multiline_comment|/* Get delimiting key of the buffer by looking for it in the buffers in the path, starting from the bottom&n;   of the path, and going upwards.  We must check the path&squot;s validity at each step.  If the key is not in&n;   the path, there is no delimiting key in the tree (buffer is first or last buffer in tree), and in this&n;   case we return a special key, either MIN_KEY or MAX_KEY. */
DECL|function|get_lkey
r_inline
r_const
r_struct
id|key
op_star
id|get_lkey
(paren
r_const
r_struct
id|path
op_star
id|p_s_chk_path
comma
r_const
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|n_position
comma
id|n_path_offset
op_assign
id|p_s_chk_path-&gt;path_length
suffix:semicolon
r_struct
id|buffer_head
op_star
id|p_s_parent
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_path_offset
OL
id|FIRST_PATH_ELEMENT_OFFSET
comma
l_string|&quot;PAP-5010: invalid offset in the path&quot;
)paren
suffix:semicolon
multiline_comment|/* While not higher in path than first element. */
r_while
c_loop
(paren
id|n_path_offset
op_decrement
OG
id|FIRST_PATH_ELEMENT_OFFSET
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
)paren
)paren
comma
l_string|&quot;PAP-5020: parent is not uptodate&quot;
)paren
suffix:semicolon
multiline_comment|/* Parent at the path is not in the tree now. */
r_if
c_cond
(paren
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|p_s_parent
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
)paren
)paren
)paren
r_return
op_amp
id|MAX_KEY
suffix:semicolon
multiline_comment|/* Check whether position in the parent is correct. */
r_if
c_cond
(paren
(paren
id|n_position
op_assign
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
)paren
)paren
OG
id|B_NR_ITEMS
c_func
(paren
id|p_s_parent
)paren
)paren
r_return
op_amp
id|MAX_KEY
suffix:semicolon
multiline_comment|/* Check whether parent at the path really points to the child. */
r_if
c_cond
(paren
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_parent
comma
id|n_position
)paren
op_ne
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|b_blocknr
)paren
r_return
op_amp
id|MAX_KEY
suffix:semicolon
multiline_comment|/* Return delimiting key if position in the parent is not equal to zero. */
r_if
c_cond
(paren
id|n_position
)paren
r_return
id|B_N_PDELIM_KEY
c_func
(paren
id|p_s_parent
comma
id|n_position
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Return MIN_KEY if we are in the root of the buffer tree. */
r_if
c_cond
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|FIRST_PATH_ELEMENT_OFFSET
)paren
op_member_access_from_pointer
id|b_blocknr
op_eq
id|SB_ROOT_BLOCK
(paren
id|p_s_sb
)paren
)paren
r_return
op_amp
id|MIN_KEY
suffix:semicolon
r_return
op_amp
id|MAX_KEY
suffix:semicolon
)brace
multiline_comment|/* Get delimiting key of the buffer at the path and its right neighbor. */
DECL|function|get_rkey
r_inline
r_const
r_struct
id|key
op_star
id|get_rkey
(paren
r_const
r_struct
id|path
op_star
id|p_s_chk_path
comma
r_const
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|n_position
comma
id|n_path_offset
op_assign
id|p_s_chk_path-&gt;path_length
suffix:semicolon
r_struct
id|buffer_head
op_star
id|p_s_parent
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_path_offset
OL
id|FIRST_PATH_ELEMENT_OFFSET
comma
l_string|&quot;PAP-5030: invalid offset in the path&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n_path_offset
op_decrement
OG
id|FIRST_PATH_ELEMENT_OFFSET
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
)paren
)paren
comma
l_string|&quot;PAP-5040: parent is not uptodate&quot;
)paren
suffix:semicolon
multiline_comment|/* Parent at the path is not in the tree now. */
r_if
c_cond
(paren
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|p_s_parent
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
)paren
)paren
)paren
r_return
op_amp
id|MIN_KEY
suffix:semicolon
multiline_comment|/* Check whether position in the parent is correct. */
r_if
c_cond
(paren
(paren
id|n_position
op_assign
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
)paren
)paren
OG
id|B_NR_ITEMS
c_func
(paren
id|p_s_parent
)paren
)paren
r_return
op_amp
id|MIN_KEY
suffix:semicolon
multiline_comment|/* Check whether parent at the path really points to the child. */
r_if
c_cond
(paren
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_parent
comma
id|n_position
)paren
op_ne
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|n_path_offset
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|b_blocknr
)paren
r_return
op_amp
id|MIN_KEY
suffix:semicolon
multiline_comment|/* Return delimiting key if position in the parent is not the last one. */
r_if
c_cond
(paren
id|n_position
op_ne
id|B_NR_ITEMS
c_func
(paren
id|p_s_parent
)paren
)paren
r_return
id|B_N_PDELIM_KEY
c_func
(paren
id|p_s_parent
comma
id|n_position
)paren
suffix:semicolon
)brace
multiline_comment|/* Return MAX_KEY if we are in the root of the buffer tree. */
r_if
c_cond
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_chk_path
comma
id|FIRST_PATH_ELEMENT_OFFSET
)paren
op_member_access_from_pointer
id|b_blocknr
op_eq
id|SB_ROOT_BLOCK
(paren
id|p_s_sb
)paren
)paren
r_return
op_amp
id|MAX_KEY
suffix:semicolon
r_return
op_amp
id|MIN_KEY
suffix:semicolon
)brace
multiline_comment|/* Check whether a key is contained in the tree rooted from a buffer at a path. */
multiline_comment|/* This works by looking at the left and right delimiting keys for the buffer in the last path_element in&n;   the path.  These delimiting keys are stored at least one level above that buffer in the tree. If the&n;   buffer is the first or last node in the tree order then one of the delimiting keys may be absent, and in&n;   this case get_lkey and get_rkey return a special key which is MIN_KEY or MAX_KEY. */
DECL|function|key_in_buffer
r_static
r_inline
r_int
id|key_in_buffer
(paren
r_struct
id|path
op_star
id|p_s_chk_path
comma
multiline_comment|/* Path which should be checked.  */
r_const
r_struct
id|cpu_key
op_star
id|p_s_key
comma
multiline_comment|/* Key which should be checked.   */
r_struct
id|super_block
op_star
id|p_s_sb
multiline_comment|/* Super block pointer.           */
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|p_s_key
op_logical_or
id|p_s_chk_path-&gt;path_length
template_param
id|MAX_HEIGHT
comma
l_string|&quot;PAP-5050: pointer to the key(%p) is NULL or invalid path length(%d)&quot;
comma
id|p_s_key
comma
id|p_s_chk_path-&gt;path_length
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_chk_path
)paren
op_member_access_from_pointer
id|b_bdev
comma
l_string|&quot;PAP-5060: device must not be NODEV&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COMP_KEYS
c_func
(paren
id|get_lkey
c_func
(paren
id|p_s_chk_path
comma
id|p_s_sb
)paren
comma
id|p_s_key
)paren
op_eq
l_int|1
)paren
multiline_comment|/* left delimiting key is bigger, that the key we look for */
r_return
l_int|0
suffix:semicolon
singleline_comment|//  if ( COMP_KEYS(p_s_key, get_rkey(p_s_chk_path, p_s_sb)) != -1 )
r_if
c_cond
(paren
id|COMP_KEYS
c_func
(paren
id|get_rkey
c_func
(paren
id|p_s_chk_path
comma
id|p_s_sb
)paren
comma
id|p_s_key
)paren
op_ne
l_int|1
)paren
multiline_comment|/* p_s_key must be less than right delimitiing key */
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|decrement_bcount
r_inline
r_void
id|decrement_bcount
c_func
(paren
r_struct
id|buffer_head
op_star
id|p_s_bh
)paren
(brace
r_if
c_cond
(paren
id|p_s_bh
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
(paren
id|p_s_bh-&gt;b_count
)paren
)paren
)paren
(brace
id|put_bh
c_func
(paren
id|p_s_bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reiserfs_panic
c_func
(paren
l_int|NULL
comma
l_string|&quot;PAP-5070: decrement_bcount: trying to free free buffer %b&quot;
comma
id|p_s_bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Decrement b_count field of the all buffers in the path. */
DECL|function|decrement_counters_in_path
r_void
id|decrement_counters_in_path
(paren
r_struct
id|path
op_star
id|p_s_search_path
)paren
(brace
r_int
id|n_path_offset
op_assign
id|p_s_search_path-&gt;path_length
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_path_offset
template_param
id|EXTENDED_MAX_HEIGHT
op_minus
l_int|1
comma
l_string|&quot;PAP-5080: invalid path offset of %d&quot;
comma
id|n_path_offset
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n_path_offset
OG
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_search_path
comma
id|n_path_offset
op_decrement
)paren
suffix:semicolon
id|decrement_bcount
(paren
id|bh
)paren
suffix:semicolon
)brace
id|p_s_search_path-&gt;path_length
op_assign
id|ILLEGAL_PATH_ELEMENT_OFFSET
suffix:semicolon
)brace
DECL|function|reiserfs_check_path
r_int
id|reiserfs_check_path
c_func
(paren
r_struct
id|path
op_star
id|p
)paren
(brace
id|RFALSE
c_func
(paren
id|p-&gt;path_length
op_ne
id|ILLEGAL_PATH_ELEMENT_OFFSET
comma
l_string|&quot;path not properly relsed&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Release all buffers in the path. Restore dirty bits clean&n;** when preparing the buffer for the log&n;**&n;** only called from fix_nodes()&n;*/
DECL|function|pathrelse_and_restore
r_void
id|pathrelse_and_restore
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|path
op_star
id|p_s_search_path
)paren
(brace
r_int
id|n_path_offset
op_assign
id|p_s_search_path-&gt;path_length
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_path_offset
OL
id|ILLEGAL_PATH_ELEMENT_OFFSET
comma
l_string|&quot;clm-4000: invalid path offset&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n_path_offset
OG
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|s
comma
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_search_path
comma
id|n_path_offset
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_search_path
comma
id|n_path_offset
op_decrement
)paren
)paren
suffix:semicolon
)brace
id|p_s_search_path-&gt;path_length
op_assign
id|ILLEGAL_PATH_ELEMENT_OFFSET
suffix:semicolon
)brace
multiline_comment|/* Release all buffers in the path. */
DECL|function|pathrelse
r_void
id|pathrelse
(paren
r_struct
id|path
op_star
id|p_s_search_path
)paren
(brace
r_int
id|n_path_offset
op_assign
id|p_s_search_path-&gt;path_length
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_path_offset
OL
id|ILLEGAL_PATH_ELEMENT_OFFSET
comma
l_string|&quot;PAP-5090: invalid path offset&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n_path_offset
OG
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
id|brelse
c_func
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_search_path
comma
id|n_path_offset
op_decrement
)paren
)paren
suffix:semicolon
id|p_s_search_path-&gt;path_length
op_assign
id|ILLEGAL_PATH_ELEMENT_OFFSET
suffix:semicolon
)brace
DECL|function|is_leaf
r_static
r_int
id|is_leaf
(paren
r_char
op_star
id|buf
comma
r_int
id|blocksize
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_int
id|used_space
suffix:semicolon
r_int
id|prev_location
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|blkh
op_assign
(paren
r_struct
id|block_head
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|blkh_level
c_func
(paren
id|blkh
)paren
op_ne
id|DISK_LEAF_NODE_LEVEL
)paren
(brace
id|printk
(paren
l_string|&quot;is_leaf: this should be caught earlier&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nr
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
template_param
(paren
(paren
id|blocksize
op_minus
id|BLKH_SIZE
)paren
op_div
(paren
id|IH_SIZE
op_plus
id|MIN_ITEM_LEN
)paren
)paren
)paren
(brace
multiline_comment|/* item number is too big or too small */
id|reiserfs_warning
(paren
l_string|&quot;is_leaf: nr_item seems wrong: %z&bslash;n&quot;
comma
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ih
op_assign
(paren
r_struct
id|item_head
op_star
)paren
(paren
id|buf
op_plus
id|BLKH_SIZE
)paren
op_plus
id|nr
op_minus
l_int|1
suffix:semicolon
id|used_space
op_assign
id|BLKH_SIZE
op_plus
id|IH_SIZE
op_star
id|nr
op_plus
(paren
id|blocksize
op_minus
id|ih_location
(paren
id|ih
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|used_space
op_ne
id|blocksize
op_minus
id|blkh_free_space
c_func
(paren
id|blkh
)paren
)paren
(brace
multiline_comment|/* free space does not match to calculated amount of use space */
id|reiserfs_warning
(paren
l_string|&quot;is_leaf: free space seems wrong: %z&bslash;n&quot;
comma
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// FIXME: it is_leaf will hit performance too much - we may have
singleline_comment|// return 1 here
multiline_comment|/* check tables of item heads */
id|ih
op_assign
(paren
r_struct
id|item_head
op_star
)paren
(paren
id|buf
op_plus
id|BLKH_SIZE
)paren
suffix:semicolon
id|prev_location
op_assign
id|blocksize
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
comma
id|ih
op_increment
)paren
(brace
r_if
c_cond
(paren
id|le_ih_k_type
c_func
(paren
id|ih
)paren
op_eq
id|TYPE_ANY
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;is_leaf: wrong item type for item %h&bslash;n&quot;
comma
id|ih
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ih_location
(paren
id|ih
)paren
op_ge
id|blocksize
op_logical_or
id|ih_location
(paren
id|ih
)paren
OL
id|IH_SIZE
op_star
id|nr
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;is_leaf: item location seems wrong: %h&bslash;n&quot;
comma
id|ih
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ih_item_len
(paren
id|ih
)paren
template_param
id|MAX_ITEM_LEN
(paren
id|blocksize
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;is_leaf: item length seems wrong: %h&bslash;n&quot;
comma
id|ih
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev_location
op_minus
id|ih_location
(paren
id|ih
)paren
op_ne
id|ih_item_len
(paren
id|ih
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;is_leaf: item location seems wrong (second one): %h&bslash;n&quot;
comma
id|ih
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|prev_location
op_assign
id|ih_location
(paren
id|ih
)paren
suffix:semicolon
)brace
singleline_comment|// one may imagine much more checks
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* returns 1 if buf looks like an internal node, 0 otherwise */
DECL|function|is_internal
r_static
r_int
id|is_internal
(paren
r_char
op_star
id|buf
comma
r_int
id|blocksize
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_int
id|used_space
suffix:semicolon
id|blkh
op_assign
(paren
r_struct
id|block_head
op_star
)paren
id|buf
suffix:semicolon
id|nr
op_assign
id|blkh_level
c_func
(paren
id|blkh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_le
id|DISK_LEAF_NODE_LEVEL
op_logical_or
id|nr
OG
id|MAX_HEIGHT
)paren
(brace
multiline_comment|/* this level is not possible for internal nodes */
id|printk
(paren
l_string|&quot;is_internal: this should be caught earlier&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nr
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
(paren
id|blocksize
op_minus
id|BLKH_SIZE
op_minus
id|DC_SIZE
)paren
op_div
(paren
id|KEY_SIZE
op_plus
id|DC_SIZE
)paren
)paren
(brace
multiline_comment|/* for internal which is not root we might check min number of keys */
id|reiserfs_warning
(paren
l_string|&quot;is_internal: number of key seems wrong: %z&bslash;n&quot;
comma
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|used_space
op_assign
id|BLKH_SIZE
op_plus
id|KEY_SIZE
op_star
id|nr
op_plus
id|DC_SIZE
op_star
(paren
id|nr
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|used_space
op_ne
id|blocksize
op_minus
id|blkh_free_space
c_func
(paren
id|blkh
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;is_internal: free space seems wrong: %z&bslash;n&quot;
comma
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// one may imagine much more checks
r_return
l_int|1
suffix:semicolon
)brace
singleline_comment|// make sure that bh contains formatted node of reiserfs tree of
singleline_comment|// &squot;level&squot;-th level
DECL|function|is_tree_node
r_static
r_int
id|is_tree_node
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|level
)paren
(brace
r_if
c_cond
(paren
id|B_LEVEL
(paren
id|bh
)paren
op_ne
id|level
)paren
(brace
id|printk
(paren
l_string|&quot;is_tree_node: node level %d does not match to the expected one %d&bslash;n&quot;
comma
id|B_LEVEL
(paren
id|bh
)paren
comma
id|level
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|level
op_eq
id|DISK_LEAF_NODE_LEVEL
)paren
r_return
id|is_leaf
(paren
id|bh-&gt;b_data
comma
id|bh-&gt;b_size
comma
id|bh
)paren
suffix:semicolon
r_return
id|is_internal
(paren
id|bh-&gt;b_data
comma
id|bh-&gt;b_size
comma
id|bh
)paren
suffix:semicolon
)brace
macro_line|#ifdef SEARCH_BY_KEY_READA
multiline_comment|/* The function is NOT SCHEDULE-SAFE! */
DECL|function|search_by_key_reada
r_static
r_void
id|search_by_key_reada
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|blocknr
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|blocknr
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|bh
op_assign
id|sb_getblk
(paren
id|s
comma
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
(paren
id|bh
)paren
)paren
(brace
id|ll_rw_block
(paren
id|READA
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
)brace
id|bh-&gt;b_count
op_decrement
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/**************************************************************************&n; * Algorithm   SearchByKey                                                *&n; *             look for item in the Disk S+Tree by its key                *&n; * Input:  p_s_sb   -  super block                                        *&n; *         p_s_key  - pointer to the key to search                        *&n; * Output: ITEM_FOUND, ITEM_NOT_FOUND or IO_ERROR                         *&n; *         p_s_search_path - path from the root to the needed leaf        *&n; **************************************************************************/
multiline_comment|/* This function fills up the path from the root to the leaf as it&n;   descends the tree looking for the key.  It uses reiserfs_bread to&n;   try to find buffers in the cache given their block number.  If it&n;   does not find them in the cache it reads them from disk.  For each&n;   node search_by_key finds using reiserfs_bread it then uses&n;   bin_search to look through that node.  bin_search will find the&n;   position of the block_number of the next node if it is looking&n;   through an internal node.  If it is looking through a leaf node&n;   bin_search will find the position of the item which has key either&n;   equal to given key, or which is the maximal key less than the given&n;   key.  search_by_key returns a path that must be checked for the&n;   correctness of the top of the path but need not be checked for the&n;   correctness of the bottom of the path */
multiline_comment|/* The function is NOT SCHEDULE-SAFE! */
DECL|function|search_by_key
r_int
id|search_by_key
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_const
r_struct
id|cpu_key
op_star
id|p_s_key
comma
multiline_comment|/* Key to search. */
r_struct
id|path
op_star
id|p_s_search_path
comma
multiline_comment|/* This structure was&n;&t;&t;&t;&t;&t;&t;     allocated and initialized&n;&t;&t;&t;&t;&t;&t;     by the calling&n;&t;&t;&t;&t;&t;&t;     function. It is filled up&n;&t;&t;&t;&t;&t;&t;     by this function.  */
r_int
id|n_stop_level
multiline_comment|/* How far down the tree to search. To&n;                                       stop at leaf level - set to&n;                                       DISK_LEAF_NODE_LEVEL */
)paren
(brace
r_int
id|n_block_number
op_assign
id|SB_ROOT_BLOCK
(paren
id|p_s_sb
)paren
comma
id|expected_level
op_assign
id|SB_TREE_HEIGHT
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|p_s_bh
suffix:semicolon
r_struct
id|path_element
op_star
id|p_s_last_element
suffix:semicolon
r_int
id|n_node_level
comma
id|n_retval
suffix:semicolon
r_int
id|right_neighbor_of_leaf_node
suffix:semicolon
r_int
id|fs_gen
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_int
id|n_repeat_counter
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|search_by_key
)paren
suffix:semicolon
multiline_comment|/* As we add each node to a path we increase its count.  This means that&n;       we must be careful to release all nodes in a path before we either&n;       discard the path struct or re-use the path struct, as we do here. */
id|decrement_counters_in_path
c_func
(paren
id|p_s_search_path
)paren
suffix:semicolon
id|right_neighbor_of_leaf_node
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* With each iteration of this loop we search through the items in the&n;       current node, and calculate the next current node(next path element)&n;       for the next iteration of this loop.. */
r_while
c_loop
(paren
l_int|1
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
(paren
op_increment
id|n_repeat_counter
op_mod
l_int|50000
)paren
)paren
id|reiserfs_warning
(paren
l_string|&quot;PAP-5100: search_by_key: %s:&quot;
l_string|&quot;there were %d iterations of while loop &quot;
l_string|&quot;looking for key %K&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|n_repeat_counter
comma
id|p_s_key
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* prep path to have another element added to it. */
id|p_s_last_element
op_assign
id|PATH_OFFSET_PELEMENT
c_func
(paren
id|p_s_search_path
comma
op_increment
id|p_s_search_path-&gt;path_length
)paren
suffix:semicolon
id|fs_gen
op_assign
id|get_generation
(paren
id|p_s_sb
)paren
suffix:semicolon
id|expected_level
op_decrement
suffix:semicolon
macro_line|#ifdef SEARCH_BY_KEY_READA
multiline_comment|/* schedule read of right neighbor */
id|search_by_key_reada
(paren
id|p_s_sb
comma
id|right_neighbor_of_leaf_node
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read the next tree node, and set the last element in the path to&n;           have a pointer to it. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p_s_bh
op_assign
id|p_s_last_element-&gt;pe_buffer
op_assign
id|sb_bread
c_func
(paren
id|p_s_sb
comma
id|n_block_number
)paren
)paren
)paren
(brace
id|p_s_search_path-&gt;path_length
op_decrement
suffix:semicolon
id|pathrelse
c_func
(paren
id|p_s_search_path
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|p_s_sb
)paren
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|search_by_key_fs_changed
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|sbk_fs_changed
(braket
id|expected_level
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* It is possible that schedule occurred. We must check whether the key&n;&t;   to search is still in the tree rooted from the current buffer. If&n;&t;   not then repeat search from the root. */
r_if
c_cond
(paren
id|fs_changed
(paren
id|fs_gen
comma
id|p_s_sb
)paren
op_logical_and
(paren
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_bh
)paren
op_logical_or
op_logical_neg
id|key_in_buffer
c_func
(paren
id|p_s_search_path
comma
id|p_s_key
comma
id|p_s_sb
)paren
)paren
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|search_by_key_restarted
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|sbk_restarted
(braket
id|expected_level
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|decrement_counters_in_path
c_func
(paren
id|p_s_search_path
)paren
suffix:semicolon
multiline_comment|/* Get the root block number so that we can repeat the search&n;               starting from the root. */
id|n_block_number
op_assign
id|SB_ROOT_BLOCK
(paren
id|p_s_sb
)paren
suffix:semicolon
id|expected_level
op_assign
id|SB_TREE_HEIGHT
(paren
id|p_s_sb
)paren
suffix:semicolon
id|right_neighbor_of_leaf_node
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* repeat search from the root */
r_continue
suffix:semicolon
)brace
multiline_comment|/* only check that the key is in the buffer if p_s_key is not&n;           equal to the MAX_KEY. Latter case is only possible in&n;           &quot;finish_unfinished()&quot; processing during mount. */
id|RFALSE
c_func
(paren
id|COMP_KEYS
c_func
(paren
op_amp
id|MAX_KEY
comma
id|p_s_key
)paren
op_logical_and
op_logical_neg
id|key_in_buffer
c_func
(paren
id|p_s_search_path
comma
id|p_s_key
comma
id|p_s_sb
)paren
comma
l_string|&quot;PAP-5130: key is not in the buffer&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|cur_tb
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;5140&quot;
)paren
suffix:semicolon
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;PAP-5140: search_by_key: schedule occurred in do_balance!&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
singleline_comment|// make sure, that the node contents look like a node of
singleline_comment|// certain level
r_if
c_cond
(paren
op_logical_neg
id|is_tree_node
(paren
id|p_s_bh
comma
id|expected_level
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-5150: search_by_key: &quot;
l_string|&quot;invalid format found in block %ld. Fsck?&bslash;n&quot;
comma
id|p_s_bh-&gt;b_blocknr
)paren
suffix:semicolon
id|pathrelse
(paren
id|p_s_search_path
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
multiline_comment|/* ok, we have acquired next formatted node in the tree */
id|n_node_level
op_assign
id|B_LEVEL
(paren
id|p_s_bh
)paren
suffix:semicolon
id|PROC_INFO_BH_STAT
c_func
(paren
id|p_s_sb
comma
id|p_s_bh
comma
id|n_node_level
op_minus
l_int|1
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_node_level
OL
id|n_stop_level
comma
l_string|&quot;vs-5152: tree level (%d) is less than stop level (%d)&quot;
comma
id|n_node_level
comma
id|n_stop_level
)paren
suffix:semicolon
id|n_retval
op_assign
id|bin_search
c_func
(paren
id|p_s_key
comma
id|B_N_PITEM_HEAD
c_func
(paren
id|p_s_bh
comma
l_int|0
)paren
comma
id|B_NR_ITEMS
c_func
(paren
id|p_s_bh
)paren
comma
(paren
id|n_node_level
op_eq
id|DISK_LEAF_NODE_LEVEL
)paren
ques
c_cond
id|IH_SIZE
suffix:colon
id|KEY_SIZE
comma
op_amp
(paren
id|p_s_last_element-&gt;pe_position
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_node_level
op_eq
id|n_stop_level
)paren
(brace
r_return
id|n_retval
suffix:semicolon
)brace
multiline_comment|/* we are not in the stop level */
r_if
c_cond
(paren
id|n_retval
op_eq
id|ITEM_FOUND
)paren
multiline_comment|/* item has been found, so we choose the pointer which is to the right of the found one */
id|p_s_last_element-&gt;pe_position
op_increment
suffix:semicolon
multiline_comment|/* if item was not found we choose the position which is to&n;&t;   the left of the found item. This requires no code,&n;&t;   bin_search did it already.*/
multiline_comment|/* So we have chosen a position in the current node which is&n;&t;   an internal node.  Now we calculate child block number by&n;&t;   position in the node. */
id|n_block_number
op_assign
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_bh
comma
id|p_s_last_element-&gt;pe_position
)paren
suffix:semicolon
macro_line|#ifdef SEARCH_BY_KEY_READA
multiline_comment|/* if we are going to read leaf node, then calculate its right neighbor if possible */
r_if
c_cond
(paren
id|n_node_level
op_eq
id|DISK_LEAF_NODE_LEVEL
op_plus
l_int|1
op_logical_and
id|p_s_last_element-&gt;pe_position
OL
id|B_NR_ITEMS
(paren
id|p_s_bh
)paren
)paren
id|right_neighbor_of_leaf_node
op_assign
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_bh
comma
id|p_s_last_element-&gt;pe_position
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/* Form the path to an item and position in this item which contains&n;   file byte defined by p_s_key. If there is no such item&n;   corresponding to the key, we point the path to the item with&n;   maximal key less than p_s_key, and *p_n_pos_in_item is set to one&n;   past the last entry/byte in the item.  If searching for entry in a&n;   directory item, and it is not found, *p_n_pos_in_item is set to one&n;   entry more than the entry with maximal key which is less than the&n;   sought key.&n;&n;   Note that if there is no entry in this same node which is one more,&n;   then we point to an imaginary entry.  for direct items, the&n;   position is in units of bytes, for indirect items the position is&n;   in units of blocknr entries, for directory items the position is in&n;   units of directory entries.  */
multiline_comment|/* The function is NOT SCHEDULE-SAFE! */
DECL|function|search_for_position_by_key
r_int
id|search_for_position_by_key
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
multiline_comment|/* Pointer to the super block.          */
r_const
r_struct
id|cpu_key
op_star
id|p_cpu_key
comma
multiline_comment|/* Key to search (cpu variable)         */
r_struct
id|path
op_star
id|p_s_search_path
multiline_comment|/* Filled up by this function.          */
)paren
(brace
r_struct
id|item_head
op_star
id|p_le_ih
suffix:semicolon
multiline_comment|/* pointer to on-disk structure */
r_int
id|n_blk_size
suffix:semicolon
id|loff_t
id|item_offset
comma
id|offset
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/* If searching for directory entry. */
r_if
c_cond
(paren
id|is_direntry_cpu_key
(paren
id|p_cpu_key
)paren
)paren
r_return
id|search_by_entry_key
(paren
id|p_s_sb
comma
id|p_cpu_key
comma
id|p_s_search_path
comma
op_amp
id|de
)paren
suffix:semicolon
multiline_comment|/* If not searching for directory entry. */
multiline_comment|/* If item is found. */
id|retval
op_assign
id|search_item
(paren
id|p_s_sb
comma
id|p_cpu_key
comma
id|p_s_search_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|ih_item_len
c_func
(paren
id|B_N_PITEM_HEAD
c_func
(paren
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_search_path
)paren
comma
id|PATH_LAST_POSITION
c_func
(paren
id|p_s_search_path
)paren
)paren
)paren
comma
l_string|&quot;PAP-5165: item length equals zero&quot;
)paren
suffix:semicolon
id|pos_in_item
c_func
(paren
id|p_s_search_path
)paren
op_assign
l_int|0
suffix:semicolon
r_return
id|POSITION_FOUND
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
op_logical_neg
id|PATH_LAST_POSITION
c_func
(paren
id|p_s_search_path
)paren
comma
l_string|&quot;PAP-5170: position equals zero&quot;
)paren
suffix:semicolon
multiline_comment|/* Item is not found. Set path to the previous item. */
id|p_le_ih
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_search_path
)paren
comma
op_decrement
id|PATH_LAST_POSITION
c_func
(paren
id|p_s_search_path
)paren
)paren
suffix:semicolon
id|n_blk_size
op_assign
id|p_s_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|comp_short_keys
(paren
op_amp
(paren
id|p_le_ih-&gt;ih_key
)paren
comma
id|p_cpu_key
)paren
)paren
(brace
r_return
id|FILE_NOT_FOUND
suffix:semicolon
)brace
singleline_comment|// FIXME: quite ugly this far
id|item_offset
op_assign
id|le_ih_k_offset
(paren
id|p_le_ih
)paren
suffix:semicolon
id|offset
op_assign
id|cpu_key_k_offset
(paren
id|p_cpu_key
)paren
suffix:semicolon
multiline_comment|/* Needed byte is contained in the item pointed to by the path.*/
r_if
c_cond
(paren
id|item_offset
op_le
id|offset
op_logical_and
id|item_offset
op_plus
id|op_bytes_number
(paren
id|p_le_ih
comma
id|n_blk_size
)paren
OG
id|offset
)paren
(brace
id|pos_in_item
(paren
id|p_s_search_path
)paren
op_assign
id|offset
op_minus
id|item_offset
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
c_func
(paren
id|p_le_ih
)paren
)paren
(brace
id|pos_in_item
(paren
id|p_s_search_path
)paren
op_div_assign
id|n_blk_size
suffix:semicolon
)brace
r_return
id|POSITION_FOUND
suffix:semicolon
)brace
multiline_comment|/* Needed byte is not contained in the item pointed to by the&n;     path. Set pos_in_item out of the item. */
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|p_le_ih
)paren
)paren
id|pos_in_item
(paren
id|p_s_search_path
)paren
op_assign
id|ih_item_len
c_func
(paren
id|p_le_ih
)paren
op_div
id|UNFM_P_SIZE
suffix:semicolon
r_else
id|pos_in_item
(paren
id|p_s_search_path
)paren
op_assign
id|ih_item_len
c_func
(paren
id|p_le_ih
)paren
suffix:semicolon
r_return
id|POSITION_NOT_FOUND
suffix:semicolon
)brace
multiline_comment|/* Compare given item and item pointed to by the path. */
DECL|function|comp_items
r_int
id|comp_items
(paren
r_const
r_struct
id|item_head
op_star
id|stored_ih
comma
r_const
r_struct
id|path
op_star
id|p_s_path
)paren
(brace
r_struct
id|buffer_head
op_star
id|p_s_bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
multiline_comment|/* Last buffer at the path is not in the tree. */
r_if
c_cond
(paren
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|p_s_bh
op_assign
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_path
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Last path position is invalid. */
r_if
c_cond
(paren
id|PATH_LAST_POSITION
c_func
(paren
id|p_s_path
)paren
op_ge
id|B_NR_ITEMS
c_func
(paren
id|p_s_bh
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* we need only to know, whether it is the same item */
id|ih
op_assign
id|get_ih
(paren
id|p_s_path
)paren
suffix:semicolon
r_return
id|memcmp
(paren
id|stored_ih
comma
id|ih
comma
id|IH_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* unformatted nodes are not logged anymore, ever.  This is safe&n;** now&n;*/
DECL|macro|held_by_others
mdefine_line|#define held_by_others(bh) (atomic_read(&amp;(bh)-&gt;b_count) &gt; 1)
singleline_comment|// block can not be forgotten as it is in I/O or held by someone
DECL|macro|block_in_use
mdefine_line|#define block_in_use(bh) (buffer_locked(bh) || (held_by_others(bh)))
singleline_comment|// prepare for delete or cut of direct item
DECL|function|prepare_for_direct_item
r_static
r_inline
r_int
id|prepare_for_direct_item
(paren
r_struct
id|path
op_star
id|path
comma
r_struct
id|item_head
op_star
id|le_ih
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|new_file_length
comma
r_int
op_star
id|cut_size
)paren
(brace
id|loff_t
id|round_len
suffix:semicolon
r_if
c_cond
(paren
id|new_file_length
op_eq
id|max_reiserfs_offset
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* item has to be deleted */
op_star
id|cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
id|le_ih
)paren
)paren
suffix:semicolon
r_return
id|M_DELETE
suffix:semicolon
)brace
singleline_comment|// new file gets truncated
r_if
c_cond
(paren
id|get_inode_item_key_version
(paren
id|inode
)paren
op_eq
id|KEY_FORMAT_3_6
)paren
(brace
singleline_comment|// 
id|round_len
op_assign
id|ROUND_UP
(paren
id|new_file_length
)paren
suffix:semicolon
multiline_comment|/* this was n_new_file_length &lt; le_ih ... */
r_if
c_cond
(paren
id|round_len
OL
id|le_ih_k_offset
(paren
id|le_ih
)paren
)paren
(brace
op_star
id|cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
id|le_ih
)paren
)paren
suffix:semicolon
r_return
id|M_DELETE
suffix:semicolon
multiline_comment|/* Delete this item. */
)brace
multiline_comment|/* Calculate first position and size for cutting from item. */
id|pos_in_item
(paren
id|path
)paren
op_assign
id|round_len
op_minus
(paren
id|le_ih_k_offset
(paren
id|le_ih
)paren
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|cut_size
op_assign
op_minus
(paren
id|ih_item_len
c_func
(paren
id|le_ih
)paren
op_minus
id|pos_in_item
c_func
(paren
id|path
)paren
)paren
suffix:semicolon
r_return
id|M_CUT
suffix:semicolon
multiline_comment|/* Cut from this item. */
)brace
singleline_comment|// old file: items may have any length
r_if
c_cond
(paren
id|new_file_length
OL
id|le_ih_k_offset
(paren
id|le_ih
)paren
)paren
(brace
op_star
id|cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
id|le_ih
)paren
)paren
suffix:semicolon
r_return
id|M_DELETE
suffix:semicolon
multiline_comment|/* Delete this item. */
)brace
multiline_comment|/* Calculate first position and size for cutting from item. */
op_star
id|cut_size
op_assign
op_minus
(paren
id|ih_item_len
c_func
(paren
id|le_ih
)paren
op_minus
(paren
id|pos_in_item
(paren
id|path
)paren
op_assign
id|new_file_length
op_plus
l_int|1
op_minus
id|le_ih_k_offset
(paren
id|le_ih
)paren
)paren
)paren
suffix:semicolon
r_return
id|M_CUT
suffix:semicolon
multiline_comment|/* Cut from this item. */
)brace
DECL|function|prepare_for_direntry_item
r_static
r_inline
r_int
id|prepare_for_direntry_item
(paren
r_struct
id|path
op_star
id|path
comma
r_struct
id|item_head
op_star
id|le_ih
comma
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|new_file_length
comma
r_int
op_star
id|cut_size
)paren
(brace
r_if
c_cond
(paren
id|le_ih_k_offset
(paren
id|le_ih
)paren
op_eq
id|DOT_OFFSET
op_logical_and
id|new_file_length
op_eq
id|max_reiserfs_offset
(paren
id|inode
)paren
)paren
(brace
id|RFALSE
c_func
(paren
id|ih_entry_count
(paren
id|le_ih
)paren
op_ne
l_int|2
comma
l_string|&quot;PAP-5220: incorrect empty directory item (%h)&quot;
comma
id|le_ih
)paren
suffix:semicolon
op_star
id|cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
id|le_ih
)paren
)paren
suffix:semicolon
r_return
id|M_DELETE
suffix:semicolon
multiline_comment|/* Delete the directory item containing &quot;.&quot; and &quot;..&quot; entry. */
)brace
r_if
c_cond
(paren
id|ih_entry_count
(paren
id|le_ih
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Delete the directory item such as there is one record only&n;&t;   in this item*/
op_star
id|cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
id|le_ih
)paren
)paren
suffix:semicolon
r_return
id|M_DELETE
suffix:semicolon
)brace
multiline_comment|/* Cut one record from the directory item. */
op_star
id|cut_size
op_assign
op_minus
(paren
id|DEH_SIZE
op_plus
id|entry_length
(paren
id|get_last_bh
(paren
id|path
)paren
comma
id|le_ih
comma
id|pos_in_item
(paren
id|path
)paren
)paren
)paren
suffix:semicolon
r_return
id|M_CUT
suffix:semicolon
)brace
multiline_comment|/*  If the path points to a directory or direct item, calculate mode and the size cut, for balance.&n;    If the path points to an indirect item, remove some number of its unformatted nodes.&n;    In case of file truncate calculate whether this item must be deleted/truncated or last&n;    unformatted node of this item will be converted to a direct item.&n;    This function returns a determination of what balance mode the calling function should employ. */
DECL|function|prepare_for_delete_or_cut
r_static
r_char
id|prepare_for_delete_or_cut
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|path
op_star
id|p_s_path
comma
r_const
r_struct
id|cpu_key
op_star
id|p_s_item_key
comma
r_int
op_star
id|p_n_removed
comma
multiline_comment|/* Number of unformatted nodes which were removed&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;  from end of the file. */
r_int
op_star
id|p_n_cut_size
comma
r_int
r_int
r_int
id|n_new_file_length
multiline_comment|/* MAX_KEY_OFFSET in case of delete. */
)paren
(brace
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_struct
id|item_head
op_star
id|p_le_ih
op_assign
id|PATH_PITEM_HEAD
c_func
(paren
id|p_s_path
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|p_s_bh
op_assign
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_path
)paren
suffix:semicolon
multiline_comment|/* Stat_data item. */
r_if
c_cond
(paren
id|is_statdata_le_ih
(paren
id|p_le_ih
)paren
)paren
(brace
id|RFALSE
c_func
(paren
id|n_new_file_length
op_ne
id|max_reiserfs_offset
(paren
id|inode
)paren
comma
l_string|&quot;PAP-5210: mode must be M_DELETE&quot;
)paren
suffix:semicolon
op_star
id|p_n_cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
id|p_le_ih
)paren
)paren
suffix:semicolon
r_return
id|M_DELETE
suffix:semicolon
)brace
multiline_comment|/* Directory item. */
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|p_le_ih
)paren
)paren
r_return
id|prepare_for_direntry_item
(paren
id|p_s_path
comma
id|p_le_ih
comma
id|inode
comma
id|n_new_file_length
comma
id|p_n_cut_size
)paren
suffix:semicolon
multiline_comment|/* Direct item. */
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|p_le_ih
)paren
)paren
r_return
id|prepare_for_direct_item
(paren
id|p_s_path
comma
id|p_le_ih
comma
id|inode
comma
id|n_new_file_length
comma
id|p_n_cut_size
)paren
suffix:semicolon
multiline_comment|/* Case of an indirect item. */
(brace
r_int
id|n_unfm_number
comma
multiline_comment|/* Number of the item unformatted nodes. */
id|n_counter
comma
id|n_blk_size
suffix:semicolon
id|__u32
op_star
id|p_n_unfm_pointer
suffix:semicolon
multiline_comment|/* Pointer to the unformatted node number. */
id|__u32
id|tmp
suffix:semicolon
r_struct
id|item_head
id|s_ih
suffix:semicolon
multiline_comment|/* Item header. */
r_char
id|c_mode
suffix:semicolon
multiline_comment|/* Returned mode of the balance. */
r_int
id|need_research
suffix:semicolon
id|n_blk_size
op_assign
id|p_s_sb-&gt;s_blocksize
suffix:semicolon
multiline_comment|/* Search for the needed object indirect item until there are no unformatted nodes to be removed. */
r_do
(brace
id|need_research
op_assign
l_int|0
suffix:semicolon
id|p_s_bh
op_assign
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_path
)paren
suffix:semicolon
multiline_comment|/* Copy indirect item header to a temp variable. */
id|copy_item_head
c_func
(paren
op_amp
id|s_ih
comma
id|PATH_PITEM_HEAD
c_func
(paren
id|p_s_path
)paren
)paren
suffix:semicolon
multiline_comment|/* Calculate number of unformatted nodes in this item. */
id|n_unfm_number
op_assign
id|I_UNFM_NUM
c_func
(paren
op_amp
id|s_ih
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|is_indirect_le_ih
c_func
(paren
op_amp
id|s_ih
)paren
op_logical_or
op_logical_neg
id|n_unfm_number
op_logical_or
id|pos_in_item
(paren
id|p_s_path
)paren
op_plus
l_int|1
op_ne
id|n_unfm_number
comma
l_string|&quot;PAP-5240: invalid item %h &quot;
l_string|&quot;n_unfm_number = %d *p_n_pos_in_item = %d&quot;
comma
op_amp
id|s_ih
comma
id|n_unfm_number
comma
id|pos_in_item
(paren
id|p_s_path
)paren
)paren
suffix:semicolon
multiline_comment|/* Calculate balance mode and position in the item to remove unformatted nodes. */
r_if
c_cond
(paren
id|n_new_file_length
op_eq
id|max_reiserfs_offset
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* Case of delete. */
id|pos_in_item
(paren
id|p_s_path
)paren
op_assign
l_int|0
suffix:semicolon
op_star
id|p_n_cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
op_amp
id|s_ih
)paren
)paren
suffix:semicolon
id|c_mode
op_assign
id|M_DELETE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Case of truncate. */
r_if
c_cond
(paren
id|n_new_file_length
OL
id|le_ih_k_offset
(paren
op_amp
id|s_ih
)paren
)paren
(brace
id|pos_in_item
(paren
id|p_s_path
)paren
op_assign
l_int|0
suffix:semicolon
op_star
id|p_n_cut_size
op_assign
op_minus
(paren
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
op_amp
id|s_ih
)paren
)paren
suffix:semicolon
id|c_mode
op_assign
id|M_DELETE
suffix:semicolon
multiline_comment|/* Delete this item. */
)brace
r_else
(brace
multiline_comment|/* indirect item must be truncated starting from *p_n_pos_in_item-th position */
id|pos_in_item
(paren
id|p_s_path
)paren
op_assign
(paren
id|n_new_file_length
op_plus
id|n_blk_size
op_minus
id|le_ih_k_offset
(paren
op_amp
id|s_ih
)paren
)paren
op_rshift
id|p_s_sb-&gt;s_blocksize_bits
suffix:semicolon
id|RFALSE
c_func
(paren
id|pos_in_item
(paren
id|p_s_path
)paren
OG
id|n_unfm_number
comma
l_string|&quot;PAP-5250: invalid position in the item&quot;
)paren
suffix:semicolon
multiline_comment|/* Either convert last unformatted node of indirect item to direct item or increase&n;&t;&t;       its free space.  */
r_if
c_cond
(paren
id|pos_in_item
(paren
id|p_s_path
)paren
op_eq
id|n_unfm_number
)paren
(brace
op_star
id|p_n_cut_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Nothing to cut. */
r_return
id|M_CONVERT
suffix:semicolon
multiline_comment|/* Maybe convert last unformatted node to the direct item. */
)brace
multiline_comment|/* Calculate size to cut. */
op_star
id|p_n_cut_size
op_assign
op_minus
(paren
id|ih_item_len
c_func
(paren
op_amp
id|s_ih
)paren
op_minus
id|pos_in_item
c_func
(paren
id|p_s_path
)paren
op_star
id|UNFM_P_SIZE
)paren
suffix:semicolon
id|c_mode
op_assign
id|M_CUT
suffix:semicolon
multiline_comment|/* Cut from this indirect item. */
)brace
)brace
id|RFALSE
c_func
(paren
id|n_unfm_number
op_le
id|pos_in_item
(paren
id|p_s_path
)paren
comma
l_string|&quot;PAP-5260: invalid position in the indirect item&quot;
)paren
suffix:semicolon
multiline_comment|/* pointers to be cut */
id|n_unfm_number
op_sub_assign
id|pos_in_item
(paren
id|p_s_path
)paren
suffix:semicolon
multiline_comment|/* Set pointer to the last unformatted node pointer that is to be cut. */
id|p_n_unfm_pointer
op_assign
(paren
id|__u32
op_star
)paren
id|B_I_PITEM
c_func
(paren
id|p_s_bh
comma
op_amp
id|s_ih
)paren
op_plus
id|I_UNFM_NUM
c_func
(paren
op_amp
id|s_ih
)paren
op_minus
l_int|1
op_minus
op_star
id|p_n_removed
suffix:semicolon
multiline_comment|/* We go through the unformatted nodes pointers of the indirect&n;&t;       item and look for the unformatted nodes in the cache. If we&n;&t;       found some of them we free it, zero corresponding indirect item&n;&t;       entry and log buffer containing that indirect item. For this we&n;&t;       need to prepare last path element for logging. If some&n;&t;       unformatted node has b_count &gt; 1 we must not free this&n;&t;       unformatted node since it is in use. */
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|p_s_bh
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// note: path could be changed, first line in for loop takes care
singleline_comment|// of it
r_for
c_loop
(paren
id|n_counter
op_assign
op_star
id|p_n_removed
suffix:semicolon
id|n_counter
OL
id|n_unfm_number
suffix:semicolon
id|n_counter
op_increment
comma
id|p_n_unfm_pointer
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|item_moved
(paren
op_amp
id|s_ih
comma
id|p_s_path
)paren
)paren
(brace
id|need_research
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|p_n_unfm_pointer
template_param
(paren
id|__u32
op_star
)paren
id|B_I_PITEM
c_func
(paren
id|p_s_bh
comma
op_amp
id|s_ih
)paren
op_plus
id|I_UNFM_NUM
c_func
(paren
op_amp
id|s_ih
)paren
op_minus
l_int|1
comma
l_string|&quot;vs-5265: pointer out of range&quot;
)paren
suffix:semicolon
multiline_comment|/* Hole, nothing to remove. */
r_if
c_cond
(paren
op_logical_neg
id|get_block_num
c_func
(paren
id|p_n_unfm_pointer
comma
l_int|0
)paren
)paren
(brace
(paren
op_star
id|p_n_removed
)paren
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
(paren
op_star
id|p_n_removed
)paren
op_increment
suffix:semicolon
id|tmp
op_assign
id|get_block_num
c_func
(paren
id|p_n_unfm_pointer
comma
l_int|0
)paren
suffix:semicolon
id|put_block_num
c_func
(paren
id|p_n_unfm_pointer
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|p_s_sb
comma
id|p_s_bh
)paren
suffix:semicolon
id|inode-&gt;i_blocks
op_sub_assign
id|p_s_sb-&gt;s_blocksize
op_div
l_int|512
suffix:semicolon
id|reiserfs_free_block
c_func
(paren
id|th
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item_moved
(paren
op_amp
id|s_ih
comma
id|p_s_path
)paren
)paren
(brace
id|need_research
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* a trick.  If the buffer has been logged, this&n;&t;    ** will do nothing.  If we&squot;ve broken the loop without&n;&t;    ** logging it, it will restore the buffer&n;&t;    **&n;&t;    */
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_sb
comma
id|p_s_bh
)paren
suffix:semicolon
multiline_comment|/* This loop can be optimized. */
)brace
r_while
c_loop
(paren
(paren
op_star
id|p_n_removed
OL
id|n_unfm_number
op_logical_or
id|need_research
)paren
op_logical_and
id|search_for_position_by_key
c_func
(paren
id|p_s_sb
comma
id|p_s_item_key
comma
id|p_s_path
)paren
op_eq
id|POSITION_FOUND
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_star
id|p_n_removed
OL
id|n_unfm_number
comma
l_string|&quot;PAP-5310: indirect item is not found&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|item_moved
(paren
op_amp
id|s_ih
comma
id|p_s_path
)paren
comma
l_string|&quot;after while, comp failed, retry&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_mode
op_eq
id|M_CUT
)paren
id|pos_in_item
(paren
id|p_s_path
)paren
op_mul_assign
id|UNFM_P_SIZE
suffix:semicolon
r_return
id|c_mode
suffix:semicolon
)brace
)brace
multiline_comment|/* Calculate bytes number which will be deleted or cutted in the balance. */
DECL|function|calc_deleted_bytes_number
r_int
id|calc_deleted_bytes_number
c_func
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_char
id|c_mode
)paren
(brace
r_int
id|n_del_size
suffix:semicolon
r_struct
id|item_head
op_star
id|p_le_ih
op_assign
id|PATH_PITEM_HEAD
c_func
(paren
id|p_s_tb-&gt;tb_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_statdata_le_ih
(paren
id|p_le_ih
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|p_le_ih
)paren
)paren
(brace
singleline_comment|// return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
singleline_comment|// we can&squot;t use EMPTY_DIR_SIZE, as old format dirs have a different
singleline_comment|// empty size.  ick. FIXME, is this right?
singleline_comment|//
r_return
id|ih_item_len
c_func
(paren
id|p_le_ih
)paren
suffix:semicolon
)brace
id|n_del_size
op_assign
(paren
id|c_mode
op_eq
id|M_DELETE
)paren
ques
c_cond
id|ih_item_len
c_func
(paren
id|p_le_ih
)paren
suffix:colon
op_minus
id|p_s_tb-&gt;insert_size
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|p_le_ih
)paren
)paren
id|n_del_size
op_assign
(paren
id|n_del_size
op_div
id|UNFM_P_SIZE
)paren
op_star
(paren
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
)paren
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
singleline_comment|// - get_ih_free_space (p_le_ih);
r_return
id|n_del_size
suffix:semicolon
)brace
DECL|function|init_tb_struct
r_static
r_void
id|init_tb_struct
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|path
op_star
id|p_s_path
comma
r_int
id|n_size
)paren
(brace
id|memset
(paren
id|p_s_tb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
r_struct
id|tree_balance
)paren
)paren
suffix:semicolon
id|p_s_tb-&gt;transaction_handle
op_assign
id|th
suffix:semicolon
id|p_s_tb-&gt;tb_sb
op_assign
id|p_s_sb
suffix:semicolon
id|p_s_tb-&gt;tb_path
op_assign
id|p_s_path
suffix:semicolon
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
op_assign
l_int|NULL
suffix:semicolon
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_path
comma
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
op_assign
l_int|0
suffix:semicolon
id|p_s_tb-&gt;insert_size
(braket
l_int|0
)braket
op_assign
id|n_size
suffix:semicolon
)brace
DECL|function|padd_item
r_void
id|padd_item
(paren
r_char
op_star
id|item
comma
r_int
id|total_length
comma
r_int
id|length
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|total_length
suffix:semicolon
id|i
OG
id|length
suffix:semicolon
)paren
id|item
(braket
op_decrement
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Delete object item. */
DECL|function|reiserfs_delete_item
r_int
id|reiserfs_delete_item
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|path
op_star
id|p_s_path
comma
multiline_comment|/* Path to the deleted item. */
r_const
r_struct
id|cpu_key
op_star
id|p_s_item_key
comma
multiline_comment|/* Key to search for the deleted item.  */
r_struct
id|inode
op_star
id|p_s_inode
comma
multiline_comment|/* inode is here just to update i_blocks */
r_struct
id|buffer_head
op_star
id|p_s_un_bh
)paren
multiline_comment|/* NULL or unformatted node pointer.    */
(brace
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|p_s_inode-&gt;i_sb
suffix:semicolon
r_struct
id|tree_balance
id|s_del_balance
suffix:semicolon
r_struct
id|item_head
id|s_ih
suffix:semicolon
r_int
id|n_ret_value
comma
id|n_del_size
comma
id|n_removed
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_char
id|c_mode
suffix:semicolon
r_int
id|n_iter
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|init_tb_struct
c_func
(paren
id|th
comma
op_amp
id|s_del_balance
comma
id|p_s_sb
comma
id|p_s_path
comma
l_int|0
multiline_comment|/*size is unknown*/
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|n_removed
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|n_iter
op_increment
suffix:semicolon
id|c_mode
op_assign
macro_line|#endif
id|prepare_for_delete_or_cut
c_func
(paren
id|th
comma
id|p_s_inode
comma
id|p_s_path
comma
id|p_s_item_key
comma
op_amp
id|n_removed
comma
op_amp
id|n_del_size
comma
id|max_reiserfs_offset
(paren
id|p_s_inode
)paren
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|c_mode
op_ne
id|M_DELETE
comma
l_string|&quot;PAP-5320: mode must be M_DELETE&quot;
)paren
suffix:semicolon
id|copy_item_head
c_func
(paren
op_amp
id|s_ih
comma
id|PATH_PITEM_HEAD
c_func
(paren
id|p_s_path
)paren
)paren
suffix:semicolon
id|s_del_balance.insert_size
(braket
l_int|0
)braket
op_assign
id|n_del_size
suffix:semicolon
id|n_ret_value
op_assign
id|fix_nodes
c_func
(paren
id|M_DELETE
comma
op_amp
id|s_del_balance
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_ret_value
op_ne
id|REPEAT_SEARCH
)paren
r_break
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|delete_item_restarted
)paren
suffix:semicolon
singleline_comment|// file system changed, repeat search
id|n_ret_value
op_assign
id|search_for_position_by_key
c_func
(paren
id|p_s_sb
comma
id|p_s_item_key
comma
id|p_s_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_ret_value
op_eq
id|IO_ERROR
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|n_ret_value
op_eq
id|FILE_NOT_FOUND
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-5340: reiserfs_delete_item: &quot;
l_string|&quot;no items of the file %K found&bslash;n&quot;
comma
id|p_s_item_key
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* while (1) */
r_if
c_cond
(paren
id|n_ret_value
op_ne
id|CARRY_ON
)paren
(brace
id|unfix_nodes
c_func
(paren
op_amp
id|s_del_balance
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// reiserfs_delete_item returns item length when success
id|n_ret_value
op_assign
id|calc_deleted_bytes_number
c_func
(paren
op_amp
id|s_del_balance
comma
id|M_DELETE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p_s_un_bh
)paren
(brace
r_int
id|off
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/* We are in direct2indirect conversion, so move tail contents&n;           to the unformatted node */
multiline_comment|/* note, we do the copy before preparing the buffer because we&n;&t;** don&squot;t care about the contents of the unformatted node yet.&n;&t;** the only thing we really care about is the direct item&squot;s data&n;&t;** is in the unformatted node.&n;&t;**&n;&t;** Otherwise, we would have to call reiserfs_prepare_for_journal on&n;&t;** the unformatted node, which might schedule, meaning we&squot;d have to&n;&t;** loop all the way back up to the start of the while loop.&n;&t;**&n;&t;** The unformatted node must be dirtied later on.  We can&squot;t be&n;&t;** sure here if the entire tail has been deleted yet.&n;        **&n;        ** p_s_un_bh is from the page cache (all unformatted nodes are&n;        ** from the page cache) and might be a highmem page.  So, we&n;        ** can&squot;t use p_s_un_bh-&gt;b_data.&n;&t;** -clm&n;&t;*/
id|data
op_assign
id|kmap_atomic
c_func
(paren
id|p_s_un_bh-&gt;b_page
comma
id|KM_USER0
)paren
suffix:semicolon
id|off
op_assign
(paren
(paren
id|le_ih_k_offset
(paren
op_amp
id|s_ih
)paren
op_minus
l_int|1
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
id|off
comma
id|B_I_PITEM
c_func
(paren
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_path
)paren
comma
op_amp
id|s_ih
)paren
comma
id|n_ret_value
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|data
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
multiline_comment|/* Perform balancing after all resources have been collected at once. */
id|do_balance
c_func
(paren
op_amp
id|s_del_balance
comma
l_int|NULL
comma
l_int|NULL
comma
id|M_DELETE
)paren
suffix:semicolon
multiline_comment|/* Return deleted body length */
r_return
id|n_ret_value
suffix:semicolon
)brace
multiline_comment|/* Summary Of Mechanisms For Handling Collisions Between Processes:&n;&n; deletion of the body of the object is performed by iput(), with the&n; result that if multiple processes are operating on a file, the&n; deletion of the body of the file is deferred until the last process&n; that has an open inode performs its iput().&n;&n; writes and truncates are protected from collisions by use of&n; semaphores.&n;&n; creates, linking, and mknod are protected from collisions with other&n; processes by making the reiserfs_add_entry() the last step in the&n; creation, and then rolling back all changes if there was a collision.&n; - Hans&n;*/
multiline_comment|/* this deletes item which never gets split */
DECL|function|reiserfs_delete_solid_item
r_void
id|reiserfs_delete_solid_item
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|key
op_star
id|key
)paren
(brace
r_struct
id|tree_balance
id|tb
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_int
id|item_len
suffix:semicolon
r_int
id|tb_init
op_assign
l_int|0
suffix:semicolon
r_struct
id|cpu_key
id|cpu_key
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|le_key2cpu_key
(paren
op_amp
id|cpu_key
comma
id|key
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|retval
op_assign
id|search_item
(paren
id|th-&gt;t_super
comma
op_amp
id|cpu_key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-5350: reiserfs_delete_solid_item: &quot;
l_string|&quot;i/o failure occurred trying to delete %K&bslash;n&quot;
comma
op_amp
id|cpu_key
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_ne
id|ITEM_FOUND
)paren
(brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
singleline_comment|// No need for a warning, if there is just no free space to insert &squot;..&squot; item into the newly-created subdir
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
r_int
r_int
r_int
)paren
id|GET_HASH_VALUE
(paren
id|le_key_k_offset
(paren
id|le_key_version
(paren
id|key
)paren
comma
id|key
)paren
)paren
op_eq
l_int|0
op_logical_and
"&bslash;"
(paren
r_int
r_int
r_int
)paren
id|GET_GENERATION_NUMBER
(paren
id|le_key_k_offset
(paren
id|le_key_version
(paren
id|key
)paren
comma
id|key
)paren
)paren
op_eq
l_int|1
)paren
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-5355: reiserfs_delete_solid_item: %k not found&quot;
comma
id|key
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tb_init
)paren
(brace
id|tb_init
op_assign
l_int|1
suffix:semicolon
id|item_len
op_assign
id|ih_item_len
c_func
(paren
id|PATH_PITEM_HEAD
c_func
(paren
op_amp
id|path
)paren
)paren
suffix:semicolon
id|init_tb_struct
(paren
id|th
comma
op_amp
id|tb
comma
id|th-&gt;t_super
comma
op_amp
id|path
comma
op_minus
(paren
id|IH_SIZE
op_plus
id|item_len
)paren
)paren
suffix:semicolon
)brace
id|retval
op_assign
id|fix_nodes
(paren
id|M_DELETE
comma
op_amp
id|tb
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|REPEAT_SEARCH
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|th
op_member_access_from_pointer
id|t_super
comma
id|delete_solid_item_restarted
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|CARRY_ON
)paren
(brace
id|do_balance
(paren
op_amp
id|tb
comma
l_int|0
comma
l_int|0
comma
id|M_DELETE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
singleline_comment|// IO_ERROR, NO_DISK_SPACE, etc
id|reiserfs_warning
(paren
l_string|&quot;vs-5360: reiserfs_delete_solid_item: &quot;
l_string|&quot;could not delete %K due to fix_nodes failure&bslash;n&quot;
comma
op_amp
id|cpu_key
)paren
suffix:semicolon
id|unfix_nodes
(paren
op_amp
id|tb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_delete_object
r_void
id|reiserfs_delete_object
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for directory this deletes item containing &quot;.&quot; and &quot;..&quot; */
id|reiserfs_do_truncate
(paren
id|th
comma
id|inode
comma
l_int|NULL
comma
l_int|0
multiline_comment|/*no timestamp updates*/
)paren
suffix:semicolon
macro_line|#if defined( USE_INODE_GENERATION_COUNTER )
r_if
c_cond
(paren
op_logical_neg
id|old_format_only
(paren
id|th
op_member_access_from_pointer
id|t_super
)paren
)paren
(brace
id|__u32
op_star
id|inode_generation
suffix:semicolon
id|inode_generation
op_assign
op_amp
id|REISERFS_SB
c_func
(paren
id|th
op_member_access_from_pointer
id|t_super
)paren
op_member_access_from_pointer
id|s_rs
op_member_access_from_pointer
id|s_inode_generation
suffix:semicolon
op_star
id|inode_generation
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
op_star
id|inode_generation
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* USE_INODE_GENERATION_COUNTER */
macro_line|#endif
id|reiserfs_delete_solid_item
(paren
id|th
comma
id|INODE_PKEY
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|maybe_indirect_to_direct
r_static
r_int
id|maybe_indirect_to_direct
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|p_s_inode
comma
r_struct
id|page
op_star
id|page
comma
r_struct
id|path
op_star
id|p_s_path
comma
r_const
r_struct
id|cpu_key
op_star
id|p_s_item_key
comma
id|loff_t
id|n_new_file_size
comma
r_char
op_star
id|p_c_mode
)paren
(brace
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|p_s_inode-&gt;i_sb
suffix:semicolon
r_int
id|n_block_size
op_assign
id|p_s_sb-&gt;s_blocksize
suffix:semicolon
r_int
id|cut_bytes
suffix:semicolon
r_if
c_cond
(paren
id|n_new_file_size
op_ne
id|p_s_inode-&gt;i_size
)paren
id|BUG
(paren
)paren
suffix:semicolon
multiline_comment|/* the page being sent in could be NULL if there was an i/o error&n;    ** reading in the last block.  The user will hit problems trying to&n;    ** read the file, but for now we just skip the indirect2direct&n;    */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|p_s_inode-&gt;i_count
)paren
OG
l_int|1
op_logical_or
op_logical_neg
id|tail_has_to_be_packed
(paren
id|p_s_inode
)paren
op_logical_or
op_logical_neg
id|page
op_logical_or
(paren
id|REISERFS_I
c_func
(paren
id|p_s_inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_nopack_mask
)paren
)paren
(brace
singleline_comment|// leave tail in an unformatted node&t;
op_star
id|p_c_mode
op_assign
id|M_SKIP_BALANCING
suffix:semicolon
id|cut_bytes
op_assign
id|n_block_size
op_minus
(paren
id|n_new_file_size
op_amp
(paren
id|n_block_size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
id|p_s_path
)paren
suffix:semicolon
r_return
id|cut_bytes
suffix:semicolon
)brace
multiline_comment|/* Permorm the conversion to a direct_item. */
multiline_comment|/*return indirect_to_direct (p_s_inode, p_s_path, p_s_item_key, n_new_file_size, p_c_mode);*/
r_return
id|indirect2direct
(paren
id|th
comma
id|p_s_inode
comma
id|page
comma
id|p_s_path
comma
id|p_s_item_key
comma
id|n_new_file_size
comma
id|p_c_mode
)paren
suffix:semicolon
)brace
multiline_comment|/* we did indirect_to_direct conversion. And we have inserted direct&n;   item successesfully, but there were no disk space to cut unfm&n;   pointer being converted. Therefore we have to delete inserted&n;   direct item(s) */
DECL|function|indirect_to_direct_roll_back
r_static
r_void
id|indirect_to_direct_roll_back
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_struct
id|cpu_key
id|tail_key
suffix:semicolon
r_int
id|tail_len
suffix:semicolon
r_int
id|removed
suffix:semicolon
id|make_cpu_key
(paren
op_amp
id|tail_key
comma
id|inode
comma
id|inode-&gt;i_size
op_plus
l_int|1
comma
id|TYPE_DIRECT
comma
l_int|4
)paren
suffix:semicolon
singleline_comment|// !!!!
id|tail_key.key_length
op_assign
l_int|4
suffix:semicolon
id|tail_len
op_assign
(paren
id|cpu_key_k_offset
(paren
op_amp
id|tail_key
)paren
op_amp
(paren
id|inode-&gt;i_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|tail_len
)paren
(brace
multiline_comment|/* look for the last byte of the tail */
r_if
c_cond
(paren
id|search_for_position_by_key
(paren
id|inode-&gt;i_sb
comma
op_amp
id|tail_key
comma
id|path
)paren
op_eq
id|POSITION_NOT_FOUND
)paren
id|reiserfs_panic
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-5615: indirect_to_direct_roll_back: found invalid item&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|path-&gt;pos_in_item
op_ne
id|ih_item_len
c_func
(paren
id|PATH_PITEM_HEAD
(paren
id|path
)paren
)paren
op_minus
l_int|1
comma
l_string|&quot;vs-5616: appended bytes found&quot;
)paren
suffix:semicolon
id|PATH_LAST_POSITION
(paren
id|path
)paren
op_decrement
suffix:semicolon
id|removed
op_assign
id|reiserfs_delete_item
(paren
id|th
comma
id|path
comma
op_amp
id|tail_key
comma
id|inode
comma
l_int|0
multiline_comment|/*unbh not needed*/
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|removed
op_le
l_int|0
op_logical_or
id|removed
OG
id|tail_len
comma
l_string|&quot;vs-5617: there was tail %d bytes, removed item length %d bytes&quot;
comma
id|tail_len
comma
id|removed
)paren
suffix:semicolon
id|tail_len
op_sub_assign
id|removed
suffix:semicolon
id|set_cpu_key_k_offset
(paren
op_amp
id|tail_key
comma
id|cpu_key_k_offset
(paren
op_amp
id|tail_key
)paren
op_minus
id|removed
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|//mark_file_without_tail (inode);
id|mark_inode_dirty
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/* (Truncate or cut entry) or delete object item. Returns &lt; 0 on failure */
DECL|function|reiserfs_cut_from_item
r_int
id|reiserfs_cut_from_item
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|path
op_star
id|p_s_path
comma
r_struct
id|cpu_key
op_star
id|p_s_item_key
comma
r_struct
id|inode
op_star
id|p_s_inode
comma
r_struct
id|page
op_star
id|page
comma
id|loff_t
id|n_new_file_size
)paren
(brace
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|p_s_inode-&gt;i_sb
suffix:semicolon
multiline_comment|/* Every function which is going to call do_balance must first&n;       create a tree_balance structure.  Then it must fill up this&n;       structure by using the init_tb_struct and fix_nodes functions.&n;       After that we can make tree balancing. */
r_struct
id|tree_balance
id|s_cut_balance
suffix:semicolon
r_int
id|n_cut_size
op_assign
l_int|0
comma
multiline_comment|/* Amount to be cut. */
id|n_ret_value
op_assign
id|CARRY_ON
comma
id|n_removed
op_assign
l_int|0
comma
multiline_comment|/* Number of the removed unformatted nodes. */
id|n_is_inode_locked
op_assign
l_int|0
suffix:semicolon
r_char
id|c_mode
suffix:semicolon
multiline_comment|/* Mode of the balance. */
r_int
id|retval2
op_assign
op_minus
l_int|1
suffix:semicolon
id|init_tb_struct
c_func
(paren
id|th
comma
op_amp
id|s_cut_balance
comma
id|p_s_inode-&gt;i_sb
comma
id|p_s_path
comma
id|n_cut_size
)paren
suffix:semicolon
multiline_comment|/* Repeat this loop until we either cut the item without needing&n;       to balance, or we fix_nodes without schedule occurring */
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Determine the balance mode, position of the first byte to&n;&t;   be cut, and size to be cut.  In case of the indirect item&n;&t;   free unformatted nodes which are pointed to by the cut&n;&t;   pointers. */
id|c_mode
op_assign
id|prepare_for_delete_or_cut
c_func
(paren
id|th
comma
id|p_s_inode
comma
id|p_s_path
comma
id|p_s_item_key
comma
op_amp
id|n_removed
comma
op_amp
id|n_cut_size
comma
id|n_new_file_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_mode
op_eq
id|M_CONVERT
)paren
(brace
multiline_comment|/* convert last unformatted node to direct item or leave&n;               tail in the unformatted node */
id|RFALSE
c_func
(paren
id|n_ret_value
op_ne
id|CARRY_ON
comma
l_string|&quot;PAP-5570: can not convert twice&quot;
)paren
suffix:semicolon
id|n_ret_value
op_assign
id|maybe_indirect_to_direct
(paren
id|th
comma
id|p_s_inode
comma
id|page
comma
id|p_s_path
comma
id|p_s_item_key
comma
id|n_new_file_size
comma
op_amp
id|c_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_mode
op_eq
id|M_SKIP_BALANCING
)paren
multiline_comment|/* tail has been left in the unformatted node */
r_return
id|n_ret_value
suffix:semicolon
id|n_is_inode_locked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* removing of last unformatted node will change value we&n;               have to return to truncate. Save it */
id|retval2
op_assign
id|n_ret_value
suffix:semicolon
multiline_comment|/*retval2 = p_s_sb-&gt;s_blocksize - (n_new_file_size &amp; (p_s_sb-&gt;s_blocksize - 1));*/
multiline_comment|/* So, we have performed the first part of the conversion:&n;&t;       inserting the new direct item.  Now we are removing the&n;&t;       last unformatted node pointer. Set key to search for&n;&t;       it. */
id|set_cpu_key_k_type
(paren
id|p_s_item_key
comma
id|TYPE_INDIRECT
)paren
suffix:semicolon
id|p_s_item_key-&gt;key_length
op_assign
l_int|4
suffix:semicolon
id|n_new_file_size
op_sub_assign
(paren
id|n_new_file_size
op_amp
(paren
id|p_s_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|set_cpu_key_k_offset
(paren
id|p_s_item_key
comma
id|n_new_file_size
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_for_position_by_key
c_func
(paren
id|p_s_sb
comma
id|p_s_item_key
comma
id|p_s_path
)paren
op_eq
id|POSITION_NOT_FOUND
)paren
(brace
id|print_block
(paren
id|PATH_PLAST_BUFFER
(paren
id|p_s_path
)paren
comma
l_int|3
comma
id|PATH_LAST_POSITION
(paren
id|p_s_path
)paren
op_minus
l_int|1
comma
id|PATH_LAST_POSITION
(paren
id|p_s_path
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;PAP-5580: reiserfs_cut_from_item: item to convert does not exist (%K)&quot;
comma
id|p_s_item_key
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_cut_size
op_eq
l_int|0
)paren
(brace
id|pathrelse
(paren
id|p_s_path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|s_cut_balance.insert_size
(braket
l_int|0
)braket
op_assign
id|n_cut_size
suffix:semicolon
id|n_ret_value
op_assign
id|fix_nodes
c_func
(paren
id|c_mode
comma
op_amp
id|s_cut_balance
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_ret_value
op_ne
id|REPEAT_SEARCH
)paren
r_break
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|cut_from_item_restarted
)paren
suffix:semicolon
id|n_ret_value
op_assign
id|search_for_position_by_key
c_func
(paren
id|p_s_sb
comma
id|p_s_item_key
comma
id|p_s_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_ret_value
op_eq
id|POSITION_FOUND
)paren
r_continue
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;PAP-5610: reiserfs_cut_from_item: item %K not found&bslash;n&quot;
comma
id|p_s_item_key
)paren
suffix:semicolon
id|unfix_nodes
(paren
op_amp
id|s_cut_balance
)paren
suffix:semicolon
r_return
(paren
id|n_ret_value
op_eq
id|IO_ERROR
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/* while */
singleline_comment|// check fix_nodes results (IO_ERROR or NO_DISK_SPACE)
r_if
c_cond
(paren
id|n_ret_value
op_ne
id|CARRY_ON
)paren
(brace
r_if
c_cond
(paren
id|n_is_inode_locked
)paren
(brace
singleline_comment|// FIXME: this seems to be not needed: we are always able
singleline_comment|// to cut item
id|indirect_to_direct_roll_back
(paren
id|th
comma
id|p_s_inode
comma
id|p_s_path
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_ret_value
op_eq
id|NO_DISK_SPACE
)paren
id|reiserfs_warning
(paren
l_string|&quot;NO_DISK_SPACE&quot;
)paren
suffix:semicolon
id|unfix_nodes
(paren
op_amp
id|s_cut_balance
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* go ahead and perform balancing */
id|RFALSE
c_func
(paren
id|c_mode
op_eq
id|M_PASTE
op_logical_or
id|c_mode
op_eq
id|M_INSERT
comma
l_string|&quot;invalid mode&quot;
)paren
suffix:semicolon
multiline_comment|/* Calculate number of bytes that need to be cut from the item. */
r_if
c_cond
(paren
id|retval2
op_eq
op_minus
l_int|1
)paren
id|n_ret_value
op_assign
id|calc_deleted_bytes_number
c_func
(paren
op_amp
id|s_cut_balance
comma
id|c_mode
)paren
suffix:semicolon
r_else
id|n_ret_value
op_assign
id|retval2
suffix:semicolon
r_if
c_cond
(paren
id|c_mode
op_eq
id|M_DELETE
)paren
(brace
r_struct
id|item_head
op_star
id|p_le_ih
op_assign
id|PATH_PITEM_HEAD
(paren
id|s_cut_balance.tb_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|p_le_ih
)paren
op_logical_and
(paren
id|le_ih_k_offset
(paren
id|p_le_ih
)paren
op_amp
(paren
id|p_s_sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* we delete first part of tail which was stored in direct&n;               item(s) */
singleline_comment|// FIXME: this is to keep 3.5 happy
id|REISERFS_I
c_func
(paren
id|p_s_inode
)paren
op_member_access_from_pointer
id|i_first_direct_byte
op_assign
id|U32_MAX
suffix:semicolon
id|p_s_inode-&gt;i_blocks
op_sub_assign
id|p_s_sb-&gt;s_blocksize
op_div
l_int|512
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|n_is_inode_locked
)paren
(brace
r_struct
id|item_head
op_star
id|le_ih
op_assign
id|PATH_PITEM_HEAD
(paren
id|s_cut_balance.tb_path
)paren
suffix:semicolon
multiline_comment|/* we are going to complete indirect2direct conversion. Make&n;           sure, that we exactly remove last unformatted node pointer&n;           of the item */
r_if
c_cond
(paren
op_logical_neg
id|is_indirect_le_ih
(paren
id|le_ih
)paren
)paren
id|reiserfs_panic
(paren
id|p_s_sb
comma
l_string|&quot;vs-5652: reiserfs_cut_from_item: &quot;
l_string|&quot;item must be indirect %h&quot;
comma
id|le_ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_mode
op_eq
id|M_DELETE
op_logical_and
id|ih_item_len
c_func
(paren
id|le_ih
)paren
op_ne
id|UNFM_P_SIZE
)paren
id|reiserfs_panic
(paren
id|p_s_sb
comma
l_string|&quot;vs-5653: reiserfs_cut_from_item: &quot;
l_string|&quot;completing indirect2direct conversion indirect item %h &quot;
l_string|&quot;being deleted must be of 4 byte long&quot;
comma
id|le_ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_mode
op_eq
id|M_CUT
op_logical_and
id|s_cut_balance.insert_size
(braket
l_int|0
)braket
op_ne
op_minus
id|UNFM_P_SIZE
)paren
(brace
id|reiserfs_panic
(paren
id|p_s_sb
comma
l_string|&quot;vs-5654: reiserfs_cut_from_item: &quot;
l_string|&quot;can not complete indirect2direct conversion of %h (CUT, insert_size==%d)&quot;
comma
id|le_ih
comma
id|s_cut_balance.insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* it would be useful to make sure, that right neighboring&n;           item is direct item of this file */
)brace
macro_line|#endif
id|do_balance
c_func
(paren
op_amp
id|s_cut_balance
comma
l_int|NULL
comma
l_int|NULL
comma
id|c_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_is_inode_locked
)paren
(brace
multiline_comment|/* we&squot;ve done an indirect-&gt;direct conversion.  when the data block&n;&t;** was freed, it was removed from the list of blocks that must&n;&t;** be flushed before the transaction commits, so we don&squot;t need to&n;&t;** deal with it here.&n;&t;*/
id|REISERFS_I
c_func
(paren
id|p_s_inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_pack_on_close_mask
suffix:semicolon
)brace
r_return
id|n_ret_value
suffix:semicolon
)brace
DECL|function|truncate_directory
r_static
r_void
id|truncate_directory
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_nlink
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-5655: truncate_directory: link count != 0&bslash;n&quot;
)paren
suffix:semicolon
id|set_le_key_k_offset
(paren
id|KEY_FORMAT_3_5
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|DOT_OFFSET
)paren
suffix:semicolon
id|set_le_key_k_type
(paren
id|KEY_FORMAT_3_5
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|TYPE_DIRENTRY
)paren
suffix:semicolon
id|reiserfs_delete_solid_item
(paren
id|th
comma
id|INODE_PKEY
(paren
id|inode
)paren
)paren
suffix:semicolon
id|set_le_key_k_offset
(paren
id|KEY_FORMAT_3_5
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|SD_OFFSET
)paren
suffix:semicolon
id|set_le_key_k_type
(paren
id|KEY_FORMAT_3_5
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|TYPE_STAT_DATA
)paren
suffix:semicolon
)brace
multiline_comment|/* Truncate file to the new size. Note, this must be called with a transaction&n;   already started */
DECL|function|reiserfs_do_truncate
r_void
id|reiserfs_do_truncate
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|p_s_inode
comma
multiline_comment|/* -&gt;i_size contains new&n;                                                         size */
r_struct
id|page
op_star
id|page
comma
multiline_comment|/* up to date for last block */
r_int
id|update_timestamps
multiline_comment|/* when it is called by&n;&t;&t;&t;&t;&t;&t;     file_release to convert&n;&t;&t;&t;&t;&t;&t;     the tail - no timestamps&n;&t;&t;&t;&t;&t;&t;     should be updated */
)paren
(brace
id|INITIALIZE_PATH
(paren
id|s_search_path
)paren
suffix:semicolon
multiline_comment|/* Path to the current object item. */
r_struct
id|item_head
op_star
id|p_le_ih
suffix:semicolon
multiline_comment|/* Pointer to an item header. */
r_struct
id|cpu_key
id|s_item_key
suffix:semicolon
multiline_comment|/* Key to search for a previous file item. */
id|loff_t
id|n_file_size
comma
multiline_comment|/* Old file size. */
id|n_new_file_size
suffix:semicolon
multiline_comment|/* New file size. */
r_int
id|n_deleted
suffix:semicolon
multiline_comment|/* Number of deleted or truncated bytes. */
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|S_ISREG
c_func
(paren
id|p_s_inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|p_s_inode-&gt;i_mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|p_s_inode-&gt;i_mode
)paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|p_s_inode-&gt;i_mode
)paren
)paren
(brace
singleline_comment|// deletion of directory - no need to update timestamps
id|truncate_directory
(paren
id|th
comma
id|p_s_inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Get new file size. */
id|n_new_file_size
op_assign
id|p_s_inode-&gt;i_size
suffix:semicolon
singleline_comment|// FIXME: note, that key type is unimportant here
id|make_cpu_key
(paren
op_amp
id|s_item_key
comma
id|p_s_inode
comma
id|max_reiserfs_offset
(paren
id|p_s_inode
)paren
comma
id|TYPE_DIRECT
comma
l_int|3
)paren
suffix:semicolon
id|retval
op_assign
id|search_for_position_by_key
c_func
(paren
id|p_s_inode-&gt;i_sb
comma
op_amp
id|s_item_key
comma
op_amp
id|s_search_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-5657: reiserfs_do_truncate: &quot;
l_string|&quot;i/o failure occurred trying to truncate %K&bslash;n&quot;
comma
op_amp
id|s_item_key
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|POSITION_FOUND
op_logical_or
id|retval
op_eq
id|FILE_NOT_FOUND
)paren
(brace
id|pathrelse
(paren
op_amp
id|s_search_path
)paren
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;PAP-5660: reiserfs_do_truncate: &quot;
l_string|&quot;wrong result %d of search for %K&bslash;n&quot;
comma
id|retval
comma
op_amp
id|s_item_key
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|s_search_path.pos_in_item
op_decrement
suffix:semicolon
multiline_comment|/* Get real file size (total length of all file items) */
id|p_le_ih
op_assign
id|PATH_PITEM_HEAD
c_func
(paren
op_amp
id|s_search_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_statdata_le_ih
(paren
id|p_le_ih
)paren
)paren
id|n_file_size
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|loff_t
id|offset
op_assign
id|le_ih_k_offset
(paren
id|p_le_ih
)paren
suffix:semicolon
r_int
id|bytes
op_assign
id|op_bytes_number
(paren
id|p_le_ih
comma
id|p_s_inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
multiline_comment|/* this may mismatch with real file size: if last direct item&n;           had no padding zeros and last unformatted node had no free&n;           space, this file would have this file size */
id|n_file_size
op_assign
id|offset
op_plus
id|bytes
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_file_size
op_eq
l_int|0
op_logical_or
id|n_file_size
OL
id|n_new_file_size
)paren
(brace
r_goto
id|update_and_out
suffix:semicolon
)brace
multiline_comment|/* Update key to search for the last file item. */
id|set_cpu_key_k_offset
(paren
op_amp
id|s_item_key
comma
id|n_file_size
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Cut or delete file item. */
id|n_deleted
op_assign
id|reiserfs_cut_from_item
c_func
(paren
id|th
comma
op_amp
id|s_search_path
comma
op_amp
id|s_item_key
comma
id|p_s_inode
comma
id|page
comma
id|n_new_file_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_deleted
OL
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed&quot;
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|s_search_path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|n_deleted
OG
id|n_file_size
comma
l_string|&quot;PAP-5670: reiserfs_cut_from_item: too many bytes deleted: deleted %d, file_size %lu, item_key %K&quot;
comma
id|n_deleted
comma
id|n_file_size
comma
op_amp
id|s_item_key
)paren
suffix:semicolon
multiline_comment|/* Change key to search the last file item. */
id|n_file_size
op_sub_assign
id|n_deleted
suffix:semicolon
id|set_cpu_key_k_offset
(paren
op_amp
id|s_item_key
comma
id|n_file_size
)paren
suffix:semicolon
multiline_comment|/* While there are bytes to truncate and previous file item is presented in the tree. */
multiline_comment|/*&n;&t;** This loop could take a really long time, and could log &n;&t;** many more blocks than a transaction can hold.  So, we do a polite&n;&t;** journal end here, and if the transaction needs ending, we make&n;&t;** sure the file is consistent before ending the current trans&n;&t;** and starting a new one&n;&t;*/
r_if
c_cond
(paren
id|journal_transaction_should_end
c_func
(paren
id|th
comma
id|th-&gt;t_blocks_allocated
)paren
)paren
(brace
r_int
id|orig_len_alloc
op_assign
id|th-&gt;t_blocks_allocated
suffix:semicolon
id|decrement_counters_in_path
c_func
(paren
op_amp
id|s_search_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|update_timestamps
)paren
(brace
id|p_s_inode-&gt;i_mtime
op_assign
id|p_s_inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
id|reiserfs_update_sd
c_func
(paren
id|th
comma
id|p_s_inode
)paren
suffix:semicolon
id|journal_end
c_func
(paren
id|th
comma
id|p_s_inode-&gt;i_sb
comma
id|orig_len_alloc
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
id|th
comma
id|p_s_inode-&gt;i_sb
comma
id|orig_len_alloc
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|p_s_inode
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|n_file_size
OG
id|ROUND_UP
(paren
id|n_new_file_size
)paren
op_logical_and
id|search_for_position_by_key
c_func
(paren
id|p_s_inode-&gt;i_sb
comma
op_amp
id|s_item_key
comma
op_amp
id|s_search_path
)paren
op_eq
id|POSITION_FOUND
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_file_size
OG
id|ROUND_UP
(paren
id|n_new_file_size
)paren
comma
l_string|&quot;PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d&bslash;n&quot;
comma
id|n_new_file_size
comma
id|n_file_size
comma
id|s_item_key.on_disk_key.k_objectid
)paren
suffix:semicolon
id|update_and_out
suffix:colon
r_if
c_cond
(paren
id|update_timestamps
)paren
(brace
singleline_comment|// this is truncate, not file closing
id|p_s_inode-&gt;i_mtime
op_assign
id|p_s_inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
id|reiserfs_update_sd
(paren
id|th
comma
id|p_s_inode
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
op_amp
id|s_search_path
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
singleline_comment|// this makes sure, that we __append__, not overwrite or add holes
DECL|function|check_research_for_paste
r_static
r_void
id|check_research_for_paste
(paren
r_struct
id|path
op_star
id|path
comma
r_const
r_struct
id|cpu_key
op_star
id|p_s_key
)paren
(brace
r_struct
id|item_head
op_star
id|found_ih
op_assign
id|get_ih
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|found_ih
)paren
)paren
(brace
r_if
c_cond
(paren
id|le_ih_k_offset
(paren
id|found_ih
)paren
op_plus
id|op_bytes_number
(paren
id|found_ih
comma
id|get_last_bh
(paren
id|path
)paren
op_member_access_from_pointer
id|b_size
)paren
op_ne
id|cpu_key_k_offset
(paren
id|p_s_key
)paren
op_logical_or
id|op_bytes_number
(paren
id|found_ih
comma
id|get_last_bh
(paren
id|path
)paren
op_member_access_from_pointer
id|b_size
)paren
op_ne
id|pos_in_item
(paren
id|path
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;PAP-5720: check_research_for_paste: &quot;
l_string|&quot;found direct item %h or position (%d) does not match to key %K&quot;
comma
id|found_ih
comma
id|pos_in_item
(paren
id|path
)paren
comma
id|p_s_key
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|found_ih
)paren
)paren
(brace
r_if
c_cond
(paren
id|le_ih_k_offset
(paren
id|found_ih
)paren
op_plus
id|op_bytes_number
(paren
id|found_ih
comma
id|get_last_bh
(paren
id|path
)paren
op_member_access_from_pointer
id|b_size
)paren
op_ne
id|cpu_key_k_offset
(paren
id|p_s_key
)paren
op_logical_or
id|I_UNFM_NUM
(paren
id|found_ih
)paren
op_ne
id|pos_in_item
(paren
id|path
)paren
op_logical_or
id|get_ih_free_space
(paren
id|found_ih
)paren
op_ne
l_int|0
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;PAP-5730: check_research_for_paste: &quot;
l_string|&quot;found indirect item (%h) or position (%d) does not match to key (%K)&quot;
comma
id|found_ih
comma
id|pos_in_item
(paren
id|path
)paren
comma
id|p_s_key
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* config reiserfs check */
multiline_comment|/* Paste bytes to the existing item. Returns bytes number pasted into the item. */
DECL|function|reiserfs_paste_into_item
r_int
id|reiserfs_paste_into_item
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|path
op_star
id|p_s_search_path
comma
multiline_comment|/* Path to the pasted item.          */
r_const
r_struct
id|cpu_key
op_star
id|p_s_key
comma
multiline_comment|/* Key to search for the needed item.*/
r_const
r_char
op_star
id|p_c_body
comma
multiline_comment|/* Pointer to the bytes to paste.    */
r_int
id|n_pasted_size
)paren
multiline_comment|/* Size of pasted bytes.             */
(brace
r_struct
id|tree_balance
id|s_paste_balance
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|init_tb_struct
c_func
(paren
id|th
comma
op_amp
id|s_paste_balance
comma
id|th-&gt;t_super
comma
id|p_s_search_path
comma
id|n_pasted_size
)paren
suffix:semicolon
macro_line|#ifdef DISPLACE_NEW_PACKING_LOCALITIES
id|s_paste_balance.key
op_assign
id|p_s_key-&gt;on_disk_key
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|retval
op_assign
id|fix_nodes
c_func
(paren
id|M_PASTE
comma
op_amp
id|s_paste_balance
comma
l_int|NULL
comma
id|p_c_body
)paren
)paren
op_eq
id|REPEAT_SEARCH
)paren
(brace
multiline_comment|/* file system changed while we were in the fix_nodes */
id|PROC_INFO_INC
c_func
(paren
id|th
op_member_access_from_pointer
id|t_super
comma
id|paste_into_item_restarted
)paren
suffix:semicolon
id|retval
op_assign
id|search_for_position_by_key
(paren
id|th-&gt;t_super
comma
id|p_s_key
comma
id|p_s_search_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|POSITION_FOUND
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists&bslash;n&quot;
comma
id|p_s_key
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|check_research_for_paste
(paren
id|p_s_search_path
comma
id|p_s_key
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Perform balancing after all resources are collected by fix_nodes, and&n;       accessing them will not risk triggering schedule. */
r_if
c_cond
(paren
id|retval
op_eq
id|CARRY_ON
)paren
(brace
id|do_balance
c_func
(paren
op_amp
id|s_paste_balance
comma
l_int|NULL
multiline_comment|/*ih*/
comma
id|p_c_body
comma
id|M_PASTE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
(paren
id|retval
op_eq
id|NO_DISK_SPACE
)paren
ques
c_cond
op_minus
id|ENOSPC
suffix:colon
op_minus
id|EIO
suffix:semicolon
id|error_out
suffix:colon
multiline_comment|/* this also releases the path */
id|unfix_nodes
c_func
(paren
op_amp
id|s_paste_balance
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Insert new item into the buffer at the path. */
DECL|function|reiserfs_insert_item
r_int
id|reiserfs_insert_item
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|path
op_star
id|p_s_path
comma
multiline_comment|/* Path to the inserteded item.         */
r_const
r_struct
id|cpu_key
op_star
id|key
comma
r_struct
id|item_head
op_star
id|p_s_ih
comma
multiline_comment|/* Pointer to the item header to insert.*/
r_const
r_char
op_star
id|p_c_body
)paren
multiline_comment|/* Pointer to the bytes to insert.      */
(brace
r_struct
id|tree_balance
id|s_ins_balance
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|init_tb_struct
c_func
(paren
id|th
comma
op_amp
id|s_ins_balance
comma
id|th-&gt;t_super
comma
id|p_s_path
comma
id|IH_SIZE
op_plus
id|ih_item_len
c_func
(paren
id|p_s_ih
)paren
)paren
suffix:semicolon
macro_line|#ifdef DISPLACE_NEW_PACKING_LOCALITIES
id|s_ins_balance.key
op_assign
id|key-&gt;on_disk_key
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;    if (p_c_body == 0)&n;      n_zeros_num = ih_item_len(p_s_ih);&n;    */
singleline_comment|//    le_key2cpu_key (&amp;key, &amp;(p_s_ih-&gt;ih_key));
r_while
c_loop
(paren
(paren
id|retval
op_assign
id|fix_nodes
c_func
(paren
id|M_INSERT
comma
op_amp
id|s_ins_balance
comma
id|p_s_ih
comma
id|p_c_body
)paren
)paren
op_eq
id|REPEAT_SEARCH
)paren
(brace
multiline_comment|/* file system changed while we were in the fix_nodes */
id|PROC_INFO_INC
c_func
(paren
id|th
op_member_access_from_pointer
id|t_super
comma
id|insert_item_restarted
)paren
suffix:semicolon
id|retval
op_assign
id|search_item
(paren
id|th-&gt;t_super
comma
id|key
comma
id|p_s_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|ITEM_FOUND
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;PAP-5760: reiserfs_insert_item: &quot;
l_string|&quot;key %K already exists in the tree&bslash;n&quot;
comma
id|key
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
)brace
multiline_comment|/* make balancing after all resources will be collected at a time */
r_if
c_cond
(paren
id|retval
op_eq
id|CARRY_ON
)paren
(brace
id|do_balance
(paren
op_amp
id|s_ins_balance
comma
id|p_s_ih
comma
id|p_c_body
comma
id|M_INSERT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
(paren
id|retval
op_eq
id|NO_DISK_SPACE
)paren
ques
c_cond
op_minus
id|ENOSPC
suffix:colon
op_minus
id|EIO
suffix:semicolon
id|error_out
suffix:colon
multiline_comment|/* also releases the path */
id|unfix_nodes
c_func
(paren
op_amp
id|s_ins_balance
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
eof
