multiline_comment|/*&n; * Keyed 32-bit hash function using TEA in a Davis-Meyer function&n; *   H0 = Key&n; *   Hi = E Mi(Hi-1) + Hi-1&n; *&n; * (see Applied Cryptography, 2nd edition, p448).&n; *&n; * Jeremy Fitzhardinge &lt;jeremy@zip.com.au&gt; 1998&n; * &n; * Jeremy has agreed to the contents of reiserfs/README. -Hans&n; * Yura&squot;s function is added (04/07/2000)&n; */
singleline_comment|//
singleline_comment|// keyed_hash
singleline_comment|// yura_hash
singleline_comment|// r5_hash
singleline_comment|//
macro_line|#include &lt;asm/types.h&gt;
DECL|macro|DELTA
mdefine_line|#define DELTA 0x9E3779B9
DECL|macro|FULLROUNDS
mdefine_line|#define FULLROUNDS 10&t;&t;/* 32 is overkill, 16 is strong crypto */
DECL|macro|PARTROUNDS
mdefine_line|#define PARTROUNDS 6&t;&t;/* 6 gets complete mixing */
multiline_comment|/* a, b, c, d - data; h0, h1 - accumulated hash */
DECL|macro|TEACORE
mdefine_line|#define TEACORE(rounds)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;u32 sum = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;int n = rounds;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;u32 b0, b1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;b0 = h0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;b1 = h1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;do&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;sum += DELTA;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;b0 += ((b1 &lt;&lt; 4)+a) ^ (b1+sum) ^ ((b1 &gt;&gt; 5)+b);&t;&bslash;&n;&t;&t;&t;b1 += ((b0 &lt;&lt; 4)+c) ^ (b0+sum) ^ ((b0 &gt;&gt; 5)+d);&t;&bslash;&n;&t;&t;} while(--n);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;h0 += b0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;h1 += b1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while(0)
DECL|function|keyed_hash
id|u32
id|keyed_hash
c_func
(paren
r_const
r_int
r_char
op_star
id|msg
comma
r_int
id|len
)paren
(brace
id|u32
id|k
(braket
)braket
op_assign
(brace
l_int|0x9464a485
comma
l_int|0x542e1a94
comma
l_int|0x3e846bff
comma
l_int|0xb75bcfc3
)brace
suffix:semicolon
id|u32
id|h0
op_assign
id|k
(braket
l_int|0
)braket
comma
id|h1
op_assign
id|k
(braket
l_int|1
)braket
suffix:semicolon
id|u32
id|a
comma
id|b
comma
id|c
comma
id|d
suffix:semicolon
id|u32
id|pad
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|//&t;assert(len &gt;= 0 &amp;&amp; len &lt; 256);
id|pad
op_assign
(paren
id|u32
)paren
id|len
op_or
(paren
(paren
id|u32
)paren
id|len
op_lshift
l_int|8
)paren
suffix:semicolon
id|pad
op_or_assign
id|pad
op_lshift
l_int|16
suffix:semicolon
r_while
c_loop
(paren
id|len
op_ge
l_int|16
)paren
(brace
id|a
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|0
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|2
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|3
)braket
op_lshift
l_int|24
suffix:semicolon
id|b
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|4
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|5
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|6
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|7
)braket
op_lshift
l_int|24
suffix:semicolon
id|c
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|8
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|9
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|10
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|11
)braket
op_lshift
l_int|24
suffix:semicolon
id|d
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|12
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|13
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|14
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|15
)braket
op_lshift
l_int|24
suffix:semicolon
id|TEACORE
c_func
(paren
id|PARTROUNDS
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|16
suffix:semicolon
id|msg
op_add_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_ge
l_int|12
)paren
(brace
singleline_comment|//assert(len &lt; 16);
r_if
c_cond
(paren
id|len
op_ge
l_int|16
)paren
op_star
(paren
r_int
op_star
)paren
l_int|0
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|0
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|2
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|3
)braket
op_lshift
l_int|24
suffix:semicolon
id|b
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|4
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|5
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|6
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|7
)braket
op_lshift
l_int|24
suffix:semicolon
id|c
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|8
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|9
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|10
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|11
)braket
op_lshift
l_int|24
suffix:semicolon
id|d
op_assign
id|pad
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|12
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d
op_lshift_assign
l_int|8
suffix:semicolon
id|d
op_or_assign
id|msg
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|len
op_ge
l_int|8
)paren
(brace
singleline_comment|//assert(len &lt; 12);
r_if
c_cond
(paren
id|len
op_ge
l_int|12
)paren
op_star
(paren
r_int
op_star
)paren
l_int|0
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|0
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|2
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|3
)braket
op_lshift
l_int|24
suffix:semicolon
id|b
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|4
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|5
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|6
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|7
)braket
op_lshift
l_int|24
suffix:semicolon
id|c
op_assign
id|d
op_assign
id|pad
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_lshift_assign
l_int|8
suffix:semicolon
id|c
op_or_assign
id|msg
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|len
op_ge
l_int|4
)paren
(brace
singleline_comment|//assert(len &lt; 8);
r_if
c_cond
(paren
id|len
op_ge
l_int|8
)paren
op_star
(paren
r_int
op_star
)paren
l_int|0
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
(paren
id|u32
)paren
id|msg
(braket
l_int|0
)braket
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|2
)braket
op_lshift
l_int|16
op_or
(paren
id|u32
)paren
id|msg
(braket
l_int|3
)braket
op_lshift
l_int|24
suffix:semicolon
id|b
op_assign
id|c
op_assign
id|d
op_assign
id|pad
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
op_lshift_assign
l_int|8
suffix:semicolon
id|b
op_or_assign
id|msg
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|//assert(len &lt; 4);
r_if
c_cond
(paren
id|len
op_ge
l_int|4
)paren
op_star
(paren
r_int
op_star
)paren
l_int|0
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
id|b
op_assign
id|c
op_assign
id|d
op_assign
id|pad
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|a
op_lshift_assign
l_int|8
suffix:semicolon
id|a
op_or_assign
id|msg
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|TEACORE
c_func
(paren
id|FULLROUNDS
)paren
suffix:semicolon
multiline_comment|/*&t;return 0;*/
r_return
id|h0
op_xor
id|h1
suffix:semicolon
)brace
multiline_comment|/* What follows in this file is copyright 2000 by Hans Reiser, and the&n; * licensing of what follows is governed by reiserfs/README */
DECL|function|yura_hash
id|u32
id|yura_hash
(paren
r_const
r_int
r_char
op_star
id|msg
comma
r_int
id|len
)paren
(brace
r_int
id|j
comma
id|pow
suffix:semicolon
id|u32
id|a
comma
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|pow
op_assign
l_int|1
comma
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|pow
op_assign
id|pow
op_star
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|1
)paren
id|a
op_assign
id|msg
(braket
l_int|0
)braket
op_minus
l_int|48
suffix:semicolon
r_else
id|a
op_assign
(paren
id|msg
(braket
l_int|0
)braket
op_minus
l_int|48
)paren
op_star
id|pow
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|msg
(braket
id|i
)braket
op_minus
l_int|48
suffix:semicolon
r_for
c_loop
(paren
id|pow
op_assign
l_int|1
comma
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|j
op_increment
)paren
id|pow
op_assign
id|pow
op_star
l_int|10
suffix:semicolon
id|a
op_assign
id|a
op_plus
id|c
op_star
id|pow
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|40
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
l_char|&squot;0&squot;
op_minus
l_int|48
suffix:semicolon
r_for
c_loop
(paren
id|pow
op_assign
l_int|1
comma
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|j
op_increment
)paren
id|pow
op_assign
id|pow
op_star
l_int|10
suffix:semicolon
id|a
op_assign
id|a
op_plus
id|c
op_star
id|pow
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|pow
op_assign
l_int|1
comma
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|j
op_increment
)paren
id|pow
op_assign
id|pow
op_star
l_int|10
suffix:semicolon
id|a
op_assign
id|a
op_plus
id|c
op_star
id|pow
suffix:semicolon
)brace
id|a
op_assign
id|a
op_lshift
l_int|7
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
DECL|function|r5_hash
id|u32
id|r5_hash
(paren
r_const
r_int
r_char
op_star
id|msg
comma
r_int
id|len
)paren
(brace
id|u32
id|a
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|msg
)paren
(brace
id|a
op_add_assign
op_star
id|msg
op_lshift
l_int|4
suffix:semicolon
id|a
op_add_assign
op_star
id|msg
op_rshift
l_int|4
suffix:semicolon
id|a
op_mul_assign
l_int|11
suffix:semicolon
id|msg
op_increment
suffix:semicolon
)brace
r_return
id|a
suffix:semicolon
)brace
eof
