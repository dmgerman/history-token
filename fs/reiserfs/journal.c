multiline_comment|/*&n;** Write ahead logging implementation copyright Chris Mason 2000&n;**&n;** The background commits make this code very interelated, and &n;** overly complex.  I need to rethink things a bit....The major players:&n;**&n;** journal_begin -- call with the number of blocks you expect to log.  &n;**                  If the current transaction is too&n;** &t;&t;    old, it will block until the current transaction is &n;** &t;&t;    finished, and then start a new one.&n;**&t;&t;    Usually, your transaction will get joined in with &n;**                  previous ones for speed.&n;**&n;** journal_join  -- same as journal_begin, but won&squot;t block on the current &n;**                  transaction regardless of age.  Don&squot;t ever call&n;**                  this.  Ever.  There are only two places it should be &n;**                  called from, and they are both inside this file.&n;**&n;** journal_mark_dirty -- adds blocks into this transaction.  clears any flags &n;**                       that might make them get sent to disk&n;**                       and then marks them BH_JDirty.  Puts the buffer head &n;**                       into the current transaction hash.  &n;**&n;** journal_end -- if the current transaction is batchable, it does nothing&n;**                   otherwise, it could do an async/synchronous commit, or&n;**                   a full flush of all log and real blocks in the &n;**                   transaction.&n;**&n;** flush_old_commits -- if the current transaction is too old, it is ended and &n;**                      commit blocks are sent to disk.  Forces commit blocks &n;**                      to disk for all backgrounded commits that have been &n;**                      around too long.&n;**&t;&t;     -- Note, if you call this as an immediate flush from &n;**&t;&t;        from within kupdate, it will ignore the immediate flag&n;**&n;** The commit thread -- a writer process for async commits.  It allows a &n;**                      a process to request a log flush on a task queue.&n;**                      the commit will happen once the commit thread wakes up.&n;**                      The benefit here is the writer (with whatever&n;**                      related locks it has) doesn&squot;t have to wait for the&n;**                      log blocks to hit disk if it doesn&squot;t want to.&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/suspend.h&gt; 
macro_line|#include &lt;linux/buffer_head.h&gt;
multiline_comment|/* the number of mounted filesystems.  This is used to decide when to&n;** start and kill the commit thread&n;*/
DECL|variable|reiserfs_mounted_fs_count
r_static
r_int
id|reiserfs_mounted_fs_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wake this up when you add something to the commit thread task queue */
DECL|variable|reiserfs_commit_thread_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|reiserfs_commit_thread_wait
)paren
suffix:semicolon
multiline_comment|/* wait on this if you need to be sure you task queue entries have been run */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
DECL|variable|reiserfs_commit_thread_tq
id|DECLARE_TASK_QUEUE
c_func
(paren
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
DECL|macro|JOURNAL_TRANS_HALF
mdefine_line|#define JOURNAL_TRANS_HALF 1018   /* must be correct to keep the desc and commit&n;&t;&t;&t;&t;     structs at 4k */
DECL|macro|BUFNR
mdefine_line|#define BUFNR 64 /*read ahead */
multiline_comment|/* cnode stat bits.  Move these into reiserfs_fs.h */
DECL|macro|BLOCK_FREED
mdefine_line|#define BLOCK_FREED 2&t;&t;/* this block was freed, and can&squot;t be written.  */
DECL|macro|BLOCK_FREED_HOLDER
mdefine_line|#define BLOCK_FREED_HOLDER 3    /* this block was freed during this transaction, and can&squot;t be written */
DECL|macro|BLOCK_NEEDS_FLUSH
mdefine_line|#define BLOCK_NEEDS_FLUSH 4&t;/* used in flush_journal_list */
multiline_comment|/* flags for do_journal_end */
DECL|macro|FLUSH_ALL
mdefine_line|#define FLUSH_ALL   1&t;&t;/* flush commit and real blocks */
DECL|macro|COMMIT_NOW
mdefine_line|#define COMMIT_NOW  2&t;&t;/* end and commit this transaction */
DECL|macro|WAIT
mdefine_line|#define WAIT        4&t;&t;/* wait for the log blocks to hit the disk*/
multiline_comment|/* state bits for the journal */
DECL|macro|WRITERS_BLOCKED
mdefine_line|#define WRITERS_BLOCKED 1      /* set when new writers not allowed */
r_static
r_int
id|do_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
comma
r_struct
id|super_block
op_star
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|flush_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
suffix:semicolon
r_static
r_int
id|flush_commit_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
suffix:semicolon
r_static
r_int
id|can_dirty
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
suffix:semicolon
r_static
r_int
id|journal_join
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|release_journal_dev
c_func
(paren
r_struct
id|super_block
op_star
id|super
comma
r_struct
id|reiserfs_journal
op_star
id|journal
)paren
suffix:semicolon
DECL|function|journ_get_hash_table
r_static
r_inline
r_struct
id|buffer_head
op_star
id|journ_get_hash_table
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|block
)paren
(brace
r_return
id|__get_hash_table
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_dev_bd
comma
id|block
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
)brace
DECL|function|journ_getblk
r_static
r_inline
r_struct
id|buffer_head
op_star
id|journ_getblk
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|block
)paren
(brace
r_return
id|__getblk
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_dev_bd
comma
id|block
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
)brace
DECL|function|journ_bread
r_static
r_inline
r_struct
id|buffer_head
op_star
id|journ_bread
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|block
)paren
(brace
r_return
id|__bread
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_dev_bd
comma
id|block
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
)brace
DECL|function|init_journal_hash
r_static
r_void
id|init_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|memset
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
l_int|0
comma
id|JOURNAL_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** clears BH_Dirty and sticks the buffer on the clean list.  Called because I can&squot;t allow refile_buffer to&n;** make schedule happen after I&squot;ve freed a block.  Look at remove_from_transaction and journal_mark_freed for&n;** more details.&n;*/
DECL|function|reiserfs_clean_and_file_buffer
r_static
r_int
id|reiserfs_clean_and_file_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|reiserfs_bitmap_node
op_star
DECL|function|allocate_bitmap_node
id|allocate_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
suffix:semicolon
r_static
r_int
id|id
op_assign
l_int|0
suffix:semicolon
id|bn
op_assign
id|reiserfs_kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|bn-&gt;data
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|p_s_sb-&gt;s_blocksize
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn-&gt;data
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|bn
comma
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bn-&gt;id
op_assign
id|id
op_increment
suffix:semicolon
id|memset
c_func
(paren
id|bn-&gt;data
comma
l_int|0
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bn-&gt;list
)paren
suffix:semicolon
r_return
id|bn
suffix:semicolon
)brace
r_static
r_struct
id|reiserfs_bitmap_node
op_star
DECL|function|get_bitmap_node
id|get_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes.next
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_used_bitmap_nodes
op_increment
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|entry
op_ne
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
(brace
id|bn
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|reiserfs_bitmap_node
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bn-&gt;data
comma
l_int|0
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_decrement
suffix:semicolon
r_return
id|bn
suffix:semicolon
)brace
id|bn
op_assign
id|allocate_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn
)paren
(brace
id|yield
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_return
id|bn
suffix:semicolon
)brace
DECL|function|free_bitmap_node
r_static
r_inline
r_void
id|free_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_used_bitmap_nodes
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
OG
id|REISERFS_MAX_BITMAP_NODES
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|bn-&gt;data
comma
id|p_s_sb-&gt;s_blocksize
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|bn
comma
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|bn-&gt;list
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_increment
suffix:semicolon
)brace
)brace
DECL|function|allocate_bitmap_nodes
r_static
r_void
id|allocate_bitmap_nodes
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|REISERFS_MIN_BITMAP_NODES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bn
op_assign
id|allocate_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bn
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|bn-&gt;list
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_increment
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
singleline_comment|// this is ok, we&squot;ll try again when more are needed 
)brace
)brace
)brace
DECL|function|set_bit_in_list_bitmap
r_static
r_int
id|set_bit_in_list_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|block
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
)paren
(brace
r_int
id|bmap_nr
op_assign
id|block
op_div
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_int
id|bit_nr
op_assign
id|block
op_mod
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
)paren
(brace
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_assign
id|get_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|bit_nr
comma
(paren
r_int
r_int
op_star
)paren
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_bitmap_list
r_static
r_void
id|cleanup_bitmap_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|jb-&gt;bitmaps
(braket
id|i
)braket
)paren
(brace
id|free_bitmap_node
c_func
(paren
id|p_s_sb
comma
id|jb-&gt;bitmaps
(braket
id|i
)braket
)paren
suffix:semicolon
id|jb-&gt;bitmaps
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** only call this on FS unmount.&n;*/
DECL|function|free_list_bitmaps
r_static
r_int
id|free_list_bitmaps
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb_array
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jb
op_assign
id|jb_array
op_plus
id|i
suffix:semicolon
id|jb-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|cleanup_bitmap_list
c_func
(paren
id|p_s_sb
comma
id|jb
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|jb-&gt;bitmaps
)paren
suffix:semicolon
id|jb-&gt;bitmaps
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_bitmap_nodes
r_static
r_int
id|free_bitmap_nodes
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|list_head
op_star
id|next
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes.next
suffix:semicolon
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
(brace
id|bn
op_assign
id|list_entry
c_func
(paren
id|next
comma
r_struct
id|reiserfs_bitmap_node
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|next
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|bn-&gt;data
comma
id|p_s_sb-&gt;s_blocksize
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|bn
comma
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|next
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes.next
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** get memory for JOURNAL_NUM_BITMAPS worth of bitmaps. &n;** jb_array is the array to be filled in.&n;*/
DECL|function|reiserfs_allocate_list_bitmaps
r_int
id|reiserfs_allocate_list_bitmaps
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb_array
comma
r_int
id|bmap_nr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_int
id|mem
op_assign
id|bmap_nr
op_star
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
op_star
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jb
op_assign
id|jb_array
op_plus
id|i
suffix:semicolon
id|jb-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|jb-&gt;bitmaps
op_assign
id|vmalloc
c_func
(paren
id|mem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb-&gt;bitmaps
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2000, unable to allocate bitmaps for journal lists&bslash;n&quot;
)paren
suffix:semicolon
id|failed
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|jb-&gt;bitmaps
comma
l_int|0
comma
id|mem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed
)paren
(brace
id|free_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|jb_array
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** find an available list bitmap.  If you can&squot;t find one, flush a commit list &n;** and try again&n;*/
r_static
r_struct
id|reiserfs_list_bitmap
op_star
DECL|function|get_list_bitmap
id|get_list_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
id|JOURNAL_NUM_BITMAPS
op_star
l_int|3
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|i
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap_index
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap_index
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|jb
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|jb-&gt;journal_list
)paren
(brace
multiline_comment|/* double check to make sure if flushed correctly */
r_return
l_int|NULL
suffix:semicolon
)brace
id|jb-&gt;journal_list
op_assign
id|jl
suffix:semicolon
r_return
id|jb
suffix:semicolon
)brace
multiline_comment|/* &n;** allocates a new chunk of X nodes, and links them all together as a list.&n;** Uses the cnode-&gt;next and cnode-&gt;prev pointers&n;** returns NULL on failure&n;*/
DECL|function|allocate_cnodes
r_static
r_struct
id|reiserfs_journal_cnode
op_star
id|allocate_cnodes
c_func
(paren
r_int
id|num_cnodes
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|head
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|num_cnodes
op_le
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|head
op_assign
id|vmalloc
c_func
(paren
id|num_cnodes
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|head
comma
l_int|0
comma
id|num_cnodes
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
id|head
(braket
l_int|0
)braket
dot
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|head
(braket
l_int|0
)braket
dot
id|next
op_assign
id|head
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|num_cnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|head
(braket
id|i
)braket
dot
id|prev
op_assign
id|head
op_plus
(paren
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|head
(braket
id|i
)braket
dot
id|next
op_assign
id|head
op_plus
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if last one, overwrite it after the if */
)brace
id|head
(braket
id|num_cnodes
op_minus
l_int|1
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n;** pulls a cnode off the free list, or returns NULL on failure &n;*/
DECL|function|get_cnode
r_static
r_struct
id|reiserfs_journal_cnode
op_star
id|get_cnode
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;get_cnode&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_le
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_used
op_increment
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_decrement
suffix:semicolon
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
r_return
id|cn
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn-&gt;next
)paren
(brace
id|cn-&gt;next-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
op_assign
id|cn-&gt;next
suffix:semicolon
id|memset
c_func
(paren
id|cn
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
r_return
id|cn
suffix:semicolon
)brace
multiline_comment|/*&n;** returns a cnode to the free list &n;*/
DECL|function|free_cnode
r_static
r_void
id|free_cnode
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;free_cnode&quot;
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_used
op_decrement
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_increment
suffix:semicolon
multiline_comment|/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */
id|cn-&gt;next
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list-&gt;prev
op_assign
id|cn
suffix:semicolon
)brace
id|cn-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not needed with the memset, but I might kill the memset, and forget to do this */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
op_assign
id|cn
suffix:semicolon
)brace
DECL|function|clear_prepared_bits
r_static
r_int
id|clear_prepared_bits
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* buffer is in current transaction */
DECL|function|buffer_journaled
r_inline
r_int
id|buffer_journaled
c_func
(paren
r_const
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
r_return
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* disk block was taken off free list before being in a finished transation, or written to disk&n;** journal_new blocks can be reused immediately, for any purpose&n;*/
DECL|function|buffer_journal_new
r_inline
r_int
id|buffer_journal_new
c_func
(paren
r_const
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
r_return
id|test_bit
c_func
(paren
id|BH_JNew
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mark_buffer_journal_new
r_inline
r_int
id|mark_buffer_journal_new
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JNew
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mark_buffer_not_journaled
r_inline
r_int
id|mark_buffer_not_journaled
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
id|clear_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* utility function to force a BUG if it is called without the big&n;** kernel lock held.  caller is the string printed just before calling BUG()&n;*/
DECL|function|reiserfs_check_lock_depth
r_void
id|reiserfs_check_lock_depth
c_func
(paren
r_char
op_star
id|caller
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|current-&gt;lock_depth
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s called without kernel lock held&bslash;n&quot;
comma
id|caller
)paren
suffix:semicolon
id|show_reiserfs_locks
c_func
(paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* return a cnode with same dev, block number and size in table, or null if not found */
r_static
r_inline
r_struct
id|reiserfs_journal_cnode
op_star
DECL|function|get_journal_hash_dev
id|get_journal_hash_dev
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_int
id|bl
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
id|cn
op_assign
id|journal_hash
c_func
(paren
id|table
comma
id|sb
comma
id|bl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
id|bl
op_logical_and
id|cn-&gt;sb
op_eq
id|sb
)paren
r_return
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;hnext
suffix:semicolon
)brace
r_return
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns a cnode with same size, block number and dev as bh in the current transaction hash.  NULL if not found */
DECL|function|get_journal_hash
r_static
r_inline
r_struct
id|reiserfs_journal_cnode
op_star
id|get_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
r_return
id|cn
suffix:semicolon
)brace
multiline_comment|/* once upon a time, the journal would deadlock.  a lot.  Now, when&n;** CONFIG_REISERFS_CHECK is defined, anytime someone enters a&n;** transaction, it pushes itself into this ugly static list, and pops&n;** itself off before calling journal_end.  I made a SysRq key to dump&n;** the list, and tell me what the writers are when I&squot;m deadlocked.  */
multiline_comment|/* are you depending on the compiler&n;                                   to optimize this function away&n;                                   everywhere it is called? It is not&n;                                   obvious how this works, but I&n;                                   suppose debugging code need not be&n;                                   clear.  -Hans */
DECL|variable|journal_writers
r_static
r_char
op_star
id|journal_writers
(braket
l_int|512
)braket
suffix:semicolon
DECL|function|push_journal_writer
r_int
id|push_journal_writer
c_func
(paren
r_char
op_star
id|s
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|journal_writers
(braket
id|i
)braket
)paren
(brace
id|journal_writers
(braket
id|i
)braket
op_assign
id|s
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|pop_journal_writer
r_int
id|pop_journal_writer
c_func
(paren
r_int
id|index
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
(brace
id|journal_writers
(braket
id|index
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dump_journal_writers
r_int
id|dump_journal_writers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|journal_writers
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d: %s&bslash;n&quot;
comma
id|i
comma
id|journal_writers
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** this actually means &squot;can this block be reallocated yet?&squot;.  If you set search_all, a block can only be allocated&n;** if it is not in the current transaction, was not freed by the current transaction, and has no chance of ever&n;** being overwritten by a replay after crashing.&n;**&n;** If you don&squot;t set search_all, a block can only be allocated if it is not in the current transaction.  Since deleting&n;** a block removes it from the current transaction, this case should never happen.  If you don&squot;t set search_all, make&n;** sure you never write the block without logging it.&n;**&n;** next_zero_bit is a suggestion about the next block to try for find_forward.&n;** when bl is rejected because it is set in a journal list bitmap, we search&n;** for the next zero bit in the bitmap that rejected bl.  Then, we return that&n;** through next_zero_bit for find_forward to try.&n;**&n;** Just because we return something in next_zero_bit does not mean we won&squot;t&n;** reject it on the next call to reiserfs_in_journal&n;**&n;*/
DECL|function|reiserfs_in_journal
r_int
id|reiserfs_in_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|bl
comma
r_int
id|search_all
comma
r_int
r_int
op_star
id|next_zero_bit
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|bmap_nr
op_assign
id|bl
op_div
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_int
id|bit_nr
op_assign
id|bl
op_mod
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_int
id|tmp_bit
suffix:semicolon
op_star
id|next_zero_bit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always start this at zero. */
multiline_comment|/* we aren&squot;t logging all blocks are safe for reuse */
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.in_journal
)paren
suffix:semicolon
multiline_comment|/* If we aren&squot;t doing a search_all, this is a metablock, and it will be logged before use.&n;  ** if we crash before the transaction that freed it commits,  this transaction won&squot;t&n;  ** have committed either, and the block will never be written&n;  */
r_if
c_cond
(paren
id|search_all
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.in_journal_bitmap
)paren
suffix:semicolon
id|jb
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|jb-&gt;journal_list
op_logical_and
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_logical_and
id|test_bit
c_func
(paren
id|bit_nr
comma
(paren
r_int
r_int
op_star
)paren
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
)paren
(brace
id|tmp_bit
op_assign
id|find_next_zero_bit
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
comma
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
comma
id|bit_nr
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|next_zero_bit
op_assign
id|bmap_nr
op_star
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
op_plus
id|tmp_bit
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* is it in any old transactions? */
r_if
c_cond
(paren
id|search_all
op_logical_and
(paren
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|bl
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* is it in the current transaction.  This should never happen */
r_if
c_cond
(paren
(paren
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|bl
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.in_journal_reusable
)paren
suffix:semicolon
multiline_comment|/* safe for reuse */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* insert cn into table&n;*/
DECL|function|insert_journal_hash
r_inline
r_void
id|insert_journal_hash
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn_orig
suffix:semicolon
id|cn_orig
op_assign
id|journal_hash
c_func
(paren
id|table
comma
id|cn-&gt;sb
comma
id|cn-&gt;blocknr
)paren
suffix:semicolon
id|cn-&gt;hnext
op_assign
id|cn_orig
suffix:semicolon
id|cn-&gt;hprev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cn_orig
)paren
(brace
id|cn_orig-&gt;hprev
op_assign
id|cn
suffix:semicolon
)brace
id|journal_hash
c_func
(paren
id|table
comma
id|cn-&gt;sb
comma
id|cn-&gt;blocknr
)paren
op_assign
id|cn
suffix:semicolon
)brace
multiline_comment|/* lock the current transaction */
DECL|function|lock_journal
r_inline
r_static
r_void
id|lock_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.lock_journal
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
)paren
OG
l_int|0
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.lock_journal_wait
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wait
)paren
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* unlock the current transaction */
DECL|function|unlock_journal
r_inline
r_static
r_void
id|unlock_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** this used to be much more involved, and I&squot;m keeping it just in case things get ugly again.&n;** it gets called by flush_commit_list, and cleans up any data stored about blocks freed during a&n;** transaction.&n;*/
DECL|function|cleanup_freed_for_journal_list
r_static
r_void
id|cleanup_freed_for_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
id|jl-&gt;j_list_bitmap
suffix:semicolon
r_if
c_cond
(paren
id|jb
)paren
(brace
id|cleanup_bitmap_list
c_func
(paren
id|p_s_sb
comma
id|jb
)paren
suffix:semicolon
)brace
id|jl-&gt;j_list_bitmap-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_list_bitmap
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** if this journal list still has commit blocks unflushed, send them to disk.&n;**&n;** log areas must be flushed in order (transaction 2 can&squot;t commit before transaction 1)&n;** Before the commit block can by written, every other log block must be safely on disk&n;**&n;*/
DECL|function|flush_commit_list
r_static
r_int
id|flush_commit_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_int
id|bn
suffix:semicolon
r_int
id|retry_count
op_assign
l_int|0
suffix:semicolon
r_int
id|orig_commit_left
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tbh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|other_jl
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;flush_commit_list&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|jl-&gt;j_older_commits_done
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* before we can put our commit blocks on disk, we have to make sure everyone older than&n;  ** us is on disk too&n;  */
r_if
c_cond
(paren
id|jl-&gt;j_len
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flushall
)paren
(brace
multiline_comment|/* we _must_ make sure the transactions are committed in order.  Start with the&n;    ** index after this one, wrap all the way around &n;    */
id|index
op_assign
(paren
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|other_jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
op_plus
(paren
(paren
id|index
op_plus
id|i
)paren
op_mod
id|JOURNAL_LIST_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|other_jl
op_logical_and
id|other_jl
op_ne
id|jl
op_logical_and
id|other_jl-&gt;j_len
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
op_le
id|jl-&gt;j_trans_id
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|flush_commit_list
c_func
(paren
id|s
comma
id|other_jl
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t flush the commit list for the current transactoin */
r_if
c_cond
(paren
id|jl
op_eq
(paren
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|s
)paren
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* make sure nobody is trying to flush this one at the same time */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this commit is done, exit */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* keeps others from flushing while we are flushing */
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_len
OG
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|s
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-512: flush_commit_list: length is %lu, list number %d&bslash;n&quot;
comma
id|jl-&gt;j_len
comma
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|orig_commit_left
op_assign
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
multiline_comment|/* start by checking all the commit blocks in this transaction.  &n;  ** Add anyone not on disk into tbh.  Stop checking once commit_left &lt;= 1, because that means we&n;  ** only have the commit block left &n;  */
id|retry
suffix:colon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
OG
l_int|1
op_logical_and
id|i
OL
(paren
id|jl-&gt;j_len
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* everything but commit_bh */
id|bn
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|s
)paren
op_plus
(paren
id|jl-&gt;j_start
op_plus
id|i
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|s
)paren
suffix:semicolon
id|tbh
op_assign
id|journ_get_hash_table
c_func
(paren
id|s
comma
id|bn
)paren
suffix:semicolon
multiline_comment|/* kill this sanity check */
r_if
c_cond
(paren
id|count
OG
(paren
id|orig_commit_left
op_plus
l_int|2
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-539: flush_commit_list: BAD count(%d) &gt; orig_commit_left(%d)!&bslash;n&quot;
comma
id|count
comma
id|orig_commit_left
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tbh
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|tbh
)paren
)paren
(brace
multiline_comment|/* wait on it, redo it just to make sure */
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-584, buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|tbh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-569: flush_commit_list, block already dirty!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|mark_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|tbh
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|put_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
multiline_comment|/* once for our get_hash */
)brace
)brace
multiline_comment|/* wait on everyone in tbh before writing commit block*/
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
OG
l_int|1
op_logical_and
id|i
OL
(paren
id|jl-&gt;j_len
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* everything but commit_bh */
id|bn
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|s
)paren
op_plus
(paren
id|jl-&gt;j_start
op_plus
id|i
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|s
)paren
suffix:semicolon
id|tbh
op_assign
id|journ_get_hash_table
c_func
(paren
id|s
comma
id|bn
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-601, buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
multiline_comment|/* once for our get_hash */
id|bforget
c_func
(paren
id|tbh
)paren
suffix:semicolon
multiline_comment|/* once due to original getblk in do_journal_end */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* just the commit_bh left, flush it without calling getblk for everyone */
r_if
c_cond
(paren
id|retry_count
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-582: flush_commit_list, not all log blocks on disk yet, trying again&bslash;n&quot;
)paren
suffix:semicolon
id|retry_count
op_increment
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-563: flush_commit_list: BAD, j_commit_left is %u, should be 1&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
)paren
suffix:semicolon
)brace
id|mark_buffer_dirty
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
(paren
id|jl-&gt;j_commit_bh
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-615: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
id|bforget
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
multiline_comment|/* now, every commit block is on the disk.  It is safe to allow blocks freed during this transaction to be reallocated */
id|cleanup_freed_for_journal_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** flush_journal_list frequently needs to find a newer transaction for a given block.  This does that, or &n;** returns NULL if it can&squot;t find anything &n;*/
DECL|function|find_newer_jl_for_cn
r_static
r_struct
id|reiserfs_journal_list
op_star
id|find_newer_jl_for_cn
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|cn-&gt;sb
suffix:semicolon
r_int
r_int
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
id|cn
op_assign
id|cn-&gt;hprev
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;sb
op_eq
id|sb
op_logical_and
id|cn-&gt;blocknr
op_eq
id|blocknr
op_logical_and
id|cn-&gt;jlist
)paren
(brace
r_return
id|cn-&gt;jlist
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;hprev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
id|remove_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
comma
r_struct
id|reiserfs_journal_cnode
op_star
op_star
comma
r_struct
id|reiserfs_journal_list
op_star
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n;** once all the real blocks have been flushed, it is safe to remove them from the&n;** journal list for this transaction.  Aside from freeing the cnode, this also allows the&n;** block to be reallocated for data blocks if it had been deleted.&n;*/
DECL|function|remove_all_from_journal_list
r_static
r_void
id|remove_all_from_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|debug
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|last
suffix:semicolon
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
multiline_comment|/* which is better, to lock once around the whole loop, or&n;  ** to lock for each call to remove_journal_hash?&n;  */
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;block %lu, bh is %d, state %ld&bslash;n&quot;
comma
id|cn-&gt;blocknr
comma
id|cn-&gt;bh
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|cn-&gt;state
)paren
suffix:semicolon
)brace
id|cn-&gt;state
op_assign
l_int|0
suffix:semicolon
id|remove_journal_hash
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|jl
comma
id|cn-&gt;blocknr
comma
l_int|1
)paren
suffix:semicolon
)brace
id|last
op_assign
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|last
)paren
suffix:semicolon
)brace
id|jl-&gt;j_realblock
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** if this timestamp is greater than the timestamp we wrote last to the header block, write it to the header block.&n;** once this is done, I can safely say the log area for this transaction won&squot;t ever be replayed, and I can start&n;** releasing blocks in this transaction for reuse as data blocks.&n;** called by flush_journal_list, before it calls remove_all_from_journal_list&n;**&n;*/
DECL|function|_update_journal_header_block
r_static
r_int
id|_update_journal_header_block
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|trans_id
)paren
(brace
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_if
c_cond
(paren
id|trans_id
op_ge
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
)paren
(brace
id|wait_on_buffer
c_func
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-699: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
op_assign
id|trans_id
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first_unflushed_offset
op_assign
id|offset
suffix:semicolon
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh-&gt;b_data
)paren
suffix:semicolon
id|jh-&gt;j_last_flush_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|trans_id
)paren
suffix:semicolon
id|jh-&gt;j_first_unflushed_offset
op_assign
id|cpu_to_le32
c_func
(paren
id|offset
)paren
suffix:semicolon
id|jh-&gt;j_mount_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
)paren
suffix:semicolon
id|set_buffer_dirty
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs: journal-837: IO error during journal replay&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|update_journal_header_block
r_static
r_int
id|update_journal_header_block
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|trans_id
)paren
(brace
r_if
c_cond
(paren
id|_update_journal_header_block
c_func
(paren
id|p_s_sb
comma
id|offset
comma
id|trans_id
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-712: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;** flush any and all journal lists older than you are &n;** can only be called from flush_journal_list&n;*/
DECL|function|flush_older_journal_lists
r_static
r_int
id|flush_older_journal_lists
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
r_int
id|trans_id
)paren
(brace
r_int
id|i
comma
id|index
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|other_jl
suffix:semicolon
id|index
op_assign
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|other_jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|index
op_plus
id|i
)paren
op_mod
id|JOURNAL_LIST_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|other_jl
op_logical_and
id|other_jl-&gt;j_len
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
OL
id|trans_id
op_logical_and
id|other_jl
op_ne
id|jl
)paren
(brace
multiline_comment|/* do not flush all */
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|other_jl
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_end_buffer_io_sync
r_static
r_void
id|reiserfs_end_buffer_io_sync
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2084: pinned buffer %lu:%s sent to disk&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|bdevname
c_func
(paren
id|bh-&gt;b_bdev
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uptodate
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_else
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|submit_logged_buffer
r_static
r_void
id|submit_logged_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|reiserfs_end_buffer_io_sync
suffix:semicolon
id|mark_buffer_notjournal_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* flush a journal list, both commit and real blocks&n;**&n;** always set flushall to 1, unless you are calling from inside&n;** flush_journal_list&n;**&n;** IMPORTANT.  This can only be called while there are no journal writers, &n;** and the journal is locked.  That means it can only be called from &n;** do_journal_end, or by journal_release&n;*/
DECL|function|flush_journal_list
r_static
r_int
id|flush_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|pjl
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|last
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|was_jwait
op_assign
l_int|0
suffix:semicolon
r_int
id|was_dirty
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|saved_bh
suffix:semicolon
r_int
r_int
id|j_len_saved
op_assign
id|jl-&gt;j_len
suffix:semicolon
r_if
c_cond
(paren
id|j_len_saved
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_wcount
)paren
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2048: flush_journal_list called with wcount %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if someone is getting the commit list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if someone is flushing this list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* this list is now ours, we can change anything we want */
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|j_len_saved
OG
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|s
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-715: flush_journal_list, length is %lu, list number %d&bslash;n&quot;
comma
id|j_len_saved
comma
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if all the work is already done, get out of here */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
op_le
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_goto
id|flush_older_and_return
suffix:semicolon
)brace
multiline_comment|/* start by putting the commit list on disk.  This will also flush &n;  ** the commit lists of any olders transactions&n;  */
id|flush_commit_list
c_func
(paren
id|s
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* are we done now? */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
op_le
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_goto
id|flush_older_and_return
suffix:semicolon
)brace
multiline_comment|/* loop through each cnode, see if we need to write it, &n;  ** or wait on a more recent transaction, or just ignore it &n;  */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-844: panic journal list is flushing, wcount is not 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
id|was_jwait
op_assign
l_int|0
suffix:semicolon
id|was_dirty
op_assign
l_int|0
suffix:semicolon
id|saved_bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* blocknr of 0 is no longer in the hash, ignore it */
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
l_int|0
)paren
(brace
r_goto
id|free_cnode
suffix:semicolon
)brace
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
multiline_comment|/* the order is important here.  We check pjl to make sure we&n;    ** don&squot;t clear BH_JDirty_wait if we aren&squot;t the one writing this&n;    ** block to disk&n;    */
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
)paren
(brace
id|saved_bh
op_assign
id|cn-&gt;bh
suffix:semicolon
multiline_comment|/* we do this to make sure nobody releases the buffer while &n;      ** we are working with it &n;      */
id|get_bh
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_journal_dirty
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|was_jwait
op_assign
l_int|1
suffix:semicolon
id|mark_buffer_notjournal_dirty
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
multiline_comment|/* undo the inc from journal_mark_dirty */
id|put_bh
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|can_dirty
c_func
(paren
id|cn
)paren
)paren
(brace
id|was_dirty
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* if someone has this block in a newer transaction, just make&n;    ** sure they are commited, and don&squot;t try writing it to disk&n;    */
r_if
c_cond
(paren
id|pjl
)paren
(brace
id|flush_commit_list
c_func
(paren
id|s
comma
id|pjl
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|free_cnode
suffix:semicolon
)brace
multiline_comment|/* bh == NULL when the block got to disk on its own, OR, &n;    ** the block got freed in a future transaction &n;    */
r_if
c_cond
(paren
id|saved_bh
op_eq
l_int|NULL
)paren
(brace
r_goto
id|free_cnode
suffix:semicolon
)brace
multiline_comment|/* this should never happen.  kupdate_one_transaction has this list&n;    ** locked while it works, so we should never see a buffer here that&n;    ** is not marked JDirty_wait&n;    */
r_if
c_cond
(paren
(paren
op_logical_neg
id|was_jwait
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-813: BAD! buffer %lu %cdirty %cjwait, not in a newer tranasction&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
comma
id|was_dirty
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|was_jwait
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* kupdate_one_transaction waits on the buffers it is writing, so we&n;    ** should never see locked buffers here&n;    */
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;clm-2083: locked buffer %lu in flush_journal_list&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-923: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|was_dirty
)paren
(brace
multiline_comment|/* we inc again because saved_bh gets decremented at free_cnode */
id|get_bh
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
id|submit_logged_buffer
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;clm-2082: Unable to flush buffer %lu in flush_journal_list&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|free_cnode
suffix:colon
id|last
op_assign
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|saved_bh
)paren
(brace
multiline_comment|/* we incremented this to keep others from taking the buffer head away */
id|put_bh
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|saved_bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-945: saved_bh-&gt;b_count &lt; 0&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cn-&gt;bh
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-1011: cn-&gt;bh is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|wait_on_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn-&gt;bh
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-1012: cn-&gt;bh is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-949: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
)brace
id|flush_older_and_return
suffix:colon
multiline_comment|/* before we can update the journal header block, we _must_ flush all &n;  ** real blocks from all older transactions to disk.  This is because&n;  ** once the header block is updated, this transaction will not be&n;  ** replayed after a crash&n;  */
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|flush_older_journal_lists
c_func
(paren
id|s
comma
id|jl
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
)brace
multiline_comment|/* before we can remove everything from the hash tables for this &n;  ** transaction, we must make sure it can never be replayed&n;  **&n;  ** since we are only called from do_journal_end, we know for sure there&n;  ** are no allocations going on while we are flushing journal lists.  So,&n;  ** we only need to update the journal header block for the last list&n;  ** being flushed&n;  */
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|update_journal_header_block
c_func
(paren
id|s
comma
(paren
id|jl-&gt;j_start
op_plus
id|jl-&gt;j_len
op_plus
l_int|2
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|s
)paren
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
)brace
id|remove_all_from_journal_list
c_func
(paren
id|s
comma
id|jl
comma
l_int|0
)paren
suffix:semicolon
id|jl-&gt;j_len
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
comma
l_int|0
)paren
suffix:semicolon
id|jl-&gt;j_start
op_assign
l_int|0
suffix:semicolon
id|jl-&gt;j_realblock
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_commit_bh
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_trans_id
op_assign
l_int|0
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|kupdate_one_transaction
r_static
r_int
id|kupdate_one_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|pjl
suffix:semicolon
multiline_comment|/* previous list for this cn */
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|walk_cn
suffix:semicolon
r_int
r_int
id|blocknr
suffix:semicolon
r_int
id|run
op_assign
l_int|0
suffix:semicolon
r_int
id|orig_trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
r_struct
id|buffer_head
op_star
id|saved_bh
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if someone is getting the commit list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if someone is flushing this list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* was it flushed while we slept? */
r_if
c_cond
(paren
id|jl-&gt;j_len
op_le
l_int|0
op_logical_or
id|jl-&gt;j_trans_id
op_ne
id|orig_trans_id
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this list is now ours, we can change anything we want */
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|loop_start
suffix:colon
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
id|saved_bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* if the blocknr == 0, this has been cleared from the hash,&n;        ** skip it&n;        */
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
l_int|0
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* look for a more recent transaction that logged this&n;        ** buffer.  Only the most recent transaction with a buffer in&n;        ** it is allowed to send that buffer to disk&n;        */
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run
op_eq
l_int|0
op_logical_and
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
op_logical_and
id|buffer_journal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
op_logical_and
id|can_dirty
c_func
(paren
id|cn
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|cn-&gt;bh-&gt;b_state
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
id|submit_logged_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* someone else is using this buffer.  We can&squot;t &n;                ** send it to disk right now because they might&n;                ** be changing/logging it.&n;                */
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
)paren
(brace
id|clear_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
multiline_comment|/* check again, someone could have logged while we scheduled */
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
multiline_comment|/* before the JDirty_wait bit is set, the &n;            ** buffer is added to the hash list.  So, if we are&n;            ** run in the middle of a do_journal_end, we will notice&n;            ** if this buffer was logged and added from the latest&n;            ** transaction.  In this case, we don&squot;t want to decrement&n;            ** b_count&n;            */
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
op_logical_and
id|buffer_journal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
id|walk_cn
op_assign
id|cn
suffix:semicolon
id|saved_bh
op_assign
id|cn-&gt;bh
suffix:semicolon
multiline_comment|/* update all older transactions to show this block&n;                ** was flushed&n;                */
id|mark_buffer_notjournal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_while
c_loop
(paren
id|walk_cn
)paren
(brace
r_if
c_cond
(paren
id|walk_cn-&gt;bh
op_logical_and
id|walk_cn-&gt;blocknr
op_eq
id|blocknr
op_logical_and
id|walk_cn-&gt;sb
op_eq
id|cn-&gt;sb
)paren
(brace
r_if
c_cond
(paren
id|walk_cn-&gt;jlist
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|walk_cn-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
)brace
id|walk_cn-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
id|walk_cn
op_assign
id|walk_cn-&gt;hnext
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|saved_bh-&gt;b_count
)paren
OL
l_int|1
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2081: bad count on %lu&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;        ** if the more recent transaction is committed to the log,&n;        ** this buffer can be considered flushed.  Decrement our&n;        ** counters to reflect one less buffer that needs writing.&n;        **&n;        ** note, this relies on all of the above code being&n;        ** schedule free once pjl comes back non-null.&n;        */
r_if
c_cond
(paren
id|pjl
op_logical_and
id|cn-&gt;bh
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|pjl-&gt;j_commit_left
)paren
op_eq
l_int|0
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|cn-&gt;jlist-&gt;j_nonzerolen
)paren
suffix:semicolon
id|cn-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
id|next
suffix:colon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
multiline_comment|/* the first run through the loop sends all the dirty buffers to&n;    ** ll_rw_block.&n;    ** the second run through the loop does all the accounting&n;    */
r_if
c_cond
(paren
id|run
op_increment
op_eq
l_int|0
)paren
(brace
r_goto
id|loop_start
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* since we never give dirty buffers to bdflush/kupdate, we have to&n;** flush them ourselves.  This runs through the journal lists, finds&n;** old metadata in need of flushing and sends it to disk.&n;** this does not end transactions, commit anything, or free&n;** cnodes.&n;**&n;** returns the highest transaction id that was flushed last time&n;*/
DECL|function|reiserfs_journal_kupdate
r_static
r_int
r_int
id|reiserfs_journal_kupdate
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|start
suffix:semicolon
id|time_t
id|age
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* safety check to prevent flush attempts during a mount */
r_if
c_cond
(paren
id|start
OL
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_assign
(paren
id|start
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|start
)paren
(brace
id|jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
op_plus
id|i
suffix:semicolon
id|age
op_assign
id|CURRENT_TIME
op_minus
id|jl-&gt;j_timestamp
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_len
OG
l_int|0
op_logical_and
singleline_comment|// age &gt;= (JOURNAL_MAX_COMMIT_AGE * 2) &amp;&amp; 
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jl-&gt;j_trans_id
op_eq
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* if ret was already 1, we want to preserve that */
id|ret
op_or_assign
id|kupdate_one_transaction
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
OG
l_int|0
)paren
(brace
id|ret
op_or_assign
l_int|1
suffix:semicolon
)brace
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;** removes any nodes in table with name block and dev as bh.&n;** only touchs the hnext and hprev pointers.&n;*/
DECL|function|remove_journal_hash
r_void
id|remove_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
r_int
id|block
comma
r_int
id|remove_freed
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cur
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|head
suffix:semicolon
id|head
op_assign
op_amp
(paren
id|journal_hash
c_func
(paren
id|table
comma
id|sb
comma
id|block
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head
)paren
(brace
r_return
suffix:semicolon
)brace
id|cur
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|cur
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;blocknr
op_eq
id|block
op_logical_and
id|cur-&gt;sb
op_eq
id|sb
op_logical_and
(paren
id|jl
op_eq
l_int|NULL
op_logical_or
id|jl
op_eq
id|cur-&gt;jlist
)paren
op_logical_and
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BLOCK_FREED
comma
op_amp
id|cur-&gt;state
)paren
op_logical_or
id|remove_freed
)paren
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;hnext
)paren
(brace
id|cur-&gt;hnext-&gt;hprev
op_assign
id|cur-&gt;hprev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur-&gt;hprev
)paren
(brace
id|cur-&gt;hprev-&gt;hnext
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
r_else
(brace
op_star
id|head
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
id|cur-&gt;blocknr
op_assign
l_int|0
suffix:semicolon
id|cur-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
id|cur-&gt;state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cur-&gt;bh
op_logical_and
id|cur-&gt;jlist
)paren
multiline_comment|/* anybody who clears the cur-&gt;bh will also dec the nonzerolen */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|cur-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
id|cur-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
id|cur-&gt;jlist
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
)brace
DECL|function|free_journal_ram
r_static
r_void
id|free_journal_ram
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|vfree
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_orig
)paren
suffix:semicolon
id|free_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
)paren
suffix:semicolon
id|free_bitmap_nodes
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* must be after free_list_bitmaps */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
(brace
id|brelse
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** call on unmount.  Only set error to 1 if you haven&squot;t made your way out&n;** of read_super() yet.  Any other caller must keep error at 0.&n;*/
DECL|function|do_journal_release
r_static
r_int
id|do_journal_release
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|error
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|myth
suffix:semicolon
multiline_comment|/* we only want to flush out transactions if we were called with error == 0&n;  */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
op_logical_neg
(paren
id|p_s_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
multiline_comment|/* end the current trans */
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|10
comma
id|FLUSH_ALL
)paren
suffix:semicolon
multiline_comment|/* make sure something gets logged to force our way into the flush code */
id|journal_join
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
id|FLUSH_ALL
)paren
suffix:semicolon
)brace
multiline_comment|/* we decrement before we wake up, because the commit thread dies off&n;  ** when it has been woken up and the count is &lt;= 0&n;  */
id|reiserfs_mounted_fs_count
op_decrement
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_wait
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
id|release_journal_dev
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|free_journal_ram
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** call on unmount.  flush all journal trans, release all alloc&squot;d ram&n;*/
DECL|function|journal_release
r_int
id|journal_release
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_return
id|do_journal_release
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** only call from an error condition inside reiserfs_read_super!&n;*/
DECL|function|journal_release_error
r_int
id|journal_release_error
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_return
id|do_journal_release
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* compares description block with commit block.  returns 1 if they differ, 0 if they are the same */
DECL|function|journal_compare_desc_commit
r_static
r_int
id|journal_compare_desc_commit
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_desc
op_star
id|desc
comma
r_struct
id|reiserfs_journal_commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_trans_id
)paren
op_ne
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
op_ne
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
OG
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
op_le
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns 0 if it did not find a description block  &n;** returns -1 if it found a corrupt commit block&n;** returns 1 if both desc and commit were valid &n;*/
DECL|function|journal_transaction_is_valid
r_static
r_int
id|journal_transaction_is_valid
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|d_bh
comma
r_int
r_int
op_star
id|oldest_invalid_trans_id
comma
r_int
r_int
op_star
id|newest_mount_id
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_bh
)paren
r_return
l_int|0
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
OG
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|desc-&gt;j_magic
comma
id|JOURNAL_DESC_MAGIC
comma
l_int|8
)paren
)paren
(brace
r_if
c_cond
(paren
id|oldest_invalid_trans_id
op_logical_and
op_star
id|oldest_invalid_trans_id
op_logical_and
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
OG
op_star
id|oldest_invalid_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-986: transaction &quot;
l_string|&quot;is valid returning because trans_id %d is greater than &quot;
l_string|&quot;oldest_invalid %lu&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
comma
op_star
id|oldest_invalid_trans_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newest_mount_id
op_logical_and
op_star
id|newest_mount_id
OG
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1087: transaction &quot;
l_string|&quot;is valid returning because mount_id %d is less than &quot;
l_string|&quot;newest_mount_id %lu&bslash;n&quot;
comma
id|desc-&gt;j_mount_id
comma
op_star
id|newest_mount_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|offset
op_assign
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* ok, we have a journal description block, lets see if the transaction was valid */
id|c_bh
op_assign
id|journ_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|offset
op_plus
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c_bh
)paren
r_return
l_int|0
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|journal_compare_desc_commit
c_func
(paren
id|p_s_sb
comma
id|desc
comma
id|commit
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal_transaction_is_valid, commit offset %ld had bad &quot;
l_string|&quot;time %d or length %d&bslash;n&quot;
comma
id|c_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_trans_id
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldest_invalid_trans_id
)paren
op_star
id|oldest_invalid_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1004: &quot;
l_string|&quot;transaction_is_valid setting oldest invalid trans_id &quot;
l_string|&quot;to %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1006: found valid &quot;
l_string|&quot;transaction start offset %lu, len %d id %d&bslash;n&quot;
comma
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|brelse_array
r_static
r_void
id|brelse_array
c_func
(paren
r_struct
id|buffer_head
op_star
op_star
id|heads
comma
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
c_func
(paren
id|heads
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** given the start, and values for the oldest acceptable transactions,&n;** this either reads in a replays a transaction, or returns because the transaction&n;** is invalid, or too old.&n;*/
DECL|function|journal_read_transaction
r_static
r_int
id|journal_read_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|cur_dblock
comma
r_int
r_int
id|oldest_start
comma
r_int
r_int
id|oldest_trans_id
comma
r_int
r_int
id|newest_mount_id
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_int
r_int
id|trans_id
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|log_blocks
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|real_blocks
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|trans_offset
suffix:semicolon
r_int
id|i
suffix:semicolon
id|d_bh
op_assign
id|journ_bread
c_func
(paren
id|p_s_sb
comma
id|cur_dblock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_bh
)paren
r_return
l_int|1
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
id|trans_offset
op_assign
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1037: &quot;
l_string|&quot;journal_read_transaction, offset %lu, len %d mount_id %d&bslash;n&quot;
comma
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
OL
id|oldest_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1039: &quot;
l_string|&quot;journal_read_trans skipping because %lu is too old&bslash;n&quot;
comma
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
op_ne
id|newest_mount_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1146: &quot;
l_string|&quot;journal_read_trans skipping because %d is != &quot;
l_string|&quot;newest_mount_id %lu&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
comma
id|newest_mount_id
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|c_bh
op_assign
id|journ_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|trans_offset
op_plus
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c_bh
)paren
(brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|journal_compare_desc_commit
c_func
(paren
id|p_s_sb
comma
id|desc
comma
id|commit
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal_read_transaction, &quot;
l_string|&quot;commit offset %ld had bad time %d or length %d&bslash;n&quot;
comma
id|c_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_trans_id
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
multiline_comment|/* now we know we&squot;ve got a good transaction, and it was inside the valid time ranges */
id|log_blocks
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
id|real_blocks
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|log_blocks
op_logical_or
op_logical_neg
id|real_blocks
)paren
(brace
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1169: kmalloc failed, unable to mount FS&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* get all the buffer heads */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|log_blocks
(braket
id|i
)braket
op_assign
id|journ_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
id|trans_offset
op_plus
l_int|1
op_plus
id|i
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|JOURNAL_TRANS_HALF
)paren
(brace
id|real_blocks
(braket
id|i
)braket
op_assign
id|sb_getblk
c_func
(paren
id|p_s_sb
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_realblock
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|real_blocks
(braket
id|i
)braket
op_assign
id|sb_getblk
c_func
(paren
id|p_s_sb
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_realblock
(braket
id|i
op_minus
id|JOURNAL_TRANS_HALF
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* make sure we don&squot;t try to replay onto log or reserved area */
r_if
c_cond
(paren
id|is_block_in_log_or_reserved_area
c_func
(paren
id|p_s_sb
comma
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block&bslash;n&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|log_blocks
comma
id|i
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
comma
id|i
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* read in the log blocks, memcpy to the corresponding real block */
id|ll_rw_block
c_func
(paren
id|READ
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
comma
id|log_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1212: REPLAY FAILURE fsck required! buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|log_blocks
op_plus
id|i
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_minus
id|i
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|log_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* flush out the real blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|set_buffer_dirty
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
id|real_blocks
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1226: REPLAY FAILURE, fsck required! buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
op_plus
id|i
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_minus
id|i
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|cur_dblock
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|trans_offset
op_plus
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|2
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1095: setting journal &quot;
l_string|&quot;start to offset %ld&bslash;n&quot;
comma
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
multiline_comment|/* init starting values for the first transaction, in case this is the last transaction to be replayed. */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
op_assign
id|trans_id
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_assign
id|trans_id
op_plus
l_int|1
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** read and replay the log&n;** on a clean unmount, the journal header&squot;s next unflushed pointer will be to an invalid&n;** transaction.  This tests that before finding all the transactions in the log, whic makes normal mount times fast.&n;**&n;** After a crash, this starts with the next unflushed transaction, and replays until it finds one too old, or invalid.&n;**&n;** On exit, it sets things up so the first transaction will work correctly.&n;*/
DECL|function|reiserfs_breada
r_struct
id|buffer_head
op_star
id|reiserfs_breada
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|block
comma
r_int
r_int
id|max_block
)paren
(brace
r_struct
id|buffer_head
op_star
id|bhlist
(braket
id|BUFNR
)braket
suffix:semicolon
r_int
r_int
id|blocks
op_assign
id|BUFNR
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|bh
op_assign
id|sb_getblk
(paren
id|sb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
(paren
id|bh
)paren
)paren
r_return
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_plus
id|BUFNR
OG
id|max_block
)paren
(brace
id|blocks
op_assign
id|max_block
op_minus
id|block
suffix:semicolon
)brace
id|bhlist
(braket
l_int|0
)braket
op_assign
id|bh
suffix:semicolon
id|j
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|sb_getblk
(paren
id|sb
comma
id|block
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
(paren
id|bh
)paren
)paren
(brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|bhlist
(braket
id|j
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
id|ll_rw_block
(paren
id|READ
comma
id|j
comma
id|bhlist
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
(paren
id|bhlist
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|bhlist
(braket
l_int|0
)braket
suffix:semicolon
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|journal_read
r_static
r_int
id|journal_read
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_int
r_int
id|oldest_trans_id
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldest_invalid_trans_id
op_assign
l_int|0
suffix:semicolon
id|time_t
id|start
suffix:semicolon
r_int
r_int
id|oldest_start
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cur_dblock
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|newest_mount_id
op_assign
l_int|9
suffix:semicolon
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_int
id|valid_journal_header
op_assign
l_int|0
suffix:semicolon
r_int
id|replay_count
op_assign
l_int|0
suffix:semicolon
r_int
id|continue_replay
op_assign
l_int|1
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|cur_dblock
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reiserfs: checking transaction log (%s) for (%s)&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_dev_bd
)paren
comma
id|p_s_sb-&gt;s_id
)paren
suffix:semicolon
id|start
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* step 1, read in the journal header block.  Check the transaction it says &n;  ** is the first unflushed, and if that transaction is not valid, &n;  ** replay is done&n;  */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
op_assign
id|journ_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh-&gt;b_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
op_ge
l_int|0
op_logical_and
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
template_param
l_int|0
)paren
(brace
id|oldest_start
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
suffix:semicolon
id|oldest_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
op_plus
l_int|1
suffix:semicolon
id|newest_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_mount_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1153: found in &quot;
l_string|&quot;header: first_unflushed_offset %d, last_flushed_trans_id &quot;
l_string|&quot;%lu&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
comma
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
)paren
suffix:semicolon
id|valid_journal_header
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* now, we try to read the first unflushed offset.  If it is not valid, &n;    ** there is nothing more we can do, and it makes no sense to read &n;    ** through the whole log.&n;    */
id|d_bh
op_assign
id|journ_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|journal_transaction_is_valid
c_func
(paren
id|p_s_sb
comma
id|d_bh
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|continue_replay
op_assign
l_int|0
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_goto
id|start_log_replay
suffix:semicolon
)brace
r_if
c_cond
(paren
id|continue_replay
op_logical_and
id|bdev_read_only
c_func
(paren
id|p_s_sb-&gt;s_bdev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;clm-2076: device is readonly, unable to replay log&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ok, there are transactions that need to be replayed.  start with the first log block, find&n;  ** all the valid transactions, and pick out the oldest.&n;  */
r_while
c_loop
(paren
id|continue_replay
op_logical_and
id|cur_dblock
OL
(paren
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
(brace
id|d_bh
op_assign
id|reiserfs_breada
c_func
(paren
id|p_s_sb
comma
id|cur_dblock
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|journal_transaction_is_valid
c_func
(paren
id|p_s_sb
comma
id|d_bh
comma
op_amp
id|oldest_invalid_trans_id
comma
op_amp
id|newest_mount_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|oldest_start
op_eq
l_int|0
)paren
(brace
multiline_comment|/* init all oldest_ values */
id|oldest_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
id|oldest_start
op_assign
id|d_bh-&gt;b_blocknr
suffix:semicolon
id|newest_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1179: Setting &quot;
l_string|&quot;oldest_start to offset %lu, trans_id %lu&bslash;n&quot;
comma
id|oldest_start
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|oldest_trans_id
OG
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
)paren
(brace
multiline_comment|/* one we just read was older */
id|oldest_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
id|oldest_start
op_assign
id|d_bh-&gt;b_blocknr
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1180: Resetting &quot;
l_string|&quot;oldest_start to offset %lu, trans_id %lu&bslash;n&quot;
comma
id|oldest_start
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newest_mount_id
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
(brace
id|newest_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1299: Setting &quot;
l_string|&quot;newest_mount_id to %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
suffix:semicolon
)brace
id|cur_dblock
op_add_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|cur_dblock
op_increment
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
)brace
id|start_log_replay
suffix:colon
id|cur_dblock
op_assign
id|oldest_start
suffix:semicolon
r_if
c_cond
(paren
id|oldest_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1206: Starting replay &quot;
l_string|&quot;from offset %lu, trans_id %lu&bslash;n&quot;
comma
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
id|replay_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|continue_replay
op_logical_and
id|oldest_trans_id
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|journal_read_transaction
c_func
(paren
id|p_s_sb
comma
id|cur_dblock
comma
id|oldest_start
comma
id|oldest_trans_id
comma
id|newest_mount_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|cur_dblock
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|replay_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur_dblock
op_eq
id|oldest_start
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldest_trans_id
op_eq
l_int|0
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1225: No valid &quot;
l_string|&quot;transactions found&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* j_start does not get set correctly if we don&squot;t replay any transactions.&n;  ** if we had a valid journal_header, set j_start to the first unflushed transaction value,&n;  ** copy the trans_id from the header&n;  */
r_if
c_cond
(paren
id|valid_journal_header
op_logical_and
id|replay_count
op_eq
l_int|0
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
op_plus
l_int|1
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_mount_id
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
op_assign
id|newest_mount_id
op_plus
l_int|1
suffix:semicolon
)brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1299: Setting &quot;
l_string|&quot;newest_mount_id to %lu&bslash;n&quot;
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first_unflushed_offset
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
r_if
c_cond
(paren
id|replay_count
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs: replayed %d transactions in %lu seconds&bslash;n&quot;
comma
id|replay_count
comma
id|CURRENT_TIME
op_minus
id|start
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bdev_read_only
c_func
(paren
id|p_s_sb-&gt;s_bdev
)paren
op_logical_and
id|_update_journal_header_block
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
)paren
)paren
(brace
multiline_comment|/* replay failed, caller must call free_journal_ram and abort&n;      ** the mount&n;      */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|reiserfs_journal_commit_task
r_struct
id|reiserfs_journal_commit_task
(brace
DECL|member|p_s_sb
r_struct
id|super_block
op_star
id|p_s_sb
suffix:semicolon
DECL|member|jindex
r_int
id|jindex
suffix:semicolon
DECL|member|wake_on_finish
r_int
id|wake_on_finish
suffix:semicolon
multiline_comment|/* if this is one, we wake the task_done queue, if it&n;                       ** is zero, we free the whole struct on finish&n;&t;&t;       */
DECL|member|self
r_struct
id|reiserfs_journal_commit_task
op_star
id|self
suffix:semicolon
DECL|member|task_done
r_struct
id|wait_queue
op_star
id|task_done
suffix:semicolon
DECL|member|task
r_struct
id|tq_struct
id|task
suffix:semicolon
)brace
suffix:semicolon
DECL|function|reiserfs_journal_commit_task_func
r_static
r_void
id|reiserfs_journal_commit_task_func
c_func
(paren
r_struct
id|reiserfs_journal_commit_task
op_star
id|ct
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
id|jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|ct-&gt;p_s_sb
)paren
op_plus
id|ct-&gt;jindex
suffix:semicolon
id|flush_commit_list
c_func
(paren
id|ct-&gt;p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|ct-&gt;p_s_sb
)paren
op_plus
id|ct-&gt;jindex
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_len
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|kupdate_one_transaction
c_func
(paren
id|ct-&gt;p_s_sb
comma
id|jl
)paren
suffix:semicolon
)brace
id|reiserfs_kfree
c_func
(paren
id|ct-&gt;self
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit_task
)paren
comma
id|ct-&gt;p_s_sb
)paren
suffix:semicolon
)brace
DECL|function|setup_commit_task_arg
r_static
r_void
id|setup_commit_task_arg
c_func
(paren
r_struct
id|reiserfs_journal_commit_task
op_star
id|ct
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|jindex
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ct
)paren
(brace
id|reiserfs_panic
c_func
(paren
l_int|NULL
comma
l_string|&quot;journal-1360: setup_commit_task_arg called with NULL struct&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ct-&gt;p_s_sb
op_assign
id|p_s_sb
suffix:semicolon
id|ct-&gt;jindex
op_assign
id|jindex
suffix:semicolon
id|ct-&gt;task_done
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ct-&gt;task.list
)paren
suffix:semicolon
id|ct-&gt;task.sync
op_assign
l_int|0
suffix:semicolon
id|ct-&gt;task.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|reiserfs_journal_commit_task_func
suffix:semicolon
id|ct-&gt;self
op_assign
id|ct
suffix:semicolon
id|ct-&gt;task.data
op_assign
(paren
r_void
op_star
)paren
id|ct
suffix:semicolon
)brace
DECL|function|commit_flush_async
r_static
r_void
id|commit_flush_async
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|jindex
)paren
(brace
r_struct
id|reiserfs_journal_commit_task
op_star
id|ct
suffix:semicolon
multiline_comment|/* using GFP_NOFS, GFP_KERNEL could try to flush inodes, which will try&n;  ** to start/join a transaction, which will deadlock&n;  */
id|ct
op_assign
id|reiserfs_kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit_task
)paren
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
)paren
(brace
id|setup_commit_task_arg
c_func
(paren
id|ct
comma
id|p_s_sb
comma
id|jindex
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
(paren
id|ct-&gt;task
)paren
comma
op_amp
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_wait
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1540: kmalloc failed, doing sync commit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** this is the commit thread.  It is started with kernel_thread on&n;** FS mount, and journal_release() waits for it to exit.&n;**&n;** It could do a periodic commit, but there is a lot code for that&n;** elsewhere right now, and I only wanted to implement this little&n;** piece for starters.&n;**&n;** All we do here is sleep on the j_commit_thread_wait wait queue, and&n;** then run the per filesystem commit task queue when we wakeup.&n;*/
DECL|function|reiserfs_journal_commit_thread
r_static
r_int
id|reiserfs_journal_commit_thread
c_func
(paren
r_void
op_star
id|nullp
)paren
(brace
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kreiserfsd&quot;
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
id|TQ_ACTIVE
c_func
(paren
id|reiserfs_commit_thread_tq
)paren
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
)brace
multiline_comment|/* if there aren&squot;t any more filesystems left, break */
r_if
c_cond
(paren
id|reiserfs_mounted_fs_count
op_le
l_int|0
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
id|refrigerator
c_func
(paren
id|PF_IOTHREAD
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|reiserfs_commit_thread_wait
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_list_init
r_static
r_void
id|journal_list_init
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_commit_wait
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_flush_wait
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|release_journal_dev
r_static
r_int
id|release_journal_dev
c_func
(paren
r_struct
id|super_block
op_star
id|super
comma
r_struct
id|reiserfs_journal
op_star
id|journal
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_ne
l_int|NULL
)paren
(brace
id|result
op_assign
id|blkdev_put
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_bd
comma
id|BDEV_FS
)paren
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
op_ne
l_int|NULL
)paren
(brace
id|result
op_assign
id|filp_close
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
comma
l_int|NULL
)paren
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;sh-457: release_journal_dev: Cannot release journal device: %i&quot;
comma
id|result
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|journal_init_dev
r_static
r_int
id|journal_init_dev
c_func
(paren
r_struct
id|super_block
op_star
id|super
comma
r_struct
id|reiserfs_journal
op_star
id|journal
comma
r_const
r_char
op_star
id|jdev_name
)paren
(brace
r_int
id|result
suffix:semicolon
id|dev_t
id|jdev
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_assign
l_int|NULL
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
l_int|NULL
suffix:semicolon
id|jdev
op_assign
id|SB_ONDISK_JOURNAL_DEVICE
c_func
(paren
id|super
)paren
ques
c_cond
id|SB_ONDISK_JOURNAL_DEVICE
c_func
(paren
id|super
)paren
suffix:colon
id|super-&gt;s_dev
suffix:semicolon
multiline_comment|/* there is no &quot;jdev&quot; option and journal is on separate device */
r_if
c_cond
(paren
(paren
op_logical_neg
id|jdev_name
op_logical_or
op_logical_neg
id|jdev_name
(braket
l_int|0
)braket
)paren
)paren
(brace
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_assign
id|bdget
c_func
(paren
id|jdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal
op_member_access_from_pointer
id|j_dev_bd
)paren
(brace
id|result
op_assign
id|blkdev_get
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_bd
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_FS
)paren
suffix:semicolon
)brace
r_else
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sh-458: journal_init_dev: cannot init journal device&bslash;n &squot;%s&squot;: %i&quot;
comma
id|kdevname
c_func
(paren
id|to_kdev_t
c_func
(paren
id|jdev
)paren
)paren
comma
id|result
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
id|filp_open
c_func
(paren
id|jdev_name
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
)paren
)paren
(brace
r_struct
id|inode
op_star
id|jdev_inode
suffix:semicolon
id|jdev_inode
op_assign
id|journal
op_member_access_from_pointer
id|j_dev_file
op_member_access_from_pointer
id|f_dentry
op_member_access_from_pointer
id|d_inode
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_assign
id|jdev_inode
op_member_access_from_pointer
id|i_bdev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|jdev_inode
op_member_access_from_pointer
id|i_mode
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal_init_dev: &squot;%s&squot; is not a block device&quot;
comma
id|jdev_name
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOTBLK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jdev_inode
op_member_access_from_pointer
id|i_bdev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal_init_dev: bdev unintialized for &squot;%s&squot;&quot;
comma
id|jdev_name
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
op_assign
id|blkdev_get
c_func
(paren
id|jdev_inode
op_member_access_from_pointer
id|i_bdev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
comma
l_int|0
comma
id|BDEV_FS
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal_init_dev: Cannot load device &squot;%s&squot;: %i&quot;
comma
id|jdev_name
comma
id|result
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* ok */
id|jdev
op_assign
id|jdev_inode
op_member_access_from_pointer
id|i_bdev
op_member_access_from_pointer
id|bd_dev
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|PTR_ERR
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
)paren
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;journal_init_dev: Cannot open &squot;%s&squot;: %i&quot;
comma
id|jdev_name
comma
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|release_journal_dev
c_func
(paren
id|super
comma
id|journal
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;journal_init_dev: journal device: %s&quot;
comma
id|kdevname
c_func
(paren
id|to_kdev_t
c_func
(paren
id|jdev
)paren
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n;** must be called once on fs mount.  calls journal_read for you&n;*/
DECL|function|journal_init
r_int
id|journal_init
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_const
r_char
op_star
id|j_dev_name
comma
r_int
id|old_format
)paren
(brace
r_int
id|num_cnodes
op_assign
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
op_star
l_int|2
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhjh
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit
)paren
op_ne
l_int|4096
op_logical_or
r_sizeof
(paren
r_struct
id|reiserfs_journal_desc
)paren
op_ne
l_int|4096
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1249: commit or desc struct not 4096 %Zd %Zd&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit
)paren
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_desc
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|journal
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1256: unable to get memory for journal structure&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|journal
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal
)paren
)paren
suffix:semicolon
multiline_comment|/* reserved for journal area support */
id|SB_JOURNAL_1st_RESERVED_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_assign
(paren
id|old_format
ques
c_cond
id|REISERFS_OLD_DISK_OFFSET_IN_BYTES
op_div
id|p_s_sb-&gt;s_blocksize
op_plus
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
suffix:colon
id|REISERFS_DISK_OFFSET_IN_BYTES
op_div
id|p_s_sb-&gt;s_blocksize
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal_init_dev
c_func
(paren
id|p_s_sb
comma
id|journal
comma
id|j_dev_name
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sh-462: unable to initialize jornal device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* read journal header */
id|bhjh
op_assign
id|journ_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhjh
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sh-459: unable to read  journal header&bslash;n&quot;
)paren
suffix:semicolon
id|release_journal_dev
c_func
(paren
id|p_s_sb
comma
id|journal
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|bhjh-&gt;b_data
)paren
suffix:semicolon
multiline_comment|/* make sure that journal matches to the super block */
r_if
c_cond
(paren
id|is_reiserfs_jr
c_func
(paren
id|rs
)paren
op_logical_and
(paren
id|jh-&gt;jh_journal.jp_journal_magic
op_ne
id|sb_jp_journal_magic
c_func
(paren
id|rs
)paren
)paren
)paren
(brace
r_char
id|jname
(braket
l_int|32
)braket
suffix:semicolon
r_char
id|fname
(braket
l_int|32
)braket
suffix:semicolon
id|strcpy
c_func
(paren
id|jname
comma
id|bdevname
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_dev_bd
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|fname
comma
id|p_s_sb-&gt;s_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sh-460: journal header magic %x (device %s) does not match &quot;
l_string|&quot;to magic found in super block %x (device %s)&bslash;n&quot;
comma
id|jh-&gt;jh_journal.jp_journal_magic
comma
id|jname
comma
id|sb_jp_journal_magic
c_func
(paren
id|rs
)paren
comma
id|fname
)paren
suffix:semicolon
id|brelse
(paren
id|bhjh
)paren
suffix:semicolon
id|release_journal_dev
c_func
(paren
id|p_s_sb
comma
id|journal
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_assign
id|le32_to_cpu
(paren
id|jh-&gt;jh_journal.jp_journal_trans_max
)paren
suffix:semicolon
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|p_s_sb
)paren
op_assign
id|le32_to_cpu
(paren
id|jh-&gt;jh_journal.jp_journal_max_batch
)paren
suffix:semicolon
id|SB_JOURNAL_MAX_COMMIT_AGE
c_func
(paren
id|p_s_sb
)paren
op_assign
id|le32_to_cpu
(paren
id|jh-&gt;jh_journal.jp_journal_max_commit_age
)paren
suffix:semicolon
id|SB_JOURNAL_MAX_TRANS_AGE
c_func
(paren
id|p_s_sb
)paren
op_assign
id|JOURNAL_MAX_TRANS_AGE
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
multiline_comment|/* make sure these parameters are available, assign it if they are not */
id|__u32
id|initial
op_assign
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|__u32
id|ratio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p_s_sb-&gt;s_blocksize
OL
l_int|4096
)paren
id|ratio
op_assign
l_int|4096
op_div
id|p_s_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
op_div
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
OL
id|JOURNAL_MIN_RATIO
)paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_assign
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
op_div
id|JOURNAL_MIN_RATIO
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
OG
id|JOURNAL_TRANS_MAX_DEFAULT
op_div
id|ratio
)paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_assign
id|JOURNAL_TRANS_MAX_DEFAULT
op_div
id|ratio
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
OL
id|JOURNAL_TRANS_MIN_DEFAULT
op_div
id|ratio
)paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_assign
id|JOURNAL_TRANS_MIN_DEFAULT
op_div
id|ratio
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_ne
id|initial
)paren
id|printk
(paren
l_string|&quot;sh-461: journal_init: wrong transaction max size (%u). Changed to %u&bslash;n&quot;
comma
id|initial
comma
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|p_s_sb
)paren
op_assign
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_star
id|JOURNAL_MAX_BATCH_DEFAULT
op_div
id|JOURNAL_TRANS_MAX_DEFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
multiline_comment|/*we have the file system was created by old version of mkreiserfs &n;      so this field contains zero value */
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_assign
id|JOURNAL_TRANS_MAX_DEFAULT
suffix:semicolon
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|p_s_sb
)paren
op_assign
id|JOURNAL_MAX_BATCH_DEFAULT
suffix:semicolon
id|SB_JOURNAL_MAX_COMMIT_AGE
c_func
(paren
id|p_s_sb
)paren
op_assign
id|JOURNAL_MAX_COMMIT_AGE
suffix:semicolon
multiline_comment|/* for blocksize &gt;= 4096 - max transaction size is 1024. For block size &lt; 4096&n;       trans max size is decreased proportionally */
r_if
c_cond
(paren
id|p_s_sb-&gt;s_blocksize
OL
l_int|4096
)paren
(brace
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_div_assign
(paren
l_int|4096
op_div
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|p_s_sb
)paren
op_assign
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
)paren
op_star
l_int|9
op_div
l_int|10
suffix:semicolon
)brace
)brace
id|printk
(paren
l_string|&quot;Reiserfs journal params: device %s, size %u, &quot;
l_string|&quot;journal first block %u, max trans len %u, max batch %u, &quot;
l_string|&quot;max commit age %u, max trans age %u&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_dev_bd
)paren
comma
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
comma
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|p_s_sb
)paren
comma
id|SB_JOURNAL_MAX_COMMIT_AGE
c_func
(paren
id|p_s_sb
)paren
comma
id|SB_JOURNAL_MAX_TRANS_AGE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|brelse
(paren
id|bhjh
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap_index
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_assign
op_minus
l_int|10000
suffix:semicolon
multiline_comment|/* make sure flush_old_commits does not try to flush a list while replay is on */
multiline_comment|/* clear out the journal list array */
id|memset
c_func
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_list
)paren
op_star
id|JOURNAL_LIST_COUNT
)paren
suffix:semicolon
id|journal_list_init
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|memset
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
l_int|0
comma
id|JOURNAL_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|journal_writers
comma
l_int|0
comma
r_sizeof
(paren
r_char
op_star
)paren
op_star
l_int|512
)paren
suffix:semicolon
multiline_comment|/* debug code */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_dirty_buffers
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_dirty_buffers_lock
)paren
suffix:semicolon
id|reiserfs_allocate_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
comma
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|allocate_bitmap_nodes
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bcount
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
l_int|NULL
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
l_int|NULL
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wait
)paren
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_assign
l_int|10
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
op_assign
l_int|10
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_state
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
op_assign
id|allocate_cnodes
c_func
(paren
id|num_cnodes
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_orig
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
ques
c_cond
id|num_cnodes
suffix:colon
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_used
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|0
suffix:semicolon
id|init_journal_hash
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
l_int|0
)braket
dot
id|j_list_bitmap
op_assign
id|get_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
l_int|0
)braket
dot
id|j_list_bitmap
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-2005, get_list_bitmap failed for journal list 0&bslash;n&quot;
)paren
suffix:semicolon
id|release_journal_dev
c_func
(paren
id|p_s_sb
comma
id|journal
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal_read
c_func
(paren
id|p_s_sb
)paren
OL
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;Replay Failure, unable to mount&bslash;n&quot;
)paren
suffix:semicolon
id|free_journal_ram
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|release_journal_dev
c_func
(paren
id|p_s_sb
comma
id|journal
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* once the read is done, we can set this&n;                                         where it belongs */
id|INIT_LIST_HEAD
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_prealloc_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
(paren
id|p_s_sb
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|reiserfs_mounted_fs_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_mounted_fs_count
op_le
l_int|1
)paren
(brace
id|kernel_thread
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|reiserfs_journal_commit_thread
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_VM
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** test for a polite end of the current transaction.  Used by file_write, and should&n;** be used by delete to make sure they don&squot;t write more than can fit inside a single&n;** transaction&n;*/
DECL|function|journal_transaction_should_end
r_int
id|journal_transaction_should_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
id|new_alloc
)paren
(brace
id|time_t
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
op_logical_or
(paren
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_len_alloc
op_plus
id|new_alloc
)paren
op_ge
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|th-&gt;t_super
)paren
op_logical_or
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
op_logical_or
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|SB_JOURNAL_MAX_TRANS_AGE
c_func
(paren
id|th-&gt;t_super
)paren
op_logical_or
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_cnode_free
OL
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|th-&gt;t_super
)paren
op_star
l_int|3
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this must be called inside a transaction, and requires the &n;** kernel_lock to be held&n;*/
DECL|function|reiserfs_block_writes
r_void
id|reiserfs_block_writes
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|1
suffix:semicolon
id|set_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* this must be called without a transaction started, and does not&n;** require BKL&n;*/
DECL|function|reiserfs_allow_writes
r_void
id|reiserfs_allow_writes
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|clear_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* this must be called without a transaction started, and does not&n;** require BKL&n;*/
DECL|function|reiserfs_wait_on_write_block
r_void
id|reiserfs_wait_on_write_block
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|wait_event
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_join_wait
comma
op_logical_neg
id|test_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_state
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* join == true if you must join an existing transaction.&n;** join == false if you can deal with waiting for others to finish&n;**&n;** this will block until the transaction is joinable.  send the number of blocks you&n;** expect to use in nblocks.&n;*/
DECL|function|do_journal_begin_r
r_static
r_int
id|do_journal_begin_r
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|join
)paren
(brace
id|time_t
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
r_int
id|old_trans_id
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;journal_begin&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|p_s_sb-&gt;s_flags
op_amp
id|MS_RDONLY
comma
l_string|&quot;clm-2078: calling journal_begin on readonly FS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|th-&gt;t_super
op_assign
id|p_s_sb
suffix:semicolon
multiline_comment|/* others will check this for the don&squot;t log flag */
r_return
l_int|0
suffix:semicolon
)brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.journal_being
)paren
suffix:semicolon
id|relock
suffix:colon
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_state
)paren
)paren
(brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.journal_relock_writers
)paren
suffix:semicolon
r_goto
id|relock
suffix:semicolon
)brace
multiline_comment|/* if there is no room in the journal OR&n;  ** if this transaction is too old, and we weren&squot;t called joinable, wait for it to finish before beginning &n;  ** we don&squot;t sleep if there aren&squot;t other writers&n;  */
r_if
c_cond
(paren
(paren
op_logical_neg
id|join
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_plus
id|nblocks
op_plus
l_int|2
)paren
op_ge
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|p_s_sb
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
OG
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
OG
l_int|0
op_logical_and
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|SB_JOURNAL_MAX_TRANS_AGE
c_func
(paren
id|p_s_sb
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
OL
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_star
l_int|3
)paren
)paren
)paren
(brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* allow others to finish this transaction */
multiline_comment|/* if writer count is 0, we can just force this transaction to end, and start&n;    ** a new one afterwards.&n;    */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_le
l_int|0
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|myth
suffix:semicolon
id|journal_join
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* but if the writer count isn&squot;t zero, we have to wait for the current writers to finish.&n;      ** They won&squot;t batch on transaction end once we set j_jlock&n;      */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|1
)paren
suffix:semicolon
id|old_trans_id
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_eq
id|old_trans_id
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
)brace
)brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.journal_relock_wcount
)paren
suffix:semicolon
r_goto
id|relock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_eq
l_int|0
)paren
(brace
multiline_comment|/* we are the first writer, set trans_id */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_assign
id|now
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_add_assign
id|nblocks
suffix:semicolon
id|th-&gt;t_blocks_logged
op_assign
l_int|0
suffix:semicolon
id|th-&gt;t_blocks_allocated
op_assign
id|nblocks
suffix:semicolon
id|th-&gt;t_super
op_assign
id|p_s_sb
suffix:semicolon
id|th-&gt;t_trans_id
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
suffix:semicolon
id|th-&gt;t_caller
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|p_s_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_join
r_static
r_int
id|journal_join
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_return
id|do_journal_begin_r
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|journal_begin
r_int
id|journal_begin
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_return
id|do_journal_begin_r
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* not used at all */
DECL|function|journal_prepare
r_int
id|journal_prepare
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** puts bh into the current transaction.  If it was already there, reorders removes the&n;** old pointers from the hash, and puts new ones in (to make sure replay happen in the right order).&n;**&n;** if it was dirty, cleans and files onto the clean list.  I can&squot;t let it be dirty again until the&n;** transaction is committed.&n;** &n;** if j_len, is bigger than j_len_alloc, it pushes j_len_alloc to 10 + j_len.&n;*/
DECL|function|journal_mark_dirty
r_int
id|journal_mark_dirty
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count_already_incd
op_assign
l_int|0
suffix:semicolon
r_int
id|prepared
op_assign
l_int|0
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.mark_dirty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;t_trans_id
op_ne
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1577: handle trans id %ld != current trans id %ld&bslash;n&quot;
comma
id|th-&gt;t_trans_id
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
)brace
id|p_s_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|prepared
op_assign
id|test_and_clear_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/* already in this transaction, we are done */
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.mark_dirty_already
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this must be turned into a panic instead of a warning.  We can&squot;t allow&n;  ** a dirty or journal_dirty or locked buffer to be logged, as some changes&n;  ** could get to disk too early.  NOT GOOD.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|prepared
op_logical_or
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1777: buffer %lu bad state %cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|prepared
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_locked
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_dirty
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
)paren
suffix:semicolon
id|show_reiserfs_locks
c_func
(paren
)paren
suffix:semicolon
)brace
id|count_already_incd
op_assign
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1409: journal_mark_dirty returning because j_wcount was %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* this error means I&squot;ve screwed up, and we&squot;ve overflowed the transaction.  &n;  ** Nothing can be done here, except make the FS readonly or panic.&n;  */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_ge
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1413: journal_mark_dirty: j_len (%lu) is too big&bslash;n&quot;
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|count_already_incd
op_assign
l_int|1
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.mark_dirty_notjournal
)paren
suffix:semicolon
id|mark_buffer_notjournal_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* must double check after getting lock */
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
OG
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/* now put this guy on the end */
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
id|cn
op_assign
id|get_cnode
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;get_cnode failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;t_blocks_logged
op_eq
id|th-&gt;t_blocks_allocated
)paren
(brace
id|th-&gt;t_blocks_allocated
op_add_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_add_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
)brace
id|th-&gt;t_blocks_logged
op_increment
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_increment
suffix:semicolon
id|cn-&gt;bh
op_assign
id|bh
suffix:semicolon
id|cn-&gt;blocknr
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|cn-&gt;sb
op_assign
id|p_s_sb
suffix:semicolon
id|cn-&gt;jlist
op_assign
l_int|NULL
suffix:semicolon
id|insert_journal_hash
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|cn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count_already_incd
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
id|cn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cn-&gt;prev
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
suffix:semicolon
id|cn-&gt;bh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last-&gt;next
op_assign
id|cn
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
id|cn
suffix:semicolon
)brace
r_else
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
id|cn
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
id|cn
suffix:semicolon
)brace
id|done
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** if buffer already in current transaction, do a journal_mark_dirty&n;** otherwise, just mark it dirty and move on.  Used for writes to meta blocks&n;** that don&squot;t need journaling&n;*/
DECL|function|journal_mark_dirty_nolog
r_int
id|journal_mark_dirty_nolog
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
op_logical_or
id|buffer_journaled
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
r_return
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|bh-&gt;b_blocknr
)paren
)paren
(brace
r_return
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|bh
)paren
suffix:semicolon
)brace
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_end
r_int
id|journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_return
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* removes from the current transaction, relsing and descrementing any counters.  &n;** also files the removed buffer directly onto the clean list&n;**&n;** called by journal_mark_freed when a block has been deleted&n;**&n;** returns 1 if it cleaned and relsed the buffer. 0 otherwise&n;*/
DECL|function|remove_from_transaction
r_static
r_int
id|remove_from_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|blocknr
comma
r_int
id|already_cleaned
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
op_logical_or
op_logical_neg
id|cn-&gt;bh
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
id|bh
op_assign
id|cn-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;prev
)paren
(brace
id|cn-&gt;prev-&gt;next
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn-&gt;next
)paren
(brace
id|cn-&gt;next-&gt;prev
op_assign
id|cn-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn
op_eq
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn
op_eq
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
id|cn-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh
)paren
id|remove_journal_hash
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
l_int|NULL
comma
id|bh-&gt;b_blocknr
comma
l_int|0
)paren
suffix:semicolon
id|mark_buffer_not_journaled
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* don&squot;t log this one */
r_if
c_cond
(paren
op_logical_neg
id|already_cleaned
)paren
(brace
id|mark_buffer_notjournal_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1752: remove from trans, b_count &lt; 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|reiserfs_clean_and_file_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_decrement
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_decrement
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|cn
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;** for any cnode in a journal list, it can only be dirtied of all the&n;** transactions that include it are commited to disk.&n;** this checks through each transaction, and returns 1 if you are allowed to dirty,&n;** and 0 if you aren&squot;t&n;**&n;** it is called by dirty_journal_list, which is called after flush_commit_list has gotten all the log&n;** blocks for a given transaction on disk&n;**&n;*/
DECL|function|can_dirty
r_static
r_int
id|can_dirty
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|cn-&gt;sb
suffix:semicolon
r_int
r_int
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cur
op_assign
id|cn-&gt;hprev
suffix:semicolon
r_int
id|can_dirty
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* first test hprev.  These are all newer than cn, so any node here&n;  ** with the name block number and dev means this node can&squot;t be sent&n;  ** to disk right now.&n;  */
r_while
c_loop
(paren
id|cur
op_logical_and
id|can_dirty
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;jlist
op_logical_and
id|cur-&gt;bh
op_logical_and
id|cur-&gt;blocknr
op_logical_and
id|cur-&gt;sb
op_eq
id|sb
op_logical_and
id|cur-&gt;blocknr
op_eq
id|blocknr
)paren
(brace
id|can_dirty
op_assign
l_int|0
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hprev
suffix:semicolon
)brace
multiline_comment|/* then test hnext.  These are all older than cn.  As long as they&n;  ** are committed to the log, it is safe to write cn to disk&n;  */
id|cur
op_assign
id|cn-&gt;hnext
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_logical_and
id|can_dirty
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;jlist
op_logical_and
id|cur-&gt;jlist-&gt;j_len
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|cur-&gt;jlist-&gt;j_commit_left
)paren
)paren
OG
l_int|0
op_logical_and
id|cur-&gt;bh
op_logical_and
id|cur-&gt;blocknr
op_logical_and
id|cur-&gt;sb
op_eq
id|sb
op_logical_and
id|cur-&gt;blocknr
op_eq
id|blocknr
)paren
(brace
id|can_dirty
op_assign
l_int|0
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
r_return
id|can_dirty
suffix:semicolon
)brace
multiline_comment|/* syncs the commit blocks, but does not force the real buffers to disk&n;** will wait until the current transaction is done/commited before returning &n;*/
DECL|function|journal_end_sync
r_int
id|journal_end_sync
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_eq
l_int|0
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
)brace
r_return
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|COMMIT_NOW
op_or
id|WAIT
)paren
suffix:semicolon
)brace
DECL|function|show_reiserfs_locks
r_int
id|show_reiserfs_locks
c_func
(paren
r_void
)paren
(brace
id|dump_journal_writers
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** used to get memory back from async commits that are floating around&n;** and to reclaim any blocks deleted but unusable because their commits&n;** haven&squot;t hit disk yet.  called from bitmap.c&n;**&n;** if it starts flushing things, it ors SCHEDULE_OCCURRED into repeat.&n;** note, this is just if schedule has a chance of occuring.  I need to &n;** change flush_commit_lists to have a repeat parameter too.&n;**&n;*/
DECL|function|flush_async_commits
r_void
id|flush_async_commits
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|i
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** flushes any old transactions to disk&n;** ends the current transaction if it is too old&n;**&n;** also calls flush_journal_list with old_only == 1, which allows me to reclaim&n;** memory and such from the journal lists whose real blocks are all on disk.&n;**&n;** called by sync_dev_journal from buffer.c&n;*/
DECL|function|flush_old_commits
r_int
id|flush_old_commits
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|immediate
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|start
suffix:semicolon
id|time_t
id|now
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|start
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* safety check so we don&squot;t flush while we are replaying the log during mount */
r_if
c_cond
(paren
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* starting with oldest, loop until we get to the start */
id|i
op_assign
(paren
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|start
)paren
(brace
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
(paren
(paren
id|now
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_timestamp
)paren
OG
id|SB_JOURNAL_MAX_COMMIT_AGE
c_func
(paren
id|p_s_sb
)paren
op_logical_or
id|immediate
)paren
)paren
(brace
multiline_comment|/* we have to check again to be sure the current transaction did not change */
r_if
c_cond
(paren
id|i
op_ne
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|i
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
multiline_comment|/* now, check the current transaction.  If there are no writers, and it is too old, finish it, and&n;  ** force the commit blocks to disk&n;  */
r_if
c_cond
(paren
op_logical_neg
id|immediate
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_le
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
OG
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
OG
l_int|0
op_logical_and
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|SB_JOURNAL_MAX_TRANS_AGE
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|journal_join
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|immediate
)paren
(brace
multiline_comment|/* belongs above, but I wanted this to be very explicit as a special case.  If they say to &n;                             flush, we must be sure old transactions hit the disk too. */
id|journal_join
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
op_or
id|WAIT
)paren
suffix:semicolon
)brace
id|reiserfs_journal_kupdate
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** returns 0 if do_journal_end should return right away, returns 1 if do_journal_end should finish the commit&n;** &n;** if the current transaction is too old, but still has writers, this will wait on j_join_wait until all &n;** the writers are done.  By the time it wakes up, the transaction it was called has already ended, so it just&n;** flushes the commit list and returns 0.&n;**&n;** Won&squot;t batch when flush or commit_now is set.  Also won&squot;t batch when others are waiting on j_join_wait.&n;** &n;** Note, we can&squot;t allow the journal_end to proceed while there are still writers in the log.&n;*/
DECL|function|check_journal_end
r_static
r_int
id|check_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
(brace
id|time_t
id|now
suffix:semicolon
r_int
id|flush
op_assign
id|flags
op_amp
id|FLUSH_ALL
suffix:semicolon
r_int
id|commit_now
op_assign
id|flags
op_amp
id|COMMIT_NOW
suffix:semicolon
r_int
id|wait_on_commit
op_assign
id|flags
op_amp
id|WAIT
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_trans_id
op_ne
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1577: handle trans id %ld != current trans id %ld&bslash;n&quot;
comma
id|th-&gt;t_trans_id
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_sub_assign
(paren
id|th-&gt;t_blocks_allocated
op_minus
id|th-&gt;t_blocks_logged
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* &lt;= 0 is allowed.  unmounting might not call begin */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BUG, deal with case where j_len is 0, but people previously freed blocks need to be released &n;  ** will be dealt with by next transaction that actually writes something, but should be taken&n;  ** care of in this trans&n;  */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_eq
l_int|0
)paren
(brace
r_int
id|wcount
op_assign
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
OG
l_int|0
op_logical_and
id|wcount
op_le
l_int|0
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if wcount &gt; 0, and we are called to with flush or commit_now,&n;  ** we wait on j_join_wait.  We will wake up when the last writer has&n;  ** finished the transaction, and started it on its way to the disk.&n;  ** Then, we flush the commit or journal list, and just return 0 &n;  ** because the rest of journal end was already done for this transaction.&n;  */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flush
op_logical_or
id|commit_now
)paren
(brace
r_int
id|orig_jindex
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
op_assign
l_int|1
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* sleep while the current transaction is still j_jlocked */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_eq
id|th-&gt;t_trans_id
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_now
)paren
(brace
r_if
c_cond
(paren
id|wait_on_commit
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit_flush_async
c_func
(paren
id|p_s_sb
comma
id|orig_jindex
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* deal with old transactions where we are the last writers */
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|SB_JOURNAL_MAX_TRANS_AGE
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|commit_now
op_assign
l_int|1
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* don&squot;t batch when someone is waiting on j_join_wait */
multiline_comment|/* don&squot;t batch when syncing the commit or flushing the whole trans */
r_if
c_cond
(paren
op_logical_neg
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|flush
op_logical_and
op_logical_neg
id|commit_now
op_logical_and
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
OL
id|SB_JOURNAL_MAX_BATCH
c_func
(paren
id|p_s_sb
)paren
)paren
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
template_param
(paren
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_star
l_int|3
)paren
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bcount
op_increment
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
OG
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-003: journal_end: j_start (%ld) is too high&bslash;n&quot;
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** Does all the work that makes deleting blocks safe.&n;** when deleting a block mark BH_JNew, just remove it from the current transaction, clean it&squot;s buffer_head and move on.&n;** &n;** otherwise:&n;** set a bit for the block in the journal bitmap.  That will prevent it from being allocated for unformatted nodes&n;** before this transaction has finished.&n;**&n;** mark any cnodes for this block as BLOCK_FREED, and clear their bh pointers.  That will prevent any old transactions with&n;** this block from trying to flush to the real location.  Since we aren&squot;t removing the cnode from the journal_list_hash,&n;** the block can&squot;t be reallocated yet.&n;**&n;** Then remove it from the current transaction, decrementing any counters and filing it on the clean list.&n;*/
DECL|function|journal_mark_freed
r_int
id|journal_mark_freed
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|blocknr
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cleaned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
id|bh
op_assign
id|sb_get_hash_table
c_func
(paren
id|p_s_sb
comma
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_logical_and
id|buffer_dirty
(paren
id|bh
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;journal_mark_freed(dont_log): dirty buffer on hash list: %lx %ld&bslash;n&quot;
comma
id|bh-&gt;b_state
comma
id|blocknr
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bh
op_assign
id|sb_get_hash_table
c_func
(paren
id|p_s_sb
comma
id|blocknr
)paren
suffix:semicolon
multiline_comment|/* if it is journal new, we just remove it from this transaction */
r_if
c_cond
(paren
id|bh
op_logical_and
id|buffer_journal_new
c_func
(paren
id|bh
)paren
)paren
(brace
id|mark_buffer_notjournal_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
id|cleaned
op_assign
id|remove_from_transaction
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|cleaned
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the bit for this block in the journal bitmap for this transaction */
id|jb
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_list_bitmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1702: journal_mark_freed, journal_list_bitmap is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|set_bit_in_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|jb
)paren
suffix:semicolon
multiline_comment|/* Note, the entire while loop is not allowed to schedule.  */
r_if
c_cond
(paren
id|bh
)paren
(brace
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|cleaned
op_assign
id|remove_from_transaction
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|cleaned
)paren
suffix:semicolon
multiline_comment|/* find all older transactions with this block, make sure they don&squot;t try to write it out */
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|blocknr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|p_s_sb
op_eq
id|cn-&gt;sb
op_logical_and
id|blocknr
op_eq
id|cn-&gt;blocknr
)paren
(brace
id|set_bit
c_func
(paren
id|BLOCK_FREED
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cleaned
)paren
(brace
multiline_comment|/* remove_from_transaction will brelse the buffer if it was &n;&t;    ** in the current trans&n;&t;    */
id|mark_buffer_notjournal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
id|cleaned
op_assign
l_int|1
suffix:semicolon
id|put_bh
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|cn-&gt;bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-2138: cn-&gt;bh-&gt;b_count &lt; 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cn-&gt;jlist
)paren
(brace
multiline_comment|/* since we are clearing the bh, we MUST dec nonzerolen */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|cn-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
)brace
id|cn-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|cn
op_assign
id|cn-&gt;hnext
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|reiserfs_clean_and_file_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* get_hash grabs the buffer */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-2165: bh-&gt;b_count &lt; 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_update_inode_transaction
r_void
id|reiserfs_update_inode_transaction
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_index
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_assign
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_trans_id
suffix:semicolon
)brace
DECL|function|reiserfs_inode_in_this_transaction
r_static
r_int
id|reiserfs_inode_in_this_transaction
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_eq
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_logical_or
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_eq
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_commit_for_inode
r_void
id|reiserfs_commit_for_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
id|jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|sb
)paren
op_plus
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_index
suffix:semicolon
multiline_comment|/* is it from the current transaction, or from an unknown transaction? */
r_if
c_cond
(paren
id|reiserfs_inode_in_this_transaction
c_func
(paren
id|inode
)paren
)paren
(brace
id|journal_join
c_func
(paren
op_amp
id|th
comma
id|sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|journal_end_sync
c_func
(paren
op_amp
id|th
comma
id|sb
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jl-&gt;j_trans_id
op_eq
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
)paren
(brace
id|flush_commit_list
c_func
(paren
id|sb
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* if the transaction id does not match, this list is long since flushed&n;  ** and we don&squot;t have to do anything here&n;  */
)brace
DECL|function|reiserfs_restore_prepared_buffer
r_void
id|reiserfs_restore_prepared_buffer
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.restore_prepared
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
(paren
id|p_s_sb
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_return
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|tree_balance
op_star
id|cur_tb
suffix:semicolon
multiline_comment|/*&n;** before we can change a metadata block, we have to make sure it won&squot;t&n;** be written to disk while we are altering it.  So, we must:&n;** clean it&n;** wait on it.&n;** &n;*/
DECL|function|reiserfs_prepare_for_journal
r_void
id|reiserfs_prepare_for_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|wait
)paren
(brace
r_int
id|retry_count
op_assign
l_int|0
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.prepare
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
(paren
id|p_s_sb
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
op_logical_or
(paren
id|wait
op_logical_and
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|RFALSE
c_func
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
id|cur_tb
op_ne
l_int|NULL
comma
l_string|&quot;waiting while do_balance was running&bslash;n&quot;
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.prepare_retry
)paren
suffix:semicolon
id|retry_count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* &n;** long and ugly.  If flush, will not return until all commit&n;** blocks and all real buffers in the trans are on disk.&n;** If no_async, won&squot;t return until all commit blocks are on disk.&n;**&n;** keep reading, there are comments as you go along&n;*/
DECL|function|do_journal_end
r_static
r_int
id|do_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|next
comma
op_star
id|jl_cn
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|last_cn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
multiline_comment|/* commit bh */
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
multiline_comment|/* desc bh */
r_int
id|cur_write_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start index of current log write */
r_int
id|cur_blocks_left
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of journal blocks left to write */
r_int
id|old_start
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|jindex
suffix:semicolon
r_int
id|orig_jindex
suffix:semicolon
r_int
id|flush
op_assign
id|flags
op_amp
id|FLUSH_ALL
suffix:semicolon
r_int
id|commit_now
op_assign
id|flags
op_amp
id|COMMIT_NOW
suffix:semicolon
r_int
id|wait_on_commit
op_assign
id|flags
op_amp
id|WAIT
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
)paren
(brace
id|flags
op_or_assign
id|FLUSH_ALL
suffix:semicolon
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
)paren
(brace
id|flags
op_or_assign
id|COMMIT_NOW
suffix:semicolon
id|commit_now
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check_journal_end locks the journal, and unlocks if it does not return 1 &n;  ** it tells us if we should continue with the journal_end, or just return&n;  */
r_if
c_cond
(paren
op_logical_neg
id|check_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|flags
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check_journal_end might set these, check again */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
)paren
(brace
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
)paren
(brace
id|commit_now
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;  ** j must wait means we have to flush the log blocks, and the real blocks for&n;  ** this transaction&n;  */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
)paren
(brace
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef REISERFS_PREALLOCATE
id|reiserfs_discard_all_prealloc
c_func
(paren
id|th
)paren
suffix:semicolon
multiline_comment|/* it should not involve new blocks into&n;&t;&t;&t;&t;      * the transaction */
macro_line|#endif
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* setup description block */
id|d_bh
op_assign
id|journ_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
(paren
id|d_bh
)paren
op_member_access_from_pointer
id|b_data
suffix:semicolon
id|memset
c_func
(paren
id|desc
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_desc
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|desc-&gt;j_magic
comma
id|JOURNAL_DESC_MAGIC
comma
l_int|8
)paren
suffix:semicolon
id|desc-&gt;j_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
multiline_comment|/* setup commit block.  Don&squot;t write (keep it clean too) this one until after everyone else is written */
id|c_bh
op_assign
id|journ_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
id|memset
c_func
(paren
id|commit
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit
)paren
)paren
suffix:semicolon
id|commit-&gt;j_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|c_bh
)paren
suffix:semicolon
multiline_comment|/* init this journal list */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_older_commits_done
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_trans_id
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_timestamp
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_bh
op_assign
id|c_bh
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_start
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_len
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_nonzerolen
)paren
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_left
)paren
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
l_int|2
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_realblock
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* which is faster, locking/unlocking at the start and end of the for&n;  ** or locking once per iteration around the insert_journal_hash?&n;  ** eitherway, we are write locking insert_journal_hash.  The ENTIRE FOR&n;  ** LOOP MUST not cause schedule to occur.&n;  */
multiline_comment|/* for each real block, add it to the journal list hash,&n;  ** copy into real block index array in the commit or desc block&n;  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
suffix:semicolon
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|cn-&gt;bh-&gt;b_state
)paren
)paren
(brace
id|jl_cn
op_assign
id|get_cnode
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jl_cn
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1676, get_cnode returned NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_realblock
op_assign
id|jl_cn
suffix:semicolon
)brace
id|jl_cn-&gt;prev
op_assign
id|last_cn
suffix:semicolon
id|jl_cn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|last_cn
)paren
(brace
id|last_cn-&gt;next
op_assign
id|jl_cn
suffix:semicolon
)brace
id|last_cn
op_assign
id|jl_cn
suffix:semicolon
multiline_comment|/* make sure the block we are trying to log is not a block &n;         of journal or reserved area */
r_if
c_cond
(paren
id|is_block_in_log_or_reserved_area
c_func
(paren
id|p_s_sb
comma
id|cn-&gt;bh-&gt;b_blocknr
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-2332: Trying to log block %lu, which is a log block&bslash;n&quot;
comma
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|jl_cn-&gt;blocknr
op_assign
id|cn-&gt;bh-&gt;b_blocknr
suffix:semicolon
id|jl_cn-&gt;state
op_assign
l_int|0
suffix:semicolon
id|jl_cn-&gt;sb
op_assign
id|p_s_sb
suffix:semicolon
id|jl_cn-&gt;bh
op_assign
id|cn-&gt;bh
suffix:semicolon
id|jl_cn-&gt;jlist
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|insert_journal_hash
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|jl_cn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|JOURNAL_TRANS_HALF
)paren
(brace
id|desc-&gt;j_realblock
(braket
id|i
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit-&gt;j_realblock
(braket
id|i
op_minus
id|JOURNAL_TRANS_HALF
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|i
op_decrement
suffix:semicolon
)brace
)brace
id|desc-&gt;j_len
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
id|desc-&gt;j_mount_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
)paren
suffix:semicolon
id|desc-&gt;j_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
id|commit-&gt;j_len
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
multiline_comment|/* special check in case all buffers in the journal were marked for not logging */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_eq
l_int|0
)paren
(brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;journal-2020: do_journal_end: BAD desc-&gt;j_len is ZERO&bslash;n&quot;
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* first data block is j_start + 1, so add one to cur_write_start wherever you use it */
id|cur_write_start
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|cur_blocks_left
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
suffix:semicolon
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
suffix:semicolon
id|jindex
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start at one so we don&squot;t get the desc again */
r_while
c_loop
(paren
id|cur_blocks_left
OG
l_int|0
)paren
(brace
multiline_comment|/* copy all the real blocks into log area.  dirty log blocks */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|cn-&gt;bh-&gt;b_state
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp_bh
suffix:semicolon
id|tmp_bh
op_assign
id|journ_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|cur_write_start
op_plus
id|jindex
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|tmp_bh
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp_bh-&gt;b_data
comma
id|cn-&gt;bh-&gt;b_data
comma
id|cn-&gt;bh-&gt;b_size
)paren
suffix:semicolon
id|jindex
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* JDirty cleared sometime during transaction.  don&squot;t log this one */
id|printk
c_func
(paren
l_string|&quot;journal-2048: do_journal_end: BAD, buffer in journal hash, but not JDirty!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
id|cur_blocks_left
op_decrement
suffix:semicolon
)brace
multiline_comment|/* we are done  with both the c_bh and d_bh, but&n;  ** c_bh must be written after all other commit blocks,&n;  ** so we dirty/relse c_bh in flush_commit_list, with commit_left &lt;= 1.&n;  */
multiline_comment|/* now loop through and mark all buffers from this transaction as JDirty_wait&n;  ** clear the JDirty bit, clear BH_JNew too.  &n;  ** if they weren&squot;t JDirty, they weren&squot;t logged, just relse them and move on&n;  */
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_JNew
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JDirty_wait
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|brelse
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
id|next
op_assign
id|cn-&gt;next
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|cn
)paren
suffix:semicolon
id|cn
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* unlock the journal list for committing and flushing */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|orig_jindex
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|jindex
op_assign
(paren
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_assign
id|jindex
suffix:semicolon
multiline_comment|/* write any buffers that must hit disk before this commit is done */
id|fsync_buffers_list
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_dirty_buffers_lock
)paren
comma
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_dirty_buffers
)paren
)paren
suffix:semicolon
multiline_comment|/* honor the flush and async wishes from the caller */
r_if
c_cond
(paren
id|flush
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|commit_now
)paren
(brace
r_if
c_cond
(paren
id|wait_on_commit
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit_flush_async
c_func
(paren
id|p_s_sb
comma
id|orig_jindex
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* reset journal values for the next transaction */
id|old_start
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
l_int|2
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bcount
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
l_int|NULL
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
l_int|NULL
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_increment
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
op_assign
l_int|0
suffix:semicolon
id|init_journal_hash
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* if the next transaction has any chance of wrapping, flush &n;  ** transactions that might get overwritten.  If any journal lists are very &n;  ** old flush them as well.  &n;  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jindex
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_le
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_start
)paren
(brace
r_if
c_cond
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
)paren
op_ge
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_start
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
)paren
OG
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|SB_JOURNAL_TRANS_MAX
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
op_ge
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_start
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* this check should always be run, to send old lists to disk */
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_timestamp
OL
(paren
id|CURRENT_TIME
op_minus
(paren
id|SB_JOURNAL_MAX_TRANS_AGE
c_func
(paren
id|p_s_sb
)paren
op_star
l_int|4
)paren
)paren
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if the next journal_list is still in use, flush it */
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_len
op_ne
l_int|0
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t want anyone flushing the new transaction&squot;s list */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_list_bitmap
op_assign
id|get_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_list_bitmap
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1996: do_journal_end, could not get a list bitmap&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* wake up any body waiting to join. */
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
