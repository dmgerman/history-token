multiline_comment|/*&n;** Write ahead logging implementation copyright Chris Mason 2000&n;**&n;** The background commits make this code very interelated, and &n;** overly complex.  I need to rethink things a bit....The major players:&n;**&n;** journal_begin -- call with the number of blocks you expect to log.  &n;**                  If the current transaction is too&n;** &t;&t;    old, it will block until the current transaction is &n;** &t;&t;    finished, and then start a new one.&n;**&t;&t;    Usually, your transaction will get joined in with &n;**                  previous ones for speed.&n;**&n;** journal_join  -- same as journal_begin, but won&squot;t block on the current &n;**                  transaction regardless of age.  Don&squot;t ever call&n;**                  this.  Ever.  There are only two places it should be &n;**                  called from, and they are both inside this file.&n;**&n;** journal_mark_dirty -- adds blocks into this transaction.  clears any flags &n;**                       that might make them get sent to disk&n;**                       and then marks them BH_JDirty.  Puts the buffer head &n;**                       into the current transaction hash.  &n;**&n;** journal_end -- if the current transaction is batchable, it does nothing&n;**                   otherwise, it could do an async/synchronous commit, or&n;**                   a full flush of all log and real blocks in the &n;**                   transaction.&n;**&n;** flush_old_commits -- if the current transaction is too old, it is ended and &n;**                      commit blocks are sent to disk.  Forces commit blocks &n;**                      to disk for all backgrounded commits that have been &n;**                      around too long.&n;**&t;&t;     -- Note, if you call this as an immediate flush from &n;**&t;&t;        from within kupdate, it will ignore the immediate flag&n;**&n;** The commit thread -- a writer process for async commits.  It allows a &n;**                      a process to request a log flush on a task queue.&n;**                      the commit will happen once the commit thread wakes up.&n;**                      The benefit here is the writer (with whatever&n;**                      related locks it has) doesn&squot;t have to wait for the&n;**                      log blocks to hit disk if it doesn&squot;t want to.&n;*/
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#else
macro_line|#include &quot;nokernel.h&quot;
macro_line|#endif
multiline_comment|/* the number of mounted filesystems.  This is used to decide when to&n;** start and kill the commit thread&n;*/
DECL|variable|reiserfs_mounted_fs_count
r_static
r_int
id|reiserfs_mounted_fs_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wake this up when you add something to the commit thread task queue */
DECL|variable|reiserfs_commit_thread_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|reiserfs_commit_thread_wait
)paren
suffix:semicolon
multiline_comment|/* wait on this if you need to be sure you task queue entries have been run */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
DECL|variable|reiserfs_commit_thread_tq
id|DECLARE_TASK_QUEUE
c_func
(paren
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
DECL|macro|JOURNAL_TRANS_HALF
mdefine_line|#define JOURNAL_TRANS_HALF 1018   /* must be correct to keep the desc and commit structs at 4k */
multiline_comment|/* cnode stat bits.  Move these into reiserfs_fs.h */
DECL|macro|BLOCK_FREED
mdefine_line|#define BLOCK_FREED 2&t;&t;/* this block was freed, and can&squot;t be written.  */
DECL|macro|BLOCK_FREED_HOLDER
mdefine_line|#define BLOCK_FREED_HOLDER 3    /* this block was freed during this transaction, and can&squot;t be written */
DECL|macro|BLOCK_NEEDS_FLUSH
mdefine_line|#define BLOCK_NEEDS_FLUSH 4&t;/* used in flush_journal_list */
multiline_comment|/* flags for do_journal_end */
DECL|macro|FLUSH_ALL
mdefine_line|#define FLUSH_ALL   1&t;&t;/* flush commit and real blocks */
DECL|macro|COMMIT_NOW
mdefine_line|#define COMMIT_NOW  2&t;&t;/* end and commit this transaction */
DECL|macro|WAIT
mdefine_line|#define WAIT        4&t;&t;/* wait for the log blocks to hit the disk*/
multiline_comment|/* state bits for the journal */
DECL|macro|WRITERS_BLOCKED
mdefine_line|#define WRITERS_BLOCKED 1      /* set when new writers not allowed */
r_static
r_int
id|do_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
comma
r_struct
id|super_block
op_star
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|flush_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
suffix:semicolon
r_static
r_int
id|flush_commit_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
suffix:semicolon
r_static
r_int
id|can_dirty
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
suffix:semicolon
DECL|function|init_journal_hash
r_static
r_void
id|init_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|memset
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
l_int|0
comma
id|JOURNAL_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** clears BH_Dirty and sticks the buffer on the clean list.  Called because I can&squot;t allow refile_buffer to&n;** make schedule happen after I&squot;ve freed a block.  Look at remove_from_transaction and journal_mark_freed for&n;** more details.&n;*/
DECL|function|reiserfs_clean_and_file_buffer
r_static
r_int
id|reiserfs_clean_and_file_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|BUF_CLEAN
)paren
(brace
id|reiserfs_file_buffer
c_func
(paren
id|bh
comma
id|BUF_CLEAN
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|reiserfs_bitmap_node
op_star
DECL|function|allocate_bitmap_node
id|allocate_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
suffix:semicolon
r_static
r_int
id|id
op_assign
l_int|0
suffix:semicolon
id|bn
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|bn-&gt;data
op_assign
id|kmalloc
c_func
(paren
id|p_s_sb-&gt;s_blocksize
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn-&gt;data
)paren
(brace
id|kfree
c_func
(paren
id|bn
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bn-&gt;id
op_assign
id|id
op_increment
suffix:semicolon
id|memset
c_func
(paren
id|bn-&gt;data
comma
l_int|0
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bn-&gt;list
)paren
suffix:semicolon
r_return
id|bn
suffix:semicolon
)brace
r_static
r_struct
id|reiserfs_bitmap_node
op_star
DECL|function|get_bitmap_node
id|get_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes.next
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_used_bitmap_nodes
op_increment
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|entry
op_ne
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
(brace
id|bn
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|reiserfs_bitmap_node
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bn-&gt;data
comma
l_int|0
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_decrement
suffix:semicolon
r_return
id|bn
suffix:semicolon
)brace
id|bn
op_assign
id|allocate_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn
)paren
(brace
id|current-&gt;policy
op_assign
id|SCHED_YIELD
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_return
id|bn
suffix:semicolon
)brace
DECL|function|free_bitmap_node
r_static
r_inline
r_void
id|free_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_used_bitmap_nodes
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
OG
id|REISERFS_MAX_BITMAP_NODES
)paren
(brace
id|kfree
c_func
(paren
id|bn-&gt;data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bn
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|bn-&gt;list
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_increment
suffix:semicolon
)brace
)brace
DECL|function|allocate_bitmap_nodes
r_static
r_void
id|allocate_bitmap_nodes
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|REISERFS_MIN_BITMAP_NODES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bn
op_assign
id|allocate_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bn
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|bn-&gt;list
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_increment
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
singleline_comment|// this is ok, we&squot;ll try again when more are needed 
)brace
)brace
)brace
DECL|function|set_bit_in_list_bitmap
r_static
r_int
id|set_bit_in_list_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|block
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
)paren
(brace
r_int
id|bmap_nr
op_assign
id|block
op_div
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_int
id|bit_nr
op_assign
id|block
op_mod
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
)paren
(brace
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_assign
id|get_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|bit_nr
comma
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_bitmap_list
r_static
r_void
id|cleanup_bitmap_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|jb-&gt;bitmaps
(braket
id|i
)braket
)paren
(brace
id|free_bitmap_node
c_func
(paren
id|p_s_sb
comma
id|jb-&gt;bitmaps
(braket
id|i
)braket
)paren
suffix:semicolon
id|jb-&gt;bitmaps
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** only call this on FS unmount.&n;*/
DECL|function|free_list_bitmaps
r_static
r_int
id|free_list_bitmaps
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb_array
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jb
op_assign
id|jb_array
op_plus
id|i
suffix:semicolon
id|jb-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|cleanup_bitmap_list
c_func
(paren
id|p_s_sb
comma
id|jb
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|jb-&gt;bitmaps
)paren
suffix:semicolon
id|jb-&gt;bitmaps
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_bitmap_nodes
r_static
r_int
id|free_bitmap_nodes
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|list_head
op_star
id|next
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes.next
suffix:semicolon
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
(brace
id|bn
op_assign
id|list_entry
c_func
(paren
id|next
comma
r_struct
id|reiserfs_bitmap_node
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|next
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bn-&gt;data
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bn
)paren
suffix:semicolon
id|next
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes.next
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_free_bitmap_nodes
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** get memory for JOURNAL_NUM_BITMAPS worth of bitmaps. &n;** jb_array is the array to be filled in.&n;*/
DECL|function|reiserfs_allocate_list_bitmaps
r_int
id|reiserfs_allocate_list_bitmaps
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb_array
comma
r_int
id|bmap_nr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_int
id|mem
op_assign
id|bmap_nr
op_star
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
op_star
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jb
op_assign
id|jb_array
op_plus
id|i
suffix:semicolon
id|jb-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|jb-&gt;bitmaps
op_assign
id|vmalloc
c_func
(paren
id|mem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb-&gt;bitmaps
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2000, unable to allocate bitmaps for journal lists&bslash;n&quot;
)paren
suffix:semicolon
id|failed
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|jb-&gt;bitmaps
comma
l_int|0
comma
id|mem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed
)paren
(brace
id|free_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|jb_array
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** find an available list bitmap.  If you can&squot;t find one, flush a commit list &n;** and try again&n;*/
r_static
r_struct
id|reiserfs_list_bitmap
op_star
DECL|function|get_list_bitmap
id|get_list_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
id|JOURNAL_NUM_BITMAPS
op_star
l_int|3
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|i
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap_index
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap_index
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|jb
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|jb-&gt;journal_list
)paren
(brace
multiline_comment|/* double check to make sure if flushed correctly */
r_return
l_int|NULL
suffix:semicolon
)brace
id|jb-&gt;journal_list
op_assign
id|jl
suffix:semicolon
r_return
id|jb
suffix:semicolon
)brace
multiline_comment|/* &n;** allocates a new chunk of X nodes, and links them all together as a list.&n;** Uses the cnode-&gt;next and cnode-&gt;prev pointers&n;** returns NULL on failure&n;*/
DECL|function|allocate_cnodes
r_static
r_struct
id|reiserfs_journal_cnode
op_star
id|allocate_cnodes
c_func
(paren
r_int
id|num_cnodes
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|head
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|num_cnodes
op_le
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|head
op_assign
id|vmalloc
c_func
(paren
id|num_cnodes
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|head
comma
l_int|0
comma
id|num_cnodes
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
id|head
(braket
l_int|0
)braket
dot
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|head
(braket
l_int|0
)braket
dot
id|next
op_assign
id|head
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|num_cnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|head
(braket
id|i
)braket
dot
id|prev
op_assign
id|head
op_plus
(paren
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|head
(braket
id|i
)braket
dot
id|next
op_assign
id|head
op_plus
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if last one, overwrite it after the if */
)brace
id|head
(braket
id|num_cnodes
op_minus
l_int|1
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n;** pulls a cnode off the free list, or returns NULL on failure &n;*/
DECL|function|get_cnode
r_static
r_struct
id|reiserfs_journal_cnode
op_star
id|get_cnode
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;get_cnode&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_le
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_used
op_increment
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_decrement
suffix:semicolon
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
r_return
id|cn
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn-&gt;next
)paren
(brace
id|cn-&gt;next-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
op_assign
id|cn-&gt;next
suffix:semicolon
id|memset
c_func
(paren
id|cn
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
r_return
id|cn
suffix:semicolon
)brace
multiline_comment|/*&n;** returns a cnode to the free list &n;*/
DECL|function|free_cnode
r_static
r_void
id|free_cnode
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;free_cnode&quot;
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_used
op_decrement
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_increment
suffix:semicolon
multiline_comment|/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */
id|cn-&gt;next
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list-&gt;prev
op_assign
id|cn
suffix:semicolon
)brace
id|cn-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not needed with the memset, but I might kill the memset, and forget to do this */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
op_assign
id|cn
suffix:semicolon
)brace
DECL|function|clear_prepared_bits
r_static
r_int
id|clear_prepared_bits
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* buffer is in current transaction */
DECL|function|buffer_journaled
r_inline
r_int
id|buffer_journaled
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
r_return
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* disk block was taken off free list before being in a finished transation, or written to disk&n;** journal_new blocks can be reused immediately, for any purpose&n;*/
DECL|function|buffer_journal_new
r_inline
r_int
id|buffer_journal_new
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
r_return
id|test_bit
c_func
(paren
id|BH_JNew
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mark_buffer_journal_new
r_inline
r_int
id|mark_buffer_journal_new
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JNew
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mark_buffer_not_journaled
r_inline
r_int
id|mark_buffer_not_journaled
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
id|clear_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* utility function to force a BUG if it is called without the big&n;** kernel lock held.  caller is the string printed just before calling BUG()&n;*/
DECL|function|reiserfs_check_lock_depth
r_void
id|reiserfs_check_lock_depth
c_func
(paren
r_char
op_star
id|caller
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|current-&gt;lock_depth
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s called without kernel lock held&bslash;n&quot;
comma
id|caller
)paren
suffix:semicolon
id|show_reiserfs_locks
c_func
(paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#else
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* return a cnode with same dev, block number and size in table, or null if not found */
DECL|function|get_journal_hash_dev
r_static
r_inline
r_struct
id|reiserfs_journal_cnode
op_star
id|get_journal_hash_dev
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
id|kdev_t
id|dev
comma
r_int
id|bl
comma
r_int
id|size
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
id|cn
op_assign
id|journal_hash
c_func
(paren
id|table
comma
id|dev
comma
id|bl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
(paren
id|cn-&gt;blocknr
op_eq
id|bl
)paren
op_logical_and
(paren
id|cn-&gt;dev
op_eq
id|dev
)paren
)paren
r_return
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;hnext
suffix:semicolon
)brace
r_return
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns a cnode with same size, block number and dev as bh in the current transaction hash.  NULL if not found */
DECL|function|get_journal_hash
r_static
r_inline
r_struct
id|reiserfs_journal_cnode
op_star
id|get_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
r_return
id|cn
suffix:semicolon
)brace
multiline_comment|/* once upon a time, the journal would deadlock.  a lot.  Now, when&n;** CONFIG_REISERFS_CHECK is defined, anytime someone enters a&n;** transaction, it pushes itself into this ugly static list, and pops&n;** itself off before calling journal_end.  I made a SysRq key to dump&n;** the list, and tell me what the writers are when I&squot;m deadlocked.  */
multiline_comment|/* are you depending on the compiler&n;                                   to optimize this function away&n;                                   everywhere it is called? It is not&n;                                   obvious how this works, but I&n;                                   suppose debugging code need not be&n;                                   clear.  -Hans */
DECL|variable|journal_writers
r_static
r_char
op_star
id|journal_writers
(braket
l_int|512
)braket
suffix:semicolon
DECL|function|push_journal_writer
r_int
id|push_journal_writer
c_func
(paren
r_char
op_star
id|s
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|journal_writers
(braket
id|i
)braket
)paren
(brace
id|journal_writers
(braket
id|i
)braket
op_assign
id|s
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|pop_journal_writer
r_int
id|pop_journal_writer
c_func
(paren
r_int
id|index
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
(brace
id|journal_writers
(braket
id|index
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dump_journal_writers
r_int
id|dump_journal_writers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|512
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|journal_writers
(braket
id|i
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d: %s&bslash;n&quot;
comma
id|i
comma
id|journal_writers
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** this actually means &squot;can this block be reallocated yet?&squot;.  If you set search_all, a block can only be allocated&n;** if it is not in the current transaction, was not freed by the current transaction, and has no chance of ever&n;** being overwritten by a replay after crashing.&n;**&n;** If you don&squot;t set search_all, a block can only be allocated if it is not in the current transaction.  Since deleting&n;** a block removes it from the current transaction, this case should never happen.  If you don&squot;t set search_all, make&n;** sure you never write the block without logging it.&n;**&n;** next_zero_bit is a suggestion about the next block to try for find_forward.&n;** when bl is rejected because it is set in a journal list bitmap, we search&n;** for the next zero bit in the bitmap that rejected bl.  Then, we return that&n;** through next_zero_bit for find_forward to try.&n;**&n;** Just because we return something in next_zero_bit does not mean we won&squot;t&n;** reject it on the next call to reiserfs_in_journal&n;**&n;*/
DECL|function|reiserfs_in_journal
r_int
id|reiserfs_in_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|bl
comma
r_int
id|size
comma
r_int
id|search_all
comma
r_int
r_int
op_star
id|next_zero_bit
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|bmap_nr
op_assign
id|bl
op_div
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_int
id|bit_nr
op_assign
id|bl
op_mod
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_int
id|tmp_bit
suffix:semicolon
op_star
id|next_zero_bit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always start this at zero. */
multiline_comment|/* we aren&squot;t logging all blocks are safe for reuse */
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If we aren&squot;t doing a search_all, this is a metablock, and it will be logged before use.&n;  ** if we crash before the transaction that freed it commits,  this transaction won&squot;t&n;  ** have committed either, and the block will never be written&n;  */
r_if
c_cond
(paren
id|search_all
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jb
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|jb-&gt;journal_list
op_logical_and
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_logical_and
id|test_bit
c_func
(paren
id|bit_nr
comma
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
)paren
(brace
id|tmp_bit
op_assign
id|find_next_zero_bit
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
comma
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
comma
id|bit_nr
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|next_zero_bit
op_assign
id|bmap_nr
op_star
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
op_plus
id|tmp_bit
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* is it in any old transactions? */
r_if
c_cond
(paren
id|search_all
op_logical_and
(paren
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|dev
comma
id|bl
comma
id|size
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* is it in the current transaction.  This should never happen */
r_if
c_cond
(paren
(paren
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|dev
comma
id|bl
comma
id|size
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* safe for reuse */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* insert cn into table&n;*/
DECL|function|insert_journal_hash
r_inline
r_void
id|insert_journal_hash
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn_orig
suffix:semicolon
id|cn_orig
op_assign
id|journal_hash
c_func
(paren
id|table
comma
id|cn-&gt;dev
comma
id|cn-&gt;blocknr
)paren
suffix:semicolon
id|cn-&gt;hnext
op_assign
id|cn_orig
suffix:semicolon
id|cn-&gt;hprev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cn_orig
)paren
(brace
id|cn_orig-&gt;hprev
op_assign
id|cn
suffix:semicolon
)brace
id|journal_hash
c_func
(paren
id|table
comma
id|cn-&gt;dev
comma
id|cn-&gt;blocknr
)paren
op_assign
id|cn
suffix:semicolon
)brace
multiline_comment|/* lock the current transaction */
DECL|function|lock_journal
r_inline
r_static
r_void
id|lock_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
)paren
OG
l_int|0
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wait
)paren
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* unlock the current transaction */
DECL|function|unlock_journal
r_inline
r_static
r_void
id|unlock_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** this used to be much more involved, and I&squot;m keeping it just in case things get ugly again.&n;** it gets called by flush_commit_list, and cleans up any data stored about blocks freed during a&n;** transaction.&n;*/
DECL|function|cleanup_freed_for_journal_list
r_static
r_void
id|cleanup_freed_for_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
id|jl-&gt;j_list_bitmap
suffix:semicolon
r_if
c_cond
(paren
id|jb
)paren
(brace
id|cleanup_bitmap_list
c_func
(paren
id|p_s_sb
comma
id|jb
)paren
suffix:semicolon
)brace
id|jl-&gt;j_list_bitmap-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_list_bitmap
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** if this journal list still has commit blocks unflushed, send them to disk.&n;**&n;** log areas must be flushed in order (transaction 2 can&squot;t commit before transaction 1)&n;** Before the commit block can by written, every other log block must be safely on disk&n;**&n;*/
DECL|function|flush_commit_list
r_static
r_int
id|flush_commit_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
(brace
r_int
id|i
comma
id|count
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_int
id|bn
suffix:semicolon
r_int
id|retry_count
op_assign
l_int|0
suffix:semicolon
r_int
id|orig_commit_left
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tbh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|other_jl
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;flush_commit_list&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|jl-&gt;j_older_commits_done
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* before we can put our commit blocks on disk, we have to make sure everyone older than&n;  ** us is on disk too&n;  */
r_if
c_cond
(paren
id|jl-&gt;j_len
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flushall
)paren
(brace
multiline_comment|/* we _must_ make sure the transactions are committed in order.  Start with the&n;    ** index after this one, wrap all the way around &n;    */
id|index
op_assign
(paren
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
)paren
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|other_jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
op_plus
(paren
(paren
id|index
op_plus
id|i
)paren
op_mod
id|JOURNAL_LIST_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|other_jl
op_logical_and
id|other_jl
op_ne
id|jl
op_logical_and
id|other_jl-&gt;j_len
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
op_le
id|jl-&gt;j_trans_id
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|flush_commit_list
c_func
(paren
id|s
comma
id|other_jl
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t flush the commit list for the current transactoin */
r_if
c_cond
(paren
id|jl
op_eq
(paren
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|s
)paren
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* make sure nobody is trying to flush this one at the same time */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this commit is done, exit */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* keeps others from flushing while we are flushing */
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_len
OG
id|JOURNAL_TRANS_MAX
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-512: flush_commit_list: length is %lu, list number %d&bslash;n&quot;
comma
id|jl-&gt;j_len
comma
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|orig_commit_left
op_assign
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
multiline_comment|/* start by checking all the commit blocks in this transaction.  &n;  ** Add anyone not on disk into tbh.  Stop checking once commit_left &lt;= 1, because that means we&n;  ** only have the commit block left &n;  */
id|retry
suffix:colon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
OG
l_int|1
op_logical_and
id|i
OL
(paren
id|jl-&gt;j_len
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* everything but commit_bh */
id|bn
op_assign
id|reiserfs_get_journal_block
c_func
(paren
id|s
)paren
op_plus
(paren
id|jl-&gt;j_start
op_plus
id|i
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
suffix:semicolon
id|tbh
op_assign
id|get_hash_table
c_func
(paren
id|s-&gt;s_dev
comma
id|bn
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
multiline_comment|/* kill this sanity check */
r_if
c_cond
(paren
id|count
OG
(paren
id|orig_commit_left
op_plus
l_int|2
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-539: flush_commit_list: BAD count(%d) &gt; orig_commit_left(%d)!&bslash;n&quot;
comma
id|count
comma
id|orig_commit_left
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tbh
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|tbh
)paren
)paren
(brace
multiline_comment|/* wait on it, redo it just to make sure */
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-584, buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|tbh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-569: flush_commit_list, block already dirty!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|mark_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|tbh
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|tbh-&gt;b_count
)paren
)paren
suffix:semicolon
multiline_comment|/* once for our get_hash */
)brace
)brace
multiline_comment|/* wait on everyone in tbh before writing commit block*/
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
OG
l_int|1
op_logical_and
id|i
OL
(paren
id|jl-&gt;j_len
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* everything but commit_bh */
id|bn
op_assign
id|reiserfs_get_journal_block
c_func
(paren
id|s
)paren
op_plus
(paren
id|jl-&gt;j_start
op_plus
id|i
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
suffix:semicolon
id|tbh
op_assign
id|get_hash_table
c_func
(paren
id|s-&gt;s_dev
comma
id|bn
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-601, buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|tbh-&gt;b_count
)paren
)paren
suffix:semicolon
multiline_comment|/* once for our get_hash */
id|bforget
c_func
(paren
id|tbh
)paren
suffix:semicolon
multiline_comment|/* once due to original getblk in do_journal_end */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* just the commit_bh left, flush it without calling getblk for everyone */
r_if
c_cond
(paren
id|retry_count
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-582: flush_commit_list, not all log blocks on disk yet, trying again&bslash;n&quot;
)paren
suffix:semicolon
id|retry_count
op_increment
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-563: flush_commit_list: BAD, j_commit_left is %lu, should be 1&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
)paren
suffix:semicolon
)brace
id|mark_buffer_dirty
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
(paren
id|jl-&gt;j_commit_bh
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-615: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
id|bforget
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
multiline_comment|/* now, every commit block is on the disk.  It is safe to allow blocks freed during this transaction to be reallocated */
id|cleanup_freed_for_journal_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** flush_journal_list frequently needs to find a newer transaction for a given block.  This does that, or &n;** returns NULL if it can&squot;t find anything &n;*/
DECL|function|find_newer_jl_for_cn
r_static
r_struct
id|reiserfs_journal_list
op_star
id|find_newer_jl_for_cn
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
id|kdev_t
id|dev
op_assign
id|cn-&gt;dev
suffix:semicolon
r_int
r_int
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
id|cn
op_assign
id|cn-&gt;hprev
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;dev
op_eq
id|dev
op_logical_and
id|cn-&gt;blocknr
op_eq
id|blocknr
op_logical_and
id|cn-&gt;jlist
)paren
(brace
r_return
id|cn-&gt;jlist
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;hprev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** once all the real blocks have been flushed, it is safe to remove them from the&n;** journal list for this transaction.  Aside from freeing the cnode, this also allows the&n;** block to be reallocated for data blocks if it had been deleted.&n;*/
DECL|function|remove_all_from_journal_list
r_static
r_void
id|remove_all_from_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|debug
)paren
(brace
r_struct
id|buffer_head
id|fake_bh
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|last
suffix:semicolon
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
multiline_comment|/* which is better, to lock once around the whole loop, or&n;  ** to lock for each call to remove_from_journal_list?&n;  */
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;block %lu, bh is %d, state %d&bslash;n&quot;
comma
id|cn-&gt;blocknr
comma
id|cn-&gt;bh
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|cn-&gt;state
)paren
suffix:semicolon
)brace
id|fake_bh.b_blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
id|fake_bh.b_dev
op_assign
id|cn-&gt;dev
suffix:semicolon
id|cn-&gt;state
op_assign
l_int|0
suffix:semicolon
id|remove_from_journal_list
c_func
(paren
id|p_s_sb
comma
id|jl
comma
op_amp
id|fake_bh
comma
l_int|1
)paren
suffix:semicolon
)brace
id|last
op_assign
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|last
)paren
suffix:semicolon
)brace
id|jl-&gt;j_realblock
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** if this timestamp is greater than the timestamp we wrote last to the header block, write it to the header block.&n;** once this is done, I can safely say the log area for this transaction won&squot;t ever be replayed, and I can start&n;** releasing blocks in this transaction for reuse as data blocks.&n;** called by flush_journal_list, before it calls remove_all_from_journal_list&n;**&n;*/
DECL|function|update_journal_header_block
r_static
r_int
id|update_journal_header_block
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|trans_id
)paren
(brace
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_if
c_cond
(paren
id|trans_id
op_ge
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
)paren
(brace
id|wait_on_buffer
c_func
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-699: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
op_assign
id|trans_id
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first_unflushed_offset
op_assign
id|offset
suffix:semicolon
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh-&gt;b_data
)paren
suffix:semicolon
id|jh-&gt;j_last_flush_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|trans_id
)paren
suffix:semicolon
id|jh-&gt;j_first_unflushed_offset
op_assign
id|cpu_to_le32
c_func
(paren
id|offset
)paren
suffix:semicolon
id|jh-&gt;j_mount_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh-&gt;b_state
)paren
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-712: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;** flush any and all journal lists older than you are &n;** can only be called from flush_journal_list&n;*/
DECL|function|flush_older_journal_lists
r_static
r_int
id|flush_older_journal_lists
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
r_int
id|trans_id
)paren
(brace
r_int
id|i
comma
id|index
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|other_jl
suffix:semicolon
id|index
op_assign
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|other_jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|index
op_plus
id|i
)paren
op_mod
id|JOURNAL_LIST_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|other_jl
op_logical_and
id|other_jl-&gt;j_len
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
OG
l_int|0
op_logical_and
id|other_jl-&gt;j_trans_id
OL
id|trans_id
op_logical_and
id|other_jl
op_ne
id|jl
)paren
(brace
multiline_comment|/* do not flush all */
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|other_jl
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_end_buffer_io_sync
r_static
r_void
id|reiserfs_end_buffer_io_sync
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2084: pinned buffer %u:%s sent to disk&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|kdevname
c_func
(paren
id|bh-&gt;b_dev
)paren
)paren
suffix:semicolon
)brace
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|submit_logged_buffer
r_static
r_void
id|submit_logged_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|reiserfs_end_buffer_io_sync
suffix:semicolon
id|mark_buffer_notjournal_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* flush a journal list, both commit and real blocks&n;**&n;** always set flushall to 1, unless you are calling from inside&n;** flush_journal_list&n;**&n;** IMPORTANT.  This can only be called while there are no journal writers, &n;** and the journal is locked.  That means it can only be called from &n;** do_journal_end, or by journal_release&n;*/
DECL|function|flush_journal_list
r_static
r_int
id|flush_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|pjl
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|last
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|was_jwait
op_assign
l_int|0
suffix:semicolon
r_int
id|was_dirty
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|saved_bh
suffix:semicolon
r_int
r_int
id|j_len_saved
op_assign
id|jl-&gt;j_len
suffix:semicolon
r_if
c_cond
(paren
id|j_len_saved
op_le
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_wcount
)paren
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2048: flush_journal_list called with wcount %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if someone is getting the commit list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if someone is flushing this list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* this list is now ours, we can change anything we want */
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|j_len_saved
OG
id|JOURNAL_TRANS_MAX
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-715: flush_journal_list, length is %lu, list number %d&bslash;n&quot;
comma
id|j_len_saved
comma
id|jl
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if all the work is already done, get out of here */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
op_le
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_goto
id|flush_older_and_return
suffix:semicolon
)brace
multiline_comment|/* start by putting the commit list on disk.  This will also flush &n;  ** the commit lists of any olders transactions&n;  */
id|flush_commit_list
c_func
(paren
id|s
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* are we done now? */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
op_le
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_goto
id|flush_older_and_return
suffix:semicolon
)brace
multiline_comment|/* loop through each cnode, see if we need to write it, &n;  ** or wait on a more recent transaction, or just ignore it &n;  */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-844: panic journal list is flushing, wcount is not 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
id|was_jwait
op_assign
l_int|0
suffix:semicolon
id|was_dirty
op_assign
l_int|0
suffix:semicolon
id|saved_bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* blocknr of 0 is no longer in the hash, ignore it */
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
l_int|0
)paren
(brace
r_goto
id|free_cnode
suffix:semicolon
)brace
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
multiline_comment|/* the order is important here.  We check pjl to make sure we&n;    ** don&squot;t clear BH_JDirty_wait if we aren&squot;t the one writing this&n;    ** block to disk&n;    */
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
)paren
(brace
id|saved_bh
op_assign
id|cn-&gt;bh
suffix:semicolon
multiline_comment|/* we do this to make sure nobody releases the buffer while &n;      ** we are working with it &n;      */
id|atomic_inc
c_func
(paren
op_amp
(paren
id|saved_bh-&gt;b_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_journal_dirty
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|was_jwait
op_assign
l_int|1
suffix:semicolon
id|mark_buffer_notjournal_dirty
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
multiline_comment|/* brelse the inc from journal_mark_dirty */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|saved_bh-&gt;b_count
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|can_dirty
c_func
(paren
id|cn
)paren
)paren
(brace
id|was_dirty
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* if someone has this block in a newer transaction, just make&n;    ** sure they are commited, and don&squot;t try writing it to disk&n;    */
r_if
c_cond
(paren
id|pjl
)paren
(brace
id|flush_commit_list
c_func
(paren
id|s
comma
id|pjl
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|free_cnode
suffix:semicolon
)brace
multiline_comment|/* bh == NULL when the block got to disk on its own, OR, &n;    ** the block got freed in a future transaction &n;    */
r_if
c_cond
(paren
id|saved_bh
op_eq
l_int|NULL
)paren
(brace
r_goto
id|free_cnode
suffix:semicolon
)brace
multiline_comment|/* this should never happen.  kupdate_one_transaction has this list&n;    ** locked while it works, so we should never see a buffer here that&n;    ** is not marked JDirty_wait&n;    */
r_if
c_cond
(paren
(paren
op_logical_neg
id|was_jwait
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-813: BAD! buffer %lu %cdirty %cjwait, not in a newer tranasction&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
comma
id|was_dirty
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|was_jwait
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/* kupdate_one_transaction waits on the buffers it is writing, so we&n;    ** should never see locked buffers here&n;    */
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;clm-2083: locked buffer %lu in flush_journal_list&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-923: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|was_dirty
)paren
(brace
multiline_comment|/* we inc again because saved_bh gets decremented at free_cnode */
id|atomic_inc
c_func
(paren
op_amp
(paren
id|saved_bh-&gt;b_count
)paren
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
id|submit_logged_buffer
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;clm-2082: Unable to flush buffer %lu in flush_journal_list&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|free_cnode
suffix:colon
id|last
op_assign
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|saved_bh
)paren
(brace
multiline_comment|/* we incremented this to keep others from taking the buffer head away */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|saved_bh-&gt;b_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|saved_bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-945: saved_bh-&gt;b_count &lt; 0&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cn-&gt;bh
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-1011: cn-&gt;bh is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|wait_on_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn-&gt;bh
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-1012: cn-&gt;bh is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-949: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|refile_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
)brace
id|flush_older_and_return
suffix:colon
multiline_comment|/* before we can update the journal header block, we _must_ flush all &n;  ** real blocks from all older transactions to disk.  This is because&n;  ** once the header block is updated, this transaction will not be&n;  ** replayed after a crash&n;  */
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|flush_older_journal_lists
c_func
(paren
id|s
comma
id|jl
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
)brace
multiline_comment|/* before we can remove everything from the hash tables for this &n;  ** transaction, we must make sure it can never be replayed&n;  **&n;  ** since we are only called from do_journal_end, we know for sure there&n;  ** are no allocations going on while we are flushing journal lists.  So,&n;  ** we only need to update the journal header block for the last list&n;  ** being flushed&n;  */
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|update_journal_header_block
c_func
(paren
id|s
comma
(paren
id|jl-&gt;j_start
op_plus
id|jl-&gt;j_len
op_plus
l_int|2
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
)brace
id|remove_all_from_journal_list
c_func
(paren
id|s
comma
id|jl
comma
l_int|0
)paren
suffix:semicolon
id|jl-&gt;j_len
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
comma
l_int|0
)paren
suffix:semicolon
id|jl-&gt;j_start
op_assign
l_int|0
suffix:semicolon
id|jl-&gt;j_realblock
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_commit_bh
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_trans_id
op_assign
l_int|0
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|kupdate_one_transaction
r_static
r_int
id|kupdate_one_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|pjl
suffix:semicolon
multiline_comment|/* previous list for this cn */
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|walk_cn
suffix:semicolon
r_int
r_int
id|blocknr
suffix:semicolon
r_int
id|run
op_assign
l_int|0
suffix:semicolon
r_int
id|orig_trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
r_struct
id|buffer_head
op_star
id|saved_bh
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if someone is getting the commit list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if someone is flushing this list, we must wait for them */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* was it flushed while we slept? */
r_if
c_cond
(paren
id|jl-&gt;j_len
op_le
l_int|0
op_logical_or
id|jl-&gt;j_trans_id
op_ne
id|orig_trans_id
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this list is now ours, we can change anything we want */
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|loop_start
suffix:colon
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
id|saved_bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* if the blocknr == 0, this has been cleared from the hash,&n;        ** skip it&n;        */
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
l_int|0
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* look for a more recent transaction that logged this&n;        ** buffer.  Only the most recent transaction with a buffer in&n;        ** it is allowed to send that buffer to disk&n;        */
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run
op_eq
l_int|0
op_logical_and
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
op_logical_and
id|buffer_journal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
op_logical_and
id|can_dirty
c_func
(paren
id|cn
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|cn-&gt;bh-&gt;b_state
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
id|submit_logged_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* someone else is using this buffer.  We can&squot;t &n;                ** send it to disk right now because they might&n;                ** be changing/logging it.&n;                */
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
)paren
(brace
id|clear_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
multiline_comment|/* check again, someone could have logged while we scheduled */
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
multiline_comment|/* before the JDirty_wait bit is set, the &n;            ** buffer is added to the hash list.  So, if we are&n;            ** run in the middle of a do_journal_end, we will notice&n;            ** if this buffer was logged and added from the latest&n;            ** transaction.  In this case, we don&squot;t want to decrement&n;            ** b_count&n;            */
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
op_logical_and
id|buffer_journal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
id|walk_cn
op_assign
id|cn
suffix:semicolon
id|saved_bh
op_assign
id|cn-&gt;bh
suffix:semicolon
multiline_comment|/* update all older transactions to show this block&n;                ** was flushed&n;                */
id|mark_buffer_notjournal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_while
c_loop
(paren
id|walk_cn
)paren
(brace
r_if
c_cond
(paren
id|walk_cn-&gt;bh
op_logical_and
id|walk_cn-&gt;blocknr
op_eq
id|blocknr
op_logical_and
id|walk_cn-&gt;dev
op_eq
id|cn-&gt;dev
)paren
(brace
r_if
c_cond
(paren
id|walk_cn-&gt;jlist
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|walk_cn-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
)brace
id|walk_cn-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
id|walk_cn
op_assign
id|walk_cn-&gt;hnext
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|saved_bh-&gt;b_count
)paren
OL
l_int|1
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;clm-2081: bad count on %lu&bslash;n&quot;
comma
id|saved_bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;        ** if the more recent transaction is committed to the log,&n;        ** this buffer can be considered flushed.  Decrement our&n;        ** counters to reflect one less buffer that needs writing.&n;        **&n;        ** note, this relies on all of the above code being&n;        ** schedule free once pjl comes back non-null.&n;        */
r_if
c_cond
(paren
id|pjl
op_logical_and
id|cn-&gt;bh
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|pjl-&gt;j_commit_left
)paren
op_eq
l_int|0
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|cn-&gt;jlist-&gt;j_nonzerolen
)paren
suffix:semicolon
id|cn-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
id|next
suffix:colon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
multiline_comment|/* the first run through the loop sends all the dirty buffers to&n;    ** ll_rw_block.&n;    ** the second run through the loop does all the accounting&n;    */
r_if
c_cond
(paren
id|run
op_increment
op_eq
l_int|0
)paren
(brace
r_goto
id|loop_start
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|jl-&gt;j_flush_wait
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* since we never give dirty buffers to bdflush/kupdate, we have to&n;** flush them ourselves.  This runs through the journal lists, finds&n;** old metadata in need of flushing and sends it to disk.&n;** this does not end transactions, commit anything, or free&n;** cnodes.&n;**&n;** returns the highest transaction id that was flushed last time&n;*/
DECL|function|reiserfs_journal_kupdate
r_static
r_int
r_int
id|reiserfs_journal_kupdate
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|start
suffix:semicolon
id|time_t
id|age
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|start
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* safety check to prevent flush attempts during a mount */
r_if
c_cond
(paren
id|start
OL
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_assign
(paren
id|start
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|start
)paren
(brace
id|jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|s
)paren
op_plus
id|i
suffix:semicolon
id|age
op_assign
id|CURRENT_TIME
op_minus
id|jl-&gt;j_timestamp
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_len
OG
l_int|0
op_logical_and
singleline_comment|// age &gt;= (JOURNAL_MAX_COMMIT_AGE * 2) &amp;&amp; 
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jl-&gt;j_trans_id
op_eq
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* if ret was already 1, we want to preserve that */
id|ret
op_or_assign
id|kupdate_one_transaction
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
OG
l_int|0
)paren
(brace
id|ret
op_or_assign
l_int|1
suffix:semicolon
)brace
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;** removes any nodes in table with name block and dev as bh.&n;** only touchs the hnext and hprev pointers.&n;*/
DECL|function|remove_journal_hash
r_void
(def_block
id|remove_journal_hash
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|remove_freed
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cur
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
suffix:semicolon
id|head
op_assign
op_amp
(paren
id|journal_hash
c_func
(paren
id|table
comma
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head
)paren
(brace
r_return
suffix:semicolon
)brace
id|cur
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|cur
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;blocknr
op_eq
id|bh-&gt;b_blocknr
op_logical_and
id|cur-&gt;dev
op_eq
id|bh-&gt;b_dev
op_logical_and
(paren
id|jl
op_eq
l_int|NULL
op_logical_or
id|jl
op_eq
id|cur-&gt;jlist
)paren
op_logical_and
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BLOCK_FREED
comma
op_amp
id|cur-&gt;state
)paren
op_logical_or
id|remove_freed
)paren
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;hnext
)paren
(brace
id|cur-&gt;hnext-&gt;hprev
op_assign
id|cur-&gt;hprev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur-&gt;hprev
)paren
(brace
id|cur-&gt;hprev-&gt;hnext
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
r_else
(brace
op_star
id|head
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
id|cur-&gt;blocknr
op_assign
l_int|0
suffix:semicolon
id|cur-&gt;dev
op_assign
l_int|0
suffix:semicolon
id|cur-&gt;state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cur-&gt;bh
op_logical_and
id|cur-&gt;jlist
)paren
multiline_comment|/* anybody who clears the cur-&gt;bh will also dec the nonzerolen */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|cur-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
id|cur-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
id|cur-&gt;jlist
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
)brace
)def_block
DECL|function|free_journal_ram
r_static
r_void
id|free_journal_ram
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|vfree
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_orig
)paren
suffix:semicolon
id|free_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
)paren
suffix:semicolon
id|free_bitmap_nodes
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* must be after free_list_bitmaps */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
(brace
id|brelse
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** call on unmount.  Only set error to 1 if you haven&squot;t made your way out&n;** of read_super() yet.  Any other caller must keep error at 0.&n;*/
DECL|function|do_journal_release
r_static
r_int
id|do_journal_release
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|error
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|myth
suffix:semicolon
multiline_comment|/* we only want to flush out transactions if we were called with error == 0&n;  */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
op_logical_neg
(paren
id|p_s_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
multiline_comment|/* end the current trans */
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|10
comma
id|FLUSH_ALL
)paren
suffix:semicolon
multiline_comment|/* make sure something gets logged to force our way into the flush code */
id|journal_join
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
id|FLUSH_ALL
)paren
suffix:semicolon
)brace
multiline_comment|/* we decrement before we wake up, because the commit thread dies off&n;  ** when it has been woken up and the count is &lt;= 0&n;  */
id|reiserfs_mounted_fs_count
op_decrement
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_wait
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
id|free_journal_ram
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** call on unmount.  flush all journal trans, release all alloc&squot;d ram&n;*/
DECL|function|journal_release
r_int
id|journal_release
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_return
id|do_journal_release
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** only call from an error condition inside reiserfs_read_super!&n;*/
DECL|function|journal_release_error
r_int
id|journal_release_error
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_return
id|do_journal_release
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* compares description block with commit block.  returns 1 if they differ, 0 if they are the same */
DECL|function|journal_compare_desc_commit
r_static
r_int
id|journal_compare_desc_commit
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_desc
op_star
id|desc
comma
r_struct
id|reiserfs_journal_commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_trans_id
)paren
op_ne
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
op_ne
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_logical_or
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
OG
id|JOURNAL_TRANS_MAX
op_logical_or
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
op_le
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns 0 if it did not find a description block  &n;** returns -1 if it found a corrupt commit block&n;** returns 1 if both desc and commit were valid &n;*/
DECL|function|journal_transaction_is_valid
r_static
r_int
id|journal_transaction_is_valid
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|d_bh
comma
r_int
r_int
op_star
id|oldest_invalid_trans_id
comma
r_int
r_int
op_star
id|newest_mount_id
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
OG
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|desc-&gt;j_magic
comma
id|JOURNAL_DESC_MAGIC
comma
l_int|8
)paren
)paren
(brace
r_if
c_cond
(paren
id|oldest_invalid_trans_id
op_logical_and
op_star
id|oldest_invalid_trans_id
op_logical_and
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
OG
op_star
id|oldest_invalid_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-986: transaction &quot;
l_string|&quot;is valid returning because trans_id %d is greater than &quot;
l_string|&quot;oldest_invalid %lu&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
comma
op_star
id|oldest_invalid_trans_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newest_mount_id
op_logical_and
op_star
id|newest_mount_id
OG
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1087: transaction &quot;
l_string|&quot;is valid returning because mount_id %d is less than &quot;
l_string|&quot;newest_mount_id %lu&bslash;n&quot;
comma
id|desc-&gt;j_mount_id
comma
op_star
id|newest_mount_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|offset
op_assign
id|d_bh-&gt;b_blocknr
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* ok, we have a journal description block, lets see if the transaction was valid */
id|c_bh
op_assign
id|bread
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|offset
op_plus
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c_bh
)paren
r_return
l_int|0
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|journal_compare_desc_commit
c_func
(paren
id|p_s_sb
comma
id|desc
comma
id|commit
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal_transaction_is_valid, commit offset %ld had bad &quot;
l_string|&quot;time %d or length %d&bslash;n&quot;
comma
id|c_bh-&gt;b_blocknr
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_trans_id
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldest_invalid_trans_id
)paren
op_star
id|oldest_invalid_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1004: &quot;
l_string|&quot;transaction_is_valid setting oldest invalid trans_id &quot;
l_string|&quot;to %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1006: found valid &quot;
l_string|&quot;transaction start offset %lu, len %d id %d&bslash;n&quot;
comma
id|d_bh-&gt;b_blocknr
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|brelse_array
r_static
r_void
id|brelse_array
c_func
(paren
r_struct
id|buffer_head
op_star
op_star
id|heads
comma
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
c_func
(paren
id|heads
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** given the start, and values for the oldest acceptable transactions,&n;** this either reads in a replays a transaction, or returns because the transaction&n;** is invalid, or too old.&n;*/
DECL|function|journal_read_transaction
r_static
r_int
id|journal_read_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|cur_dblock
comma
r_int
r_int
id|oldest_start
comma
r_int
r_int
id|oldest_trans_id
comma
r_int
r_int
id|newest_mount_id
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_int
r_int
id|trans_id
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|log_blocks
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|real_blocks
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|trans_offset
suffix:semicolon
r_int
id|i
suffix:semicolon
id|d_bh
op_assign
id|bread
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|cur_dblock
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_bh
)paren
r_return
l_int|1
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
id|trans_offset
op_assign
id|d_bh-&gt;b_blocknr
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1037: &quot;
l_string|&quot;journal_read_transaction, offset %lu, len %d mount_id %d&bslash;n&quot;
comma
id|d_bh-&gt;b_blocknr
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
OL
id|oldest_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1039: &quot;
l_string|&quot;journal_read_trans skipping because %lu is too old&bslash;n&quot;
comma
id|cur_dblock
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
op_ne
id|newest_mount_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1146: &quot;
l_string|&quot;journal_read_trans skipping because %d is != &quot;
l_string|&quot;newest_mount_id %lu&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
comma
id|newest_mount_id
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|c_bh
op_assign
id|bread
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|trans_offset
op_plus
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c_bh
)paren
(brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|journal_compare_desc_commit
c_func
(paren
id|p_s_sb
comma
id|desc
comma
id|commit
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal_read_transaction, &quot;
l_string|&quot;commit offset %ld had bad time %d or length %d&bslash;n&quot;
comma
id|c_bh-&gt;b_blocknr
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_trans_id
)paren
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_len
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
multiline_comment|/* now we know we&squot;ve got a good transaction, and it was inside the valid time ranges */
id|log_blocks
op_assign
id|kmalloc
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_BUFFER
)paren
suffix:semicolon
id|real_blocks
op_assign
id|kmalloc
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|log_blocks
op_logical_or
op_logical_neg
id|real_blocks
)paren
(brace
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|log_blocks
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|real_blocks
)paren
suffix:semicolon
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1169: kmalloc failed, unable to mount FS&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* get all the buffer heads */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|log_blocks
(braket
id|i
)braket
op_assign
id|getblk
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
id|trans_offset
op_plus
l_int|1
op_plus
id|i
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|JOURNAL_TRANS_HALF
)paren
(brace
id|real_blocks
(braket
id|i
)braket
op_assign
id|getblk
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_realblock
(braket
id|i
)braket
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
)brace
r_else
(brace
id|real_blocks
(braket
id|i
)braket
op_assign
id|getblk
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_realblock
(braket
id|i
op_minus
id|JOURNAL_TRANS_HALF
)braket
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
op_ge
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_logical_and
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
OL
(paren
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|JOURNAL_BLOCK_COUNT
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block&bslash;n&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|log_blocks
comma
id|i
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
comma
id|i
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|log_blocks
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|real_blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* read in the log blocks, memcpy to the corresponding real block */
id|ll_rw_block
c_func
(paren
id|READ
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
comma
id|log_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1212: REPLAY FAILURE fsck required! buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|log_blocks
op_plus
id|i
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_minus
id|i
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|log_blocks
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|real_blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|log_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|real_blocks
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* flush out the real blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|set_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
(paren
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_state
)paren
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
id|real_blocks
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1226: REPLAY FAILURE, fsck required! buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
op_plus
id|i
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_minus
id|i
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|log_blocks
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|real_blocks
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|cur_dblock
op_assign
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|trans_offset
op_plus
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|2
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1095: setting journal &quot;
l_string|&quot;start to offset %ld&bslash;n&quot;
comma
id|cur_dblock
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
multiline_comment|/* init starting values for the first transaction, in case this is the last transaction to be replayed. */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
id|cur_dblock
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
op_assign
id|trans_id
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_assign
id|trans_id
op_plus
l_int|1
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|log_blocks
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|real_blocks
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** read and replay the log&n;** on a clean unmount, the journal header&squot;s next unflushed pointer will be to an invalid&n;** transaction.  This tests that before finding all the transactions in the log, whic makes normal mount times fast.&n;**&n;** After a crash, this starts with the next unflushed transaction, and replays until it finds one too old, or invalid.&n;**&n;** On exit, it sets things up so the first transaction will work correctly.&n;*/
DECL|function|journal_read
r_static
r_int
id|journal_read
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_int
r_int
id|last_flush_trans_id
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldest_trans_id
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldest_invalid_trans_id
op_assign
l_int|0
suffix:semicolon
id|time_t
id|start
suffix:semicolon
r_int
r_int
id|last_flush_start
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldest_start
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cur_dblock
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|newest_mount_id
op_assign
l_int|9
suffix:semicolon
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_int
id|valid_journal_header
op_assign
l_int|0
suffix:semicolon
r_int
id|replay_count
op_assign
l_int|0
suffix:semicolon
r_int
id|continue_replay
op_assign
l_int|1
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|cur_dblock
op_assign
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reiserfs: checking transaction log (device %s) ...&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|p_s_sb-&gt;s_dev
)paren
)paren
suffix:semicolon
id|start
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* step 1, read in the journal header block.  Check the transaction it says &n;  ** is the first unflushed, and if that transaction is not valid, &n;  ** replay is done&n;  */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
op_assign
id|bread
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|JOURNAL_BLOCK_COUNT
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh-&gt;b_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
op_ge
l_int|0
op_logical_and
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
template_param
l_int|0
)paren
(brace
id|last_flush_start
op_assign
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
suffix:semicolon
id|last_flush_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1153: found in &quot;
l_string|&quot;header: first_unflushed_offset %d, last_flushed_trans_id &quot;
l_string|&quot;%lu&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
comma
id|last_flush_trans_id
)paren
suffix:semicolon
id|valid_journal_header
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* now, we try to read the first unflushed offset.  If it is not valid, &n;    ** there is nothing more we can do, and it makes no sense to read &n;    ** through the whole log.&n;    */
id|d_bh
op_assign
id|bread
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|ret
op_assign
id|journal_transaction_is_valid
c_func
(paren
id|p_s_sb
comma
id|d_bh
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|continue_replay
op_assign
l_int|0
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|continue_replay
op_logical_and
id|is_read_only
c_func
(paren
id|p_s_sb-&gt;s_dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;clm-2076: device is readonly, unable to replay log&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_header_bh
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|continue_replay
op_logical_and
(paren
id|p_s_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning, log replay starting on readonly filesystem&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ok, there are transactions that need to be replayed.  start with the first log block, find&n;  ** all the valid transactions, and pick out the oldest.&n;  */
r_while
c_loop
(paren
id|continue_replay
op_logical_and
id|cur_dblock
OL
(paren
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|JOURNAL_BLOCK_COUNT
)paren
)paren
(brace
id|d_bh
op_assign
id|bread
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|cur_dblock
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|ret
op_assign
id|journal_transaction_is_valid
c_func
(paren
id|p_s_sb
comma
id|d_bh
comma
op_amp
id|oldest_invalid_trans_id
comma
op_amp
id|newest_mount_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|oldest_start
op_eq
l_int|0
)paren
(brace
multiline_comment|/* init all oldest_ values */
id|oldest_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
id|oldest_start
op_assign
id|d_bh-&gt;b_blocknr
suffix:semicolon
id|newest_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1179: Setting &quot;
l_string|&quot;oldest_start to offset %lu, trans_id %lu&bslash;n&quot;
comma
id|oldest_start
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|oldest_trans_id
OG
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
)paren
(brace
multiline_comment|/* one we just read was older */
id|oldest_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_trans_id
)paren
suffix:semicolon
id|oldest_start
op_assign
id|d_bh-&gt;b_blocknr
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1180: Resetting &quot;
l_string|&quot;oldest_start to offset %lu, trans_id %lu&bslash;n&quot;
comma
id|oldest_start
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newest_mount_id
OL
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
(brace
id|newest_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1299: Setting &quot;
l_string|&quot;newest_mount_id to %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_mount_id
)paren
)paren
suffix:semicolon
)brace
id|cur_dblock
op_add_assign
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_plus
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|cur_dblock
op_increment
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
)brace
multiline_comment|/* step three, starting at the oldest transaction, replay */
r_if
c_cond
(paren
id|last_flush_start
OG
l_int|0
)paren
(brace
id|oldest_start
op_assign
id|last_flush_start
suffix:semicolon
id|oldest_trans_id
op_assign
id|last_flush_trans_id
suffix:semicolon
)brace
id|cur_dblock
op_assign
id|oldest_start
suffix:semicolon
r_if
c_cond
(paren
id|oldest_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1206: Starting replay &quot;
l_string|&quot;from offset %lu, trans_id %lu&bslash;n&quot;
comma
id|cur_dblock
op_minus
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
id|replay_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|continue_replay
op_logical_and
id|oldest_trans_id
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|journal_read_transaction
c_func
(paren
id|p_s_sb
comma
id|cur_dblock
comma
id|oldest_start
comma
id|oldest_trans_id
comma
id|newest_mount_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|cur_dblock
op_assign
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|replay_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldest_trans_id
op_eq
l_int|0
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1225: No valid &quot;
l_string|&quot;transactions found&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* j_start does not get set correctly if we don&squot;t replay any transactions.&n;  ** if we had a valid journal_header, set j_start to the first unflushed transaction value,&n;  ** copy the trans_id from the header&n;  */
r_if
c_cond
(paren
id|valid_journal_header
op_logical_and
id|replay_count
op_eq
l_int|0
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
op_plus
l_int|1
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_mount_id
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
op_assign
id|newest_mount_id
op_plus
l_int|1
suffix:semicolon
)brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1299: Setting &quot;
l_string|&quot;newest_mount_id to %lu&bslash;n&quot;
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first_unflushed_offset
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
r_if
c_cond
(paren
id|replay_count
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs: replayed %d transactions in %lu seconds&bslash;n&quot;
comma
id|replay_count
comma
id|CURRENT_TIME
op_minus
id|start
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_read_only
c_func
(paren
id|p_s_sb-&gt;s_dev
)paren
)paren
(brace
id|update_journal_header_block
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last_flush_trans_id
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|reiserfs_journal_commit_task
r_struct
id|reiserfs_journal_commit_task
(brace
DECL|member|p_s_sb
r_struct
id|super_block
op_star
id|p_s_sb
suffix:semicolon
DECL|member|jindex
r_int
id|jindex
suffix:semicolon
DECL|member|wake_on_finish
r_int
id|wake_on_finish
suffix:semicolon
multiline_comment|/* if this is one, we wake the task_done queue, if it&n;                       ** is zero, we free the whole struct on finish&n;&t;&t;       */
DECL|member|self
r_struct
id|reiserfs_journal_commit_task
op_star
id|self
suffix:semicolon
DECL|member|task_done
r_struct
id|wait_queue
op_star
id|task_done
suffix:semicolon
DECL|member|task
r_struct
id|tq_struct
id|task
suffix:semicolon
)brace
suffix:semicolon
DECL|function|reiserfs_journal_commit_task_func
r_static
r_void
id|reiserfs_journal_commit_task_func
c_func
(paren
r_struct
id|reiserfs_journal_commit_task
op_star
id|ct
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
id|jl
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|ct-&gt;p_s_sb
)paren
op_plus
id|ct-&gt;jindex
suffix:semicolon
id|flush_commit_list
c_func
(paren
id|ct-&gt;p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|ct-&gt;p_s_sb
)paren
op_plus
id|ct-&gt;jindex
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_len
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|kupdate_one_transaction
c_func
(paren
id|ct-&gt;p_s_sb
comma
id|jl
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ct-&gt;self
)paren
suffix:semicolon
)brace
DECL|function|setup_commit_task_arg
r_static
r_void
id|setup_commit_task_arg
c_func
(paren
r_struct
id|reiserfs_journal_commit_task
op_star
id|ct
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|jindex
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ct
)paren
(brace
id|reiserfs_panic
c_func
(paren
l_int|NULL
comma
l_string|&quot;journal-1360: setup_commit_task_arg called with NULL struct&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|ct-&gt;p_s_sb
op_assign
id|p_s_sb
suffix:semicolon
id|ct-&gt;jindex
op_assign
id|jindex
suffix:semicolon
id|ct-&gt;task_done
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ct-&gt;task.list
)paren
suffix:semicolon
id|ct-&gt;task.sync
op_assign
l_int|0
suffix:semicolon
id|ct-&gt;task.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|reiserfs_journal_commit_task_func
suffix:semicolon
id|ct-&gt;self
op_assign
id|ct
suffix:semicolon
id|ct-&gt;task.data
op_assign
(paren
r_void
op_star
)paren
id|ct
suffix:semicolon
)brace
DECL|function|commit_flush_async
r_static
r_void
id|commit_flush_async
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|jindex
)paren
(brace
r_struct
id|reiserfs_journal_commit_task
op_star
id|ct
suffix:semicolon
multiline_comment|/* using GFP_BUFFER, GFP_KERNEL could try to flush inodes, which will try&n;  ** to start/join a transaction, which will deadlock&n;  */
id|ct
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit_task
)paren
comma
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
)paren
(brace
id|setup_commit_task_arg
c_func
(paren
id|ct
comma
id|p_s_sb
comma
id|jindex
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
(paren
id|ct-&gt;task
)paren
comma
op_amp
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_wait
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-1540: kmalloc failed, doing sync commit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** this is the commit thread.  It is started with kernel_thread on&n;** FS mount, and journal_release() waits for it to exit.&n;**&n;** It could do a periodic commit, but there is a lot code for that&n;** elsewhere right now, and I only wanted to implement this little&n;** piece for starters.&n;**&n;** All we do here is sleep on the j_commit_thread_wait wait queue, and&n;** then run the per filesystem commit task queue when we wakeup.&n;*/
DECL|function|reiserfs_journal_commit_thread
r_static
r_int
id|reiserfs_journal_commit_thread
c_func
(paren
r_void
op_star
id|nullp
)paren
(brace
id|exit_files
c_func
(paren
id|current
)paren
suffix:semicolon
id|exit_mm
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|current-&gt;session
op_assign
l_int|1
suffix:semicolon
id|current-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kreiserfsd&quot;
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
id|TQ_ACTIVE
c_func
(paren
id|reiserfs_commit_thread_tq
)paren
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
)brace
multiline_comment|/* if there aren&squot;t any more filesystems left, break */
r_if
c_cond
(paren
id|reiserfs_mounted_fs_count
op_le
l_int|0
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|reiserfs_commit_thread_tq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|reiserfs_commit_thread_wait
comma
l_int|5
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|reiserfs_commit_thread_done
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_list_init
r_static
r_void
id|journal_list_init
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_commit_wait
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_flush_wait
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** must be called once on fs mount.  calls journal_read for you&n;*/
DECL|function|journal_init
r_int
id|journal_init
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|num_cnodes
op_assign
id|JOURNAL_BLOCK_COUNT
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit
)paren
op_ne
l_int|4096
op_logical_or
r_sizeof
(paren
r_struct
id|reiserfs_journal_desc
)paren
op_ne
l_int|4096
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1249: commit or desc struct not 4096 %Zd %Zd&bslash;n&quot;
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit
)paren
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_desc
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* sanity check to make sure they don&squot;t overflow the journal */
r_if
c_cond
(paren
id|JOURNAL_BLOCK_COUNT
OG
id|reiserfs_get_journal_orig_size
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1393: current JOURNAL_BLOCK_COUNT (%d) is too big.  This FS was created with a journal size of %lu blocks&bslash;n&quot;
comma
id|JOURNAL_BLOCK_COUNT
comma
id|reiserfs_get_journal_orig_size
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1256: unable to get memory for journal structure&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal
)paren
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap_index
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_assign
op_minus
l_int|10000
suffix:semicolon
multiline_comment|/* make sure flush_old_commits does not try to flush a list while replay is on */
multiline_comment|/* clear out the journal list array */
id|memset
c_func
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_list
)paren
op_star
id|JOURNAL_LIST_COUNT
)paren
suffix:semicolon
id|journal_list_init
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|memset
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
l_int|0
comma
id|JOURNAL_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|journal_writers
comma
l_int|0
comma
r_sizeof
(paren
r_char
op_star
)paren
op_star
l_int|512
)paren
suffix:semicolon
multiline_comment|/* debug code */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bitmap_nodes
)paren
suffix:semicolon
id|reiserfs_allocate_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_bitmap
comma
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|allocate_bitmap_nodes
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bcount
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
l_int|NULL
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
l_int|NULL
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wait
)paren
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_assign
l_int|10
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
op_assign
l_int|10
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_state
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
op_assign
id|allocate_cnodes
c_func
(paren
id|num_cnodes
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_orig
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free_list
ques
c_cond
id|num_cnodes
suffix:colon
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_used
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|0
suffix:semicolon
id|init_journal_hash
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
l_int|0
)braket
dot
id|j_list_bitmap
op_assign
id|get_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
l_int|0
)braket
dot
id|j_list_bitmap
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-2005, get_list_bitmap failed for journal list 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal_read
c_func
(paren
id|p_s_sb
)paren
OL
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;Replay Failure, unable to mount&bslash;n&quot;
)paren
suffix:semicolon
id|free_journal_ram
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* once the read is done, we can set this where it belongs */
r_if
c_cond
(paren
id|reiserfs_dont_log
(paren
id|p_s_sb
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|reiserfs_mounted_fs_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_mounted_fs_count
op_le
l_int|1
)paren
(brace
id|kernel_thread
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|reiserfs_journal_commit_thread
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_VM
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** test for a polite end of the current transaction.  Used by file_write, and should&n;** be used by delete to make sure they don&squot;t write more than can fit inside a single&n;** transaction&n;*/
DECL|function|journal_transaction_should_end
r_int
id|journal_transaction_should_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
id|new_alloc
)paren
(brace
id|time_t
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
op_logical_or
(paren
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_len_alloc
op_plus
id|new_alloc
)paren
op_ge
id|JOURNAL_MAX_BATCH
op_logical_or
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
op_logical_or
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|JOURNAL_MAX_TRANS_AGE
op_logical_or
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_cnode_free
OL
(paren
id|JOURNAL_TRANS_MAX
op_star
l_int|3
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this must be called inside a transaction, and requires the &n;** kernel_lock to be held&n;*/
DECL|function|reiserfs_block_writes
r_void
id|reiserfs_block_writes
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|1
suffix:semicolon
id|set_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* this must be called without a transaction started, and does not&n;** require BKL&n;*/
DECL|function|reiserfs_allow_writes
r_void
id|reiserfs_allow_writes
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|clear_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* this must be called without a transaction started, and does not&n;** require BKL&n;*/
DECL|function|reiserfs_wait_on_write_block
r_void
id|reiserfs_wait_on_write_block
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|wait_event
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_join_wait
comma
op_logical_neg
id|test_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_state
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* join == true if you must join an existing transaction.&n;** join == false if you can deal with waiting for others to finish&n;**&n;** this will block until the transaction is joinable.  send the number of blocks you&n;** expect to use in nblocks.&n;*/
DECL|function|do_journal_begin_r
r_static
r_int
id|do_journal_begin_r
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|join
)paren
(brace
id|time_t
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
r_int
id|old_trans_id
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
l_string|&quot;journal_begin&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|p_s_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;clm-2078: calling journal_begin on readonly FS&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|th-&gt;t_super
op_assign
id|p_s_sb
suffix:semicolon
multiline_comment|/* others will check this for the don&squot;t log flag */
r_return
l_int|0
suffix:semicolon
)brace
id|relock
suffix:colon
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|WRITERS_BLOCKED
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_state
)paren
)paren
(brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_goto
id|relock
suffix:semicolon
)brace
multiline_comment|/* if there is no room in the journal OR&n;  ** if this transaction is too old, and we weren&squot;t called joinable, wait for it to finish before beginning &n;  ** we don&squot;t sleep if there aren&squot;t other writers&n;  */
r_if
c_cond
(paren
(paren
op_logical_neg
id|join
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_plus
id|nblocks
op_plus
l_int|2
)paren
op_ge
id|JOURNAL_MAX_BATCH
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
OG
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
OG
l_int|0
op_logical_and
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|JOURNAL_MAX_TRANS_AGE
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
OL
(paren
id|JOURNAL_TRANS_MAX
op_star
l_int|3
)paren
)paren
)paren
(brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* allow others to finish this transaction */
multiline_comment|/* if writer count is 0, we can just force this transaction to end, and start&n;    ** a new one afterwards.&n;    */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_le
l_int|0
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|myth
suffix:semicolon
id|journal_join
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* but if the writer count isn&squot;t zero, we have to wait for the current writers to finish.&n;      ** They won&squot;t batch on transaction end once we set j_jlock&n;      */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|1
)paren
suffix:semicolon
id|old_trans_id
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_eq
id|old_trans_id
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
)brace
)brace
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* relock to continue */
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_eq
l_int|0
)paren
(brace
multiline_comment|/* we are the first writer, set trans_id */
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_assign
id|now
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_add_assign
id|nblocks
suffix:semicolon
id|th-&gt;t_blocks_logged
op_assign
l_int|0
suffix:semicolon
id|th-&gt;t_blocks_allocated
op_assign
id|nblocks
suffix:semicolon
id|th-&gt;t_super
op_assign
id|p_s_sb
suffix:semicolon
id|th-&gt;t_trans_id
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
suffix:semicolon
id|th-&gt;t_caller
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|p_s_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_join
r_int
id|journal_join
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_return
id|do_journal_begin_r
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|journal_begin
r_int
id|journal_begin
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_return
id|do_journal_begin_r
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* not used at all */
DECL|function|journal_prepare
r_int
id|journal_prepare
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** puts bh into the current transaction.  If it was already there, reorders removes the&n;** old pointers from the hash, and puts new ones in (to make sure replay happen in the right order).&n;**&n;** if it was dirty, cleans and files onto the clean list.  I can&squot;t let it be dirty again until the&n;** transaction is committed.&n;** &n;** if j_len, is bigger than j_len_alloc, it pushes j_len_alloc to 10 + j_len.&n;*/
DECL|function|journal_mark_dirty
r_int
id|journal_mark_dirty
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count_already_incd
op_assign
l_int|0
suffix:semicolon
r_int
id|prepared
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;t_trans_id
op_ne
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1577: handle trans id %d != current trans id %d&bslash;n&quot;
comma
id|th-&gt;t_trans_id
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
)brace
id|p_s_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|prepared
op_assign
id|test_and_clear_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/* already in this transaction, we are done */
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this must be turned into a panic instead of a warning.  We can&squot;t allow&n;  ** a dirty or journal_dirty or locked buffer to be logged, as some changes&n;  ** could get to disk too early.  NOT GOOD.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|prepared
op_logical_or
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1777: buffer %lu bad state %cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|prepared
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_locked
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_dirty
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
)paren
suffix:semicolon
id|show_reiserfs_locks
c_func
(paren
)paren
suffix:semicolon
)brace
id|count_already_incd
op_assign
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1409: journal_mark_dirty returning because j_wcount was %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* this error means I&squot;ve screwed up, and we&squot;ve overflowed the transaction.  &n;  ** Nothing can be done here, except make the FS readonly or panic.&n;  */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_ge
id|JOURNAL_TRANS_MAX
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1413: journal_mark_dirty: j_len (%lu) is too big&bslash;n&quot;
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|count_already_incd
op_assign
l_int|1
suffix:semicolon
id|mark_buffer_notjournal_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* must double check after getting lock */
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
OG
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/* now put this guy on the end */
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
id|cn
op_assign
id|get_cnode
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;get_cnode failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;t_blocks_logged
op_eq
id|th-&gt;t_blocks_allocated
)paren
(brace
id|th-&gt;t_blocks_allocated
op_add_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_add_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
)brace
id|th-&gt;t_blocks_logged
op_increment
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_increment
suffix:semicolon
id|cn-&gt;bh
op_assign
id|bh
suffix:semicolon
id|cn-&gt;blocknr
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|cn-&gt;dev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|cn-&gt;jlist
op_assign
l_int|NULL
suffix:semicolon
id|insert_journal_hash
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|cn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count_already_incd
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
suffix:semicolon
)brace
)brace
id|cn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cn-&gt;prev
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
suffix:semicolon
id|cn-&gt;bh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last-&gt;next
op_assign
id|cn
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
id|cn
suffix:semicolon
)brace
r_else
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
id|cn
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
id|cn
suffix:semicolon
)brace
id|done
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** if buffer already in current transaction, do a journal_mark_dirty&n;** otherwise, just mark it dirty and move on.  Used for writes to meta blocks&n;** that don&squot;t need journaling&n;*/
DECL|function|journal_mark_dirty_nolog
r_int
id|journal_mark_dirty_nolog
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
op_logical_or
id|buffer_journaled
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
r_return
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_journal_hash_dev
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
comma
id|bh-&gt;b_size
)paren
)paren
(brace
r_return
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|bh
)paren
suffix:semicolon
)brace
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_end
r_int
id|journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_return
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* removes from the current transaction, relsing and descrementing any counters.  &n;** also files the removed buffer directly onto the clean list&n;**&n;** called by journal_mark_freed when a block has been deleted&n;**&n;** returns 1 if it cleaned and relsed the buffer. 0 otherwise&n;*/
DECL|function|remove_from_transaction
r_int
id|remove_from_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|blocknr
comma
r_int
id|already_cleaned
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
id|p_s_sb-&gt;s_dev
comma
id|blocknr
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
op_logical_or
op_logical_neg
id|cn-&gt;bh
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
id|bh
op_assign
id|cn-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;prev
)paren
(brace
id|cn-&gt;prev-&gt;next
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn-&gt;next
)paren
(brace
id|cn-&gt;next-&gt;prev
op_assign
id|cn-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn
op_eq
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn
op_eq
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
id|cn-&gt;prev
suffix:semicolon
)brace
id|remove_journal_hash
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_hash_table
comma
l_int|NULL
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|mark_buffer_not_journaled
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* don&squot;t log this one */
r_if
c_cond
(paren
op_logical_neg
id|already_cleaned
)paren
(brace
id|mark_buffer_notjournal_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-1752: remove from trans, b_count &lt; 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|reiserfs_clean_and_file_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_decrement
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_decrement
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|cn
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* removes from a specific journal list hash */
DECL|function|remove_from_journal_list
r_int
id|remove_from_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|remove_freed
)paren
(brace
id|remove_journal_hash
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|jl
comma
id|bh
comma
id|remove_freed
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** for any cnode in a journal list, it can only be dirtied of all the&n;** transactions that include it are commited to disk.&n;** this checks through each transaction, and returns 1 if you are allowed to dirty,&n;** and 0 if you aren&squot;t&n;**&n;** it is called by dirty_journal_list, which is called after flush_commit_list has gotten all the log&n;** blocks for a given transaction on disk&n;**&n;*/
DECL|function|can_dirty
r_static
r_int
id|can_dirty
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
id|kdev_t
id|dev
op_assign
id|cn-&gt;dev
suffix:semicolon
r_int
r_int
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cur
op_assign
id|cn-&gt;hprev
suffix:semicolon
r_int
id|can_dirty
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* first test hprev.  These are all newer than cn, so any node here&n;  ** with the name block number and dev means this node can&squot;t be sent&n;  ** to disk right now.&n;  */
r_while
c_loop
(paren
id|cur
op_logical_and
id|can_dirty
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;jlist
op_logical_and
id|cur-&gt;bh
op_logical_and
id|cur-&gt;blocknr
op_logical_and
id|cur-&gt;dev
op_eq
id|dev
op_logical_and
id|cur-&gt;blocknr
op_eq
id|blocknr
)paren
(brace
id|can_dirty
op_assign
l_int|0
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hprev
suffix:semicolon
)brace
multiline_comment|/* then test hnext.  These are all older than cn.  As long as they&n;  ** are committed to the log, it is safe to write cn to disk&n;  */
id|cur
op_assign
id|cn-&gt;hnext
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_logical_and
id|can_dirty
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;jlist
op_logical_and
id|cur-&gt;jlist-&gt;j_len
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|cur-&gt;jlist-&gt;j_commit_left
)paren
)paren
OG
l_int|0
op_logical_and
id|cur-&gt;bh
op_logical_and
id|cur-&gt;blocknr
op_logical_and
id|cur-&gt;dev
op_eq
id|dev
op_logical_and
id|cur-&gt;blocknr
op_eq
id|blocknr
)paren
(brace
id|can_dirty
op_assign
l_int|0
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
r_return
id|can_dirty
suffix:semicolon
)brace
multiline_comment|/* syncs the commit blocks, but does not force the real buffers to disk&n;** will wait until the current transaction is done/commited before returning &n;*/
DECL|function|journal_end_sync
r_int
id|journal_end_sync
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_return
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|COMMIT_NOW
op_or
id|WAIT
)paren
suffix:semicolon
)brace
macro_line|#ifdef __KERNEL__
DECL|function|show_reiserfs_locks
r_int
id|show_reiserfs_locks
c_func
(paren
r_void
)paren
(brace
id|dump_journal_writers
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0 /* debugging code for when we are compiled static don&squot;t delete */
id|p_s_sb
op_assign
id|sb_entry
c_func
(paren
id|super_blocks.next
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p_s_sb
op_ne
id|sb_entry
c_func
(paren
op_amp
id|super_blocks
)paren
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_is_super
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal lock is %d, join lock is %d, writers %d must wait is %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wlock
)paren
)paren
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;used cnodes %d, free cnodes %d&bslash;n&quot;
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_used
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_cnode_free
)paren
suffix:semicolon
)brace
id|p_s_sb
op_assign
id|sb_entry
c_func
(paren
id|p_s_sb-&gt;s_list.next
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;** used to get memory back from async commits that are floating around&n;** and to reclaim any blocks deleted but unusable because their commits&n;** haven&squot;t hit disk yet.  called from bitmap.c&n;**&n;** if it starts flushing things, it ors SCHEDULE_OCCURRED into repeat.&n;** note, this is just if schedule has a chance of occuring.  I need to &n;** change flush_commit_lists to have a repeat parameter too.&n;**&n;*/
DECL|function|flush_async_commits
r_void
id|flush_async_commits
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_ne
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|i
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** flushes any old transactions to disk&n;** ends the current transaction if it is too old&n;**&n;** also calls flush_journal_list with old_only == 1, which allows me to reclaim&n;** memory and such from the journal lists whose real blocks are all on disk.&n;**&n;** called by sync_dev_journal from buffer.c&n;*/
DECL|function|flush_old_commits
r_int
id|flush_old_commits
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|immediate
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|start
suffix:semicolon
id|time_t
id|now
suffix:semicolon
r_int
id|keep_dirty
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|start
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* safety check so we don&squot;t flush while we are replaying the log during mount */
r_if
c_cond
(paren
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kupdate&quot;
)paren
)paren
(brace
id|immediate
op_assign
l_int|0
suffix:semicolon
id|keep_dirty
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* starting with oldest, loop until we get to the start */
id|i
op_assign
(paren
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|i
op_ne
id|start
)paren
(brace
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
(paren
(paren
id|now
op_minus
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|i
)braket
dot
id|j_timestamp
)paren
OG
id|JOURNAL_MAX_COMMIT_AGE
op_logical_or
id|immediate
)paren
)paren
(brace
multiline_comment|/* we have to check again to be sure the current transaction did not change */
r_if
c_cond
(paren
id|i
op_ne
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|i
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|i
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
multiline_comment|/* now, check the current transaction.  If there are no writers, and it is too old, finish it, and&n;  ** force the commit blocks to disk&n;  */
r_if
c_cond
(paren
op_logical_neg
id|immediate
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
op_le
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
OG
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
OG
l_int|0
op_logical_and
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|JOURNAL_MAX_TRANS_AGE
)paren
(brace
id|journal_join
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
)paren
suffix:semicolon
id|keep_dirty
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|immediate
)paren
(brace
multiline_comment|/* belongs above, but I wanted this to be very explicit as a special case.  If they say to &n;                             flush, we must be sure old transactions hit the disk too. */
id|journal_join
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
op_or
id|WAIT
)paren
suffix:semicolon
)brace
id|keep_dirty
op_or_assign
id|reiserfs_journal_kupdate
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
id|keep_dirty
suffix:semicolon
)brace
multiline_comment|/*&n;** returns 0 if do_journal_end should return right away, returns 1 if do_journal_end should finish the commit&n;** &n;** if the current transaction is too old, but still has writers, this will wait on j_join_wait until all &n;** the writers are done.  By the time it wakes up, the transaction it was called has already ended, so it just&n;** flushes the commit list and returns 0.&n;**&n;** Won&squot;t batch when flush or commit_now is set.  Also won&squot;t batch when others are waiting on j_join_wait.&n;** &n;** Note, we can&squot;t allow the journal_end to proceed while there are still writers in the log.&n;*/
DECL|function|check_journal_end
r_static
r_int
id|check_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
(brace
id|time_t
id|now
suffix:semicolon
r_int
id|flush
op_assign
id|flags
op_amp
id|FLUSH_ALL
suffix:semicolon
r_int
id|commit_now
op_assign
id|flags
op_amp
id|COMMIT_NOW
suffix:semicolon
r_int
id|wait_on_commit
op_assign
id|flags
op_amp
id|WAIT
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_trans_id
op_ne
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1577: handle trans id %d != current trans id %d&bslash;n&quot;
comma
id|th-&gt;t_trans_id
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_sub_assign
(paren
id|th-&gt;t_blocks_allocated
op_minus
id|th-&gt;t_blocks_logged
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* &lt;= 0 is allowed.  unmounting might not call begin */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BUG, deal with case where j_len is 0, but people previously freed blocks need to be released &n;  ** will be dealt with by next transaction that actually writes something, but should be taken&n;  ** care of in this trans&n;  */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_eq
l_int|0
)paren
(brace
r_int
id|wcount
op_assign
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
OG
l_int|0
op_logical_and
id|wcount
op_le
l_int|0
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if wcount &gt; 0, and we are called to with flush or commit_now,&n;  ** we wait on j_join_wait.  We will wake up when the last writer has&n;  ** finished the transaction, and started it on its way to the disk.&n;  ** Then, we flush the commit or journal list, and just return 0 &n;  ** because the rest of journal end was already done for this transaction.&n;  */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flush
op_logical_or
id|commit_now
)paren
(brace
r_int
id|orig_jindex
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
op_assign
l_int|1
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* sleep while the current transaction is still j_jlocked */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_eq
id|th-&gt;t_trans_id
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_now
)paren
(brace
r_if
c_cond
(paren
id|wait_on_commit
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit_flush_async
c_func
(paren
id|p_s_sb
comma
id|orig_jindex
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* deal with old transactions where we are the last writers */
id|now
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|now
op_minus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
)paren
OG
id|JOURNAL_MAX_TRANS_AGE
)paren
(brace
id|commit_now
op_assign
l_int|1
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* don&squot;t batch when someone is waiting on j_join_wait */
multiline_comment|/* don&squot;t batch when syncing the commit or flushing the whole trans */
r_if
c_cond
(paren
op_logical_neg
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|flush
op_logical_and
op_logical_neg
id|commit_now
op_logical_and
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
OL
id|JOURNAL_MAX_BATCH
)paren
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
template_param
(paren
id|JOURNAL_TRANS_MAX
op_star
l_int|3
)paren
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bcount
op_increment
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
OG
id|JOURNAL_BLOCK_COUNT
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-003: journal_end: j_start (%d) is too high&bslash;n&quot;
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** Does all the work that makes deleting blocks safe.&n;** when deleting a block mark BH_JNew, just remove it from the current transaction, clean it&squot;s buffer_head and move on.&n;** &n;** otherwise:&n;** set a bit for the block in the journal bitmap.  That will prevent it from being allocated for unformatted nodes&n;** before this transaction has finished.&n;**&n;** mark any cnodes for this block as BLOCK_FREED, and clear their bh pointers.  That will prevent any old transactions with&n;** this block from trying to flush to the real location.  Since we aren&squot;t removing the cnode from the journal_list_hash,&n;** the block can&squot;t be reallocated yet.&n;**&n;** Then remove it from the current transaction, decrementing any counters and filing it on the clean list.&n;*/
DECL|function|journal_mark_freed
r_int
id|journal_mark_freed
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|blocknr
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cleaned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
id|bh
op_assign
id|get_hash_table
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|blocknr
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_logical_and
id|buffer_dirty
(paren
id|bh
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;journal_mark_freed(dont_log): dirty buffer on hash list: %lx %ld&bslash;n&quot;
comma
id|bh-&gt;b_state
comma
id|blocknr
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
)brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bh
op_assign
id|get_hash_table
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|blocknr
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
multiline_comment|/* if it is journal new, we just remove it from this transaction */
r_if
c_cond
(paren
id|bh
op_logical_and
id|buffer_journal_new
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
id|cleaned
op_assign
id|remove_from_transaction
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|cleaned
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the bit for this block in the journal bitmap for this transaction */
id|jb
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_list_bitmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1702: journal_mark_freed, journal_list_bitmap is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|set_bit_in_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|jb
)paren
suffix:semicolon
multiline_comment|/* Note, the entire while loop is not allowed to schedule.  */
r_if
c_cond
(paren
id|bh
)paren
(brace
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|cleaned
op_assign
id|remove_from_transaction
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|cleaned
)paren
suffix:semicolon
multiline_comment|/* find all older transactions with this block, make sure they don&squot;t try to write it out */
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|p_s_sb-&gt;s_dev
comma
id|blocknr
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|p_s_sb-&gt;s_dev
op_eq
id|cn-&gt;dev
op_logical_and
id|blocknr
op_eq
id|cn-&gt;blocknr
)paren
(brace
id|set_bit
c_func
(paren
id|BLOCK_FREED
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cleaned
)paren
(brace
multiline_comment|/* remove_from_transaction will brelse the buffer if it was &n;&t;    ** in the current trans&n;&t;    */
id|mark_buffer_notjournal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|reiserfs_clean_and_file_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
id|cleaned
op_assign
l_int|1
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|cn-&gt;bh-&gt;b_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|cn-&gt;bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-2138: cn-&gt;bh-&gt;b_count &lt; 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cn-&gt;jlist
)paren
(brace
multiline_comment|/* since we are clearing the bh, we MUST dec nonzerolen */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|cn-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
)brace
id|cn-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|cn
op_assign
id|cn-&gt;hnext
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
suffix:semicolon
multiline_comment|/* get_hash incs this */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;journal-2165: bh-&gt;b_count &lt; 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_restore_prepared_buffer
r_void
id|reiserfs_restore_prepared_buffer
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_dont_log
(paren
id|p_s_sb
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_return
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|tree_balance
op_star
id|cur_tb
suffix:semicolon
multiline_comment|/*&n;** before we can change a metadata block, we have to make sure it won&squot;t&n;** be written to disk while we are altering it.  So, we must:&n;** clean it&n;** wait on it.&n;** &n;*/
DECL|function|reiserfs_prepare_for_journal
r_void
id|reiserfs_prepare_for_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|wait
)paren
(brace
r_int
id|retry_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
(paren
id|p_s_sb
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
op_logical_or
(paren
id|wait
op_logical_and
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|BH_JPrepared
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
id|cur_tb
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs_prepare_for_journal, waiting while do_balance was running&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|retry_count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Wait for a page to get unlocked.&n; *&n; * This must be called with the caller &quot;holding&quot; the page,&n; * ie with increased &quot;page-&gt;count&quot; so that the page won&squot;t&n; * go away during the wait..&n; */
DECL|function|___reiserfs_wait_on_page
r_static
r_void
id|___reiserfs_wait_on_page
c_func
(paren
r_struct
id|reiserfs_page_list
op_star
id|pl
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|pl-&gt;page
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_do
(brace
id|block_sync_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
op_logical_or
id|pl-&gt;do_not_lock
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get an exclusive lock on the page..&n; * but, every time you get woken up, check the page to make sure&n; * someone hasn&squot;t called a journal_begin with it locked.&n; *&n; * the page should always be locked when this returns&n; *&n; * returns 0 if you&squot;ve got the page locked&n; * returns 1 if it returns because someone else has called journal_begin&n; *           with the page locked&n; * this is only useful to the code that flushes pages before a &n; * commit.  Do not export this hack.  Ever.&n; */
DECL|function|reiserfs_try_lock_page
r_static
r_int
id|reiserfs_try_lock_page
c_func
(paren
r_struct
id|reiserfs_page_list
op_star
id|pl
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pl-&gt;page
suffix:semicolon
r_while
c_loop
(paren
id|TryLockPage
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|pl-&gt;do_not_lock
)paren
(brace
multiline_comment|/* the page is locked, but we cannot have it */
r_return
l_int|1
suffix:semicolon
)brace
id|___reiserfs_wait_on_page
c_func
(paren
id|pl
)paren
suffix:semicolon
)brace
multiline_comment|/* we have the page locked */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** This can only be called from do_journal_end.&n;** it runs through the list things that need flushing before the&n;** transaction can commit, and writes each of them to disk&n;**&n;*/
DECL|function|flush_pages_before_commit
r_static
r_void
id|flush_pages_before_commit
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_page_list
op_star
id|pl
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_flush_pages
suffix:semicolon
r_struct
id|reiserfs_page_list
op_star
id|pl_tmp
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first write each dirty unlocked buffer in the list */
r_while
c_loop
(paren
id|pl
)paren
(brace
multiline_comment|/* ugly.  journal_end can be called from get_block, which has a &n;    ** page locked.  So, we have to check to see if pl-&gt;page is the page&n;    ** currently locked by the calling function, and if so, skip the&n;    ** lock&n;    */
r_if
c_cond
(paren
id|reiserfs_try_lock_page
c_func
(paren
id|pl
)paren
)paren
(brace
r_goto
id|setup_next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|pl-&gt;page
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pl-&gt;page-&gt;buffers
)paren
(brace
id|head
op_assign
id|pl-&gt;page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|bh-&gt;b_blocknr
op_eq
id|pl-&gt;blocknr
op_logical_and
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pl-&gt;do_not_lock
)paren
(brace
id|UnlockPage
c_func
(paren
id|pl-&gt;page
)paren
suffix:semicolon
)brace
id|setup_next
suffix:colon
id|pl
op_assign
id|pl-&gt;next
suffix:semicolon
)brace
multiline_comment|/* now wait on them */
id|pl
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_flush_pages
suffix:semicolon
r_while
c_loop
(paren
id|pl
)paren
(brace
r_if
c_cond
(paren
id|reiserfs_try_lock_page
c_func
(paren
id|pl
)paren
)paren
(brace
r_goto
id|remove_page
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|pl-&gt;page
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pl-&gt;page-&gt;buffers
)paren
(brace
id|head
op_assign
id|pl-&gt;page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|bh-&gt;b_blocknr
op_eq
id|pl-&gt;blocknr
)paren
(brace
id|count
op_increment
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-2443: flush_pages_before_commit, error writing block %lu&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pl-&gt;do_not_lock
)paren
(brace
id|UnlockPage
c_func
(paren
id|pl-&gt;page
)paren
suffix:semicolon
)brace
id|remove_page
suffix:colon
multiline_comment|/* we&squot;ve waited on the I/O, we can remove the page from the&n;    ** list, and free our pointer struct to it.&n;    */
r_if
c_cond
(paren
id|pl-&gt;prev
)paren
(brace
id|pl-&gt;prev-&gt;next
op_assign
id|pl-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pl-&gt;next
)paren
(brace
id|pl-&gt;next-&gt;prev
op_assign
id|pl-&gt;prev
suffix:semicolon
)brace
id|put_page
c_func
(paren
id|pl-&gt;page
)paren
suffix:semicolon
id|pl_tmp
op_assign
id|pl
suffix:semicolon
id|pl
op_assign
id|pl-&gt;next
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|pl_tmp
comma
r_sizeof
(paren
r_struct
id|reiserfs_page_list
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_flush_pages
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** called when a indirect item is converted back into a tail.&n;**&n;** The reiserfs part of the inode stores enough information to find&n;** our page_list struct in the flush list.  We remove it from the list&n;** and free the struct.&n;**&n;** Note, it is possible for this to happen:&n;**&n;** reiserfs_add_page_to_flush_list(inode)&n;** transaction ends, list is flushed&n;** reiserfs_remove_page_from_flush_list(inode)&n;**&n;** This would be bad because the page_list pointer in the inode is not&n;** updated when the list is flushed, so we can&squot;t know if the pointer is&n;** valid.  So, in the inode, we also store the transaction id when the&n;** page was added.  If we are trying to remove something from an old &n;** transaction, we just clear out the pointer in the inode and return.&n;**&n;** Normal case is to use the reiserfs_page_list pointer in the inode to &n;** find and remove the page from the flush list.&n;*/
DECL|function|reiserfs_remove_page_from_flush_list
r_int
id|reiserfs_remove_page_from_flush_list
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|reiserfs_page_list
op_star
id|pl
suffix:semicolon
multiline_comment|/* was this conversion done in a previous transaction? If so, return */
r_if
c_cond
(paren
id|inode-&gt;u.reiserfs_i.i_conversion_trans_id
OL
id|th-&gt;t_trans_id
)paren
(brace
id|inode-&gt;u.reiserfs_i.i_converted_page
op_assign
l_int|NULL
suffix:semicolon
id|inode-&gt;u.reiserfs_i.i_conversion_trans_id
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* remove the page_list struct from the list, release our hold on the&n;  ** page, and free the page_list struct&n;  */
id|pl
op_assign
id|inode-&gt;u.reiserfs_i.i_converted_page
suffix:semicolon
r_if
c_cond
(paren
id|pl
)paren
(brace
r_if
c_cond
(paren
id|pl-&gt;next
)paren
(brace
id|pl-&gt;next-&gt;prev
op_assign
id|pl-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pl-&gt;prev
)paren
(brace
id|pl-&gt;prev-&gt;next
op_assign
id|pl-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_flush_pages
op_eq
id|pl
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_flush_pages
op_assign
id|pl-&gt;next
suffix:semicolon
)brace
id|put_page
c_func
(paren
id|pl-&gt;page
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|pl
comma
r_sizeof
(paren
r_struct
id|reiserfs_page_list
)paren
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|inode-&gt;u.reiserfs_i.i_converted_page
op_assign
l_int|NULL
suffix:semicolon
id|inode-&gt;u.reiserfs_i.i_conversion_trans_id
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Called after a direct to indirect transaction.  The unformatted node&n;** must be flushed to disk before the transaction commits, otherwise, we&n;** risk losing the data from the direct item.  This adds the page&n;** containing the unformatted node to a list of pages that need flushing.&n;**&n;** it calls get_page(page), so the page won&squot;t disappear until we&squot;ve&n;** flushed or removed it from our list.&n;**&n;** pointers to the reiserfs_page_list struct are stored in the inode, &n;** so this page can be quickly removed from the list after the tail is&n;** converted back into a direct item.&n;**&n;** If we fail to find the memory for the reiserfs_page_list struct, we&n;** just sync the page now.  Not good, but safe.&n;**&n;** since this must be called with the page locked, we always set&n;** the do_not_lock field in the page_list struct we allocate&n;**&n;*/
DECL|function|reiserfs_add_page_to_flush_list
r_int
id|reiserfs_add_page_to_flush_list
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_page_list
op_star
id|new_pl
suffix:semicolon
multiline_comment|/* debugging use ONLY.  Do not define this on data you care about. */
macro_line|#ifdef REISERFS_NO_FLUSH_AFTER_CONVERT
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|get_page
c_func
(paren
id|bh-&gt;b_page
)paren
suffix:semicolon
id|new_pl
op_assign
id|reiserfs_kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_page_list
)paren
comma
id|GFP_BUFFER
comma
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_pl
)paren
(brace
id|put_page
c_func
(paren
id|bh-&gt;b_page
)paren
suffix:semicolon
id|reiserfs_warning
c_func
(paren
l_string|&quot;journal-2480: forced to flush page, out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;journal-2484: error writing buffer %lu to disk&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|inode-&gt;u.reiserfs_i.i_converted_page
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|new_pl-&gt;page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|new_pl-&gt;do_not_lock
op_assign
l_int|1
suffix:semicolon
id|new_pl-&gt;blocknr
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|new_pl-&gt;next
op_assign
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_flush_pages
suffix:semicolon
r_if
c_cond
(paren
id|new_pl-&gt;next
)paren
(brace
id|new_pl-&gt;next-&gt;prev
op_assign
id|new_pl
suffix:semicolon
)brace
id|new_pl-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|j_flush_pages
op_assign
id|new_pl
suffix:semicolon
multiline_comment|/* if we have numbers from an old transaction, zero the converted&n;  ** page, it has already been flushed and freed&n;  */
r_if
c_cond
(paren
id|inode-&gt;u.reiserfs_i.i_conversion_trans_id
op_logical_and
id|inode-&gt;u.reiserfs_i.i_conversion_trans_id
OL
id|th-&gt;t_trans_id
)paren
(brace
id|inode-&gt;u.reiserfs_i.i_converted_page
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;u.reiserfs_i.i_converted_page
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;journal-2501: inode already had a converted page&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|inode-&gt;u.reiserfs_i.i_converted_page
op_assign
id|new_pl
suffix:semicolon
id|inode-&gt;u.reiserfs_i.i_conversion_trans_id
op_assign
id|th-&gt;t_trans_id
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** long and ugly.  If flush, will not return until all commit&n;** blocks and all real buffers in the trans are on disk.&n;** If no_async, won&squot;t return until all commit blocks are on disk.&n;**&n;** keep reading, there are comments as you go along&n;*/
DECL|function|do_journal_end
r_static
r_int
id|do_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|next
comma
op_star
id|jl_cn
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|last_cn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
multiline_comment|/* commit bh */
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
multiline_comment|/* desc bh */
r_int
id|cur_write_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start index of current log write */
r_int
id|cur_blocks_left
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of journal blocks left to write */
r_int
id|old_start
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|jindex
suffix:semicolon
r_int
id|orig_jindex
suffix:semicolon
r_int
id|flush
op_assign
id|flags
op_amp
id|FLUSH_ALL
suffix:semicolon
r_int
id|commit_now
op_assign
id|flags
op_amp
id|COMMIT_NOW
suffix:semicolon
r_int
id|wait_on_commit
op_assign
id|flags
op_amp
id|WAIT
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_dont_log
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
)paren
(brace
id|flags
op_or_assign
id|FLUSH_ALL
suffix:semicolon
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
)paren
(brace
id|flags
op_or_assign
id|COMMIT_NOW
suffix:semicolon
id|commit_now
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check_journal_end locks the journal, and unlocks if it does not return 1 &n;  ** it tells us if we should continue with the journal_end, or just return&n;  */
r_if
c_cond
(paren
op_logical_neg
id|check_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|flags
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check_journal_end might set these, check again */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
)paren
(brace
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
)paren
(brace
id|commit_now
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;  ** j must wait means we have to flush the log blocks, and the real blocks for&n;  ** this transaction&n;  */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
OG
l_int|0
)paren
(brace
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* setup description block */
id|d_bh
op_assign
id|getblk
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|d_bh
comma
l_int|1
)paren
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
(paren
id|d_bh
)paren
op_member_access_from_pointer
id|b_data
suffix:semicolon
id|memset
c_func
(paren
id|desc
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_desc
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|desc-&gt;j_magic
comma
id|JOURNAL_DESC_MAGIC
comma
l_int|8
)paren
suffix:semicolon
id|desc-&gt;j_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
multiline_comment|/* setup commit block.  Don&squot;t write (keep it clean too) this one until after everyone else is written */
id|c_bh
op_assign
id|getblk
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
id|memset
c_func
(paren
id|commit
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_commit
)paren
)paren
suffix:semicolon
id|commit-&gt;j_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|c_bh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* init this journal list */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_older_commits_done
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_trans_id
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_timestamp
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_bh
op_assign
id|c_bh
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_start
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_len
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_nonzerolen
)paren
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_left
)paren
comma
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
l_int|2
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_realblock
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* which is faster, locking/unlocking at the start and end of the for&n;  ** or locking once per iteration around the insert_journal_hash?&n;  ** eitherway, we are write locking insert_journal_hash.  The ENTIRE FOR&n;  ** LOOP MUST not cause schedule to occur.&n;  */
multiline_comment|/* for each real block, add it to the journal list hash,&n;  ** copy into real block index array in the commit or desc block&n;  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
suffix:semicolon
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|cn-&gt;bh-&gt;b_state
)paren
)paren
(brace
id|jl_cn
op_assign
id|get_cnode
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jl_cn
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1676, get_cnode returned NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_realblock
op_assign
id|jl_cn
suffix:semicolon
)brace
id|jl_cn-&gt;prev
op_assign
id|last_cn
suffix:semicolon
id|jl_cn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|last_cn
)paren
(brace
id|last_cn-&gt;next
op_assign
id|jl_cn
suffix:semicolon
)brace
id|last_cn
op_assign
id|jl_cn
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;bh-&gt;b_blocknr
op_ge
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_logical_and
id|cn-&gt;bh-&gt;b_blocknr
OL
(paren
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
id|JOURNAL_BLOCK_COUNT
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-2332: Trying to log block %lu, which is a log block&bslash;n&quot;
comma
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|jl_cn-&gt;blocknr
op_assign
id|cn-&gt;bh-&gt;b_blocknr
suffix:semicolon
id|jl_cn-&gt;state
op_assign
l_int|0
suffix:semicolon
id|jl_cn-&gt;dev
op_assign
id|cn-&gt;bh-&gt;b_dev
suffix:semicolon
id|jl_cn-&gt;bh
op_assign
id|cn-&gt;bh
suffix:semicolon
id|jl_cn-&gt;jlist
op_assign
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|insert_journal_hash
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_list_hash_table
comma
id|jl_cn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|JOURNAL_TRANS_HALF
)paren
(brace
id|desc-&gt;j_realblock
(braket
id|i
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit-&gt;j_realblock
(braket
id|i
op_minus
id|JOURNAL_TRANS_HALF
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|i
op_decrement
suffix:semicolon
)brace
)brace
id|desc-&gt;j_len
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
id|desc-&gt;j_mount_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_mount_id
)paren
suffix:semicolon
id|desc-&gt;j_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
)paren
suffix:semicolon
id|commit-&gt;j_len
op_assign
id|cpu_to_le32
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
)paren
suffix:semicolon
multiline_comment|/* special check in case all buffers in the journal were marked for not logging */
r_if
c_cond
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_eq
l_int|0
)paren
(brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;journal-2020: do_journal_end: BAD desc-&gt;j_len is ZERO&bslash;n&quot;
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* first data block is j_start + 1, so add one to cur_write_start wherever you use it */
id|cur_write_start
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|cur_blocks_left
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
suffix:semicolon
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
suffix:semicolon
id|jindex
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start at one so we don&squot;t get the desc again */
r_while
c_loop
(paren
id|cur_blocks_left
OG
l_int|0
)paren
(brace
multiline_comment|/* copy all the real blocks into log area.  dirty log blocks */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
id|cn-&gt;bh-&gt;b_state
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp_bh
suffix:semicolon
id|tmp_bh
op_assign
id|getblk
c_func
(paren
id|p_s_sb-&gt;s_dev
comma
id|reiserfs_get_journal_block
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|cur_write_start
op_plus
id|jindex
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|tmp_bh
comma
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp_bh-&gt;b_data
comma
id|cn-&gt;bh-&gt;b_data
comma
id|cn-&gt;bh-&gt;b_size
)paren
suffix:semicolon
id|jindex
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* JDirty cleared sometime during transaction.  don&squot;t log this one */
id|printk
c_func
(paren
l_string|&quot;journal-2048: do_journal_end: BAD, buffer in journal hash, but not JDirty!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
id|cur_blocks_left
op_decrement
suffix:semicolon
)brace
multiline_comment|/* we are done  with both the c_bh and d_bh, but&n;  ** c_bh must be written after all other commit blocks,&n;  ** so we dirty/relse c_bh in flush_commit_list, with commit_left &lt;= 1.&n;  */
multiline_comment|/* now loop through and mark all buffers from this transaction as JDirty_wait&n;  ** clear the JDirty bit, clear BH_JNew too.  &n;  ** if they weren&squot;t JDirty, they weren&squot;t logged, just relse them and move on&n;  */
id|cn
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_JNew
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JDirty_wait
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_JDirty
comma
op_amp
(paren
id|cn-&gt;bh-&gt;b_state
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|brelse
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
id|next
op_assign
id|cn-&gt;next
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|cn
)paren
suffix:semicolon
id|cn
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/* unlock the journal list for committing and flushing */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_flushing
)paren
comma
l_int|0
)paren
suffix:semicolon
id|orig_jindex
op_assign
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|jindex
op_assign
(paren
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
op_assign
id|jindex
suffix:semicolon
multiline_comment|/* make sure to flush any data converted from direct items to&n;  ** indirect items before allowing the commit blocks to reach the&n;  ** disk&n;  */
id|flush_pages_before_commit
c_func
(paren
id|th
comma
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* honor the flush and async wishes from the caller */
r_if
c_cond
(paren
id|flush
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|commit_now
)paren
(brace
r_if
c_cond
(paren
id|wait_on_commit
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|orig_jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit_flush_async
c_func
(paren
id|p_s_sb
comma
id|orig_jindex
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* reset journal values for the next transaction */
id|old_start
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_assign
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_plus
l_int|2
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_wcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_bcount
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_last
op_assign
l_int|NULL
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_first
op_assign
l_int|NULL
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_start_time
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_id
op_increment
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_len_alloc
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_full_flush
op_assign
l_int|0
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_next_async_flush
op_assign
l_int|0
suffix:semicolon
id|init_journal_hash
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* if the next transaction has any chance of wrapping, flush &n;  ** transactions that might get overwritten.  If any journal lists are very &n;  ** old flush them as well.  &n;  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_LIST_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jindex
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_le
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_start
)paren
(brace
r_if
c_cond
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|JOURNAL_TRANS_MAX
op_plus
l_int|1
)paren
op_ge
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_start
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|JOURNAL_TRANS_MAX
op_plus
l_int|1
)paren
OG
id|JOURNAL_BLOCK_COUNT
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_start
op_plus
id|JOURNAL_TRANS_MAX
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_BLOCK_COUNT
)paren
op_ge
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_start
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* this check should always be run, to send old lists to disk */
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_len
OG
l_int|0
op_logical_and
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|jindex
)braket
dot
id|j_timestamp
OL
(paren
id|CURRENT_TIME
op_minus
(paren
id|JOURNAL_MAX_TRANS_AGE
op_star
l_int|4
)paren
)paren
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|jindex
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if the next journal_list is still in use, flush it */
r_if
c_cond
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_len
op_ne
l_int|0
)paren
(brace
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t want anyone flushing the new transaction&squot;s list */
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_commit_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_flushing
)paren
comma
l_int|1
)paren
suffix:semicolon
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_list_bitmap
op_assign
id|get_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|SB_JOURNAL_LIST
c_func
(paren
id|p_s_sb
)paren
(braket
id|SB_JOURNAL_LIST_INDEX
c_func
(paren
id|p_s_sb
)paren
)braket
dot
id|j_list_bitmap
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1996: do_journal_end, could not get a list bitmap&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* wake up any body waiting to join. */
id|wake_up
c_func
(paren
op_amp
(paren
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_join_wait
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
