multiline_comment|/*&n;** Write ahead logging implementation copyright Chris Mason 2000&n;**&n;** The background commits make this code very interelated, and &n;** overly complex.  I need to rethink things a bit....The major players:&n;**&n;** journal_begin -- call with the number of blocks you expect to log.  &n;**                  If the current transaction is too&n;** &t;&t;    old, it will block until the current transaction is &n;** &t;&t;    finished, and then start a new one.&n;**&t;&t;    Usually, your transaction will get joined in with &n;**                  previous ones for speed.&n;**&n;** journal_join  -- same as journal_begin, but won&squot;t block on the current &n;**                  transaction regardless of age.  Don&squot;t ever call&n;**                  this.  Ever.  There are only two places it should be &n;**                  called from, and they are both inside this file.&n;**&n;** journal_mark_dirty -- adds blocks into this transaction.  clears any flags &n;**                       that might make them get sent to disk&n;**                       and then marks them BH_JDirty.  Puts the buffer head &n;**                       into the current transaction hash.  &n;**&n;** journal_end -- if the current transaction is batchable, it does nothing&n;**                   otherwise, it could do an async/synchronous commit, or&n;**                   a full flush of all log and real blocks in the &n;**                   transaction.&n;**&n;** flush_old_commits -- if the current transaction is too old, it is ended and &n;**                      commit blocks are sent to disk.  Forces commit blocks &n;**                      to disk for all backgrounded commits that have been &n;**                      around too long.&n;**&t;&t;     -- Note, if you call this as an immediate flush from &n;**&t;&t;        from within kupdate, it will ignore the immediate flag&n;*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
multiline_comment|/* gets a struct reiserfs_journal_list * from a list head */
DECL|macro|JOURNAL_LIST_ENTRY
mdefine_line|#define JOURNAL_LIST_ENTRY(h) (list_entry((h), struct reiserfs_journal_list, &bslash;&n;                               j_list))
DECL|macro|JOURNAL_WORK_ENTRY
mdefine_line|#define JOURNAL_WORK_ENTRY(h) (list_entry((h), struct reiserfs_journal_list, &bslash;&n;                               j_working_list))
multiline_comment|/* the number of mounted filesystems.  This is used to decide when to&n;** start and kill the commit workqueue&n;*/
DECL|variable|reiserfs_mounted_fs_count
r_static
r_int
id|reiserfs_mounted_fs_count
suffix:semicolon
DECL|variable|commit_wq
r_static
r_struct
id|workqueue_struct
op_star
id|commit_wq
suffix:semicolon
DECL|macro|JOURNAL_TRANS_HALF
mdefine_line|#define JOURNAL_TRANS_HALF 1018   /* must be correct to keep the desc and commit&n;&t;&t;&t;&t;     structs at 4k */
DECL|macro|BUFNR
mdefine_line|#define BUFNR 64 /*read ahead */
multiline_comment|/* cnode stat bits.  Move these into reiserfs_fs.h */
DECL|macro|BLOCK_FREED
mdefine_line|#define BLOCK_FREED 2&t;&t;/* this block was freed, and can&squot;t be written.  */
DECL|macro|BLOCK_FREED_HOLDER
mdefine_line|#define BLOCK_FREED_HOLDER 3    /* this block was freed during this transaction, and can&squot;t be written */
DECL|macro|BLOCK_NEEDS_FLUSH
mdefine_line|#define BLOCK_NEEDS_FLUSH 4&t;/* used in flush_journal_list */
DECL|macro|BLOCK_DIRTIED
mdefine_line|#define BLOCK_DIRTIED 5
multiline_comment|/* journal list state bits */
DECL|macro|LIST_TOUCHED
mdefine_line|#define LIST_TOUCHED 1
DECL|macro|LIST_DIRTY
mdefine_line|#define LIST_DIRTY   2
DECL|macro|LIST_COMMIT_PENDING
mdefine_line|#define LIST_COMMIT_PENDING  4&t;&t;/* someone will commit this list */
multiline_comment|/* flags for do_journal_end */
DECL|macro|FLUSH_ALL
mdefine_line|#define FLUSH_ALL   1&t;&t;/* flush commit and real blocks */
DECL|macro|COMMIT_NOW
mdefine_line|#define COMMIT_NOW  2&t;&t;/* end and commit this transaction */
DECL|macro|WAIT
mdefine_line|#define WAIT        4&t;&t;/* wait for the log blocks to hit the disk*/
r_static
r_int
id|do_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
comma
r_struct
id|super_block
op_star
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
suffix:semicolon
r_static
r_int
id|flush_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
suffix:semicolon
r_static
r_int
id|flush_commit_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
suffix:semicolon
r_static
r_int
id|can_dirty
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
suffix:semicolon
r_static
r_int
id|journal_join
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|release_journal_dev
c_func
(paren
r_struct
id|super_block
op_star
id|super
comma
r_struct
id|reiserfs_journal
op_star
id|journal
)paren
suffix:semicolon
r_static
r_int
id|dirty_one_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
suffix:semicolon
r_static
r_void
id|flush_async_commits
c_func
(paren
r_void
op_star
id|p
)paren
suffix:semicolon
r_static
r_void
id|queue_log_writer
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
suffix:semicolon
multiline_comment|/* values for join in do_journal_begin_r */
r_enum
(brace
DECL|enumerator|JBEGIN_REG
id|JBEGIN_REG
op_assign
l_int|0
comma
multiline_comment|/* regular journal begin */
DECL|enumerator|JBEGIN_JOIN
id|JBEGIN_JOIN
op_assign
l_int|1
comma
multiline_comment|/* join the running transaction if at all possible */
DECL|enumerator|JBEGIN_ABORT
id|JBEGIN_ABORT
op_assign
l_int|2
comma
multiline_comment|/* called from cleanup code, ignores aborted flag */
)brace
suffix:semicolon
r_static
r_int
id|do_journal_begin_r
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|join
)paren
suffix:semicolon
DECL|function|init_journal_hash
r_static
r_void
id|init_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|memset
c_func
(paren
id|journal-&gt;j_hash_table
comma
l_int|0
comma
id|JOURNAL_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** clears BH_Dirty and sticks the buffer on the clean list.  Called because I can&squot;t allow refile_buffer to&n;** make schedule happen after I&squot;ve freed a block.  Look at remove_from_transaction and journal_mark_freed for&n;** more details.&n;*/
DECL|function|reiserfs_clean_and_file_buffer
r_static
r_int
id|reiserfs_clean_and_file_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_journal_test
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|disable_barrier
r_static
r_void
id|disable_barrier
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|REISERFS_BARRIER_FLUSH
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reiserfs: disabling flush barriers on %s&bslash;n&quot;
comma
id|reiserfs_bdevname
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
r_static
r_struct
id|reiserfs_bitmap_node
op_star
DECL|function|allocate_bitmap_node
id|allocate_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
suffix:semicolon
r_static
r_int
id|id
suffix:semicolon
id|bn
op_assign
id|reiserfs_kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|bn-&gt;data
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|p_s_sb-&gt;s_blocksize
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn-&gt;data
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|bn
comma
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bn-&gt;id
op_assign
id|id
op_increment
suffix:semicolon
id|memset
c_func
(paren
id|bn-&gt;data
comma
l_int|0
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|bn-&gt;list
)paren
suffix:semicolon
r_return
id|bn
suffix:semicolon
)brace
r_static
r_struct
id|reiserfs_bitmap_node
op_star
DECL|function|get_bitmap_node
id|get_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
op_assign
id|journal-&gt;j_bitmap_nodes.next
suffix:semicolon
id|journal-&gt;j_used_bitmap_nodes
op_increment
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|entry
op_ne
op_amp
id|journal-&gt;j_bitmap_nodes
)paren
(brace
id|bn
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|reiserfs_bitmap_node
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|entry
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bn-&gt;data
comma
l_int|0
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|journal-&gt;j_free_bitmap_nodes
op_decrement
suffix:semicolon
r_return
id|bn
suffix:semicolon
)brace
id|bn
op_assign
id|allocate_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bn
)paren
(brace
id|yield
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_return
id|bn
suffix:semicolon
)brace
DECL|function|free_bitmap_node
r_static
r_inline
r_void
id|free_bitmap_node
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|journal-&gt;j_used_bitmap_nodes
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_free_bitmap_nodes
OG
id|REISERFS_MAX_BITMAP_NODES
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|bn-&gt;data
comma
id|p_s_sb-&gt;s_blocksize
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|bn
comma
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
)brace
r_else
(brace
id|list_add
c_func
(paren
op_amp
id|bn-&gt;list
comma
op_amp
id|journal-&gt;j_bitmap_nodes
)paren
suffix:semicolon
id|journal-&gt;j_free_bitmap_nodes
op_increment
suffix:semicolon
)brace
)brace
DECL|function|allocate_bitmap_nodes
r_static
r_void
id|allocate_bitmap_nodes
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|REISERFS_MIN_BITMAP_NODES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bn
op_assign
id|allocate_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bn
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|bn-&gt;list
comma
op_amp
id|journal-&gt;j_bitmap_nodes
)paren
suffix:semicolon
id|journal-&gt;j_free_bitmap_nodes
op_increment
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
singleline_comment|// this is ok, we&squot;ll try again when more are needed 
)brace
)brace
)brace
DECL|function|set_bit_in_list_bitmap
r_static
r_int
id|set_bit_in_list_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|block
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
)paren
(brace
r_int
id|bmap_nr
op_assign
id|block
op_div
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_int
id|bit_nr
op_assign
id|block
op_mod
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
)paren
(brace
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_assign
id|get_bitmap_node
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|bit_nr
comma
(paren
r_int
r_int
op_star
)paren
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_bitmap_list
r_static
r_void
id|cleanup_bitmap_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|jb-&gt;bitmaps
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|jb-&gt;bitmaps
(braket
id|i
)braket
)paren
(brace
id|free_bitmap_node
c_func
(paren
id|p_s_sb
comma
id|jb-&gt;bitmaps
(braket
id|i
)braket
)paren
suffix:semicolon
id|jb-&gt;bitmaps
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** only call this on FS unmount.&n;*/
DECL|function|free_list_bitmaps
r_static
r_int
id|free_list_bitmaps
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb_array
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jb
op_assign
id|jb_array
op_plus
id|i
suffix:semicolon
id|jb-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|cleanup_bitmap_list
c_func
(paren
id|p_s_sb
comma
id|jb
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|jb-&gt;bitmaps
)paren
suffix:semicolon
id|jb-&gt;bitmaps
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|free_bitmap_nodes
r_static
r_int
id|free_bitmap_nodes
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|next
op_assign
id|journal-&gt;j_bitmap_nodes.next
suffix:semicolon
r_struct
id|reiserfs_bitmap_node
op_star
id|bn
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|journal-&gt;j_bitmap_nodes
)paren
(brace
id|bn
op_assign
id|list_entry
c_func
(paren
id|next
comma
r_struct
id|reiserfs_bitmap_node
comma
id|list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|next
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|bn-&gt;data
comma
id|p_s_sb-&gt;s_blocksize
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|bn
comma
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|next
op_assign
id|journal-&gt;j_bitmap_nodes.next
suffix:semicolon
id|journal-&gt;j_free_bitmap_nodes
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** get memory for JOURNAL_NUM_BITMAPS worth of bitmaps. &n;** jb_array is the array to be filled in.&n;*/
DECL|function|reiserfs_allocate_list_bitmaps
r_int
id|reiserfs_allocate_list_bitmaps
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_list_bitmap
op_star
id|jb_array
comma
r_int
id|bmap_nr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_int
id|mem
op_assign
id|bmap_nr
op_star
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_node
op_star
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|jb
op_assign
id|jb_array
op_plus
id|i
suffix:semicolon
id|jb-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|jb-&gt;bitmaps
op_assign
id|vmalloc
c_func
(paren
id|mem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb-&gt;bitmaps
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;clm-2000, unable to allocate bitmaps for journal lists&quot;
)paren
suffix:semicolon
id|failed
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|jb-&gt;bitmaps
comma
l_int|0
comma
id|mem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|failed
)paren
(brace
id|free_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|jb_array
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** find an available list bitmap.  If you can&squot;t find one, flush a commit list &n;** and try again&n;*/
r_static
r_struct
id|reiserfs_list_bitmap
op_star
DECL|function|get_list_bitmap
id|get_list_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
(paren
id|JOURNAL_NUM_BITMAPS
op_star
l_int|3
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|i
op_assign
id|journal-&gt;j_list_bitmap_index
suffix:semicolon
id|journal-&gt;j_list_bitmap_index
op_assign
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|jb
op_assign
id|journal-&gt;j_list_bitmap
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_list_bitmap
(braket
id|i
)braket
dot
id|journal_list
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|jb-&gt;journal_list
)paren
(brace
multiline_comment|/* double check to make sure if flushed correctly */
r_return
l_int|NULL
suffix:semicolon
)brace
id|jb-&gt;journal_list
op_assign
id|jl
suffix:semicolon
r_return
id|jb
suffix:semicolon
)brace
multiline_comment|/* &n;** allocates a new chunk of X nodes, and links them all together as a list.&n;** Uses the cnode-&gt;next and cnode-&gt;prev pointers&n;** returns NULL on failure&n;*/
DECL|function|allocate_cnodes
r_static
r_struct
id|reiserfs_journal_cnode
op_star
id|allocate_cnodes
c_func
(paren
r_int
id|num_cnodes
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|head
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|num_cnodes
op_le
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|head
op_assign
id|vmalloc
c_func
(paren
id|num_cnodes
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|head
comma
l_int|0
comma
id|num_cnodes
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
id|head
(braket
l_int|0
)braket
dot
id|prev
op_assign
l_int|NULL
suffix:semicolon
id|head
(braket
l_int|0
)braket
dot
id|next
op_assign
id|head
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|num_cnodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|head
(braket
id|i
)braket
dot
id|prev
op_assign
id|head
op_plus
(paren
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|head
(braket
id|i
)braket
dot
id|next
op_assign
id|head
op_plus
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if last one, overwrite it after the if */
)brace
id|head
(braket
id|num_cnodes
op_minus
l_int|1
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
multiline_comment|/*&n;** pulls a cnode off the free list, or returns NULL on failure &n;*/
DECL|function|get_cnode
r_static
r_struct
id|reiserfs_journal_cnode
op_star
id|get_cnode
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
id|p_s_sb
comma
l_string|&quot;get_cnode&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_cnode_free
op_le
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|journal-&gt;j_cnode_used
op_increment
suffix:semicolon
id|journal-&gt;j_cnode_free
op_decrement
suffix:semicolon
id|cn
op_assign
id|journal-&gt;j_cnode_free_list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
r_return
id|cn
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn-&gt;next
)paren
(brace
id|cn-&gt;next-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
)brace
id|journal-&gt;j_cnode_free_list
op_assign
id|cn-&gt;next
suffix:semicolon
id|memset
c_func
(paren
id|cn
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
)paren
)paren
suffix:semicolon
r_return
id|cn
suffix:semicolon
)brace
multiline_comment|/*&n;** returns a cnode to the free list &n;*/
DECL|function|free_cnode
r_static
r_void
id|free_cnode
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
id|p_s_sb
comma
l_string|&quot;free_cnode&quot;
)paren
suffix:semicolon
id|journal-&gt;j_cnode_used
op_decrement
suffix:semicolon
id|journal-&gt;j_cnode_free
op_increment
suffix:semicolon
multiline_comment|/* memset(cn, 0, sizeof(struct reiserfs_journal_cnode)) ; */
id|cn-&gt;next
op_assign
id|journal-&gt;j_cnode_free_list
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_cnode_free_list
)paren
(brace
id|journal-&gt;j_cnode_free_list-&gt;prev
op_assign
id|cn
suffix:semicolon
)brace
id|cn-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not needed with the memset, but I might kill the memset, and forget to do this */
id|journal-&gt;j_cnode_free_list
op_assign
id|cn
suffix:semicolon
)brace
DECL|function|clear_prepared_bits
r_static
r_void
id|clear_prepared_bits
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|clear_buffer_journal_prepared
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_journal_restore_dirty
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* utility function to force a BUG if it is called without the big&n;** kernel lock held.  caller is the string printed just before calling BUG()&n;*/
DECL|function|reiserfs_check_lock_depth
r_void
id|reiserfs_check_lock_depth
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_char
op_star
id|caller
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
id|current-&gt;lock_depth
OL
l_int|0
)paren
(brace
id|reiserfs_panic
(paren
id|sb
comma
l_string|&quot;%s called without kernel lock held&quot;
comma
id|caller
)paren
suffix:semicolon
)brace
macro_line|#else
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* return a cnode with same dev, block number and size in table, or null if not found */
r_static
r_inline
r_struct
id|reiserfs_journal_cnode
op_star
DECL|function|get_journal_hash_dev
id|get_journal_hash_dev
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_int
id|bl
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
id|cn
op_assign
id|journal_hash
c_func
(paren
id|table
comma
id|sb
comma
id|bl
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
id|bl
op_logical_and
id|cn-&gt;sb
op_eq
id|sb
)paren
r_return
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;hnext
suffix:semicolon
)brace
r_return
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** this actually means &squot;can this block be reallocated yet?&squot;.  If you set search_all, a block can only be allocated&n;** if it is not in the current transaction, was not freed by the current transaction, and has no chance of ever&n;** being overwritten by a replay after crashing.&n;**&n;** If you don&squot;t set search_all, a block can only be allocated if it is not in the current transaction.  Since deleting&n;** a block removes it from the current transaction, this case should never happen.  If you don&squot;t set search_all, make&n;** sure you never write the block without logging it.&n;**&n;** next_zero_bit is a suggestion about the next block to try for find_forward.&n;** when bl is rejected because it is set in a journal list bitmap, we search&n;** for the next zero bit in the bitmap that rejected bl.  Then, we return that&n;** through next_zero_bit for find_forward to try.&n;**&n;** Just because we return something in next_zero_bit does not mean we won&squot;t&n;** reject it on the next call to reiserfs_in_journal&n;**&n;*/
DECL|function|reiserfs_in_journal
r_int
id|reiserfs_in_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|bmap_nr
comma
r_int
id|bit_nr
comma
r_int
id|search_all
comma
id|b_blocknr_t
op_star
id|next_zero_bit
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|bl
suffix:semicolon
op_star
id|next_zero_bit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always start this at zero. */
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.in_journal
)paren
suffix:semicolon
multiline_comment|/* If we aren&squot;t doing a search_all, this is a metablock, and it will be logged before use.&n;  ** if we crash before the transaction that freed it commits,  this transaction won&squot;t&n;  ** have committed either, and the block will never be written&n;  */
r_if
c_cond
(paren
id|search_all
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|JOURNAL_NUM_BITMAPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.in_journal_bitmap
)paren
suffix:semicolon
id|jb
op_assign
id|journal-&gt;j_list_bitmap
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|jb-&gt;journal_list
op_logical_and
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_logical_and
id|test_bit
c_func
(paren
id|bit_nr
comma
(paren
r_int
r_int
op_star
)paren
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
)paren
(brace
op_star
id|next_zero_bit
op_assign
id|find_next_zero_bit
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|jb-&gt;bitmaps
(braket
id|bmap_nr
)braket
op_member_access_from_pointer
id|data
)paren
comma
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
comma
id|bit_nr
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
id|bl
op_assign
id|bmap_nr
op_star
(paren
id|p_s_sb-&gt;s_blocksize
op_lshift
l_int|3
)paren
op_plus
id|bit_nr
suffix:semicolon
multiline_comment|/* is it in any old transactions? */
r_if
c_cond
(paren
id|search_all
op_logical_and
(paren
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_list_hash_table
comma
id|bl
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* is it in the current transaction.  This should never happen */
r_if
c_cond
(paren
(paren
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_hash_table
comma
id|bl
)paren
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.in_journal_reusable
)paren
suffix:semicolon
multiline_comment|/* safe for reuse */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* insert cn into table&n;*/
DECL|function|insert_journal_hash
r_static
r_inline
r_void
id|insert_journal_hash
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn_orig
suffix:semicolon
id|cn_orig
op_assign
id|journal_hash
c_func
(paren
id|table
comma
id|cn-&gt;sb
comma
id|cn-&gt;blocknr
)paren
suffix:semicolon
id|cn-&gt;hnext
op_assign
id|cn_orig
suffix:semicolon
id|cn-&gt;hprev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cn_orig
)paren
(brace
id|cn_orig-&gt;hprev
op_assign
id|cn
suffix:semicolon
)brace
id|journal_hash
c_func
(paren
id|table
comma
id|cn-&gt;sb
comma
id|cn-&gt;blocknr
)paren
op_assign
id|cn
suffix:semicolon
)brace
multiline_comment|/* lock the current transaction */
DECL|function|lock_journal
r_inline
r_static
r_void
id|lock_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.lock_journal
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* unlock the current transaction */
DECL|function|unlock_journal
r_inline
r_static
r_void
id|unlock_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|up
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_lock
)paren
suffix:semicolon
)brace
DECL|function|get_journal_list
r_static
r_inline
r_void
id|get_journal_list
c_func
(paren
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
id|jl-&gt;j_refcount
op_increment
suffix:semicolon
)brace
DECL|function|put_journal_list
r_static
r_inline
r_void
id|put_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_if
c_cond
(paren
id|jl-&gt;j_refcount
OL
l_int|1
)paren
(brace
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;trans id %lu, refcount at %d&quot;
comma
id|jl-&gt;j_trans_id
comma
id|jl-&gt;j_refcount
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|jl-&gt;j_refcount
op_eq
l_int|0
)paren
id|reiserfs_kfree
c_func
(paren
id|jl
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_list
)paren
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** this used to be much more involved, and I&squot;m keeping it just in case things get ugly again.&n;** it gets called by flush_commit_list, and cleans up any data stored about blocks freed during a&n;** transaction.&n;*/
DECL|function|cleanup_freed_for_journal_list
r_static
r_void
id|cleanup_freed_for_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
id|jl-&gt;j_list_bitmap
suffix:semicolon
r_if
c_cond
(paren
id|jb
)paren
(brace
id|cleanup_bitmap_list
c_func
(paren
id|p_s_sb
comma
id|jb
)paren
suffix:semicolon
)brace
id|jl-&gt;j_list_bitmap-&gt;journal_list
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_list_bitmap
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|journal_list_still_alive
r_static
r_int
id|journal_list_still_alive
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|trans_id
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
op_assign
op_amp
id|journal-&gt;j_journal_list
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|entry
)paren
)paren
(brace
id|jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_trans_id
op_le
id|trans_id
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_end_buffer_io_sync
r_static
r_void
id|reiserfs_end_buffer_io_sync
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_int|NULL
comma
l_string|&quot;clm-2084: pinned buffer %lu:%s sent to disk&quot;
comma
id|bh-&gt;b_blocknr
comma
id|bdevname
c_func
(paren
id|bh-&gt;b_bdev
comma
id|b
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uptodate
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_else
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_end_ordered_io
r_static
r_void
id|reiserfs_end_ordered_io
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_if
c_cond
(paren
id|uptodate
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_else
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|submit_logged_buffer
r_static
r_void
id|submit_logged_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|reiserfs_end_buffer_io_sync
suffix:semicolon
id|clear_buffer_journal_new
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_clear_buffer_journal_test
(paren
id|bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|submit_ordered_buffer
r_static
r_void
id|submit_ordered_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|reiserfs_end_ordered_io
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|submit_barrier_buffer
r_static
r_int
id|submit_barrier_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|reiserfs_end_ordered_io
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
id|submit_bh
c_func
(paren
id|WRITE_BARRIER
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|check_barrier_completion
r_static
r_void
id|check_barrier_completion
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|buffer_eopnotsupp
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_eopnotsupp
c_func
(paren
id|bh
)paren
suffix:semicolon
id|disable_barrier
c_func
(paren
id|s
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|set_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|sync_dirty_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
DECL|macro|CHUNK_SIZE
mdefine_line|#define CHUNK_SIZE 32
DECL|struct|buffer_chunk
r_struct
id|buffer_chunk
(brace
DECL|member|bh
r_struct
id|buffer_head
op_star
id|bh
(braket
id|CHUNK_SIZE
)braket
suffix:semicolon
DECL|member|nr
r_int
id|nr
suffix:semicolon
)brace
suffix:semicolon
DECL|function|write_chunk
r_static
r_void
id|write_chunk
c_func
(paren
r_struct
id|buffer_chunk
op_star
id|chunk
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chunk-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|submit_logged_buffer
c_func
(paren
id|chunk-&gt;bh
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|chunk-&gt;nr
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|write_ordered_chunk
r_static
r_void
id|write_ordered_chunk
c_func
(paren
r_struct
id|buffer_chunk
op_star
id|chunk
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chunk-&gt;nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|submit_ordered_buffer
c_func
(paren
id|chunk-&gt;bh
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|chunk-&gt;nr
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|add_to_chunk
r_static
r_int
id|add_to_chunk
c_func
(paren
r_struct
id|buffer_chunk
op_star
id|chunk
comma
r_struct
id|buffer_head
op_star
id|bh
comma
id|spinlock_t
op_star
id|lock
comma
r_void
(paren
id|fn
)paren
(paren
r_struct
id|buffer_chunk
op_star
)paren
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;nr
op_ge
id|CHUNK_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|chunk-&gt;bh
(braket
id|chunk-&gt;nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|chunk-&gt;nr
op_ge
id|CHUNK_SIZE
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lock
)paren
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|fn
c_func
(paren
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock
)paren
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|nr_reiserfs_jh
r_static
id|atomic_t
id|nr_reiserfs_jh
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|alloc_jh
r_static
r_struct
id|reiserfs_jh
op_star
id|alloc_jh
c_func
(paren
r_void
)paren
(brace
r_struct
id|reiserfs_jh
op_star
id|jh
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|jh
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|jh
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|nr_reiserfs_jh
)paren
suffix:semicolon
r_return
id|jh
suffix:semicolon
)brace
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * we want to free the jh when the buffer has been written&n; * and waited on&n; */
DECL|function|reiserfs_free_jh
r_void
id|reiserfs_free_jh
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_jh
op_star
id|jh
suffix:semicolon
id|jh
op_assign
id|bh-&gt;b_private
suffix:semicolon
r_if
c_cond
(paren
id|jh
)paren
(brace
id|bh-&gt;b_private
op_assign
l_int|NULL
suffix:semicolon
id|jh-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|jh-&gt;list
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|jh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|nr_reiserfs_jh
)paren
op_le
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|nr_reiserfs_jh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
DECL|function|__add_jh
r_static
r_inline
r_int
id|__add_jh
c_func
(paren
r_struct
id|reiserfs_journal
op_star
id|j
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|tail
)paren
(brace
r_struct
id|reiserfs_jh
op_star
id|jh
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_private
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_private
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
r_goto
id|no_jh
suffix:semicolon
)brace
id|jh
op_assign
id|bh-&gt;b_private
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|jh-&gt;list
)paren
suffix:semicolon
)brace
r_else
(brace
id|no_jh
suffix:colon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|jh
op_assign
id|alloc_jh
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
multiline_comment|/* buffer must be locked for __add_jh, should be able to have&n;&t; * two adds at the same time&n;&t; */
r_if
c_cond
(paren
id|bh-&gt;b_private
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|jh-&gt;bh
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_private
op_assign
id|jh
suffix:semicolon
)brace
id|jh-&gt;jl
op_assign
id|j-&gt;j_current_jl
suffix:semicolon
r_if
c_cond
(paren
id|tail
)paren
id|list_add_tail
c_func
(paren
op_amp
id|jh-&gt;list
comma
op_amp
id|jh-&gt;jl-&gt;j_tail_bh_list
)paren
suffix:semicolon
r_else
(brace
id|list_add_tail
c_func
(paren
op_amp
id|jh-&gt;list
comma
op_amp
id|jh-&gt;jl-&gt;j_bh_list
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|j-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_add_tail_list
r_int
id|reiserfs_add_tail_list
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
id|__add_jh
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_add_ordered_list
r_int
id|reiserfs_add_ordered_list
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
id|__add_jh
c_func
(paren
id|SB_JOURNAL
c_func
(paren
id|inode-&gt;i_sb
)paren
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|macro|JH_ENTRY
mdefine_line|#define JH_ENTRY(l) list_entry((l), struct reiserfs_jh, list)
DECL|function|write_ordered_buffers
r_static
r_int
id|write_ordered_buffers
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_struct
id|reiserfs_journal
op_star
id|j
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|reiserfs_jh
op_star
id|jh
suffix:semicolon
r_int
id|ret
op_assign
id|j-&gt;j_errno
suffix:semicolon
r_struct
id|buffer_chunk
id|chunk
suffix:semicolon
r_struct
id|list_head
id|tmp
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|chunk.nr
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
)paren
(brace
id|jh
op_assign
id|JH_ENTRY
c_func
(paren
id|list-&gt;next
)paren
suffix:semicolon
id|bh
op_assign
id|jh-&gt;bh
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_set_buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|jh-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jh-&gt;list
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_goto
id|loop_next
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chunk.nr
)paren
id|write_ordered_chunk
c_func
(paren
op_amp
id|chunk
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_goto
id|loop_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|jh-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|jh-&gt;list
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|add_to_chunk
c_func
(paren
op_amp
id|chunk
comma
id|bh
comma
id|lock
comma
id|write_ordered_chunk
)paren
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_free_jh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|loop_next
suffix:colon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|cond_resched_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunk.nr
)paren
(brace
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|write_ordered_chunk
c_func
(paren
op_amp
id|chunk
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tmp
)paren
)paren
(brace
id|jh
op_assign
id|JH_ENTRY
c_func
(paren
id|tmp.prev
)paren
suffix:semicolon
id|bh
op_assign
id|jh-&gt;bh
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|reiserfs_free_jh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|cond_resched_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|flush_older_commits
r_static
r_int
id|flush_older_commits
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|other_jl
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|first_jl
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_int
r_int
id|trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
r_int
r_int
id|other_trans_id
suffix:semicolon
r_int
r_int
id|first_trans_id
suffix:semicolon
id|find_first
suffix:colon
multiline_comment|/*&n;     * first we walk backwards to find the oldest uncommitted transation&n;     */
id|first_jl
op_assign
id|jl
suffix:semicolon
id|entry
op_assign
id|jl-&gt;j_list.prev
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|other_jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|journal-&gt;j_journal_list
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|other_jl-&gt;j_older_commits_done
)paren
)paren
r_break
suffix:semicolon
id|first_jl
op_assign
id|other_jl
suffix:semicolon
id|entry
op_assign
id|other_jl-&gt;j_list.prev
suffix:semicolon
)brace
multiline_comment|/* if we didn&squot;t find any older uncommitted transactions, return now */
r_if
c_cond
(paren
id|first_jl
op_eq
id|jl
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|first_trans_id
op_assign
id|first_jl-&gt;j_trans_id
suffix:semicolon
id|entry
op_assign
op_amp
id|first_jl-&gt;j_list
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|other_jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
id|other_trans_id
op_assign
id|other_jl-&gt;j_trans_id
suffix:semicolon
r_if
c_cond
(paren
id|other_trans_id
OL
id|trans_id
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|other_jl-&gt;j_commit_left
)paren
op_ne
l_int|0
)paren
(brace
id|flush_commit_list
c_func
(paren
id|s
comma
id|other_jl
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* list we were called with is gone, return */
r_if
c_cond
(paren
op_logical_neg
id|journal_list_still_alive
c_func
(paren
id|s
comma
id|trans_id
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* the one we just flushed is gone, this means all&n;&t;&t; * older lists are also gone, so first_jl is no longer&n;&t;&t; * valid either.  Go back to the beginning.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|journal_list_still_alive
c_func
(paren
id|s
comma
id|other_trans_id
)paren
)paren
(brace
r_goto
id|find_first
suffix:semicolon
)brace
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|journal-&gt;j_journal_list
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_async_progress_wait
r_int
id|reiserfs_async_progress_wait
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|j
op_assign
id|SB_JOURNAL
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|j-&gt;j_async_throttle
)paren
)paren
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** if this journal list still has commit blocks unflushed, send them to disk.&n;**&n;** log areas must be flushed in order (transaction 2 can&squot;t commit before transaction 1)&n;** Before the commit block can by written, every other log block must be safely on disk&n;**&n;*/
DECL|function|flush_commit_list
r_static
r_int
id|flush_commit_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|bn
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tbh
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
r_int
id|barrier
op_assign
l_int|0
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
id|s
comma
l_string|&quot;flush_commit_list&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|jl-&gt;j_older_commits_done
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* before we can put our commit blocks on disk, we have to make sure everyone older than&n;  ** us is on disk too&n;  */
id|BUG_ON
(paren
id|jl-&gt;j_len
op_le
l_int|0
)paren
suffix:semicolon
id|BUG_ON
(paren
id|trans_id
op_eq
id|journal-&gt;j_trans_id
)paren
suffix:semicolon
id|get_journal_list
c_func
(paren
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flushall
)paren
(brace
r_if
c_cond
(paren
id|flush_older_commits
c_func
(paren
id|s
comma
id|jl
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* list disappeared during flush_older_commits.  return */
r_goto
id|put_jl
suffix:semicolon
)brace
)brace
multiline_comment|/* make sure nobody is trying to flush this one at the same time */
id|down
c_func
(paren
op_amp
id|jl-&gt;j_commit_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal_list_still_alive
c_func
(paren
id|s
comma
id|trans_id
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|jl-&gt;j_commit_lock
)paren
suffix:semicolon
r_goto
id|put_jl
suffix:semicolon
)brace
id|BUG_ON
(paren
id|jl-&gt;j_trans_id
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* this commit is done, exit */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|jl-&gt;j_commit_lock
)paren
suffix:semicolon
r_goto
id|put_jl
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|jl-&gt;j_bh_list
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|write_ordered_buffers
c_func
(paren
op_amp
id|journal-&gt;j_dirty_buffers_lock
comma
id|journal
comma
id|jl
comma
op_amp
id|jl-&gt;j_bh_list
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
id|BUG_ON
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|jl-&gt;j_bh_list
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * for the description block and all the log blocks, submit any buffers&n;   * that haven&squot;t already reached the disk&n;   */
id|atomic_inc
c_func
(paren
op_amp
id|journal-&gt;j_async_throttle
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|jl-&gt;j_len
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bn
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|s
)paren
op_plus
(paren
id|jl-&gt;j_start
op_plus
id|i
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|s
)paren
suffix:semicolon
id|tbh
op_assign
id|journal_find_get_block
c_func
(paren
id|s
comma
id|bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|tbh
)paren
)paren
multiline_comment|/* redundant, ll_rw_block() checks */
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|tbh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|journal-&gt;j_async_throttle
)paren
suffix:semicolon
multiline_comment|/* wait on everything written so far before writing the commit&n;   * if we are in barrier mode, send the commit down now&n;   */
id|barrier
op_assign
id|reiserfs_barrier_flush
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|barrier
)paren
(brace
r_int
id|ret
suffix:semicolon
id|lock_buffer
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
id|ret
op_assign
id|submit_barrier_buffer
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EOPNOTSUPP
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
id|disable_barrier
c_func
(paren
id|s
)paren
suffix:semicolon
id|barrier
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|jl-&gt;j_len
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bn
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|s
)paren
op_plus
(paren
id|jl-&gt;j_start
op_plus
id|i
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|s
)paren
suffix:semicolon
id|tbh
op_assign
id|journal_find_get_block
c_func
(paren
id|s
comma
id|bn
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
singleline_comment|// since we&squot;re using ll_rw_blk above, it might have skipped over
singleline_comment|// a locked buffer.  Double check here
singleline_comment|//
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|tbh
)paren
)paren
multiline_comment|/* redundant, sync_dirty_buffer() checks */
id|sync_dirty_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;journal-601, buffer write failed&quot;
)paren
suffix:semicolon
macro_line|#endif
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
multiline_comment|/* once for journal_find_get_block */
id|put_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
multiline_comment|/* once due to original getblk in do_journal_end */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
)brace
id|BUG_ON
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_ne
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|barrier
)paren
(brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
id|sync_dirty_buffer
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
)brace
r_else
id|wait_on_buffer
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
id|check_barrier_completion
c_func
(paren
id|s
comma
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
multiline_comment|/* If there was a write error in the journal - we can&squot;t commit this&n;   * transaction - it will be invalid and, if successful, will just end&n;   * up propogating the write error out to the filesystem. */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;journal-615: buffer write failed&quot;
)paren
suffix:semicolon
macro_line|#endif
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|bforget
c_func
(paren
id|jl-&gt;j_commit_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_last_commit_id
op_ne
l_int|0
op_logical_and
(paren
id|jl-&gt;j_trans_id
op_minus
id|journal-&gt;j_last_commit_id
)paren
op_ne
l_int|1
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;clm-2200: last commit %lu, current %lu&quot;
comma
id|journal-&gt;j_last_commit_id
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
)brace
id|journal-&gt;j_last_commit_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
multiline_comment|/* now, every commit block is on the disk.  It is safe to allow blocks freed during this transaction to be reallocated */
id|cleanup_freed_for_journal_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
id|retval
op_assign
id|retval
ques
c_cond
id|retval
suffix:colon
id|journal-&gt;j_errno
suffix:semicolon
multiline_comment|/* mark the metadata dirty */
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|dirty_one_transaction
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_older_commits_done
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|jl-&gt;j_commit_lock
)paren
suffix:semicolon
id|put_jl
suffix:colon
id|put_journal_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
id|reiserfs_abort
(paren
id|s
comma
id|retval
comma
l_string|&quot;Journal write error in %s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n;** flush_journal_list frequently needs to find a newer transaction for a given block.  This does that, or &n;** returns NULL if it can&squot;t find anything &n;*/
DECL|function|find_newer_jl_for_cn
r_static
r_struct
id|reiserfs_journal_list
op_star
id|find_newer_jl_for_cn
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|cn-&gt;sb
suffix:semicolon
id|b_blocknr_t
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
id|cn
op_assign
id|cn-&gt;hprev
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;sb
op_eq
id|sb
op_logical_and
id|cn-&gt;blocknr
op_eq
id|blocknr
op_logical_and
id|cn-&gt;jlist
)paren
(brace
r_return
id|cn-&gt;jlist
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;hprev
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_void
id|remove_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
comma
r_struct
id|reiserfs_journal_cnode
op_star
op_star
comma
r_struct
id|reiserfs_journal_list
op_star
comma
r_int
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n;** once all the real blocks have been flushed, it is safe to remove them from the&n;** journal list for this transaction.  Aside from freeing the cnode, this also allows the&n;** block to be reallocated for data blocks if it had been deleted.&n;*/
DECL|function|remove_all_from_journal_list
r_static
r_void
id|remove_all_from_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|debug
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|last
suffix:semicolon
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
multiline_comment|/* which is better, to lock once around the whole loop, or&n;  ** to lock for each call to remove_journal_hash?&n;  */
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;block %u, bh is %d, state %ld&quot;
comma
id|cn-&gt;blocknr
comma
id|cn-&gt;bh
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|cn-&gt;state
)paren
suffix:semicolon
)brace
id|cn-&gt;state
op_assign
l_int|0
suffix:semicolon
id|remove_journal_hash
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_list_hash_table
comma
id|jl
comma
id|cn-&gt;blocknr
comma
l_int|1
)paren
suffix:semicolon
)brace
id|last
op_assign
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|last
)paren
suffix:semicolon
)brace
id|jl-&gt;j_realblock
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** if this timestamp is greater than the timestamp we wrote last to the header block, write it to the header block.&n;** once this is done, I can safely say the log area for this transaction won&squot;t ever be replayed, and I can start&n;** releasing blocks in this transaction for reuse as data blocks.&n;** called by flush_journal_list, before it calls remove_all_from_journal_list&n;**&n;*/
DECL|function|_update_journal_header_block
r_static
r_int
id|_update_journal_header_block
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|trans_id
)paren
(brace
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_is_journal_aborted
(paren
id|journal
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|trans_id
op_ge
id|journal-&gt;j_last_flush_trans_id
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
(paren
id|journal-&gt;j_header_bh
)paren
)paren
)paren
(brace
id|wait_on_buffer
c_func
(paren
(paren
id|journal-&gt;j_header_bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|journal-&gt;j_header_bh
)paren
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-699: buffer write failed&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|journal-&gt;j_last_flush_trans_id
op_assign
id|trans_id
suffix:semicolon
id|journal-&gt;j_first_unflushed_offset
op_assign
id|offset
suffix:semicolon
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|journal-&gt;j_header_bh-&gt;b_data
)paren
suffix:semicolon
id|jh-&gt;j_last_flush_trans_id
op_assign
id|cpu_to_le32
c_func
(paren
id|trans_id
)paren
suffix:semicolon
id|jh-&gt;j_first_unflushed_offset
op_assign
id|cpu_to_le32
c_func
(paren
id|offset
)paren
suffix:semicolon
id|jh-&gt;j_mount_id
op_assign
id|cpu_to_le32
c_func
(paren
id|journal-&gt;j_mount_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_barrier_flush
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
id|lock_buffer
c_func
(paren
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
id|ret
op_assign
id|submit_barrier_buffer
c_func
(paren
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EOPNOTSUPP
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
id|disable_barrier
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_goto
id|sync
suffix:semicolon
)brace
id|wait_on_buffer
c_func
(paren
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
id|check_barrier_completion
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|sync
suffix:colon
id|set_buffer_dirty
c_func
(paren
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
id|sync_dirty_buffer
c_func
(paren
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|journal-&gt;j_header_bh
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-837: IO error during journal replay&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|update_journal_header_block
r_static
r_int
id|update_journal_header_block
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|trans_id
)paren
(brace
r_return
id|_update_journal_header_block
c_func
(paren
id|p_s_sb
comma
id|offset
comma
id|trans_id
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;** flush any and all journal lists older than you are &n;** can only be called from flush_journal_list&n;*/
DECL|function|flush_older_journal_lists
r_static
r_int
id|flush_older_journal_lists
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|other_jl
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_int
r_int
id|trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
multiline_comment|/* we know we are the only ones flushing things, no extra race&n;     * protection is required.&n;     */
id|restart
suffix:colon
id|entry
op_assign
id|journal-&gt;j_journal_list.next
suffix:semicolon
multiline_comment|/* Did we wrap? */
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|journal-&gt;j_journal_list
)paren
r_return
l_int|0
suffix:semicolon
id|other_jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|other_jl-&gt;j_trans_id
OL
id|trans_id
)paren
(brace
id|BUG_ON
(paren
id|other_jl-&gt;j_refcount
op_le
l_int|0
)paren
suffix:semicolon
multiline_comment|/* do not flush all */
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|other_jl
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* other_jl is now deleted from the list */
r_goto
id|restart
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|del_from_work_list
r_static
r_void
id|del_from_work_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|jl-&gt;j_working_list
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|jl-&gt;j_working_list
)paren
suffix:semicolon
id|journal-&gt;j_num_work_lists
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* flush a journal list, both commit and real blocks&n;**&n;** always set flushall to 1, unless you are calling from inside&n;** flush_journal_list&n;**&n;** IMPORTANT.  This can only be called while there are no journal writers, &n;** and the journal is locked.  That means it can only be called from &n;** do_journal_end, or by journal_release&n;*/
DECL|function|flush_journal_list
r_static
r_int
id|flush_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
id|flushall
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|pjl
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|last
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|was_jwait
op_assign
l_int|0
suffix:semicolon
r_int
id|was_dirty
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|saved_bh
suffix:semicolon
r_int
r_int
id|j_len_saved
op_assign
id|jl-&gt;j_len
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
(paren
id|j_len_saved
op_le
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_wcount
)paren
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;clm-2048: flush_journal_list called with wcount %d&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_wcount
)paren
)paren
suffix:semicolon
)brace
id|BUG_ON
(paren
id|jl-&gt;j_trans_id
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* if flushall == 0, the lock is already held */
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|down
c_func
(paren
op_amp
id|journal-&gt;j_flush_sem
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|down_trylock
c_func
(paren
op_amp
id|journal-&gt;j_flush_sem
)paren
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|j_len_saved
OG
id|journal-&gt;j_trans_max
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-715: flush_journal_list, length is %lu, trans id %lu&bslash;n&quot;
comma
id|j_len_saved
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if all the work is already done, get out of here */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
op_le
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_goto
id|flush_older_and_return
suffix:semicolon
)brace
multiline_comment|/* start by putting the commit list on disk.  This will also flush &n;  ** the commit lists of any olders transactions&n;  */
id|flush_commit_list
c_func
(paren
id|s
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|jl-&gt;j_state
op_amp
id|LIST_DIRTY
)paren
op_logical_and
op_logical_neg
id|reiserfs_is_journal_aborted
(paren
id|journal
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* are we done now? */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
)paren
op_le
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|jl-&gt;j_commit_left
)paren
)paren
op_le
l_int|0
)paren
(brace
r_goto
id|flush_older_and_return
suffix:semicolon
)brace
multiline_comment|/* loop through each cnode, see if we need to write it, &n;  ** or wait on a more recent transaction, or just ignore it &n;  */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-844: panic journal list is flushing, wcount is not 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
id|was_jwait
op_assign
l_int|0
suffix:semicolon
id|was_dirty
op_assign
l_int|0
suffix:semicolon
id|saved_bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* blocknr of 0 is no longer in the hash, ignore it */
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
l_int|0
)paren
(brace
r_goto
id|free_cnode
suffix:semicolon
)brace
multiline_comment|/* This transaction failed commit. Don&squot;t write out to the disk */
r_if
c_cond
(paren
op_logical_neg
(paren
id|jl-&gt;j_state
op_amp
id|LIST_DIRTY
)paren
)paren
r_goto
id|free_cnode
suffix:semicolon
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
multiline_comment|/* the order is important here.  We check pjl to make sure we&n;    ** don&squot;t clear BH_JDirty_wait if we aren&squot;t the one writing this&n;    ** block to disk&n;    */
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;bh
)paren
(brace
id|saved_bh
op_assign
id|cn-&gt;bh
suffix:semicolon
multiline_comment|/* we do this to make sure nobody releases the buffer while &n;      ** we are working with it &n;      */
id|get_bh
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_journal_dirty
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|can_dirty
(paren
id|cn
)paren
)paren
suffix:semicolon
id|was_jwait
op_assign
l_int|1
suffix:semicolon
id|was_dirty
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|can_dirty
c_func
(paren
id|cn
)paren
)paren
(brace
multiline_comment|/* everything with !pjl &amp;&amp; jwait should be writable */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if someone has this block in a newer transaction, just make&n;    ** sure they are commited, and don&squot;t try writing it to disk&n;    */
r_if
c_cond
(paren
id|pjl
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pjl-&gt;j_commit_left
)paren
)paren
id|flush_commit_list
c_func
(paren
id|s
comma
id|pjl
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|free_cnode
suffix:semicolon
)brace
multiline_comment|/* bh == NULL when the block got to disk on its own, OR, &n;    ** the block got freed in a future transaction &n;    */
r_if
c_cond
(paren
id|saved_bh
op_eq
l_int|NULL
)paren
(brace
r_goto
id|free_cnode
suffix:semicolon
)brace
multiline_comment|/* this should never happen.  kupdate_one_transaction has this list&n;    ** locked while it works, so we should never see a buffer here that&n;    ** is not marked JDirty_wait&n;    */
r_if
c_cond
(paren
(paren
op_logical_neg
id|was_jwait
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|saved_bh
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;journal-813: BAD! buffer %llu %cdirty %cjwait, &quot;
l_string|&quot;not in a newer tranasction&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|saved_bh-&gt;b_blocknr
comma
id|was_dirty
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|was_jwait
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|was_dirty
)paren
(brace
multiline_comment|/* we inc again because saved_bh gets decremented at free_cnode */
id|get_bh
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
id|BUG_ON
(paren
id|cn-&gt;blocknr
op_ne
id|saved_bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|saved_bh
)paren
)paren
id|submit_logged_buffer
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
r_else
id|unlock_buffer
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;clm-2082: Unable to flush buffer %llu in %s&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|saved_bh-&gt;b_blocknr
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
id|free_cnode
suffix:colon
id|last
op_assign
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|saved_bh
)paren
(brace
multiline_comment|/* we incremented this to keep others from taking the buffer head away */
id|put_bh
c_func
(paren
id|saved_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|saved_bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;journal-945: saved_bh-&gt;b_count &lt; 0&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|BLOCK_NEEDS_FLUSH
comma
op_amp
id|cn-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cn-&gt;bh
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-1011: cn-&gt;bh is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|wait_on_buffer
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn-&gt;bh
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;journal-1012: cn-&gt;bh is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|cn-&gt;bh
)paren
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;journal-949: buffer write failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* note, we must clear the JDirty_wait bit after the up to date&n;&t;** check, otherwise we race against our flushpage routine&n;&t;*/
id|BUG_ON
(paren
op_logical_neg
id|test_clear_buffer_journal_dirty
(paren
id|cn-&gt;bh
)paren
)paren
suffix:semicolon
multiline_comment|/* undo the inc from journal_mark_dirty */
id|put_bh
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
id|reiserfs_abort
(paren
id|s
comma
op_minus
id|EIO
comma
l_string|&quot;Write error while pushing transaction to disk in %s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|flush_older_and_return
suffix:colon
multiline_comment|/* before we can update the journal header block, we _must_ flush all &n;  ** real blocks from all older transactions to disk.  This is because&n;  ** once the header block is updated, this transaction will not be&n;  ** replayed after a crash&n;  */
r_if
c_cond
(paren
id|flushall
)paren
(brace
id|flush_older_journal_lists
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
)brace
id|err
op_assign
id|journal-&gt;j_errno
suffix:semicolon
multiline_comment|/* before we can remove everything from the hash tables for this &n;  ** transaction, we must make sure it can never be replayed&n;  **&n;  ** since we are only called from do_journal_end, we know for sure there&n;  ** are no allocations going on while we are flushing journal lists.  So,&n;  ** we only need to update the journal header block for the last list&n;  ** being flushed&n;  */
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|flushall
)paren
(brace
id|err
op_assign
id|update_journal_header_block
c_func
(paren
id|s
comma
(paren
id|jl-&gt;j_start
op_plus
id|jl-&gt;j_len
op_plus
l_int|2
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|s
)paren
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|reiserfs_abort
(paren
id|s
comma
op_minus
id|EIO
comma
l_string|&quot;Write error while updating journal header in %s&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
id|remove_all_from_journal_list
c_func
(paren
id|s
comma
id|jl
comma
l_int|0
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|jl-&gt;j_list
)paren
suffix:semicolon
id|journal-&gt;j_num_lists
op_decrement
suffix:semicolon
id|del_from_work_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_last_flush_id
op_ne
l_int|0
op_logical_and
(paren
id|jl-&gt;j_trans_id
op_minus
id|journal-&gt;j_last_flush_id
)paren
op_ne
l_int|1
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;clm-2201: last flush %lu, current %lu&quot;
comma
id|journal-&gt;j_last_flush_id
comma
id|jl-&gt;j_trans_id
)paren
suffix:semicolon
)brace
id|journal-&gt;j_last_flush_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
multiline_comment|/* not strictly required since we are freeing the list, but it should&n;   * help find code using dead lists later on&n;   */
id|jl-&gt;j_len
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|jl-&gt;j_nonzerolen
)paren
comma
l_int|0
)paren
suffix:semicolon
id|jl-&gt;j_start
op_assign
l_int|0
suffix:semicolon
id|jl-&gt;j_realblock
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_commit_bh
op_assign
l_int|NULL
suffix:semicolon
id|jl-&gt;j_trans_id
op_assign
l_int|0
suffix:semicolon
id|jl-&gt;j_state
op_assign
l_int|0
suffix:semicolon
id|put_journal_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flushall
)paren
id|up
c_func
(paren
op_amp
id|journal-&gt;j_flush_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|write_one_transaction
r_static
r_int
id|write_one_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_struct
id|buffer_chunk
op_star
id|chunk
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|jl-&gt;j_state
op_or_assign
id|LIST_TOUCHED
suffix:semicolon
id|del_from_work_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jl-&gt;j_len
op_eq
l_int|0
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|jl-&gt;j_nonzerolen
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
multiline_comment|/* if the blocknr == 0, this has been cleared from the hash,&n;        ** skip it&n;        */
r_if
c_cond
(paren
id|cn-&gt;blocknr
op_eq
l_int|0
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn-&gt;bh
op_logical_and
id|can_dirty
c_func
(paren
id|cn
)paren
op_logical_and
id|buffer_dirty
c_func
(paren
id|cn-&gt;bh
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp_bh
suffix:semicolon
multiline_comment|/* we can race against journal_mark_freed when we try&n;&t;     * to lock_buffer(cn-&gt;bh), so we have to inc the buffer&n;&t;     * count, and recheck things after locking&n;&t;     */
id|tmp_bh
op_assign
id|cn-&gt;bh
suffix:semicolon
id|get_bh
c_func
(paren
id|tmp_bh
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tmp_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;bh
op_logical_and
id|can_dirty
c_func
(paren
id|cn
)paren
op_logical_and
id|buffer_dirty
c_func
(paren
id|tmp_bh
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_journal_dirty
c_func
(paren
id|tmp_bh
)paren
op_logical_or
id|buffer_journal_prepared
c_func
(paren
id|tmp_bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|add_to_chunk
c_func
(paren
id|chunk
comma
id|tmp_bh
comma
l_int|NULL
comma
id|write_chunk
)paren
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* note, cn-&gt;bh might be null now */
id|unlock_buffer
c_func
(paren
id|tmp_bh
)paren
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|tmp_bh
)paren
suffix:semicolon
)brace
id|next
suffix:colon
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* used by flush_commit_list */
DECL|function|dirty_one_transaction
r_static
r_int
id|dirty_one_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|pjl
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|jl-&gt;j_state
op_or_assign
id|LIST_DIRTY
suffix:semicolon
id|cn
op_assign
id|jl-&gt;j_realblock
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
multiline_comment|/* look for a more recent transaction that logged this&n;        ** buffer.  Only the most recent transaction with a buffer in&n;        ** it is allowed to send that buffer to disk&n;        */
id|pjl
op_assign
id|find_newer_jl_for_cn
c_func
(paren
id|cn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pjl
op_logical_and
id|cn-&gt;blocknr
op_logical_and
id|cn-&gt;bh
op_logical_and
id|buffer_journal_dirty
c_func
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|can_dirty
c_func
(paren
id|cn
)paren
)paren
suffix:semicolon
multiline_comment|/* if the buffer is prepared, it will either be logged&n;&t;     * or restored.  If restored, we need to make sure&n;&t;     * it actually gets marked dirty&n;&t;     */
id|clear_buffer_journal_new
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_journal_prepared
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|set_buffer_journal_restore_dirty
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_buffer_journal_test
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
)brace
id|cn
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|kupdate_transactions
r_static
r_int
id|kupdate_transactions
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_struct
id|reiserfs_journal_list
op_star
op_star
id|next_jl
comma
r_int
r_int
op_star
id|next_trans_id
comma
r_int
id|num_blocks
comma
r_int
id|num_trans
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|written
op_assign
l_int|0
suffix:semicolon
r_int
id|transactions_flushed
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|orig_trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
r_struct
id|buffer_chunk
id|chunk
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
id|chunk.nr
op_assign
l_int|0
suffix:semicolon
id|down
c_func
(paren
op_amp
id|journal-&gt;j_flush_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal_list_still_alive
c_func
(paren
id|s
comma
id|orig_trans_id
)paren
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* we&squot;ve got j_flush_sem held, nobody is going to delete any&n;     * of these lists out from underneath us&n;     */
r_while
c_loop
(paren
(paren
id|num_trans
op_logical_and
id|transactions_flushed
OL
id|num_trans
)paren
op_logical_or
(paren
op_logical_neg
id|num_trans
op_logical_and
id|written
OL
id|num_blocks
)paren
)paren
(brace
r_if
c_cond
(paren
id|jl-&gt;j_len
op_eq
l_int|0
op_logical_or
(paren
id|jl-&gt;j_state
op_amp
id|LIST_TOUCHED
)paren
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|jl-&gt;j_commit_left
)paren
op_logical_or
op_logical_neg
(paren
id|jl-&gt;j_state
op_amp
id|LIST_DIRTY
)paren
)paren
(brace
id|del_from_work_list
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|write_one_transaction
c_func
(paren
id|s
comma
id|jl
comma
op_amp
id|chunk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|done
suffix:semicolon
id|transactions_flushed
op_increment
suffix:semicolon
id|written
op_add_assign
id|ret
suffix:semicolon
id|entry
op_assign
id|jl-&gt;j_list.next
suffix:semicolon
multiline_comment|/* did we wrap? */
r_if
c_cond
(paren
id|entry
op_eq
op_amp
id|journal-&gt;j_journal_list
)paren
(brace
r_break
suffix:semicolon
)brace
id|jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* don&squot;t bother with older transactions */
r_if
c_cond
(paren
id|jl-&gt;j_trans_id
op_le
id|orig_trans_id
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chunk.nr
)paren
(brace
id|write_chunk
c_func
(paren
op_amp
id|chunk
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|up
c_func
(paren
op_amp
id|journal-&gt;j_flush_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* for o_sync and fsync heavy applications, they tend to use&n;** all the journa list slots with tiny transactions.  These&n;** trigger lots and lots of calls to update the header block, which&n;** adds seeks and slows things down.&n;**&n;** This function tries to clear out a large chunk of the journal lists&n;** at once, which makes everything faster since only the newest journal&n;** list updates the header block&n;*/
DECL|function|flush_used_journal_lists
r_static
r_int
id|flush_used_journal_lists
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_int
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cur_len
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|limit
op_assign
l_int|256
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|tjl
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|flush_jl
suffix:semicolon
r_int
r_int
id|trans_id
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
id|flush_jl
op_assign
id|tjl
op_assign
id|jl
suffix:semicolon
multiline_comment|/* in data logging mode, try harder to flush a lot of blocks */
r_if
c_cond
(paren
id|reiserfs_data_log
c_func
(paren
id|s
)paren
)paren
id|limit
op_assign
l_int|1024
suffix:semicolon
multiline_comment|/* flush for 256 transactions or limit blocks, whichever comes first */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
op_logical_and
id|len
OL
id|limit
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|tjl-&gt;j_commit_left
)paren
op_logical_or
id|tjl-&gt;j_trans_id
OL
id|jl-&gt;j_trans_id
)paren
(brace
r_break
suffix:semicolon
)brace
id|cur_len
op_assign
id|atomic_read
c_func
(paren
op_amp
id|tjl-&gt;j_nonzerolen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_len
OG
l_int|0
)paren
(brace
id|tjl-&gt;j_state
op_and_assign
op_complement
id|LIST_TOUCHED
suffix:semicolon
)brace
id|len
op_add_assign
id|cur_len
suffix:semicolon
id|flush_jl
op_assign
id|tjl
suffix:semicolon
r_if
c_cond
(paren
id|tjl-&gt;j_list.next
op_eq
op_amp
id|journal-&gt;j_journal_list
)paren
r_break
suffix:semicolon
id|tjl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|tjl-&gt;j_list.next
)paren
suffix:semicolon
)brace
multiline_comment|/* try to find a group of blocks we can flush across all the&n;    ** transactions, but only bother if we&squot;ve actually spanned&n;    ** across multiple lists&n;    */
r_if
c_cond
(paren
id|flush_jl
op_ne
id|jl
)paren
(brace
id|ret
op_assign
id|kupdate_transactions
c_func
(paren
id|s
comma
id|jl
comma
op_amp
id|tjl
comma
op_amp
id|trans_id
comma
id|len
comma
id|i
)paren
suffix:semicolon
)brace
id|flush_journal_list
c_func
(paren
id|s
comma
id|flush_jl
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** removes any nodes in table with name block and dev as bh.&n;** only touchs the hnext and hprev pointers.&n;*/
DECL|function|remove_journal_hash
r_void
id|remove_journal_hash
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|table
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
r_int
r_int
id|block
comma
r_int
id|remove_freed
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cur
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
op_star
id|head
suffix:semicolon
id|head
op_assign
op_amp
(paren
id|journal_hash
c_func
(paren
id|table
comma
id|sb
comma
id|block
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head
)paren
(brace
r_return
suffix:semicolon
)brace
id|cur
op_assign
op_star
id|head
suffix:semicolon
r_while
c_loop
(paren
id|cur
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;blocknr
op_eq
id|block
op_logical_and
id|cur-&gt;sb
op_eq
id|sb
op_logical_and
(paren
id|jl
op_eq
l_int|NULL
op_logical_or
id|jl
op_eq
id|cur-&gt;jlist
)paren
op_logical_and
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BLOCK_FREED
comma
op_amp
id|cur-&gt;state
)paren
op_logical_or
id|remove_freed
)paren
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;hnext
)paren
(brace
id|cur-&gt;hnext-&gt;hprev
op_assign
id|cur-&gt;hprev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur-&gt;hprev
)paren
(brace
id|cur-&gt;hprev-&gt;hnext
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
r_else
(brace
op_star
id|head
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
id|cur-&gt;blocknr
op_assign
l_int|0
suffix:semicolon
id|cur-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
id|cur-&gt;state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cur-&gt;bh
op_logical_and
id|cur-&gt;jlist
)paren
multiline_comment|/* anybody who clears the cur-&gt;bh will also dec the nonzerolen */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|cur-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
id|cur-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
id|cur-&gt;jlist
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
)brace
DECL|function|free_journal_ram
r_static
r_void
id|free_journal_ram
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|journal-&gt;j_current_jl
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal_list
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|journal-&gt;j_num_lists
op_decrement
suffix:semicolon
id|vfree
c_func
(paren
id|journal-&gt;j_cnode_free_orig
)paren
suffix:semicolon
id|free_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_list_bitmap
)paren
suffix:semicolon
id|free_bitmap_nodes
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* must be after free_list_bitmaps */
r_if
c_cond
(paren
id|journal-&gt;j_header_bh
)paren
(brace
id|brelse
c_func
(paren
id|journal-&gt;j_header_bh
)paren
suffix:semicolon
)brace
multiline_comment|/* j_header_bh is on the journal dev, make sure not to release the journal&n;   * dev until we brelse j_header_bh&n;   */
id|release_journal_dev
c_func
(paren
id|p_s_sb
comma
id|journal
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** call on unmount.  Only set error to 1 if you haven&squot;t made your way out&n;** of read_super() yet.  Any other caller must keep error at 0.&n;*/
DECL|function|do_journal_release
r_static
r_int
id|do_journal_release
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
id|error
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|myth
suffix:semicolon
r_int
id|flushed
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* we only want to flush out transactions if we were called with error == 0&n;  */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
op_logical_neg
(paren
id|p_s_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
multiline_comment|/* end the current trans */
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|10
comma
id|FLUSH_ALL
)paren
suffix:semicolon
multiline_comment|/* make sure something gets logged to force our way into the flush code */
r_if
c_cond
(paren
op_logical_neg
id|journal_join
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
)paren
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
id|FLUSH_ALL
)paren
suffix:semicolon
id|flushed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* this also catches errors during the do_journal_end above */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|reiserfs_is_journal_aborted
c_func
(paren
id|journal
)paren
)paren
(brace
id|memset
c_func
(paren
op_amp
id|myth
comma
l_int|0
comma
r_sizeof
(paren
id|myth
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal_join_abort
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
)paren
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
id|FLUSH_ALL
)paren
suffix:semicolon
)brace
)brace
id|reiserfs_mounted_fs_count
op_decrement
suffix:semicolon
multiline_comment|/* wait for all commits to finish */
id|cancel_delayed_work
c_func
(paren
op_amp
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_work
)paren
suffix:semicolon
id|flush_workqueue
c_func
(paren
id|commit_wq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_mounted_fs_count
)paren
(brace
id|destroy_workqueue
c_func
(paren
id|commit_wq
)paren
suffix:semicolon
id|commit_wq
op_assign
l_int|NULL
suffix:semicolon
)brace
id|free_journal_ram
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** call on unmount.  flush all journal trans, release all alloc&squot;d ram&n;*/
DECL|function|journal_release
r_int
id|journal_release
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_return
id|do_journal_release
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** only call from an error condition inside reiserfs_read_super!&n;*/
DECL|function|journal_release_error
r_int
id|journal_release_error
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_return
id|do_journal_release
c_func
(paren
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* compares description block with commit block.  returns 1 if they differ, 0 if they are the same */
DECL|function|journal_compare_desc_commit
r_static
r_int
id|journal_compare_desc_commit
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|reiserfs_journal_desc
op_star
id|desc
comma
r_struct
id|reiserfs_journal_commit
op_star
id|commit
)paren
(brace
r_if
c_cond
(paren
id|get_commit_trans_id
(paren
id|commit
)paren
op_ne
id|get_desc_trans_id
(paren
id|desc
)paren
op_logical_or
id|get_commit_trans_len
(paren
id|commit
)paren
op_ne
id|get_desc_trans_len
(paren
id|desc
)paren
op_logical_or
id|get_commit_trans_len
(paren
id|commit
)paren
OG
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_max
op_logical_or
id|get_commit_trans_len
(paren
id|commit
)paren
op_le
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* returns 0 if it did not find a description block  &n;** returns -1 if it found a corrupt commit block&n;** returns 1 if both desc and commit were valid &n;*/
DECL|function|journal_transaction_is_valid
r_static
r_int
id|journal_transaction_is_valid
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|d_bh
comma
r_int
r_int
op_star
id|oldest_invalid_trans_id
comma
r_int
r_int
op_star
id|newest_mount_id
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_bh
)paren
r_return
l_int|0
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
OG
l_int|0
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|get_journal_desc_magic
(paren
id|d_bh
)paren
comma
id|JOURNAL_DESC_MAGIC
comma
l_int|8
)paren
)paren
(brace
r_if
c_cond
(paren
id|oldest_invalid_trans_id
op_logical_and
op_star
id|oldest_invalid_trans_id
op_logical_and
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
OG
op_star
id|oldest_invalid_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-986: transaction &quot;
l_string|&quot;is valid returning because trans_id %d is greater than &quot;
l_string|&quot;oldest_invalid %lu&quot;
comma
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
comma
op_star
id|oldest_invalid_trans_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newest_mount_id
op_logical_and
op_star
id|newest_mount_id
OG
id|get_desc_mount_id
(paren
id|desc
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1087: transaction &quot;
l_string|&quot;is valid returning because mount_id %d is less than &quot;
l_string|&quot;newest_mount_id %lu&quot;
comma
id|get_desc_mount_id
(paren
id|desc
)paren
comma
op_star
id|newest_mount_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
OG
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_trans_max
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-2018: Bad transaction length %d encountered, ignoring transaction&quot;
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|offset
op_assign
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* ok, we have a journal description block, lets see if the transaction was valid */
id|c_bh
op_assign
id|journal_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|offset
op_plus
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c_bh
)paren
r_return
l_int|0
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|journal_compare_desc_commit
c_func
(paren
id|p_s_sb
comma
id|desc
comma
id|commit
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal_transaction_is_valid, commit offset %ld had bad &quot;
l_string|&quot;time %d or length %d&quot;
comma
id|c_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|get_commit_trans_id
(paren
id|commit
)paren
comma
id|get_commit_trans_len
c_func
(paren
id|commit
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldest_invalid_trans_id
)paren
(brace
op_star
id|oldest_invalid_trans_id
op_assign
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1004: &quot;
l_string|&quot;transaction_is_valid setting oldest invalid trans_id &quot;
l_string|&quot;to %d&quot;
comma
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1006: found valid &quot;
l_string|&quot;transaction start offset %llu, len %d id %d&quot;
comma
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
comma
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|brelse_array
r_static
r_void
id|brelse_array
c_func
(paren
r_struct
id|buffer_head
op_star
op_star
id|heads
comma
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
c_func
(paren
id|heads
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** given the start, and values for the oldest acceptable transactions,&n;** this either reads in a replays a transaction, or returns because the transaction&n;** is invalid, or too old.&n;*/
DECL|function|journal_read_transaction
r_static
r_int
id|journal_read_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|cur_dblock
comma
r_int
r_int
id|oldest_start
comma
r_int
r_int
id|oldest_trans_id
comma
r_int
r_int
id|newest_mount_id
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_int
r_int
id|trans_id
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|log_blocks
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|real_blocks
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|trans_offset
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|trans_half
suffix:semicolon
id|d_bh
op_assign
id|journal_bread
c_func
(paren
id|p_s_sb
comma
id|cur_dblock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_bh
)paren
r_return
l_int|1
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
id|trans_offset
op_assign
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1037: &quot;
l_string|&quot;journal_read_transaction, offset %llu, len %d mount_id %d&quot;
comma
id|d_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
comma
id|get_desc_mount_id
c_func
(paren
id|desc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
OL
id|oldest_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1039: &quot;
l_string|&quot;journal_read_trans skipping because %lu is too old&quot;
comma
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_desc_mount_id
c_func
(paren
id|desc
)paren
op_ne
id|newest_mount_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1146: &quot;
l_string|&quot;journal_read_trans skipping because %d is != &quot;
l_string|&quot;newest_mount_id %lu&quot;
comma
id|get_desc_mount_id
c_func
(paren
id|desc
)paren
comma
id|newest_mount_id
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|c_bh
op_assign
id|journal_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|trans_offset
op_plus
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c_bh
)paren
(brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|journal_compare_desc_commit
c_func
(paren
id|p_s_sb
comma
id|desc
comma
id|commit
)paren
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal_read_transaction, &quot;
l_string|&quot;commit offset %llu had bad time %d or length %d&quot;
comma
id|c_bh-&gt;b_blocknr
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|get_commit_trans_id
c_func
(paren
id|commit
)paren
comma
id|get_commit_trans_len
c_func
(paren
id|commit
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|trans_id
op_assign
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
suffix:semicolon
multiline_comment|/* now we know we&squot;ve got a good transaction, and it was inside the valid time ranges */
id|log_blocks
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
id|real_blocks
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|GFP_NOFS
comma
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|log_blocks
op_logical_or
op_logical_neg
id|real_blocks
)paren
(brace
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1169: kmalloc failed, unable to mount FS&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* get all the buffer heads */
id|trans_half
op_assign
id|journal_trans_half
(paren
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|log_blocks
(braket
id|i
)braket
op_assign
id|journal_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
id|trans_offset
op_plus
l_int|1
op_plus
id|i
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|trans_half
)paren
(brace
id|real_blocks
(braket
id|i
)braket
op_assign
id|sb_getblk
c_func
(paren
id|p_s_sb
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_realblock
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|real_blocks
(braket
id|i
)braket
op_assign
id|sb_getblk
c_func
(paren
id|p_s_sb
comma
id|le32_to_cpu
c_func
(paren
id|commit-&gt;j_realblock
(braket
id|i
op_minus
id|trans_half
)braket
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
OG
id|SB_BLOCK_COUNT
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1207: REPLAY FAILURE fsck required! Block to replay is outside of filesystem&quot;
)paren
suffix:semicolon
r_goto
id|abort_replay
suffix:semicolon
)brace
multiline_comment|/* make sure we don&squot;t try to replay onto log or reserved area */
r_if
c_cond
(paren
id|is_block_in_log_or_reserved_area
c_func
(paren
id|p_s_sb
comma
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block&quot;
)paren
suffix:semicolon
id|abort_replay
suffix:colon
id|brelse_array
c_func
(paren
id|log_blocks
comma
id|i
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
comma
id|i
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* read in the log blocks, memcpy to the corresponding real block */
id|ll_rw_block
c_func
(paren
id|READ
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
comma
id|log_blocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1212: REPLAY FAILURE fsck required! buffer write failed&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|log_blocks
op_plus
id|i
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_minus
id|i
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|log_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|real_blocks
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|log_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* flush out the real blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|set_buffer_dirty
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
id|real_blocks
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1226: REPLAY FAILURE, fsck required! buffer write failed&quot;
)paren
suffix:semicolon
id|brelse_array
c_func
(paren
id|real_blocks
op_plus
id|i
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_minus
id|i
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|real_blocks
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|cur_dblock
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|trans_offset
op_plus
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_plus
l_int|2
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1095: setting journal &quot;
l_string|&quot;start to offset %ld&quot;
comma
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
multiline_comment|/* init starting values for the first transaction, in case this is the last transaction to be replayed. */
id|journal-&gt;j_start
op_assign
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|journal-&gt;j_last_flush_trans_id
op_assign
id|trans_id
suffix:semicolon
id|journal-&gt;j_trans_id
op_assign
id|trans_id
op_plus
l_int|1
suffix:semicolon
id|brelse
c_func
(paren
id|c_bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|log_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|real_blocks
comma
id|le32_to_cpu
c_func
(paren
id|desc-&gt;j_len
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function reads blocks starting from block and to max_block of bufsize&n;   size (but no more than BUFNR blocks at a time). This proved to improve&n;   mounting speed on self-rebuilding raid5 arrays at least.&n;   Right now it is only used from journal code. But later we might use it&n;   from other places.&n;   Note: Do not use journal_getblk/sb_getblk functions here! */
DECL|function|reiserfs_breada
r_static
r_struct
id|buffer_head
op_star
id|reiserfs_breada
(paren
r_struct
id|block_device
op_star
id|dev
comma
r_int
id|block
comma
r_int
id|bufsize
comma
r_int
r_int
id|max_block
)paren
(brace
r_struct
id|buffer_head
op_star
id|bhlist
(braket
id|BUFNR
)braket
suffix:semicolon
r_int
r_int
id|blocks
op_assign
id|BUFNR
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|bh
op_assign
id|__getblk
(paren
id|dev
comma
id|block
comma
id|bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
(paren
id|bh
)paren
)paren
r_return
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_plus
id|BUFNR
OG
id|max_block
)paren
(brace
id|blocks
op_assign
id|max_block
op_minus
id|block
suffix:semicolon
)brace
id|bhlist
(braket
l_int|0
)braket
op_assign
id|bh
suffix:semicolon
id|j
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|__getblk
(paren
id|dev
comma
id|block
op_plus
id|i
comma
id|bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
(paren
id|bh
)paren
)paren
(brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|bhlist
(braket
id|j
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
id|ll_rw_block
(paren
id|READ
comma
id|j
comma
id|bhlist
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
(paren
id|bhlist
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|bhlist
(braket
l_int|0
)braket
suffix:semicolon
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** read and replay the log&n;** on a clean unmount, the journal header&squot;s next unflushed pointer will be to an invalid&n;** transaction.  This tests that before finding all the transactions in the log, which makes normal mount times fast.&n;**&n;** After a crash, this starts with the next unflushed transaction, and replays until it finds one too old, or invalid.&n;**&n;** On exit, it sets things up so the first transaction will work correctly.&n;*/
DECL|function|journal_read
r_static
r_int
id|journal_read
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_int
r_int
id|oldest_trans_id
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|oldest_invalid_trans_id
op_assign
l_int|0
suffix:semicolon
id|time_t
id|start
suffix:semicolon
r_int
r_int
id|oldest_start
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cur_dblock
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|newest_mount_id
op_assign
l_int|9
suffix:semicolon
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_int
id|valid_journal_header
op_assign
l_int|0
suffix:semicolon
r_int
id|replay_count
op_assign
l_int|0
suffix:semicolon
r_int
id|continue_replay
op_assign
l_int|1
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|cur_dblock
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_info
(paren
id|p_s_sb
comma
l_string|&quot;checking transaction log (%s)&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|journal-&gt;j_dev_bd
comma
id|b
)paren
)paren
suffix:semicolon
id|start
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* step 1, read in the journal header block.  Check the transaction it says &n;  ** is the first unflushed, and if that transaction is not valid, &n;  ** replay is done&n;  */
id|journal-&gt;j_header_bh
op_assign
id|journal_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_header_bh
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|journal-&gt;j_header_bh-&gt;b_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
op_ge
l_int|0
op_logical_and
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
template_param
l_int|0
)paren
(brace
id|oldest_start
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
suffix:semicolon
id|oldest_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
op_plus
l_int|1
suffix:semicolon
id|newest_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_mount_id
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1153: found in &quot;
l_string|&quot;header: first_unflushed_offset %d, last_flushed_trans_id &quot;
l_string|&quot;%lu&quot;
comma
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
comma
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
)paren
suffix:semicolon
id|valid_journal_header
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* now, we try to read the first unflushed offset.  If it is not valid, &n;    ** there is nothing more we can do, and it makes no sense to read &n;    ** through the whole log.&n;    */
id|d_bh
op_assign
id|journal_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|journal_transaction_is_valid
c_func
(paren
id|p_s_sb
comma
id|d_bh
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|continue_replay
op_assign
l_int|0
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
r_goto
id|start_log_replay
suffix:semicolon
)brace
r_if
c_cond
(paren
id|continue_replay
op_logical_and
id|bdev_read_only
c_func
(paren
id|p_s_sb-&gt;s_bdev
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;clm-2076: device is readonly, unable to replay log&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ok, there are transactions that need to be replayed.  start with the first log block, find&n;  ** all the valid transactions, and pick out the oldest.&n;  */
r_while
c_loop
(paren
id|continue_replay
op_logical_and
id|cur_dblock
OL
(paren
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
(brace
multiline_comment|/* Note that it is required for blocksize of primary fs device and journal&n;       device to be the same */
id|d_bh
op_assign
id|reiserfs_breada
c_func
(paren
id|journal-&gt;j_dev_bd
comma
id|cur_dblock
comma
id|p_s_sb-&gt;s_blocksize
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|journal_transaction_is_valid
c_func
(paren
id|p_s_sb
comma
id|d_bh
comma
op_amp
id|oldest_invalid_trans_id
comma
op_amp
id|newest_mount_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
(brace
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
id|d_bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|oldest_start
op_eq
l_int|0
)paren
(brace
multiline_comment|/* init all oldest_ values */
id|oldest_trans_id
op_assign
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
suffix:semicolon
id|oldest_start
op_assign
id|d_bh-&gt;b_blocknr
suffix:semicolon
id|newest_mount_id
op_assign
id|get_desc_mount_id
c_func
(paren
id|desc
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1179: Setting &quot;
l_string|&quot;oldest_start to offset %llu, trans_id %lu&quot;
comma
id|oldest_start
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|oldest_trans_id
OG
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
)paren
(brace
multiline_comment|/* one we just read was older */
id|oldest_trans_id
op_assign
id|get_desc_trans_id
c_func
(paren
id|desc
)paren
suffix:semicolon
id|oldest_start
op_assign
id|d_bh-&gt;b_blocknr
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1180: Resetting &quot;
l_string|&quot;oldest_start to offset %lu, trans_id %lu&quot;
comma
id|oldest_start
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newest_mount_id
OL
id|get_desc_mount_id
c_func
(paren
id|desc
)paren
)paren
(brace
id|newest_mount_id
op_assign
id|get_desc_mount_id
c_func
(paren
id|desc
)paren
suffix:semicolon
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1299: Setting &quot;
l_string|&quot;newest_mount_id to %d&quot;
comma
id|get_desc_mount_id
c_func
(paren
id|desc
)paren
)paren
suffix:semicolon
)brace
id|cur_dblock
op_add_assign
id|get_desc_trans_len
c_func
(paren
id|desc
)paren
op_plus
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|cur_dblock
op_increment
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|d_bh
)paren
suffix:semicolon
)brace
id|start_log_replay
suffix:colon
id|cur_dblock
op_assign
id|oldest_start
suffix:semicolon
r_if
c_cond
(paren
id|oldest_trans_id
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1206: Starting replay &quot;
l_string|&quot;from offset %llu, trans_id %lu&quot;
comma
id|cur_dblock
op_minus
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|oldest_trans_id
)paren
suffix:semicolon
)brace
id|replay_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|continue_replay
op_logical_and
id|oldest_trans_id
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|journal_read_transaction
c_func
(paren
id|p_s_sb
comma
id|cur_dblock
comma
id|oldest_start
comma
id|oldest_trans_id
comma
id|newest_mount_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|cur_dblock
op_assign
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|journal-&gt;j_start
suffix:semicolon
id|replay_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur_dblock
op_eq
id|oldest_start
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldest_trans_id
op_eq
l_int|0
)paren
(brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1225: No valid &quot;
l_string|&quot;transactions found&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* j_start does not get set correctly if we don&squot;t replay any transactions.&n;  ** if we had a valid journal_header, set j_start to the first unflushed transaction value,&n;  ** copy the trans_id from the header&n;  */
r_if
c_cond
(paren
id|valid_journal_header
op_logical_and
id|replay_count
op_eq
l_int|0
)paren
(brace
id|journal-&gt;j_start
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_first_unflushed_offset
)paren
suffix:semicolon
id|journal-&gt;j_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
op_plus
l_int|1
suffix:semicolon
id|journal-&gt;j_last_flush_trans_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_last_flush_trans_id
)paren
suffix:semicolon
id|journal-&gt;j_mount_id
op_assign
id|le32_to_cpu
c_func
(paren
id|jh-&gt;j_mount_id
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|journal-&gt;j_mount_id
op_assign
id|newest_mount_id
op_plus
l_int|1
suffix:semicolon
)brace
id|reiserfs_debug
c_func
(paren
id|p_s_sb
comma
id|REISERFS_DEBUG_CODE
comma
l_string|&quot;journal-1299: Setting &quot;
l_string|&quot;newest_mount_id to %lu&quot;
comma
id|journal-&gt;j_mount_id
)paren
suffix:semicolon
id|journal-&gt;j_first_unflushed_offset
op_assign
id|journal-&gt;j_start
suffix:semicolon
r_if
c_cond
(paren
id|replay_count
OG
l_int|0
)paren
(brace
id|reiserfs_info
(paren
id|p_s_sb
comma
l_string|&quot;replayed %d transactions in %lu seconds&bslash;n&quot;
comma
id|replay_count
comma
id|get_seconds
c_func
(paren
)paren
op_minus
id|start
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bdev_read_only
c_func
(paren
id|p_s_sb-&gt;s_bdev
)paren
op_logical_and
id|_update_journal_header_block
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_start
comma
id|journal-&gt;j_last_flush_trans_id
)paren
)paren
(brace
multiline_comment|/* replay failed, caller must call free_journal_ram and abort&n;      ** the mount&n;      */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|alloc_journal_list
r_static
r_struct
id|reiserfs_journal_list
op_star
id|alloc_journal_list
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
id|retry
suffix:colon
id|jl
op_assign
id|reiserfs_kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal_list
)paren
comma
id|GFP_NOFS
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jl
)paren
(brace
id|yield
c_func
(paren
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|memset
c_func
(paren
id|jl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|jl
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|jl-&gt;j_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|jl-&gt;j_working_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|jl-&gt;j_tail_bh_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|jl-&gt;j_bh_list
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|jl-&gt;j_commit_lock
comma
l_int|1
)paren
suffix:semicolon
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_num_lists
op_increment
suffix:semicolon
id|get_journal_list
c_func
(paren
id|jl
)paren
suffix:semicolon
r_return
id|jl
suffix:semicolon
)brace
DECL|function|journal_list_init
r_static
r_void
id|journal_list_init
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_member_access_from_pointer
id|j_current_jl
op_assign
id|alloc_journal_list
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
)brace
DECL|function|release_journal_dev
r_static
r_int
id|release_journal_dev
c_func
(paren
r_struct
id|super_block
op_star
id|super
comma
r_struct
id|reiserfs_journal
op_star
id|journal
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
op_ne
l_int|NULL
)paren
(brace
id|result
op_assign
id|filp_close
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
comma
l_int|NULL
)paren
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
l_int|NULL
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_ne
l_int|NULL
)paren
(brace
id|result
op_assign
id|blkdev_put
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_bd
)paren
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|super
comma
l_string|&quot;sh-457: release_journal_dev: Cannot release journal device: %i&quot;
comma
id|result
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|journal_init_dev
r_static
r_int
id|journal_init_dev
c_func
(paren
r_struct
id|super_block
op_star
id|super
comma
r_struct
id|reiserfs_journal
op_star
id|journal
comma
r_const
r_char
op_star
id|jdev_name
)paren
(brace
r_int
id|result
suffix:semicolon
id|dev_t
id|jdev
suffix:semicolon
r_int
id|blkdev_mode
op_assign
id|FMODE_READ
op_or
id|FMODE_WRITE
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_bd
op_assign
l_int|NULL
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
l_int|NULL
suffix:semicolon
id|jdev
op_assign
id|SB_ONDISK_JOURNAL_DEVICE
c_func
(paren
id|super
)paren
ques
c_cond
id|new_decode_dev
c_func
(paren
id|SB_ONDISK_JOURNAL_DEVICE
c_func
(paren
id|super
)paren
)paren
suffix:colon
id|super-&gt;s_dev
suffix:semicolon
r_if
c_cond
(paren
id|bdev_read_only
c_func
(paren
id|super-&gt;s_bdev
)paren
)paren
id|blkdev_mode
op_assign
id|FMODE_READ
suffix:semicolon
multiline_comment|/* there is no &quot;jdev&quot; option and journal is on separate device */
r_if
c_cond
(paren
(paren
op_logical_neg
id|jdev_name
op_logical_or
op_logical_neg
id|jdev_name
(braket
l_int|0
)braket
)paren
)paren
(brace
id|journal-&gt;j_dev_bd
op_assign
id|open_by_devnum
c_func
(paren
id|jdev
comma
id|blkdev_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|journal-&gt;j_dev_bd
)paren
)paren
(brace
id|result
op_assign
id|PTR_ERR
c_func
(paren
id|journal-&gt;j_dev_bd
)paren
suffix:semicolon
id|journal-&gt;j_dev_bd
op_assign
l_int|NULL
suffix:semicolon
id|reiserfs_warning
(paren
id|super
comma
l_string|&quot;sh-458: journal_init_dev: &quot;
l_string|&quot;cannot init journal device &squot;%s&squot;: %i&quot;
comma
id|__bdevname
c_func
(paren
id|jdev
comma
id|b
)paren
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jdev
op_ne
id|super-&gt;s_dev
)paren
id|set_blocksize
c_func
(paren
id|journal-&gt;j_dev_bd
comma
id|super-&gt;s_blocksize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
id|filp_open
c_func
(paren
id|jdev_name
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
)paren
)paren
(brace
r_struct
id|inode
op_star
id|jdev_inode
op_assign
id|journal-&gt;j_dev_file-&gt;f_mapping-&gt;host
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|jdev_inode
op_member_access_from_pointer
id|i_mode
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|super
comma
l_string|&quot;journal_init_dev: &squot;%s&squot; is &quot;
l_string|&quot;not a block device&quot;
comma
id|jdev_name
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOTBLK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ok */
id|journal-&gt;j_dev_bd
op_assign
id|I_BDEV
c_func
(paren
id|jdev_inode
)paren
suffix:semicolon
id|set_blocksize
c_func
(paren
id|journal-&gt;j_dev_bd
comma
id|super-&gt;s_blocksize
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|result
op_assign
id|PTR_ERR
c_func
(paren
id|journal
op_member_access_from_pointer
id|j_dev_file
)paren
suffix:semicolon
id|journal
op_member_access_from_pointer
id|j_dev_file
op_assign
l_int|NULL
suffix:semicolon
id|reiserfs_warning
(paren
id|super
comma
l_string|&quot;journal_init_dev: Cannot open &squot;%s&squot;: %i&quot;
comma
id|jdev_name
comma
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|release_journal_dev
c_func
(paren
id|super
comma
id|journal
)paren
suffix:semicolon
)brace
id|reiserfs_info
c_func
(paren
id|super
comma
l_string|&quot;journal_init_dev: journal device: %s&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|journal-&gt;j_dev_bd
comma
id|b
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n;** must be called once on fs mount.  calls journal_read for you&n;*/
DECL|function|journal_init
r_int
id|journal_init
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_const
r_char
op_star
id|j_dev_name
comma
r_int
id|old_format
comma
r_int
r_int
id|commit_max_age
)paren
(brace
r_int
id|num_cnodes
op_assign
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
op_star
l_int|2
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhjh
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_struct
id|reiserfs_journal_header
op_star
id|jh
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_char
id|b
(braket
id|BDEVNAME_SIZE
)braket
suffix:semicolon
id|journal
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
op_assign
id|vmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_journal
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-1256: unable to get memory for journal structure&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|journal
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_journal
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|journal-&gt;j_bitmap_nodes
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|journal-&gt;j_prealloc_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|journal-&gt;j_working_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|journal-&gt;j_journal_list
)paren
suffix:semicolon
id|journal-&gt;j_persistent_trans
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_allocate_list_bitmaps
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_list_bitmap
comma
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
r_goto
id|free_and_return
suffix:semicolon
id|allocate_bitmap_nodes
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* reserved for journal area support */
id|SB_JOURNAL_1st_RESERVED_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_assign
(paren
id|old_format
ques
c_cond
id|REISERFS_OLD_DISK_OFFSET_IN_BYTES
op_div
id|p_s_sb-&gt;s_blocksize
op_plus
id|SB_BMAP_NR
c_func
(paren
id|p_s_sb
)paren
op_plus
l_int|1
suffix:colon
id|REISERFS_DISK_OFFSET_IN_BYTES
op_div
id|p_s_sb-&gt;s_blocksize
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Sanity check to see is the standard journal fitting withing first bitmap&n;       (actual for small blocksizes) */
r_if
c_cond
(paren
op_logical_neg
id|SB_ONDISK_JOURNAL_DEVICE
c_func
(paren
id|p_s_sb
)paren
op_logical_and
(paren
id|SB_JOURNAL_1st_RESERVED_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
OG
id|p_s_sb-&gt;s_blocksize
op_star
l_int|8
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-1393: journal does not fit for area &quot;
l_string|&quot;addressed by first of bitmap blocks. It starts at &quot;
l_string|&quot;%u and its size is %u. Block size %ld&quot;
comma
id|SB_JOURNAL_1st_RESERVED_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
comma
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_goto
id|free_and_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal_init_dev
c_func
(paren
id|p_s_sb
comma
id|journal
comma
id|j_dev_name
)paren
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;sh-462: unable to initialize jornal device&quot;
)paren
suffix:semicolon
r_goto
id|free_and_return
suffix:semicolon
)brace
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* read journal header */
id|bhjh
op_assign
id|journal_bread
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bhjh
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;sh-459: unable to read journal header&quot;
)paren
suffix:semicolon
r_goto
id|free_and_return
suffix:semicolon
)brace
id|jh
op_assign
(paren
r_struct
id|reiserfs_journal_header
op_star
)paren
(paren
id|bhjh-&gt;b_data
)paren
suffix:semicolon
multiline_comment|/* make sure that journal matches to the super block */
r_if
c_cond
(paren
id|is_reiserfs_jr
c_func
(paren
id|rs
)paren
op_logical_and
(paren
id|jh-&gt;jh_journal.jp_journal_magic
op_ne
id|sb_jp_journal_magic
c_func
(paren
id|rs
)paren
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;sh-460: journal header magic %x &quot;
l_string|&quot;(device %s) does not match to magic found in super &quot;
l_string|&quot;block %x&quot;
comma
id|jh-&gt;jh_journal.jp_journal_magic
comma
id|bdevname
c_func
(paren
id|journal-&gt;j_dev_bd
comma
id|b
)paren
comma
id|sb_jp_journal_magic
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|brelse
(paren
id|bhjh
)paren
suffix:semicolon
r_goto
id|free_and_return
suffix:semicolon
)brace
id|journal-&gt;j_trans_max
op_assign
id|le32_to_cpu
(paren
id|jh-&gt;jh_journal.jp_journal_trans_max
)paren
suffix:semicolon
id|journal-&gt;j_max_batch
op_assign
id|le32_to_cpu
(paren
id|jh-&gt;jh_journal.jp_journal_max_batch
)paren
suffix:semicolon
id|journal-&gt;j_max_commit_age
op_assign
id|le32_to_cpu
(paren
id|jh-&gt;jh_journal.jp_journal_max_commit_age
)paren
suffix:semicolon
id|journal-&gt;j_max_trans_age
op_assign
id|JOURNAL_MAX_TRANS_AGE
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_trans_max
)paren
(brace
multiline_comment|/* make sure these parameters are available, assign it if they are not */
id|__u32
id|initial
op_assign
id|journal-&gt;j_trans_max
suffix:semicolon
id|__u32
id|ratio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p_s_sb-&gt;s_blocksize
OL
l_int|4096
)paren
id|ratio
op_assign
l_int|4096
op_div
id|p_s_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
op_div
id|journal-&gt;j_trans_max
OL
id|JOURNAL_MIN_RATIO
)paren
id|journal-&gt;j_trans_max
op_assign
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
op_div
id|JOURNAL_MIN_RATIO
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_trans_max
OG
id|JOURNAL_TRANS_MAX_DEFAULT
op_div
id|ratio
)paren
id|journal-&gt;j_trans_max
op_assign
id|JOURNAL_TRANS_MAX_DEFAULT
op_div
id|ratio
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_trans_max
OL
id|JOURNAL_TRANS_MIN_DEFAULT
op_div
id|ratio
)paren
id|journal-&gt;j_trans_max
op_assign
id|JOURNAL_TRANS_MIN_DEFAULT
op_div
id|ratio
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_trans_max
op_ne
id|initial
)paren
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;sh-461: journal_init: wrong transaction max size (%u). Changed to %u&quot;
comma
id|initial
comma
id|journal-&gt;j_trans_max
)paren
suffix:semicolon
id|journal-&gt;j_max_batch
op_assign
id|journal-&gt;j_trans_max
op_star
id|JOURNAL_MAX_BATCH_DEFAULT
op_div
id|JOURNAL_TRANS_MAX_DEFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_trans_max
)paren
(brace
multiline_comment|/*we have the file system was created by old version of mkreiserfs &n;      so this field contains zero value */
id|journal-&gt;j_trans_max
op_assign
id|JOURNAL_TRANS_MAX_DEFAULT
suffix:semicolon
id|journal-&gt;j_max_batch
op_assign
id|JOURNAL_MAX_BATCH_DEFAULT
suffix:semicolon
id|journal-&gt;j_max_commit_age
op_assign
id|JOURNAL_MAX_COMMIT_AGE
suffix:semicolon
multiline_comment|/* for blocksize &gt;= 4096 - max transaction size is 1024. For block size &lt; 4096&n;       trans max size is decreased proportionally */
r_if
c_cond
(paren
id|p_s_sb-&gt;s_blocksize
OL
l_int|4096
)paren
(brace
id|journal-&gt;j_trans_max
op_div_assign
(paren
l_int|4096
op_div
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|journal-&gt;j_max_batch
op_assign
(paren
id|journal-&gt;j_trans_max
)paren
op_star
l_int|9
op_div
l_int|10
suffix:semicolon
)brace
)brace
id|journal-&gt;j_default_max_commit_age
op_assign
id|journal-&gt;j_max_commit_age
suffix:semicolon
r_if
c_cond
(paren
id|commit_max_age
op_ne
l_int|0
)paren
(brace
id|journal-&gt;j_max_commit_age
op_assign
id|commit_max_age
suffix:semicolon
id|journal-&gt;j_max_trans_age
op_assign
id|commit_max_age
suffix:semicolon
)brace
id|reiserfs_info
(paren
id|p_s_sb
comma
l_string|&quot;journal params: device %s, size %u, &quot;
l_string|&quot;journal first block %u, max trans len %u, max batch %u, &quot;
l_string|&quot;max commit age %u, max trans age %u&bslash;n&quot;
comma
id|bdevname
c_func
(paren
id|journal-&gt;j_dev_bd
comma
id|b
)paren
comma
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
comma
id|journal-&gt;j_trans_max
comma
id|journal-&gt;j_max_batch
comma
id|journal-&gt;j_max_commit_age
comma
id|journal-&gt;j_max_trans_age
)paren
suffix:semicolon
id|brelse
(paren
id|bhjh
)paren
suffix:semicolon
id|journal-&gt;j_list_bitmap_index
op_assign
l_int|0
suffix:semicolon
id|journal_list_init
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|memset
c_func
(paren
id|journal-&gt;j_list_hash_table
comma
l_int|0
comma
id|JOURNAL_HASH_SIZE
op_star
r_sizeof
(paren
r_struct
id|reiserfs_journal_cnode
op_star
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|journal-&gt;j_dirty_buffers
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|journal-&gt;j_dirty_buffers_lock
)paren
suffix:semicolon
id|journal-&gt;j_start
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_len
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_len_alloc
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|journal-&gt;j_async_throttle
)paren
comma
l_int|0
)paren
suffix:semicolon
id|journal-&gt;j_bcount
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_trans_start_time
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_last
op_assign
l_int|NULL
suffix:semicolon
id|journal-&gt;j_first
op_assign
l_int|NULL
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
(paren
id|journal-&gt;j_join_wait
)paren
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|journal-&gt;j_lock
comma
l_int|1
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|journal-&gt;j_flush_sem
comma
l_int|1
)paren
suffix:semicolon
id|journal-&gt;j_trans_id
op_assign
l_int|10
suffix:semicolon
id|journal-&gt;j_mount_id
op_assign
l_int|10
suffix:semicolon
id|journal-&gt;j_state
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|journal-&gt;j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|journal-&gt;j_cnode_free_list
op_assign
id|allocate_cnodes
c_func
(paren
id|num_cnodes
)paren
suffix:semicolon
id|journal-&gt;j_cnode_free_orig
op_assign
id|journal-&gt;j_cnode_free_list
suffix:semicolon
id|journal-&gt;j_cnode_free
op_assign
id|journal-&gt;j_cnode_free_list
ques
c_cond
id|num_cnodes
suffix:colon
l_int|0
suffix:semicolon
id|journal-&gt;j_cnode_used
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_must_wait
op_assign
l_int|0
suffix:semicolon
id|init_journal_hash
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|jl
op_assign
id|journal-&gt;j_current_jl
suffix:semicolon
id|jl-&gt;j_list_bitmap
op_assign
id|get_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|jl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jl-&gt;j_list_bitmap
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-2005, get_list_bitmap failed for journal list 0&quot;
)paren
suffix:semicolon
r_goto
id|free_and_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal_read
c_func
(paren
id|p_s_sb
)paren
OL
l_int|0
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;Replay Failure, unable to mount&quot;
)paren
suffix:semicolon
r_goto
id|free_and_return
suffix:semicolon
)brace
id|reiserfs_mounted_fs_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_mounted_fs_count
op_le
l_int|1
)paren
id|commit_wq
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;reiserfs&quot;
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|journal-&gt;j_work
comma
id|flush_async_commits
comma
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_and_return
suffix:colon
id|free_journal_ram
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** test for a polite end of the current transaction.  Used by file_write, and should&n;** be used by delete to make sure they don&squot;t write more than can fit inside a single&n;** transaction&n;*/
DECL|function|journal_transaction_should_end
r_int
id|journal_transaction_should_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
id|new_alloc
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|th-&gt;t_super
)paren
suffix:semicolon
id|time_t
id|now
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* cannot restart while nested */
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_refcount
OG
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_must_wait
OG
l_int|0
op_logical_or
(paren
id|journal-&gt;j_len_alloc
op_plus
id|new_alloc
)paren
op_ge
id|journal-&gt;j_max_batch
op_logical_or
id|atomic_read
c_func
(paren
op_amp
(paren
id|journal-&gt;j_jlock
)paren
)paren
op_logical_or
(paren
id|now
op_minus
id|journal-&gt;j_trans_start_time
)paren
OG
id|journal-&gt;j_max_trans_age
op_logical_or
id|journal-&gt;j_cnode_free
OL
(paren
id|journal-&gt;j_trans_max
op_star
l_int|3
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this must be called inside a transaction, and requires the &n;** kernel_lock to be held&n;*/
DECL|function|reiserfs_block_writes
r_void
id|reiserfs_block_writes
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|th-&gt;t_super
)paren
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|journal-&gt;j_must_wait
op_assign
l_int|1
suffix:semicolon
id|set_bit
c_func
(paren
id|J_WRITERS_BLOCKED
comma
op_amp
id|journal-&gt;j_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* this must be called without a transaction started, and does not&n;** require BKL&n;*/
DECL|function|reiserfs_allow_writes
r_void
id|reiserfs_allow_writes
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|J_WRITERS_BLOCKED
comma
op_amp
id|journal-&gt;j_state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_join_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* this must be called without a transaction started, and does not&n;** require BKL&n;*/
DECL|function|reiserfs_wait_on_write_block
r_void
id|reiserfs_wait_on_write_block
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|journal-&gt;j_join_wait
comma
op_logical_neg
id|test_bit
c_func
(paren
id|J_WRITERS_BLOCKED
comma
op_amp
id|journal-&gt;j_state
)paren
)paren
suffix:semicolon
)brace
DECL|function|queue_log_writer
r_static
r_void
id|queue_log_writer
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|wait_queue_t
id|wait
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|J_WRITERS_QUEUED
comma
op_amp
id|journal-&gt;j_state
)paren
suffix:semicolon
multiline_comment|/*&n;     * we don&squot;t want to use wait_event here because&n;     * we only want to wait once.&n;     */
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|journal-&gt;j_join_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|J_WRITERS_QUEUED
comma
op_amp
id|journal-&gt;j_state
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|journal-&gt;j_join_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
DECL|function|wake_queued_writers
r_static
r_void
id|wake_queued_writers
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|J_WRITERS_QUEUED
comma
op_amp
id|journal-&gt;j_state
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_join_wait
)paren
suffix:semicolon
)brace
DECL|function|let_transaction_grow
r_static
r_void
id|let_transaction_grow
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|trans_id
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|sb
)paren
suffix:semicolon
r_int
r_int
id|bcount
op_assign
id|journal-&gt;j_bcount
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|journal-&gt;j_current_jl-&gt;j_state
op_or_assign
id|LIST_COMMIT_PENDING
suffix:semicolon
r_while
c_loop
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_wcount
)paren
OG
l_int|0
op_logical_or
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_jlock
)paren
)paren
op_logical_and
id|journal-&gt;j_trans_id
op_eq
id|trans_id
)paren
(brace
id|queue_log_writer
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_trans_id
op_ne
id|trans_id
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bcount
op_eq
id|journal-&gt;j_bcount
)paren
r_break
suffix:semicolon
id|bcount
op_assign
id|journal-&gt;j_bcount
suffix:semicolon
)brace
)brace
multiline_comment|/* join == true if you must join an existing transaction.&n;** join == false if you can deal with waiting for others to finish&n;**&n;** this will block until the transaction is joinable.  send the number of blocks you&n;** expect to use in nblocks.&n;*/
DECL|function|do_journal_begin_r
r_static
r_int
id|do_journal_begin_r
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|join
)paren
(brace
id|time_t
id|now
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
r_int
id|old_trans_id
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|myth
suffix:semicolon
r_int
id|sched_count
op_assign
l_int|0
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal_begin&quot;
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.journal_being
)paren
suffix:semicolon
multiline_comment|/* set here for journal_join */
id|th-&gt;t_refcount
op_assign
l_int|1
suffix:semicolon
id|th-&gt;t_super
op_assign
id|p_s_sb
suffix:semicolon
id|relock
suffix:colon
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|join
op_ne
id|JBEGIN_ABORT
op_logical_and
id|reiserfs_is_journal_aborted
(paren
id|journal
)paren
)paren
(brace
id|unlock_journal
(paren
id|p_s_sb
)paren
suffix:semicolon
id|retval
op_assign
id|journal-&gt;j_errno
suffix:semicolon
r_goto
id|out_fail
suffix:semicolon
)brace
id|journal-&gt;j_bcount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|J_WRITERS_BLOCKED
comma
op_amp
id|journal-&gt;j_state
)paren
)paren
(brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_wait_on_write_block
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.journal_relock_writers
)paren
suffix:semicolon
r_goto
id|relock
suffix:semicolon
)brace
id|now
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* if there is no room in the journal OR&n;  ** if this transaction is too old, and we weren&squot;t called joinable, wait for it to finish before beginning &n;  ** we don&squot;t sleep if there aren&squot;t other writers&n;  */
r_if
c_cond
(paren
(paren
op_logical_neg
id|join
op_logical_and
id|journal-&gt;j_must_wait
OG
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
(paren
id|journal-&gt;j_len_alloc
op_plus
id|nblocks
op_plus
l_int|2
)paren
op_ge
id|journal-&gt;j_max_batch
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_wcount
)paren
OG
l_int|0
op_logical_and
id|journal-&gt;j_trans_start_time
OG
l_int|0
op_logical_and
(paren
id|now
op_minus
id|journal-&gt;j_trans_start_time
)paren
OG
id|journal-&gt;j_max_trans_age
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_jlock
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|join
op_logical_and
id|journal-&gt;j_cnode_free
OL
(paren
id|journal-&gt;j_trans_max
op_star
l_int|3
)paren
)paren
)paren
(brace
id|old_trans_id
op_assign
id|journal-&gt;j_trans_id
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* allow others to finish this transaction */
r_if
c_cond
(paren
op_logical_neg
id|join
op_logical_and
(paren
id|journal-&gt;j_len_alloc
op_plus
id|nblocks
op_plus
l_int|2
)paren
op_ge
id|journal-&gt;j_max_batch
op_logical_and
(paren
(paren
id|journal-&gt;j_len
op_plus
id|nblocks
op_plus
l_int|2
)paren
op_star
l_int|100
)paren
OL
(paren
id|journal-&gt;j_len_alloc
op_star
l_int|75
)paren
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_wcount
)paren
OG
l_int|10
)paren
(brace
id|sched_count
op_increment
suffix:semicolon
id|queue_log_writer
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_goto
id|relock
suffix:semicolon
)brace
)brace
multiline_comment|/* don&squot;t mess with joining the transaction if all we have to do is&n;     * wait for someone else to do a commit&n;     */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_jlock
)paren
)paren
(brace
r_while
c_loop
(paren
id|journal-&gt;j_trans_id
op_eq
id|old_trans_id
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_jlock
)paren
)paren
(brace
id|queue_log_writer
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
)brace
r_goto
id|relock
suffix:semicolon
)brace
id|retval
op_assign
id|journal_join
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out_fail
suffix:semicolon
multiline_comment|/* someone might have ended the transaction while we joined */
r_if
c_cond
(paren
id|old_trans_id
op_ne
id|journal-&gt;j_trans_id
)paren
(brace
id|retval
op_assign
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|do_journal_end
c_func
(paren
op_amp
id|myth
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out_fail
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.journal_relock_wcount
)paren
suffix:semicolon
r_goto
id|relock
suffix:semicolon
)brace
multiline_comment|/* we are the first writer, set trans_id */
r_if
c_cond
(paren
id|journal-&gt;j_trans_start_time
op_eq
l_int|0
)paren
(brace
id|journal-&gt;j_trans_start_time
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
)paren
suffix:semicolon
id|journal-&gt;j_len_alloc
op_add_assign
id|nblocks
suffix:semicolon
id|th-&gt;t_blocks_logged
op_assign
l_int|0
suffix:semicolon
id|th-&gt;t_blocks_allocated
op_assign
id|nblocks
suffix:semicolon
id|th-&gt;t_trans_id
op_assign
id|journal-&gt;j_trans_id
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|th-&gt;t_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_fail
suffix:colon
id|memset
(paren
id|th
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
multiline_comment|/* Re-set th-&gt;t_super, so we can properly keep track of how many&n;   * persistent transactions there are. We need to do this so if this&n;   * call is part of a failed restart_transaction, we can free it later */
id|th-&gt;t_super
op_assign
id|p_s_sb
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_struct
id|reiserfs_transaction_handle
op_star
DECL|function|reiserfs_persistent_transaction
id|reiserfs_persistent_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|nblocks
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
op_star
id|th
suffix:semicolon
multiline_comment|/* if we&squot;re nesting into an existing transaction.  It will be&n;    ** persistent on its own&n;    */
r_if
c_cond
(paren
id|reiserfs_transaction_running
c_func
(paren
id|s
)paren
)paren
(brace
id|th
op_assign
id|current-&gt;journal_info
suffix:semicolon
id|th-&gt;t_refcount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_refcount
OL
l_int|2
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|th
suffix:semicolon
)brace
id|th
op_assign
id|reiserfs_kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_transaction_handle
)paren
comma
id|GFP_NOFS
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th
)paren
r_return
l_int|NULL
suffix:semicolon
id|ret
op_assign
id|journal_begin
c_func
(paren
id|th
comma
id|s
comma
id|nblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|reiserfs_kfree
c_func
(paren
id|th
comma
r_sizeof
(paren
r_struct
id|reiserfs_transaction_handle
)paren
comma
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_persistent_trans
op_increment
suffix:semicolon
r_return
id|th
suffix:semicolon
)brace
r_int
DECL|function|reiserfs_end_persistent_transaction
id|reiserfs_end_persistent_transaction
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_trans_id
)paren
id|ret
op_assign
id|journal_end
c_func
(paren
id|th
comma
id|th-&gt;t_super
comma
id|th-&gt;t_blocks_allocated
)paren
suffix:semicolon
r_else
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_refcount
op_eq
l_int|0
)paren
(brace
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_persistent_trans
op_decrement
suffix:semicolon
id|reiserfs_kfree
c_func
(paren
id|th
comma
r_sizeof
(paren
r_struct
id|reiserfs_transaction_handle
)paren
comma
id|s
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|journal_join
r_static
r_int
id|journal_join
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_struct
id|reiserfs_transaction_handle
op_star
id|cur_th
op_assign
id|current-&gt;journal_info
suffix:semicolon
multiline_comment|/* this keeps do_journal_end from NULLing out the current-&gt;journal_info&n;  ** pointer&n;  */
id|th-&gt;t_handle_save
op_assign
id|cur_th
suffix:semicolon
r_if
c_cond
(paren
id|cur_th
op_logical_and
id|cur_th-&gt;t_refcount
OG
l_int|1
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|do_journal_begin_r
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|JBEGIN_JOIN
)paren
suffix:semicolon
)brace
DECL|function|journal_join_abort
r_int
id|journal_join_abort
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_struct
id|reiserfs_transaction_handle
op_star
id|cur_th
op_assign
id|current-&gt;journal_info
suffix:semicolon
multiline_comment|/* this keeps do_journal_end from NULLing out the current-&gt;journal_info&n;  ** pointer&n;  */
id|th-&gt;t_handle_save
op_assign
id|cur_th
suffix:semicolon
r_if
c_cond
(paren
id|cur_th
op_logical_and
id|cur_th-&gt;t_refcount
OG
l_int|1
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|do_journal_begin_r
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|JBEGIN_ABORT
)paren
suffix:semicolon
)brace
DECL|function|journal_begin
r_int
id|journal_begin
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_struct
id|reiserfs_transaction_handle
op_star
id|cur_th
op_assign
id|current-&gt;journal_info
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|th-&gt;t_handle_save
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cur_th
)paren
(brace
multiline_comment|/* we are nesting into the current transaction */
r_if
c_cond
(paren
id|cur_th-&gt;t_super
op_eq
id|p_s_sb
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|cur_th-&gt;t_refcount
)paren
suffix:semicolon
id|cur_th-&gt;t_refcount
op_increment
suffix:semicolon
id|memcpy
c_func
(paren
id|th
comma
id|cur_th
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_refcount
op_le
l_int|1
)paren
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;BAD: refcount &lt;= 1, but journal_info != 0&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we&squot;ve ended up with a handle from a different filesystem.&n;&t;    ** save it and restore on journal_end.  This should never&n;&t;    ** really happen...&n;&t;    */
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;clm-2100: nesting info a different FS&quot;
)paren
suffix:semicolon
id|th-&gt;t_handle_save
op_assign
id|current-&gt;journal_info
suffix:semicolon
id|current-&gt;journal_info
op_assign
id|th
suffix:semicolon
)brace
)brace
r_else
(brace
id|current-&gt;journal_info
op_assign
id|th
suffix:semicolon
)brace
id|ret
op_assign
id|do_journal_begin_r
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|JBEGIN_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;journal_info
op_ne
id|th
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* I guess this boils down to being the reciprocal of clm-2100 above.&n;     * If do_journal_begin_r fails, we need to put it back, since journal_end&n;     * won&squot;t be called to do it. */
r_if
c_cond
(paren
id|ret
)paren
id|current-&gt;journal_info
op_assign
id|th-&gt;t_handle_save
suffix:semicolon
r_else
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_refcount
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;** puts bh into the current transaction.  If it was already there, reorders removes the&n;** old pointers from the hash, and puts new ones in (to make sure replay happen in the right order).&n;**&n;** if it was dirty, cleans and files onto the clean list.  I can&squot;t let it be dirty again until the&n;** transaction is committed.&n;** &n;** if j_len, is bigger than j_len_alloc, it pushes j_len_alloc to 10 + j_len.&n;*/
DECL|function|journal_mark_dirty
r_int
id|journal_mark_dirty
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count_already_incd
op_assign
l_int|0
suffix:semicolon
r_int
id|prepared
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.mark_dirty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_trans_id
op_ne
id|journal-&gt;j_trans_id
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1577: handle trans id %ld != current trans id %ld&bslash;n&quot;
comma
id|th-&gt;t_trans_id
comma
id|journal-&gt;j_trans_id
)paren
suffix:semicolon
)brace
id|p_s_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|prepared
op_assign
id|test_clear_buffer_journal_prepared
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_journal_restore_dirty
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* already in this transaction, we are done */
r_if
c_cond
(paren
id|buffer_journaled
c_func
(paren
id|bh
)paren
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.mark_dirty_already
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this must be turned into a panic instead of a warning.  We can&squot;t allow&n;  ** a dirty or journal_dirty or locked buffer to be logged, as some changes&n;  ** could get to disk too early.  NOT GOOD.&n;  */
r_if
c_cond
(paren
op_logical_neg
id|prepared
op_logical_or
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-1777: buffer %llu bad state &quot;
l_string|&quot;%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bh-&gt;b_blocknr
comma
id|prepared
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_locked
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_dirty
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
comma
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;!&squot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
)paren
op_le
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-1409: journal_mark_dirty returning because j_wcount was %d&quot;
comma
id|atomic_read
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* this error means I&squot;ve screwed up, and we&squot;ve overflowed the transaction.  &n;  ** Nothing can be done here, except make the FS readonly or panic.&n;  */
r_if
c_cond
(paren
id|journal-&gt;j_len
op_ge
id|journal-&gt;j_trans_max
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1413: journal_mark_dirty: j_len (%lu) is too big&bslash;n&quot;
comma
id|journal-&gt;j_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|count_already_incd
op_assign
l_int|1
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.mark_dirty_notjournal
)paren
suffix:semicolon
id|clear_buffer_journal_dirty
(paren
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_len
OG
id|journal-&gt;j_len_alloc
)paren
(brace
id|journal-&gt;j_len_alloc
op_assign
id|journal-&gt;j_len
op_plus
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
)brace
id|set_buffer_journaled
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* now put this guy on the end */
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
id|cn
op_assign
id|get_cnode
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;get_cnode failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|th-&gt;t_blocks_logged
op_eq
id|th-&gt;t_blocks_allocated
)paren
(brace
id|th-&gt;t_blocks_allocated
op_add_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
id|journal-&gt;j_len_alloc
op_add_assign
id|JOURNAL_PER_BALANCE_CNT
suffix:semicolon
)brace
id|th-&gt;t_blocks_logged
op_increment
suffix:semicolon
id|journal-&gt;j_len
op_increment
suffix:semicolon
id|cn-&gt;bh
op_assign
id|bh
suffix:semicolon
id|cn-&gt;blocknr
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|cn-&gt;sb
op_assign
id|p_s_sb
suffix:semicolon
id|cn-&gt;jlist
op_assign
l_int|NULL
suffix:semicolon
id|insert_journal_hash
c_func
(paren
id|journal-&gt;j_hash_table
comma
id|cn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count_already_incd
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
id|cn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cn-&gt;prev
op_assign
id|journal-&gt;j_last
suffix:semicolon
id|cn-&gt;bh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_last
)paren
(brace
id|journal-&gt;j_last-&gt;next
op_assign
id|cn
suffix:semicolon
id|journal-&gt;j_last
op_assign
id|cn
suffix:semicolon
)brace
r_else
(brace
id|journal-&gt;j_first
op_assign
id|cn
suffix:semicolon
id|journal-&gt;j_last
op_assign
id|cn
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_end
r_int
id|journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;journal_info
op_logical_and
id|th-&gt;t_refcount
OG
l_int|1
)paren
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;REISER-NESTING: th NULL, refcount %d&quot;
comma
id|th-&gt;t_refcount
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
(brace
id|WARN_ON
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|th-&gt;t_refcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_refcount
OG
l_int|0
)paren
(brace
r_struct
id|reiserfs_transaction_handle
op_star
id|cur_th
op_assign
id|current-&gt;journal_info
suffix:semicolon
multiline_comment|/* we aren&squot;t allowed to close a nested transaction on a different&n;    ** filesystem from the one in the task struct&n;    */
r_if
c_cond
(paren
id|cur_th-&gt;t_super
op_ne
id|th-&gt;t_super
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th
op_ne
id|cur_th
)paren
(brace
id|memcpy
c_func
(paren
id|current-&gt;journal_info
comma
id|th
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
id|th-&gt;t_trans_id
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* removes from the current transaction, relsing and descrementing any counters.  &n;** also files the removed buffer directly onto the clean list&n;**&n;** called by journal_mark_freed when a block has been deleted&n;**&n;** returns 1 if it cleaned and relsed the buffer. 0 otherwise&n;*/
DECL|function|remove_from_transaction
r_static
r_int
id|remove_from_transaction
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
id|b_blocknr_t
id|blocknr
comma
r_int
id|already_cleaned
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_hash_table
comma
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cn
op_logical_or
op_logical_neg
id|cn-&gt;bh
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
id|bh
op_assign
id|cn-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;prev
)paren
(brace
id|cn-&gt;prev-&gt;next
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn-&gt;next
)paren
(brace
id|cn-&gt;next-&gt;prev
op_assign
id|cn-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn
op_eq
id|journal-&gt;j_first
)paren
(brace
id|journal-&gt;j_first
op_assign
id|cn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cn
op_eq
id|journal-&gt;j_last
)paren
(brace
id|journal-&gt;j_last
op_assign
id|cn-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh
)paren
id|remove_journal_hash
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_hash_table
comma
l_int|NULL
comma
id|bh-&gt;b_blocknr
comma
l_int|0
)paren
suffix:semicolon
id|clear_buffer_journaled
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* don&squot;t log this one */
r_if
c_cond
(paren
op_logical_neg
id|already_cleaned
)paren
(brace
id|clear_buffer_journal_dirty
(paren
id|bh
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-1752: remove from trans, b_count &lt; 0&quot;
)paren
suffix:semicolon
)brace
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|journal-&gt;j_len
op_decrement
suffix:semicolon
id|journal-&gt;j_len_alloc
op_decrement
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|cn
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;** for any cnode in a journal list, it can only be dirtied of all the&n;** transactions that include it are commited to disk.&n;** this checks through each transaction, and returns 1 if you are allowed to dirty,&n;** and 0 if you aren&squot;t&n;**&n;** it is called by dirty_journal_list, which is called after flush_commit_list has gotten all the log&n;** blocks for a given transaction on disk&n;**&n;*/
DECL|function|can_dirty
r_static
r_int
id|can_dirty
c_func
(paren
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|cn-&gt;sb
suffix:semicolon
id|b_blocknr_t
id|blocknr
op_assign
id|cn-&gt;blocknr
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cur
op_assign
id|cn-&gt;hprev
suffix:semicolon
r_int
id|can_dirty
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* first test hprev.  These are all newer than cn, so any node here&n;  ** with the same block number and dev means this node can&squot;t be sent&n;  ** to disk right now.&n;  */
r_while
c_loop
(paren
id|cur
op_logical_and
id|can_dirty
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;jlist
op_logical_and
id|cur-&gt;bh
op_logical_and
id|cur-&gt;blocknr
op_logical_and
id|cur-&gt;sb
op_eq
id|sb
op_logical_and
id|cur-&gt;blocknr
op_eq
id|blocknr
)paren
(brace
id|can_dirty
op_assign
l_int|0
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hprev
suffix:semicolon
)brace
multiline_comment|/* then test hnext.  These are all older than cn.  As long as they&n;  ** are committed to the log, it is safe to write cn to disk&n;  */
id|cur
op_assign
id|cn-&gt;hnext
suffix:semicolon
r_while
c_loop
(paren
id|cur
op_logical_and
id|can_dirty
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;jlist
op_logical_and
id|cur-&gt;jlist-&gt;j_len
OG
l_int|0
op_logical_and
id|atomic_read
c_func
(paren
op_amp
(paren
id|cur-&gt;jlist-&gt;j_commit_left
)paren
)paren
OG
l_int|0
op_logical_and
id|cur-&gt;bh
op_logical_and
id|cur-&gt;blocknr
op_logical_and
id|cur-&gt;sb
op_eq
id|sb
op_logical_and
id|cur-&gt;blocknr
op_eq
id|blocknr
)paren
(brace
id|can_dirty
op_assign
l_int|0
suffix:semicolon
)brace
id|cur
op_assign
id|cur-&gt;hnext
suffix:semicolon
)brace
r_return
id|can_dirty
suffix:semicolon
)brace
multiline_comment|/* syncs the commit blocks, but does not force the real buffers to disk&n;** will wait until the current transaction is done/commited before returning &n;*/
DECL|function|journal_end_sync
r_int
id|journal_end_sync
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
multiline_comment|/* you can sync while nested, very, very bad */
r_if
c_cond
(paren
id|th-&gt;t_refcount
OG
l_int|1
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_len
op_eq
l_int|0
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
)brace
r_return
id|do_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|COMMIT_NOW
op_or
id|WAIT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** writeback the pending async commits to disk&n;*/
DECL|function|flush_async_commits
r_static
r_void
id|flush_async_commits
c_func
(paren
r_void
op_star
id|p
)paren
(brace
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|p
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|journal-&gt;j_journal_list
)paren
)paren
(brace
multiline_comment|/* last entry is the youngest, commit it and you get everything */
id|entry
op_assign
id|journal-&gt;j_journal_list.prev
suffix:semicolon
id|jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;   * this is a little racey, but there&squot;s no harm in missing&n;   * the filemap_fdata_write&n;   */
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_async_throttle
)paren
op_logical_and
op_logical_neg
id|reiserfs_is_journal_aborted
(paren
id|journal
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|journal-&gt;j_async_throttle
)paren
suffix:semicolon
id|filemap_fdatawrite
c_func
(paren
id|p_s_sb-&gt;s_bdev-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|journal-&gt;j_async_throttle
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** flushes any old transactions to disk&n;** ends the current transaction if it is too old&n;*/
DECL|function|reiserfs_flush_old_commits
r_int
id|reiserfs_flush_old_commits
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
)paren
(brace
id|time_t
id|now
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|now
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* safety check so we don&squot;t flush while we are replaying the log during&n;     * mount&n;     */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|journal-&gt;j_journal_list
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check the current transaction.  If there are no writers, and it is&n;     * too old, finish it, and force the commit blocks to disk&n;     */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_wcount
)paren
op_le
l_int|0
op_logical_and
id|journal-&gt;j_trans_start_time
OG
l_int|0
op_logical_and
id|journal-&gt;j_len
OG
l_int|0
op_logical_and
(paren
id|now
op_minus
id|journal-&gt;j_trans_start_time
)paren
OG
id|journal-&gt;j_max_trans_age
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|journal_join
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
)paren
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
multiline_comment|/* we&squot;re only being called from kreiserfsd, it makes no sense to do&n;            ** an async commit so that kreiserfsd can do it later&n;            */
id|do_journal_end
c_func
(paren
op_amp
id|th
comma
id|p_s_sb
comma
l_int|1
comma
id|COMMIT_NOW
op_or
id|WAIT
)paren
suffix:semicolon
)brace
)brace
r_return
id|p_s_sb-&gt;s_dirt
suffix:semicolon
)brace
multiline_comment|/*&n;** returns 0 if do_journal_end should return right away, returns 1 if do_journal_end should finish the commit&n;** &n;** if the current transaction is too old, but still has writers, this will wait on j_join_wait until all &n;** the writers are done.  By the time it wakes up, the transaction it was called has already ended, so it just&n;** flushes the commit list and returns 0.&n;**&n;** Won&squot;t batch when flush or commit_now is set.  Also won&squot;t batch when others are waiting on j_join_wait.&n;** &n;** Note, we can&squot;t allow the journal_end to proceed while there are still writers in the log.&n;*/
DECL|function|check_journal_end
r_static
r_int
id|check_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
(brace
id|time_t
id|now
suffix:semicolon
r_int
id|flush
op_assign
id|flags
op_amp
id|FLUSH_ALL
suffix:semicolon
r_int
id|commit_now
op_assign
id|flags
op_amp
id|COMMIT_NOW
suffix:semicolon
r_int
id|wait_on_commit
op_assign
id|flags
op_amp
id|WAIT
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|th-&gt;t_trans_id
op_ne
id|journal-&gt;j_trans_id
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|th-&gt;t_super
comma
l_string|&quot;journal-1577: handle trans id %ld != current trans id %ld&bslash;n&quot;
comma
id|th-&gt;t_trans_id
comma
id|journal-&gt;j_trans_id
)paren
suffix:semicolon
)brace
id|journal-&gt;j_len_alloc
op_sub_assign
(paren
id|th-&gt;t_blocks_allocated
op_minus
id|th-&gt;t_blocks_logged
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* &lt;= 0 is allowed.  unmounting might not call begin */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* BUG, deal with case where j_len is 0, but people previously freed blocks need to be released &n;  ** will be dealt with by next transaction that actually writes something, but should be taken&n;  ** care of in this trans&n;  */
r_if
c_cond
(paren
id|journal-&gt;j_len
op_eq
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* if wcount &gt; 0, and we are called to with flush or commit_now,&n;  ** we wait on j_join_wait.  We will wake up when the last writer has&n;  ** finished the transaction, and started it on its way to the disk.&n;  ** Then, we flush the commit or journal list, and just return 0 &n;  ** because the rest of journal end was already done for this transaction.&n;  */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flush
op_logical_or
id|commit_now
)paren
(brace
r_int
id|trans_id
suffix:semicolon
id|jl
op_assign
id|journal-&gt;j_current_jl
suffix:semicolon
id|trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
r_if
c_cond
(paren
id|wait_on_commit
)paren
id|jl-&gt;j_state
op_or_assign
id|LIST_COMMIT_PENDING
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|journal-&gt;j_jlock
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
)paren
(brace
id|journal-&gt;j_next_full_flush
op_assign
l_int|1
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* sleep while the current transaction is still j_jlocked */
r_while
c_loop
(paren
id|journal-&gt;j_trans_id
op_eq
id|trans_id
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|journal-&gt;j_jlock
)paren
)paren
(brace
id|queue_log_writer
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
)brace
r_else
(brace
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_trans_id
op_eq
id|trans_id
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|journal-&gt;j_jlock
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|journal-&gt;j_trans_id
op_eq
id|trans_id
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_now
op_logical_and
id|journal_list_still_alive
c_func
(paren
id|p_s_sb
comma
id|trans_id
)paren
op_logical_and
id|wait_on_commit
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* deal with old transactions where we are the last writers */
id|now
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|now
op_minus
id|journal-&gt;j_trans_start_time
)paren
OG
id|journal-&gt;j_max_trans_age
)paren
(brace
id|commit_now
op_assign
l_int|1
suffix:semicolon
id|journal-&gt;j_next_async_flush
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* don&squot;t batch when someone is waiting on j_join_wait */
multiline_comment|/* don&squot;t batch when syncing the commit or flushing the whole trans */
r_if
c_cond
(paren
op_logical_neg
(paren
id|journal-&gt;j_must_wait
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|journal-&gt;j_jlock
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|flush
op_logical_and
op_logical_neg
id|commit_now
op_logical_and
(paren
id|journal-&gt;j_len
OL
id|journal-&gt;j_max_batch
)paren
op_logical_and
id|journal-&gt;j_len_alloc
template_param
(paren
id|journal-&gt;j_trans_max
op_star
l_int|3
)paren
)paren
(brace
id|journal-&gt;j_bcount
op_increment
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_start
OG
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-003: journal_end: j_start (%ld) is too high&bslash;n&quot;
comma
id|journal-&gt;j_start
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** Does all the work that makes deleting blocks safe.&n;** when deleting a block mark BH_JNew, just remove it from the current transaction, clean it&squot;s buffer_head and move on.&n;** &n;** otherwise:&n;** set a bit for the block in the journal bitmap.  That will prevent it from being allocated for unformatted nodes&n;** before this transaction has finished.&n;**&n;** mark any cnodes for this block as BLOCK_FREED, and clear their bh pointers.  That will prevent any old transactions with&n;** this block from trying to flush to the real location.  Since we aren&squot;t removing the cnode from the journal_list_hash,&n;** the block can&squot;t be reallocated yet.&n;**&n;** Then remove it from the current transaction, decrementing any counters and filing it on the clean list.&n;*/
DECL|function|journal_mark_freed
r_int
id|journal_mark_freed
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
id|b_blocknr_t
id|blocknr
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_list_bitmap
op_star
id|jb
op_assign
l_int|NULL
suffix:semicolon
r_int
id|cleaned
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_hash_table
comma
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cn
op_logical_and
id|cn-&gt;bh
)paren
(brace
id|bh
op_assign
id|cn-&gt;bh
suffix:semicolon
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* if it is journal new, we just remove it from this transaction */
r_if
c_cond
(paren
id|bh
op_logical_and
id|buffer_journal_new
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_journal_new
(paren
id|bh
)paren
suffix:semicolon
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
id|reiserfs_clean_and_file_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|cleaned
op_assign
id|remove_from_transaction
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|cleaned
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the bit for this block in the journal bitmap for this transaction */
id|jb
op_assign
id|journal-&gt;j_current_jl-&gt;j_list_bitmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jb
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1702: journal_mark_freed, journal_list_bitmap is NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|set_bit_in_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|jb
)paren
suffix:semicolon
multiline_comment|/* Note, the entire while loop is not allowed to schedule.  */
r_if
c_cond
(paren
id|bh
)paren
(brace
id|clear_prepared_bits
c_func
(paren
id|bh
)paren
suffix:semicolon
id|reiserfs_clean_and_file_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|cleaned
op_assign
id|remove_from_transaction
c_func
(paren
id|p_s_sb
comma
id|blocknr
comma
id|cleaned
)paren
suffix:semicolon
multiline_comment|/* find all older transactions with this block, make sure they don&squot;t try to write it out */
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_list_hash_table
comma
id|blocknr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cn
)paren
(brace
r_if
c_cond
(paren
id|p_s_sb
op_eq
id|cn-&gt;sb
op_logical_and
id|blocknr
op_eq
id|cn-&gt;blocknr
)paren
(brace
id|set_bit
c_func
(paren
id|BLOCK_FREED
comma
op_amp
id|cn-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cn-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cleaned
)paren
(brace
multiline_comment|/* remove_from_transaction will brelse the buffer if it was &n;&t;    ** in the current trans&n;&t;    */
id|clear_buffer_journal_dirty
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
id|cleaned
op_assign
l_int|1
suffix:semicolon
id|put_bh
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|cn-&gt;bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-2138: cn-&gt;bh-&gt;b_count &lt; 0&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cn-&gt;jlist
)paren
(brace
multiline_comment|/* since we are clearing the bh, we MUST dec nonzerolen */
id|atomic_dec
c_func
(paren
op_amp
(paren
id|cn-&gt;jlist-&gt;j_nonzerolen
)paren
)paren
suffix:semicolon
)brace
id|cn-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|cn
op_assign
id|cn-&gt;hnext
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bh
)paren
(brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* get_hash grabs the buffer */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
OL
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|p_s_sb
comma
l_string|&quot;journal-2165: bh-&gt;b_count &lt; 0&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_update_inode_transaction
r_void
id|reiserfs_update_inode_transaction
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_jl
op_assign
id|journal-&gt;j_current_jl
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
op_assign
id|journal-&gt;j_trans_id
suffix:semicolon
)brace
multiline_comment|/*&n; * returns -1 on error, 0 if no commits/barriers were done and 1&n; * if a transaction was actually committed and the barrier was done&n; */
DECL|function|__commit_trans_jl
r_static
r_int
id|__commit_trans_jl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|id
comma
r_struct
id|reiserfs_journal_list
op_star
id|jl
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|sb
)paren
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* is it from the current transaction, or from an unknown transaction? */
r_if
c_cond
(paren
id|id
op_eq
id|journal-&gt;j_trans_id
)paren
(brace
id|jl
op_assign
id|journal-&gt;j_current_jl
suffix:semicolon
multiline_comment|/* try to let other writers come in and grow this transaction */
id|let_transaction_grow
c_func
(paren
id|sb
comma
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_trans_id
op_ne
id|id
)paren
(brace
r_goto
id|flush_commit_only
suffix:semicolon
)brace
id|ret
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|sb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* someone might have ended this transaction while we joined */
r_if
c_cond
(paren
id|journal-&gt;j_trans_id
op_ne
id|id
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|sb
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|flush_commit_only
suffix:semicolon
)brace
id|ret
op_assign
id|journal_end_sync
c_func
(paren
op_amp
id|th
comma
id|sb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this gets tricky, we have to make sure the journal list in&n;&t; * the inode still exists.  We know the list is still around&n;&t; * if we&squot;ve got a larger transaction id than the oldest list&n;&t; */
id|flush_commit_only
suffix:colon
r_if
c_cond
(paren
id|journal_list_still_alive
c_func
(paren
id|inode-&gt;i_sb
comma
id|id
)paren
)paren
(brace
multiline_comment|/*&n;&t;     * we only set ret to 1 when we know for sure&n;&t;     * the barrier hasn&squot;t been started yet on the commit&n;&t;     * block.&n;&t;     */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|jl-&gt;j_commit_left
)paren
OG
l_int|1
)paren
id|ret
op_assign
l_int|1
suffix:semicolon
id|flush_commit_list
c_func
(paren
id|sb
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_errno
)paren
id|ret
op_assign
id|journal-&gt;j_errno
suffix:semicolon
)brace
)brace
multiline_comment|/* otherwise the list is gone, and long since committed */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|reiserfs_commit_for_inode
r_int
id|reiserfs_commit_for_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
r_int
id|id
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|jl
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_jl
suffix:semicolon
multiline_comment|/* for the whole inode, assume unset id means it was&n;     * changed in the current transaction.  More conservative&n;     */
r_if
c_cond
(paren
op_logical_neg
id|id
op_logical_or
op_logical_neg
id|jl
)paren
(brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|id
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_trans_id
suffix:semicolon
multiline_comment|/* jl will be updated in __commit_trans_jl */
)brace
r_return
id|__commit_trans_jl
c_func
(paren
id|inode
comma
id|id
comma
id|jl
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_restore_prepared_buffer
r_void
id|reiserfs_restore_prepared_buffer
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.restore_prepared
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_clear_buffer_journal_restore_dirty
(paren
id|bh
)paren
op_logical_and
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
suffix:semicolon
id|cn
op_assign
id|get_journal_hash_dev
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_list_hash_table
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cn
op_logical_and
id|can_dirty
c_func
(paren
id|cn
)paren
)paren
(brace
id|set_buffer_journal_test
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
id|clear_buffer_journal_prepared
(paren
id|bh
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|tree_balance
op_star
id|cur_tb
suffix:semicolon
multiline_comment|/*&n;** before we can change a metadata block, we have to make sure it won&squot;t&n;** be written to disk while we are altering it.  So, we must:&n;** clean it&n;** wait on it.&n;** &n;*/
DECL|function|reiserfs_prepare_for_journal
r_int
id|reiserfs_prepare_for_journal
c_func
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|wait
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|journal.prepare
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_set_buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_return
l_int|0
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|set_buffer_journal_prepared
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_journal_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_journal_test
(paren
id|bh
)paren
suffix:semicolon
id|set_buffer_journal_restore_dirty
(paren
id|bh
)paren
suffix:semicolon
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|flush_old_journal_lists
r_static
r_void
id|flush_old_journal_lists
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|s
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|jl
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
id|time_t
id|now
op_assign
id|get_seconds
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|journal-&gt;j_journal_list
)paren
)paren
(brace
id|entry
op_assign
id|journal-&gt;j_journal_list.next
suffix:semicolon
id|jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* this check should always be run, to send old lists to disk */
r_if
c_cond
(paren
id|jl-&gt;j_timestamp
OL
(paren
id|now
op_minus
(paren
id|JOURNAL_MAX_TRANS_AGE
op_star
l_int|4
)paren
)paren
)paren
(brace
id|flush_used_journal_lists
c_func
(paren
id|s
comma
id|jl
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n;** long and ugly.  If flush, will not return until all commit&n;** blocks and all real buffers in the trans are on disk.&n;** If no_async, won&squot;t return until all commit blocks are on disk.&n;**&n;** keep reading, there are comments as you go along&n;**&n;** If the journal is aborted, we just clean up. Things like flushing&n;** journal lists, etc just won&squot;t happen.&n;*/
DECL|function|do_journal_end
r_static
r_int
id|do_journal_end
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_int
r_int
id|nblocks
comma
r_int
id|flags
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|p_s_sb
)paren
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|cn
comma
op_star
id|next
comma
op_star
id|jl_cn
suffix:semicolon
r_struct
id|reiserfs_journal_cnode
op_star
id|last_cn
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
r_struct
id|reiserfs_journal_commit
op_star
id|commit
suffix:semicolon
r_struct
id|buffer_head
op_star
id|c_bh
suffix:semicolon
multiline_comment|/* commit bh */
r_struct
id|buffer_head
op_star
id|d_bh
suffix:semicolon
multiline_comment|/* desc bh */
r_int
id|cur_write_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start index of current log write */
r_int
id|old_start
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|flush
op_assign
id|flags
op_amp
id|FLUSH_ALL
suffix:semicolon
r_int
id|wait_on_commit
op_assign
id|flags
op_amp
id|WAIT
suffix:semicolon
r_struct
id|reiserfs_journal_list
op_star
id|jl
comma
op_star
id|temp_jl
suffix:semicolon
r_struct
id|list_head
op_star
id|entry
comma
op_star
id|safe
suffix:semicolon
r_int
r_int
id|jindex
suffix:semicolon
r_int
r_int
id|commit_trans_id
suffix:semicolon
r_int
id|trans_half
suffix:semicolon
id|BUG_ON
(paren
id|th-&gt;t_refcount
OG
l_int|1
)paren
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
id|current-&gt;journal_info
op_assign
id|th-&gt;t_handle_save
suffix:semicolon
id|reiserfs_check_lock_depth
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal end&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_len
op_eq
l_int|0
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_sb
)paren
)paren
suffix:semicolon
)brace
id|lock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_next_full_flush
)paren
(brace
id|flags
op_or_assign
id|FLUSH_ALL
suffix:semicolon
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_next_async_flush
)paren
(brace
id|flags
op_or_assign
id|COMMIT_NOW
op_or
id|WAIT
suffix:semicolon
id|wait_on_commit
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check_journal_end locks the journal, and unlocks if it does not return 1 &n;  ** it tells us if we should continue with the journal_end, or just return&n;  */
r_if
c_cond
(paren
op_logical_neg
id|check_journal_end
c_func
(paren
id|th
comma
id|p_s_sb
comma
id|nblocks
comma
id|flags
)paren
)paren
(brace
id|p_s_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
id|wake_queued_writers
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|reiserfs_async_progress_wait
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* check_journal_end might set these, check again */
r_if
c_cond
(paren
id|journal-&gt;j_next_full_flush
)paren
(brace
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;  ** j must wait means we have to flush the log blocks, and the real blocks for&n;  ** this transaction&n;  */
r_if
c_cond
(paren
id|journal-&gt;j_must_wait
OG
l_int|0
)paren
(brace
id|flush
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef REISERFS_PREALLOCATE
multiline_comment|/* quota ops might need to nest, setup the journal_info pointer for them */
id|current-&gt;journal_info
op_assign
id|th
suffix:semicolon
id|reiserfs_discard_all_prealloc
c_func
(paren
id|th
)paren
suffix:semicolon
multiline_comment|/* it should not involve new blocks into&n;&t;&t;&t;&t;      * the transaction */
id|current-&gt;journal_info
op_assign
id|th-&gt;t_handle_save
suffix:semicolon
macro_line|#endif
multiline_comment|/* setup description block */
id|d_bh
op_assign
id|journal_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
id|journal-&gt;j_start
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|d_bh
)paren
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
(paren
id|d_bh
)paren
op_member_access_from_pointer
id|b_data
suffix:semicolon
id|memset
c_func
(paren
id|d_bh-&gt;b_data
comma
l_int|0
comma
id|d_bh-&gt;b_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|get_journal_desc_magic
(paren
id|d_bh
)paren
comma
id|JOURNAL_DESC_MAGIC
comma
l_int|8
)paren
suffix:semicolon
id|set_desc_trans_id
c_func
(paren
id|desc
comma
id|journal-&gt;j_trans_id
)paren
suffix:semicolon
multiline_comment|/* setup commit block.  Don&squot;t write (keep it clean too) this one until after everyone else is written */
id|c_bh
op_assign
id|journal_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|journal-&gt;j_start
op_plus
id|journal-&gt;j_len
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
id|commit
op_assign
(paren
r_struct
id|reiserfs_journal_commit
op_star
)paren
id|c_bh-&gt;b_data
suffix:semicolon
id|memset
c_func
(paren
id|c_bh-&gt;b_data
comma
l_int|0
comma
id|c_bh-&gt;b_size
)paren
suffix:semicolon
id|set_commit_trans_id
c_func
(paren
id|commit
comma
id|journal-&gt;j_trans_id
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|c_bh
)paren
suffix:semicolon
multiline_comment|/* init this journal list */
id|jl
op_assign
id|journal-&gt;j_current_jl
suffix:semicolon
multiline_comment|/* we lock the commit before doing anything because&n;   * we want to make sure nobody tries to run flush_commit_list until&n;   * the new transaction is fully setup, and we&squot;ve already flushed the&n;   * ordered bh list&n;   */
id|down
c_func
(paren
op_amp
id|jl-&gt;j_commit_lock
)paren
suffix:semicolon
multiline_comment|/* save the transaction id in case we need to commit it later */
id|commit_trans_id
op_assign
id|jl-&gt;j_trans_id
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|jl-&gt;j_older_commits_done
comma
l_int|0
)paren
suffix:semicolon
id|jl-&gt;j_trans_id
op_assign
id|journal-&gt;j_trans_id
suffix:semicolon
id|jl-&gt;j_timestamp
op_assign
id|journal-&gt;j_trans_start_time
suffix:semicolon
id|jl-&gt;j_commit_bh
op_assign
id|c_bh
suffix:semicolon
id|jl-&gt;j_start
op_assign
id|journal-&gt;j_start
suffix:semicolon
id|jl-&gt;j_len
op_assign
id|journal-&gt;j_len
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|jl-&gt;j_nonzerolen
comma
id|journal-&gt;j_len
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|jl-&gt;j_commit_left
comma
id|journal-&gt;j_len
op_plus
l_int|2
)paren
suffix:semicolon
id|jl-&gt;j_realblock
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The ENTIRE FOR LOOP MUST not cause schedule to occur.&n;  **  for each real block, add it to the journal list hash,&n;  ** copy into real block index array in the commit or desc block&n;  */
id|trans_half
op_assign
id|journal_trans_half
c_func
(paren
id|p_s_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cn
op_assign
id|journal-&gt;j_first
suffix:semicolon
id|cn
suffix:semicolon
id|cn
op_assign
id|cn-&gt;next
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|buffer_journaled
(paren
id|cn-&gt;bh
)paren
)paren
(brace
id|jl_cn
op_assign
id|get_cnode
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jl_cn
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1676, get_cnode returned NULL&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|jl-&gt;j_realblock
op_assign
id|jl_cn
suffix:semicolon
)brace
id|jl_cn-&gt;prev
op_assign
id|last_cn
suffix:semicolon
id|jl_cn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|last_cn
)paren
(brace
id|last_cn-&gt;next
op_assign
id|jl_cn
suffix:semicolon
)brace
id|last_cn
op_assign
id|jl_cn
suffix:semicolon
multiline_comment|/* make sure the block we are trying to log is not a block &n;         of journal or reserved area */
r_if
c_cond
(paren
id|is_block_in_log_or_reserved_area
c_func
(paren
id|p_s_sb
comma
id|cn-&gt;bh-&gt;b_blocknr
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-2332: Trying to log block %lu, which is a log block&bslash;n&quot;
comma
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
id|jl_cn-&gt;blocknr
op_assign
id|cn-&gt;bh-&gt;b_blocknr
suffix:semicolon
id|jl_cn-&gt;state
op_assign
l_int|0
suffix:semicolon
id|jl_cn-&gt;sb
op_assign
id|p_s_sb
suffix:semicolon
id|jl_cn-&gt;bh
op_assign
id|cn-&gt;bh
suffix:semicolon
id|jl_cn-&gt;jlist
op_assign
id|jl
suffix:semicolon
id|insert_journal_hash
c_func
(paren
id|journal-&gt;j_list_hash_table
comma
id|jl_cn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|trans_half
)paren
(brace
id|desc-&gt;j_realblock
(braket
id|i
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit-&gt;j_realblock
(braket
id|i
op_minus
id|trans_half
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|cn-&gt;bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|i
op_decrement
suffix:semicolon
)brace
)brace
id|set_desc_trans_len
c_func
(paren
id|desc
comma
id|journal-&gt;j_len
)paren
suffix:semicolon
id|set_desc_mount_id
c_func
(paren
id|desc
comma
id|journal-&gt;j_mount_id
)paren
suffix:semicolon
id|set_desc_trans_id
c_func
(paren
id|desc
comma
id|journal-&gt;j_trans_id
)paren
suffix:semicolon
id|set_commit_trans_len
c_func
(paren
id|commit
comma
id|journal-&gt;j_len
)paren
suffix:semicolon
multiline_comment|/* special check in case all buffers in the journal were marked for not logging */
r_if
c_cond
(paren
id|journal-&gt;j_len
op_eq
l_int|0
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* we&squot;re about to dirty all the log blocks, mark the description block&n;   * dirty now too.  Don&squot;t mark the commit block dirty until all the&n;   * others are on disk&n;   */
id|mark_buffer_dirty
c_func
(paren
id|d_bh
)paren
suffix:semicolon
multiline_comment|/* first data block is j_start + 1, so add one to cur_write_start wherever you use it */
id|cur_write_start
op_assign
id|journal-&gt;j_start
suffix:semicolon
id|cn
op_assign
id|journal-&gt;j_first
suffix:semicolon
id|jindex
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* start at one so we don&squot;t get the desc again */
r_while
c_loop
(paren
id|cn
)paren
(brace
id|clear_buffer_journal_new
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
multiline_comment|/* copy all the real blocks into log area.  dirty log blocks */
r_if
c_cond
(paren
id|buffer_journaled
(paren
id|cn-&gt;bh
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp_bh
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|tmp_bh
op_assign
id|journal_getblk
c_func
(paren
id|p_s_sb
comma
id|SB_ONDISK_JOURNAL_1st_BLOCK
c_func
(paren
id|p_s_sb
)paren
op_plus
(paren
(paren
id|cur_write_start
op_plus
id|jindex
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|tmp_bh
)paren
suffix:semicolon
id|page
op_assign
id|cn-&gt;bh-&gt;b_page
suffix:semicolon
id|addr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp_bh-&gt;b_data
comma
id|addr
op_plus
id|offset_in_page
c_func
(paren
id|cn-&gt;bh-&gt;b_data
)paren
comma
id|cn-&gt;bh-&gt;b_size
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|tmp_bh
)paren
suffix:semicolon
id|jindex
op_increment
suffix:semicolon
id|set_buffer_journal_dirty
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
id|clear_buffer_journaled
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* JDirty cleared sometime during transaction.  don&squot;t log this one */
id|reiserfs_warning
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-2048: do_journal_end: BAD, buffer in journal hash, but not JDirty!&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|cn-&gt;bh
)paren
suffix:semicolon
)brace
id|next
op_assign
id|cn-&gt;next
suffix:semicolon
id|free_cnode
c_func
(paren
id|p_s_sb
comma
id|cn
)paren
suffix:semicolon
id|cn
op_assign
id|next
suffix:semicolon
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* we are done  with both the c_bh and d_bh, but&n;  ** c_bh must be written after all other commit blocks,&n;  ** so we dirty/relse c_bh in flush_commit_list, with commit_left &lt;= 1.&n;  */
id|journal-&gt;j_current_jl
op_assign
id|alloc_journal_list
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* now it is safe to insert this transaction on the main list */
id|list_add_tail
c_func
(paren
op_amp
id|jl-&gt;j_list
comma
op_amp
id|journal-&gt;j_journal_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jl-&gt;j_working_list
comma
op_amp
id|journal-&gt;j_working_list
)paren
suffix:semicolon
id|journal-&gt;j_num_work_lists
op_increment
suffix:semicolon
multiline_comment|/* reset journal values for the next transaction */
id|old_start
op_assign
id|journal-&gt;j_start
suffix:semicolon
id|journal-&gt;j_start
op_assign
(paren
id|journal-&gt;j_start
op_plus
id|journal-&gt;j_len
op_plus
l_int|2
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
(paren
id|journal-&gt;j_wcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|journal-&gt;j_bcount
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_last
op_assign
l_int|NULL
suffix:semicolon
id|journal-&gt;j_first
op_assign
l_int|NULL
suffix:semicolon
id|journal-&gt;j_len
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_trans_start_time
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_trans_id
op_increment
suffix:semicolon
id|journal-&gt;j_current_jl-&gt;j_trans_id
op_assign
id|journal-&gt;j_trans_id
suffix:semicolon
id|journal-&gt;j_must_wait
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_len_alloc
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_next_full_flush
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_next_async_flush
op_assign
l_int|0
suffix:semicolon
id|init_journal_hash
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
singleline_comment|// make sure reiserfs_add_jh sees the new current_jl before we
singleline_comment|// write out the tails
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* tail conversion targets have to hit the disk before we end the&n;   * transaction.  Otherwise a later transaction might repack the tail&n;   * before this transaction commits, leaving the data block unflushed and&n;   * clean, if we crash before the later transaction commits, the data block&n;   * is lost.&n;   */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|jl-&gt;j_tail_bh_list
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|write_ordered_buffers
c_func
(paren
op_amp
id|journal-&gt;j_dirty_buffers_lock
comma
id|journal
comma
id|jl
comma
op_amp
id|jl-&gt;j_tail_bh_list
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|jl-&gt;j_tail_bh_list
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|jl-&gt;j_commit_lock
)paren
suffix:semicolon
multiline_comment|/* honor the flush wishes from the caller, simple commits can&n;  ** be done outside the journal lock, they are done below&n;  **&n;  ** if we don&squot;t flush the commit list right now, we put it into&n;  ** the work queue so the people waiting on the async progress work&n;  ** queue don&squot;t wait for this proc to flush journal lists and such.&n;  */
r_if
c_cond
(paren
id|flush
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
id|flush_journal_list
c_func
(paren
id|p_s_sb
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|jl-&gt;j_state
op_amp
id|LIST_COMMIT_PENDING
)paren
)paren
id|queue_delayed_work
c_func
(paren
id|commit_wq
comma
op_amp
id|journal-&gt;j_work
comma
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
multiline_comment|/* if the next transaction has any chance of wrapping, flush &n;  ** transactions that might get overwritten.  If any journal lists are very &n;  ** old flush them as well.  &n;  */
id|first_jl
suffix:colon
id|list_for_each_safe
c_func
(paren
id|entry
comma
id|safe
comma
op_amp
id|journal-&gt;j_journal_list
)paren
(brace
id|temp_jl
op_assign
id|JOURNAL_LIST_ENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_start
op_le
id|temp_jl-&gt;j_start
)paren
(brace
r_if
c_cond
(paren
(paren
id|journal-&gt;j_start
op_plus
id|journal-&gt;j_trans_max
op_plus
l_int|1
)paren
op_ge
id|temp_jl-&gt;j_start
)paren
(brace
id|flush_used_journal_lists
c_func
(paren
id|p_s_sb
comma
id|temp_jl
)paren
suffix:semicolon
r_goto
id|first_jl
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|journal-&gt;j_start
op_plus
id|journal-&gt;j_trans_max
op_plus
l_int|1
)paren
OL
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
multiline_comment|/* if we don&squot;t cross into the next transaction and we don&squot;t&n;&t;   * wrap, there is no way we can overlap any later transactions&n;&t;   * break now&n;&t;   */
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|journal-&gt;j_start
op_plus
id|journal-&gt;j_trans_max
op_plus
l_int|1
)paren
OG
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|journal-&gt;j_start
op_plus
id|journal-&gt;j_trans_max
op_plus
l_int|1
)paren
op_mod
id|SB_ONDISK_JOURNAL_SIZE
c_func
(paren
id|p_s_sb
)paren
)paren
op_ge
id|temp_jl-&gt;j_start
)paren
(brace
id|flush_used_journal_lists
c_func
(paren
id|p_s_sb
comma
id|temp_jl
)paren
suffix:semicolon
r_goto
id|first_jl
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we don&squot;t overlap anything from out start to the end of the&n;&t;   * log, and our wrapped portion doesn&squot;t overlap anything at&n;&t;   * the start of the log.  We can break&n;&t;   */
r_break
suffix:semicolon
)brace
)brace
)brace
id|flush_old_journal_lists
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
id|journal-&gt;j_current_jl-&gt;j_list_bitmap
op_assign
id|get_list_bitmap
c_func
(paren
id|p_s_sb
comma
id|journal-&gt;j_current_jl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|journal-&gt;j_current_jl-&gt;j_list_bitmap
)paren
)paren
(brace
id|reiserfs_panic
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal-1996: do_journal_end, could not get a list bitmap&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|atomic_set
c_func
(paren
op_amp
(paren
id|journal-&gt;j_jlock
)paren
comma
l_int|0
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|p_s_sb
)paren
suffix:semicolon
multiline_comment|/* wake up any body waiting to join. */
id|clear_bit
c_func
(paren
id|J_WRITERS_QUEUED
comma
op_amp
id|journal-&gt;j_state
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
(paren
id|journal-&gt;j_join_wait
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flush
op_logical_and
id|wait_on_commit
op_logical_and
id|journal_list_still_alive
c_func
(paren
id|p_s_sb
comma
id|commit_trans_id
)paren
)paren
(brace
id|flush_commit_list
c_func
(paren
id|p_s_sb
comma
id|jl
comma
l_int|1
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|reiserfs_check_lock_depth
c_func
(paren
id|p_s_sb
comma
l_string|&quot;journal end2&quot;
)paren
suffix:semicolon
id|memset
(paren
id|th
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|th
)paren
)paren
suffix:semicolon
multiline_comment|/* Re-set th-&gt;t_super, so we can properly keep track of how many&n;   * persistent transactions there are. We need to do this so if this&n;   * call is part of a failed restart_transaction, we can free it later */
id|th-&gt;t_super
op_assign
id|p_s_sb
suffix:semicolon
r_return
id|journal-&gt;j_errno
suffix:semicolon
)brace
r_static
r_void
DECL|function|__reiserfs_journal_abort_hard
id|__reiserfs_journal_abort_hard
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|J_ABORTED
comma
op_amp
id|journal-&gt;j_state
)paren
)paren
r_return
suffix:semicolon
id|printk
(paren
id|KERN_CRIT
l_string|&quot;REISERFS: Aborting journal for filesystem on %s&bslash;n&quot;
comma
id|reiserfs_bdevname
(paren
id|sb
)paren
)paren
suffix:semicolon
id|sb-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
id|set_bit
(paren
id|J_ABORTED
comma
op_amp
id|journal-&gt;j_state
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|dump_stack
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|__reiserfs_journal_abort_soft
id|__reiserfs_journal_abort_soft
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|errno
)paren
(brace
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
(paren
id|J_ABORTED
comma
op_amp
id|journal-&gt;j_state
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_errno
)paren
id|journal-&gt;j_errno
op_assign
id|errno
suffix:semicolon
id|__reiserfs_journal_abort_hard
(paren
id|sb
)paren
suffix:semicolon
)brace
r_void
DECL|function|reiserfs_journal_abort
id|reiserfs_journal_abort
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|errno
)paren
(brace
r_return
id|__reiserfs_journal_abort_soft
(paren
id|sb
comma
id|errno
)paren
suffix:semicolon
)brace
eof
