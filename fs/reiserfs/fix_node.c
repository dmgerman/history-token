multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
multiline_comment|/**&n; ** old_item_num&n; ** old_entry_num&n; ** set_entry_sizes&n; ** create_virtual_node&n; ** check_left&n; ** check_right&n; ** directory_part_size&n; ** get_num_ver&n; ** set_parameters&n; ** is_leaf_removable&n; ** are_leaves_removable&n; ** get_empty_nodes&n; ** get_lfree&n; ** get_rfree&n; ** is_left_neighbor_in_cache&n; ** decrement_key&n; ** get_far_parent&n; ** get_parents&n; ** can_node_be_removed&n; ** ip_check_balance&n; ** dc_check_balance_internal&n; ** dc_check_balance_leaf&n; ** dc_check_balance&n; ** check_balance&n; ** get_direct_parent&n; ** get_neighbors&n; ** fix_nodes&n; ** &n; ** &n; **/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
multiline_comment|/* To make any changes in the tree we find a node, that contains item&n;   to be changed/deleted or position in the node we insert a new item&n;   to. We call this node S. To do balancing we need to decide what we&n;   will shift to left/right neighbor, or to a new node, where new item&n;   will be etc. To make this analysis simpler we build virtual&n;   node. Virtual node is an array of items, that will replace items of&n;   node S. (For instance if we are going to delete an item, virtual&n;   node does not contain it). Virtual node keeps information about&n;   item sizes and types, mergeability of first and last items, sizes&n;   of all entries in directory item. We use this array of items when&n;   calculating what we can shift to neighbors and how many nodes we&n;   have to have if we do not any shiftings, if we shift to left/right&n;   neighbor or to both. */
multiline_comment|/* taking item number in virtual node, returns number of item, that it has in source buffer */
DECL|function|old_item_num
r_static
r_inline
r_int
id|old_item_num
(paren
r_int
id|new_num
comma
r_int
id|affected_item_num
comma
r_int
id|mode
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|M_PASTE
op_logical_or
id|mode
op_eq
id|M_CUT
op_logical_or
id|new_num
OL
id|affected_item_num
)paren
r_return
id|new_num
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|M_INSERT
)paren
(brace
id|RFALSE
c_func
(paren
id|new_num
op_eq
l_int|0
comma
l_string|&quot;vs-8005: for INSERT mode and item number of inserted item&quot;
)paren
suffix:semicolon
r_return
id|new_num
op_minus
l_int|1
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|mode
op_ne
id|M_DELETE
comma
l_string|&quot;vs-8010: old_item_num: mode must be M_DELETE (mode = &bslash;&squot;%c&bslash;&squot;&quot;
comma
id|mode
)paren
suffix:semicolon
multiline_comment|/* delete mode */
r_return
id|new_num
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|create_virtual_node
r_static
r_void
id|create_virtual_node
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
r_int
id|new_num
suffix:semicolon
r_struct
id|buffer_head
op_star
id|Sh
suffix:semicolon
multiline_comment|/* this comes from tb-&gt;S[h] */
id|Sh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
multiline_comment|/* size of changed node */
id|vn-&gt;vn_size
op_assign
id|MAX_CHILD_SIZE
(paren
id|Sh
)paren
op_minus
id|B_FREE_SPACE
(paren
id|Sh
)paren
op_plus
id|tb-&gt;insert_size
(braket
id|h
)braket
suffix:semicolon
multiline_comment|/* for internal nodes array if virtual items is not created */
r_if
c_cond
(paren
id|h
)paren
(brace
id|vn-&gt;vn_nr_item
op_assign
(paren
id|vn-&gt;vn_size
op_minus
id|DC_SIZE
)paren
op_div
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* number of items in virtual node  */
id|vn-&gt;vn_nr_item
op_assign
id|B_NR_ITEMS
(paren
id|Sh
)paren
op_plus
(paren
(paren
id|vn-&gt;vn_mode
op_eq
id|M_INSERT
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
op_minus
(paren
(paren
id|vn-&gt;vn_mode
op_eq
id|M_DELETE
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* first virtual item */
id|vn-&gt;vn_vi
op_assign
(paren
r_struct
id|virtual_item
op_star
)paren
(paren
id|tb-&gt;tb_vn
op_plus
l_int|1
)paren
suffix:semicolon
id|memset
(paren
id|vn-&gt;vn_vi
comma
l_int|0
comma
id|vn-&gt;vn_nr_item
op_star
r_sizeof
(paren
r_struct
id|virtual_item
)paren
)paren
suffix:semicolon
id|vn-&gt;vn_free_ptr
op_add_assign
id|vn-&gt;vn_nr_item
op_star
r_sizeof
(paren
r_struct
id|virtual_item
)paren
suffix:semicolon
multiline_comment|/* first item in the node */
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|Sh
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* define the mergeability for 0-th item (if it is not being deleted) */
r_if
c_cond
(paren
id|op_is_left_mergeable
(paren
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
id|Sh-&gt;b_size
)paren
op_logical_and
(paren
id|vn-&gt;vn_mode
op_ne
id|M_DELETE
op_logical_or
id|vn-&gt;vn_affected_item_num
)paren
)paren
id|vn-&gt;vn_vi
(braket
l_int|0
)braket
dot
id|vi_type
op_or_assign
id|VI_TYPE_LEFT_MERGEABLE
suffix:semicolon
multiline_comment|/* go through all items those remain in the virtual node (except for the new (inserted) one) */
r_for
c_loop
(paren
id|new_num
op_assign
l_int|0
suffix:semicolon
id|new_num
OL
id|vn-&gt;vn_nr_item
suffix:semicolon
id|new_num
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_struct
id|virtual_item
op_star
id|vi
op_assign
id|vn-&gt;vn_vi
op_plus
id|new_num
suffix:semicolon
r_int
id|is_affected
op_assign
(paren
(paren
id|new_num
op_ne
id|vn-&gt;vn_affected_item_num
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_affected
op_logical_and
id|vn-&gt;vn_mode
op_eq
id|M_INSERT
)paren
r_continue
suffix:semicolon
multiline_comment|/* get item number in source node */
id|j
op_assign
id|old_item_num
(paren
id|new_num
comma
id|vn-&gt;vn_affected_item_num
comma
id|vn-&gt;vn_mode
)paren
suffix:semicolon
id|vi-&gt;vi_item_len
op_add_assign
id|ih_item_len
c_func
(paren
id|ih
op_plus
id|j
)paren
op_plus
id|IH_SIZE
suffix:semicolon
id|vi-&gt;vi_ih
op_assign
id|ih
op_plus
id|j
suffix:semicolon
id|vi-&gt;vi_item
op_assign
id|B_I_PITEM
(paren
id|Sh
comma
id|ih
op_plus
id|j
)paren
suffix:semicolon
id|vi-&gt;vi_uarea
op_assign
id|vn-&gt;vn_free_ptr
suffix:semicolon
singleline_comment|// FIXME: there is no check, that item operation did not
singleline_comment|// consume too much memory
id|vn-&gt;vn_free_ptr
op_add_assign
id|op_create_vi
(paren
id|vn
comma
id|vi
comma
id|is_affected
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;vn_buf
op_plus
id|tb-&gt;vn_buf_size
OL
id|vn-&gt;vn_free_ptr
)paren
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-8030: create_virtual_node: &quot;
l_string|&quot;virtual node space consumed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_affected
)paren
multiline_comment|/* this is not being changed */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vn-&gt;vn_mode
op_eq
id|M_PASTE
op_logical_or
id|vn-&gt;vn_mode
op_eq
id|M_CUT
)paren
(brace
id|vn-&gt;vn_vi
(braket
id|new_num
)braket
dot
id|vi_item_len
op_add_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
suffix:semicolon
id|vi-&gt;vi_new_data
op_assign
id|vn-&gt;vn_data
suffix:semicolon
singleline_comment|// pointer to data which is going to be pasted
)brace
)brace
multiline_comment|/* virtual inserted item is not defined yet */
r_if
c_cond
(paren
id|vn-&gt;vn_mode
op_eq
id|M_INSERT
)paren
(brace
r_struct
id|virtual_item
op_star
id|vi
op_assign
id|vn-&gt;vn_vi
op_plus
id|vn-&gt;vn_affected_item_num
suffix:semicolon
id|RFALSE
c_func
(paren
id|vn-&gt;vn_ins_ih
op_eq
l_int|0
comma
l_string|&quot;vs-8040: item header of inserted item is not specified&quot;
)paren
suffix:semicolon
id|vi-&gt;vi_item_len
op_assign
id|tb-&gt;insert_size
(braket
l_int|0
)braket
suffix:semicolon
id|vi-&gt;vi_ih
op_assign
id|vn-&gt;vn_ins_ih
suffix:semicolon
id|vi-&gt;vi_item
op_assign
id|vn-&gt;vn_data
suffix:semicolon
id|vi-&gt;vi_uarea
op_assign
id|vn-&gt;vn_free_ptr
suffix:semicolon
id|op_create_vi
(paren
id|vn
comma
id|vi
comma
l_int|0
multiline_comment|/*not pasted or cut*/
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* set right merge flag we take right delimiting key and check whether it is a mergeable item */
r_if
c_cond
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
id|key
op_assign
id|B_N_PDELIM_KEY
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op_is_left_mergeable
(paren
id|key
comma
id|Sh-&gt;b_size
)paren
op_logical_and
(paren
id|vn-&gt;vn_mode
op_ne
id|M_DELETE
op_logical_or
id|vn-&gt;vn_affected_item_num
op_ne
id|B_NR_ITEMS
(paren
id|Sh
)paren
op_minus
l_int|1
)paren
)paren
id|vn-&gt;vn_vi
(braket
id|vn-&gt;vn_nr_item
op_minus
l_int|1
)braket
dot
id|vi_type
op_or_assign
id|VI_TYPE_RIGHT_MERGEABLE
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|op_is_left_mergeable
(paren
id|key
comma
id|Sh-&gt;b_size
)paren
op_logical_and
op_logical_neg
(paren
id|vn-&gt;vn_mode
op_ne
id|M_DELETE
op_logical_or
id|vn-&gt;vn_affected_item_num
op_ne
id|B_NR_ITEMS
(paren
id|Sh
)paren
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* we delete last item and it could be merged with right neighbor&squot;s first item */
r_if
c_cond
(paren
op_logical_neg
(paren
id|B_NR_ITEMS
(paren
id|Sh
)paren
op_eq
l_int|1
op_logical_and
id|is_direntry_le_ih
(paren
id|B_N_PITEM_HEAD
(paren
id|Sh
comma
l_int|0
)paren
)paren
op_logical_and
id|I_ENTRY_COUNT
(paren
id|B_N_PITEM_HEAD
(paren
id|Sh
comma
l_int|0
)paren
)paren
op_eq
l_int|1
)paren
)paren
(brace
multiline_comment|/* node contains more than 1 item, or item is not directory item, or this item contains more than 1 entry */
id|print_block
(paren
id|Sh
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-8045: create_virtual_node: rdkey %k, affected item==%d (mode==%c) Must be %c&quot;
comma
id|key
comma
id|vn-&gt;vn_affected_item_num
comma
id|vn-&gt;vn_mode
comma
id|M_DELETE
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* we can delete directory item, that has only one directory entry in it */
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
multiline_comment|/* using virtual node check, how many items can be shifted to left&n;   neighbor */
DECL|function|check_left
r_static
r_void
id|check_left
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|cur_free
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
r_struct
id|virtual_item
op_star
id|vi
suffix:semicolon
r_int
id|d_size
comma
id|ih_size
suffix:semicolon
id|RFALSE
c_func
(paren
id|cur_free
OL
l_int|0
comma
l_string|&quot;vs-8050: cur_free (%d) &lt; 0&quot;
comma
id|cur_free
)paren
suffix:semicolon
multiline_comment|/* internal level */
r_if
c_cond
(paren
id|h
OG
l_int|0
)paren
(brace
id|tb-&gt;lnum
(braket
id|h
)braket
op_assign
id|cur_free
op_div
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* leaf level */
r_if
c_cond
(paren
op_logical_neg
id|cur_free
op_logical_or
op_logical_neg
id|vn-&gt;vn_nr_item
)paren
(brace
multiline_comment|/* no free space or nothing to move */
id|tb-&gt;lnum
(braket
id|h
)braket
op_assign
l_int|0
suffix:semicolon
id|tb-&gt;lbytes
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
op_logical_neg
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
comma
l_string|&quot;vs-8055: parent does not exist or invalid&quot;
)paren
suffix:semicolon
id|vi
op_assign
id|vn-&gt;vn_vi
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|cur_free
op_ge
(paren
id|vn-&gt;vn_size
op_minus
(paren
(paren
id|vi-&gt;vi_type
op_amp
id|VI_TYPE_LEFT_MERGEABLE
)paren
ques
c_cond
id|IH_SIZE
suffix:colon
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* all contents of S[0] fits into L[0] */
id|RFALSE
c_func
(paren
id|vn-&gt;vn_mode
op_eq
id|M_INSERT
op_logical_or
id|vn-&gt;vn_mode
op_eq
id|M_PASTE
comma
l_string|&quot;vs-8055: invalid mode or balance condition failed&quot;
)paren
suffix:semicolon
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_assign
id|vn-&gt;vn_nr_item
suffix:semicolon
id|tb-&gt;lbytes
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|d_size
op_assign
l_int|0
comma
id|ih_size
op_assign
id|IH_SIZE
suffix:semicolon
multiline_comment|/* first item may be merge with last item in left neighbor */
r_if
c_cond
(paren
id|vi-&gt;vi_type
op_amp
id|VI_TYPE_LEFT_MERGEABLE
)paren
id|d_size
op_assign
op_minus
(paren
(paren
r_int
)paren
id|IH_SIZE
)paren
comma
id|ih_size
op_assign
l_int|0
suffix:semicolon
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vn-&gt;vn_nr_item
suffix:semicolon
id|i
op_increment
comma
id|ih_size
op_assign
id|IH_SIZE
comma
id|d_size
op_assign
l_int|0
comma
id|vi
op_increment
)paren
(brace
id|d_size
op_add_assign
id|vi-&gt;vi_item_len
suffix:semicolon
r_if
c_cond
(paren
id|cur_free
op_ge
id|d_size
)paren
(brace
multiline_comment|/* the item can be shifted entirely */
id|cur_free
op_sub_assign
id|d_size
suffix:semicolon
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* the item cannot be shifted entirely, try to split it */
multiline_comment|/* check whether L[0] can hold ih and at least one byte of the item body */
r_if
c_cond
(paren
id|cur_free
op_le
id|ih_size
)paren
(brace
multiline_comment|/* cannot shift even a part of the current item */
id|tb-&gt;lbytes
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cur_free
op_sub_assign
id|ih_size
suffix:semicolon
id|tb-&gt;lbytes
op_assign
id|op_check_left
(paren
id|vi
comma
id|cur_free
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
)paren
multiline_comment|/* count partially shifted item */
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* using virtual node check, how many items can be shifted to right&n;   neighbor */
DECL|function|check_right
r_static
r_void
id|check_right
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|cur_free
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
r_struct
id|virtual_item
op_star
id|vi
suffix:semicolon
r_int
id|d_size
comma
id|ih_size
suffix:semicolon
id|RFALSE
c_func
(paren
id|cur_free
OL
l_int|0
comma
l_string|&quot;vs-8070: cur_free &lt; 0&quot;
)paren
suffix:semicolon
multiline_comment|/* internal level */
r_if
c_cond
(paren
id|h
OG
l_int|0
)paren
(brace
id|tb-&gt;rnum
(braket
id|h
)braket
op_assign
id|cur_free
op_div
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* leaf level */
r_if
c_cond
(paren
op_logical_neg
id|cur_free
op_logical_or
op_logical_neg
id|vn-&gt;vn_nr_item
)paren
(brace
multiline_comment|/* no free space  */
id|tb-&gt;rnum
(braket
id|h
)braket
op_assign
l_int|0
suffix:semicolon
id|tb-&gt;rbytes
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
op_logical_neg
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
comma
l_string|&quot;vs-8075: parent does not exist or invalid&quot;
)paren
suffix:semicolon
id|vi
op_assign
id|vn-&gt;vn_vi
op_plus
id|vn-&gt;vn_nr_item
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|cur_free
op_ge
(paren
id|vn-&gt;vn_size
op_minus
(paren
(paren
id|vi-&gt;vi_type
op_amp
id|VI_TYPE_RIGHT_MERGEABLE
)paren
ques
c_cond
id|IH_SIZE
suffix:colon
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* all contents of S[0] fits into R[0] */
id|RFALSE
c_func
(paren
id|vn-&gt;vn_mode
op_eq
id|M_INSERT
op_logical_or
id|vn-&gt;vn_mode
op_eq
id|M_PASTE
comma
l_string|&quot;vs-8080: invalid mode or balance condition failed&quot;
)paren
suffix:semicolon
id|tb-&gt;rnum
(braket
id|h
)braket
op_assign
id|vn-&gt;vn_nr_item
suffix:semicolon
id|tb-&gt;rbytes
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|d_size
op_assign
l_int|0
comma
id|ih_size
op_assign
id|IH_SIZE
suffix:semicolon
multiline_comment|/* last item may be merge with first item in right neighbor */
r_if
c_cond
(paren
id|vi-&gt;vi_type
op_amp
id|VI_TYPE_RIGHT_MERGEABLE
)paren
id|d_size
op_assign
op_minus
(paren
r_int
)paren
id|IH_SIZE
comma
id|ih_size
op_assign
l_int|0
suffix:semicolon
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|vn-&gt;vn_nr_item
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
comma
id|d_size
op_assign
l_int|0
comma
id|ih_size
op_assign
id|IH_SIZE
comma
id|vi
op_decrement
)paren
(brace
id|d_size
op_add_assign
id|vi-&gt;vi_item_len
suffix:semicolon
r_if
c_cond
(paren
id|cur_free
op_ge
id|d_size
)paren
(brace
multiline_comment|/* the item can be shifted entirely */
id|cur_free
op_sub_assign
id|d_size
suffix:semicolon
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* check whether R[0] can hold ih and at least one byte of the item body */
r_if
c_cond
(paren
id|cur_free
op_le
id|ih_size
)paren
(brace
multiline_comment|/* cannot shift even a part of the current item */
id|tb-&gt;rbytes
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* R[0] can hold the header of the item and at least one byte of its body */
id|cur_free
op_sub_assign
id|ih_size
suffix:semicolon
multiline_comment|/* cur_free is still &gt; 0 */
id|tb-&gt;rbytes
op_assign
id|op_check_right
(paren
id|vi
comma
id|cur_free
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
multiline_comment|/* count partially shifted item */
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * from - number of items, which are shifted to left neighbor entirely&n; * to - number of item, which are shifted to right neighbor entirely&n; * from_bytes - number of bytes of boundary item (or directory entries) which are shifted to left neighbor&n; * to_bytes - number of bytes of boundary item (or directory entries) which are shifted to right neighbor */
DECL|function|get_num_ver
r_static
r_int
id|get_num_ver
(paren
r_int
id|mode
comma
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|from
comma
r_int
id|from_bytes
comma
r_int
id|to
comma
r_int
id|to_bytes
comma
r_int
op_star
id|snum012
comma
r_int
id|flow
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|cur_free
suffix:semicolon
singleline_comment|//    int bytes;
r_int
id|units
suffix:semicolon
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
singleline_comment|//    struct virtual_item * vi;
r_int
id|total_node_size
comma
id|max_node_size
comma
id|current_item_size
suffix:semicolon
r_int
id|needed_nodes
suffix:semicolon
r_int
id|start_item
comma
multiline_comment|/* position of item we start filling node from */
id|end_item
comma
multiline_comment|/* position of item we finish filling node by */
id|start_bytes
comma
multiline_comment|/* number of first bytes (entries for directory) of start_item-th item &n;&t;&t;       we do not include into node that is being filled */
id|end_bytes
suffix:semicolon
multiline_comment|/* number of last bytes (entries for directory) of end_item-th item &n;&t;&t;&t;   we do node include into node that is being filled */
r_int
id|split_item_positions
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* these are positions in virtual item of&n;&t;&t;&t;&t;    items, that are split between S[0] and&n;&t;&t;&t;&t;    S1new and S1new and S2new */
id|split_item_positions
(braket
l_int|0
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|split_item_positions
(braket
l_int|1
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We only create additional nodes if we are in insert or paste mode&n;       or we are in replace mode at the internal level. If h is 0 and&n;       the mode is M_REPLACE then in fix_nodes we change the mode to&n;       paste or insert before we get here in the code.  */
id|RFALSE
c_func
(paren
id|tb-&gt;insert_size
(braket
id|h
)braket
OL
l_int|0
op_logical_or
(paren
id|mode
op_ne
id|M_INSERT
op_logical_and
id|mode
op_ne
id|M_PASTE
)paren
comma
l_string|&quot;vs-8100: insert_size &lt; 0 in overflow&quot;
)paren
suffix:semicolon
id|max_node_size
op_assign
id|MAX_CHILD_SIZE
(paren
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
suffix:semicolon
multiline_comment|/* snum012 [0-2] - number of items, that lay&n;       to S[0], first new node and second new node */
id|snum012
(braket
l_int|3
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* s1bytes */
id|snum012
(braket
l_int|4
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* s2bytes */
multiline_comment|/* internal level */
r_if
c_cond
(paren
id|h
OG
l_int|0
)paren
(brace
id|i
op_assign
(paren
(paren
id|to
op_minus
id|from
)paren
op_star
(paren
id|KEY_SIZE
op_plus
id|DC_SIZE
)paren
op_plus
id|DC_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|max_node_size
)paren
r_return
l_int|1
suffix:semicolon
r_return
(paren
id|i
op_div
id|max_node_size
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* leaf level */
id|needed_nodes
op_assign
l_int|1
suffix:semicolon
id|total_node_size
op_assign
l_int|0
suffix:semicolon
id|cur_free
op_assign
id|max_node_size
suffix:semicolon
singleline_comment|// start from &squot;from&squot;-th item
id|start_item
op_assign
id|from
suffix:semicolon
singleline_comment|// skip its first &squot;start_bytes&squot; units
id|start_bytes
op_assign
(paren
(paren
id|from_bytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|from_bytes
suffix:colon
l_int|0
)paren
suffix:semicolon
singleline_comment|// last included item is the &squot;end_item&squot;-th one
id|end_item
op_assign
id|vn-&gt;vn_nr_item
op_minus
id|to
op_minus
l_int|1
suffix:semicolon
singleline_comment|// do not count last &squot;end_bytes&squot; units of &squot;end_item&squot;-th item
id|end_bytes
op_assign
(paren
id|to_bytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|to_bytes
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* go through all item beginning from the start_item-th item and ending by&n;       the end_item-th item. Do not count first &squot;start_bytes&squot; units of&n;       &squot;start_item&squot;-th item and last &squot;end_bytes&squot; of &squot;end_item&squot;-th item */
r_for
c_loop
(paren
id|i
op_assign
id|start_item
suffix:semicolon
id|i
op_le
id|end_item
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|virtual_item
op_star
id|vi
op_assign
id|vn-&gt;vn_vi
op_plus
id|i
suffix:semicolon
r_int
id|skip_from_end
op_assign
(paren
(paren
id|i
op_eq
id|end_item
)paren
ques
c_cond
id|end_bytes
suffix:colon
l_int|0
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|needed_nodes
OG
l_int|3
comma
l_string|&quot;vs-8105: too many nodes are needed&quot;
)paren
suffix:semicolon
multiline_comment|/* get size of current item */
id|current_item_size
op_assign
id|vi-&gt;vi_item_len
suffix:semicolon
multiline_comment|/* do not take in calculation head part (from_bytes) of from-th item */
id|current_item_size
op_sub_assign
id|op_part_size
(paren
id|vi
comma
l_int|0
multiline_comment|/*from start*/
comma
id|start_bytes
)paren
suffix:semicolon
multiline_comment|/* do not take in calculation tail part of last item */
id|current_item_size
op_sub_assign
id|op_part_size
(paren
id|vi
comma
l_int|1
multiline_comment|/*from end*/
comma
id|skip_from_end
)paren
suffix:semicolon
multiline_comment|/* if item fits into current node entierly */
r_if
c_cond
(paren
id|total_node_size
op_plus
id|current_item_size
op_le
id|max_node_size
)paren
(brace
id|snum012
(braket
id|needed_nodes
op_minus
l_int|1
)braket
op_increment
suffix:semicolon
id|total_node_size
op_add_assign
id|current_item_size
suffix:semicolon
id|start_bytes
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_item_size
OG
id|max_node_size
)paren
(brace
multiline_comment|/* virtual item length is longer, than max size of item in&n;               a node. It is impossible for direct item */
id|RFALSE
c_func
(paren
id|is_direct_le_ih
(paren
id|vi-&gt;vi_ih
)paren
comma
l_string|&quot;vs-8110: &quot;
l_string|&quot;direct item length is %d. It can not be longer than %d&quot;
comma
id|current_item_size
comma
id|max_node_size
)paren
suffix:semicolon
multiline_comment|/* we will try to split it */
id|flow
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|flow
)paren
(brace
multiline_comment|/* as we do not split items, take new node and continue */
id|needed_nodes
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
id|total_node_size
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// calculate number of item units which fit into node being
singleline_comment|// filled
(brace
r_int
id|free_space
suffix:semicolon
id|free_space
op_assign
id|max_node_size
op_minus
id|total_node_size
op_minus
id|IH_SIZE
suffix:semicolon
id|units
op_assign
id|op_check_left
(paren
id|vi
comma
id|free_space
comma
id|start_bytes
comma
id|skip_from_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|units
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* nothing fits into current node, take new node and continue */
id|needed_nodes
op_increment
comma
id|i
op_decrement
comma
id|total_node_size
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* something fits into the current node */
singleline_comment|//if (snum012[3] != -1 || needed_nodes != 1)
singleline_comment|//  reiserfs_panic (tb-&gt;tb_sb, &quot;vs-8115: get_num_ver: too many nodes required&quot;);
singleline_comment|//snum012[needed_nodes - 1 + 3] = op_unit_num (vi) - start_bytes - units;
id|start_bytes
op_add_assign
id|units
suffix:semicolon
id|snum012
(braket
id|needed_nodes
op_minus
l_int|1
op_plus
l_int|3
)braket
op_assign
id|units
suffix:semicolon
r_if
c_cond
(paren
id|needed_nodes
OG
l_int|2
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-8111: get_num_ver: split_item_position is out of boundary&bslash;n&quot;
)paren
suffix:semicolon
id|snum012
(braket
id|needed_nodes
op_minus
l_int|1
)braket
op_increment
suffix:semicolon
id|split_item_positions
(braket
id|needed_nodes
op_minus
l_int|1
)braket
op_assign
id|i
suffix:semicolon
id|needed_nodes
op_increment
suffix:semicolon
multiline_comment|/* continue from the same item with start_bytes != -1 */
id|start_item
op_assign
id|i
suffix:semicolon
id|i
op_decrement
suffix:semicolon
id|total_node_size
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// sum012[4] (if it is not -1) contains number of units of which
singleline_comment|// are to be in S1new, snum012[3] - to be in S0. They are supposed
singleline_comment|// to be S1bytes and S2bytes correspondingly, so recalculate
r_if
c_cond
(paren
id|snum012
(braket
l_int|4
)braket
OG
l_int|0
)paren
(brace
r_int
id|split_item_num
suffix:semicolon
r_int
id|bytes_to_r
comma
id|bytes_to_l
suffix:semicolon
r_int
id|bytes_to_S1new
suffix:semicolon
id|split_item_num
op_assign
id|split_item_positions
(braket
l_int|1
)braket
suffix:semicolon
id|bytes_to_l
op_assign
(paren
(paren
id|from
op_eq
id|split_item_num
op_logical_and
id|from_bytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|from_bytes
suffix:colon
l_int|0
)paren
suffix:semicolon
id|bytes_to_r
op_assign
(paren
(paren
id|end_item
op_eq
id|split_item_num
op_logical_and
id|end_bytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|end_bytes
suffix:colon
l_int|0
)paren
suffix:semicolon
id|bytes_to_S1new
op_assign
(paren
(paren
id|split_item_positions
(braket
l_int|0
)braket
op_eq
id|split_item_positions
(braket
l_int|1
)braket
)paren
ques
c_cond
id|snum012
(braket
l_int|3
)braket
suffix:colon
l_int|0
)paren
suffix:semicolon
singleline_comment|// s2bytes
id|snum012
(braket
l_int|4
)braket
op_assign
id|op_unit_num
(paren
op_amp
id|vn-&gt;vn_vi
(braket
id|split_item_num
)braket
)paren
op_minus
id|snum012
(braket
l_int|4
)braket
op_minus
id|bytes_to_r
op_minus
id|bytes_to_l
op_minus
id|bytes_to_S1new
suffix:semicolon
r_if
c_cond
(paren
id|vn-&gt;vn_vi
(braket
id|split_item_num
)braket
dot
id|vi_index
op_ne
id|TYPE_DIRENTRY
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-8115: get_num_ver: not directory item&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* now we know S2bytes, calculate S1bytes */
r_if
c_cond
(paren
id|snum012
(braket
l_int|3
)braket
OG
l_int|0
)paren
(brace
r_int
id|split_item_num
suffix:semicolon
r_int
id|bytes_to_r
comma
id|bytes_to_l
suffix:semicolon
r_int
id|bytes_to_S2new
suffix:semicolon
id|split_item_num
op_assign
id|split_item_positions
(braket
l_int|0
)braket
suffix:semicolon
id|bytes_to_l
op_assign
(paren
(paren
id|from
op_eq
id|split_item_num
op_logical_and
id|from_bytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|from_bytes
suffix:colon
l_int|0
)paren
suffix:semicolon
id|bytes_to_r
op_assign
(paren
(paren
id|end_item
op_eq
id|split_item_num
op_logical_and
id|end_bytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|end_bytes
suffix:colon
l_int|0
)paren
suffix:semicolon
id|bytes_to_S2new
op_assign
(paren
(paren
id|split_item_positions
(braket
l_int|0
)braket
op_eq
id|split_item_positions
(braket
l_int|1
)braket
op_logical_and
id|snum012
(braket
l_int|4
)braket
op_ne
op_minus
l_int|1
)paren
ques
c_cond
id|snum012
(braket
l_int|4
)braket
suffix:colon
l_int|0
)paren
suffix:semicolon
singleline_comment|// s1bytes
id|snum012
(braket
l_int|3
)braket
op_assign
id|op_unit_num
(paren
op_amp
id|vn-&gt;vn_vi
(braket
id|split_item_num
)braket
)paren
op_minus
id|snum012
(braket
l_int|3
)braket
op_minus
id|bytes_to_r
op_minus
id|bytes_to_l
op_minus
id|bytes_to_S2new
suffix:semicolon
)brace
r_return
id|needed_nodes
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_extern
r_struct
id|tree_balance
op_star
id|cur_tb
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set parameters for balancing.&n; * Performs write of results of analysis of balancing into structure tb,&n; * where it will later be used by the functions that actually do the balancing. &n; * Parameters:&n; *&t;tb&t;tree_balance structure;&n; *&t;h&t;current level of the node;&n; *&t;lnum&t;number of items from S[h] that must be shifted to L[h];&n; *&t;rnum&t;number of items from S[h] that must be shifted to R[h];&n; *&t;blk_num&t;number of blocks that S[h] will be splitted into;&n; *&t;s012&t;number of items that fall into splitted nodes.&n; *&t;lbytes&t;number of bytes which flow to the left neighbor from the item that is not&n; *&t;&t;not shifted entirely&n; *&t;rbytes&t;number of bytes which flow to the right neighbor from the item that is not&n; *&t;&t;not shifted entirely&n; *&t;s1bytes&t;number of bytes which flow to the first  new node when S[0] splits (this number is contained in s012 array)&n; */
DECL|function|set_parameters
r_static
r_void
id|set_parameters
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|lnum
comma
r_int
id|rnum
comma
r_int
id|blk_num
comma
r_int
op_star
id|s012
comma
r_int
id|lb
comma
r_int
id|rb
)paren
(brace
id|tb-&gt;lnum
(braket
id|h
)braket
op_assign
id|lnum
suffix:semicolon
id|tb-&gt;rnum
(braket
id|h
)braket
op_assign
id|rnum
suffix:semicolon
id|tb-&gt;blknum
(braket
id|h
)braket
op_assign
id|blk_num
suffix:semicolon
r_if
c_cond
(paren
id|h
op_eq
l_int|0
)paren
(brace
multiline_comment|/* only for leaf level */
r_if
c_cond
(paren
id|s012
op_ne
l_int|NULL
)paren
(brace
id|tb-&gt;s0num
op_assign
op_star
id|s012
op_increment
comma
id|tb-&gt;s1num
op_assign
op_star
id|s012
op_increment
comma
id|tb-&gt;s2num
op_assign
op_star
id|s012
op_increment
suffix:semicolon
id|tb-&gt;s1bytes
op_assign
op_star
id|s012
op_increment
suffix:semicolon
id|tb-&gt;s2bytes
op_assign
op_star
id|s012
suffix:semicolon
)brace
id|tb-&gt;lbytes
op_assign
id|lb
suffix:semicolon
id|tb-&gt;rbytes
op_assign
id|rb
suffix:semicolon
)brace
id|PROC_INFO_ADD
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|lnum
(braket
id|h
)braket
comma
id|lnum
)paren
suffix:semicolon
id|PROC_INFO_ADD
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|rnum
(braket
id|h
)braket
comma
id|rnum
)paren
suffix:semicolon
id|PROC_INFO_ADD
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|lbytes
(braket
id|h
)braket
comma
id|lb
)paren
suffix:semicolon
id|PROC_INFO_ADD
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|rbytes
(braket
id|h
)braket
comma
id|rb
)paren
suffix:semicolon
)brace
multiline_comment|/* check, does node disappear if we shift tb-&gt;lnum[0] items to left&n;   neighbor and tb-&gt;rnum[0] to the right one. */
DECL|function|is_leaf_removable
r_static
r_int
id|is_leaf_removable
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
r_int
id|to_left
comma
id|to_right
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|remain_items
suffix:semicolon
multiline_comment|/* number of items, that will be shifted to left (right) neighbor&n;     entirely */
id|to_left
op_assign
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_minus
(paren
(paren
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|to_right
op_assign
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_minus
(paren
(paren
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|remain_items
op_assign
id|vn-&gt;vn_nr_item
suffix:semicolon
multiline_comment|/* how many items remain in S[0] after shiftings to neighbors */
id|remain_items
op_sub_assign
(paren
id|to_left
op_plus
id|to_right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remain_items
OL
l_int|1
)paren
(brace
multiline_comment|/* all content of node can be shifted to neighbors */
id|set_parameters
(paren
id|tb
comma
l_int|0
comma
id|to_left
comma
id|vn-&gt;vn_nr_item
op_minus
id|to_left
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remain_items
OG
l_int|1
op_logical_or
id|tb-&gt;lbytes
op_eq
op_minus
l_int|1
op_logical_or
id|tb-&gt;rbytes
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* S[0] is not removable */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* check, whether we can divide 1 remaining item between neighbors */
multiline_comment|/* get size of remaining item (in item units) */
id|size
op_assign
id|op_unit_num
(paren
op_amp
(paren
id|vn-&gt;vn_vi
(braket
id|to_left
)braket
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lbytes
op_plus
id|tb-&gt;rbytes
op_ge
id|size
)paren
(brace
id|set_parameters
(paren
id|tb
comma
l_int|0
comma
id|to_left
op_plus
l_int|1
comma
id|to_right
op_plus
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
id|tb-&gt;lbytes
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check whether L, S, R can be joined in one node */
DECL|function|are_leaves_removable
r_static
r_int
id|are_leaves_removable
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|lfree
comma
r_int
id|rfree
)paren
(brace
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
r_int
id|ih_size
suffix:semicolon
r_struct
id|buffer_head
op_star
id|S0
suffix:semicolon
id|S0
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|ih_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vn-&gt;vn_nr_item
)paren
(brace
r_if
c_cond
(paren
id|vn-&gt;vn_vi
(braket
l_int|0
)braket
dot
id|vi_type
op_amp
id|VI_TYPE_LEFT_MERGEABLE
)paren
id|ih_size
op_add_assign
id|IH_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|vn-&gt;vn_vi
(braket
id|vn-&gt;vn_nr_item
op_minus
l_int|1
)braket
dot
id|vi_type
op_amp
id|VI_TYPE_RIGHT_MERGEABLE
)paren
id|ih_size
op_add_assign
id|IH_SIZE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* there was only one item and it will be deleted */
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
id|RFALSE
c_func
(paren
id|B_NR_ITEMS
(paren
id|S0
)paren
op_ne
l_int|1
comma
l_string|&quot;vs-8125: item number must be 1: it is %d&quot;
comma
id|B_NR_ITEMS
c_func
(paren
id|S0
)paren
)paren
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|S0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|comp_short_le_keys
(paren
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
id|B_N_PDELIM_KEY
(paren
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
)paren
)paren
)paren
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* Directory must be in correct state here: that is&n;&t;       somewhere at the left side should exist first directory&n;&t;       item. But the item being deleted can not be that first&n;&t;       one because its right neighbor is item of the same&n;&t;       directory. (But first item always gets deleted in last&n;&t;       turn). So, neighbors of deleted item can be merged, so&n;&t;       we can save ih_size */
id|ih_size
op_assign
id|IH_SIZE
suffix:semicolon
multiline_comment|/* we might check that left neighbor exists and is of the&n;&t;       same directory */
id|RFALSE
c_func
(paren
id|le_ih_k_offset
(paren
id|ih
)paren
op_eq
id|DOT_OFFSET
comma
l_string|&quot;vs-8130: first directory item can not be removed until directory is not empty&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|MAX_CHILD_SIZE
(paren
id|S0
)paren
op_plus
id|vn-&gt;vn_size
op_le
id|rfree
op_plus
id|lfree
op_plus
id|ih_size
)paren
(brace
id|set_parameters
(paren
id|tb
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|leaves_removable
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* when we do not split item, lnum and rnum are numbers of entire items */
DECL|macro|SET_PAR_SHIFT_LEFT
mdefine_line|#define SET_PAR_SHIFT_LEFT &bslash;&n;if (h)&bslash;&n;{&bslash;&n;   int to_l;&bslash;&n;   &bslash;&n;   to_l = (MAX_NR_KEY(Sh)+1 - lpar + vn-&gt;vn_nr_item + 1) / 2 -&bslash;&n;&t;      (MAX_NR_KEY(Sh) + 1 - lpar);&bslash;&n;&t;      &bslash;&n;&t;      set_parameters (tb, h, to_l, 0, lnver, NULL, -1, -1);&bslash;&n;}&bslash;&n;else &bslash;&n;{&bslash;&n;   if (lset==LEFT_SHIFT_FLOW)&bslash;&n;     set_parameters (tb, h, lpar, 0, lnver, snum012+lset,&bslash;&n;&t;&t;     tb-&gt;lbytes, -1);&bslash;&n;   else&bslash;&n;     set_parameters (tb, h, lpar - (tb-&gt;lbytes!=-1), 0, lnver, snum012+lset,&bslash;&n;&t;&t;     -1, -1);&bslash;&n;}
DECL|macro|SET_PAR_SHIFT_RIGHT
mdefine_line|#define SET_PAR_SHIFT_RIGHT &bslash;&n;if (h)&bslash;&n;{&bslash;&n;   int to_r;&bslash;&n;   &bslash;&n;   to_r = (MAX_NR_KEY(Sh)+1 - rpar + vn-&gt;vn_nr_item + 1) / 2 - (MAX_NR_KEY(Sh) + 1 - rpar);&bslash;&n;   &bslash;&n;   set_parameters (tb, h, 0, to_r, rnver, NULL, -1, -1);&bslash;&n;}&bslash;&n;else &bslash;&n;{&bslash;&n;   if (rset==RIGHT_SHIFT_FLOW)&bslash;&n;     set_parameters (tb, h, 0, rpar, rnver, snum012+rset,&bslash;&n;&t;&t;  -1, tb-&gt;rbytes);&bslash;&n;   else&bslash;&n;     set_parameters (tb, h, 0, rpar - (tb-&gt;rbytes!=-1), rnver, snum012+rset,&bslash;&n;&t;&t;  -1, -1);&bslash;&n;}
DECL|function|free_buffers_in_tb
r_void
id|free_buffers_in_tb
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
)paren
(brace
r_int
id|n_counter
suffix:semicolon
id|decrement_counters_in_path
c_func
(paren
id|p_s_tb-&gt;tb_path
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n_counter
op_assign
l_int|0
suffix:semicolon
id|n_counter
OL
id|MAX_HEIGHT
suffix:semicolon
id|n_counter
op_increment
)paren
(brace
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;L
(braket
id|n_counter
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;L
(braket
id|n_counter
)braket
op_assign
l_int|NULL
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;R
(braket
id|n_counter
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;R
(braket
id|n_counter
)braket
op_assign
l_int|NULL
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_counter
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;FL
(braket
id|n_counter
)braket
op_assign
l_int|NULL
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;FR
(braket
id|n_counter
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;FR
(braket
id|n_counter
)braket
op_assign
l_int|NULL
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;CFL
(braket
id|n_counter
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;CFL
(braket
id|n_counter
)braket
op_assign
l_int|NULL
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;CFR
(braket
id|n_counter
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;CFR
(braket
id|n_counter
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Get new buffers for storing new nodes that are created while balancing.&n; * Returns:&t;SCHEDULE_OCCURRED - schedule occurred while the function worked;&n; *&t;        CARRY_ON - schedule didn&squot;t occur while the function worked;&n; *&t;        NO_DISK_SPACE - no disk space.&n; */
multiline_comment|/* The function is NOT SCHEDULE-SAFE! */
DECL|function|get_empty_nodes
r_static
r_int
id|get_empty_nodes
c_func
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_int
id|n_h
)paren
(brace
r_struct
id|buffer_head
op_star
id|p_s_new_bh
comma
op_star
id|p_s_Sh
op_assign
id|PATH_H_PBUFFER
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_h
)paren
suffix:semicolon
r_int
r_int
op_star
id|p_n_blocknr
comma
id|a_n_blocknrs
(braket
id|MAX_AMOUNT_NEEDED
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_int
id|n_counter
comma
id|n_number_of_freeblk
comma
id|n_amount_needed
comma
multiline_comment|/* number of needed empty blocks */
id|n_retval
op_assign
id|CARRY_ON
suffix:semicolon
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|p_s_tb-&gt;tb_sb
suffix:semicolon
multiline_comment|/* number_of_freeblk is the number of empty blocks which have been&n;     acquired for use by the balancing algorithm minus the number of&n;     empty blocks used in the previous levels of the analysis,&n;     number_of_freeblk = tb-&gt;cur_blknum can be non-zero if a schedule occurs&n;     after empty blocks are acquired, and the balancing analysis is&n;     then restarted, amount_needed is the number needed by this level&n;     (n_h) of the balancing analysis.&n;&t;&t;&t;    &n;     Note that for systems with many processes writing, it would be&n;     more layout optimal to calculate the total number needed by all&n;     levels and then to run reiserfs_new_blocks to get all of them at once.  */
multiline_comment|/* Initiate number_of_freeblk to the amount acquired prior to the restart of&n;     the analysis or 0 if not restarted, then subtract the amount needed&n;     by all of the levels of the tree below n_h. */
multiline_comment|/* blknum includes S[n_h], so we subtract 1 in this calculation */
r_for
c_loop
(paren
id|n_counter
op_assign
l_int|0
comma
id|n_number_of_freeblk
op_assign
id|p_s_tb-&gt;cur_blknum
suffix:semicolon
id|n_counter
OL
id|n_h
suffix:semicolon
id|n_counter
op_increment
)paren
id|n_number_of_freeblk
op_sub_assign
(paren
id|p_s_tb-&gt;blknum
(braket
id|n_counter
)braket
)paren
ques
c_cond
(paren
id|p_s_tb-&gt;blknum
(braket
id|n_counter
)braket
op_minus
l_int|1
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Allocate missing empty blocks. */
multiline_comment|/* if p_s_Sh == 0  then we are getting a new root */
id|n_amount_needed
op_assign
(paren
id|p_s_Sh
)paren
ques
c_cond
(paren
id|p_s_tb-&gt;blknum
(braket
id|n_h
)braket
op_minus
l_int|1
)paren
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*  Amount_needed = the amount that we need more than the amount that we have. */
r_if
c_cond
(paren
id|n_amount_needed
OG
id|n_number_of_freeblk
)paren
id|n_amount_needed
op_sub_assign
id|n_number_of_freeblk
suffix:semicolon
r_else
multiline_comment|/* If we have enough already then there is nothing to do. */
r_return
id|CARRY_ON
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_new_blocknrs
(paren
id|p_s_tb-&gt;transaction_handle
comma
id|a_n_blocknrs
comma
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
)paren
op_member_access_from_pointer
id|b_blocknr
comma
id|n_amount_needed
)paren
op_eq
id|NO_DISK_SPACE
)paren
r_return
id|NO_DISK_SPACE
suffix:semicolon
multiline_comment|/* for each blocknumber we just got, get a buffer and stick it on FEB */
r_for
c_loop
(paren
id|p_n_blocknr
op_assign
id|a_n_blocknrs
comma
id|n_counter
op_assign
l_int|0
suffix:semicolon
id|n_counter
OL
id|n_amount_needed
suffix:semicolon
id|p_n_blocknr
op_increment
comma
id|n_counter
op_increment
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
op_star
id|p_n_blocknr
comma
l_string|&quot;PAP-8135: reiserfs_new_blocknrs failed when got new blocks&quot;
)paren
suffix:semicolon
id|p_s_new_bh
op_assign
id|reiserfs_getblk
c_func
(paren
id|p_s_sb
comma
op_star
id|p_n_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
(paren
id|p_s_new_bh-&gt;b_count
)paren
)paren
OG
l_int|1
)paren
(brace
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
multiline_comment|/*&n;      reiserfs_warning (&quot;waiting for buffer %b, iput inode pid = %d, this pid %d, mode %c, %h&bslash;n&quot;,&n;&t;&t;&t;p_s_new_bh, put_inode_pid, current-&gt;pid, p_s_tb-&gt;tb_vn-&gt;vn_mode, p_s_tb-&gt;tb_vn-&gt;vn_ins_ih);&n;      print_tb (0, 0, 0, p_s_tb, &quot;tb&quot;);&n;*/
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|p_s_new_bh-&gt;b_count
)paren
)paren
OG
l_int|2
op_logical_or
op_logical_neg
(paren
id|buffer_journaled
c_func
(paren
id|p_s_new_bh
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|p_s_new_bh
)paren
)paren
)paren
(brace
id|n_retval
op_assign
id|REPEAT_SEARCH
suffix:semicolon
id|free_buffers_in_tb
(paren
id|p_s_tb
)paren
suffix:semicolon
id|wait_buffer_until_released
(paren
id|p_s_new_bh
)paren
suffix:semicolon
)brace
)brace
id|RFALSE
c_func
(paren
(paren
id|atomic_read
(paren
op_amp
(paren
id|p_s_new_bh-&gt;b_count
)paren
)paren
op_ne
l_int|1
op_logical_or
id|buffer_dirty
(paren
id|p_s_new_bh
)paren
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
(paren
id|p_s_new_bh-&gt;b_count
)paren
)paren
OG
l_int|2
op_logical_or
op_logical_neg
(paren
id|buffer_journaled
c_func
(paren
id|p_s_new_bh
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|p_s_new_bh
)paren
)paren
)paren
comma
l_string|&quot;PAP-8140: not free or dirty buffer %b for the new block&quot;
comma
id|p_s_new_bh
)paren
suffix:semicolon
multiline_comment|/* Put empty buffers into the array. */
r_if
c_cond
(paren
id|p_s_tb-&gt;FEB
(braket
id|p_s_tb-&gt;cur_blknum
)braket
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|mark_buffer_journal_new
c_func
(paren
id|p_s_new_bh
)paren
suffix:semicolon
id|p_s_tb-&gt;FEB
(braket
id|p_s_tb-&gt;cur_blknum
op_increment
)braket
op_assign
id|p_s_new_bh
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_retval
op_eq
id|CARRY_ON
op_logical_and
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
id|n_retval
op_assign
id|REPEAT_SEARCH
suffix:semicolon
r_return
id|n_retval
suffix:semicolon
)brace
multiline_comment|/* Get free space of the left neighbor, which is stored in the parent&n; * node of the left neighbor.  */
DECL|function|get_lfree
r_static
r_int
id|get_lfree
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_struct
id|buffer_head
op_star
id|l
comma
op_star
id|f
suffix:semicolon
r_int
id|order
suffix:semicolon
r_if
c_cond
(paren
(paren
id|f
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|l
op_assign
id|tb-&gt;FL
(braket
id|h
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|f
op_eq
id|l
)paren
id|order
op_assign
id|PATH_H_B_ITEM_ORDER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
op_minus
l_int|1
suffix:semicolon
r_else
(brace
id|order
op_assign
id|B_NR_ITEMS
(paren
id|l
)paren
suffix:semicolon
id|f
op_assign
id|l
suffix:semicolon
)brace
r_return
(paren
id|MAX_CHILD_SIZE
c_func
(paren
id|f
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
c_func
(paren
id|f
comma
id|order
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Get free space of the right neighbor,&n; * which is stored in the parent node of the right neighbor.&n; */
DECL|function|get_rfree
r_static
r_int
id|get_rfree
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_struct
id|buffer_head
op_star
id|r
comma
op_star
id|f
suffix:semicolon
r_int
id|order
suffix:semicolon
r_if
c_cond
(paren
(paren
id|f
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
op_eq
l_int|0
op_logical_or
(paren
id|r
op_assign
id|tb-&gt;FR
(braket
id|h
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|f
op_eq
id|r
)paren
id|order
op_assign
id|PATH_H_B_ITEM_ORDER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
op_plus
l_int|1
suffix:semicolon
r_else
(brace
id|order
op_assign
l_int|0
suffix:semicolon
id|f
op_assign
id|r
suffix:semicolon
)brace
r_return
(paren
id|MAX_CHILD_SIZE
c_func
(paren
id|f
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
c_func
(paren
id|f
comma
id|order
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check whether left neighbor is in memory. */
DECL|function|is_left_neighbor_in_cache
r_static
r_int
id|is_left_neighbor_in_cache
c_func
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_int
id|n_h
)paren
(brace
r_struct
id|buffer_head
op_star
id|p_s_father
comma
op_star
id|left
suffix:semicolon
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|p_s_tb-&gt;tb_sb
suffix:semicolon
r_int
r_int
id|n_left_neighbor_blocknr
suffix:semicolon
r_int
id|n_left_neighbor_position
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
multiline_comment|/* Father of the left neighbor does not exist. */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Calculate father of the node to be balanced. */
id|p_s_father
op_assign
id|PATH_H_PBUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_h
op_plus
l_int|1
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|p_s_father
op_logical_or
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_father
)paren
op_logical_or
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
op_logical_or
op_logical_neg
id|buffer_uptodate
(paren
id|p_s_father
)paren
op_logical_or
op_logical_neg
id|buffer_uptodate
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
comma
l_string|&quot;vs-8165: F[h] (%b) or FL[h] (%b) is invalid&quot;
comma
id|p_s_father
comma
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
suffix:semicolon
multiline_comment|/* Get position of the pointer to the left neighbor into the left father. */
id|n_left_neighbor_position
op_assign
(paren
id|p_s_father
op_eq
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
ques
c_cond
id|p_s_tb-&gt;lkey
(braket
id|n_h
)braket
suffix:colon
id|B_NR_ITEMS
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
suffix:semicolon
multiline_comment|/* Get left neighbor block number. */
id|n_left_neighbor_blocknr
op_assign
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
comma
id|n_left_neighbor_position
)paren
suffix:semicolon
multiline_comment|/* Look for the left neighbor in the cache. */
r_if
c_cond
(paren
(paren
id|left
op_assign
id|sb_get_hash_table
c_func
(paren
id|p_s_sb
comma
id|n_left_neighbor_blocknr
)paren
)paren
)paren
(brace
id|RFALSE
c_func
(paren
id|buffer_uptodate
(paren
id|left
)paren
op_logical_and
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|left
)paren
comma
l_string|&quot;vs-8170: left neighbor (%b %z) is not in the tree&quot;
comma
id|left
comma
id|left
)paren
suffix:semicolon
id|put_bh
c_func
(paren
id|left
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|LEFT_PARENTS
mdefine_line|#define LEFT_PARENTS  &squot;l&squot;
DECL|macro|RIGHT_PARENTS
mdefine_line|#define RIGHT_PARENTS &squot;r&squot;
DECL|function|decrement_key
r_static
r_void
id|decrement_key
(paren
r_struct
id|cpu_key
op_star
id|p_s_key
)paren
(brace
singleline_comment|// call item specific function for this key
id|item_ops
(braket
id|cpu_key_k_type
(paren
id|p_s_key
)paren
)braket
op_member_access_from_pointer
id|decrement_key
(paren
id|p_s_key
)paren
suffix:semicolon
)brace
multiline_comment|/* Calculate far left/right parent of the left/right neighbor of the current node, that&n; * is calculate the left/right (FL[h]/FR[h]) neighbor of the parent F[h].&n; * Calculate left/right common parent of the current node and L[h]/R[h].&n; * Calculate left/right delimiting key position.&n; * Returns:&t;PATH_INCORRECT   - path in the tree is not correct;&n; &t;&t;SCHEDULE_OCCURRED - schedule occurred while the function worked;&n; *&t;        CARRY_ON         - schedule didn&squot;t occur while the function worked;&n; */
DECL|function|get_far_parent
r_static
r_int
id|get_far_parent
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_int
id|n_h
comma
r_struct
id|buffer_head
op_star
op_star
id|pp_s_father
comma
r_struct
id|buffer_head
op_star
op_star
id|pp_s_com_father
comma
r_char
id|c_lr_par
)paren
(brace
r_struct
id|buffer_head
op_star
id|p_s_parent
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|s_path_to_neighbor_father
)paren
suffix:semicolon
r_struct
id|path
op_star
id|p_s_path
op_assign
id|p_s_tb-&gt;tb_path
suffix:semicolon
r_struct
id|cpu_key
id|s_lr_father_key
suffix:semicolon
r_int
id|n_counter
comma
id|n_position
op_assign
id|INT_MAX
comma
id|n_first_last_position
op_assign
l_int|0
comma
id|n_path_offset
op_assign
id|PATH_H_PATH_OFFSET
c_func
(paren
id|p_s_path
comma
id|n_h
)paren
suffix:semicolon
multiline_comment|/* Starting from F[n_h] go upwards in the tree, and look for the common&n;      ancestor of F[n_h], and its neighbor l/r, that should be obtained. */
id|n_counter
op_assign
id|n_path_offset
suffix:semicolon
id|RFALSE
c_func
(paren
id|n_counter
OL
id|FIRST_PATH_ELEMENT_OFFSET
comma
l_string|&quot;PAP-8180: invalid path length&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n_counter
OG
id|FIRST_PATH_ELEMENT_OFFSET
suffix:semicolon
id|n_counter
op_decrement
)paren
(brace
multiline_comment|/* Check whether parent of the current buffer in the path is really parent in the tree. */
r_if
c_cond
(paren
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|p_s_parent
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_counter
op_minus
l_int|1
)paren
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
multiline_comment|/* Check whether position in the parent is correct. */
r_if
c_cond
(paren
(paren
id|n_position
op_assign
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_path
comma
id|n_counter
op_minus
l_int|1
)paren
)paren
OG
id|B_NR_ITEMS
c_func
(paren
id|p_s_parent
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
multiline_comment|/* Check whether parent at the path really points to the child. */
r_if
c_cond
(paren
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_parent
comma
id|n_position
)paren
op_ne
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_counter
)paren
op_member_access_from_pointer
id|b_blocknr
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
multiline_comment|/* Return delimiting key if position in the parent is not equal to first/last one. */
r_if
c_cond
(paren
id|c_lr_par
op_eq
id|RIGHT_PARENTS
)paren
id|n_first_last_position
op_assign
id|B_NR_ITEMS
(paren
id|p_s_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_position
op_ne
id|n_first_last_position
)paren
(brace
op_star
id|pp_s_com_father
op_assign
id|p_s_parent
suffix:semicolon
id|get_bh
c_func
(paren
op_star
id|pp_s_com_father
)paren
suffix:semicolon
multiline_comment|/*(*pp_s_com_father = p_s_parent)-&gt;b_count++;*/
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* if we are in the root of the tree, then there is no common father */
r_if
c_cond
(paren
id|n_counter
op_eq
id|FIRST_PATH_ELEMENT_OFFSET
)paren
(brace
multiline_comment|/* Check whether first buffer in the path is the root of the tree. */
r_if
c_cond
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|FIRST_PATH_ELEMENT_OFFSET
)paren
op_member_access_from_pointer
id|b_blocknr
op_eq
id|SB_ROOT_BLOCK
(paren
id|p_s_tb-&gt;tb_sb
)paren
)paren
(brace
op_star
id|pp_s_father
op_assign
op_star
id|pp_s_com_father
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|B_LEVEL
(paren
op_star
id|pp_s_com_father
)paren
op_le
id|DISK_LEAF_NODE_LEVEL
comma
l_string|&quot;PAP-8185: (%b %z) level too small&quot;
comma
op_star
id|pp_s_com_father
comma
op_star
id|pp_s_com_father
)paren
suffix:semicolon
multiline_comment|/* Check whether the common parent is locked. */
r_if
c_cond
(paren
id|buffer_locked
(paren
op_star
id|pp_s_com_father
)paren
)paren
(brace
id|__wait_on_buffer
c_func
(paren
op_star
id|pp_s_com_father
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
(brace
id|decrement_bcount
c_func
(paren
op_star
id|pp_s_com_father
)paren
suffix:semicolon
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
)brace
multiline_comment|/* So, we got common parent of the current node and its left/right neighbor.&n;     Now we are geting the parent of the left/right neighbor. */
multiline_comment|/* Form key to get parent of the left/right neighbor. */
id|le_key2cpu_key
(paren
op_amp
id|s_lr_father_key
comma
id|B_N_PDELIM_KEY
c_func
(paren
op_star
id|pp_s_com_father
comma
(paren
id|c_lr_par
op_eq
id|LEFT_PARENTS
)paren
ques
c_cond
(paren
id|p_s_tb-&gt;lkey
(braket
id|n_h
op_minus
l_int|1
)braket
op_assign
id|n_position
op_minus
l_int|1
)paren
suffix:colon
(paren
id|p_s_tb-&gt;rkey
(braket
id|n_h
op_minus
l_int|1
)braket
op_assign
id|n_position
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_lr_par
op_eq
id|LEFT_PARENTS
)paren
id|decrement_key
c_func
(paren
op_amp
id|s_lr_father_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_by_key
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
op_amp
id|s_lr_father_key
comma
op_amp
id|s_path_to_neighbor_father
comma
id|n_h
op_plus
l_int|1
)paren
op_eq
id|IO_ERROR
)paren
singleline_comment|// path is released
r_return
id|IO_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
(brace
id|decrement_counters_in_path
c_func
(paren
op_amp
id|s_path_to_neighbor_father
)paren
suffix:semicolon
id|decrement_bcount
c_func
(paren
op_star
id|pp_s_com_father
)paren
suffix:semicolon
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
op_star
id|pp_s_father
op_assign
id|PATH_PLAST_BUFFER
c_func
(paren
op_amp
id|s_path_to_neighbor_father
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|B_LEVEL
(paren
op_star
id|pp_s_father
)paren
op_ne
id|n_h
op_plus
l_int|1
comma
l_string|&quot;PAP-8190: (%b %z) level too small&quot;
comma
op_star
id|pp_s_father
comma
op_star
id|pp_s_father
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|s_path_to_neighbor_father.path_length
OL
id|FIRST_PATH_ELEMENT_OFFSET
comma
l_string|&quot;PAP-8192: path length is too small&quot;
)paren
suffix:semicolon
id|s_path_to_neighbor_father.path_length
op_decrement
suffix:semicolon
id|decrement_counters_in_path
c_func
(paren
op_amp
id|s_path_to_neighbor_father
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* Get parents of neighbors of node in the path(S[n_path_offset]) and common parents of&n; * S[n_path_offset] and L[n_path_offset]/R[n_path_offset]: F[n_path_offset], FL[n_path_offset],&n; * FR[n_path_offset], CFL[n_path_offset], CFR[n_path_offset].&n; * Calculate numbers of left and right delimiting keys position: lkey[n_path_offset], rkey[n_path_offset].&n; * Returns:&t;SCHEDULE_OCCURRED - schedule occurred while the function worked;&n; *&t;        CARRY_ON - schedule didn&squot;t occur while the function worked;&n; */
DECL|function|get_parents
r_static
r_int
id|get_parents
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_int
id|n_h
)paren
(brace
r_struct
id|path
op_star
id|p_s_path
op_assign
id|p_s_tb-&gt;tb_path
suffix:semicolon
r_int
id|n_position
comma
id|n_ret_value
comma
id|n_path_offset
op_assign
id|PATH_H_PATH_OFFSET
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_h
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|p_s_curf
comma
op_star
id|p_s_curcf
suffix:semicolon
multiline_comment|/* Current node is the root of the tree or will be root of the tree */
r_if
c_cond
(paren
id|n_path_offset
op_le
id|FIRST_PATH_ELEMENT_OFFSET
)paren
(brace
multiline_comment|/* The root can not have parents.&n;&t;   Release nodes which previously were obtained as parents of the current node neighbors. */
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;CFL
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;FR
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;CFR
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
op_assign
id|p_s_tb-&gt;CFL
(braket
id|n_h
)braket
op_assign
id|p_s_tb-&gt;FR
(braket
id|n_h
)braket
op_assign
id|p_s_tb-&gt;CFR
(braket
id|n_h
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* Get parent FL[n_path_offset] of L[n_path_offset]. */
r_if
c_cond
(paren
(paren
id|n_position
op_assign
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_path
comma
id|n_path_offset
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* Current node is not the first child of its parent. */
multiline_comment|/*(p_s_curf = p_s_curcf = PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1))-&gt;b_count += 2;*/
id|p_s_curf
op_assign
id|p_s_curcf
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_path_offset
op_minus
l_int|1
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|p_s_curf
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|p_s_curf
)paren
suffix:semicolon
id|p_s_tb-&gt;lkey
(braket
id|n_h
)braket
op_assign
id|n_position
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Calculate current parent of L[n_path_offset], which is the left neighbor of the current node.&n;&t;   Calculate current common parent of L[n_path_offset] and the current node. Note that&n;&t;   CFL[n_path_offset] not equal FL[n_path_offset] and CFL[n_path_offset] not equal F[n_path_offset].&n;&t;   Calculate lkey[n_path_offset]. */
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_far_parent
c_func
(paren
id|p_s_tb
comma
id|n_h
op_plus
l_int|1
comma
op_amp
id|p_s_curf
comma
op_amp
id|p_s_curcf
comma
id|LEFT_PARENTS
)paren
)paren
op_ne
id|CARRY_ON
)paren
r_return
id|n_ret_value
suffix:semicolon
)brace
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
op_assign
id|p_s_curf
suffix:semicolon
multiline_comment|/* New initialization of FL[n_h]. */
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;CFL
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;CFL
(braket
id|n_h
)braket
op_assign
id|p_s_curcf
suffix:semicolon
multiline_comment|/* New initialization of CFL[n_h]. */
id|RFALSE
c_func
(paren
(paren
id|p_s_curf
op_logical_and
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_curf
)paren
)paren
op_logical_or
(paren
id|p_s_curcf
op_logical_and
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_curcf
)paren
)paren
comma
l_string|&quot;PAP-8195: FL (%b) or CFL (%b) is invalid&quot;
comma
id|p_s_curf
comma
id|p_s_curcf
)paren
suffix:semicolon
multiline_comment|/* Get parent FR[n_h] of R[n_h]. */
multiline_comment|/* Current node is the last child of F[n_h]. FR[n_h] != F[n_h]. */
r_if
c_cond
(paren
id|n_position
op_eq
id|B_NR_ITEMS
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_h
op_plus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* Calculate current parent of R[n_h], which is the right neighbor of F[n_h].&n;   Calculate current common parent of R[n_h] and current node. Note that CFR[n_h]&n;   not equal FR[n_path_offset] and CFR[n_h] not equal F[n_h]. */
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_far_parent
c_func
(paren
id|p_s_tb
comma
id|n_h
op_plus
l_int|1
comma
op_amp
id|p_s_curf
comma
op_amp
id|p_s_curcf
comma
id|RIGHT_PARENTS
)paren
)paren
op_ne
id|CARRY_ON
)paren
r_return
id|n_ret_value
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Current node is not the last child of its parent F[n_h]. */
multiline_comment|/*(p_s_curf = p_s_curcf = PATH_OFFSET_PBUFFER(p_s_path, n_path_offset - 1))-&gt;b_count += 2;*/
id|p_s_curf
op_assign
id|p_s_curcf
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_path_offset
op_minus
l_int|1
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|p_s_curf
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|p_s_curf
)paren
suffix:semicolon
id|p_s_tb-&gt;rkey
(braket
id|n_h
)braket
op_assign
id|n_position
suffix:semicolon
)brace
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;FR
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;FR
(braket
id|n_h
)braket
op_assign
id|p_s_curf
suffix:semicolon
multiline_comment|/* New initialization of FR[n_path_offset]. */
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;CFR
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;CFR
(braket
id|n_h
)braket
op_assign
id|p_s_curcf
suffix:semicolon
multiline_comment|/* New initialization of CFR[n_path_offset]. */
id|RFALSE
c_func
(paren
(paren
id|p_s_curf
op_logical_and
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_curf
)paren
)paren
op_logical_or
(paren
id|p_s_curcf
op_logical_and
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_curcf
)paren
)paren
comma
l_string|&quot;PAP-8205: FR (%b) or CFR (%b) is invalid&quot;
comma
id|p_s_curf
comma
id|p_s_curcf
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* it is possible to remove node as result of shiftings to&n;   neighbors even when we insert or paste item. */
DECL|function|can_node_be_removed
r_static
r_inline
r_int
id|can_node_be_removed
(paren
r_int
id|mode
comma
r_int
id|lfree
comma
r_int
id|sfree
comma
r_int
id|rfree
comma
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_struct
id|buffer_head
op_star
id|Sh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
r_int
id|levbytes
op_assign
id|tb-&gt;insert_size
(braket
id|h
)braket
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_struct
id|key
op_star
id|r_key
op_assign
l_int|NULL
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|Sh
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;CFR
(braket
id|h
)braket
)paren
id|r_key
op_assign
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFR
(braket
id|h
)braket
comma
id|tb-&gt;rkey
(braket
id|h
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lfree
op_plus
id|rfree
op_plus
id|sfree
OL
id|MAX_CHILD_SIZE
c_func
(paren
id|Sh
)paren
op_plus
id|levbytes
multiline_comment|/* shifting may merge items which might save space */
op_minus
(paren
(paren
op_logical_neg
id|h
op_logical_and
id|op_is_left_mergeable
(paren
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
id|Sh-&gt;b_size
)paren
)paren
ques
c_cond
id|IH_SIZE
suffix:colon
l_int|0
)paren
op_minus
(paren
(paren
op_logical_neg
id|h
op_logical_and
id|r_key
op_logical_and
id|op_is_left_mergeable
(paren
id|r_key
comma
id|Sh-&gt;b_size
)paren
)paren
ques
c_cond
id|IH_SIZE
suffix:colon
l_int|0
)paren
op_plus
(paren
(paren
id|h
)paren
ques
c_cond
id|KEY_SIZE
suffix:colon
l_int|0
)paren
)paren
(brace
multiline_comment|/* node can not be removed */
r_if
c_cond
(paren
id|sfree
op_ge
id|levbytes
)paren
(brace
multiline_comment|/* new item fits into node S[h] without any shifting */
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
id|tb-&gt;s0num
op_assign
id|B_NR_ITEMS
c_func
(paren
id|Sh
)paren
op_plus
(paren
(paren
id|mode
op_eq
id|M_INSERT
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
)brace
)brace
id|PROC_INFO_INC
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|can_node_be_removed
(braket
id|h
)braket
)paren
suffix:semicolon
r_return
op_logical_neg
id|NO_BALANCING_NEEDED
suffix:semicolon
)brace
multiline_comment|/* Check whether current node S[h] is balanced when increasing its size by&n; * Inserting or Pasting.&n; * Calculate parameters for balancing for current level h.&n; * Parameters:&n; *&t;tb&t;tree_balance structure;&n; *&t;h&t;current level of the node;&n; *&t;inum&t;item number in S[h];&n; *&t;mode&t;i - insert, p - paste;&n; * Returns:&t;1 - schedule occurred; &n; *&t;        0 - balancing for higher levels needed;&n; *&t;       -1 - no balancing for higher levels needed;&n; *&t;       -2 - no disk space.&n; */
multiline_comment|/* ip means Inserting or Pasting */
DECL|function|ip_check_balance
r_static
r_int
id|ip_check_balance
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
r_int
id|levbytes
comma
multiline_comment|/* Number of bytes that must be inserted into (value&n;&t;&t;      is negative if bytes are deleted) buffer which&n;&t;&t;      contains node being balanced.  The mnemonic is&n;&t;&t;      that the attempted change in node space used level&n;&t;&t;      is levbytes bytes. */
id|n_ret_value
suffix:semicolon
r_int
id|lfree
comma
id|sfree
comma
id|rfree
multiline_comment|/* free space in L, S and R */
suffix:semicolon
multiline_comment|/* nver is short for number of vertixes, and lnver is the number if&n;       we shift to the left, rnver is the number if we shift to the&n;       right, and lrnver is the number if we shift in both directions.&n;       The goal is to minimize first the number of vertixes, and second,&n;       the number of vertixes whose contents are changed by shifting,&n;       and third the number of uncached vertixes whose contents are&n;       changed by shifting and must be read from disk.  */
r_int
id|nver
comma
id|lnver
comma
id|rnver
comma
id|lrnver
suffix:semicolon
multiline_comment|/* used at leaf level only, S0 = S[0] is the node being balanced,&n;       sInum [ I = 0,1,2 ] is the number of items that will&n;       remain in node SI after balancing.  S1 and S2 are new&n;       nodes that might be created. */
multiline_comment|/* we perform 8 calls to get_num_ver().  For each call we calculate five parameters.&n;       where 4th parameter is s1bytes and 5th - s2bytes&n;    */
r_int
id|snum012
(braket
l_int|40
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* s0num, s1num, s2num for 8 cases &n;&t;&t;&t;&t;   0,1 - do not shift and do not shift but bottle&n;&t;&t;&t;&t;   2 - shift only whole item to left&n;&t;&t;&t;&t;   3 - shift to left and bottle as much as possible&n;&t;&t;&t;&t;   4,5 - shift to right&t;(whole items and as much as possible&n;&t;&t;&t;&t;   6,7 - shift to both directions (whole items and as much as possible)&n;&t;&t;&t;&t;*/
multiline_comment|/* Sh is the node whose balance is currently being checked */
r_struct
id|buffer_head
op_star
id|Sh
suffix:semicolon
id|Sh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|levbytes
op_assign
id|tb-&gt;insert_size
(braket
id|h
)braket
suffix:semicolon
multiline_comment|/* Calculate balance parameters for creating new root. */
r_if
c_cond
(paren
op_logical_neg
id|Sh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-8210: ip_check_balance: S[0] can not be 0&quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|n_ret_value
op_assign
id|get_empty_nodes
(paren
id|tb
comma
id|h
)paren
)paren
(brace
r_case
id|CARRY_ON
suffix:colon
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
multiline_comment|/* no balancing for higher levels needed */
r_case
id|NO_DISK_SPACE
suffix:colon
r_case
id|REPEAT_SEARCH
suffix:colon
r_return
id|n_ret_value
suffix:semicolon
r_default
suffix:colon
id|reiserfs_panic
c_func
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-8215: ip_check_balance: incorrect return value of get_empty_nodes&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_parents
(paren
id|tb
comma
id|h
)paren
)paren
op_ne
id|CARRY_ON
)paren
multiline_comment|/* get parents of S[h] neighbors. */
r_return
id|n_ret_value
suffix:semicolon
id|sfree
op_assign
id|B_FREE_SPACE
(paren
id|Sh
)paren
suffix:semicolon
multiline_comment|/* get free space of neighbors */
id|rfree
op_assign
id|get_rfree
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|lfree
op_assign
id|get_lfree
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_node_be_removed
(paren
id|vn-&gt;vn_mode
comma
id|lfree
comma
id|sfree
comma
id|rfree
comma
id|tb
comma
id|h
)paren
op_eq
id|NO_BALANCING_NEEDED
)paren
multiline_comment|/* and new item fits into node S[h] without any shifting */
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
id|create_virtual_node
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
multiline_comment|/*&t;&n;&t;determine maximal number of items we can shift to the left neighbor (in tb structure)&n;&t;and the maximal number of bytes that can flow to the left neighbor&n;&t;from the left most liquid item that cannot be shifted from S[0] entirely (returned value)&n;    */
id|check_left
(paren
id|tb
comma
id|h
comma
id|lfree
)paren
suffix:semicolon
multiline_comment|/*&n;      determine maximal number of items we can shift to the right neighbor (in tb structure)&n;      and the maximal number of bytes that can flow to the right neighbor&n;      from the right most liquid item that cannot be shifted from S[0] entirely (returned value)&n;    */
id|check_right
(paren
id|tb
comma
id|h
comma
id|rfree
)paren
suffix:semicolon
multiline_comment|/* all contents of internal node S[h] can be moved into its&n;       neighbors, S[h] will be removed after balancing */
r_if
c_cond
(paren
id|h
op_logical_and
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_plus
id|tb-&gt;lnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
)paren
(brace
r_int
id|to_r
suffix:semicolon
multiline_comment|/* Since we are working on internal nodes, and our internal&n;&t;   nodes have fixed size entries, then we can balance by the&n;&t;   number of items rather than the space they consume.  In this&n;&t;   routine we set the left node equal to the right node,&n;&t;   allowing a difference of less than or equal to 1 child&n;&t;   pointer. */
id|to_r
op_assign
(paren
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|2
op_minus
id|tb-&gt;lnum
(braket
id|h
)braket
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
op_plus
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
op_div
l_int|2
op_minus
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_plus
l_int|1
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
id|vn-&gt;vn_nr_item
op_plus
l_int|1
op_minus
id|to_r
comma
id|to_r
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* this checks balance condition, that any two neighboring nodes can not fit in one node */
id|RFALSE
c_func
(paren
id|h
op_logical_and
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
op_logical_or
id|tb-&gt;rnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
comma
l_string|&quot;vs-8220: tree is not balanced on internal level&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|h
op_logical_and
(paren
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_logical_and
(paren
id|tb-&gt;lbytes
op_eq
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_logical_and
(paren
id|tb-&gt;rbytes
op_eq
op_minus
l_int|1
)paren
)paren
)paren
comma
l_string|&quot;vs-8225: tree is not balanced on leaf level&quot;
)paren
suffix:semicolon
multiline_comment|/* all contents of S[0] can be moved into its neighbors&n;       S[0] will be removed after balancing. */
r_if
c_cond
(paren
op_logical_neg
id|h
op_logical_and
id|is_leaf_removable
(paren
id|tb
)paren
)paren
r_return
id|CARRY_ON
suffix:semicolon
multiline_comment|/* why do we perform this check here rather than earlier??&n;       Answer: we can win 1 node in some cases above. Moreover we&n;       checked it above, when we checked, that S[0] is not removable&n;       in principle */
r_if
c_cond
(paren
id|sfree
op_ge
id|levbytes
)paren
(brace
multiline_comment|/* new item fits into node S[h] without any shifting */
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
id|tb-&gt;s0num
op_assign
id|vn-&gt;vn_nr_item
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
)brace
(brace
r_int
id|lpar
comma
id|rpar
comma
id|nset
comma
id|lset
comma
id|rset
comma
id|lrset
suffix:semicolon
multiline_comment|/* &n;&t; * regular overflowing of the node&n;&t; */
multiline_comment|/* get_num_ver works in 2 modes (FLOW &amp; NO_FLOW) &n;&t;   lpar, rpar - number of items we can shift to left/right neighbor (including splitting item)&n;&t;   nset, lset, rset, lrset - shows, whether flowing items give better packing &n;&t;*/
DECL|macro|FLOW
mdefine_line|#define FLOW 1
DECL|macro|NO_FLOW
mdefine_line|#define NO_FLOW 0&t;/* do not any splitting */
multiline_comment|/* we choose one the following */
DECL|macro|NOTHING_SHIFT_NO_FLOW
mdefine_line|#define NOTHING_SHIFT_NO_FLOW&t;0
DECL|macro|NOTHING_SHIFT_FLOW
mdefine_line|#define NOTHING_SHIFT_FLOW&t;5
DECL|macro|LEFT_SHIFT_NO_FLOW
mdefine_line|#define LEFT_SHIFT_NO_FLOW&t;10
DECL|macro|LEFT_SHIFT_FLOW
mdefine_line|#define LEFT_SHIFT_FLOW&t;&t;15
DECL|macro|RIGHT_SHIFT_NO_FLOW
mdefine_line|#define RIGHT_SHIFT_NO_FLOW&t;20
DECL|macro|RIGHT_SHIFT_FLOW
mdefine_line|#define RIGHT_SHIFT_FLOW&t;25
DECL|macro|LR_SHIFT_NO_FLOW
mdefine_line|#define LR_SHIFT_NO_FLOW&t;30
DECL|macro|LR_SHIFT_FLOW
mdefine_line|#define LR_SHIFT_FLOW&t;&t;35
id|lpar
op_assign
id|tb-&gt;lnum
(braket
id|h
)braket
suffix:semicolon
id|rpar
op_assign
id|tb-&gt;rnum
(braket
id|h
)braket
suffix:semicolon
multiline_comment|/* calculate number of blocks S[h] must be split into when&n;&t;   nothing is shifted to the neighbors,&n;&t;   as well as number of items in each part of the split node (s012 numbers),&n;&t;   and number of bytes (s1bytes) of the shared drop which flow to S1 if any */
id|nset
op_assign
id|NOTHING_SHIFT_NO_FLOW
suffix:semicolon
id|nver
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
l_int|1
comma
id|h
ques
c_cond
id|vn-&gt;vn_nr_item
suffix:colon
l_int|0
comma
op_minus
l_int|1
comma
id|snum012
comma
id|NO_FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
r_int
id|nver1
suffix:semicolon
multiline_comment|/* note, that in this case we try to bottle between S[0] and S1 (S1 - the first new node) */
id|nver1
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
op_minus
l_int|1
comma
id|snum012
op_plus
id|NOTHING_SHIFT_FLOW
comma
id|FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nver
OG
id|nver1
)paren
id|nset
op_assign
id|NOTHING_SHIFT_FLOW
comma
id|nver
op_assign
id|nver1
suffix:semicolon
)brace
multiline_comment|/* calculate number of blocks S[h] must be split into when&n;&t;   l_shift_num first items and l_shift_bytes of the right most&n;&t;   liquid item to be shifted are shifted to the left neighbor,&n;&t;   as well as number of items in each part of the splitted node (s012 numbers),&n;&t;   and number of bytes (s1bytes) of the shared drop which flow to S1 if any&n;&t;*/
id|lset
op_assign
id|LEFT_SHIFT_NO_FLOW
suffix:semicolon
id|lnver
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
id|lpar
op_minus
(paren
(paren
id|h
op_logical_or
id|tb-&gt;lbytes
op_eq
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
comma
op_minus
l_int|1
comma
id|h
ques
c_cond
id|vn-&gt;vn_nr_item
suffix:colon
l_int|0
comma
op_minus
l_int|1
comma
id|snum012
op_plus
id|LEFT_SHIFT_NO_FLOW
comma
id|NO_FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
r_int
id|lnver1
suffix:semicolon
id|lnver1
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
id|lpar
op_minus
(paren
(paren
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
id|tb-&gt;lbytes
comma
l_int|0
comma
op_minus
l_int|1
comma
id|snum012
op_plus
id|LEFT_SHIFT_FLOW
comma
id|FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lnver
OG
id|lnver1
)paren
id|lset
op_assign
id|LEFT_SHIFT_FLOW
comma
id|lnver
op_assign
id|lnver1
suffix:semicolon
)brace
multiline_comment|/* calculate number of blocks S[h] must be split into when&n;&t;   r_shift_num first items and r_shift_bytes of the left most&n;&t;   liquid item to be shifted are shifted to the right neighbor,&n;&t;   as well as number of items in each part of the splitted node (s012 numbers),&n;&t;   and number of bytes (s1bytes) of the shared drop which flow to S1 if any&n;&t;*/
id|rset
op_assign
id|RIGHT_SHIFT_NO_FLOW
suffix:semicolon
id|rnver
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
l_int|1
comma
id|h
ques
c_cond
(paren
id|vn-&gt;vn_nr_item
op_minus
id|rpar
)paren
suffix:colon
(paren
id|rpar
op_minus
(paren
(paren
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
comma
op_minus
l_int|1
comma
id|snum012
op_plus
id|RIGHT_SHIFT_NO_FLOW
comma
id|NO_FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
r_int
id|rnver1
suffix:semicolon
id|rnver1
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
l_int|1
comma
(paren
id|rpar
op_minus
(paren
(paren
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
comma
id|tb-&gt;rbytes
comma
id|snum012
op_plus
id|RIGHT_SHIFT_FLOW
comma
id|FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rnver
OG
id|rnver1
)paren
id|rset
op_assign
id|RIGHT_SHIFT_FLOW
comma
id|rnver
op_assign
id|rnver1
suffix:semicolon
)brace
multiline_comment|/* calculate number of blocks S[h] must be split into when&n;&t;   items are shifted in both directions,&n;&t;   as well as number of items in each part of the splitted node (s012 numbers),&n;&t;   and number of bytes (s1bytes) of the shared drop which flow to S1 if any&n;&t;*/
id|lrset
op_assign
id|LR_SHIFT_NO_FLOW
suffix:semicolon
id|lrnver
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
id|lpar
op_minus
(paren
(paren
id|h
op_logical_or
id|tb-&gt;lbytes
op_eq
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
comma
op_minus
l_int|1
comma
id|h
ques
c_cond
(paren
id|vn-&gt;vn_nr_item
op_minus
id|rpar
)paren
suffix:colon
(paren
id|rpar
op_minus
(paren
(paren
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
comma
op_minus
l_int|1
comma
id|snum012
op_plus
id|LR_SHIFT_NO_FLOW
comma
id|NO_FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|h
)paren
(brace
r_int
id|lrnver1
suffix:semicolon
id|lrnver1
op_assign
id|get_num_ver
(paren
id|vn-&gt;vn_mode
comma
id|tb
comma
id|h
comma
id|lpar
op_minus
(paren
(paren
id|tb-&gt;lbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
id|tb-&gt;lbytes
comma
(paren
id|rpar
op_minus
(paren
(paren
id|tb-&gt;rbytes
op_ne
op_minus
l_int|1
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
comma
id|tb-&gt;rbytes
comma
id|snum012
op_plus
id|LR_SHIFT_FLOW
comma
id|FLOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lrnver
OG
id|lrnver1
)paren
id|lrset
op_assign
id|LR_SHIFT_FLOW
comma
id|lrnver
op_assign
id|lrnver1
suffix:semicolon
)brace
multiline_comment|/* Our general shifting strategy is:&n;&t;   1) to minimized number of new nodes;&n;&t;   2) to minimized number of neighbors involved in shifting;&n;&t;   3) to minimized number of disk reads; */
multiline_comment|/* we can win TWO or ONE nodes by shifting in both directions */
r_if
c_cond
(paren
id|lrnver
OL
id|lnver
op_logical_and
id|lrnver
OL
id|rnver
)paren
(brace
id|RFALSE
c_func
(paren
id|h
op_logical_and
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_ne
l_int|1
op_logical_or
id|tb-&gt;rnum
(braket
id|h
)braket
op_ne
l_int|1
op_logical_or
id|lrnver
op_ne
l_int|1
op_logical_or
id|rnver
op_ne
l_int|2
op_logical_or
id|lnver
op_ne
l_int|2
op_logical_or
id|h
op_ne
l_int|1
)paren
comma
l_string|&quot;vs-8230: bad h&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lrset
op_eq
id|LR_SHIFT_FLOW
)paren
id|set_parameters
(paren
id|tb
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
comma
id|tb-&gt;rnum
(braket
id|h
)braket
comma
id|lrnver
comma
id|snum012
op_plus
id|lrset
comma
id|tb-&gt;lbytes
comma
id|tb-&gt;rbytes
)paren
suffix:semicolon
r_else
id|set_parameters
(paren
id|tb
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
op_minus
(paren
(paren
id|tb-&gt;lbytes
op_eq
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
comma
id|tb-&gt;rnum
(braket
id|h
)braket
op_minus
(paren
(paren
id|tb-&gt;rbytes
op_eq
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
comma
id|lrnver
comma
id|snum012
op_plus
id|lrset
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* if shifting doesn&squot;t lead to better packing then don&squot;t shift */
r_if
c_cond
(paren
id|nver
op_eq
id|lrnver
)paren
(brace
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
id|nver
comma
id|snum012
op_plus
id|nset
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* now we know that for better packing shifting in only one&n;&t;   direction either to the left or to the right is required */
multiline_comment|/*  if shifting to the left is better than shifting to the right */
r_if
c_cond
(paren
id|lnver
OL
id|rnver
)paren
(brace
id|SET_PAR_SHIFT_LEFT
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* if shifting to the right is better than shifting to the left */
r_if
c_cond
(paren
id|lnver
OG
id|rnver
)paren
(brace
id|SET_PAR_SHIFT_RIGHT
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* now shifting in either direction gives the same number&n;&t;   of nodes and we can make use of the cached neighbors */
r_if
c_cond
(paren
id|is_left_neighbor_in_cache
(paren
id|tb
comma
id|h
)paren
)paren
(brace
id|SET_PAR_SHIFT_LEFT
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* shift to the right independently on whether the right neighbor in cache or not */
id|SET_PAR_SHIFT_RIGHT
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
)brace
multiline_comment|/* Check whether current node S[h] is balanced when Decreasing its size by&n; * Deleting or Cutting for INTERNAL node of S+tree.&n; * Calculate parameters for balancing for current level h.&n; * Parameters:&n; *&t;tb&t;tree_balance structure;&n; *&t;h&t;current level of the node;&n; *&t;inum&t;item number in S[h];&n; *&t;mode&t;i - insert, p - paste;&n; * Returns:&t;1 - schedule occurred; &n; *&t;        0 - balancing for higher levels needed;&n; *&t;       -1 - no balancing for higher levels needed;&n; *&t;       -2 - no disk space.&n; *&n; * Note: Items of internal nodes have fixed size, so the balance condition for&n; * the internal part of S+tree is as for the B-trees.&n; */
DECL|function|dc_check_balance_internal
r_static
r_int
id|dc_check_balance_internal
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
multiline_comment|/* Sh is the node whose balance is currently being checked,&n;     and Fh is its father.  */
r_struct
id|buffer_head
op_star
id|Sh
comma
op_star
id|Fh
suffix:semicolon
r_int
id|maxsize
comma
id|n_ret_value
suffix:semicolon
r_int
id|lfree
comma
id|rfree
multiline_comment|/* free space in L and R */
suffix:semicolon
id|Sh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|Fh
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|maxsize
op_assign
id|MAX_CHILD_SIZE
c_func
(paren
id|Sh
)paren
suffix:semicolon
multiline_comment|/*   using tb-&gt;insert_size[h], which is negative in this case, create_virtual_node calculates: */
multiline_comment|/*   new_nr_item = number of items node would have if operation is */
multiline_comment|/* &t;performed without balancing (new_nr_item); */
id|create_virtual_node
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Fh
)paren
(brace
multiline_comment|/* S[h] is the root. */
r_if
c_cond
(paren
id|vn-&gt;vn_nr_item
OG
l_int|0
)paren
(brace
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
multiline_comment|/* no balancing for higher levels needed */
)brace
multiline_comment|/* new_nr_item == 0.&n;       * Current root will be deleted resulting in&n;       * decrementing the tree height. */
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_parents
c_func
(paren
id|tb
comma
id|h
)paren
)paren
op_ne
id|CARRY_ON
)paren
r_return
id|n_ret_value
suffix:semicolon
multiline_comment|/* get free space of neighbors */
id|rfree
op_assign
id|get_rfree
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|lfree
op_assign
id|get_lfree
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
multiline_comment|/* determine maximal number of items we can fit into neighbors */
id|check_left
(paren
id|tb
comma
id|h
comma
id|lfree
)paren
suffix:semicolon
id|check_right
(paren
id|tb
comma
id|h
comma
id|rfree
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vn-&gt;vn_nr_item
op_ge
id|MIN_NR_KEY
c_func
(paren
id|Sh
)paren
)paren
(brace
multiline_comment|/* Balance condition for the internal node is valid.&n;       * In this case we balance only if it leads to better packing. */
r_if
c_cond
(paren
id|vn-&gt;vn_nr_item
op_eq
id|MIN_NR_KEY
c_func
(paren
id|Sh
)paren
)paren
(brace
multiline_comment|/* Here we join S[h] with one of its neighbors,&n;&t;   * which is impossible with greater values of new_nr_item. */
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
(brace
multiline_comment|/* All contents of S[h] can be moved to L[h]. */
r_int
id|n
suffix:semicolon
r_int
id|order_L
suffix:semicolon
id|order_L
op_assign
(paren
(paren
id|n
op_assign
id|PATH_H_B_ITEM_ORDER
c_func
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;FL
(braket
id|h
)braket
)paren
suffix:colon
id|n
op_minus
l_int|1
suffix:semicolon
id|n
op_assign
id|dc_size
c_func
(paren
id|B_N_CHILD
c_func
(paren
id|tb-&gt;FL
(braket
id|h
)braket
comma
id|order_L
)paren
)paren
op_div
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
op_minus
id|n
op_minus
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
(brace
multiline_comment|/* All contents of S[h] can be moved to R[h]. */
r_int
id|n
suffix:semicolon
r_int
id|order_R
suffix:semicolon
id|order_R
op_assign
(paren
(paren
id|n
op_assign
id|PATH_H_B_ITEM_ORDER
c_func
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
op_eq
id|B_NR_ITEMS
c_func
(paren
id|Fh
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|n
op_plus
l_int|1
suffix:semicolon
id|n
op_assign
id|dc_size
c_func
(paren
id|B_N_CHILD
c_func
(paren
id|tb-&gt;FR
(braket
id|h
)braket
comma
id|order_R
)paren
)paren
op_div
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
id|n
op_minus
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_plus
id|tb-&gt;lnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
(brace
multiline_comment|/* All contents of S[h] can be moved to the neighbors (L[h] &amp; R[h]). */
r_int
id|to_r
suffix:semicolon
id|to_r
op_assign
(paren
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|2
op_minus
id|tb-&gt;lnum
(braket
id|h
)braket
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
op_plus
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
op_div
l_int|2
op_minus
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_plus
l_int|1
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
id|vn-&gt;vn_nr_item
op_plus
l_int|1
op_minus
id|to_r
comma
id|to_r
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* Balancing does not lead to better packing. */
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
)brace
multiline_comment|/* Current node contain insufficient number of items. Balancing is required. */
multiline_comment|/* Check whether we can merge S[h] with left neighbor. */
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
r_if
c_cond
(paren
id|is_left_neighbor_in_cache
(paren
id|tb
comma
id|h
)paren
op_logical_or
id|tb-&gt;rnum
(braket
id|h
)braket
OL
id|vn-&gt;vn_nr_item
op_plus
l_int|1
op_logical_or
op_logical_neg
id|tb-&gt;FR
(braket
id|h
)braket
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
id|order_L
suffix:semicolon
id|order_L
op_assign
(paren
(paren
id|n
op_assign
id|PATH_H_B_ITEM_ORDER
c_func
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
op_eq
l_int|0
)paren
ques
c_cond
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;FL
(braket
id|h
)braket
)paren
suffix:colon
id|n
op_minus
l_int|1
suffix:semicolon
id|n
op_assign
id|dc_size
c_func
(paren
id|B_N_CHILD
c_func
(paren
id|tb-&gt;FL
(braket
id|h
)braket
comma
id|order_L
)paren
)paren
op_div
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
op_minus
id|n
op_minus
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* Check whether we can merge S[h] with right neighbor. */
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
id|order_R
suffix:semicolon
id|order_R
op_assign
(paren
(paren
id|n
op_assign
id|PATH_H_B_ITEM_ORDER
c_func
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
op_eq
id|B_NR_ITEMS
c_func
(paren
id|Fh
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|n
op_plus
l_int|1
)paren
suffix:semicolon
id|n
op_assign
id|dc_size
c_func
(paren
id|B_N_CHILD
c_func
(paren
id|tb-&gt;FR
(braket
id|h
)braket
comma
id|order_R
)paren
)paren
op_div
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
id|n
op_minus
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* All contents of S[h] can be moved to the neighbors (L[h] &amp; R[h]). */
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_plus
id|tb-&gt;lnum
(braket
id|h
)braket
op_ge
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
(brace
r_int
id|to_r
suffix:semicolon
id|to_r
op_assign
(paren
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_lshift
l_int|1
)paren
op_plus
l_int|2
op_minus
id|tb-&gt;lnum
(braket
id|h
)braket
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
op_plus
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
op_div
l_int|2
op_minus
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_plus
l_int|1
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
id|vn-&gt;vn_nr_item
op_plus
l_int|1
op_minus
id|to_r
comma
id|to_r
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* For internal nodes try to borrow item from a neighbor */
id|RFALSE
c_func
(paren
op_logical_neg
id|tb-&gt;FL
(braket
id|h
)braket
op_logical_and
op_logical_neg
id|tb-&gt;FR
(braket
id|h
)braket
comma
l_string|&quot;vs-8235: trying to borrow for root&quot;
)paren
suffix:semicolon
multiline_comment|/* Borrow one or two items from caching neighbor */
r_if
c_cond
(paren
id|is_left_neighbor_in_cache
(paren
id|tb
comma
id|h
)paren
op_logical_or
op_logical_neg
id|tb-&gt;FR
(braket
id|h
)braket
)paren
(brace
r_int
id|from_l
suffix:semicolon
id|from_l
op_assign
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_plus
l_int|1
op_minus
id|tb-&gt;lnum
(braket
id|h
)braket
op_plus
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
op_div
l_int|2
op_minus
(paren
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
op_minus
id|from_l
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
(paren
(paren
id|MAX_NR_KEY
c_func
(paren
id|Sh
)paren
op_plus
l_int|1
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
op_plus
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
op_div
l_int|2
op_minus
(paren
id|vn-&gt;vn_nr_item
op_plus
l_int|1
)paren
)paren
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* Check whether current node S[h] is balanced when Decreasing its size by&n; * Deleting or Truncating for LEAF node of S+tree.&n; * Calculate parameters for balancing for current level h.&n; * Parameters:&n; *&t;tb&t;tree_balance structure;&n; *&t;h&t;current level of the node;&n; *&t;inum&t;item number in S[h];&n; *&t;mode&t;i - insert, p - paste;&n; * Returns:&t;1 - schedule occurred; &n; *&t;        0 - balancing for higher levels needed;&n; *&t;       -1 - no balancing for higher levels needed;&n; *&t;       -2 - no disk space.&n; */
DECL|function|dc_check_balance_leaf
r_static
r_int
id|dc_check_balance_leaf
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
r_struct
id|virtual_node
op_star
id|vn
op_assign
id|tb-&gt;tb_vn
suffix:semicolon
multiline_comment|/* Number of bytes that must be deleted from&n;     (value is negative if bytes are deleted) buffer which&n;     contains node being balanced.  The mnemonic is that the&n;     attempted change in node space used level is levbytes bytes. */
r_int
id|levbytes
suffix:semicolon
multiline_comment|/* the maximal item size */
r_int
id|maxsize
comma
id|n_ret_value
suffix:semicolon
multiline_comment|/* S0 is the node whose balance is currently being checked,&n;     and F0 is its father.  */
r_struct
id|buffer_head
op_star
id|S0
comma
op_star
id|F0
suffix:semicolon
r_int
id|lfree
comma
id|rfree
multiline_comment|/* free space in L and R */
suffix:semicolon
id|S0
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|F0
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|levbytes
op_assign
id|tb-&gt;insert_size
(braket
id|h
)braket
suffix:semicolon
id|maxsize
op_assign
id|MAX_CHILD_SIZE
c_func
(paren
id|S0
)paren
suffix:semicolon
multiline_comment|/* maximal possible size of an item */
r_if
c_cond
(paren
op_logical_neg
id|F0
)paren
(brace
multiline_comment|/* S[0] is the root now. */
id|RFALSE
c_func
(paren
op_minus
id|levbytes
op_ge
id|maxsize
op_minus
id|B_FREE_SPACE
(paren
id|S0
)paren
comma
l_string|&quot;vs-8240: attempt to create empty buffer tree&quot;
)paren
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_parents
c_func
(paren
id|tb
comma
id|h
)paren
)paren
op_ne
id|CARRY_ON
)paren
r_return
id|n_ret_value
suffix:semicolon
multiline_comment|/* get free space of neighbors */
id|rfree
op_assign
id|get_rfree
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|lfree
op_assign
id|get_lfree
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|create_virtual_node
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
multiline_comment|/* if 3 leaves can be merge to one, set parameters and return */
r_if
c_cond
(paren
id|are_leaves_removable
(paren
id|tb
comma
id|lfree
comma
id|rfree
)paren
)paren
r_return
id|CARRY_ON
suffix:semicolon
multiline_comment|/* determine maximal number of items we can shift to the left/right  neighbor&n;     and the maximal number of bytes that can flow to the left/right neighbor&n;     from the left/right most liquid item that cannot be shifted from S[0] entirely&n;     */
id|check_left
(paren
id|tb
comma
id|h
comma
id|lfree
)paren
suffix:semicolon
id|check_right
(paren
id|tb
comma
id|h
comma
id|rfree
)paren
suffix:semicolon
multiline_comment|/* check whether we can merge S with left neighbor. */
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
l_int|0
)braket
op_ge
id|vn-&gt;vn_nr_item
op_logical_and
id|tb-&gt;lbytes
op_eq
op_minus
l_int|1
)paren
r_if
c_cond
(paren
id|is_left_neighbor_in_cache
(paren
id|tb
comma
id|h
)paren
op_logical_or
(paren
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_minus
(paren
(paren
id|tb-&gt;rbytes
op_eq
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
OL
id|vn-&gt;vn_nr_item
)paren
op_logical_or
multiline_comment|/* S can not be merged with R */
op_logical_neg
id|tb-&gt;FR
(braket
id|h
)braket
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|tb-&gt;FL
(braket
id|h
)braket
comma
l_string|&quot;vs-8245: dc_check_balance_leaf: FL[h] must exist&quot;
)paren
suffix:semicolon
multiline_comment|/* set parameter to merge S[0] with its left neighbor */
id|set_parameters
(paren
id|tb
comma
id|h
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* check whether we can merge S[0] with right neighbor. */
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
l_int|0
)braket
op_ge
id|vn-&gt;vn_nr_item
op_logical_and
id|tb-&gt;rbytes
op_eq
op_minus
l_int|1
)paren
(brace
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* All contents of S[0] can be moved to the neighbors (L[0] &amp; R[0]). Set parameters and return */
r_if
c_cond
(paren
id|is_leaf_removable
(paren
id|tb
)paren
)paren
r_return
id|CARRY_ON
suffix:semicolon
multiline_comment|/* Balancing is not required. */
id|tb-&gt;s0num
op_assign
id|vn-&gt;vn_nr_item
suffix:semicolon
id|set_parameters
(paren
id|tb
comma
id|h
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|NULL
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|NO_BALANCING_NEEDED
suffix:semicolon
)brace
multiline_comment|/* Check whether current node S[h] is balanced when Decreasing its size by&n; * Deleting or Cutting.&n; * Calculate parameters for balancing for current level h.&n; * Parameters:&n; *&t;tb&t;tree_balance structure;&n; *&t;h&t;current level of the node;&n; *&t;inum&t;item number in S[h];&n; *&t;mode&t;d - delete, c - cut.&n; * Returns:&t;1 - schedule occurred; &n; *&t;        0 - balancing for higher levels needed;&n; *&t;       -1 - no balancing for higher levels needed;&n; *&t;       -2 - no disk space.&n; */
DECL|function|dc_check_balance
r_static
r_int
id|dc_check_balance
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
(paren
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
comma
l_string|&quot;vs-8250: S is not initialized&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
r_return
id|dc_check_balance_internal
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
r_else
r_return
id|dc_check_balance_leaf
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
)brace
multiline_comment|/* Check whether current node S[h] is balanced.&n; * Calculate parameters for balancing for current level h.&n; * Parameters:&n; *&n; *&t;tb&t;tree_balance structure:&n; *&n; *              tb is a large structure that must be read about in the header file&n; *              at the same time as this procedure if the reader is to successfully&n; *              understand this procedure&n; *&n; *&t;h&t;current level of the node;&n; *&t;inum&t;item number in S[h];&n; *&t;mode&t;i - insert, p - paste, d - delete, c - cut.&n; * Returns:&t;1 - schedule occurred; &n; *&t;        0 - balancing for higher levels needed;&n; *&t;       -1 - no balancing for higher levels needed;&n; *&t;       -2 - no disk space.&n; */
DECL|function|check_balance
r_static
r_int
id|check_balance
(paren
r_int
id|mode
comma
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|inum
comma
r_int
id|pos_in_item
comma
r_struct
id|item_head
op_star
id|ins_ih
comma
r_const
r_void
op_star
id|data
)paren
(brace
r_struct
id|virtual_node
op_star
id|vn
suffix:semicolon
id|vn
op_assign
id|tb-&gt;tb_vn
op_assign
(paren
r_struct
id|virtual_node
op_star
)paren
(paren
id|tb-&gt;vn_buf
)paren
suffix:semicolon
id|vn-&gt;vn_free_ptr
op_assign
(paren
r_char
op_star
)paren
(paren
id|tb-&gt;tb_vn
op_plus
l_int|1
)paren
suffix:semicolon
id|vn-&gt;vn_mode
op_assign
id|mode
suffix:semicolon
id|vn-&gt;vn_affected_item_num
op_assign
id|inum
suffix:semicolon
id|vn-&gt;vn_pos_in_item
op_assign
id|pos_in_item
suffix:semicolon
id|vn-&gt;vn_ins_ih
op_assign
id|ins_ih
suffix:semicolon
id|vn-&gt;vn_data
op_assign
id|data
suffix:semicolon
id|RFALSE
c_func
(paren
id|mode
op_eq
id|M_INSERT
op_logical_and
op_logical_neg
id|vn-&gt;vn_ins_ih
comma
l_string|&quot;vs-8255: ins_ih can not be 0 in insert mode&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;insert_size
(braket
id|h
)braket
OG
l_int|0
)paren
multiline_comment|/* Calculate balance parameters when size of node is increasing. */
r_return
id|ip_check_balance
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
multiline_comment|/* Calculate balance parameters when  size of node is decreasing. */
r_return
id|dc_check_balance
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
)brace
multiline_comment|/* Check whether parent at the path is the really parent of the current node.*/
DECL|function|get_direct_parent
r_static
r_int
id|get_direct_parent
c_func
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_int
id|n_h
)paren
(brace
r_struct
id|buffer_head
op_star
id|p_s_bh
suffix:semicolon
r_struct
id|path
op_star
id|p_s_path
op_assign
id|p_s_tb-&gt;tb_path
suffix:semicolon
r_int
id|n_position
comma
id|n_path_offset
op_assign
id|PATH_H_PATH_OFFSET
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_h
)paren
suffix:semicolon
multiline_comment|/* We are in the root or in the new root. */
r_if
c_cond
(paren
id|n_path_offset
op_le
id|FIRST_PATH_ELEMENT_OFFSET
)paren
(brace
id|RFALSE
c_func
(paren
id|n_path_offset
OL
id|FIRST_PATH_ELEMENT_OFFSET
op_minus
l_int|1
comma
l_string|&quot;PAP-8260: illegal offset in the path&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|FIRST_PATH_ELEMENT_OFFSET
)paren
op_member_access_from_pointer
id|b_blocknr
op_eq
id|SB_ROOT_BLOCK
(paren
id|p_s_tb-&gt;tb_sb
)paren
)paren
(brace
multiline_comment|/* Root is not changed. */
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_path_offset
op_minus
l_int|1
)paren
op_assign
l_int|NULL
suffix:semicolon
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_path
comma
id|n_path_offset
op_minus
l_int|1
)paren
op_assign
l_int|0
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
r_return
id|REPEAT_SEARCH
suffix:semicolon
multiline_comment|/* Root is changed and we must recalculate the path. */
)brace
r_if
c_cond
(paren
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|p_s_bh
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_path_offset
op_minus
l_int|1
)paren
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
multiline_comment|/* Parent in the path is not in the tree. */
r_if
c_cond
(paren
(paren
id|n_position
op_assign
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_path
comma
id|n_path_offset
op_minus
l_int|1
)paren
)paren
OG
id|B_NR_ITEMS
c_func
(paren
id|p_s_bh
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
r_if
c_cond
(paren
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_bh
comma
id|n_position
)paren
op_ne
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_path
comma
id|n_path_offset
)paren
op_member_access_from_pointer
id|b_blocknr
)paren
multiline_comment|/* Parent in the path is not parent of the current node in the tree. */
r_return
id|REPEAT_SEARCH
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|p_s_bh
)paren
)paren
(brace
id|__wait_on_buffer
c_func
(paren
id|p_s_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
r_return
id|CARRY_ON
suffix:semicolon
multiline_comment|/* Parent in the path is unlocked and really parent of the current node.  */
)brace
multiline_comment|/* Using lnum[n_h] and rnum[n_h] we should determine what neighbors&n; * of S[n_h] we&n; * need in order to balance S[n_h], and get them if necessary.&n; * Returns:&t;SCHEDULE_OCCURRED - schedule occurred while the function worked;&n; *&t;        CARRY_ON - schedule didn&squot;t occur while the function worked;&n; */
DECL|function|get_neighbors
r_static
r_int
id|get_neighbors
c_func
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_int
id|n_h
)paren
(brace
r_int
id|n_child_position
comma
id|n_path_offset
op_assign
id|PATH_H_PATH_OFFSET
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_h
op_plus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|n_son_number
suffix:semicolon
r_struct
id|super_block
op_star
id|p_s_sb
op_assign
id|p_s_tb-&gt;tb_sb
suffix:semicolon
r_struct
id|buffer_head
op_star
id|p_s_bh
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|get_neighbors
(braket
id|n_h
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p_s_tb-&gt;lnum
(braket
id|n_h
)braket
)paren
(brace
multiline_comment|/* We need left neighbor to balance S[n_h]. */
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|need_l_neighbor
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_bh
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_path_offset
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|p_s_bh
op_eq
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
op_logical_and
op_logical_neg
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_path_offset
)paren
comma
l_string|&quot;PAP-8270: invalid position in the parent&quot;
)paren
suffix:semicolon
id|n_child_position
op_assign
(paren
id|p_s_bh
op_eq
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
ques
c_cond
id|p_s_tb-&gt;lkey
(braket
id|n_h
)braket
suffix:colon
id|B_NR_ITEMS
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|n_son_number
op_assign
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
comma
id|n_child_position
)paren
suffix:semicolon
id|p_s_bh
op_assign
id|reiserfs_bread
c_func
(paren
id|p_s_sb
comma
id|n_son_number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_s_bh
)paren
r_return
id|IO_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
(brace
id|decrement_bcount
c_func
(paren
id|p_s_bh
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|get_neighbors_restart
(braket
id|n_h
)braket
)paren
suffix:semicolon
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
op_logical_or
id|n_child_position
OG
id|B_NR_ITEMS
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
)paren
op_logical_or
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_tb-&gt;FL
(braket
id|n_h
)braket
comma
id|n_child_position
)paren
op_ne
id|p_s_bh-&gt;b_blocknr
comma
l_string|&quot;PAP-8275: invalid parent&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|B_IS_IN_TREE
c_func
(paren
id|p_s_bh
)paren
comma
l_string|&quot;PAP-8280: invalid child&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|n_h
op_logical_and
id|B_FREE_SPACE
(paren
id|p_s_bh
)paren
op_ne
id|MAX_CHILD_SIZE
(paren
id|p_s_bh
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|p_s_tb-&gt;FL
(braket
l_int|0
)braket
comma
id|n_child_position
)paren
)paren
comma
l_string|&quot;PAP-8290: invalid child size of left neighbor&quot;
)paren
suffix:semicolon
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;L
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;L
(braket
id|n_h
)braket
op_assign
id|p_s_bh
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p_s_tb-&gt;rnum
(braket
id|n_h
)braket
)paren
(brace
multiline_comment|/* We need right neighbor to balance S[n_path_offset]. */
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|need_r_neighbor
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_bh
op_assign
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_path_offset
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|p_s_bh
op_eq
id|p_s_tb-&gt;FR
(braket
id|n_h
)braket
op_logical_and
id|PATH_OFFSET_POSITION
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_path_offset
)paren
op_ge
id|B_NR_ITEMS
c_func
(paren
id|p_s_bh
)paren
comma
l_string|&quot;PAP-8295: invalid position in the parent&quot;
)paren
suffix:semicolon
id|n_child_position
op_assign
(paren
id|p_s_bh
op_eq
id|p_s_tb-&gt;FR
(braket
id|n_h
)braket
)paren
ques
c_cond
id|p_s_tb-&gt;rkey
(braket
id|n_h
)braket
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|n_son_number
op_assign
id|B_N_CHILD_NUM
c_func
(paren
id|p_s_tb-&gt;FR
(braket
id|n_h
)braket
comma
id|n_child_position
)paren
suffix:semicolon
id|p_s_bh
op_assign
id|reiserfs_bread
c_func
(paren
id|p_s_sb
comma
id|n_son_number
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p_s_bh
)paren
r_return
id|IO_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
(brace
id|decrement_bcount
c_func
(paren
id|p_s_bh
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|p_s_sb
comma
id|get_neighbors_restart
(braket
id|n_h
)braket
)paren
suffix:semicolon
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
id|decrement_bcount
c_func
(paren
id|p_s_tb-&gt;R
(braket
id|n_h
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;R
(braket
id|n_h
)braket
op_assign
id|p_s_bh
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|n_h
op_logical_and
id|B_FREE_SPACE
(paren
id|p_s_bh
)paren
op_ne
id|MAX_CHILD_SIZE
(paren
id|p_s_bh
)paren
op_minus
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|p_s_tb-&gt;FR
(braket
l_int|0
)braket
comma
id|n_child_position
)paren
)paren
comma
l_string|&quot;PAP-8300: invalid child size of right neighbor (%d != %d - %d)&quot;
comma
id|B_FREE_SPACE
(paren
id|p_s_bh
)paren
comma
id|MAX_CHILD_SIZE
(paren
id|p_s_bh
)paren
comma
id|dc_size
c_func
(paren
id|B_N_CHILD
(paren
id|p_s_tb-&gt;FR
(braket
l_int|0
)braket
comma
id|n_child_position
)paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|CARRY_ON
suffix:semicolon
)brace
DECL|function|reiserfs_kmalloc
r_void
op_star
id|reiserfs_kmalloc
(paren
r_int
id|size
comma
r_int
id|flags
comma
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_void
op_star
id|vp
suffix:semicolon
r_static
r_int
id|malloced
suffix:semicolon
id|vp
op_assign
id|kmalloc
(paren
id|size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
)paren
(brace
id|s-&gt;u.reiserfs_sb.s_kmallocs
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;u.reiserfs_sb.s_kmallocs
OG
id|malloced
op_plus
l_int|200000
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-8301: reiserfs_kmalloc: allocated memory %d&bslash;n&quot;
comma
id|s-&gt;u.reiserfs_sb.s_kmallocs
)paren
suffix:semicolon
id|malloced
op_assign
id|s-&gt;u.reiserfs_sb.s_kmallocs
suffix:semicolon
)brace
)brace
multiline_comment|/*printk (&quot;malloc : size %d, allocated %d&bslash;n&quot;, size, s-&gt;u.reiserfs_sb.s_kmallocs);*/
r_return
id|vp
suffix:semicolon
)brace
DECL|function|reiserfs_kfree
r_void
id|reiserfs_kfree
(paren
r_const
r_void
op_star
id|vp
comma
r_int
id|size
comma
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|kfree
(paren
id|vp
)paren
suffix:semicolon
id|s-&gt;u.reiserfs_sb.s_kmallocs
op_sub_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;u.reiserfs_sb.s_kmallocs
OL
l_int|0
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-8302: reiserfs_kfree: allocated memory %d&bslash;n&quot;
comma
id|s-&gt;u.reiserfs_sb.s_kmallocs
)paren
suffix:semicolon
)brace
DECL|function|get_virtual_node_size
r_static
r_int
id|get_virtual_node_size
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
singleline_comment|//  int size = sizeof (struct virtual_item); /* for new item in case of insert */
singleline_comment|//  int i, nr_items;
singleline_comment|//  struct item_head * ih;
singleline_comment|// this is enough for _ALL_ currently possible cases. In 4 k block
singleline_comment|// one may put &lt; 170 empty items. Each virtual item eats 12
singleline_comment|// byte. The biggest direntry item may have &lt; 256 entries. Each
singleline_comment|// entry would eat 2 byte of virtual node space
r_return
id|sb-&gt;s_blocksize
suffix:semicolon
macro_line|#if 0
id|size
op_assign
r_sizeof
(paren
r_struct
id|virtual_node
)paren
op_plus
r_sizeof
(paren
r_struct
id|virtual_item
)paren
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|nr_items
op_assign
id|B_NR_ITEMS
(paren
id|bh
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_items
suffix:semicolon
id|i
op_increment
comma
id|ih
op_increment
)paren
(brace
multiline_comment|/* each item occupies some space in virtual node */
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|virtual_item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
multiline_comment|/* each entry and new one occupeis 2 byte in the virtual node */
id|size
op_add_assign
(paren
id|ih_entry_count
c_func
(paren
id|ih
)paren
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
)brace
multiline_comment|/* 1 bit for each bitmap block to note whether bitmap block was&n;     dirtied in the operation */
multiline_comment|/* size += (SB_BMAP_NR (sb) * 2 / 8 + 4);*/
r_return
id|size
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* maybe we should fail balancing we are going to perform when kmalloc&n;   fails several times. But now it will loop until kmalloc gets&n;   required memory */
DECL|function|get_mem_for_virtual_node
r_static
r_int
id|get_mem_for_virtual_node
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_int
id|check_fs
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
id|size
op_assign
id|get_virtual_node_size
(paren
id|tb-&gt;tb_sb
comma
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|tb-&gt;vn_buf_size
)paren
(brace
multiline_comment|/* we have to allocate more memory for virtual node */
r_if
c_cond
(paren
id|tb-&gt;vn_buf
)paren
(brace
multiline_comment|/* free memory allocated before */
id|reiserfs_kfree
(paren
id|tb-&gt;vn_buf
comma
id|tb-&gt;vn_buf_size
comma
id|tb-&gt;tb_sb
)paren
suffix:semicolon
multiline_comment|/* this is not needed if kfree is atomic */
id|check_fs
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* virtual node requires now more memory */
id|tb-&gt;vn_buf_size
op_assign
id|size
suffix:semicolon
multiline_comment|/* get memory for virtual item */
id|buf
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|size
comma
id|GFP_ATOMIC
comma
id|tb-&gt;tb_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
multiline_comment|/* getting memory with GFP_KERNEL priority may involve&n;               balancing now (due to indirect_to_direct conversion on&n;               dcache shrinking). So, release path and collected&n;               resourses here */
id|free_buffers_in_tb
(paren
id|tb
)paren
suffix:semicolon
id|buf
op_assign
id|reiserfs_kmalloc
c_func
(paren
id|size
comma
id|GFP_NOFS
comma
id|tb-&gt;tb_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
(paren
l_string|&quot;vs-8345: get_mem_for_virtual_node: &quot;
l_string|&quot;kmalloc failed. reiserfs kmalloced %d bytes&bslash;n&quot;
comma
id|tb-&gt;tb_sb-&gt;u.reiserfs_sb.s_kmallocs
)paren
suffix:semicolon
macro_line|#endif
id|tb-&gt;vn_buf_size
op_assign
l_int|0
suffix:semicolon
)brace
id|tb-&gt;vn_buf
op_assign
id|buf
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
id|tb-&gt;vn_buf
op_assign
id|buf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_fs
op_logical_and
id|FILESYSTEM_CHANGED_TB
(paren
id|tb
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
DECL|function|tb_buffer_sanity_check
r_static
r_void
id|tb_buffer_sanity_check
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|p_s_bh
comma
r_const
r_char
op_star
id|descr
comma
r_int
id|level
)paren
(brace
r_if
c_cond
(paren
id|p_s_bh
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
(paren
id|p_s_bh-&gt;b_count
)paren
)paren
op_le
l_int|0
)paren
(brace
id|reiserfs_panic
(paren
id|p_s_sb
comma
l_string|&quot;tb_buffer_sanity_check(): negative or zero reference counter for buffer %s[%d] (%b)&bslash;n&quot;
comma
id|descr
comma
id|level
comma
id|p_s_bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
(paren
id|p_s_bh
)paren
)paren
(brace
id|reiserfs_panic
(paren
id|p_s_sb
comma
l_string|&quot;tb_buffer_sanity_check(): buffer is not up to date %s[%d] (%b)&bslash;n&quot;
comma
id|descr
comma
id|level
comma
id|p_s_bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_bh
)paren
)paren
(brace
id|reiserfs_panic
(paren
id|p_s_sb
comma
l_string|&quot;tb_buffer_sanity_check(): buffer is not in tree %s[%d] (%b)&bslash;n&quot;
comma
id|descr
comma
id|level
comma
id|p_s_bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p_s_bh-&gt;b_dev
op_ne
id|p_s_sb-&gt;s_dev
op_logical_or
id|p_s_bh-&gt;b_size
op_ne
id|p_s_sb-&gt;s_blocksize
op_logical_or
id|p_s_bh-&gt;b_blocknr
OG
id|SB_BLOCK_COUNT
c_func
(paren
id|p_s_sb
)paren
)paren
(brace
id|reiserfs_panic
(paren
id|p_s_sb
comma
l_string|&quot;tb_buffer_sanity_check(): check failed for buffer %s[%d] (%b)&bslash;n&quot;
comma
id|descr
comma
id|level
comma
id|p_s_bh
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#else
DECL|function|tb_buffer_sanity_check
r_static
r_void
id|tb_buffer_sanity_check
(paren
r_struct
id|super_block
op_star
id|p_s_sb
comma
r_struct
id|buffer_head
op_star
id|p_s_bh
comma
r_const
r_char
op_star
id|descr
comma
r_int
id|level
)paren
(brace
suffix:semicolon
)brace
macro_line|#endif
DECL|function|clear_all_dirty_bits
r_static
r_void
id|clear_all_dirty_bits
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|wait_tb_buffers_until_unlocked
r_static
r_int
id|wait_tb_buffers_until_unlocked
(paren
r_struct
id|tree_balance
op_star
id|p_s_tb
)paren
(brace
r_struct
id|buffer_head
op_star
id|locked
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_int
id|repeat_counter
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
r_do
(brace
id|locked
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|p_s_tb-&gt;tb_path-&gt;path_length
suffix:semicolon
op_logical_neg
id|locked
op_logical_and
id|i
OG
id|ILLEGAL_PATH_ELEMENT_OFFSET
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|PATH_OFFSET_PBUFFER
(paren
id|p_s_tb-&gt;tb_path
comma
id|i
)paren
)paren
(brace
multiline_comment|/* if I understand correctly, we can only be sure the last buffer&n;&t;&t;** in the path is in the tree --clm&n;&t;&t;*/
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
)paren
op_eq
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|i
)paren
)paren
(brace
id|tb_buffer_sanity_check
(paren
id|p_s_tb-&gt;tb_sb
comma
id|PATH_OFFSET_PBUFFER
(paren
id|p_s_tb-&gt;tb_path
comma
id|i
)paren
comma
l_string|&quot;S&quot;
comma
id|p_s_tb-&gt;tb_path-&gt;path_length
op_minus
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|PATH_OFFSET_PBUFFER
(paren
id|p_s_tb-&gt;tb_path
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|PATH_OFFSET_PBUFFER
(paren
id|p_s_tb-&gt;tb_path
comma
id|i
)paren
)paren
)paren
id|locked
op_assign
id|PATH_OFFSET_PBUFFER
(paren
id|p_s_tb-&gt;tb_path
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|locked
op_logical_and
id|i
OL
id|MAX_HEIGHT
op_logical_and
id|p_s_tb-&gt;insert_size
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p_s_tb-&gt;lnum
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|p_s_tb-&gt;L
(braket
id|i
)braket
)paren
(brace
id|tb_buffer_sanity_check
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;L
(braket
id|i
)braket
comma
l_string|&quot;L&quot;
comma
id|i
)paren
suffix:semicolon
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;L
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|p_s_tb-&gt;L
(braket
id|i
)braket
)paren
)paren
id|locked
op_assign
id|p_s_tb-&gt;L
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
op_logical_and
id|p_s_tb-&gt;FL
(braket
id|i
)braket
)paren
(brace
id|tb_buffer_sanity_check
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FL
(braket
id|i
)braket
comma
l_string|&quot;FL&quot;
comma
id|i
)paren
suffix:semicolon
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FL
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|p_s_tb-&gt;FL
(braket
id|i
)braket
)paren
)paren
id|locked
op_assign
id|p_s_tb-&gt;FL
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
op_logical_and
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
)paren
(brace
id|tb_buffer_sanity_check
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
comma
l_string|&quot;CFL&quot;
comma
id|i
)paren
suffix:semicolon
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
)paren
)paren
id|locked
op_assign
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
op_logical_and
(paren
id|p_s_tb-&gt;rnum
(braket
id|i
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
id|p_s_tb-&gt;R
(braket
id|i
)braket
)paren
(brace
id|tb_buffer_sanity_check
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;R
(braket
id|i
)braket
comma
l_string|&quot;R&quot;
comma
id|i
)paren
suffix:semicolon
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;R
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|p_s_tb-&gt;R
(braket
id|i
)braket
)paren
)paren
id|locked
op_assign
id|p_s_tb-&gt;R
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
op_logical_and
id|p_s_tb-&gt;FR
(braket
id|i
)braket
)paren
(brace
id|tb_buffer_sanity_check
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FR
(braket
id|i
)braket
comma
l_string|&quot;FR&quot;
comma
id|i
)paren
suffix:semicolon
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FR
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|p_s_tb-&gt;FR
(braket
id|i
)braket
)paren
)paren
id|locked
op_assign
id|p_s_tb-&gt;FR
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
op_logical_and
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
)paren
(brace
id|tb_buffer_sanity_check
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
comma
l_string|&quot;CFR&quot;
comma
id|i
)paren
suffix:semicolon
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
)paren
)paren
id|locked
op_assign
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* as far as I can tell, this is not required.  The FEB list seems&n;&t;** to be full of newly allocated nodes, which will never be locked,&n;&t;** dirty, or anything else.&n;&t;** To be safe, I&squot;m putting in the checks and waits in.  For the moment,&n;&t;** they are needed to keep the code in journal.c from complaining&n;&t;** about the buffer.  That code is inside CONFIG_REISERFS_CHECK as well.&n;&t;** --clm&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|locked
op_logical_and
id|i
OL
id|MAX_FEB_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p_s_tb-&gt;FEB
(braket
id|i
)braket
)paren
(brace
id|clear_all_dirty_bits
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FEB
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|p_s_tb-&gt;FEB
(braket
id|i
)braket
)paren
)paren
(brace
id|locked
op_assign
id|p_s_tb-&gt;FEB
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|locked
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|repeat_counter
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|repeat_counter
op_mod
l_int|10000
)paren
op_eq
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;wait_tb_buffers_until_released(): too many iterations waiting for buffer to unlock (%b)&bslash;n&quot;
comma
id|locked
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t loop forever.  Try to recover from possible error. */
r_return
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
ques
c_cond
id|REPEAT_SEARCH
suffix:colon
id|CARRY_ON
suffix:semicolon
)brace
macro_line|#endif
id|__wait_on_buffer
(paren
id|locked
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
(brace
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|locked
)paren
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* Prepare for balancing, that is&n; *&t;get all necessary parents, and neighbors;&n; *&t;analyze what and where should be moved;&n; *&t;get sufficient number of new nodes;&n; * Balancing will start only after all resources will be collected at a time.&n; * &n; * When ported to SMP kernels, only at the last moment after all needed nodes&n; * are collected in cache, will the resources be locked using the usual&n; * textbook ordered lock acquisition algorithms.  Note that ensuring that&n; * this code neither write locks what it does not need to write lock nor locks out of order&n; * will be a pain in the butt that could have been avoided.  Grumble grumble. -Hans&n; * &n; * fix is meant in the sense of render unchanging&n; * &n; * Latency might be improved by first gathering a list of what buffers are needed&n; * and then getting as many of them in parallel as possible? -Hans&n; *&n; * Parameters:&n; *&t;op_mode&t;i - insert, d - delete, c - cut (truncate), p - paste (append)&n; *&t;tb&t;tree_balance structure;&n; *&t;inum&t;item number in S[h];&n; *      pos_in_item - comment this if you can&n; *      ins_ih &amp; ins_sd are used when inserting&n; * Returns:&t;1 - schedule occurred while the function worked;&n; *&t;        0 - schedule didn&squot;t occur while the function worked;&n; *             -1 - if no_disk_space &n; */
DECL|function|fix_nodes
r_int
id|fix_nodes
(paren
r_int
id|n_op_mode
comma
r_struct
id|tree_balance
op_star
id|p_s_tb
comma
r_struct
id|item_head
op_star
id|p_s_ins_ih
comma
singleline_comment|// item head of item being inserted
r_const
r_void
op_star
id|data
singleline_comment|// inserted item or data to be pasted
)paren
(brace
r_int
id|n_ret_value
comma
id|n_h
comma
id|n_item_num
op_assign
id|PATH_LAST_POSITION
c_func
(paren
id|p_s_tb-&gt;tb_path
)paren
suffix:semicolon
r_int
id|n_pos_in_item
suffix:semicolon
multiline_comment|/* we set wait_tb_buffers_run when we have to restore any dirty bits cleared&n;    ** during wait_tb_buffers_run&n;    */
r_int
id|wait_tb_buffers_run
op_assign
l_int|0
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|buffer_head
op_star
id|p_s_tbS0
op_assign
id|PATH_PLAST_BUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
)paren
suffix:semicolon
op_increment
id|p_s_tb
op_member_access_from_pointer
id|tb_sb
op_member_access_from_pointer
id|u.reiserfs_sb.s_fix_nodes
suffix:semicolon
id|n_pos_in_item
op_assign
id|p_s_tb-&gt;tb_path-&gt;pos_in_item
suffix:semicolon
id|p_s_tb-&gt;fs_gen
op_assign
id|get_generation
(paren
id|p_s_tb-&gt;tb_sb
)paren
suffix:semicolon
multiline_comment|/* we prepare and log the super here so it will already be in the&n;    ** transaction when do_balance needs to change it.&n;    ** This way do_balance won&squot;t have to schedule when trying to prepare&n;    ** the super for logging&n;    */
id|reiserfs_prepare_for_journal
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_tb-&gt;tb_sb
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
id|p_s_tb-&gt;transaction_handle
comma
id|p_s_tb-&gt;tb_sb
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|p_s_tb-&gt;tb_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
multiline_comment|/* if it possible in indirect_to_direct conversion */
r_if
c_cond
(paren
id|buffer_locked
(paren
id|p_s_tbS0
)paren
)paren
(brace
id|__wait_on_buffer
(paren
id|p_s_tbS0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
(paren
id|p_s_tb
)paren
)paren
r_return
id|REPEAT_SEARCH
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|cur_tb
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;fix_nodes&quot;
)paren
suffix:semicolon
id|reiserfs_panic
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
l_string|&quot;PAP-8305: fix_nodes:  there is pending do_balance&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
(paren
id|p_s_tbS0
)paren
op_logical_or
op_logical_neg
id|B_IS_IN_TREE
(paren
id|p_s_tbS0
)paren
)paren
(brace
id|reiserfs_panic
(paren
id|p_s_tb-&gt;tb_sb
comma
l_string|&quot;PAP-8320: fix_nodes: S[0] (%b %z) is not uptodate &quot;
l_string|&quot;at the beginning of fix_nodes or not in tree (mode %c)&quot;
comma
id|p_s_tbS0
comma
id|p_s_tbS0
comma
id|n_op_mode
)paren
suffix:semicolon
)brace
singleline_comment|// FIXME: new items have to be of 8 byte multiples. Including new
singleline_comment|// directory items those look like old ones
multiline_comment|/*&n;    if (p_s_tb-&gt;insert_size[0] % 8)&n;&t;reiserfs_panic (p_s_tb-&gt;tb_sb, &quot;vs-: fix_nodes: incorrect insert_size %d, &quot;&n;&t;&t;&t;&quot;mode %c&quot;,&n;&t;&t;&t;p_s_tb-&gt;insert_size[0], n_op_mode);&n;    */
multiline_comment|/* Check parameters. */
r_switch
c_cond
(paren
id|n_op_mode
)paren
(brace
r_case
id|M_INSERT
suffix:colon
r_if
c_cond
(paren
id|n_item_num
op_le
l_int|0
op_logical_or
id|n_item_num
OG
id|B_NR_ITEMS
c_func
(paren
id|p_s_tbS0
)paren
)paren
id|reiserfs_panic
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
l_string|&quot;PAP-8330: fix_nodes: Incorrect item number %d (in S0 - %d) in case of insert&quot;
comma
id|n_item_num
comma
id|B_NR_ITEMS
c_func
(paren
id|p_s_tbS0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|M_PASTE
suffix:colon
r_case
id|M_DELETE
suffix:colon
r_case
id|M_CUT
suffix:colon
r_if
c_cond
(paren
id|n_item_num
OL
l_int|0
op_logical_or
id|n_item_num
op_ge
id|B_NR_ITEMS
c_func
(paren
id|p_s_tbS0
)paren
)paren
(brace
id|print_block
(paren
id|p_s_tbS0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mode = %c insert_size = %d&bslash;n&quot;
comma
id|n_op_mode
comma
id|p_s_tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|reiserfs_panic
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
l_string|&quot;PAP-8335: fix_nodes: Incorrect item number(%d)&quot;
comma
id|n_item_num
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|reiserfs_panic
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
l_string|&quot;PAP-8340: fix_nodes: Incorrect mode of operation&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|get_mem_for_virtual_node
(paren
id|p_s_tb
)paren
op_eq
id|REPEAT_SEARCH
)paren
singleline_comment|// FIXME: maybe -ENOMEM when tb-&gt;vn_buf == 0? Now just repeat
r_return
id|REPEAT_SEARCH
suffix:semicolon
multiline_comment|/* Starting from the leaf level; for all levels n_h of the tree. */
r_for
c_loop
(paren
id|n_h
op_assign
l_int|0
suffix:semicolon
id|n_h
OL
id|MAX_HEIGHT
op_logical_and
id|p_s_tb-&gt;insert_size
(braket
id|n_h
)braket
suffix:semicolon
id|n_h
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_direct_parent
c_func
(paren
id|p_s_tb
comma
id|n_h
)paren
)paren
op_ne
id|CARRY_ON
)paren
(brace
r_goto
id|repeat
suffix:semicolon
r_return
id|n_ret_value
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|check_balance
(paren
id|n_op_mode
comma
id|p_s_tb
comma
id|n_h
comma
id|n_item_num
comma
id|n_pos_in_item
comma
id|p_s_ins_ih
comma
id|data
)paren
)paren
op_ne
id|CARRY_ON
)paren
(brace
r_if
c_cond
(paren
id|n_ret_value
op_eq
id|NO_BALANCING_NEEDED
)paren
(brace
multiline_comment|/* No balancing for higher levels needed. */
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_neighbors
c_func
(paren
id|p_s_tb
comma
id|n_h
)paren
)paren
op_ne
id|CARRY_ON
)paren
(brace
r_goto
id|repeat
suffix:semicolon
r_return
id|n_ret_value
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_h
op_ne
id|MAX_HEIGHT
op_minus
l_int|1
)paren
id|p_s_tb-&gt;insert_size
(braket
id|n_h
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ok, analysis and resource gathering are complete */
r_break
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
r_return
id|n_ret_value
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_neighbors
c_func
(paren
id|p_s_tb
comma
id|n_h
)paren
)paren
op_ne
id|CARRY_ON
)paren
(brace
r_goto
id|repeat
suffix:semicolon
r_return
id|n_ret_value
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|get_empty_nodes
c_func
(paren
id|p_s_tb
comma
id|n_h
)paren
)paren
op_ne
id|CARRY_ON
)paren
(brace
r_goto
id|repeat
suffix:semicolon
r_return
id|n_ret_value
suffix:semicolon
multiline_comment|/* No disk space, or schedule occurred and&n;&t;&t;&t;&t;   analysis may be invalid and needs to be redone. */
)brace
r_if
c_cond
(paren
op_logical_neg
id|PATH_H_PBUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_h
)paren
)paren
(brace
multiline_comment|/* We have a positive insert size but no nodes exist on this&n;&t;       level, this means that we are creating a new root. */
id|RFALSE
c_func
(paren
id|p_s_tb-&gt;blknum
(braket
id|n_h
)braket
op_ne
l_int|1
comma
l_string|&quot;PAP-8350: creating new empty root&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_h
OL
id|MAX_HEIGHT
op_minus
l_int|1
)paren
id|p_s_tb-&gt;insert_size
(braket
id|n_h
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|PATH_H_PBUFFER
c_func
(paren
id|p_s_tb-&gt;tb_path
comma
id|n_h
op_plus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|p_s_tb-&gt;blknum
(braket
id|n_h
)braket
OG
l_int|1
)paren
(brace
multiline_comment|/* The tree needs to be grown, so this node S[n_h]&n;&t;&t;       which is the root node is split into two nodes,&n;&t;&t;       and a new node (S[n_h+1]) will be created to&n;&t;&t;       become the root node.  */
id|RFALSE
c_func
(paren
id|n_h
op_eq
id|MAX_HEIGHT
op_minus
l_int|1
comma
l_string|&quot;PAP-8355: attempt to create too high of a tree&quot;
)paren
suffix:semicolon
id|p_s_tb-&gt;insert_size
(braket
id|n_h
op_plus
l_int|1
)braket
op_assign
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
op_star
(paren
id|p_s_tb-&gt;blknum
(braket
id|n_h
)braket
op_minus
l_int|1
)paren
op_plus
id|DC_SIZE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n_h
OL
id|MAX_HEIGHT
op_minus
l_int|1
)paren
id|p_s_tb-&gt;insert_size
(braket
id|n_h
op_plus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|p_s_tb-&gt;insert_size
(braket
id|n_h
op_plus
l_int|1
)braket
op_assign
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
op_star
(paren
id|p_s_tb-&gt;blknum
(braket
id|n_h
)braket
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;fix_nodes&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n_ret_value
op_assign
id|wait_tb_buffers_until_unlocked
(paren
id|p_s_tb
)paren
)paren
op_eq
id|CARRY_ON
)paren
(brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FILESYSTEM_CHANGED_TB
c_func
(paren
id|p_s_tb
)paren
)paren
(brace
id|wait_tb_buffers_run
op_assign
l_int|1
suffix:semicolon
id|n_ret_value
op_assign
id|REPEAT_SEARCH
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
(brace
r_return
id|CARRY_ON
suffix:semicolon
)brace
)brace
r_else
(brace
id|wait_tb_buffers_run
op_assign
l_int|1
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|repeat
suffix:colon
singleline_comment|// fix_nodes was unable to perform its calculation due to
singleline_comment|// filesystem got changed under us, lack of free disk space or i/o
singleline_comment|// failure. If the first is the case - the search will be
singleline_comment|// repeated. For now - free all resources acquired so far except
singleline_comment|// for the new allocated nodes
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Release path buffers. */
r_if
c_cond
(paren
id|wait_tb_buffers_run
)paren
(brace
id|pathrelse_and_restore
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;tb_path
)paren
suffix:semicolon
)brace
r_else
(brace
id|pathrelse
(paren
id|p_s_tb-&gt;tb_path
)paren
suffix:semicolon
)brace
multiline_comment|/* brelse all resources collected for balancing */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HEIGHT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|wait_tb_buffers_run
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;L
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;R
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FL
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FR
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|brelse
(paren
id|p_s_tb-&gt;L
(braket
id|i
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;L
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|brelse
(paren
id|p_s_tb-&gt;R
(braket
id|i
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;R
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|brelse
(paren
id|p_s_tb-&gt;FL
(braket
id|i
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;FL
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|brelse
(paren
id|p_s_tb-&gt;FR
(braket
id|i
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;FR
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|brelse
(paren
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;CFL
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|brelse
(paren
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
)paren
suffix:semicolon
id|p_s_tb-&gt;CFR
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait_tb_buffers_run
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_FEB_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p_s_tb-&gt;FEB
(braket
id|i
)braket
)paren
(brace
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|p_s_tb-&gt;tb_sb
comma
id|p_s_tb-&gt;FEB
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|n_ret_value
suffix:semicolon
)brace
)brace
multiline_comment|/* Anatoly will probably forgive me renaming p_s_tb to tb. I just&n;   wanted to make lines shorter */
DECL|function|unfix_nodes
r_void
id|unfix_nodes
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Release path buffers. */
id|pathrelse_and_restore
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;tb_path
)paren
suffix:semicolon
multiline_comment|/* brelse all resources collected for balancing */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HEIGHT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|reiserfs_restore_prepared_buffer
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;L
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;R
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;FL
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;FR
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;CFL
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|tb-&gt;tb_sb
comma
id|tb-&gt;CFR
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
(paren
id|tb-&gt;L
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
(paren
id|tb-&gt;R
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
(paren
id|tb-&gt;FL
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
(paren
id|tb-&gt;FR
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
(paren
id|tb-&gt;CFL
(braket
id|i
)braket
)paren
suffix:semicolon
id|brelse
(paren
id|tb-&gt;CFR
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* deal with list of allocated (used and unused) nodes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_FEB_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;FEB
(braket
id|i
)braket
)paren
(brace
r_int
r_int
id|blocknr
op_assign
id|tb-&gt;FEB
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
suffix:semicolon
multiline_comment|/* de-allocated block which was not used by balancing and&n;               bforget about buffer for it */
id|brelse
(paren
id|tb-&gt;FEB
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_free_block
(paren
id|tb-&gt;transaction_handle
comma
id|blocknr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;used
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* release used as new nodes including a new root */
id|brelse
(paren
id|tb-&gt;used
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tb-&gt;vn_buf
)paren
id|reiserfs_kfree
(paren
id|tb-&gt;vn_buf
comma
id|tb-&gt;vn_buf_size
comma
id|tb-&gt;tb_sb
)paren
suffix:semicolon
)brace
eof
