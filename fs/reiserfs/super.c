multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; *&n; * Trivial changes by Alan Cox to add the LFS fixes&n; *&n; * Trivial Changes:&n; * Rights granted to Hans Reiser to redistribute under other terms providing&n; * he accepts all liability including but not limited to patent, fitness&n; * for purpose, and direct or indirect claims arising from failure to perform.&n; *&n; * NO WARRANTY&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/reiserfs_acl.h&gt;
macro_line|#include &lt;linux/reiserfs_xattr.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/vfs.h&gt;
macro_line|#include &lt;linux/namespace.h&gt;
DECL|variable|reiserfs_fs_type
r_struct
id|file_system_type
id|reiserfs_fs_type
suffix:semicolon
DECL|variable|reiserfs_3_5_magic_string
r_const
r_char
id|reiserfs_3_5_magic_string
(braket
)braket
op_assign
id|REISERFS_SUPER_MAGIC_STRING
suffix:semicolon
DECL|variable|reiserfs_3_6_magic_string
r_const
r_char
id|reiserfs_3_6_magic_string
(braket
)braket
op_assign
id|REISER2FS_SUPER_MAGIC_STRING
suffix:semicolon
DECL|variable|reiserfs_jr_magic_string
r_const
r_char
id|reiserfs_jr_magic_string
(braket
)braket
op_assign
id|REISER2FS_JR_SUPER_MAGIC_STRING
suffix:semicolon
DECL|function|is_reiserfs_3_5
r_int
id|is_reiserfs_3_5
(paren
r_struct
id|reiserfs_super_block
op_star
id|rs
)paren
(brace
r_return
op_logical_neg
id|strncmp
(paren
id|rs-&gt;s_v1.s_magic
comma
id|reiserfs_3_5_magic_string
comma
id|strlen
(paren
id|reiserfs_3_5_magic_string
)paren
)paren
suffix:semicolon
)brace
DECL|function|is_reiserfs_3_6
r_int
id|is_reiserfs_3_6
(paren
r_struct
id|reiserfs_super_block
op_star
id|rs
)paren
(brace
r_return
op_logical_neg
id|strncmp
(paren
id|rs-&gt;s_v1.s_magic
comma
id|reiserfs_3_6_magic_string
comma
id|strlen
(paren
id|reiserfs_3_6_magic_string
)paren
)paren
suffix:semicolon
)brace
DECL|function|is_reiserfs_jr
r_int
id|is_reiserfs_jr
(paren
r_struct
id|reiserfs_super_block
op_star
id|rs
)paren
(brace
r_return
op_logical_neg
id|strncmp
(paren
id|rs-&gt;s_v1.s_magic
comma
id|reiserfs_jr_magic_string
comma
id|strlen
(paren
id|reiserfs_jr_magic_string
)paren
)paren
suffix:semicolon
)brace
DECL|function|is_any_reiserfs_magic_string
r_static
r_int
id|is_any_reiserfs_magic_string
(paren
r_struct
id|reiserfs_super_block
op_star
id|rs
)paren
(brace
r_return
(paren
id|is_reiserfs_3_5
(paren
id|rs
)paren
op_logical_or
id|is_reiserfs_3_6
(paren
id|rs
)paren
op_logical_or
id|is_reiserfs_jr
(paren
id|rs
)paren
)paren
suffix:semicolon
)brace
r_static
r_int
id|reiserfs_remount
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|data
)paren
suffix:semicolon
r_static
r_int
id|reiserfs_statfs
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|kstatfs
op_star
id|buf
)paren
suffix:semicolon
DECL|function|reiserfs_sync_fs
r_static
r_int
id|reiserfs_sync_fs
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|wait
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|journal_end_sync
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
)paren
id|reiserfs_flush_old_commits
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Even if it&squot;s not true.&n;                        * We&squot;ll loop forever in sync_supers otherwise */
id|reiserfs_write_unlock
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_write_super
r_static
r_void
id|reiserfs_write_super
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|reiserfs_sync_fs
c_func
(paren
id|s
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_write_super_lockfs
r_static
r_void
id|reiserfs_write_super_lockfs
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|reiserfs_write_lock
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_int
id|err
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|reiserfs_block_writes
c_func
(paren
op_amp
id|th
)paren
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|reiserfs_block_writes
c_func
(paren
op_amp
id|th
)paren
suffix:semicolon
id|journal_end_sync
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|s-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_unlockfs
r_void
id|reiserfs_unlockfs
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|reiserfs_allow_writes
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_extern
r_const
r_struct
id|reiserfs_key
id|MAX_KEY
suffix:semicolon
multiline_comment|/* this is used to delete &quot;save link&quot; when there are no items of a&n;   file it points to. It can either happen if unlink is completed but&n;   &quot;save unlink&quot; removal, or if file has both unlink and truncate&n;   pending and as unlink completes first (because key of &quot;save link&quot;&n;   protecting unlink is bigger that a key lf &quot;save link&quot; which&n;   protects truncate), so there left no items to make truncate&n;   completion on */
DECL|function|remove_save_link_only
r_static
r_int
id|remove_save_link_only
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|reiserfs_key
op_star
id|key
comma
r_int
id|oid_free
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* we are going to do one balancing */
id|err
op_assign
id|journal_begin
(paren
op_amp
id|th
comma
id|s
comma
id|JOURNAL_PER_BALANCE_CNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|reiserfs_delete_solid_item
(paren
op_amp
id|th
comma
l_int|NULL
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oid_free
)paren
multiline_comment|/* removals are protected by direct items */
id|reiserfs_release_objectid
(paren
op_amp
id|th
comma
id|le32_to_cpu
(paren
id|key-&gt;k_objectid
)paren
)paren
suffix:semicolon
r_return
id|journal_end
(paren
op_amp
id|th
comma
id|s
comma
id|JOURNAL_PER_BALANCE_CNT
)paren
suffix:semicolon
)brace
multiline_comment|/* look for uncompleted unlinks and truncates and complete them */
DECL|function|finish_unfinished
r_static
r_int
id|finish_unfinished
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_struct
id|cpu_key
id|max_cpu_key
comma
id|obj_key
suffix:semicolon
r_struct
id|reiserfs_key
id|save_link_key
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|item_pos
suffix:semicolon
r_char
op_star
id|item
suffix:semicolon
r_int
id|done
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|truncate
suffix:semicolon
multiline_comment|/* compose key to look for &quot;save&quot; links */
id|max_cpu_key.version
op_assign
id|KEY_FORMAT_3_5
suffix:semicolon
id|max_cpu_key.on_disk_key
op_assign
id|MAX_KEY
suffix:semicolon
id|max_cpu_key.key_length
op_assign
l_int|3
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_is_unlinked_ok
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|retval
)paren
(brace
id|retval
op_assign
id|search_item
(paren
id|s
comma
op_amp
id|max_cpu_key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|ITEM_NOT_FOUND
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;vs-2140: finish_unfinished: search_by_key returned %d&quot;
comma
id|retval
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|get_last_bh
(paren
op_amp
id|path
)paren
suffix:semicolon
id|item_pos
op_assign
id|get_item_pos
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item_pos
op_ne
id|B_NR_ITEMS
(paren
id|bh
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;vs-2060: finish_unfinished: wrong position found&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|item_pos
op_decrement
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|bh
comma
id|item_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_dir_id
)paren
op_ne
id|MAX_KEY_OBJECTID
)paren
multiline_comment|/* there are no &quot;save&quot; links anymore */
r_break
suffix:semicolon
id|save_link_key
op_assign
id|ih-&gt;ih_key
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|ih
)paren
)paren
id|truncate
op_assign
l_int|1
suffix:semicolon
r_else
id|truncate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reiserfs_iget needs k_dirid and k_objectid only */
id|item
op_assign
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
id|obj_key.on_disk_key.k_dir_id
op_assign
id|le32_to_cpu
(paren
op_star
(paren
id|__u32
op_star
)paren
id|item
)paren
suffix:semicolon
id|obj_key.on_disk_key.k_objectid
op_assign
id|le32_to_cpu
(paren
id|ih-&gt;ih_key.k_objectid
)paren
suffix:semicolon
id|obj_key.on_disk_key.u.k_offset_v1.k_offset
op_assign
l_int|0
suffix:semicolon
id|obj_key.on_disk_key.u.k_offset_v1.k_uniqueness
op_assign
l_int|0
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
id|inode
op_assign
id|reiserfs_iget
(paren
id|s
comma
op_amp
id|obj_key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
multiline_comment|/* the unlink almost completed, it just did not manage to remove&n;&t;       &quot;save&quot; link and release objectid */
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;vs-2180: finish_unfinished: iget failed for %K&quot;
comma
op_amp
id|obj_key
)paren
suffix:semicolon
id|retval
op_assign
id|remove_save_link_only
(paren
id|s
comma
op_amp
id|save_link_key
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|truncate
op_logical_and
id|inode-&gt;i_nlink
)paren
(brace
multiline_comment|/* file is not unlinked */
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;vs-2185: finish_unfinished: file %K is not unlinked&quot;
comma
op_amp
id|obj_key
)paren
suffix:semicolon
id|retval
op_assign
id|remove_save_link_only
(paren
id|s
comma
op_amp
id|save_link_key
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|truncate
op_logical_and
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
multiline_comment|/* We got a truncate request for a dir which is impossible.&n;&t;       The only imaginable way is to execute unfinished truncate request&n;&t;       then boot into old kernel, remove the file and create dir with&n;&t;       the same key. */
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;green-2101: impossible truncate on a directory %k. Please report&quot;
comma
id|INODE_PKEY
(paren
id|inode
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|remove_save_link_only
(paren
id|s
comma
op_amp
id|save_link_key
comma
l_int|0
)paren
suffix:semicolon
id|truncate
op_assign
l_int|0
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|truncate
)paren
(brace
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_link_saved_truncate_mask
suffix:semicolon
multiline_comment|/* not completed truncate found. New size was committed together&n;&t;       with &quot;save&quot; link */
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;Truncating %k to %Ld ..&quot;
comma
id|INODE_PKEY
(paren
id|inode
)paren
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
id|reiserfs_truncate_file
(paren
id|inode
comma
l_int|0
multiline_comment|/*don&squot;t update modification time*/
)paren
suffix:semicolon
id|retval
op_assign
id|remove_save_link
(paren
id|inode
comma
id|truncate
)paren
suffix:semicolon
)brace
r_else
(brace
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_link_saved_unlink_mask
suffix:semicolon
multiline_comment|/* not completed unlink (rmdir) found */
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;Removing %k..&quot;
comma
id|INODE_PKEY
(paren
id|inode
)paren
)paren
suffix:semicolon
multiline_comment|/* removal gets completed in iput */
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
id|iput
(paren
id|inode
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
id|done
op_increment
suffix:semicolon
)brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_is_unlinked_ok
op_assign
l_int|0
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;There were %d uncompleted unlinks/truncates. &quot;
l_string|&quot;Completed&bslash;n&quot;
comma
id|done
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* to protect file being unlinked from getting lost we &quot;safe&quot; link files&n;   being unlinked. This link will be deleted in the same transaction with last&n;   item of file. mounting the filesytem we scan all these links and remove&n;   files which almost got lost */
DECL|function|add_save_link
r_void
id|add_save_link
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|truncate
)paren
(brace
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
r_struct
id|item_head
id|ih
suffix:semicolon
id|__u32
id|link
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|th-&gt;t_trans_id
)paren
suffix:semicolon
multiline_comment|/* file can only get one &quot;save link&quot; of each kind */
id|RFALSE
c_func
(paren
id|truncate
op_logical_and
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_link_saved_truncate_mask
)paren
comma
l_string|&quot;saved link already exists for truncated inode %lx&quot;
comma
(paren
r_int
)paren
id|inode
op_member_access_from_pointer
id|i_ino
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|truncate
op_logical_and
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_link_saved_unlink_mask
)paren
comma
l_string|&quot;saved link already exists for unlinked inode %lx&quot;
comma
(paren
r_int
)paren
id|inode
op_member_access_from_pointer
id|i_ino
)paren
suffix:semicolon
multiline_comment|/* setup key of &quot;save&quot; link */
id|key.version
op_assign
id|KEY_FORMAT_3_5
suffix:semicolon
id|key.on_disk_key.k_dir_id
op_assign
id|MAX_KEY_OBJECTID
suffix:semicolon
id|key.on_disk_key.k_objectid
op_assign
id|inode-&gt;i_ino
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|truncate
)paren
(brace
multiline_comment|/* unlink, rmdir, rename */
id|set_cpu_key_k_offset
(paren
op_amp
id|key
comma
l_int|1
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|set_cpu_key_k_type
(paren
op_amp
id|key
comma
id|TYPE_DIRECT
)paren
suffix:semicolon
multiline_comment|/* item head of &quot;safe&quot; link */
id|make_le_item_head
(paren
op_amp
id|ih
comma
op_amp
id|key
comma
id|key.version
comma
l_int|1
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
comma
id|TYPE_DIRECT
comma
l_int|4
multiline_comment|/*length*/
comma
l_int|0xffff
multiline_comment|/*free space*/
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* truncate */
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
)paren
id|reiserfs_warning
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;green-2102: Adding a truncate savelink for a directory %k! Please report&quot;
comma
id|INODE_PKEY
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
id|set_cpu_key_k_offset
(paren
op_amp
id|key
comma
l_int|1
)paren
suffix:semicolon
id|set_cpu_key_k_type
(paren
op_amp
id|key
comma
id|TYPE_INDIRECT
)paren
suffix:semicolon
multiline_comment|/* item head of &quot;safe&quot; link */
id|make_le_item_head
(paren
op_amp
id|ih
comma
op_amp
id|key
comma
id|key.version
comma
l_int|1
comma
id|TYPE_INDIRECT
comma
l_int|4
multiline_comment|/*length*/
comma
l_int|0
multiline_comment|/*free space*/
)paren
suffix:semicolon
)brace
id|key.key_length
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* look for its place in the tree */
id|retval
op_assign
id|search_item
(paren
id|inode-&gt;i_sb
comma
op_amp
id|key
comma
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|ITEM_NOT_FOUND
)paren
(brace
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENOSPC
)paren
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-2100: add_save_link:&quot;
l_string|&quot;search_by_key (%K) returned %d&quot;
comma
op_amp
id|key
comma
id|retval
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* body of &quot;save&quot; link */
id|link
op_assign
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
suffix:semicolon
multiline_comment|/* put &quot;save&quot; link inot tree, don&squot;t charge quota to anyone */
id|retval
op_assign
id|reiserfs_insert_item
(paren
id|th
comma
op_amp
id|path
comma
op_amp
id|key
comma
op_amp
id|ih
comma
l_int|NULL
comma
(paren
r_char
op_star
)paren
op_amp
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENOSPC
)paren
id|reiserfs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;vs-2120: add_save_link: insert_item returned %d&quot;
comma
id|retval
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|truncate
)paren
(brace
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_link_saved_truncate_mask
suffix:semicolon
)brace
r_else
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_or_assign
id|i_link_saved_unlink_mask
suffix:semicolon
)brace
)brace
multiline_comment|/* this opens transaction unlike add_save_link */
DECL|function|remove_save_link
r_int
id|remove_save_link
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|truncate
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_struct
id|reiserfs_key
id|key
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* we are going to do one balancing only */
id|err
op_assign
id|journal_begin
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* setup key of &quot;save&quot; link */
id|key.k_dir_id
op_assign
id|cpu_to_le32
(paren
id|MAX_KEY_OBJECTID
)paren
suffix:semicolon
id|key.k_objectid
op_assign
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|truncate
)paren
(brace
multiline_comment|/* unlink, rmdir, rename */
id|set_le_key_k_offset
(paren
id|KEY_FORMAT_3_5
comma
op_amp
id|key
comma
l_int|1
op_plus
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|set_le_key_k_type
(paren
id|KEY_FORMAT_3_5
comma
op_amp
id|key
comma
id|TYPE_DIRECT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* truncate */
id|set_le_key_k_offset
(paren
id|KEY_FORMAT_3_5
comma
op_amp
id|key
comma
l_int|1
)paren
suffix:semicolon
id|set_le_key_k_type
(paren
id|KEY_FORMAT_3_5
comma
op_amp
id|key
comma
id|TYPE_INDIRECT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|truncate
op_logical_and
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_link_saved_truncate_mask
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|truncate
op_logical_and
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_amp
id|i_link_saved_unlink_mask
)paren
)paren
)paren
(brace
multiline_comment|/* don&squot;t take quota bytes from anywhere */
id|reiserfs_delete_solid_item
(paren
op_amp
id|th
comma
l_int|NULL
comma
op_amp
id|key
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|truncate
)paren
(brace
id|reiserfs_release_objectid
(paren
op_amp
id|th
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_link_saved_unlink_mask
suffix:semicolon
)brace
r_else
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_flags
op_and_assign
op_complement
id|i_link_saved_truncate_mask
suffix:semicolon
r_return
id|journal_end
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
id|JOURNAL_PER_BALANCE_CNT
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_put_super
r_static
r_void
id|reiserfs_put_super
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|th.t_trans_id
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|xattr_root
)paren
(brace
id|d_invalidate
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|xattr_root
)paren
suffix:semicolon
id|dput
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|xattr_root
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|priv_root
)paren
(brace
id|d_invalidate
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|priv_root
)paren
suffix:semicolon
id|dput
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|priv_root
)paren
suffix:semicolon
)brace
multiline_comment|/* change file system state to current state if it was mounted with read-write permissions */
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
)paren
(brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|set_sb_umount_state
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
comma
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_state
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* note, journal_release checks for readonly mount, and can decide not&n;  ** to do a journal_end&n;  */
id|journal_release
c_func
(paren
op_amp
id|th
comma
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
id|brelse
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
id|vfree
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
)paren
suffix:semicolon
id|brelse
(paren
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|print_statistics
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_kmallocs
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;vs-2004: reiserfs_put_super: allocated memory left %d&quot;
comma
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_kmallocs
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|reserved_blocks
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;green-2005: reiserfs_put_super: reserved blocks left %d&quot;
comma
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|reserved_blocks
)paren
suffix:semicolon
)brace
id|reiserfs_proc_info_done
c_func
(paren
id|s
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|s-&gt;s_fs_info
)paren
suffix:semicolon
id|s-&gt;s_fs_info
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|reiserfs_inode_cachep
r_static
id|kmem_cache_t
op_star
id|reiserfs_inode_cachep
suffix:semicolon
DECL|function|reiserfs_alloc_inode
r_static
r_struct
id|inode
op_star
id|reiserfs_alloc_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|reiserfs_inode_info
op_star
id|ei
suffix:semicolon
id|ei
op_assign
(paren
r_struct
id|reiserfs_inode_info
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|reiserfs_inode_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ei
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|ei-&gt;vfs_inode
suffix:semicolon
)brace
DECL|function|reiserfs_destroy_inode
r_static
r_void
id|reiserfs_destroy_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|reiserfs_inode_cachep
comma
id|REISERFS_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_once
r_static
r_void
id|init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|reiserfs_inode_info
op_star
id|ei
op_assign
(paren
r_struct
id|reiserfs_inode_info
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ei-&gt;i_prealloc_list
)paren
suffix:semicolon
id|inode_init_once
c_func
(paren
op_amp
id|ei-&gt;vfs_inode
)paren
suffix:semicolon
id|ei-&gt;i_acl_access
op_assign
l_int|NULL
suffix:semicolon
id|ei-&gt;i_acl_default
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|init_inodecache
r_static
r_int
id|init_inodecache
c_func
(paren
r_void
)paren
(brace
id|reiserfs_inode_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;reiser_inode_cache&quot;
comma
r_sizeof
(paren
r_struct
id|reiserfs_inode_info
)paren
comma
l_int|0
comma
id|SLAB_RECLAIM_ACCOUNT
comma
id|init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_inode_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|destroy_inodecache
r_static
r_void
id|destroy_inodecache
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|reiserfs_inode_cachep
)paren
)paren
id|reiserfs_warning
(paren
l_int|NULL
comma
l_string|&quot;reiserfs_inode_cache: not all structures were freed&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t mark inodes dirty, we just log them */
DECL|function|reiserfs_dirty_inode
r_static
r_void
id|reiserfs_dirty_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;clm-6006: writing inode %lu on readonly FS&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reiserfs_write_lock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* this is really only used for atime updates, so they don&squot;t have&n;    ** to be included in O_SYNC or fsync&n;    */
id|err
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|reiserfs_write_unlock
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|inode-&gt;i_sb
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_write_unlock
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_clear_inode
r_static
r_void
id|reiserfs_clear_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|posix_acl
op_star
id|acl
suffix:semicolon
id|acl
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_access
suffix:semicolon
r_if
c_cond
(paren
id|acl
op_logical_and
op_logical_neg
id|IS_ERR
(paren
id|acl
)paren
)paren
id|posix_acl_release
(paren
id|acl
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_access
op_assign
l_int|NULL
suffix:semicolon
id|acl
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_default
suffix:semicolon
r_if
c_cond
(paren
id|acl
op_logical_and
op_logical_neg
id|IS_ERR
(paren
id|acl
)paren
)paren
id|posix_acl_release
(paren
id|acl
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl_default
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|reiserfs_sops
r_struct
id|super_operations
id|reiserfs_sops
op_assign
(brace
dot
id|alloc_inode
op_assign
id|reiserfs_alloc_inode
comma
dot
id|destroy_inode
op_assign
id|reiserfs_destroy_inode
comma
dot
id|write_inode
op_assign
id|reiserfs_write_inode
comma
dot
id|dirty_inode
op_assign
id|reiserfs_dirty_inode
comma
dot
id|delete_inode
op_assign
id|reiserfs_delete_inode
comma
dot
id|clear_inode
op_assign
id|reiserfs_clear_inode
comma
dot
id|put_super
op_assign
id|reiserfs_put_super
comma
dot
id|write_super
op_assign
id|reiserfs_write_super
comma
dot
id|sync_fs
op_assign
id|reiserfs_sync_fs
comma
dot
id|write_super_lockfs
op_assign
id|reiserfs_write_super_lockfs
comma
dot
id|unlockfs
op_assign
id|reiserfs_unlockfs
comma
dot
id|statfs
op_assign
id|reiserfs_statfs
comma
dot
id|remount_fs
op_assign
id|reiserfs_remount
comma
)brace
suffix:semicolon
DECL|variable|reiserfs_export_ops
r_static
r_struct
id|export_operations
id|reiserfs_export_ops
op_assign
(brace
dot
id|encode_fh
op_assign
id|reiserfs_encode_fh
comma
dot
id|decode_fh
op_assign
id|reiserfs_decode_fh
comma
dot
id|get_parent
op_assign
id|reiserfs_get_parent
comma
dot
id|get_dentry
op_assign
id|reiserfs_get_dentry
comma
)brace
suffix:semicolon
multiline_comment|/* this struct is used in reiserfs_getopt () for containing the value for those&n;   mount options that have values rather than being toggles. */
r_typedef
r_struct
(brace
DECL|member|value
r_char
op_star
id|value
suffix:semicolon
DECL|member|setmask
r_int
id|setmask
suffix:semicolon
multiline_comment|/* bitmask which is to set on mount_options bitmask when this&n;                    value is found, 0 is no bits are to be changed. */
DECL|member|clrmask
r_int
id|clrmask
suffix:semicolon
multiline_comment|/* bitmask which is to clear on mount_options bitmask when  this&n;&t;&t;    value is found, 0 is no bits are to be changed. This is&n;&t;&t;    applied BEFORE setmask */
DECL|typedef|arg_desc_t
)brace
id|arg_desc_t
suffix:semicolon
multiline_comment|/* this struct is used in reiserfs_getopt() for describing the set of reiserfs&n;   mount options */
r_typedef
r_struct
(brace
DECL|member|option_name
r_char
op_star
id|option_name
suffix:semicolon
DECL|member|arg_required
r_int
id|arg_required
suffix:semicolon
multiline_comment|/* 0 if argument is not required, not 0 otherwise */
DECL|member|values
r_const
id|arg_desc_t
op_star
id|values
suffix:semicolon
multiline_comment|/* list of values accepted by an option */
DECL|member|setmask
r_int
id|setmask
suffix:semicolon
multiline_comment|/* bitmask which is to set on mount_options bitmask when this&n;                    value is found, 0 is no bits are to be changed. */
DECL|member|clrmask
r_int
id|clrmask
suffix:semicolon
multiline_comment|/* bitmask which is to clear on mount_options bitmask when  this&n;&t;&t;    value is found, 0 is no bits are to be changed. This is&n;&t;&t;    applied BEFORE setmask */
DECL|typedef|opt_desc_t
)brace
id|opt_desc_t
suffix:semicolon
multiline_comment|/* possible values for -o data= */
DECL|variable|logging_mode
r_static
r_const
id|arg_desc_t
id|logging_mode
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;ordered&quot;
comma
l_int|1
op_lshift
id|REISERFS_DATA_ORDERED
comma
(paren
l_int|1
op_lshift
id|REISERFS_DATA_LOG
op_or
l_int|1
op_lshift
id|REISERFS_DATA_WRITEBACK
)paren
)brace
comma
(brace
l_string|&quot;journal&quot;
comma
l_int|1
op_lshift
id|REISERFS_DATA_LOG
comma
(paren
l_int|1
op_lshift
id|REISERFS_DATA_ORDERED
op_or
l_int|1
op_lshift
id|REISERFS_DATA_WRITEBACK
)paren
)brace
comma
(brace
l_string|&quot;writeback&quot;
comma
l_int|1
op_lshift
id|REISERFS_DATA_WRITEBACK
comma
(paren
l_int|1
op_lshift
id|REISERFS_DATA_ORDERED
op_or
l_int|1
op_lshift
id|REISERFS_DATA_LOG
)paren
)brace
comma
(brace
l_int|NULL
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* possible values for -o barrier= */
DECL|variable|barrier_mode
r_static
r_const
id|arg_desc_t
id|barrier_mode
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;none&quot;
comma
l_int|1
op_lshift
id|REISERFS_BARRIER_NONE
comma
l_int|1
op_lshift
id|REISERFS_BARRIER_FLUSH
)brace
comma
(brace
l_string|&quot;flush&quot;
comma
l_int|1
op_lshift
id|REISERFS_BARRIER_FLUSH
comma
l_int|1
op_lshift
id|REISERFS_BARRIER_NONE
)brace
comma
(brace
l_int|NULL
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* possible values for &quot;-o block-allocator=&quot; and bits which are to be set in&n;   s_mount_opt of reiserfs specific part of in-core super block */
DECL|variable|balloc
r_static
r_const
id|arg_desc_t
id|balloc
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;noborder&quot;
comma
l_int|1
op_lshift
id|REISERFS_NO_BORDER
comma
l_int|0
)brace
comma
(brace
l_string|&quot;border&quot;
comma
l_int|0
comma
l_int|1
op_lshift
id|REISERFS_NO_BORDER
)brace
comma
(brace
l_string|&quot;no_unhashed_relocation&quot;
comma
l_int|1
op_lshift
id|REISERFS_NO_UNHASHED_RELOCATION
comma
l_int|0
)brace
comma
(brace
l_string|&quot;hashed_relocation&quot;
comma
l_int|1
op_lshift
id|REISERFS_HASHED_RELOCATION
comma
l_int|0
)brace
comma
(brace
l_string|&quot;test4&quot;
comma
l_int|1
op_lshift
id|REISERFS_TEST4
comma
l_int|0
)brace
comma
(brace
l_string|&quot;notest4&quot;
comma
l_int|0
comma
l_int|1
op_lshift
id|REISERFS_TEST4
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|tails
r_static
r_const
id|arg_desc_t
id|tails
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;on&quot;
comma
l_int|1
op_lshift
id|REISERFS_LARGETAIL
comma
l_int|1
op_lshift
id|REISERFS_SMALLTAIL
)brace
comma
(brace
l_string|&quot;off&quot;
comma
l_int|0
comma
(paren
l_int|1
op_lshift
id|REISERFS_LARGETAIL
)paren
op_or
(paren
l_int|1
op_lshift
id|REISERFS_SMALLTAIL
)paren
)brace
comma
(brace
l_string|&quot;small&quot;
comma
l_int|1
op_lshift
id|REISERFS_SMALLTAIL
comma
l_int|1
op_lshift
id|REISERFS_LARGETAIL
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|error_actions
r_static
r_const
id|arg_desc_t
id|error_actions
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;panic&quot;
comma
l_int|1
op_lshift
id|REISERFS_ERROR_PANIC
comma
(paren
l_int|1
op_lshift
id|REISERFS_ERROR_RO
op_or
l_int|1
op_lshift
id|REISERFS_ERROR_CONTINUE
)paren
)brace
comma
(brace
l_string|&quot;ro-remount&quot;
comma
l_int|1
op_lshift
id|REISERFS_ERROR_RO
comma
(paren
l_int|1
op_lshift
id|REISERFS_ERROR_PANIC
op_or
l_int|1
op_lshift
id|REISERFS_ERROR_CONTINUE
)paren
)brace
comma
macro_line|#ifdef REISERFS_JOURNAL_ERROR_ALLOWS_NO_LOG
(brace
l_string|&quot;continue&quot;
comma
l_int|1
op_lshift
id|REISERFS_ERROR_CONTINUE
comma
(paren
l_int|1
op_lshift
id|REISERFS_ERROR_PANIC
op_or
l_int|1
op_lshift
id|REISERFS_ERROR_RO
)paren
)brace
comma
macro_line|#endif
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|variable|reiserfs_default_io_size
r_int
id|reiserfs_default_io_size
op_assign
l_int|128
op_star
l_int|1024
suffix:semicolon
multiline_comment|/* Default recommended I/O size is 128k.&n;&t;&t;&t;&t;&t;      There might be broken applications that are&n;&t;&t;&t;&t;&t;      confused by this. Use nolargeio mount option&n;&t;&t;&t;&t;&t;      to get usual i/o size = PAGE_SIZE.&n;&t;&t;&t;&t;&t;    */
multiline_comment|/* proceed only one option from a list *cur - string containing of mount options&n;   opts - array of options which are accepted&n;   opt_arg - if option is found and requires an argument and if it is specifed&n;   in the input - pointer to the argument is stored here&n;   bit_flags - if option requires to set a certain bit - it is set here&n;   return -1 if unknown option is found, opt-&gt;arg_required otherwise */
DECL|function|reiserfs_getopt
r_static
r_int
id|reiserfs_getopt
(paren
r_struct
id|super_block
op_star
id|s
comma
r_char
op_star
op_star
id|cur
comma
id|opt_desc_t
op_star
id|opts
comma
r_char
op_star
op_star
id|opt_arg
comma
r_int
r_int
op_star
id|bit_flags
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
multiline_comment|/* foo=bar, &n;       ^   ^  ^&n;       |   |  +-- option_end&n;       |   +-- arg_start&n;       +-- option_start&n;    */
r_const
id|opt_desc_t
op_star
id|opt
suffix:semicolon
r_const
id|arg_desc_t
op_star
id|arg
suffix:semicolon
id|p
op_assign
op_star
id|cur
suffix:semicolon
multiline_comment|/* assume argument cannot contain commas */
op_star
id|cur
op_assign
id|strchr
(paren
id|p
comma
l_char|&squot;,&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cur
)paren
(brace
op_star
(paren
op_star
id|cur
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
(paren
op_star
id|cur
)paren
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|p
comma
l_string|&quot;alloc=&quot;
comma
l_int|6
)paren
)paren
(brace
multiline_comment|/* Ugly special case, probably we should redo options parser so that&n;&t;   it can understand several arguments for some options, also so that&n;&t;   it can fill several bitfields with option values. */
r_if
c_cond
(paren
id|reiserfs_parse_alloc_options
c_func
(paren
id|s
comma
id|p
op_plus
l_int|6
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* for every option in the list */
r_for
c_loop
(paren
id|opt
op_assign
id|opts
suffix:semicolon
id|opt-&gt;option_name
suffix:semicolon
id|opt
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|p
comma
id|opt-&gt;option_name
comma
id|strlen
(paren
id|opt-&gt;option_name
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|bit_flags
)paren
(brace
r_if
c_cond
(paren
id|opt-&gt;clrmask
op_eq
(paren
l_int|1
op_lshift
id|REISERFS_UNSUPPORTED_OPT
)paren
)paren
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;%s not supported.&quot;
comma
id|p
)paren
suffix:semicolon
r_else
op_star
id|bit_flags
op_and_assign
op_complement
id|opt-&gt;clrmask
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;setmask
op_eq
(paren
l_int|1
op_lshift
id|REISERFS_UNSUPPORTED_OPT
)paren
)paren
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;%s not supported.&quot;
comma
id|p
)paren
suffix:semicolon
r_else
op_star
id|bit_flags
op_or_assign
id|opt-&gt;setmask
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;option_name
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;unknown mount option &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|p
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|p
op_add_assign
id|strlen
(paren
id|opt-&gt;option_name
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|p
)paren
(brace
r_case
l_char|&squot;=&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;arg_required
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;the option &bslash;&quot;%s&bslash;&quot; does not require an argument&quot;
comma
id|opt-&gt;option_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|opt-&gt;arg_required
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;the option &bslash;&quot;%s&bslash;&quot; requires an argument&quot;
comma
id|opt-&gt;option_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;head of option &bslash;&quot;%s&bslash;&quot; is only correct&quot;
comma
id|opt-&gt;option_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* move to the argument, or to next option if argument is not required */
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opt-&gt;arg_required
op_logical_and
op_logical_neg
id|strlen
(paren
id|p
)paren
)paren
(brace
multiline_comment|/* this catches &quot;option=,&quot; */
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;empty argument for &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|opt-&gt;option_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|opt-&gt;values
)paren
(brace
multiline_comment|/* *=NULLopt_arg contains pointer to argument */
op_star
id|opt_arg
op_assign
id|p
suffix:semicolon
r_return
id|opt-&gt;arg_required
suffix:semicolon
)brace
multiline_comment|/* values possible for this option are listed in opt-&gt;values */
r_for
c_loop
(paren
id|arg
op_assign
id|opt-&gt;values
suffix:semicolon
id|arg-&gt;value
suffix:semicolon
id|arg
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|p
comma
id|arg-&gt;value
)paren
)paren
(brace
r_if
c_cond
(paren
id|bit_flags
)paren
(brace
op_star
id|bit_flags
op_and_assign
op_complement
id|arg-&gt;clrmask
suffix:semicolon
op_star
id|bit_flags
op_or_assign
id|arg-&gt;setmask
suffix:semicolon
)brace
r_return
id|opt-&gt;arg_required
suffix:semicolon
)brace
)brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;bad value &bslash;&quot;%s&bslash;&quot; for option &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|p
comma
id|opt-&gt;option_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* returns 0 if something is wrong in option string, 1 - otherwise */
DECL|function|reiserfs_parse_options
r_static
r_int
id|reiserfs_parse_options
(paren
r_struct
id|super_block
op_star
id|s
comma
r_char
op_star
id|options
comma
multiline_comment|/* string given via mount&squot;s -o */
r_int
r_int
op_star
id|mount_options
comma
multiline_comment|/* after the parsing phase, contains the&n;&t;&t;&t;&t;      collection of bitflags defining what&n;&t;&t;&t;&t;      mount options were selected. */
r_int
r_int
op_star
id|blocks
comma
multiline_comment|/* strtol-ed from NNN of resize=NNN */
r_char
op_star
op_star
id|jdev_name
comma
r_int
r_int
op_star
id|commit_max_age
)paren
(brace
r_int
id|c
suffix:semicolon
r_char
op_star
id|arg
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
id|opt_desc_t
id|opts
(braket
)braket
op_assign
(brace
multiline_comment|/* Compatibility stuff, so that -o notail for old setups still work */
(brace
l_string|&quot;tails&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;t&squot;
comma
dot
id|values
op_assign
id|tails
)brace
comma
(brace
l_string|&quot;notail&quot;
comma
dot
id|clrmask
op_assign
(paren
l_int|1
op_lshift
id|REISERFS_LARGETAIL
)paren
op_or
(paren
l_int|1
op_lshift
id|REISERFS_SMALLTAIL
)paren
)brace
comma
(brace
l_string|&quot;conv&quot;
comma
dot
id|setmask
op_assign
l_int|1
op_lshift
id|REISERFS_CONVERT
)brace
comma
(brace
l_string|&quot;attrs&quot;
comma
dot
id|setmask
op_assign
l_int|1
op_lshift
id|REISERFS_ATTRS
)brace
comma
(brace
l_string|&quot;noattrs&quot;
comma
dot
id|clrmask
op_assign
l_int|1
op_lshift
id|REISERFS_ATTRS
)brace
comma
macro_line|#ifdef CONFIG_REISERFS_FS_XATTR
(brace
l_string|&quot;user_xattr&quot;
comma
dot
id|setmask
op_assign
l_int|1
op_lshift
id|REISERFS_XATTRS_USER
)brace
comma
(brace
l_string|&quot;nouser_xattr&quot;
comma
dot
id|clrmask
op_assign
l_int|1
op_lshift
id|REISERFS_XATTRS_USER
)brace
comma
macro_line|#else
(brace
l_string|&quot;user_xattr&quot;
comma
dot
id|setmask
op_assign
l_int|1
op_lshift
id|REISERFS_UNSUPPORTED_OPT
)brace
comma
(brace
l_string|&quot;nouser_xattr&quot;
comma
dot
id|clrmask
op_assign
l_int|1
op_lshift
id|REISERFS_UNSUPPORTED_OPT
)brace
comma
macro_line|#endif
macro_line|#ifdef CONFIG_REISERFS_FS_POSIX_ACL
(brace
l_string|&quot;acl&quot;
comma
dot
id|setmask
op_assign
l_int|1
op_lshift
id|REISERFS_POSIXACL
)brace
comma
(brace
l_string|&quot;noacl&quot;
comma
dot
id|clrmask
op_assign
l_int|1
op_lshift
id|REISERFS_POSIXACL
)brace
comma
macro_line|#else
(brace
l_string|&quot;acl&quot;
comma
dot
id|setmask
op_assign
l_int|1
op_lshift
id|REISERFS_UNSUPPORTED_OPT
)brace
comma
(brace
l_string|&quot;noacl&quot;
comma
dot
id|clrmask
op_assign
l_int|1
op_lshift
id|REISERFS_UNSUPPORTED_OPT
)brace
comma
macro_line|#endif
(brace
l_string|&quot;nolog&quot;
comma
)brace
comma
multiline_comment|/* This is unsupported */
(brace
l_string|&quot;replayonly&quot;
comma
dot
id|setmask
op_assign
l_int|1
op_lshift
id|REPLAYONLY
)brace
comma
(brace
l_string|&quot;block-allocator&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;a&squot;
comma
dot
id|values
op_assign
id|balloc
)brace
comma
(brace
l_string|&quot;data&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;d&squot;
comma
dot
id|values
op_assign
id|logging_mode
)brace
comma
(brace
l_string|&quot;barrier&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;b&squot;
comma
dot
id|values
op_assign
id|barrier_mode
)brace
comma
(brace
l_string|&quot;resize&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;r&squot;
comma
dot
id|values
op_assign
l_int|NULL
)brace
comma
(brace
l_string|&quot;jdev&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;j&squot;
comma
dot
id|values
op_assign
l_int|NULL
)brace
comma
(brace
l_string|&quot;nolargeio&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;w&squot;
comma
dot
id|values
op_assign
l_int|NULL
)brace
comma
(brace
l_string|&quot;commit&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;c&squot;
comma
dot
id|values
op_assign
l_int|NULL
)brace
comma
(brace
l_string|&quot;usrquota&quot;
comma
)brace
comma
(brace
l_string|&quot;grpquota&quot;
comma
)brace
comma
(brace
l_string|&quot;errors&quot;
comma
dot
id|arg_required
op_assign
l_char|&squot;e&squot;
comma
dot
id|values
op_assign
id|error_actions
)brace
comma
(brace
l_int|NULL
comma
)brace
)brace
suffix:semicolon
op_star
id|blocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options
op_logical_or
op_logical_neg
op_star
id|options
)paren
multiline_comment|/* use default configuration: create tails, journaling on, no&n;&t;   conversion to newest format */
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
id|options
suffix:semicolon
id|pos
suffix:semicolon
)paren
(brace
id|c
op_assign
id|reiserfs_getopt
(paren
id|s
comma
op_amp
id|pos
comma
id|opts
comma
op_amp
id|arg
comma
id|mount_options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* wrong option is given */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;r&squot;
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* &quot;resize=NNN&quot; */
op_star
id|blocks
op_assign
id|simple_strtoul
(paren
id|arg
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* NNN does not look like a number */
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;reiserfs_parse_options: bad value %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;c&squot;
)paren
(brace
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|val
op_assign
id|simple_strtoul
(paren
id|arg
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* commit=NNN (time in seconds) */
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_or
id|val
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;reiserfs_parse_options: bad value %s&quot;
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|commit_max_age
op_assign
(paren
r_int
r_int
)paren
id|val
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;w&squot;
)paren
(brace
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
id|val
op_assign
id|simple_strtoul
(paren
id|arg
comma
op_amp
id|p
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;reiserfs_parse_options: non-numeric value %s for nolargeio option&quot;
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|val
)paren
id|reiserfs_default_io_size
op_assign
id|PAGE_SIZE
suffix:semicolon
r_else
id|reiserfs_default_io_size
op_assign
l_int|128
op_star
l_int|1024
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;j&squot;
)paren
(brace
r_if
c_cond
(paren
id|arg
op_logical_and
op_star
id|arg
op_logical_and
id|jdev_name
)paren
(brace
r_if
c_cond
(paren
op_star
id|jdev_name
)paren
(brace
singleline_comment|//Hm, already assigned?
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;reiserfs_parse_options: journal device was already  specified to be %s&quot;
comma
op_star
id|jdev_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|jdev_name
op_assign
id|arg
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|switch_data_mode
r_static
r_void
id|switch_data_mode
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|mode
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_and_assign
op_complement
(paren
(paren
l_int|1
op_lshift
id|REISERFS_DATA_LOG
)paren
op_or
(paren
l_int|1
op_lshift
id|REISERFS_DATA_ORDERED
)paren
op_or
(paren
l_int|1
op_lshift
id|REISERFS_DATA_WRITEBACK
)paren
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_or_assign
(paren
l_int|1
op_lshift
id|mode
)paren
suffix:semicolon
)brace
DECL|function|handle_data_mode
r_static
r_void
id|handle_data_mode
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|mount_options
)paren
(brace
r_if
c_cond
(paren
id|mount_options
op_amp
(paren
l_int|1
op_lshift
id|REISERFS_DATA_LOG
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_data_log
c_func
(paren
id|s
)paren
)paren
(brace
id|switch_data_mode
c_func
(paren
id|s
comma
id|REISERFS_DATA_LOG
)paren
suffix:semicolon
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;switching to journaled data mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|mount_options
op_amp
(paren
l_int|1
op_lshift
id|REISERFS_DATA_ORDERED
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_data_ordered
c_func
(paren
id|s
)paren
)paren
(brace
id|switch_data_mode
c_func
(paren
id|s
comma
id|REISERFS_DATA_ORDERED
)paren
suffix:semicolon
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;switching to ordered data mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|mount_options
op_amp
(paren
l_int|1
op_lshift
id|REISERFS_DATA_WRITEBACK
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_data_writeback
c_func
(paren
id|s
)paren
)paren
(brace
id|switch_data_mode
c_func
(paren
id|s
comma
id|REISERFS_DATA_WRITEBACK
)paren
suffix:semicolon
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;switching to writeback data mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|handle_barrier_mode
r_static
r_void
id|handle_barrier_mode
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|bits
)paren
(brace
r_int
id|flush
op_assign
(paren
l_int|1
op_lshift
id|REISERFS_BARRIER_FLUSH
)paren
suffix:semicolon
r_int
id|none
op_assign
(paren
l_int|1
op_lshift
id|REISERFS_BARRIER_NONE
)paren
suffix:semicolon
r_int
id|all_barrier
op_assign
id|flush
op_or
id|none
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_amp
id|all_barrier
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_and_assign
op_complement
id|all_barrier
suffix:semicolon
r_if
c_cond
(paren
id|bits
op_amp
id|flush
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_or_assign
id|flush
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reiserfs: enabling write barrier flush mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bits
op_amp
id|none
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_or_assign
id|none
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reiserfs: write barriers turned off&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|handle_attrs
r_static
r_void
id|handle_attrs
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_attrs
c_func
(paren
id|s
)paren
)paren
(brace
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
c_func
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;reiserfs: cannot support attributes on 3.5.x disk format&quot;
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|REISERFS_ATTRS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|le32_to_cpu
c_func
(paren
id|rs
op_member_access_from_pointer
id|s_flags
)paren
op_amp
id|reiserfs_attrs_cleared
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;reiserfs: cannot support attributes until flag is set in super-block&quot;
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|REISERFS_ATTRS
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|reiserfs_remount
r_static
r_int
id|reiserfs_remount
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
op_star
id|mount_flags
comma
r_char
op_star
id|arg
)paren
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
r_int
r_int
id|mount_options
op_assign
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
suffix:semicolon
r_int
r_int
id|safe_mask
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|commit_max_age
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
r_struct
id|reiserfs_journal
op_star
id|journal
op_assign
id|SB_JOURNAL
c_func
(paren
id|s
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_parse_options
c_func
(paren
id|s
comma
id|arg
comma
op_amp
id|mount_options
comma
op_amp
id|blocks
comma
l_int|NULL
comma
op_amp
id|commit_max_age
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|handle_attrs
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Add options that are safe here */
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_SMALLTAIL
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_LARGETAIL
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_NO_BORDER
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_NO_UNHASHED_RELOCATION
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_HASHED_RELOCATION
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_TEST4
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_ATTRS
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_XATTRS_USER
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_POSIXACL
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_BARRIER_FLUSH
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_BARRIER_NONE
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_ERROR_RO
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_ERROR_CONTINUE
suffix:semicolon
id|safe_mask
op_or_assign
l_int|1
op_lshift
id|REISERFS_ERROR_PANIC
suffix:semicolon
multiline_comment|/* Update the bitmask, taking care to keep&n;   * the bits we&squot;re not allowed to change here */
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_assign
(paren
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_amp
op_complement
id|safe_mask
)paren
op_or
(paren
id|mount_options
op_amp
id|safe_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_max_age
op_ne
l_int|0
op_logical_and
id|commit_max_age
op_ne
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
(brace
id|journal-&gt;j_max_commit_age
op_assign
id|commit_max_age
suffix:semicolon
id|journal-&gt;j_max_trans_age
op_assign
id|commit_max_age
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|commit_max_age
op_eq
l_int|0
)paren
(brace
multiline_comment|/* 0 means restore defaults. */
id|journal-&gt;j_max_commit_age
op_assign
id|journal-&gt;j_default_max_commit_age
suffix:semicolon
id|journal-&gt;j_max_trans_age
op_assign
id|JOURNAL_MAX_TRANS_AGE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
)paren
(brace
r_int
id|rc
op_assign
id|reiserfs_resize
c_func
(paren
id|s
comma
id|blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|mount_flags
op_amp
id|MS_RDONLY
)paren
(brace
id|reiserfs_xattr_init
(paren
id|s
comma
op_star
id|mount_flags
)paren
suffix:semicolon
multiline_comment|/* remount read-only */
r_if
c_cond
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
multiline_comment|/* it is read-only already */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* try to remount file system with read-only permissions */
r_if
c_cond
(paren
id|sb_umount_state
c_func
(paren
id|rs
)paren
op_eq
id|REISERFS_VALID_FS
op_logical_or
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_state
op_ne
id|REISERFS_VALID_FS
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|err
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Mounting a rw partition read-only. */
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|set_sb_umount_state
c_func
(paren
id|rs
comma
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_state
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* remount read-write */
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|reiserfs_xattr_init
(paren
id|s
comma
op_star
id|mount_flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We are read-write already */
)brace
r_if
c_cond
(paren
id|reiserfs_is_journal_aborted
(paren
id|journal
)paren
)paren
r_return
id|journal-&gt;j_errno
suffix:semicolon
id|handle_data_mode
c_func
(paren
id|s
comma
id|mount_options
)paren
suffix:semicolon
id|handle_barrier_mode
c_func
(paren
id|s
comma
id|mount_options
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_state
op_assign
id|sb_umount_state
c_func
(paren
id|rs
)paren
suffix:semicolon
id|s-&gt;s_flags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
multiline_comment|/* now it is safe to call journal_begin */
id|err
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Mount a partition which is read-only, read-write */
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_state
op_assign
id|sb_umount_state
c_func
(paren
id|rs
)paren
suffix:semicolon
id|s-&gt;s_flags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
id|set_sb_umount_state
c_func
(paren
id|rs
comma
id|REISERFS_ERROR_FS
)paren
suffix:semicolon
multiline_comment|/* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_state
op_assign
id|REISERFS_VALID_FS
suffix:semicolon
)brace
multiline_comment|/* this will force a full flush of all journal lists */
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|mount_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|finish_unfinished
c_func
(paren
id|s
)paren
suffix:semicolon
id|reiserfs_xattr_init
(paren
id|s
comma
op_star
id|mount_flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* load_bitmap_info_data - Sets up the reiserfs_bitmap_info structure from disk.&n; * @sb - superblock for this filesystem&n; * @bi - the bitmap info to be loaded. Requires that bi-&gt;bh is valid.&n; *&n; * This routine counts how many free bits there are, finding the first zero&n; * as a side effect. Could also be implemented as a loop of test_bit() calls, or&n; * a loop of find_first_zero_bit() calls. This implementation is similar to&n; * find_first_zero_bit(), but doesn&squot;t return after it finds the first bit.&n; * Should only be called on fs mount, but should be fairly efficient anyways.&n; *&n; * bi-&gt;first_zero_hint is considered unset if it == 0, since the bitmap itself&n; * will * invariably occupt block 0 represented in the bitmap. The only&n; * exception to this is when free_count also == 0, since there will be no&n; * free blocks at all.&n; */
DECL|function|load_bitmap_info_data
r_static
r_void
id|load_bitmap_info_data
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|reiserfs_bitmap_info
op_star
id|bi
)paren
(brace
r_int
r_int
op_star
id|cur
op_assign
(paren
r_int
r_int
op_star
)paren
id|bi-&gt;bh-&gt;b_data
suffix:semicolon
r_while
c_loop
(paren
(paren
r_char
op_star
)paren
id|cur
OL
(paren
id|bi-&gt;bh-&gt;b_data
op_plus
id|sb-&gt;s_blocksize
)paren
)paren
(brace
multiline_comment|/* No need to scan if all 0&squot;s or all 1&squot;s.&n;&t; * Since we&squot;re only counting 0&squot;s, we can simply ignore all 1&squot;s */
r_if
c_cond
(paren
op_star
id|cur
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|bi-&gt;first_zero_hint
op_eq
l_int|0
)paren
(brace
id|bi-&gt;first_zero_hint
op_assign
(paren
(paren
r_char
op_star
)paren
id|cur
op_minus
id|bi-&gt;bh-&gt;b_data
)paren
op_lshift
l_int|3
suffix:semicolon
)brace
id|bi-&gt;free_count
op_add_assign
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|8
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|cur
op_ne
op_complement
l_int|0L
)paren
(brace
r_int
id|b
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|8
suffix:semicolon
id|b
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_test_le_bit
(paren
id|b
comma
id|cur
)paren
)paren
(brace
id|bi-&gt;free_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bi-&gt;first_zero_hint
op_eq
l_int|0
)paren
id|bi-&gt;first_zero_hint
op_assign
(paren
(paren
(paren
r_char
op_star
)paren
id|cur
op_minus
id|bi-&gt;bh-&gt;b_data
)paren
op_lshift
l_int|3
)paren
op_plus
id|b
suffix:semicolon
)brace
)brace
)brace
id|cur
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
singleline_comment|// This outputs a lot of unneded info on big FSes
singleline_comment|//    reiserfs_warning (&quot;bitmap loaded from block %d: %d free blocks&quot;,
singleline_comment|//&t;&t;      bi-&gt;bh-&gt;b_blocknr, bi-&gt;free_count);
macro_line|#endif
)brace
DECL|function|read_bitmaps
r_static
r_int
id|read_bitmaps
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|bmap_nr
suffix:semicolon
id|SB_AP_BITMAP
(paren
id|s
)paren
op_assign
id|vmalloc
(paren
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_info
)paren
op_star
id|SB_BMAP_NR
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|memset
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_bitmap_info
)paren
op_star
id|SB_BMAP_NR
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|bmap_nr
op_assign
id|REISERFS_DISK_OFFSET_IN_BYTES
op_div
id|s-&gt;s_blocksize
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
comma
id|bmap_nr
op_assign
id|s-&gt;s_blocksize
op_star
l_int|8
op_star
id|i
)paren
(brace
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
op_assign
id|sb_getblk
c_func
(paren
id|s
comma
id|bmap_nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
)paren
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;sh-2029: reiserfs read_bitmaps: &quot;
l_string|&quot;bitmap block (#%lu) reading failed&quot;
comma
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
id|brelse
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
id|vfree
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|load_bitmap_info_data
(paren
id|s
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
op_plus
id|i
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_old_bitmaps
r_static
r_int
id|read_old_bitmaps
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
suffix:semicolon
r_int
id|bmp1
op_assign
(paren
id|REISERFS_OLD_DISK_OFFSET_IN_BYTES
op_div
id|s-&gt;s_blocksize
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* first of bitmap blocks */
multiline_comment|/* read true bitmap */
id|SB_AP_BITMAP
(paren
id|s
)paren
op_assign
id|vmalloc
(paren
r_sizeof
(paren
r_struct
id|reiserfs_buffer_info
op_star
)paren
op_star
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|memset
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_buffer_info
op_star
)paren
op_star
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
op_assign
id|sb_bread
(paren
id|s
comma
id|bmp1
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
r_return
l_int|1
suffix:semicolon
id|load_bitmap_info_data
(paren
id|s
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
op_plus
id|i
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_bitmap
r_void
id|check_bitmap
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|free
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|SB_BLOCK_COUNT
(paren
id|s
)paren
)paren
(brace
id|buf
op_assign
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
op_div
(paren
id|s-&gt;s_blocksize
op_star
l_int|8
)paren
)braket
dot
id|bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_test_le_bit
(paren
id|i
op_mod
(paren
id|s-&gt;s_blocksize
op_star
l_int|8
)paren
comma
id|buf
)paren
)paren
id|free
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free
op_ne
id|SB_FREE_BLOCKS
(paren
id|s
)paren
)paren
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;vs-4000: check_bitmap: %d free blocks, must be %d&quot;
comma
id|free
comma
id|SB_FREE_BLOCKS
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
DECL|function|read_super_block
r_static
r_int
id|read_super_block
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_int
id|fs_blocksize
suffix:semicolon
id|bh
op_assign
id|sb_bread
(paren
id|s
comma
id|offset
op_div
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;sh-2006: read_super_block: &quot;
l_string|&quot;bread failed (dev %s, block %lu, size %lu)&quot;
comma
id|reiserfs_bdevname
(paren
id|s
)paren
comma
id|offset
op_div
id|s-&gt;s_blocksize
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rs
op_assign
(paren
r_struct
id|reiserfs_super_block
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_any_reiserfs_magic_string
(paren
id|rs
)paren
)paren
(brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// ok, reiserfs signature (old or new) found in at the given offset
singleline_comment|//    
id|fs_blocksize
op_assign
id|sb_blocksize
c_func
(paren
id|rs
)paren
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
id|sb_set_blocksize
(paren
id|s
comma
id|fs_blocksize
)paren
suffix:semicolon
id|bh
op_assign
id|sb_bread
(paren
id|s
comma
id|offset
op_div
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;sh-2007: read_super_block: &quot;
l_string|&quot;bread failed (dev %s, block %lu, size %lu)&bslash;n&quot;
comma
id|reiserfs_bdevname
(paren
id|s
)paren
comma
id|offset
op_div
id|s-&gt;s_blocksize
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rs
op_assign
(paren
r_struct
id|reiserfs_super_block
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|sb_blocksize
c_func
(paren
id|rs
)paren
op_ne
id|s-&gt;s_blocksize
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;sh-2011: read_super_block: &quot;
l_string|&quot;can&squot;t find a reiserfs filesystem on (dev %s, block %Lu, size %lu)&bslash;n&quot;
comma
id|reiserfs_bdevname
(paren
id|s
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|bh-&gt;b_blocknr
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rs-&gt;s_v1.s_root_block
op_eq
op_minus
l_int|1
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;Unfinished reiserfsck --rebuild-tree run detected. Please run&bslash;n&quot;
l_string|&quot;reiserfsck --rebuild-tree and wait for a completion. If that fails&bslash;n&quot;
l_string|&quot;get newer reiserfsprogs package&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
op_assign
id|bh
suffix:semicolon
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
op_assign
id|rs
suffix:semicolon
r_if
c_cond
(paren
id|is_reiserfs_jr
(paren
id|rs
)paren
)paren
(brace
multiline_comment|/* magic is of non-standard journal filesystem, look at s_version to&n;&t;   find which format is in use */
r_if
c_cond
(paren
id|sb_version
c_func
(paren
id|rs
)paren
op_eq
id|REISERFS_VERSION_2
)paren
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;read_super_block: found reiserfs format &bslash;&quot;3.6&bslash;&quot;&quot;
l_string|&quot; with non-standard journal&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sb_version
c_func
(paren
id|rs
)paren
op_eq
id|REISERFS_VERSION_1
)paren
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;read_super_block: found reiserfs format &bslash;&quot;3.5&bslash;&quot;&quot;
l_string|&quot; with non-standard journal&quot;
)paren
suffix:semicolon
r_else
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;sh-2012: read_super_block: found unknown &quot;
l_string|&quot;format &bslash;&quot;%u&bslash;&quot; of reiserfs with non-standard magic&quot;
comma
id|sb_version
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* s_version of standard format may contain incorrect information,&n;&t; so we just look at the magic string */
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;found reiserfs format &bslash;&quot;%s&bslash;&quot; with standard journal&bslash;n&quot;
comma
id|is_reiserfs_3_5
(paren
id|rs
)paren
ques
c_cond
l_string|&quot;3.5&quot;
suffix:colon
l_string|&quot;3.6&quot;
)paren
suffix:semicolon
id|s-&gt;s_op
op_assign
op_amp
id|reiserfs_sops
suffix:semicolon
id|s-&gt;s_export_op
op_assign
op_amp
id|reiserfs_export_ops
suffix:semicolon
multiline_comment|/* new format is limited by the 32 bit wide i_blocks field, want to&n;    ** be one full block below that.&n;    */
id|s-&gt;s_maxbytes
op_assign
(paren
l_int|512LL
op_lshift
l_int|32
)paren
op_minus
id|s-&gt;s_blocksize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* after journal replay, reread all bitmap and super blocks */
DECL|function|reread_meta_blocks
r_static
r_int
id|reread_meta_blocks
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
(paren
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;reread_meta_blocks, error reading the super&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh
)paren
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;reread_meta_blocks, error reading bitmap block number %d at %llu&quot;
comma
id|i
comma
(paren
r_int
r_int
r_int
)paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|/////////////////////////////////////////////////////
singleline_comment|// hash detection stuff
singleline_comment|// if root directory is empty - we set default - Yura&squot;s - hash and
singleline_comment|// warn about it
singleline_comment|// FIXME: we look for only one name in a directory. If tea and yura
singleline_comment|// bith have the same value - we ask user to send report to the
singleline_comment|// mailing list
DECL|function|find_hash_out
id|__u32
id|find_hash_out
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
id|__u32
id|hash
op_assign
id|DEFAULT_HASH
suffix:semicolon
id|inode
op_assign
id|s-&gt;s_root-&gt;d_inode
suffix:semicolon
r_do
(brace
singleline_comment|// Some serious &quot;goto&quot;-hater was there ;)
id|u32
id|teahash
comma
id|r5hash
comma
id|yurahash
suffix:semicolon
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
op_complement
l_int|0
comma
id|TYPE_DIRENTRY
comma
l_int|3
)paren
suffix:semicolon
id|retval
op_assign
id|search_by_entry_key
(paren
id|s
comma
op_amp
id|key
comma
op_amp
id|path
comma
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|UNSET_HASH
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|NAME_NOT_FOUND
)paren
id|de.de_entry_num
op_decrement
suffix:semicolon
id|set_de_name_and_namelen
(paren
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
op_eq
id|DOT_DOT_OFFSET
)paren
(brace
multiline_comment|/* allow override in this case */
r_if
c_cond
(paren
id|reiserfs_rupasov_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|hash
op_assign
id|YURA_HASH
suffix:semicolon
)brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;FS seems to be empty, autodetect &quot;
l_string|&quot;is using the default hash&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|r5hash
op_assign
id|GET_HASH_VALUE
(paren
id|r5_hash
(paren
id|de.de_name
comma
id|de.de_namelen
)paren
)paren
suffix:semicolon
id|teahash
op_assign
id|GET_HASH_VALUE
(paren
id|keyed_hash
(paren
id|de.de_name
comma
id|de.de_namelen
)paren
)paren
suffix:semicolon
id|yurahash
op_assign
id|GET_HASH_VALUE
(paren
id|yura_hash
(paren
id|de.de_name
comma
id|de.de_namelen
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|teahash
op_eq
id|r5hash
)paren
op_logical_and
(paren
id|GET_HASH_VALUE
c_func
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
)paren
op_eq
id|r5hash
)paren
)paren
op_logical_or
(paren
(paren
id|teahash
op_eq
id|yurahash
)paren
op_logical_and
(paren
id|yurahash
op_eq
id|GET_HASH_VALUE
c_func
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
)paren
)paren
)paren
op_logical_or
(paren
(paren
id|r5hash
op_eq
id|yurahash
)paren
op_logical_and
(paren
id|yurahash
op_eq
id|GET_HASH_VALUE
c_func
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
)paren
)paren
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
id|s
comma
l_string|&quot;Unable to automatically detect hash function. &quot;
l_string|&quot;Please mount with -o hash={tea,rupasov,r5}&quot;
comma
id|reiserfs_bdevname
(paren
id|s
)paren
)paren
suffix:semicolon
id|hash
op_assign
id|UNSET_HASH
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_HASH_VALUE
c_func
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
)paren
op_eq
id|yurahash
)paren
id|hash
op_assign
id|YURA_HASH
suffix:semicolon
r_else
r_if
c_cond
(paren
id|GET_HASH_VALUE
c_func
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
)paren
op_eq
id|teahash
)paren
id|hash
op_assign
id|TEA_HASH
suffix:semicolon
r_else
r_if
c_cond
(paren
id|GET_HASH_VALUE
c_func
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
)paren
op_eq
id|r5hash
)paren
id|hash
op_assign
id|R5_HASH
suffix:semicolon
r_else
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;Unrecognised hash function&quot;
)paren
suffix:semicolon
id|hash
op_assign
id|UNSET_HASH
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|0
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|hash
suffix:semicolon
)brace
singleline_comment|// finds out which hash names are sorted with
DECL|function|what_hash
r_static
r_int
id|what_hash
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|__u32
id|code
suffix:semicolon
id|code
op_assign
id|sb_hash_function_code
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
multiline_comment|/* reiserfs_hash_detect() == true if any of the hash mount options&n;    ** were used.  We must check them to make sure the user isn&squot;t&n;    ** using a bad hash value&n;    */
r_if
c_cond
(paren
id|code
op_eq
id|UNSET_HASH
op_logical_or
id|reiserfs_hash_detect
c_func
(paren
id|s
)paren
)paren
id|code
op_assign
id|find_hash_out
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
id|UNSET_HASH
op_logical_and
id|reiserfs_hash_detect
c_func
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* detection has found the hash, and we must check against the &n;&t;** mount options &n;&t;*/
r_if
c_cond
(paren
id|reiserfs_rupasov_hash
c_func
(paren
id|s
)paren
op_logical_and
id|code
op_ne
id|YURA_HASH
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;Error, %s hash detected, &quot;
l_string|&quot;unable to force rupasov hash&quot;
comma
id|reiserfs_hashname
c_func
(paren
id|code
)paren
)paren
suffix:semicolon
id|code
op_assign
id|UNSET_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_tea_hash
c_func
(paren
id|s
)paren
op_logical_and
id|code
op_ne
id|TEA_HASH
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;Error, %s hash detected, &quot;
l_string|&quot;unable to force tea hash&quot;
comma
id|reiserfs_hashname
c_func
(paren
id|code
)paren
)paren
suffix:semicolon
id|code
op_assign
id|UNSET_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_r5_hash
c_func
(paren
id|s
)paren
op_logical_and
id|code
op_ne
id|R5_HASH
)paren
(brace
id|reiserfs_warning
(paren
id|s
comma
l_string|&quot;Error, %s hash detected, &quot;
l_string|&quot;unable to force r5 hash&quot;
comma
id|reiserfs_hashname
c_func
(paren
id|code
)paren
)paren
suffix:semicolon
id|code
op_assign
id|UNSET_HASH
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* find_hash_out was not called or could not determine the hash */
r_if
c_cond
(paren
id|reiserfs_rupasov_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|code
op_assign
id|YURA_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_tea_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|code
op_assign
id|TEA_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_r5_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|code
op_assign
id|R5_HASH
suffix:semicolon
)brace
)brace
multiline_comment|/* if we are mounted RW, and we have a new valid hash code, update &n;    ** the super&n;    */
r_if
c_cond
(paren
id|code
op_ne
id|UNSET_HASH
op_logical_and
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
op_logical_and
id|code
op_ne
id|sb_hash_function_code
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
)paren
)paren
(brace
id|set_sb_hash_function_code
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
comma
id|code
)paren
suffix:semicolon
)brace
r_return
id|code
suffix:semicolon
)brace
singleline_comment|// return pointer to appropriate function
DECL|function|hash_function
r_static
id|hashf_t
id|hash_function
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_switch
c_cond
(paren
id|what_hash
(paren
id|s
)paren
)paren
(brace
r_case
id|TEA_HASH
suffix:colon
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;Using tea hash to sort names&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|keyed_hash
suffix:semicolon
r_case
id|YURA_HASH
suffix:colon
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;Using rupasov hash to sort names&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|yura_hash
suffix:semicolon
r_case
id|R5_HASH
suffix:colon
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;Using r5 hash to sort names&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|r5_hash
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// this is used to set up correct value for old partitions
DECL|function|function2code
r_int
id|function2code
(paren
id|hashf_t
id|func
)paren
(brace
r_if
c_cond
(paren
id|func
op_eq
id|keyed_hash
)paren
r_return
id|TEA_HASH
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
id|yura_hash
)paren
r_return
id|YURA_HASH
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
id|r5_hash
)paren
r_return
id|R5_HASH
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// should never happen
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|SWARN
mdefine_line|#define SWARN(silent, s, ...)&t;&t;&t;&bslash;&n;&t;if (!(silent))&t;&t;&t;&t;&bslash;&n;&t;&t;reiserfs_warning (s, __VA_ARGS__)
DECL|function|reiserfs_fill_super
r_static
r_int
id|reiserfs_fill_super
(paren
r_struct
id|super_block
op_star
id|s
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|root_inode
suffix:semicolon
r_int
id|j
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|old_format
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
r_int
r_int
id|commit_max_age
op_assign
l_int|0
suffix:semicolon
r_int
id|jinit_done
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_iget_args
id|args
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_char
op_star
id|jdev_name
suffix:semicolon
r_struct
id|reiserfs_sb_info
op_star
id|sbi
suffix:semicolon
r_int
id|errval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|sbi
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|reiserfs_sb_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbi
)paren
(brace
id|errval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|s-&gt;s_fs_info
op_assign
id|sbi
suffix:semicolon
id|memset
(paren
id|sbi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_sb_info
)paren
)paren
suffix:semicolon
multiline_comment|/* Set default values for options: non-aggressive tails, RO on errors */
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_or_assign
(paren
l_int|1
op_lshift
id|REISERFS_SMALLTAIL
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_or_assign
(paren
l_int|1
op_lshift
id|REISERFS_ERROR_RO
)paren
suffix:semicolon
multiline_comment|/* no preallocation minimum, be smart in&n;       reiserfs_file_write instead */
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.preallocmin
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Preallocate by 16 blocks (17-1) at once */
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.preallocsize
op_assign
l_int|17
suffix:semicolon
multiline_comment|/* Initialize the rwsem for xattr dir */
id|init_rwsem
c_func
(paren
op_amp
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|xattr_dir_sem
)paren
suffix:semicolon
multiline_comment|/* setup default block allocator options */
id|reiserfs_init_alloc_options
c_func
(paren
id|s
)paren
suffix:semicolon
id|jdev_name
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_parse_options
(paren
id|s
comma
(paren
r_char
op_star
)paren
id|data
comma
op_amp
(paren
id|sbi-&gt;s_mount_opt
)paren
comma
op_amp
id|blocks
comma
op_amp
id|jdev_name
comma
op_amp
id|commit_max_age
)paren
op_eq
l_int|0
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
)paren
(brace
id|SWARN
(paren
id|silent
comma
id|s
comma
l_string|&quot;jmacd-7: reiserfs_fill_super: resize option &quot;
l_string|&quot;for remount only&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* try old format (undistributed bitmap, super block in 8-th 1k block of a device) */
r_if
c_cond
(paren
op_logical_neg
id|read_super_block
(paren
id|s
comma
id|REISERFS_OLD_DISK_OFFSET_IN_BYTES
)paren
)paren
id|old_format
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* try new format (64-th 1k block), which can contain reiserfs super block */
r_else
r_if
c_cond
(paren
id|read_super_block
(paren
id|s
comma
id|REISERFS_DISK_OFFSET_IN_BYTES
)paren
)paren
(brace
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;sh-2021: reiserfs_fill_super: can not find reiserfs on %s&quot;
comma
id|reiserfs_bdevname
(paren
id|s
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* Let&squot;s do basic sanity check to verify that underlying device is not&n;       smaller than the filesystem. If the check fails then abort and scream,&n;       because bad stuff will happen otherwise. */
r_if
c_cond
(paren
id|s-&gt;s_bdev
op_logical_and
id|s-&gt;s_bdev-&gt;bd_inode
op_logical_and
id|i_size_read
c_func
(paren
id|s-&gt;s_bdev-&gt;bd_inode
)paren
OL
id|sb_block_count
c_func
(paren
id|rs
)paren
op_star
id|sb_blocksize
c_func
(paren
id|rs
)paren
)paren
(brace
id|SWARN
(paren
id|silent
comma
id|s
comma
l_string|&quot;Filesystem on %s cannot be mounted because it is bigger than the device&quot;
comma
id|reiserfs_bdevname
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;You may need to run fsck or increase size of your LVM partition&quot;
)paren
suffix:semicolon
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;Or may be you forgot to reboot after fdisk when it told you to&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|sbi-&gt;s_mount_state
op_assign
id|SB_REISERFS_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|sbi-&gt;s_mount_state
op_assign
id|REISERFS_VALID_FS
suffix:semicolon
r_if
c_cond
(paren
id|old_format
ques
c_cond
id|read_old_bitmaps
c_func
(paren
id|s
)paren
suffix:colon
id|read_bitmaps
c_func
(paren
id|s
)paren
)paren
(brace
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;jmacd-8: reiserfs_fill_super: unable to read bitmap&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|SWARN
(paren
id|silent
comma
id|s
comma
l_string|&quot;CONFIG_REISERFS_CHECK is set ON&quot;
)paren
suffix:semicolon
id|SWARN
(paren
id|silent
comma
id|s
comma
l_string|&quot;- it is slow mode for debugging.&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* make data=ordered the default */
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_data_log
c_func
(paren
id|s
)paren
op_logical_and
op_logical_neg
id|reiserfs_data_ordered
c_func
(paren
id|s
)paren
op_logical_and
op_logical_neg
id|reiserfs_data_writeback
c_func
(paren
id|s
)paren
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_mount_opt
op_or_assign
(paren
l_int|1
op_lshift
id|REISERFS_DATA_ORDERED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reiserfs_data_log
c_func
(paren
id|s
)paren
)paren
(brace
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;using journaled data mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_data_ordered
c_func
(paren
id|s
)paren
)paren
(brace
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;using ordered data mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;using writeback data mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reiserfs_barrier_flush
c_func
(paren
id|s
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs: using flush barriers&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// set_device_ro(s-&gt;s_dev, 1) ;
r_if
c_cond
(paren
id|journal_init
c_func
(paren
id|s
comma
id|jdev_name
comma
id|old_format
comma
id|commit_max_age
)paren
)paren
(brace
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;sh-2022: reiserfs_fill_super: unable to initialize journal space&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_else
(brace
id|jinit_done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* once this is set, journal_release must be called&n;&t;&t;&t; ** if we error out of the mount&n;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|reread_meta_blocks
c_func
(paren
id|s
)paren
)paren
(brace
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;jmacd-9: reiserfs_fill_super: unable to reread meta blocks after journal init&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|replay_only
(paren
id|s
)paren
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|bdev_read_only
c_func
(paren
id|s-&gt;s_bdev
)paren
op_logical_and
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;clm-7000: Detected readonly device, marking FS readonly&quot;
)paren
suffix:semicolon
id|s-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
)brace
id|args.objectid
op_assign
id|REISERFS_ROOT_OBJECTID
suffix:semicolon
id|args.dirid
op_assign
id|REISERFS_ROOT_PARENT_OBJECTID
suffix:semicolon
id|root_inode
op_assign
id|iget5_locked
(paren
id|s
comma
id|REISERFS_ROOT_OBJECTID
comma
id|reiserfs_find_actor
comma
id|reiserfs_init_locked_inode
comma
(paren
r_void
op_star
)paren
(paren
op_amp
id|args
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_inode
)paren
(brace
id|SWARN
c_func
(paren
id|silent
comma
id|s
comma
l_string|&quot;jmacd-10: reiserfs_fill_super: get root inode failed&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|root_inode-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|reiserfs_read_locked_inode
c_func
(paren
id|root_inode
comma
op_amp
id|args
)paren
suffix:semicolon
id|unlock_new_inode
c_func
(paren
id|root_inode
)paren
suffix:semicolon
)brace
id|s-&gt;s_root
op_assign
id|d_alloc_root
c_func
(paren
id|root_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;s_root
)paren
(brace
id|iput
c_func
(paren
id|root_inode
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
singleline_comment|// define and initialize hash function
id|sbi-&gt;s_hash_function
op_assign
id|hash_function
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;s_hash_function
op_eq
l_int|NULL
)paren
(brace
id|dput
c_func
(paren
id|s-&gt;s_root
)paren
suffix:semicolon
id|s-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_reiserfs_3_5
(paren
id|rs
)paren
op_logical_or
(paren
id|is_reiserfs_jr
(paren
id|rs
)paren
op_logical_and
id|SB_VERSION
(paren
id|s
)paren
op_eq
id|REISERFS_VERSION_1
)paren
)paren
id|set_bit
c_func
(paren
id|REISERFS_3_5
comma
op_amp
(paren
id|sbi-&gt;s_properties
)paren
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|REISERFS_3_6
comma
op_amp
(paren
id|sbi-&gt;s_properties
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|errval
op_assign
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errval
)paren
(brace
id|dput
(paren
id|s-&gt;s_root
)paren
suffix:semicolon
id|s-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|set_sb_umount_state
c_func
(paren
id|rs
comma
id|REISERFS_ERROR_FS
)paren
suffix:semicolon
id|set_sb_fs_state
(paren
id|rs
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_format_only
c_func
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* filesystem of format 3.5 either with standard or non-standard&n;&t;     journal */
r_if
c_cond
(paren
id|convert_reiserfs
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* and -o conv is given */
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
(brace
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;converting 3.5 filesystem to the 3.6 format&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_reiserfs_3_5
(paren
id|rs
)paren
)paren
multiline_comment|/* put magic string of 3.6 format. 2.2 will not be able to&n;&t;&t; mount this filesystem anymore */
id|memcpy
(paren
id|rs-&gt;s_v1.s_magic
comma
id|reiserfs_3_6_magic_string
comma
r_sizeof
(paren
id|reiserfs_3_6_magic_string
)paren
)paren
suffix:semicolon
id|set_sb_version
c_func
(paren
id|rs
comma
id|REISERFS_VERSION_2
)paren
suffix:semicolon
id|reiserfs_convert_objectid_map_v1
c_func
(paren
id|s
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|REISERFS_3_6
comma
op_amp
(paren
id|sbi-&gt;s_properties
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|REISERFS_3_5
comma
op_amp
(paren
id|sbi-&gt;s_properties
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|silent
)paren
(brace
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;using 3.5.x disk format&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|errval
op_assign
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errval
)paren
(brace
id|dput
(paren
id|s-&gt;s_root
)paren
suffix:semicolon
id|s-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|errval
op_assign
id|reiserfs_xattr_init
(paren
id|s
comma
id|s-&gt;s_flags
)paren
)paren
)paren
(brace
id|dput
(paren
id|s-&gt;s_root
)paren
suffix:semicolon
id|s-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* look for files which were to be removed in previous session */
id|finish_unfinished
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|old_format_only
c_func
(paren
id|s
)paren
op_logical_and
op_logical_neg
id|silent
)paren
(brace
id|reiserfs_info
(paren
id|s
comma
l_string|&quot;using 3.5.x disk format&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|errval
op_assign
id|reiserfs_xattr_init
(paren
id|s
comma
id|s-&gt;s_flags
)paren
)paren
)paren
(brace
id|dput
(paren
id|s-&gt;s_root
)paren
suffix:semicolon
id|s-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
singleline_comment|// mark hash in super block: it could be unset. overwrite should be ok
id|set_sb_hash_function_code
c_func
(paren
id|rs
comma
id|function2code
c_func
(paren
id|sbi-&gt;s_hash_function
)paren
)paren
suffix:semicolon
id|handle_attrs
c_func
(paren
id|s
)paren
suffix:semicolon
id|reiserfs_proc_info_init
c_func
(paren
id|s
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
(paren
id|sbi-&gt;s_wait
)paren
)paren
suffix:semicolon
id|sbi-&gt;bitmap_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error
suffix:colon
r_if
c_cond
(paren
id|jinit_done
)paren
(brace
multiline_comment|/* kill the commit thread, free journal ram */
id|journal_release_error
c_func
(paren
l_int|NULL
comma
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SB_BMAP_NR
(paren
id|s
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
)paren
id|brelse
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|j
)braket
dot
id|bh
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
)paren
id|vfree
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
id|brelse
c_func
(paren
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|sbi
)paren
suffix:semicolon
)brace
id|s-&gt;s_fs_info
op_assign
l_int|NULL
suffix:semicolon
r_return
id|errval
suffix:semicolon
)brace
DECL|function|reiserfs_statfs
r_static
r_int
id|reiserfs_statfs
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|kstatfs
op_star
id|buf
)paren
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
(paren
id|REISERFS_MAX_NAME
(paren
id|s-&gt;s_blocksize
)paren
)paren
suffix:semicolon
id|buf-&gt;f_bfree
op_assign
id|sb_free_blocks
c_func
(paren
id|rs
)paren
suffix:semicolon
id|buf-&gt;f_bavail
op_assign
id|buf-&gt;f_bfree
suffix:semicolon
id|buf-&gt;f_blocks
op_assign
id|sb_block_count
c_func
(paren
id|rs
)paren
op_minus
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
op_minus
l_int|1
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
id|s-&gt;s_blocksize
suffix:semicolon
multiline_comment|/* changed to accommodate gcc folks.*/
id|buf-&gt;f_type
op_assign
id|REISERFS_SUPER_MAGIC
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|super_block
op_star
DECL|function|get_super_block
id|get_super_block
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_bdev
c_func
(paren
id|fs_type
comma
id|flags
comma
id|dev_name
comma
id|data
comma
id|reiserfs_fill_super
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|init_reiserfs_fs
id|init_reiserfs_fs
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|init_inodecache
(paren
)paren
)paren
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|reiserfs_xattr_register_handlers
(paren
)paren
)paren
)paren
r_goto
id|failed_reiserfs_xattr_register_handlers
suffix:semicolon
id|reiserfs_proc_info_global_init
(paren
)paren
suffix:semicolon
id|reiserfs_proc_register_global
(paren
l_string|&quot;version&quot;
comma
id|reiserfs_global_version_in_proc
)paren
suffix:semicolon
id|ret
op_assign
id|register_filesystem
(paren
op_amp
id|reiserfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|reiserfs_xattr_unregister_handlers
(paren
)paren
suffix:semicolon
id|failed_reiserfs_xattr_register_handlers
suffix:colon
id|reiserfs_proc_unregister_global
(paren
l_string|&quot;version&quot;
)paren
suffix:semicolon
id|reiserfs_proc_info_global_done
(paren
)paren
suffix:semicolon
id|destroy_inodecache
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
id|__exit
DECL|function|exit_reiserfs_fs
id|exit_reiserfs_fs
(paren
r_void
)paren
(brace
id|reiserfs_xattr_unregister_handlers
(paren
)paren
suffix:semicolon
id|reiserfs_proc_unregister_global
(paren
l_string|&quot;version&quot;
)paren
suffix:semicolon
id|reiserfs_proc_info_global_done
(paren
)paren
suffix:semicolon
id|unregister_filesystem
(paren
op_amp
id|reiserfs_fs_type
)paren
suffix:semicolon
id|destroy_inodecache
(paren
)paren
suffix:semicolon
)brace
DECL|variable|reiserfs_fs_type
r_struct
id|file_system_type
id|reiserfs_fs_type
op_assign
(brace
dot
id|owner
op_assign
id|THIS_MODULE
comma
dot
id|name
op_assign
l_string|&quot;reiserfs&quot;
comma
dot
id|get_sb
op_assign
id|get_super_block
comma
dot
id|kill_sb
op_assign
id|kill_block_super
comma
dot
id|fs_flags
op_assign
id|FS_REQUIRES_DEV
comma
)brace
suffix:semicolon
id|MODULE_DESCRIPTION
(paren
l_string|&quot;ReiserFS journaled filesystem&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
(paren
l_string|&quot;Hans Reiser &lt;reiser@namesys.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|init_reiserfs_fs
id|module_init
(paren
id|init_reiserfs_fs
)paren
suffix:semicolon
DECL|variable|exit_reiserfs_fs
id|module_exit
(paren
id|exit_reiserfs_fs
)paren
suffix:semicolon
eof
