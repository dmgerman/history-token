multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; *&n; * Trivial changes by Alan Cox to add the LFS fixes&n; *&n; * Trivial Changes:&n; * Rights granted to Hans Reiser to redistribute under other terms providing&n; * he accepts all liability including but not limited to patent, fitness&n; * for purpose, and direct or indirect claims arising from failure to perform.&n; *&n; * NO WARRANTY&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
DECL|macro|REISERFS_OLD_BLOCKSIZE
mdefine_line|#define REISERFS_OLD_BLOCKSIZE 4096
DECL|macro|REISERFS_SUPER_MAGIC_STRING_OFFSET_NJ
mdefine_line|#define REISERFS_SUPER_MAGIC_STRING_OFFSET_NJ 20
DECL|variable|reiserfs_super_magic_string
r_char
id|reiserfs_super_magic_string
(braket
)braket
op_assign
id|REISERFS_SUPER_MAGIC_STRING
suffix:semicolon
DECL|variable|reiser2fs_super_magic_string
r_char
id|reiser2fs_super_magic_string
(braket
)braket
op_assign
id|REISER2FS_SUPER_MAGIC_STRING
suffix:semicolon
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_write_super
r_void
id|reiserfs_write_super
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|dirty
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|dirty
op_assign
id|flush_old_commits
c_func
(paren
id|s
comma
l_int|1
)paren
suffix:semicolon
)brace
id|s-&gt;s_dirt
op_assign
id|dirty
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_write_super_lockfs
r_void
id|reiserfs_write_super_lockfs
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|dirty
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|reiserfs_block_writes
c_func
(paren
op_amp
id|th
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
)brace
id|s-&gt;s_dirt
op_assign
id|dirty
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_unlockfs
r_void
id|reiserfs_unlockfs
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|reiserfs_allow_writes
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_put_super
r_void
id|reiserfs_put_super
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
multiline_comment|/* change file system state to current state if it was mounted with read-write permissions */
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|set_sb_state
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
comma
id|s-&gt;u.reiserfs_sb.s_mount_state
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* note, journal_release checks for readonly mount, and can decide not&n;  ** to do a journal_end&n;  */
id|journal_release
c_func
(paren
op_amp
id|th
comma
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
id|brelse
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|reiserfs_kfree
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
comma
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
op_star
id|SB_BMAP_NR
(paren
id|s
)paren
comma
id|s
)paren
suffix:semicolon
id|brelse
(paren
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|print_statistics
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;u.reiserfs_sb.s_kmallocs
op_ne
l_int|0
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-2004: reiserfs_put_super: allocated memory left %d&bslash;n&quot;
comma
id|s-&gt;u.reiserfs_sb.s_kmallocs
)paren
suffix:semicolon
)brace
id|reiserfs_proc_unregister
c_func
(paren
id|s
comma
l_string|&quot;journal&quot;
)paren
suffix:semicolon
id|reiserfs_proc_unregister
c_func
(paren
id|s
comma
l_string|&quot;oidmap&quot;
)paren
suffix:semicolon
id|reiserfs_proc_unregister
c_func
(paren
id|s
comma
l_string|&quot;on-disk-super&quot;
)paren
suffix:semicolon
id|reiserfs_proc_unregister
c_func
(paren
id|s
comma
l_string|&quot;bitmap&quot;
)paren
suffix:semicolon
id|reiserfs_proc_unregister
c_func
(paren
id|s
comma
l_string|&quot;per-level&quot;
)paren
suffix:semicolon
id|reiserfs_proc_unregister
c_func
(paren
id|s
comma
l_string|&quot;super&quot;
)paren
suffix:semicolon
id|reiserfs_proc_unregister
c_func
(paren
id|s
comma
l_string|&quot;version&quot;
)paren
suffix:semicolon
id|reiserfs_proc_info_done
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|variable|reiserfs_inode_cachep
r_static
id|kmem_cache_t
op_star
id|reiserfs_inode_cachep
suffix:semicolon
DECL|function|reiserfs_alloc_inode
r_static
r_struct
id|inode
op_star
id|reiserfs_alloc_inode
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|reiserfs_inode_info
op_star
id|ei
suffix:semicolon
id|ei
op_assign
(paren
r_struct
id|reiserfs_inode_info
op_star
)paren
id|kmem_cache_alloc
c_func
(paren
id|reiserfs_inode_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ei
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
op_amp
id|ei-&gt;vfs_inode
suffix:semicolon
)brace
DECL|function|reiserfs_destroy_inode
r_static
r_void
id|reiserfs_destroy_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|reiserfs_inode_cachep
comma
id|REISERFS_I
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_once
r_static
r_void
id|init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cachep
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|reiserfs_inode_info
op_star
id|ei
op_assign
(paren
r_struct
id|reiserfs_inode_info
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_eq
id|SLAB_CTOR_CONSTRUCTOR
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ei-&gt;i_prealloc_list
)paren
suffix:semicolon
id|inode_init_once
c_func
(paren
op_amp
id|ei-&gt;vfs_inode
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_inodecache
r_static
r_int
id|init_inodecache
c_func
(paren
r_void
)paren
(brace
id|reiserfs_inode_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;reiserfs_inode_cache&quot;
comma
r_sizeof
(paren
r_struct
id|reiserfs_inode_info
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
id|init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_inode_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|destroy_inodecache
r_static
r_void
id|destroy_inodecache
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|reiserfs_inode_cachep
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;reiserfs_inode_cache: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|reiserfs_sops
r_struct
id|super_operations
id|reiserfs_sops
op_assign
(brace
id|alloc_inode
suffix:colon
id|reiserfs_alloc_inode
comma
id|destroy_inode
suffix:colon
id|reiserfs_destroy_inode
comma
id|read_inode
suffix:colon
id|reiserfs_read_inode
comma
id|read_inode2
suffix:colon
id|reiserfs_read_inode2
comma
id|write_inode
suffix:colon
id|reiserfs_write_inode
comma
id|dirty_inode
suffix:colon
id|reiserfs_dirty_inode
comma
id|delete_inode
suffix:colon
id|reiserfs_delete_inode
comma
id|put_super
suffix:colon
id|reiserfs_put_super
comma
id|write_super
suffix:colon
id|reiserfs_write_super
comma
id|write_super_lockfs
suffix:colon
id|reiserfs_write_super_lockfs
comma
id|unlockfs
suffix:colon
id|reiserfs_unlockfs
comma
id|statfs
suffix:colon
id|reiserfs_statfs
comma
id|remount_fs
suffix:colon
id|reiserfs_remount
comma
id|fh_to_dentry
suffix:colon
id|reiserfs_fh_to_dentry
comma
id|dentry_to_fh
suffix:colon
id|reiserfs_dentry_to_fh
comma
)brace
suffix:semicolon
multiline_comment|/* this was (ext2)parse_options */
DECL|function|parse_options
r_static
r_int
id|parse_options
(paren
r_char
op_star
id|options
comma
r_int
r_int
op_star
id|mount_options
comma
r_int
r_int
op_star
id|blocks
)paren
(brace
r_char
op_star
id|this_char
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
op_star
id|blocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|options
)paren
multiline_comment|/* use default configuration: create tails, journaling on, no&n;           conversion to newest format */
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|this_char
op_assign
id|strtok
(paren
id|options
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|this_char
op_ne
l_int|NULL
suffix:semicolon
id|this_char
op_assign
id|strtok
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
(paren
id|this_char
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|value
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;notail&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|NOTAIL
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;conv&quot;
)paren
)paren
(brace
singleline_comment|// if this is set, we update super block such that
singleline_comment|// the partition will not be mounable by 3.5.x anymore
id|set_bit
(paren
id|REISERFS_CONVERT
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;noborder&quot;
)paren
)paren
(brace
multiline_comment|/* this is used for benchmarking&n;                                   experimental variations, it is not&n;                                   intended for users to use, only for&n;                                   developers who want to casually&n;                                   hack in something to test */
id|set_bit
(paren
id|REISERFS_NO_BORDER
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;no_unhashed_relocation&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|REISERFS_NO_UNHASHED_RELOCATION
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;hashed_relocation&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|REISERFS_HASHED_RELOCATION
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;test4&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|REISERFS_TEST4
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;nolog&quot;
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;reiserfs: nolog mount option not supported yet&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;replayonly&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|REPLAYONLY
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;resize&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
op_star
id|blocks
op_assign
id|simple_strtoul
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs: resize option requires a value&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
(paren
id|this_char
comma
l_string|&quot;hash&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
op_star
id|value
)paren
(brace
multiline_comment|/* if they specify any hash option, we force detection&n;&t;&t;** to make sure they aren&squot;t using the wrong hash&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;rupasov&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|FORCE_RUPASOV_HASH
comma
id|mount_options
)paren
suffix:semicolon
id|set_bit
(paren
id|FORCE_HASH_DETECT
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;tea&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|FORCE_TEA_HASH
comma
id|mount_options
)paren
suffix:semicolon
id|set_bit
(paren
id|FORCE_HASH_DETECT
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;r5&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|FORCE_R5_HASH
comma
id|mount_options
)paren
suffix:semicolon
id|set_bit
(paren
id|FORCE_HASH_DETECT
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|value
comma
l_string|&quot;detect&quot;
)paren
)paren
(brace
id|set_bit
(paren
id|FORCE_HASH_DETECT
comma
id|mount_options
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs: invalid hash function specified&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs: hash option requires a value&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;reiserfs: Unrecognized mount option %s&bslash;n&quot;
comma
id|this_char
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|reiserfs_is_super
r_int
id|reiserfs_is_super
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_return
(paren
op_logical_neg
id|kdev_same
c_func
(paren
id|s-&gt;s_dev
comma
id|NODEV
)paren
op_logical_and
id|s-&gt;s_op
op_eq
op_amp
id|reiserfs_sops
)paren
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_remount
r_int
id|reiserfs_remount
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|data
)paren
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
r_int
r_int
id|mount_options
suffix:semicolon
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parse_options
c_func
(paren
id|data
comma
op_amp
id|mount_options
comma
op_amp
id|blocks
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blocks
)paren
(brace
r_int
id|rc
op_assign
id|reiserfs_resize
c_func
(paren
id|s
comma
id|blocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
(paren
op_star
id|flags
op_amp
id|MS_RDONLY
)paren
op_eq
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
multiline_comment|/* there is nothing to do to remount read-only fs as read-only fs */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|flags
op_amp
id|MS_RDONLY
)paren
(brace
multiline_comment|/* try to remount file system with read-only permissions */
r_if
c_cond
(paren
id|sb_state
c_func
(paren
id|rs
)paren
op_eq
id|REISERFS_VALID_FS
op_logical_or
id|s-&gt;u.reiserfs_sb.s_mount_state
op_ne
id|REISERFS_VALID_FS
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Mounting a rw partition read-only. */
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|set_sb_state
c_func
(paren
id|rs
comma
id|s-&gt;u.reiserfs_sb.s_mount_state
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;u.reiserfs_sb.s_mount_state
op_assign
id|sb_state
c_func
(paren
id|rs
)paren
suffix:semicolon
id|s-&gt;s_flags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
multiline_comment|/* now it is safe to call journal_begin */
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Mount a partition which is read-only, read-write */
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|s-&gt;u.reiserfs_sb.s_mount_state
op_assign
id|sb_state
c_func
(paren
id|rs
)paren
suffix:semicolon
id|s-&gt;s_flags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
id|set_sb_state
c_func
(paren
id|rs
comma
id|REISERFS_ERROR_FS
)paren
suffix:semicolon
multiline_comment|/* mark_buffer_dirty (SB_BUFFER_WITH_SB (s), 1); */
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
id|s-&gt;u.reiserfs_sb.s_mount_state
op_assign
id|REISERFS_VALID_FS
suffix:semicolon
)brace
multiline_comment|/* this will force a full flush of all journal lists */
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|1
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_bitmaps
r_static
r_int
id|read_bitmaps
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|bmp
comma
id|dl
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
suffix:semicolon
id|SB_AP_BITMAP
(paren
id|s
)paren
op_assign
id|reiserfs_kmalloc
(paren
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
op_star
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
comma
id|GFP_NOFS
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|memset
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
op_star
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
multiline_comment|/* reiserfs leaves the first 64k unused so that any partition&n;       labeling scheme currently used will have enough space. Then we&n;       need one block for the super.  -Hans */
id|bmp
op_assign
(paren
id|REISERFS_DISK_OFFSET_IN_BYTES
op_div
id|s-&gt;s_blocksize
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* first of bitmap blocks */
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
l_int|0
)braket
op_assign
id|reiserfs_bread
(paren
id|s
comma
id|bmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
l_int|0
)braket
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|bmp
op_assign
id|dl
op_assign
id|s-&gt;s_blocksize
op_star
l_int|8
suffix:semicolon
id|i
OL
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
op_assign
id|reiserfs_bread
(paren
id|s
comma
id|bmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
id|bmp
op_add_assign
id|dl
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_old_bitmaps
r_static
r_int
id|read_old_bitmaps
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
suffix:semicolon
r_int
id|bmp1
op_assign
(paren
id|REISERFS_OLD_DISK_OFFSET_IN_BYTES
op_div
id|s-&gt;s_blocksize
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* first of bitmap blocks */
multiline_comment|/* read true bitmap */
id|SB_AP_BITMAP
(paren
id|s
)paren
op_assign
id|reiserfs_kmalloc
(paren
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
op_star
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
comma
id|GFP_NOFS
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|memset
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
op_star
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
op_assign
id|reiserfs_bread
(paren
id|s
comma
id|bmp1
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_bitmap
r_void
id|check_bitmap
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|free
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|SB_BLOCK_COUNT
(paren
id|s
)paren
)paren
(brace
id|buf
op_assign
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
op_div
(paren
id|s-&gt;s_blocksize
op_star
l_int|8
)paren
)braket
op_member_access_from_pointer
id|b_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_test_le_bit
(paren
id|i
op_mod
(paren
id|s-&gt;s_blocksize
op_star
l_int|8
)paren
comma
id|buf
)paren
)paren
id|free
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free
op_ne
id|SB_FREE_BLOCKS
(paren
id|s
)paren
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-4000: check_bitmap: %d free blocks, must be %d&bslash;n&quot;
comma
id|free
comma
id|SB_FREE_BLOCKS
(paren
id|s
)paren
)paren
suffix:semicolon
)brace
DECL|function|read_super_block
r_static
r_int
id|read_super_block
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
id|bh
op_assign
id|sb_bread
(paren
id|s
comma
id|offset
op_div
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
(paren
l_string|&quot;read_super_block: &quot;
l_string|&quot;bread failed (dev %s, block %ld, size %ld)&bslash;n&quot;
comma
id|s-&gt;s_id
comma
id|offset
op_div
id|s-&gt;s_blocksize
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rs
op_assign
(paren
r_struct
id|reiserfs_super_block
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_reiserfs_magic_string
(paren
id|rs
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;read_super_block: &quot;
l_string|&quot;can&squot;t find a reiserfs filesystem on (dev %s, block %lu, size %ld)&bslash;n&quot;
comma
id|s-&gt;s_id
comma
id|bh-&gt;b_blocknr
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// ok, reiserfs signature (old or new) found in at the given offset
singleline_comment|//    
id|brelse
(paren
id|bh
)paren
suffix:semicolon
id|sb_set_blocksize
(paren
id|s
comma
id|sb_blocksize
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|reiserfs_bread
(paren
id|s
comma
id|offset
op_div
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;read_super_block: &quot;
l_string|&quot;bread failed (dev %s, block %ld, size %ld)&bslash;n&quot;
comma
id|s-&gt;s_id
comma
id|offset
op_div
id|s-&gt;s_blocksize
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|rs
op_assign
(paren
r_struct
id|reiserfs_super_block
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_reiserfs_magic_string
(paren
id|rs
)paren
op_logical_or
id|sb_blocksize
c_func
(paren
id|rs
)paren
op_ne
id|s-&gt;s_blocksize
)paren
(brace
id|printk
(paren
l_string|&quot;read_super_block: &quot;
l_string|&quot;can&squot;t find a reiserfs filesystem on (dev %s, block %lu, size %ld)&bslash;n&quot;
comma
id|s-&gt;s_id
comma
id|bh-&gt;b_blocknr
comma
id|s-&gt;s_blocksize
)paren
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;read_super_block: can&squot;t find a reiserfs filesystem on dev %s.&bslash;n&quot;
comma
id|s-&gt;s_id
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* must check to be sure we haven&squot;t pulled an old format super out&n;    ** of the old format&squot;s log.  This is a kludge of a check, but it&n;    ** will work.  If block we&squot;ve just read in is inside the&n;    ** journal for that super, it can&squot;t be valid.  &n;    */
r_if
c_cond
(paren
id|bh-&gt;b_blocknr
op_ge
id|sb_journal_block
c_func
(paren
id|rs
)paren
op_logical_and
id|bh-&gt;b_blocknr
OL
(paren
id|sb_journal_block
c_func
(paren
id|rs
)paren
op_plus
id|JOURNAL_BLOCK_COUNT
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;super-459: read_super_block: &quot;
l_string|&quot;super found at block %lu is within its own log. &quot;
l_string|&quot;It must not be of this format type.&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
op_assign
id|bh
suffix:semicolon
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
op_assign
id|rs
suffix:semicolon
id|s-&gt;s_op
op_assign
op_amp
id|reiserfs_sops
suffix:semicolon
multiline_comment|/* new format is limited by the 32 bit wide i_blocks field, want to&n;    ** be one full block below that.&n;    */
id|s-&gt;s_maxbytes
op_assign
(paren
l_int|512LL
op_lshift
l_int|32
)paren
op_minus
id|s-&gt;s_blocksize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* after journal replay, reread all bitmap and super blocks */
DECL|function|reread_meta_blocks
r_static
r_int
id|reread_meta_blocks
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
(paren
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reread_meta_blocks, error reading the super&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
c_func
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reread_meta_blocks, error reading bitmap block number %d at %ld&bslash;n&quot;
comma
id|i
comma
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|/////////////////////////////////////////////////////
singleline_comment|// hash detection stuff
singleline_comment|// if root directory is empty - we set default - Yura&squot;s - hash and
singleline_comment|// warn about it
singleline_comment|// FIXME: we look for only one name in a directory. If tea and yura
singleline_comment|// bith have the same value - we ask user to send report to the
singleline_comment|// mailing list
DECL|function|find_hash_out
id|__u32
id|find_hash_out
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|cpu_key
id|key
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
id|__u32
id|hash
op_assign
id|DEFAULT_HASH
suffix:semicolon
id|inode
op_assign
id|s-&gt;s_root-&gt;d_inode
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|make_cpu_key
(paren
op_amp
id|key
comma
id|inode
comma
op_complement
l_int|0
comma
id|TYPE_DIRENTRY
comma
l_int|3
)paren
suffix:semicolon
id|retval
op_assign
id|search_by_entry_key
(paren
id|s
comma
op_amp
id|key
comma
op_amp
id|path
comma
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|UNSET_HASH
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|NAME_NOT_FOUND
)paren
id|de.de_entry_num
op_decrement
suffix:semicolon
id|set_de_name_and_namelen
(paren
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
op_eq
id|DOT_DOT_OFFSET
)paren
(brace
multiline_comment|/* allow override in this case */
r_if
c_cond
(paren
id|reiserfs_rupasov_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|hash
op_assign
id|YURA_HASH
suffix:semicolon
)brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;reiserfs: FS seems to be empty, autodetect &quot;
l_string|&quot;is using the default hash&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_HASH_VALUE
c_func
(paren
id|yura_hash
(paren
id|de.de_name
comma
id|de.de_namelen
)paren
)paren
op_eq
id|GET_HASH_VALUE
c_func
(paren
id|keyed_hash
(paren
id|de.de_name
comma
id|de.de_namelen
)paren
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;reiserfs: Could not detect hash function &quot;
l_string|&quot;please mount with -o hash={tea,rupasov,r5}&bslash;n&quot;
)paren
suffix:semicolon
id|hash
op_assign
id|UNSET_HASH
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_HASH_VALUE
c_func
(paren
id|deh_offset
c_func
(paren
op_amp
(paren
id|de.de_deh
(braket
id|de.de_entry_num
)braket
)paren
)paren
)paren
op_eq
id|GET_HASH_VALUE
(paren
id|yura_hash
(paren
id|de.de_name
comma
id|de.de_namelen
)paren
)paren
)paren
id|hash
op_assign
id|YURA_HASH
suffix:semicolon
r_else
id|hash
op_assign
id|TEA_HASH
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|hash
suffix:semicolon
)brace
singleline_comment|// finds out which hash names are sorted with
DECL|function|what_hash
r_static
r_int
id|what_hash
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|__u32
id|code
suffix:semicolon
id|code
op_assign
id|sb_hash_function_code
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
multiline_comment|/* reiserfs_hash_detect() == true if any of the hash mount options&n;    ** were used.  We must check them to make sure the user isn&squot;t&n;    ** using a bad hash value&n;    */
r_if
c_cond
(paren
id|code
op_eq
id|UNSET_HASH
op_logical_or
id|reiserfs_hash_detect
c_func
(paren
id|s
)paren
)paren
id|code
op_assign
id|find_hash_out
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
op_ne
id|UNSET_HASH
op_logical_and
id|reiserfs_hash_detect
c_func
(paren
id|s
)paren
)paren
(brace
multiline_comment|/* detection has found the hash, and we must check against the &n;&t;** mount options &n;&t;*/
r_if
c_cond
(paren
id|reiserfs_rupasov_hash
c_func
(paren
id|s
)paren
op_logical_and
id|code
op_ne
id|YURA_HASH
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;REISERFS: Error, tea hash detected, &quot;
l_string|&quot;unable to force rupasov hash&bslash;n&quot;
)paren
suffix:semicolon
id|code
op_assign
id|UNSET_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_tea_hash
c_func
(paren
id|s
)paren
op_logical_and
id|code
op_ne
id|TEA_HASH
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;REISERFS: Error, rupasov hash detected, &quot;
l_string|&quot;unable to force tea hash&bslash;n&quot;
)paren
suffix:semicolon
id|code
op_assign
id|UNSET_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_r5_hash
c_func
(paren
id|s
)paren
op_logical_and
id|code
op_ne
id|R5_HASH
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;REISERFS: Error, r5 hash detected, &quot;
l_string|&quot;unable to force r5 hash&bslash;n&quot;
)paren
suffix:semicolon
id|code
op_assign
id|UNSET_HASH
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* find_hash_out was not called or could not determine the hash */
r_if
c_cond
(paren
id|reiserfs_rupasov_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|code
op_assign
id|YURA_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_tea_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|code
op_assign
id|TEA_HASH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|reiserfs_r5_hash
c_func
(paren
id|s
)paren
)paren
(brace
id|code
op_assign
id|R5_HASH
suffix:semicolon
)brace
)brace
multiline_comment|/* if we are mounted RW, and we have a new valid hash code, update &n;    ** the super&n;    */
r_if
c_cond
(paren
id|code
op_ne
id|UNSET_HASH
op_logical_and
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
op_logical_and
id|code
op_ne
id|sb_hash_function_code
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
)paren
)paren
(brace
id|set_sb_hash_function_code
c_func
(paren
id|SB_DISK_SUPER_BLOCK
c_func
(paren
id|s
)paren
comma
id|code
)paren
suffix:semicolon
)brace
r_return
id|code
suffix:semicolon
)brace
singleline_comment|// return pointer to appropriate function
DECL|function|hash_function
r_static
id|hashf_t
id|hash_function
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_switch
c_cond
(paren
id|what_hash
(paren
id|s
)paren
)paren
(brace
r_case
id|TEA_HASH
suffix:colon
id|reiserfs_warning
(paren
l_string|&quot;Using tea hash to sort names&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|keyed_hash
suffix:semicolon
r_case
id|YURA_HASH
suffix:colon
id|reiserfs_warning
(paren
l_string|&quot;Using rupasov hash to sort names&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|yura_hash
suffix:semicolon
r_case
id|R5_HASH
suffix:colon
id|reiserfs_warning
(paren
l_string|&quot;Using r5 hash to sort names&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|r5_hash
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|// this is used to set up correct value for old partitions
DECL|function|function2code
r_int
id|function2code
(paren
id|hashf_t
id|func
)paren
(brace
r_if
c_cond
(paren
id|func
op_eq
id|keyed_hash
)paren
r_return
id|TEA_HASH
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
id|yura_hash
)paren
r_return
id|YURA_HASH
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
id|r5_hash
)paren
r_return
id|R5_HASH
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
singleline_comment|// should never happen 
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_read_super
r_struct
id|super_block
op_star
id|reiserfs_read_super
(paren
r_struct
id|super_block
op_star
id|s
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_int
id|size
suffix:semicolon
r_struct
id|inode
op_star
id|root_inode
suffix:semicolon
r_int
id|j
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|old_format
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
r_int
id|jinit_done
op_assign
l_int|0
suffix:semicolon
r_struct
id|reiserfs_iget4_args
id|args
suffix:semicolon
id|memset
(paren
op_amp
id|s-&gt;u.reiserfs_sb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|reiserfs_sb_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parse_options
(paren
(paren
r_char
op_star
)paren
id|data
comma
op_amp
(paren
id|s-&gt;u.reiserfs_sb.s_mount_opt
)paren
comma
op_amp
id|blocks
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reserfs: resize option for remount only&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|size
op_assign
id|block_size
c_func
(paren
id|s-&gt;s_dev
)paren
suffix:semicolon
id|sb_set_blocksize
c_func
(paren
id|s
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* read block (64-th 1k block), which can contain reiserfs super block */
r_if
c_cond
(paren
id|read_super_block
(paren
id|s
comma
id|REISERFS_DISK_OFFSET_IN_BYTES
)paren
)paren
(brace
singleline_comment|// try old format (undistributed bitmap, super block in 8-th 1k block of a device)
id|sb_set_blocksize
c_func
(paren
id|s
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_super_block
(paren
id|s
comma
id|REISERFS_OLD_DISK_OFFSET_IN_BYTES
)paren
)paren
r_goto
id|error
suffix:semicolon
r_else
id|old_format
op_assign
l_int|1
suffix:semicolon
)brace
id|s-&gt;u.reiserfs_sb.s_mount_state
op_assign
id|SB_REISERFS_STATE
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;u.reiserfs_sb.s_mount_state
op_assign
id|REISERFS_VALID_FS
suffix:semicolon
r_if
c_cond
(paren
id|old_format
ques
c_cond
id|read_old_bitmaps
c_func
(paren
id|s
)paren
suffix:colon
id|read_bitmaps
c_func
(paren
id|s
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;reiserfs_read_super: unable to read bitmap&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|printk
c_func
(paren
l_string|&quot;reiserfs:warning: CONFIG_REISERFS_CHECK is set ON&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reiserfs:warning: - it is slow mode for debugging.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// set_device_ro(s-&gt;s_dev, 1) ;
r_if
c_cond
(paren
id|journal_init
c_func
(paren
id|s
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs_read_super: unable to initialize journal space&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_else
(brace
id|jinit_done
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* once this is set, journal_release must be called&n;&t;&t;&t; ** if we error out of the mount &n;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|reread_meta_blocks
c_func
(paren
id|s
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs_read_super: unable to reread meta blocks after journal init&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|replay_only
(paren
id|s
)paren
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|is_read_only
c_func
(paren
id|s-&gt;s_dev
)paren
op_logical_and
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;clm-7000: Detected readonly device, marking FS readonly&bslash;n&quot;
)paren
suffix:semicolon
id|s-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
)brace
id|args.objectid
op_assign
id|REISERFS_ROOT_PARENT_OBJECTID
suffix:semicolon
id|root_inode
op_assign
id|iget4
(paren
id|s
comma
id|REISERFS_ROOT_OBJECTID
comma
l_int|0
comma
(paren
r_void
op_star
)paren
(paren
op_amp
id|args
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_inode
)paren
(brace
id|printk
(paren
l_string|&quot;reiserfs_read_super: get root inode failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|s-&gt;s_root
op_assign
id|d_alloc_root
c_func
(paren
id|root_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;s_root
)paren
(brace
id|iput
c_func
(paren
id|root_inode
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
singleline_comment|// define and initialize hash function
id|s-&gt;u.reiserfs_sb.s_hash_function
op_assign
id|hash_function
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;u.reiserfs_sb.s_hash_function
op_eq
l_int|NULL
)paren
(brace
id|dput
c_func
(paren
id|s-&gt;s_root
)paren
suffix:semicolon
id|s-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|s-&gt;s_flags
op_amp
id|MS_RDONLY
)paren
)paren
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
r_int
id|old_magic
suffix:semicolon
id|old_magic
op_assign
id|strncmp
(paren
id|rs-&gt;s_magic
comma
id|REISER2FS_SUPER_MAGIC_STRING
comma
id|strlen
(paren
id|REISER2FS_SUPER_MAGIC_STRING
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_magic
op_logical_and
id|le16_to_cpu
c_func
(paren
id|rs-&gt;s_version
)paren
op_ne
l_int|0
)paren
(brace
id|dput
c_func
(paren
id|s-&gt;s_root
)paren
suffix:semicolon
id|s-&gt;s_root
op_assign
l_int|NULL
suffix:semicolon
id|reiserfs_warning
c_func
(paren
l_string|&quot;reiserfs: wrong version/magic combination in the super-block&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|set_sb_state
c_func
(paren
id|rs
comma
id|REISERFS_ERROR_FS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_magic
)paren
(brace
singleline_comment|// filesystem created under 3.5.x found
r_if
c_cond
(paren
op_logical_neg
id|old_format_only
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;reiserfs: converting 3.5.x filesystem to the new format&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// after this 3.5.x will not be able to mount this partition
id|memcpy
(paren
id|rs-&gt;s_magic
comma
id|REISER2FS_SUPER_MAGIC_STRING
comma
r_sizeof
(paren
id|REISER2FS_SUPER_MAGIC_STRING
)paren
)paren
suffix:semicolon
id|reiserfs_convert_objectid_map_v1
c_func
(paren
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;reiserfs: using 3.5.x disk format&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// new format found
id|set_bit
(paren
id|REISERFS_CONVERT
comma
op_amp
(paren
id|s-&gt;u.reiserfs_sb.s_mount_opt
)paren
)paren
suffix:semicolon
)brace
singleline_comment|// mark hash in super block: it could be unset. overwrite should be ok
id|set_sb_hash_function_code
c_func
(paren
id|rs
comma
id|function2code
c_func
(paren
id|s-&gt;u.reiserfs_sb.s_hash_function
)paren
)paren
suffix:semicolon
id|journal_mark_dirty
c_func
(paren
op_amp
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|s
comma
l_int|1
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|rs-&gt;s_magic
comma
id|REISER2FS_SUPER_MAGIC_STRING
comma
id|strlen
(paren
id|REISER2FS_SUPER_MAGIC_STRING
)paren
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;reiserfs: using 3.5.x disk format&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|reiserfs_proc_info_init
c_func
(paren
id|s
)paren
suffix:semicolon
id|reiserfs_proc_register
c_func
(paren
id|s
comma
l_string|&quot;version&quot;
comma
id|reiserfs_version_in_proc
)paren
suffix:semicolon
id|reiserfs_proc_register
c_func
(paren
id|s
comma
l_string|&quot;super&quot;
comma
id|reiserfs_super_in_proc
)paren
suffix:semicolon
id|reiserfs_proc_register
c_func
(paren
id|s
comma
l_string|&quot;per-level&quot;
comma
id|reiserfs_per_level_in_proc
)paren
suffix:semicolon
id|reiserfs_proc_register
c_func
(paren
id|s
comma
l_string|&quot;bitmap&quot;
comma
id|reiserfs_bitmap_in_proc
)paren
suffix:semicolon
id|reiserfs_proc_register
c_func
(paren
id|s
comma
l_string|&quot;on-disk-super&quot;
comma
id|reiserfs_on_disk_super_in_proc
)paren
suffix:semicolon
id|reiserfs_proc_register
c_func
(paren
id|s
comma
l_string|&quot;oidmap&quot;
comma
id|reiserfs_oidmap_in_proc
)paren
suffix:semicolon
id|reiserfs_proc_register
c_func
(paren
id|s
comma
l_string|&quot;journal&quot;
comma
id|reiserfs_journal_in_proc
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
(paren
id|s-&gt;u.reiserfs_sb.s_wait
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|reiserfs_get_version_string
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
id|error
suffix:colon
r_if
c_cond
(paren
id|jinit_done
)paren
(brace
multiline_comment|/* kill the commit thread, free journal ram */
id|journal_release_error
c_func
(paren
l_int|NULL
comma
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|SB_BMAP_NR
(paren
id|s
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
)paren
id|brelse
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
)paren
id|reiserfs_kfree
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
comma
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
op_star
id|SB_BMAP_NR
(paren
id|s
)paren
comma
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
id|brelse
c_func
(paren
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_statfs
r_int
id|reiserfs_statfs
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* changed to accomodate gcc folks.*/
id|buf-&gt;f_type
op_assign
id|REISERFS_SUPER_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
id|s-&gt;s_blocksize
suffix:semicolon
id|buf-&gt;f_blocks
op_assign
id|sb_block_count
c_func
(paren
id|rs
)paren
op_minus
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
op_minus
l_int|1
suffix:semicolon
id|buf-&gt;f_bfree
op_assign
id|sb_free_blocks
c_func
(paren
id|rs
)paren
suffix:semicolon
id|buf-&gt;f_bavail
op_assign
id|buf-&gt;f_bfree
suffix:semicolon
id|buf-&gt;f_files
op_assign
op_minus
l_int|1
suffix:semicolon
id|buf-&gt;f_ffree
op_assign
op_minus
l_int|1
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
(paren
id|REISERFS_MAX_NAME_LEN
(paren
id|s-&gt;s_blocksize
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|DECLARE_FSTYPE_DEV
c_func
(paren
id|reiserfs_fs_type
comma
l_string|&quot;reiserfs&quot;
comma
id|reiserfs_read_super
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// this is exactly what 2.3.99-pre9&squot;s init_ext2_fs is
singleline_comment|//
DECL|function|init_reiserfs_fs
r_static
r_int
id|__init
id|init_reiserfs_fs
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
id|init_inodecache
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out1
suffix:semicolon
id|reiserfs_proc_info_global_init
c_func
(paren
)paren
suffix:semicolon
id|reiserfs_proc_register_global
c_func
(paren
l_string|&quot;version&quot;
comma
id|reiserfs_global_version_in_proc
)paren
suffix:semicolon
id|err
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|reiserfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
id|reiserfs_proc_unregister_global
c_func
(paren
l_string|&quot;version&quot;
)paren
suffix:semicolon
id|reiserfs_proc_info_global_done
c_func
(paren
)paren
suffix:semicolon
id|destroy_inodecache
c_func
(paren
)paren
suffix:semicolon
id|out1
suffix:colon
r_return
id|err
suffix:semicolon
)brace
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ReiserFS journaled filesystem&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Hans Reiser &lt;reiser@namesys.com&gt;&quot;
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
singleline_comment|//
singleline_comment|// this is exactly what 2.3.99-pre9&squot;s init_ext2_fs is
singleline_comment|//
DECL|function|exit_reiserfs_fs
r_static
r_void
id|__exit
id|exit_reiserfs_fs
c_func
(paren
r_void
)paren
(brace
id|reiserfs_proc_unregister_global
c_func
(paren
l_string|&quot;version&quot;
)paren
suffix:semicolon
id|reiserfs_proc_info_global_done
c_func
(paren
)paren
suffix:semicolon
id|unregister_filesystem
c_func
(paren
op_amp
id|reiserfs_fs_type
)paren
suffix:semicolon
id|destroy_inodecache
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|init_reiserfs_fs
id|module_init
c_func
(paren
id|init_reiserfs_fs
)paren
suffix:semicolon
DECL|variable|exit_reiserfs_fs
id|module_exit
c_func
(paren
id|exit_reiserfs_fs
)paren
suffix:semicolon
eof
