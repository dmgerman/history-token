multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
multiline_comment|/* Reiserfs block (de)allocator, bitmap-based. */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/reiserfs_fs_sb.h&gt;
macro_line|#include &lt;linux/reiserfs_fs_i.h&gt;
DECL|macro|PREALLOCATION_SIZE
mdefine_line|#define PREALLOCATION_SIZE 9
multiline_comment|/* different reiserfs block allocator options */
DECL|macro|SB_ALLOC_OPTS
mdefine_line|#define SB_ALLOC_OPTS(s) (REISERFS_SB(s)-&gt;s_alloc_options.bits)
DECL|macro|_ALLOC_concentrating_formatted_nodes
mdefine_line|#define  _ALLOC_concentrating_formatted_nodes 0
DECL|macro|_ALLOC_displacing_large_files
mdefine_line|#define  _ALLOC_displacing_large_files 1
DECL|macro|_ALLOC_displacing_new_packing_localities
mdefine_line|#define  _ALLOC_displacing_new_packing_localities 2
DECL|macro|_ALLOC_old_hashed_relocation
mdefine_line|#define  _ALLOC_old_hashed_relocation 3
DECL|macro|_ALLOC_new_hashed_relocation
mdefine_line|#define  _ALLOC_new_hashed_relocation 4
DECL|macro|_ALLOC_skip_busy
mdefine_line|#define  _ALLOC_skip_busy 5
DECL|macro|_ALLOC_displace_based_on_dirid
mdefine_line|#define  _ALLOC_displace_based_on_dirid 6
DECL|macro|_ALLOC_hashed_formatted_nodes
mdefine_line|#define  _ALLOC_hashed_formatted_nodes 7
DECL|macro|_ALLOC_old_way
mdefine_line|#define  _ALLOC_old_way 8
DECL|macro|_ALLOC_hundredth_slices
mdefine_line|#define  _ALLOC_hundredth_slices 9
DECL|macro|concentrating_formatted_nodes
mdefine_line|#define  concentrating_formatted_nodes(s)&t;test_bit(_ALLOC_concentrating_formatted_nodes, &amp;SB_ALLOC_OPTS(s))
DECL|macro|displacing_large_files
mdefine_line|#define  displacing_large_files(s)&t;&t;test_bit(_ALLOC_displacing_large_files, &amp;SB_ALLOC_OPTS(s))
DECL|macro|displacing_new_packing_localities
mdefine_line|#define  displacing_new_packing_localities(s)&t;test_bit(_ALLOC_displacing_new_packing_localities, &amp;SB_ALLOC_OPTS(s))
DECL|macro|SET_OPTION
mdefine_line|#define SET_OPTION(optname) &bslash;&n;   do { &bslash;&n;        reiserfs_warning(&quot;reiserfs: option &bslash;&quot;%s&bslash;&quot; is set&bslash;n&quot;, #optname); &bslash;&n;        set_bit(_ALLOC_ ## optname , &amp;SB_ALLOC_OPTS(s)); &bslash;&n;    } while(0)
DECL|macro|TEST_OPTION
mdefine_line|#define TEST_OPTION(optname, s) &bslash;&n;    test_bit(_ALLOC_ ## optname , &amp;SB_ALLOC_OPTS(s))
DECL|function|get_bit_address
r_static
r_inline
r_void
id|get_bit_address
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|block
comma
r_int
op_star
id|bmap_nr
comma
r_int
op_star
id|offset
)paren
(brace
multiline_comment|/* It is in the bitmap block number equal to the block&n;     * number divided by the number of bits in a block. */
op_star
id|bmap_nr
op_assign
id|block
op_div
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Within that bitmap block it is located at bit offset *offset. */
op_star
id|offset
op_assign
id|block
op_amp
(paren
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
DECL|function|is_reusable
r_int
id|is_reusable
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|block
comma
r_int
id|bit_value
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
l_int|0
op_logical_or
id|block
op_ge
id|SB_BLOCK_COUNT
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4010: is_reusable: block number is out of range %lu (%u)&bslash;n&quot;
comma
id|block
comma
id|SB_BLOCK_COUNT
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* it can&squot;t be one of the bitmap blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|block
op_eq
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh-&gt;b_blocknr
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs: 4020: is_reusable: &quot;
l_string|&quot;bitmap block %lu(%u) can&squot;t be freed or reused&bslash;n&quot;
comma
id|block
comma
id|SB_BMAP_NR
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|get_bit_address
(paren
id|s
comma
id|block
comma
op_amp
id|i
comma
op_amp
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SB_BMAP_NR
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4030: is_reusable: there is no so many bitmap blocks: &quot;
l_string|&quot;block=%lu, bitmap_nr=%d&bslash;n&quot;
comma
id|block
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bit_value
op_eq
l_int|0
op_logical_and
id|reiserfs_test_le_bit
c_func
(paren
id|j
comma
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh-&gt;b_data
)paren
)paren
op_logical_or
(paren
id|bit_value
op_eq
l_int|1
op_logical_and
id|reiserfs_test_le_bit
c_func
(paren
id|j
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh-&gt;b_data
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4040: is_reusable: corresponding bit of block %lu does not &quot;
l_string|&quot;match required value (i==%d, j==%d) test_bit==%d&bslash;n&quot;
comma
id|block
comma
id|i
comma
id|j
comma
id|reiserfs_test_le_bit
(paren
id|j
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
dot
id|bh-&gt;b_data
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bit_value
op_eq
l_int|0
op_logical_and
id|block
op_eq
id|SB_ROOT_BLOCK
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4050: is_reusable: this is root block (%u), &quot;
l_string|&quot;it must be busy&bslash;n&quot;
comma
id|SB_ROOT_BLOCK
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_REISERFS_CHECK */
multiline_comment|/* searches in journal structures for a given block number (bmap, off). If block&n;   is found in reiserfs journal it suggests next free block candidate to test. */
DECL|function|is_block_in_journal
r_static
r_inline
r_int
id|is_block_in_journal
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|bmap
comma
r_int
id|off
comma
r_int
op_star
id|next
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_in_journal
(paren
id|s
comma
id|bmap
comma
id|off
comma
l_int|1
comma
op_amp
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|tmp
)paren
(brace
multiline_comment|/* hint supplied */
op_star
id|next
op_assign
id|tmp
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|scan_bitmap.in_journal_hint
)paren
suffix:semicolon
)brace
r_else
(brace
(paren
op_star
id|next
)paren
op_assign
id|off
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* inc offset to avoid looping. */
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|scan_bitmap.in_journal_nohint
)paren
suffix:semicolon
)brace
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|scan_bitmap.retry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* it searches for a window of zero bits with given minimum and maximum lengths in one bitmap&n; * block; */
DECL|function|scan_bitmap_block
r_static
r_int
id|scan_bitmap_block
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
id|bmap_n
comma
r_int
op_star
id|beg
comma
r_int
id|boundary
comma
r_int
id|min
comma
r_int
id|max
comma
r_int
id|unfm
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
r_struct
id|reiserfs_bitmap_info
op_star
id|bi
op_assign
op_amp
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|bmap_n
)braket
suffix:semicolon
r_int
id|end
comma
id|next
suffix:semicolon
r_int
id|org
op_assign
op_star
id|beg
suffix:semicolon
id|RFALSE
c_func
(paren
id|bmap_n
op_ge
id|SB_BMAP_NR
(paren
id|s
)paren
comma
l_string|&quot;Bitmap %d is out of range (0..%d)&bslash;n&quot;
comma
id|bmap_n
comma
id|SB_BMAP_NR
(paren
id|s
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|scan_bitmap.bmap
)paren
suffix:semicolon
multiline_comment|/* this is unclear and lacks comments, explain how journal bitmaps&n;   work here for the reader.  Convey a sense of the design here. What&n;   is a window? */
multiline_comment|/* - I mean `a window of zero bits&squot; as in description of this function - Zam. */
r_if
c_cond
(paren
op_logical_neg
id|bi
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Hey, bitmap info pointer is zero for bitmap %d!&bslash;n&quot;
comma
id|bmap_n
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_locked
(paren
id|bi-&gt;bh
)paren
)paren
(brace
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|scan_bitmap.wait
)paren
suffix:semicolon
id|__wait_on_buffer
(paren
id|bi-&gt;bh
)paren
suffix:semicolon
)brace
multiline_comment|/* If we know that first zero bit is only one or first zero bit is&n;       closer to the end of bitmap than our start pointer */
r_if
c_cond
(paren
id|bi-&gt;first_zero_hint
OG
op_star
id|beg
op_logical_or
id|bi-&gt;free_count
op_eq
l_int|1
)paren
op_star
id|beg
op_assign
id|bi-&gt;first_zero_hint
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cont
suffix:colon
r_if
c_cond
(paren
id|bi-&gt;free_count
OL
id|min
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// No free blocks in this bitmap
multiline_comment|/* search for a first zero bit -- beggining of a window */
op_star
id|beg
op_assign
id|reiserfs_find_next_zero_le_bit
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|bi-&gt;bh-&gt;b_data
)paren
comma
id|boundary
comma
op_star
id|beg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|beg
op_plus
id|min
OG
id|boundary
)paren
(brace
multiline_comment|/* search for a zero bit fails or the rest of bitmap block&n;&t;&t;&t;&t;      * cannot contain a zero window of minimum size */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unfm
op_logical_and
id|is_block_in_journal
c_func
(paren
id|s
comma
id|bmap_n
comma
op_star
id|beg
comma
id|beg
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* first zero bit found; we check next bits */
r_for
c_loop
(paren
id|end
op_assign
op_star
id|beg
op_plus
l_int|1
suffix:semicolon
suffix:semicolon
id|end
op_increment
)paren
(brace
r_if
c_cond
(paren
id|end
op_ge
op_star
id|beg
op_plus
id|max
op_logical_or
id|end
op_ge
id|boundary
op_logical_or
id|reiserfs_test_le_bit
(paren
id|end
comma
id|bi-&gt;bh-&gt;b_data
)paren
)paren
(brace
id|next
op_assign
id|end
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* finding the other end of zero bit window requires looking into journal structures (in&n;&t;     * case of searching for free blocks for unformatted nodes) */
r_if
c_cond
(paren
id|unfm
op_logical_and
id|is_block_in_journal
c_func
(paren
id|s
comma
id|bmap_n
comma
id|end
comma
op_amp
id|next
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* now (*beg) points to beginning of zero bits window,&n;&t; * (end) points to one bit after the window end */
r_if
c_cond
(paren
id|end
op_minus
op_star
id|beg
op_ge
id|min
)paren
(brace
multiline_comment|/* it seems we have found window of proper size */
r_int
id|i
suffix:semicolon
id|reiserfs_prepare_for_journal
(paren
id|s
comma
id|bi-&gt;bh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* try to set all blocks used checking are they still free */
r_for
c_loop
(paren
id|i
op_assign
op_star
id|beg
suffix:semicolon
id|i
OL
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* It seems that we should not check in journal again. */
r_if
c_cond
(paren
id|reiserfs_test_and_set_le_bit
(paren
id|i
comma
id|bi-&gt;bh-&gt;b_data
)paren
)paren
(brace
multiline_comment|/* bit was set by another process&n;&t;&t;     * while we slept in prepare_for_journal() */
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|scan_bitmap.stolen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
op_star
id|beg
op_plus
id|min
)paren
(brace
multiline_comment|/* we can continue with smaller set of allocated blocks,&n;&t;&t;&t;&t;&t;   * if length of this set is more or equal to `min&squot; */
id|end
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* otherwise we clear all bit were set ... */
r_while
c_loop
(paren
op_decrement
id|i
op_ge
op_star
id|beg
)paren
id|reiserfs_test_and_clear_le_bit
(paren
id|i
comma
id|bi-&gt;bh-&gt;b_data
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|s
comma
id|bi-&gt;bh
)paren
suffix:semicolon
op_star
id|beg
op_assign
id|max
c_func
(paren
id|org
comma
(paren
r_int
)paren
id|bi-&gt;first_zero_hint
)paren
suffix:semicolon
multiline_comment|/* ... and search again in current block from beginning */
r_goto
id|cont
suffix:semicolon
)brace
)brace
id|bi-&gt;free_count
op_sub_assign
(paren
id|end
op_minus
op_star
id|beg
)paren
suffix:semicolon
multiline_comment|/* if search started from zero_hint bit, and zero hint have not&n;                changed since, then we need to update first_zero_hint */
r_if
c_cond
(paren
id|bi-&gt;first_zero_hint
op_ge
op_star
id|beg
)paren
multiline_comment|/* no point in looking for free bit if there is not any */
id|bi-&gt;first_zero_hint
op_assign
(paren
id|bi-&gt;free_count
OG
l_int|0
)paren
ques
c_cond
id|reiserfs_find_next_zero_le_bit
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|bi-&gt;bh-&gt;b_data
)paren
comma
id|s-&gt;s_blocksize
op_lshift
l_int|3
comma
id|end
)paren
suffix:colon
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|bi-&gt;bh
)paren
suffix:semicolon
multiline_comment|/* free block count calculation */
id|reiserfs_prepare_for_journal
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
id|PUT_SB_FREE_BLOCKS
c_func
(paren
id|s
comma
id|SB_FREE_BLOCKS
c_func
(paren
id|s
)paren
op_minus
(paren
id|end
op_minus
op_star
id|beg
)paren
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
id|end
op_minus
(paren
op_star
id|beg
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|beg
op_assign
id|next
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Tries to find contiguous zero bit window (given size) in given region of&n; * bitmap and place new blocks there. Returns number of allocated blocks. */
DECL|function|scan_bitmap
r_static
r_int
id|scan_bitmap
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
op_star
id|start
comma
r_int
r_int
id|finish
comma
r_int
id|min
comma
r_int
id|max
comma
r_int
id|unfm
comma
r_int
r_int
id|file_block
)paren
(brace
r_int
id|nr_allocated
op_assign
l_int|0
suffix:semicolon
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
multiline_comment|/* find every bm and bmap and bmap_nr in this file, and change them all to bitmap_blocknr&n;     * - Hans, it is not a block number - Zam. */
r_int
id|bm
comma
id|off
suffix:semicolon
r_int
id|end_bm
comma
id|end_off
suffix:semicolon
r_int
id|off_max
op_assign
id|s-&gt;s_blocksize
op_lshift
l_int|3
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|scan_bitmap.call
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SB_FREE_BLOCKS
c_func
(paren
id|s
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// No point in looking for more free blocks
id|get_bit_address
(paren
id|s
comma
op_star
id|start
comma
op_amp
id|bm
comma
op_amp
id|off
)paren
suffix:semicolon
id|get_bit_address
(paren
id|s
comma
id|finish
comma
op_amp
id|end_bm
comma
op_amp
id|end_off
)paren
suffix:semicolon
singleline_comment|// With this option set first we try to find a bitmap that is at least 10%
singleline_comment|// free, and if that fails, then we fall back to old whole bitmap scanning
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|skip_busy
comma
id|s
)paren
op_logical_and
id|SB_FREE_BLOCKS
c_func
(paren
id|s
)paren
OG
id|SB_BLOCK_COUNT
c_func
(paren
id|s
)paren
op_div
l_int|20
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|bm
OL
id|end_bm
suffix:semicolon
id|bm
op_increment
comma
id|off
op_assign
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|off
op_logical_and
(paren
op_logical_neg
id|unfm
op_logical_or
(paren
id|file_block
op_ne
l_int|0
)paren
)paren
)paren
op_logical_or
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|bm
)braket
dot
id|free_count
OG
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
op_div
l_int|10
)paren
id|nr_allocated
op_assign
id|scan_bitmap_block
c_func
(paren
id|th
comma
id|bm
comma
op_amp
id|off
comma
id|off_max
comma
id|min
comma
id|max
comma
id|unfm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_allocated
)paren
r_goto
id|ret
suffix:semicolon
)brace
id|get_bit_address
(paren
id|s
comma
op_star
id|start
comma
op_amp
id|bm
comma
op_amp
id|off
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|bm
OL
id|end_bm
suffix:semicolon
id|bm
op_increment
comma
id|off
op_assign
l_int|0
)paren
(brace
id|nr_allocated
op_assign
id|scan_bitmap_block
c_func
(paren
id|th
comma
id|bm
comma
op_amp
id|off
comma
id|off_max
comma
id|min
comma
id|max
comma
id|unfm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_allocated
)paren
r_goto
id|ret
suffix:semicolon
)brace
id|nr_allocated
op_assign
id|scan_bitmap_block
c_func
(paren
id|th
comma
id|bm
comma
op_amp
id|off
comma
id|end_off
op_plus
l_int|1
comma
id|min
comma
id|max
comma
id|unfm
)paren
suffix:semicolon
id|ret
suffix:colon
op_star
id|start
op_assign
id|bm
op_star
id|off_max
op_plus
id|off
suffix:semicolon
r_return
id|nr_allocated
suffix:semicolon
)brace
DECL|function|_reiserfs_free_block
r_static
r_void
id|_reiserfs_free_block
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_struct
id|buffer_head
op_star
id|sbh
suffix:semicolon
r_struct
id|reiserfs_bitmap_info
op_star
id|apbi
suffix:semicolon
r_int
id|nr
comma
id|offset
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|s
comma
id|free_block
)paren
suffix:semicolon
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
id|sbh
op_assign
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
suffix:semicolon
id|apbi
op_assign
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
suffix:semicolon
id|get_bit_address
(paren
id|s
comma
id|block
comma
op_amp
id|nr
comma
op_amp
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
id|sb_bmap_nr
(paren
id|rs
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4075: reiserfs_free_block: &quot;
l_string|&quot;block %lu is out of range on %s&bslash;n&quot;
comma
id|block
comma
id|reiserfs_bdevname
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|apbi
(braket
id|nr
)braket
dot
id|bh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* clear bit for the given block in bit map */
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_test_and_clear_le_bit
(paren
id|offset
comma
id|apbi
(braket
id|nr
)braket
dot
id|bh-&gt;b_data
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4080: reiserfs_free_block: &quot;
l_string|&quot;free_block (%s:%lu)[dev:blocknr]: bit already cleared&bslash;n&quot;
comma
id|reiserfs_bdevname
(paren
id|s
)paren
comma
id|block
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
OL
id|apbi
(braket
id|nr
)braket
dot
id|first_zero_hint
)paren
(brace
id|apbi
(braket
id|nr
)braket
dot
id|first_zero_hint
op_assign
id|offset
suffix:semicolon
)brace
id|apbi
(braket
id|nr
)braket
dot
id|free_count
op_increment
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|apbi
(braket
id|nr
)braket
dot
id|bh
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|sbh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update super block */
id|set_sb_free_blocks
c_func
(paren
id|rs
comma
id|sb_free_blocks
c_func
(paren
id|rs
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|sbh
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|reiserfs_free_block
r_void
id|reiserfs_free_block
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|s
comma
l_string|&quot;vs-4061: trying to free block on nonexistent device&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|is_reusable
(paren
id|s
comma
id|block
comma
l_int|1
)paren
op_eq
l_int|0
comma
l_string|&quot;vs-4071: can not free such block&quot;
)paren
suffix:semicolon
multiline_comment|/* mark it before we clear it, just in case */
id|journal_mark_freed
c_func
(paren
id|th
comma
id|s
comma
id|block
)paren
suffix:semicolon
id|_reiserfs_free_block
c_func
(paren
id|th
comma
id|block
)paren
suffix:semicolon
)brace
multiline_comment|/* preallocated blocks don&squot;t need to be run through journal_mark_freed */
DECL|function|reiserfs_free_prealloc_block
r_void
id|reiserfs_free_prealloc_block
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
id|block
)paren
(brace
id|RFALSE
c_func
(paren
op_logical_neg
id|th-&gt;t_super
comma
l_string|&quot;vs-4060: trying to free block on nonexistent device&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|is_reusable
(paren
id|th-&gt;t_super
comma
id|block
comma
l_int|1
)paren
op_eq
l_int|0
comma
l_string|&quot;vs-4070: can not free such block&quot;
)paren
suffix:semicolon
id|_reiserfs_free_block
c_func
(paren
id|th
comma
id|block
)paren
suffix:semicolon
)brace
DECL|function|__discard_prealloc
r_static
r_void
id|__discard_prealloc
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|reiserfs_inode_info
op_star
id|ei
)paren
(brace
r_int
r_int
id|save
op_assign
id|ei-&gt;i_prealloc_block
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|ei-&gt;i_prealloc_count
OL
l_int|0
)paren
id|reiserfs_warning
c_func
(paren
l_string|&quot;zam-4001:%s: inode has negative prealloc blocks count.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|ei-&gt;i_prealloc_count
OG
l_int|0
)paren
(brace
id|reiserfs_free_prealloc_block
c_func
(paren
id|th
comma
id|ei-&gt;i_prealloc_block
)paren
suffix:semicolon
id|ei-&gt;i_prealloc_block
op_increment
suffix:semicolon
id|ei-&gt;i_prealloc_count
op_decrement
suffix:semicolon
)brace
id|ei-&gt;i_prealloc_block
op_assign
id|save
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
(paren
id|ei-&gt;i_prealloc_list
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* FIXME: It should be inline function */
DECL|function|reiserfs_discard_prealloc
r_void
id|reiserfs_discard_prealloc
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|reiserfs_inode_info
op_star
id|ei
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei-&gt;i_prealloc_count
)paren
(brace
id|__discard_prealloc
c_func
(paren
id|th
comma
id|ei
)paren
suffix:semicolon
)brace
)brace
DECL|function|reiserfs_discard_all_prealloc
r_void
id|reiserfs_discard_all_prealloc
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
)paren
(brace
r_struct
id|list_head
op_star
id|plist
op_assign
op_amp
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_prealloc_list
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|plist
)paren
)paren
(brace
r_struct
id|reiserfs_inode_info
op_star
id|ei
suffix:semicolon
id|ei
op_assign
id|list_entry
c_func
(paren
id|plist-&gt;next
comma
r_struct
id|reiserfs_inode_info
comma
id|i_prealloc_list
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|ei-&gt;i_prealloc_count
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;zam-4001:%s: inode is in prealloc list but has no preallocated blocks.&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
macro_line|#endif
id|__discard_prealloc
c_func
(paren
id|th
comma
id|ei
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* block allocator related options are parsed here */
DECL|function|reiserfs_parse_alloc_options
r_int
id|reiserfs_parse_alloc_options
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_char
op_star
id|options
)paren
(brace
r_char
op_star
id|this_char
comma
op_star
id|value
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.bits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear default settings */
r_while
c_loop
(paren
(paren
id|this_char
op_assign
id|strsep
(paren
op_amp
id|options
comma
l_string|&quot;:&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
(paren
id|this_char
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|value
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;concentrating_formatted_nodes&quot;
)paren
)paren
(brace
r_int
id|temp
suffix:semicolon
id|SET_OPTION
c_func
(paren
id|concentrating_formatted_nodes
)paren
suffix:semicolon
id|temp
op_assign
(paren
id|value
op_logical_and
op_star
id|value
)paren
ques
c_cond
id|simple_strtoul
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:colon
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_le
l_int|0
op_logical_or
id|temp
OG
l_int|100
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.border
op_assign
l_int|10
suffix:semicolon
)brace
r_else
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.border
op_assign
l_int|100
op_div
id|temp
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;displacing_large_files&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|displacing_large_files
)paren
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.large_file_size
op_assign
(paren
id|value
op_logical_and
op_star
id|value
)paren
ques
c_cond
id|simple_strtoul
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:colon
l_int|16
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;displacing_new_packing_localities&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|displacing_new_packing_localities
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;old_hashed_relocation&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|old_hashed_relocation
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;new_hashed_relocation&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|new_hashed_relocation
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;hashed_formatted_nodes&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|hashed_formatted_nodes
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;skip_busy&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|skip_busy
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;hundredth_slices&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|hundredth_slices
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;old_way&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|old_way
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;displace_based_on_dirid&quot;
)paren
)paren
(brace
id|SET_OPTION
c_func
(paren
id|displace_based_on_dirid
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;preallocmin&quot;
)paren
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.preallocmin
op_assign
(paren
id|value
op_logical_and
op_star
id|value
)paren
ques
c_cond
id|simple_strtoul
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:colon
l_int|4
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;preallocsize&quot;
)paren
)paren
(brace
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.preallocsize
op_assign
(paren
id|value
op_logical_and
op_star
id|value
)paren
ques
c_cond
id|simple_strtoul
(paren
id|value
comma
op_amp
id|value
comma
l_int|0
)paren
suffix:colon
id|PREALLOCATION_SIZE
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;zam-4001: %s : unknown option - %s&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|this_char
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|new_hashed_relocation
r_static
r_inline
r_void
id|new_hashed_relocation
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_char
op_star
id|hash_in
suffix:semicolon
r_if
c_cond
(paren
id|hint-&gt;formatted_node
)paren
(brace
id|hash_in
op_assign
(paren
r_char
op_star
)paren
op_amp
id|hint-&gt;key.k_dir_id
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|hint-&gt;inode
)paren
(brace
singleline_comment|//hint-&gt;search_start = hint-&gt;beg;
id|hash_in
op_assign
(paren
r_char
op_star
)paren
op_amp
id|hint-&gt;key.k_dir_id
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|displace_based_on_dirid
comma
id|hint-&gt;th-&gt;t_super
)paren
)paren
id|hash_in
op_assign
(paren
r_char
op_star
)paren
(paren
op_amp
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
r_else
id|hash_in
op_assign
(paren
r_char
op_star
)paren
(paren
op_amp
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
)brace
id|hint-&gt;search_start
op_assign
id|hint-&gt;beg
op_plus
id|keyed_hash
c_func
(paren
id|hash_in
comma
l_int|4
)paren
op_mod
(paren
id|hint-&gt;end
op_minus
id|hint-&gt;beg
)paren
suffix:semicolon
)brace
DECL|function|get_left_neighbor
r_static
r_inline
r_void
id|get_left_neighbor
c_func
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_struct
id|path
op_star
id|path
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_int
id|pos_in_item
suffix:semicolon
id|__u32
op_star
id|item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hint-&gt;path
)paren
multiline_comment|/* reiserfs code can call this function w/o pointer to path&n;&t;&t;&t;&t; * structure supplied; then we rely on supplied search_start */
r_return
suffix:semicolon
id|path
op_assign
id|hint-&gt;path
suffix:semicolon
id|bh
op_assign
id|get_last_bh
c_func
(paren
id|path
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
op_logical_neg
id|bh
comma
l_string|&quot;green-4002: Illegal path specified to get_left_neighbor&bslash;n&quot;
)paren
suffix:semicolon
id|ih
op_assign
id|get_ih
c_func
(paren
id|path
)paren
suffix:semicolon
id|pos_in_item
op_assign
id|path-&gt;pos_in_item
suffix:semicolon
id|item
op_assign
id|get_item
(paren
id|path
)paren
suffix:semicolon
id|hint-&gt;search_start
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hint-&gt;formatted_node
op_logical_and
id|is_indirect_le_ih
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* for indirect item: go to left and look for the first non-hole entry&n;&t;   in the indirect item */
r_if
c_cond
(paren
id|pos_in_item
op_eq
id|I_UNFM_NUM
(paren
id|ih
)paren
)paren
id|pos_in_item
op_decrement
suffix:semicolon
singleline_comment|//&t;    pos_in_item = I_UNFM_NUM (ih) - 1;
r_while
c_loop
(paren
id|pos_in_item
op_ge
l_int|0
)paren
(brace
r_int
id|t
op_assign
id|get_block_num
c_func
(paren
id|item
comma
id|pos_in_item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
id|hint-&gt;search_start
op_assign
id|t
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pos_in_item
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
)brace
multiline_comment|/* does result value fit into specified region? */
r_return
suffix:semicolon
)brace
multiline_comment|/* should be, if formatted node, then try to put on first part of the device&n;   specified as number of percent with mount option device, else try to put&n;   on last of device.  This is not to say it is good code to do so,&n;   but the effect should be measured.  */
DECL|function|set_border_in_hint
r_static
r_inline
r_void
id|set_border_in_hint
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
id|b_blocknr_t
id|border
op_assign
id|SB_BLOCK_COUNT
c_func
(paren
id|s
)paren
op_div
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_alloc_options.border
suffix:semicolon
r_if
c_cond
(paren
id|hint-&gt;formatted_node
)paren
id|hint-&gt;end
op_assign
id|border
op_minus
l_int|1
suffix:semicolon
r_else
id|hint-&gt;beg
op_assign
id|border
suffix:semicolon
)brace
DECL|function|displace_large_file
r_static
r_inline
r_void
id|displace_large_file
c_func
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|displace_based_on_dirid
comma
id|hint-&gt;th-&gt;t_super
)paren
)paren
id|hint-&gt;search_start
op_assign
id|hint-&gt;beg
op_plus
id|keyed_hash
c_func
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
comma
l_int|4
)paren
op_mod
(paren
id|hint-&gt;end
op_minus
id|hint-&gt;beg
)paren
suffix:semicolon
r_else
id|hint-&gt;search_start
op_assign
id|hint-&gt;beg
op_plus
id|keyed_hash
c_func
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
comma
l_int|4
)paren
op_mod
(paren
id|hint-&gt;end
op_minus
id|hint-&gt;beg
)paren
suffix:semicolon
)brace
DECL|function|hash_formatted_node
r_static
r_inline
r_void
id|hash_formatted_node
c_func
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_char
op_star
id|hash_in
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hint-&gt;inode
)paren
id|hash_in
op_assign
(paren
r_char
op_star
)paren
op_amp
id|hint-&gt;key.k_dir_id
suffix:semicolon
r_else
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|displace_based_on_dirid
comma
id|hint-&gt;th-&gt;t_super
)paren
)paren
id|hash_in
op_assign
(paren
r_char
op_star
)paren
(paren
op_amp
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
r_else
id|hash_in
op_assign
(paren
r_char
op_star
)paren
(paren
op_amp
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|k_objectid
)paren
suffix:semicolon
id|hint-&gt;search_start
op_assign
id|hint-&gt;beg
op_plus
id|keyed_hash
c_func
(paren
id|hash_in
comma
l_int|4
)paren
op_mod
(paren
id|hint-&gt;end
op_minus
id|hint-&gt;beg
)paren
suffix:semicolon
)brace
DECL|function|this_blocknr_allocation_would_make_it_a_large_file
r_static
r_inline
r_int
id|this_blocknr_allocation_would_make_it_a_large_file
c_func
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_return
id|hint-&gt;block
op_eq
id|REISERFS_SB
c_func
(paren
id|hint-&gt;th-&gt;t_super
)paren
op_member_access_from_pointer
id|s_alloc_options.large_file_size
suffix:semicolon
)brace
macro_line|#ifdef DISPLACE_NEW_PACKING_LOCALITIES
DECL|function|displace_new_packing_locality
r_static
r_inline
r_void
id|displace_new_packing_locality
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_struct
id|key
op_star
id|key
op_assign
op_amp
id|hint-&gt;key
suffix:semicolon
id|hint-&gt;th-&gt;displace_new_blocks
op_assign
l_int|0
suffix:semicolon
id|hint-&gt;search_start
op_assign
id|hint-&gt;beg
op_plus
id|keyed_hash
c_func
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|key-&gt;k_objectid
)paren
comma
l_int|4
)paren
op_mod
(paren
id|hint-&gt;end
op_minus
id|hint-&gt;beg
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|old_hashed_relocation
r_static
r_inline
r_int
id|old_hashed_relocation
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_int
r_int
id|border
suffix:semicolon
r_int
r_int
id|hash_in
suffix:semicolon
r_if
c_cond
(paren
id|hint-&gt;formatted_node
op_logical_or
id|hint-&gt;inode
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|hash_in
op_assign
id|le32_to_cpu
c_func
(paren
(paren
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
suffix:semicolon
id|border
op_assign
id|hint-&gt;beg
op_plus
(paren
r_int
r_int
)paren
id|keyed_hash
c_func
(paren
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|hash_in
)paren
)paren
comma
l_int|4
)paren
op_mod
(paren
id|hint-&gt;end
op_minus
id|hint-&gt;beg
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|border
OG
id|hint-&gt;search_start
)paren
id|hint-&gt;search_start
op_assign
id|border
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|old_way
r_static
r_inline
r_int
id|old_way
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_int
r_int
id|border
suffix:semicolon
r_if
c_cond
(paren
id|hint-&gt;formatted_node
op_logical_or
id|hint-&gt;inode
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|border
op_assign
id|hint-&gt;beg
op_plus
id|le32_to_cpu
c_func
(paren
id|INODE_PKEY
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
op_mod
(paren
id|hint-&gt;end
op_minus
id|hint-&gt;beg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|border
OG
id|hint-&gt;search_start
)paren
id|hint-&gt;search_start
op_assign
id|border
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|hundredth_slices
r_static
r_inline
r_void
id|hundredth_slices
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
r_struct
id|key
op_star
id|key
op_assign
op_amp
id|hint-&gt;key
suffix:semicolon
r_int
r_int
id|slice_start
suffix:semicolon
id|slice_start
op_assign
(paren
id|keyed_hash
c_func
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|key-&gt;k_dir_id
)paren
comma
l_int|4
)paren
op_mod
l_int|100
)paren
op_star
(paren
id|hint-&gt;end
op_div
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slice_start
OG
id|hint-&gt;search_start
op_logical_or
id|slice_start
op_plus
(paren
id|hint-&gt;end
op_div
l_int|100
)paren
op_le
id|hint-&gt;search_start
)paren
(brace
id|hint-&gt;search_start
op_assign
id|slice_start
suffix:semicolon
)brace
)brace
DECL|function|determine_search_start
r_static
r_inline
r_void
id|determine_search_start
c_func
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
comma
r_int
id|amount_needed
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|hint-&gt;th-&gt;t_super
suffix:semicolon
id|hint-&gt;beg
op_assign
l_int|0
suffix:semicolon
id|hint-&gt;end
op_assign
id|SB_BLOCK_COUNT
c_func
(paren
id|s
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This is former border algorithm. Now with tunable border offset */
r_if
c_cond
(paren
id|concentrating_formatted_nodes
c_func
(paren
id|s
)paren
)paren
id|set_border_in_hint
c_func
(paren
id|s
comma
id|hint
)paren
suffix:semicolon
macro_line|#ifdef DISPLACE_NEW_PACKING_LOCALITIES
multiline_comment|/* whenever we create a new directory, we displace it.  At first we will&n;       hash for location, later we might look for a moderately empty place for&n;       it */
r_if
c_cond
(paren
id|displacing_new_packing_localities
c_func
(paren
id|s
)paren
op_logical_and
id|hint-&gt;th-&gt;displace_new_blocks
)paren
(brace
id|displace_new_packing_locality
c_func
(paren
id|hint
)paren
suffix:semicolon
multiline_comment|/* we do not continue determine_search_start,&n;&t; * if new packing locality is being displaced */
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* all persons should feel encouraged to add more special cases here and&n;     * test them */
r_if
c_cond
(paren
id|displacing_large_files
c_func
(paren
id|s
)paren
op_logical_and
op_logical_neg
id|hint-&gt;formatted_node
op_logical_and
id|this_blocknr_allocation_would_make_it_a_large_file
c_func
(paren
id|hint
)paren
)paren
(brace
id|displace_large_file
c_func
(paren
id|hint
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* attempt to copy a feature from old block allocator code */
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|old_hashed_relocation
comma
id|s
)paren
op_logical_and
op_logical_neg
id|hint-&gt;formatted_node
)paren
(brace
id|old_hashed_relocation
c_func
(paren
id|hint
)paren
suffix:semicolon
)brace
multiline_comment|/* if none of our special cases is relevant, use the left neighbor in the&n;       tree order of the new node we are allocating for */
r_if
c_cond
(paren
id|hint-&gt;formatted_node
op_logical_and
id|TEST_OPTION
c_func
(paren
id|hashed_formatted_nodes
comma
id|s
)paren
)paren
(brace
id|hash_formatted_node
c_func
(paren
id|hint
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|get_left_neighbor
c_func
(paren
id|hint
)paren
suffix:semicolon
multiline_comment|/* Mimic old block allocator behaviour, that is if VFS allowed for preallocation,&n;       new blocks are displaced based on directory ID. Also, if suggested search_start&n;       is less than last preallocated block, we start searching from it, assuming that&n;       HDD dataflow is faster in forward direction */
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|old_way
comma
id|s
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hint-&gt;formatted_node
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_hashed_relocation
c_func
(paren
id|s
)paren
)paren
id|old_way
c_func
(paren
id|hint
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_no_unhashed_relocation
c_func
(paren
id|s
)paren
)paren
id|old_hashed_relocation
c_func
(paren
id|hint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hint-&gt;inode
op_logical_and
id|hint-&gt;search_start
OL
id|REISERFS_I
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
)paren
id|hint-&gt;search_start
op_assign
id|REISERFS_I
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* This is an approach proposed by Hans */
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|hundredth_slices
comma
id|s
)paren
op_logical_and
op_logical_neg
(paren
id|displacing_large_files
c_func
(paren
id|s
)paren
op_logical_and
op_logical_neg
id|hint-&gt;formatted_node
)paren
)paren
(brace
id|hundredth_slices
c_func
(paren
id|hint
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|old_hashed_relocation
comma
id|s
)paren
)paren
id|old_hashed_relocation
c_func
(paren
id|hint
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TEST_OPTION
c_func
(paren
id|new_hashed_relocation
comma
id|s
)paren
)paren
id|new_hashed_relocation
c_func
(paren
id|hint
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|determine_prealloc_size
r_static
r_int
id|determine_prealloc_size
c_func
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
)paren
(brace
multiline_comment|/* make minimum size a mount option and benchmark both ways */
multiline_comment|/* we preallocate blocks only for regular files, specific size */
multiline_comment|/* benchmark preallocating always and see what happens */
id|hint-&gt;prealloc_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hint-&gt;formatted_node
op_logical_and
id|hint-&gt;preallocate
)paren
(brace
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|hint-&gt;inode-&gt;i_mode
)paren
op_logical_and
id|hint-&gt;inode-&gt;i_size
op_ge
id|REISERFS_SB
c_func
(paren
id|hint-&gt;th-&gt;t_super
)paren
op_member_access_from_pointer
id|s_alloc_options.preallocmin
op_star
id|hint-&gt;inode-&gt;i_sb-&gt;s_blocksize
)paren
id|hint-&gt;prealloc_size
op_assign
id|REISERFS_SB
c_func
(paren
id|hint-&gt;th-&gt;t_super
)paren
op_member_access_from_pointer
id|s_alloc_options.preallocsize
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* XXX I know it could be merged with upper-level function;&n;   but may be result function would be too complex. */
DECL|function|allocate_without_wrapping_disk
r_static
r_inline
r_int
id|allocate_without_wrapping_disk
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
comma
id|b_blocknr_t
op_star
id|new_blocknrs
comma
id|b_blocknr_t
id|start
comma
id|b_blocknr_t
id|finish
comma
r_int
id|amount_needed
comma
r_int
id|prealloc_size
)paren
(brace
r_int
id|rest
op_assign
id|amount_needed
suffix:semicolon
r_int
id|nr_allocated
suffix:semicolon
r_while
c_loop
(paren
id|rest
OG
l_int|0
)paren
(brace
id|nr_allocated
op_assign
id|scan_bitmap
(paren
id|hint-&gt;th
comma
op_amp
id|start
comma
id|finish
comma
l_int|1
comma
id|rest
op_plus
id|prealloc_size
comma
op_logical_neg
id|hint-&gt;formatted_node
comma
id|hint-&gt;block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_allocated
op_eq
l_int|0
)paren
multiline_comment|/* no new blocks allocated, return */
r_break
suffix:semicolon
multiline_comment|/* fill free_blocknrs array first */
r_while
c_loop
(paren
id|rest
OG
l_int|0
op_logical_and
id|nr_allocated
OG
l_int|0
)paren
(brace
op_star
id|new_blocknrs
op_increment
op_assign
id|start
op_increment
suffix:semicolon
id|rest
op_decrement
suffix:semicolon
id|nr_allocated
op_decrement
suffix:semicolon
)brace
multiline_comment|/* do we have something to fill prealloc. array also ? */
r_if
c_cond
(paren
id|nr_allocated
OG
l_int|0
)paren
(brace
multiline_comment|/* it means prealloc_size was greater that 0 and we do preallocation */
id|list_add
c_func
(paren
op_amp
id|REISERFS_I
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|i_prealloc_list
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|hint-&gt;th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_prealloc_list
)paren
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
op_assign
id|start
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|hint-&gt;inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_assign
id|nr_allocated
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
(paren
id|amount_needed
op_minus
id|rest
)paren
suffix:semicolon
)brace
DECL|function|blocknrs_and_prealloc_arrays_from_search_start
r_static
r_inline
r_int
id|blocknrs_and_prealloc_arrays_from_search_start
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
comma
id|b_blocknr_t
op_star
id|new_blocknrs
comma
r_int
id|amount_needed
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|hint-&gt;th-&gt;t_super
suffix:semicolon
id|b_blocknr_t
id|start
op_assign
id|hint-&gt;search_start
suffix:semicolon
id|b_blocknr_t
id|finish
op_assign
id|SB_BLOCK_COUNT
c_func
(paren
id|s
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|second_pass
op_assign
l_int|0
suffix:semicolon
r_int
id|nr_allocated
op_assign
l_int|0
suffix:semicolon
id|determine_prealloc_size
c_func
(paren
id|hint
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nr_allocated
op_add_assign
id|allocate_without_wrapping_disk
c_func
(paren
id|hint
comma
id|new_blocknrs
op_plus
id|nr_allocated
comma
id|start
comma
id|finish
comma
id|amount_needed
op_minus
id|nr_allocated
comma
id|hint-&gt;prealloc_size
)paren
)paren
OL
id|amount_needed
)paren
(brace
multiline_comment|/* not all blocks were successfully allocated yet*/
r_if
c_cond
(paren
id|second_pass
)paren
(brace
multiline_comment|/* it was a second pass; we must free all blocks */
r_while
c_loop
(paren
id|nr_allocated
op_decrement
)paren
id|reiserfs_free_block
c_func
(paren
id|hint-&gt;th
comma
id|new_blocknrs
(braket
id|nr_allocated
)braket
)paren
suffix:semicolon
r_return
id|NO_DISK_SPACE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* refine search parameters for next pass */
id|second_pass
op_assign
l_int|1
suffix:semicolon
id|finish
op_assign
id|start
suffix:semicolon
id|start
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* grab new blocknrs from preallocated list */
multiline_comment|/* return amount still needed after using them */
DECL|function|use_preallocated_list_if_available
r_static
r_int
id|use_preallocated_list_if_available
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
comma
id|b_blocknr_t
op_star
id|new_blocknrs
comma
r_int
id|amount_needed
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|hint-&gt;inode
suffix:semicolon
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|amount_needed
)paren
(brace
op_star
id|new_blocknrs
op_increment
op_assign
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_block
op_increment
suffix:semicolon
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_decrement
suffix:semicolon
id|amount_needed
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_count
op_le
l_int|0
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|REISERFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_prealloc_list
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* return amount still needed after using preallocated blocks */
r_return
id|amount_needed
suffix:semicolon
)brace
DECL|function|reiserfs_allocate_blocknrs
r_int
id|reiserfs_allocate_blocknrs
c_func
(paren
id|reiserfs_blocknr_hint_t
op_star
id|hint
comma
id|b_blocknr_t
op_star
id|new_blocknrs
comma
r_int
id|amount_needed
comma
r_int
id|reserved_by_us
multiline_comment|/* Amount of blocks we have&n;&t;&t;&t;&t;&t;&t;      already reserved */
)paren
(brace
r_int
id|initial_amount_needed
op_assign
id|amount_needed
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Check if there is enough space, taking into account reserved space */
r_if
c_cond
(paren
id|SB_FREE_BLOCKS
c_func
(paren
id|hint-&gt;th-&gt;t_super
)paren
op_minus
id|REISERFS_SB
c_func
(paren
id|hint-&gt;th-&gt;t_super
)paren
op_member_access_from_pointer
id|reserved_blocks
OL
id|amount_needed
op_minus
id|reserved_by_us
)paren
r_return
id|NO_DISK_SPACE
suffix:semicolon
multiline_comment|/* should this be if !hint-&gt;inode &amp;&amp;  hint-&gt;preallocate? */
multiline_comment|/* do you mean hint-&gt;formatted_node can be removed ? - Zam */
multiline_comment|/* hint-&gt;formatted_node cannot be removed because we try to access&n;       inode information here, and there is often no inode assotiated with&n;       metadata allocations - green */
r_if
c_cond
(paren
op_logical_neg
id|hint-&gt;formatted_node
op_logical_and
id|hint-&gt;preallocate
)paren
(brace
id|amount_needed
op_assign
id|use_preallocated_list_if_available
(paren
id|hint
comma
id|new_blocknrs
comma
id|amount_needed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount_needed
op_eq
l_int|0
)paren
multiline_comment|/* all blocknrs we need we got from&n;                                   prealloc. list */
r_return
id|CARRY_ON
suffix:semicolon
id|new_blocknrs
op_add_assign
(paren
id|initial_amount_needed
op_minus
id|amount_needed
)paren
suffix:semicolon
)brace
multiline_comment|/* find search start and save it in hint structure */
id|determine_search_start
c_func
(paren
id|hint
comma
id|amount_needed
)paren
suffix:semicolon
multiline_comment|/* allocation itself; fill new_blocknrs and preallocation arrays */
id|ret
op_assign
id|blocknrs_and_prealloc_arrays_from_search_start
(paren
id|hint
comma
id|new_blocknrs
comma
id|amount_needed
)paren
suffix:semicolon
multiline_comment|/* we used prealloc. list to fill (partially) new_blocknrs array. If final allocation fails we&n;     * need to return blocks back to prealloc. list or just free them. -- Zam (I chose second&n;     * variant) */
r_if
c_cond
(paren
id|ret
op_ne
id|CARRY_ON
)paren
(brace
r_while
c_loop
(paren
id|amount_needed
op_increment
OL
id|initial_amount_needed
)paren
(brace
id|reiserfs_free_block
c_func
(paren
id|hint-&gt;th
comma
op_star
(paren
op_decrement
id|new_blocknrs
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* These 2 functions are here to provide blocks reservation to the rest of kernel */
multiline_comment|/* Reserve @blocks amount of blocks in fs pointed by @sb. Caller must make sure&n;   there are actually this much blocks on the FS available */
DECL|function|reiserfs_claim_blocks_to_be_allocated
r_void
id|reiserfs_claim_blocks_to_be_allocated
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
multiline_comment|/* super block of&n;&t;&t;&t;&t;&t;&t;&t;        filesystem where&n;&t;&t;&t;&t;&t;&t;&t;&t;blocks should be&n;&t;&t;&t;&t;&t;&t;&t;&t;reserved */
r_int
id|blocks
multiline_comment|/* How much to reserve */
)paren
(brace
multiline_comment|/* Fast case, if reservation is zero - exit immediately. */
r_if
c_cond
(paren
op_logical_neg
id|blocks
)paren
r_return
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|reserved_blocks
op_add_assign
id|blocks
suffix:semicolon
)brace
multiline_comment|/* Unreserve @blocks amount of blocks in fs pointed by @sb */
DECL|function|reiserfs_release_claimed_blocks
r_void
id|reiserfs_release_claimed_blocks
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
multiline_comment|/* super block of&n;&t;&t;&t;&t;&t;&t;&t;  filesystem where&n;&t;&t;&t;&t;&t;&t;&t;  blocks should be&n;&t;&t;&t;&t;&t;&t;&t;  reserved */
r_int
id|blocks
multiline_comment|/* How much to unreserve */
)paren
(brace
multiline_comment|/* Fast case, if unreservation is zero - exit immediately. */
r_if
c_cond
(paren
op_logical_neg
id|blocks
)paren
r_return
suffix:semicolon
id|REISERFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|reserved_blocks
op_sub_assign
id|blocks
suffix:semicolon
id|RFALSE
c_func
(paren
id|REISERFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|reserved_blocks
OL
l_int|0
comma
l_string|&quot;amount of blocks reserved became zero?&quot;
)paren
suffix:semicolon
)brace
eof
