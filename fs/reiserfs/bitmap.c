multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#else
macro_line|#include &quot;nokernel.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_REISERFS_CHECK
multiline_comment|/* this is a safety check to make sure&n;** blocks are reused properly.  used for debugging only.&n;**&n;** this checks, that block can be reused, and it has correct state&n;**   (free or busy) &n;*/
DECL|function|is_reusable
r_int
id|is_reusable
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|block
comma
r_int
id|bit_value
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
l_int|0
op_logical_or
id|block
op_ge
id|SB_BLOCK_COUNT
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4010: is_reusable: block number is out of range %lu (%u)&bslash;n&quot;
comma
id|block
comma
id|SB_BLOCK_COUNT
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* it can&squot;t be one of the bitmap blocks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|block
op_eq
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs: 4020: is_reusable: &quot;
l_string|&quot;bitmap block %lu(%u) can&squot;t be freed or reused&bslash;n&quot;
comma
id|block
comma
id|SB_BMAP_NR
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_assign
id|block
op_div
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|SB_BMAP_NR
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4030: is_reusable: there is no so many bitmap blocks: &quot;
l_string|&quot;block=%lu, bitmap_nr=%d&bslash;n&quot;
comma
id|block
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|j
op_assign
id|block
op_mod
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bit_value
op_eq
l_int|0
op_logical_and
id|reiserfs_test_le_bit
c_func
(paren
id|j
comma
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
)paren
)paren
op_logical_or
(paren
id|bit_value
op_eq
l_int|1
op_logical_and
id|reiserfs_test_le_bit
c_func
(paren
id|j
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4040: is_reusable: corresponding bit of block %lu does not &quot;
l_string|&quot;match required value (i==%d, j==%d) test_bit==%d&bslash;n&quot;
comma
id|block
comma
id|i
comma
id|j
comma
id|reiserfs_test_le_bit
(paren
id|j
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bit_value
op_eq
l_int|0
op_logical_and
id|block
op_eq
id|SB_ROOT_BLOCK
(paren
id|s
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4050: is_reusable: this is root block (%u), &quot;
l_string|&quot;it must be busy&quot;
comma
id|SB_ROOT_BLOCK
(paren
id|s
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_REISERFS_CHECK */
macro_line|#if 0
multiline_comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
r_int
id|is_used
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|block
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|i
op_assign
id|block
op_div
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
id|j
op_assign
id|block
op_mod
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reiserfs_test_le_bit
c_func
(paren
id|j
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
macro_line|#endif
multiline_comment|/* get address of corresponding bit (bitmap block number and offset in it) */
DECL|function|get_bit_address
r_static
r_inline
r_void
id|get_bit_address
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|block
comma
r_int
op_star
id|bmap_nr
comma
r_int
op_star
id|offset
)paren
(brace
multiline_comment|/* It is in the bitmap block number equal to the block number divided by the number of&n;                                   bits in a block. */
op_star
id|bmap_nr
op_assign
id|block
op_div
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Within that bitmap block it is located at bit offset *offset. */
op_star
id|offset
op_assign
id|block
op_mod
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* There would be a modest performance benefit if we write a version&n;   to free a list of blocks at once. -Hans */
multiline_comment|/* I wonder if it would be less modest&n;                                   now that we use journaling. -Hans */
DECL|function|reiserfs_free_block
r_void
id|reiserfs_free_block
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
r_struct
id|reiserfs_super_block
op_star
id|rs
suffix:semicolon
r_struct
id|buffer_head
op_star
id|sbh
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|apbh
suffix:semicolon
r_int
id|nr
comma
id|offset
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;vs-4060: reiserfs_free_block: trying to free block on nonexistent device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_reusable
(paren
id|s
comma
id|block
comma
l_int|1
)paren
op_eq
l_int|0
)paren
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;vs-4070: reiserfs_free_block: can not free such block&quot;
)paren
suffix:semicolon
macro_line|#endif
id|rs
op_assign
id|SB_DISK_SUPER_BLOCK
(paren
id|s
)paren
suffix:semicolon
id|sbh
op_assign
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
suffix:semicolon
id|apbh
op_assign
id|SB_AP_BITMAP
(paren
id|s
)paren
suffix:semicolon
id|get_bit_address
(paren
id|s
comma
id|block
comma
op_amp
id|nr
comma
op_amp
id|offset
)paren
suffix:semicolon
multiline_comment|/* mark it before we clear it, just in case */
id|journal_mark_freed
c_func
(paren
id|th
comma
id|s
comma
id|block
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|apbh
(braket
id|nr
)braket
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* clear bit for the given block in bit map */
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_test_and_clear_le_bit
(paren
id|offset
comma
id|apbh
(braket
id|nr
)braket
op_member_access_from_pointer
id|b_data
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-4080: reiserfs_free_block: &quot;
l_string|&quot;free_block (%04x:%lu)[dev:blocknr]: bit already cleared&bslash;n&quot;
comma
id|s-&gt;s_dev
comma
id|block
)paren
suffix:semicolon
)brace
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|apbh
(braket
id|nr
)braket
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|sbh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update super block */
id|rs-&gt;s_free_blocks
op_assign
id|cpu_to_le32
(paren
id|le32_to_cpu
(paren
id|rs-&gt;s_free_blocks
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|sbh
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* beginning from offset-th bit in bmap_nr-th bitmap block,&n;   find_forward finds the closest zero bit. It returns 1 and zero&n;   bit address (bitmap, offset) if zero bit found or 0 if there is no&n;   zero bit in the forward direction */
multiline_comment|/* The function is NOT SCHEDULE-SAFE! */
DECL|function|find_forward
r_static
r_int
id|find_forward
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
op_star
id|bmap_nr
comma
r_int
op_star
id|offset
comma
r_int
id|for_unformatted
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
r_int
id|block_to_try
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|next_block_to_try
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
op_star
id|bmap_nr
suffix:semicolon
id|i
OL
id|SB_BMAP_NR
(paren
id|s
)paren
suffix:semicolon
id|i
op_increment
comma
op_star
id|offset
op_assign
l_int|0
)paren
(brace
multiline_comment|/* get corresponding bitmap block */
id|bh
op_assign
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
(paren
id|bh
)paren
)paren
(brace
id|__wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
)brace
id|retry
suffix:colon
id|j
op_assign
id|reiserfs_find_next_zero_le_bit
(paren
(paren
r_int
r_int
op_star
)paren
id|bh-&gt;b_data
comma
id|s-&gt;s_blocksize
op_lshift
l_int|3
comma
op_star
id|offset
)paren
suffix:semicolon
multiline_comment|/* wow, this really needs to be redone.  We can&squot;t allocate a block if&n;    ** it is in the journal somehow.  reiserfs_in_journal makes a suggestion&n;    ** for a good block if the one you ask for is in the journal.  Note,&n;    ** reiserfs_in_journal might reject the block it suggests.  The big&n;    ** gain from the suggestion is when a big file has been deleted, and&n;    ** many blocks show free in the real bitmap, but are all not free&n;    ** in the journal list bitmaps.&n;    **&n;    ** this whole system sucks.  The bitmaps should reflect exactly what&n;    ** can and can&squot;t be allocated, and the journal should update them as&n;    ** it goes.  TODO.&n;    */
r_if
c_cond
(paren
id|j
OL
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
)paren
(brace
id|block_to_try
op_assign
(paren
id|i
op_star
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
)paren
op_plus
id|j
suffix:semicolon
multiline_comment|/* the block is not in the journal, we can proceed */
r_if
c_cond
(paren
op_logical_neg
(paren
id|reiserfs_in_journal
c_func
(paren
id|s
comma
id|s-&gt;s_dev
comma
id|block_to_try
comma
id|s-&gt;s_blocksize
comma
id|for_unformatted
comma
op_amp
id|next_block_to_try
)paren
)paren
)paren
(brace
op_star
id|bmap_nr
op_assign
id|i
suffix:semicolon
op_star
id|offset
op_assign
id|j
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* the block is in the journal */
r_else
r_if
c_cond
(paren
(paren
id|j
op_plus
l_int|1
)paren
OL
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
)paren
(brace
multiline_comment|/* try again */
multiline_comment|/* reiserfs_in_journal suggested a new block to try */
r_if
c_cond
(paren
id|next_block_to_try
OG
l_int|0
)paren
(brace
r_int
id|new_i
suffix:semicolon
id|get_bit_address
(paren
id|s
comma
id|next_block_to_try
comma
op_amp
id|new_i
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* block is not in this bitmap. reset i and continue&n;&t;  ** we only reset i if new_i is in a later bitmap.&n;&t;  */
r_if
c_cond
(paren
id|new_i
OG
id|i
)paren
(brace
id|i
op_assign
(paren
id|new_i
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* i gets incremented by the for loop */
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no suggestion was made, just try the next block */
op_star
id|offset
op_assign
id|j
op_plus
l_int|1
suffix:semicolon
)brace
r_goto
id|retry
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* zero bit not found */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return 0 if no free blocks, else return 1 */
multiline_comment|/* The function is NOT SCHEDULE-SAFE!  &n;** because the bitmap block we want to change could be locked, and on its&n;** way to the disk when we want to read it, and because of the &n;** flush_async_commits.  Per bitmap block locks won&squot;t help much, and &n;** really aren&squot;t needed, as we retry later on if we try to set the bit&n;** and it is already set.&n;*/
DECL|function|find_zero_bit_in_bitmap
r_static
r_int
id|find_zero_bit_in_bitmap
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
r_int
id|search_start
comma
r_int
op_star
id|bmap_nr
comma
r_int
op_star
id|offset
comma
r_int
id|for_unformatted
)paren
(brace
r_int
id|retry_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get bit location (bitmap number and bit offset) of search_start block */
id|get_bit_address
(paren
id|s
comma
id|search_start
comma
id|bmap_nr
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* note that we search forward in the bitmap, benchmarks have shown that it is better to allocate in increasing&n;       sequence, which is probably due to the disk spinning in the forward direction.. */
r_if
c_cond
(paren
id|find_forward
(paren
id|s
comma
id|bmap_nr
comma
id|offset
comma
id|for_unformatted
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* there wasn&squot;t a free block with number greater than our&n;         starting point, so we are going to go to the beginning of the disk */
id|retry
suffix:colon
id|search_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* caller will reset search_start for itself also. */
id|get_bit_address
(paren
id|s
comma
id|search_start
comma
id|bmap_nr
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|find_forward
(paren
id|s
comma
id|bmap_nr
comma
id|offset
comma
id|for_unformatted
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|for_unformatted
)paren
(brace
multiline_comment|/* why only unformatted nodes? -Hans */
r_if
c_cond
(paren
id|retry_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* we&squot;ve got a chance that flushing async commits will free up&n;&t;    ** some space.  Sync then retry&n;&t;    */
id|flush_async_commits
c_func
(paren
id|s
)paren
suffix:semicolon
id|retry_count
op_increment
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retry_count
OG
l_int|0
)paren
(brace
multiline_comment|/* nothing more we can do.  Make the others wait, flush&n;&t;    ** all log blocks to disk, and flush to their home locations.&n;&t;    ** this will free up any blocks held by the journal&n;&t;    */
id|SB_JOURNAL
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|j_must_wait
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* get amount_needed free block numbers from scanning the bitmap of&n;   free/used blocks.&n;   &n;   Optimize layout by trying to find them starting from search_start&n;   and moving in increasing blocknr direction.  (This was found to be&n;   faster than using a bi-directional elevator_direction, in part&n;   because of disk spin direction, in part because by the time one&n;   reaches the end of the disk the beginning of the disk is the least&n;   congested).&n;&n;   search_start is the block number of the left&n;   semantic neighbor of the node we create.&n;&n;   return CARRY_ON if everything is ok&n;   return NO_DISK_SPACE if out of disk space&n;   return NO_MORE_UNUSED_CONTIGUOUS_BLOCKS if the block we found is not contiguous to the last one&n;   &n;   return block numbers found, in the array free_blocknrs.  assumes&n;   that any non-zero entries already present in the array are valid.&n;   This feature is perhaps convenient coding when one might not have&n;   used all blocknrs from the last time one called this function, or&n;   perhaps it is an archaism from the days of schedule tracking, one&n;   of us ought to reread the code that calls this, and analyze whether&n;   it is still the right way to code it.&n;&n;   spare space is used only when priority is set to 1. reiserfsck has&n;   its own reiserfs_new_blocknrs, which can use reserved space&n;&n;   exactly what reserved space?  the SPARE_SPACE?  if so, please comment reiserfs.h.&n;&n;   Give example of who uses spare space, and say that it is a deadlock&n;   avoidance mechanism.  -Hans */
multiline_comment|/* This function is NOT SCHEDULE-SAFE! */
DECL|function|do_reiserfs_new_blocknrs
r_static
r_int
id|do_reiserfs_new_blocknrs
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
op_star
id|free_blocknrs
comma
r_int
r_int
id|search_start
comma
r_int
id|amount_needed
comma
r_int
id|priority
comma
r_int
id|for_unformatted
comma
r_int
id|for_prealloc
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|th-&gt;t_super
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_int
op_star
id|block_list_start
op_assign
id|free_blocknrs
suffix:semicolon
r_int
id|init_amount_needed
op_assign
id|amount_needed
suffix:semicolon
r_int
r_int
id|new_block
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SB_FREE_BLOCKS
(paren
id|s
)paren
OL
id|SPARE_SPACE
op_logical_and
op_logical_neg
id|priority
)paren
multiline_comment|/* we can answer NO_DISK_SPACE being asked for new block with&n;&t;   priority 0 */
r_return
id|NO_DISK_SPACE
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;vs-4090: reiserfs_new_blocknrs: trying to get new block from nonexistent device&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_start
op_eq
id|MAX_B_NUM
)paren
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;vs-4100: reiserfs_new_blocknrs: we are optimizing location based on &quot;
l_string|&quot;the bogus location of a temp buffer (%lu).&quot;
comma
id|search_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amount_needed
template_param
l_int|2
)paren
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;vs-4110: reiserfs_new_blocknrs: amount_needed parameter incorrect (%d)&quot;
comma
id|amount_needed
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_REISERFS_CHECK */
multiline_comment|/* We continue the while loop if another process snatches our found&n;   * free block from us after we find it but before we successfully&n;   * mark it as in use, or if we need to use sync to free up some&n;   * blocks on the preserve list.  */
r_while
c_loop
(paren
id|amount_needed
op_decrement
)paren
(brace
multiline_comment|/* skip over any blocknrs already gotten last time. */
r_if
c_cond
(paren
op_star
(paren
id|free_blocknrs
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|is_reusable
(paren
id|s
comma
op_star
id|free_blocknrs
comma
l_int|1
)paren
op_eq
l_int|0
)paren
id|reiserfs_panic
c_func
(paren
id|s
comma
l_string|&quot;vs-4120: reiserfs_new_blocknrs: bad blocknr on free_blocknrs list&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_REISERFS_CHECK */
id|free_blocknrs
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* look for zero bits in bitmap */
r_if
c_cond
(paren
id|find_zero_bit_in_bitmap
c_func
(paren
id|s
comma
id|search_start
comma
op_amp
id|i
comma
op_amp
id|j
comma
id|for_unformatted
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|find_zero_bit_in_bitmap
c_func
(paren
id|s
comma
id|search_start
comma
op_amp
id|i
comma
op_amp
id|j
comma
id|for_unformatted
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* recode without the goto and without&n;&t;&t;&t;&t;   the if.  It will require a&n;&t;&t;&t;&t;   duplicate for.  This is worth the&n;&t;&t;&t;&t;   code clarity.  Your way was&n;&t;&t;&t;&t;   admirable, and just a bit too&n;&t;&t;&t;&t;   clever in saving instructions.:-)&n;&t;&t;&t;&t;   I&squot;d say create a new function, but&n;&t;&t;&t;&t;   that would slow things also, yes?&n;&t;&t;&t;&t;   -Hans */
id|free_and_return
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|block_list_start
op_ne
id|free_blocknrs
suffix:semicolon
id|block_list_start
op_increment
)paren
(brace
id|reiserfs_free_block
(paren
id|th
comma
op_star
id|block_list_start
)paren
suffix:semicolon
op_star
id|block_list_start
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|for_prealloc
)paren
r_return
id|NO_MORE_UNUSED_CONTIGUOUS_BLOCKS
suffix:semicolon
r_else
r_return
id|NO_DISK_SPACE
suffix:semicolon
)brace
)brace
multiline_comment|/* i and j now contain the results of the search. i = bitmap block&n;       number containing free block, j = offset in this block.  we&n;       compute the blocknr which is our result, store it in&n;       free_blocknrs, and increment the pointer so that on the next&n;       loop we will insert into the next location in the array.  Also&n;       in preparation for the next loop, search_start is changed so&n;       that the next search will not rescan the same range but will&n;       start where this search finished.  Note that while it is&n;       possible that schedule has occurred and blocks have been freed&n;       in that range, it is perhaps more important that the blocks&n;       returned be near each other than that they be near their other&n;       neighbors, and it also simplifies and speeds the code this way.  */
multiline_comment|/* journal: we need to make sure the block we are giving out is not&n;    ** a log block, horrible things would happen there.&n;    */
id|new_block
op_assign
(paren
id|i
op_star
(paren
id|s-&gt;s_blocksize
op_lshift
l_int|3
)paren
)paren
op_plus
id|j
suffix:semicolon
r_if
c_cond
(paren
id|for_prealloc
op_logical_and
(paren
id|new_block
op_minus
l_int|1
)paren
op_ne
id|search_start
)paren
(brace
multiline_comment|/* preallocated blocks must be contiguous, bail if we didnt find one.&n;      ** this is not a bug.  We want to do the check here, before the&n;      ** bitmap block is prepared, and before we set the bit and log the&n;      ** bitmap. &n;      **&n;      ** If we do the check after this function returns, we have to &n;      ** call reiserfs_free_block for new_block, which would be pure&n;      ** overhead.&n;      **&n;      ** for_prealloc should only be set if the caller can deal with the&n;      ** NO_MORE_UNUSED_CONTIGUOUS_BLOCKS return value.  This can be&n;      ** returned before the disk is actually full&n;      */
r_goto
id|free_and_return
suffix:semicolon
)brace
id|search_start
op_assign
id|new_block
suffix:semicolon
r_if
c_cond
(paren
id|search_start
op_ge
id|reiserfs_get_journal_block
c_func
(paren
id|s
)paren
op_logical_and
id|search_start
OL
(paren
id|reiserfs_get_journal_block
c_func
(paren
id|s
)paren
op_plus
id|JOURNAL_BLOCK_COUNT
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;vs-4130: reiserfs_new_blocknrs: trying to allocate log block %lu&bslash;n&quot;
comma
id|search_start
)paren
suffix:semicolon
id|search_start
op_increment
suffix:semicolon
id|amount_needed
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|buffer_locked
(paren
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
)paren
op_logical_or
id|is_reusable
(paren
id|s
comma
id|search_start
comma
l_int|0
)paren
op_eq
l_int|0
)paren
id|reiserfs_panic
(paren
id|s
comma
l_string|&quot;vs-4140: reiserfs_new_blocknrs: bitmap block is locked or bad block number found&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* if this bit was already set, we&squot;ve scheduled, and someone else&n;    ** has allocated it.  loop around and try again&n;    */
r_if
c_cond
(paren
id|reiserfs_test_and_set_le_bit
(paren
id|j
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
)paren
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;vs-4150: reiserfs_new_blocknrs, block not free&quot;
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
c_func
(paren
id|s
comma
id|SB_AP_BITMAP
c_func
(paren
id|s
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|amount_needed
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|SB_AP_BITMAP
(paren
id|s
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
op_star
id|free_blocknrs
op_assign
id|search_start
suffix:semicolon
id|free_blocknrs
op_increment
suffix:semicolon
)brace
id|reiserfs_prepare_for_journal
c_func
(paren
id|s
comma
id|SB_BUFFER_WITH_SB
c_func
(paren
id|s
)paren
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update free block count in super block */
id|s-&gt;u.reiserfs_sb.s_rs-&gt;s_free_blocks
op_assign
id|cpu_to_le32
(paren
id|SB_FREE_BLOCKS
(paren
id|s
)paren
op_minus
id|init_amount_needed
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
id|th
comma
id|s
comma
id|SB_BUFFER_WITH_SB
(paren
id|s
)paren
)paren
suffix:semicolon
id|s-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
r_return
id|CARRY_ON
suffix:semicolon
)brace
singleline_comment|// this is called only by get_empty_nodes with for_preserve_list==0
DECL|function|reiserfs_new_blocknrs
r_int
id|reiserfs_new_blocknrs
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
op_star
id|free_blocknrs
comma
r_int
r_int
id|search_start
comma
r_int
id|amount_needed
)paren
(brace
r_return
id|do_reiserfs_new_blocknrs
c_func
(paren
id|th
comma
id|free_blocknrs
comma
id|search_start
comma
id|amount_needed
comma
l_int|0
multiline_comment|/*for_preserve_list-priority*/
comma
l_int|0
multiline_comment|/*for_formatted*/
comma
l_int|0
multiline_comment|/*for_prealloc */
)paren
suffix:semicolon
)brace
singleline_comment|// called by get_new_buffer and by reiserfs_get_block with amount_needed == 1 and for_preserve_list == 0
DECL|function|reiserfs_new_unf_blocknrs
r_int
id|reiserfs_new_unf_blocknrs
c_func
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_int
r_int
op_star
id|free_blocknrs
comma
r_int
r_int
id|search_start
)paren
(brace
r_return
id|do_reiserfs_new_blocknrs
c_func
(paren
id|th
comma
id|free_blocknrs
comma
id|search_start
comma
l_int|1
multiline_comment|/*amount_needed*/
comma
l_int|0
multiline_comment|/*for_preserve_list-priority*/
comma
l_int|1
multiline_comment|/*for formatted*/
comma
l_int|0
multiline_comment|/*for prealloc */
)paren
suffix:semicolon
)brace
macro_line|#ifdef REISERFS_PREALLOCATE
multiline_comment|/* &n;** We pre-allocate 8 blocks.  Pre-allocation is used for files &gt; 16 KB only.&n;** This lowers fragmentation on large files by grabbing a contiguous set of&n;** blocks at once.  It also limits the number of times the bitmap block is&n;** logged by making X number of allocation changes in a single transaction.&n;**&n;** We are using a border to divide the disk into two parts.  The first part&n;** is used for tree blocks, which have a very high turnover rate (they&n;** are constantly allocated then freed)&n;**&n;** The second part of the disk is for the unformatted nodes of larger files.&n;** Putting them away from the tree blocks lowers fragmentation, and makes&n;** it easier to group files together.  There are a number of different&n;** allocation schemes being tried right now, each is documented below.&n;**&n;** A great deal of the allocator&squot;s speed comes because reiserfs_get_block&n;** sends us the block number of the last unformatted node in the file.  Once&n;** a given block is allocated past the border, we don&squot;t collide with the&n;** blocks near the search_start again.&n;** &n;*/
DECL|function|reiserfs_new_unf_blocknrs2
r_int
id|reiserfs_new_unf_blocknrs2
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|p_s_inode
comma
r_int
r_int
op_star
id|free_blocknrs
comma
r_int
r_int
id|search_start
)paren
(brace
r_int
id|ret
op_assign
l_int|0
comma
id|blks_gotten
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|border
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bstart
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|hash_in
comma
id|hash_out
suffix:semicolon
r_int
r_int
id|saved_search_start
op_assign
id|search_start
suffix:semicolon
r_int
id|allocated
(braket
id|PREALLOCATION_SIZE
)braket
suffix:semicolon
r_int
id|blks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_no_border
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
multiline_comment|/* we default to having the border at the 10% mark of the disk.  This&n;    ** is an arbitrary decision and it needs tuning.  It also needs a limit&n;    ** to prevent it from taking too much space on huge drives.&n;    */
id|bstart
op_assign
(paren
id|SB_BLOCK_COUNT
c_func
(paren
id|th-&gt;t_super
)paren
op_div
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_no_unhashed_relocation
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
multiline_comment|/* this is a very simple first attempt at preventing too much grouping&n;    ** around the border value.  Since k_dir_id is never larger than the&n;    ** highest allocated oid, it is far from perfect, and files will tend&n;    ** to be grouped towards the start of the border&n;    */
id|border
op_assign
(paren
id|INODE_PKEY
c_func
(paren
id|p_s_inode
)paren
op_member_access_from_pointer
id|k_dir_id
)paren
op_mod
(paren
id|SB_BLOCK_COUNT
c_func
(paren
id|th-&gt;t_super
)paren
op_minus
id|bstart
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* why would we want to delcare a local variable to this if statement&n;    ** name border????? -chris&n;    ** unsigned long border = 0;&n;    */
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_hashed_relocation
c_func
(paren
id|th-&gt;t_super
)paren
)paren
(brace
id|hash_in
op_assign
(paren
id|INODE_PKEY
c_func
(paren
id|p_s_inode
)paren
)paren
op_member_access_from_pointer
id|k_dir_id
suffix:semicolon
multiline_comment|/* I wonder if the CPU cost of the&n;                                   hash will obscure the layout&n;                                   effect? Of course, whether that&n;                                   effect is good or bad we don&squot;t&n;                                   know.... :-) */
id|hash_out
op_assign
id|keyed_hash
c_func
(paren
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
id|hash_in
)paren
)paren
comma
l_int|4
)paren
suffix:semicolon
id|border
op_assign
id|hash_out
op_mod
(paren
id|SB_BLOCK_COUNT
c_func
(paren
id|th-&gt;t_super
)paren
op_minus
id|bstart
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|border
op_add_assign
id|bstart
suffix:semicolon
id|allocated
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* important.  Allows a check later on to see if at&n;                      * least one block was allocated.  This prevents false&n;&t;&t;      * no disk space returns&n;&t;&t;      */
r_if
c_cond
(paren
(paren
id|p_s_inode-&gt;i_size
OL
l_int|4
op_star
l_int|4096
)paren
op_logical_or
op_logical_neg
(paren
id|S_ISREG
c_func
(paren
id|p_s_inode-&gt;i_mode
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|search_start
OL
id|border
op_logical_or
(paren
multiline_comment|/* allow us to test whether it is a&n;                                   good idea to prevent files from&n;                                   getting too far away from their&n;                                   packing locality by some unexpected&n;                                   means.  This might be poor code for&n;                                   directories whose files total&n;                                   larger than 1/10th of the disk, and&n;                                   it might be good code for&n;                                   suffering from old insertions when the disk&n;                                   was almost full. */
multiline_comment|/* changed from !reiserfs_test3(th-&gt;t_super), which doesn&squot;t&n;               ** seem like a good idea.  Think about adding blocks to&n;               ** a large file.  If you&squot;ve allocated 10% of the disk&n;               ** in contiguous blocks, you start over at the border value&n;               ** for every new allocation.  This throws away all the&n;               ** information sent in about the last block that was allocated&n;               ** in the file.  Not a good general case at all.&n;               ** -chris&n;               */
id|reiserfs_test4
c_func
(paren
id|th-&gt;t_super
)paren
op_logical_and
(paren
id|search_start
OG
id|border
op_plus
(paren
id|SB_BLOCK_COUNT
c_func
(paren
id|th-&gt;t_super
)paren
op_div
l_int|10
)paren
)paren
)paren
)paren
id|search_start
op_assign
id|border
suffix:semicolon
id|ret
op_assign
id|do_reiserfs_new_blocknrs
c_func
(paren
id|th
comma
id|free_blocknrs
comma
id|search_start
comma
l_int|1
multiline_comment|/*amount_needed*/
comma
l_int|0
multiline_comment|/*use reserved blocks for root */
comma
l_int|1
multiline_comment|/*for_formatted*/
comma
l_int|0
multiline_comment|/*for prealloc */
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* take a block off the prealloc list and return it -Hans */
r_if
c_cond
(paren
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_count
OG
l_int|0
)paren
(brace
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_count
op_decrement
suffix:semicolon
op_star
id|free_blocknrs
op_assign
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_block
op_increment
suffix:semicolon
multiline_comment|/* if no more preallocated blocks, remove inode from list */
r_if
c_cond
(paren
op_logical_neg
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_count
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_list
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* else get a new preallocation for the file */
id|reiserfs_discard_prealloc
(paren
id|th
comma
id|p_s_inode
)paren
suffix:semicolon
multiline_comment|/* this uses the last preallocated block as the search_start.  discard&n;  ** prealloc does not zero out this number.&n;  */
r_if
c_cond
(paren
id|search_start
op_le
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_block
)paren
(brace
id|search_start
op_assign
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_block
suffix:semicolon
)brace
multiline_comment|/* doing the compare again forces search_start to be &gt;= the border,&n;  ** even if the file already had prealloction done.  This seems extra,&n;  ** and should probably be removed&n;  */
r_if
c_cond
(paren
id|search_start
OL
id|border
)paren
id|search_start
op_assign
id|border
suffix:semicolon
multiline_comment|/* If the disk free space is already below 10% we should &n;  ** start looking for the free blocks from the beginning &n;  ** of the partition, before the border line.&n;  */
r_if
c_cond
(paren
id|SB_FREE_BLOCKS
c_func
(paren
id|th-&gt;t_super
)paren
op_le
(paren
id|SB_BLOCK_COUNT
c_func
(paren
id|th-&gt;t_super
)paren
op_div
l_int|10
)paren
)paren
(brace
id|search_start
op_assign
id|saved_search_start
suffix:semicolon
)brace
op_star
id|free_blocknrs
op_assign
l_int|0
suffix:semicolon
id|blks
op_assign
id|PREALLOCATION_SIZE
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|blks_gotten
op_assign
l_int|0
suffix:semicolon
id|blks_gotten
OL
id|PREALLOCATION_SIZE
suffix:semicolon
id|blks_gotten
op_increment
)paren
(brace
id|ret
op_assign
id|do_reiserfs_new_blocknrs
c_func
(paren
id|th
comma
id|free_blocknrs
comma
id|search_start
comma
l_int|1
multiline_comment|/*amount_needed*/
comma
l_int|0
multiline_comment|/*for root reserved*/
comma
l_int|1
multiline_comment|/*for_formatted*/
comma
(paren
id|blks_gotten
OG
l_int|0
)paren
multiline_comment|/*must_be_contiguous*/
)paren
suffix:semicolon
multiline_comment|/* if we didn&squot;t find a block this time, adjust blks to reflect&n;    ** the actual number of blocks allocated&n;    */
r_if
c_cond
(paren
id|ret
op_ne
id|CARRY_ON
)paren
(brace
id|blks
op_assign
id|blks_gotten
OG
l_int|0
ques
c_cond
(paren
id|blks_gotten
op_minus
l_int|1
)paren
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|allocated
(braket
id|blks_gotten
)braket
op_assign
op_star
id|free_blocknrs
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
(paren
id|blks_gotten
OG
l_int|0
)paren
op_logical_and
(paren
id|allocated
(braket
id|blks_gotten
)braket
op_minus
id|allocated
(braket
id|blks_gotten
op_minus
l_int|1
)braket
)paren
op_ne
l_int|1
)paren
(brace
multiline_comment|/* this should be caught by new_blocknrs now, checking code */
id|reiserfs_warning
c_func
(paren
l_string|&quot;yura-1, reiserfs_new_unf_blocknrs2: pre-allocated not contiguous set of blocks!&bslash;n&quot;
)paren
suffix:semicolon
id|reiserfs_free_block
c_func
(paren
id|th
comma
id|allocated
(braket
id|blks_gotten
)braket
)paren
suffix:semicolon
id|blks
op_assign
id|blks_gotten
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|blks_gotten
op_eq
l_int|0
)paren
(brace
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_block
op_assign
op_star
id|free_blocknrs
suffix:semicolon
)brace
id|search_start
op_assign
op_star
id|free_blocknrs
suffix:semicolon
op_star
id|free_blocknrs
op_assign
l_int|0
suffix:semicolon
)brace
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_count
op_assign
id|blks
suffix:semicolon
op_star
id|free_blocknrs
op_assign
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_block
suffix:semicolon
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_block
op_increment
suffix:semicolon
multiline_comment|/* if inode has preallocated blocks, link him to list */
r_if
c_cond
(paren
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_count
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|p_s_inode-&gt;u.reiserfs_i.i_prealloc_list
comma
op_amp
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_prealloc_list
)paren
suffix:semicolon
)brace
multiline_comment|/* we did actually manage to get 1 block */
r_if
c_cond
(paren
id|ret
op_ne
id|CARRY_ON
op_logical_and
id|allocated
(braket
l_int|0
)braket
OG
l_int|0
)paren
(brace
r_return
id|CARRY_ON
suffix:semicolon
)brace
multiline_comment|/* NO_MORE_UNUSED_CONTIGUOUS_BLOCKS should only mean something to&n;  ** the preallocation code.  The rest of the filesystem asks for a block&n;  ** and should either get it, or know the disk is full.  The code&n;  ** above should never allow ret == NO_MORE_UNUSED_CONTIGUOUS_BLOCK,&n;  ** as it doesn&squot;t send for_prealloc = 1 to do_reiserfs_new_blocknrs&n;  ** unless it has already successfully allocated at least one block.&n;  ** Just in case, we translate into a return value the rest of the&n;  ** filesystem can understand.&n;  **&n;  ** It is an error to change this without making the&n;  ** rest of the filesystem understand NO_MORE_UNUSED_CONTIGUOUS_BLOCKS&n;  ** If you consider it a bug to return NO_DISK_SPACE here, fix the rest&n;  ** of the fs first.&n;  */
r_if
c_cond
(paren
id|ret
op_eq
id|NO_MORE_UNUSED_CONTIGUOUS_BLOCKS
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|reiserfs_warning
c_func
(paren
l_string|&quot;reiser-2015: this shouldn&squot;t happen, may cause false out of disk space error&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|NO_DISK_SPACE
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, was derived from minix or ext2&squot;s
singleline_comment|// analog. You should be able to tell which portion by looking at the
singleline_comment|// ext2 code and comparing. 
DECL|function|__discard_prealloc
r_static
r_void
id|__discard_prealloc
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_while
c_loop
(paren
id|inode-&gt;u.reiserfs_i.i_prealloc_count
OG
l_int|0
)paren
(brace
id|reiserfs_free_block
c_func
(paren
id|th
comma
id|inode-&gt;u.reiserfs_i.i_prealloc_block
)paren
suffix:semicolon
id|inode-&gt;u.reiserfs_i.i_prealloc_block
op_increment
suffix:semicolon
id|inode-&gt;u.reiserfs_i.i_prealloc_count
op_decrement
suffix:semicolon
)brace
id|list_del
(paren
op_amp
(paren
id|inode-&gt;u.reiserfs_i.i_prealloc_list
)paren
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_discard_prealloc
r_void
id|reiserfs_discard_prealloc
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|inode-&gt;u.reiserfs_i.i_prealloc_count
OL
l_int|0
)paren
id|reiserfs_warning
c_func
(paren
l_string|&quot;zam-4001:&quot;
id|__FUNCTION__
l_string|&quot;: inode has negative prealloc blocks count.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif  
r_if
c_cond
(paren
id|inode-&gt;u.reiserfs_i.i_prealloc_count
OG
l_int|0
)paren
(brace
id|__discard_prealloc
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
)brace
)brace
DECL|function|reiserfs_discard_all_prealloc
r_void
id|reiserfs_discard_all_prealloc
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
)paren
(brace
r_struct
id|list_head
op_star
id|plist
op_assign
op_amp
id|SB_JOURNAL
c_func
(paren
id|th-&gt;t_super
)paren
op_member_access_from_pointer
id|j_prealloc_list
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|plist
)paren
)paren
(brace
id|inode
op_assign
id|list_entry
c_func
(paren
id|plist-&gt;next
comma
r_struct
id|inode
comma
id|u.reiserfs_i.i_prealloc_list
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;u.reiserfs_i.i_prealloc_count
)paren
(brace
id|reiserfs_warning
c_func
(paren
l_string|&quot;zam-4001:&quot;
id|__FUNCTION__
l_string|&quot;: inode is in prealloc list but has no preallocated blocks.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif    
id|__discard_prealloc
c_func
(paren
id|th
comma
id|inode
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
