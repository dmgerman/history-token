multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;stdarg.h&gt;
DECL|variable|error_buf
r_static
r_char
id|error_buf
(braket
l_int|1024
)braket
suffix:semicolon
DECL|variable|fmt_buf
r_static
r_char
id|fmt_buf
(braket
l_int|1024
)braket
suffix:semicolon
DECL|variable|off_buf
r_static
r_char
id|off_buf
(braket
l_int|80
)braket
suffix:semicolon
DECL|function|reiserfs_cpu_offset
r_static
r_char
op_star
id|reiserfs_cpu_offset
(paren
r_struct
id|cpu_key
op_star
id|key
)paren
(brace
r_if
c_cond
(paren
id|cpu_key_k_type
c_func
(paren
id|key
)paren
op_eq
id|TYPE_DIRENTRY
)paren
id|sprintf
(paren
id|off_buf
comma
l_string|&quot;%Lu(%Lu)&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|GET_HASH_VALUE
(paren
id|cpu_key_k_offset
(paren
id|key
)paren
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|GET_GENERATION_NUMBER
(paren
id|cpu_key_k_offset
(paren
id|key
)paren
)paren
)paren
suffix:semicolon
r_else
id|sprintf
(paren
id|off_buf
comma
l_string|&quot;0x%Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|cpu_key_k_offset
(paren
id|key
)paren
)paren
suffix:semicolon
r_return
id|off_buf
suffix:semicolon
)brace
DECL|function|le_offset
r_static
r_char
op_star
id|le_offset
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
r_int
id|version
suffix:semicolon
id|version
op_assign
id|le_key_version
(paren
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_type
(paren
id|version
comma
id|key
)paren
op_eq
id|TYPE_DIRENTRY
)paren
id|sprintf
(paren
id|off_buf
comma
l_string|&quot;%Lu(%Lu)&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|GET_HASH_VALUE
(paren
id|le_key_k_offset
(paren
id|version
comma
id|key
)paren
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|GET_GENERATION_NUMBER
(paren
id|le_key_k_offset
(paren
id|version
comma
id|key
)paren
)paren
)paren
suffix:semicolon
r_else
id|sprintf
(paren
id|off_buf
comma
l_string|&quot;0x%Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|le_key_k_offset
(paren
id|version
comma
id|key
)paren
)paren
suffix:semicolon
r_return
id|off_buf
suffix:semicolon
)brace
DECL|function|cpu_type
r_static
r_char
op_star
id|cpu_type
(paren
r_struct
id|cpu_key
op_star
id|key
)paren
(brace
r_if
c_cond
(paren
id|cpu_key_k_type
(paren
id|key
)paren
op_eq
id|TYPE_STAT_DATA
)paren
r_return
l_string|&quot;SD&quot;
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_type
(paren
id|key
)paren
op_eq
id|TYPE_DIRENTRY
)paren
r_return
l_string|&quot;DIR&quot;
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_type
(paren
id|key
)paren
op_eq
id|TYPE_DIRECT
)paren
r_return
l_string|&quot;DIRECT&quot;
suffix:semicolon
r_if
c_cond
(paren
id|cpu_key_k_type
(paren
id|key
)paren
op_eq
id|TYPE_INDIRECT
)paren
r_return
l_string|&quot;IND&quot;
suffix:semicolon
r_return
l_string|&quot;UNKNOWN&quot;
suffix:semicolon
)brace
DECL|function|le_type
r_static
r_char
op_star
id|le_type
(paren
r_struct
id|key
op_star
id|key
)paren
(brace
r_int
id|version
suffix:semicolon
id|version
op_assign
id|le_key_version
(paren
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_type
(paren
id|version
comma
id|key
)paren
op_eq
id|TYPE_STAT_DATA
)paren
r_return
l_string|&quot;SD&quot;
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_type
(paren
id|version
comma
id|key
)paren
op_eq
id|TYPE_DIRENTRY
)paren
r_return
l_string|&quot;DIR&quot;
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_type
(paren
id|version
comma
id|key
)paren
op_eq
id|TYPE_DIRECT
)paren
r_return
l_string|&quot;DIRECT&quot;
suffix:semicolon
r_if
c_cond
(paren
id|le_key_k_type
(paren
id|version
comma
id|key
)paren
op_eq
id|TYPE_INDIRECT
)paren
r_return
l_string|&quot;IND&quot;
suffix:semicolon
r_return
l_string|&quot;UNKNOWN&quot;
suffix:semicolon
)brace
multiline_comment|/* %k */
DECL|function|sprintf_le_key
r_static
r_void
id|sprintf_le_key
(paren
r_char
op_star
id|buf
comma
r_struct
id|key
op_star
id|key
)paren
(brace
r_if
c_cond
(paren
id|key
)paren
id|sprintf
(paren
id|buf
comma
l_string|&quot;[%d %d %s %s]&quot;
comma
id|le32_to_cpu
(paren
id|key-&gt;k_dir_id
)paren
comma
id|le32_to_cpu
(paren
id|key-&gt;k_objectid
)paren
comma
id|le_offset
(paren
id|key
)paren
comma
id|le_type
(paren
id|key
)paren
)paren
suffix:semicolon
r_else
id|sprintf
(paren
id|buf
comma
l_string|&quot;[NULL]&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* %K */
DECL|function|sprintf_cpu_key
r_static
r_void
id|sprintf_cpu_key
(paren
r_char
op_star
id|buf
comma
r_struct
id|cpu_key
op_star
id|key
)paren
(brace
r_if
c_cond
(paren
id|key
)paren
id|sprintf
(paren
id|buf
comma
l_string|&quot;[%d %d %s %s]&quot;
comma
id|key-&gt;on_disk_key.k_dir_id
comma
id|key-&gt;on_disk_key.k_objectid
comma
id|reiserfs_cpu_offset
(paren
id|key
)paren
comma
id|cpu_type
(paren
id|key
)paren
)paren
suffix:semicolon
r_else
id|sprintf
(paren
id|buf
comma
l_string|&quot;[NULL]&quot;
)paren
suffix:semicolon
)brace
DECL|function|sprintf_de_head
r_static
r_void
id|sprintf_de_head
c_func
(paren
r_char
op_star
id|buf
comma
r_struct
id|reiserfs_de_head
op_star
id|deh
)paren
(brace
r_if
c_cond
(paren
id|deh
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;[offset=%d dir_id=%d objectid=%d location=%d state=%04x]&quot;
comma
id|deh_offset
c_func
(paren
id|deh
)paren
comma
id|deh_dir_id
c_func
(paren
id|deh
)paren
comma
id|deh_objectid
c_func
(paren
id|deh
)paren
comma
id|deh_location
c_func
(paren
id|deh
)paren
comma
id|deh_state
c_func
(paren
id|deh
)paren
)paren
suffix:semicolon
)brace
r_else
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;[NULL]&quot;
)paren
suffix:semicolon
)brace
DECL|function|sprintf_item_head
r_static
r_void
id|sprintf_item_head
(paren
r_char
op_star
id|buf
comma
r_struct
id|item_head
op_star
id|ih
)paren
(brace
r_if
c_cond
(paren
id|ih
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;%s&quot;
comma
(paren
id|ih_version
(paren
id|ih
)paren
op_eq
id|KEY_FORMAT_3_6
)paren
ques
c_cond
l_string|&quot;*3.6* &quot;
suffix:colon
l_string|&quot;*3.5*&quot;
)paren
suffix:semicolon
id|sprintf_le_key
(paren
id|buf
op_plus
id|strlen
(paren
id|buf
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
suffix:semicolon
id|sprintf
(paren
id|buf
op_plus
id|strlen
(paren
id|buf
)paren
comma
l_string|&quot;, item_len %d, item_location %d, &quot;
l_string|&quot;free_space(entry_count) %d&quot;
comma
id|ih_item_len
c_func
(paren
id|ih
)paren
comma
id|ih_location
c_func
(paren
id|ih
)paren
comma
id|ih_free_space
(paren
id|ih
)paren
)paren
suffix:semicolon
)brace
r_else
id|sprintf
(paren
id|buf
comma
l_string|&quot;[NULL]&quot;
)paren
suffix:semicolon
)brace
DECL|function|sprintf_direntry
r_static
r_void
id|sprintf_direntry
(paren
r_char
op_star
id|buf
comma
r_struct
id|reiserfs_dir_entry
op_star
id|de
)paren
(brace
r_char
id|name
(braket
l_int|20
)braket
suffix:semicolon
id|memcpy
(paren
id|name
comma
id|de-&gt;de_name
comma
id|de-&gt;de_namelen
OG
l_int|19
ques
c_cond
l_int|19
suffix:colon
id|de-&gt;de_namelen
)paren
suffix:semicolon
id|name
(braket
id|de-&gt;de_namelen
OG
l_int|19
ques
c_cond
l_int|19
suffix:colon
id|de-&gt;de_namelen
)braket
op_assign
l_int|0
suffix:semicolon
id|sprintf
(paren
id|buf
comma
l_string|&quot;&bslash;&quot;%s&bslash;&quot;==&gt;[%d %d]&quot;
comma
id|name
comma
id|de-&gt;de_dir_id
comma
id|de-&gt;de_objectid
)paren
suffix:semicolon
)brace
DECL|function|sprintf_block_head
r_static
r_void
id|sprintf_block_head
(paren
r_char
op_star
id|buf
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;level=%d, nr_items=%d, free_space=%d rdkey &quot;
comma
id|B_LEVEL
(paren
id|bh
)paren
comma
id|B_NR_ITEMS
(paren
id|bh
)paren
comma
id|B_FREE_SPACE
(paren
id|bh
)paren
)paren
suffix:semicolon
)brace
DECL|function|sprintf_buffer_head
r_static
r_void
id|sprintf_buffer_head
(paren
r_char
op_star
id|buf
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;dev %s, size %d, blocknr %ld, count %d, list %d, state 0x%lx, page %p, (%s, %s, %s)&quot;
comma
id|kdevname
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_size
comma
id|bh-&gt;b_blocknr
comma
id|atomic_read
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
comma
id|bh-&gt;b_list
comma
id|bh-&gt;b_state
comma
id|bh-&gt;b_page
comma
id|buffer_uptodate
(paren
id|bh
)paren
ques
c_cond
l_string|&quot;UPTODATE&quot;
suffix:colon
l_string|&quot;!UPTODATE&quot;
comma
id|buffer_dirty
(paren
id|bh
)paren
ques
c_cond
l_string|&quot;DIRTY&quot;
suffix:colon
l_string|&quot;CLEAN&quot;
comma
id|buffer_locked
(paren
id|bh
)paren
ques
c_cond
l_string|&quot;LOCKED&quot;
suffix:colon
l_string|&quot;UNLOCKED&quot;
)paren
suffix:semicolon
)brace
DECL|function|sprintf_disk_child
r_static
r_void
id|sprintf_disk_child
(paren
r_char
op_star
id|buf
comma
r_struct
id|disk_child
op_star
id|dc
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;[dc_number=%d, dc_size=%u]&quot;
comma
id|dc_block_number
c_func
(paren
id|dc
)paren
comma
id|dc_size
c_func
(paren
id|dc
)paren
)paren
suffix:semicolon
)brace
DECL|function|is_there_reiserfs_struct
r_static
r_char
op_star
id|is_there_reiserfs_struct
(paren
r_char
op_star
id|fmt
comma
r_int
op_star
id|what
comma
r_int
op_star
id|skip
)paren
(brace
r_char
op_star
id|k
op_assign
id|fmt
suffix:semicolon
op_star
id|skip
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|k
op_assign
id|strstr
(paren
id|k
comma
l_string|&quot;%&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;k&squot;
op_logical_or
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;K&squot;
op_logical_or
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;h&squot;
op_logical_or
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;t&squot;
op_logical_or
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;z&squot;
op_logical_or
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;b&squot;
op_logical_or
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;y&squot;
op_logical_or
id|k
(braket
l_int|1
)braket
op_eq
l_char|&squot;a&squot;
)paren
(brace
op_star
id|what
op_assign
id|k
(braket
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
(paren
op_star
id|skip
)paren
op_increment
suffix:semicolon
id|k
op_increment
suffix:semicolon
)brace
r_return
id|k
suffix:semicolon
)brace
multiline_comment|/* debugging reiserfs we used to print out a lot of different&n;   variables, like keys, item headers, buffer heads etc. Values of&n;   most fields matter. So it took a long time just to write&n;   appropriative printk. With this reiserfs_warning you can use format&n;   specification for complex structures like you used to do with&n;   printfs for integers, doubles and pointers. For instance, to print&n;   out key structure you have to write just: &n;   reiserfs_warning (&quot;bad key %k&quot;, key); &n;   instead of &n;   printk (&quot;bad key %lu %lu %lu %lu&quot;, key-&gt;k_dir_id, key-&gt;k_objectid, &n;           key-&gt;k_offset, key-&gt;k_uniqueness); &n;*/
r_static
r_void
DECL|function|prepare_error_buf
id|prepare_error_buf
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
id|va_list
id|args
)paren
(brace
r_char
op_star
id|fmt1
op_assign
id|fmt_buf
suffix:semicolon
r_char
op_star
id|k
suffix:semicolon
r_char
op_star
id|p
op_assign
id|error_buf
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|what
comma
id|skip
suffix:semicolon
id|strcpy
(paren
id|fmt1
comma
id|fmt
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|k
op_assign
id|is_there_reiserfs_struct
c_func
(paren
id|fmt1
comma
op_amp
id|what
comma
op_amp
id|skip
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
op_star
id|k
op_assign
l_int|0
suffix:semicolon
id|p
op_add_assign
id|vsprintf
(paren
id|p
comma
id|fmt1
comma
id|args
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skip
suffix:semicolon
id|i
op_increment
)paren
id|j
op_assign
id|va_arg
(paren
id|args
comma
r_int
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
l_char|&squot;k&squot;
suffix:colon
id|sprintf_le_key
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|key
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;K&squot;
suffix:colon
id|sprintf_cpu_key
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|cpu_key
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|sprintf_item_head
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|item_head
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|sprintf_direntry
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|reiserfs_dir_entry
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;y&squot;
suffix:colon
id|sprintf_disk_child
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|disk_child
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;z&squot;
suffix:colon
id|sprintf_block_head
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|buffer_head
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|sprintf_buffer_head
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|buffer_head
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;a&squot;
suffix:colon
id|sprintf_de_head
(paren
id|p
comma
id|va_arg
c_func
(paren
id|args
comma
r_struct
id|reiserfs_de_head
op_star
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|p
op_add_assign
id|strlen
(paren
id|p
)paren
suffix:semicolon
id|fmt1
op_assign
id|k
op_plus
l_int|2
suffix:semicolon
)brace
id|vsprintf
(paren
id|p
comma
id|fmt1
comma
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/* in addition to usual conversion specifiers this accepts reiserfs&n;   specific conversion specifiers: &n;   %k to print little endian key, &n;   %K to print cpu key, &n;   %h to print item_head,&n;   %t to print directory entry &n;   %z to print block head (arg must be struct buffer_head *&n;   %b to print buffer_head&n;*/
DECL|macro|do_reiserfs_warning
mdefine_line|#define do_reiserfs_warning(fmt)&bslash;&n;{&bslash;&n;    va_list args;&bslash;&n;    va_start( args, fmt );&bslash;&n;    prepare_error_buf( fmt, args );&bslash;&n;    va_end( args );&bslash;&n;}
DECL|function|reiserfs_warning
r_void
id|reiserfs_warning
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|do_reiserfs_warning
c_func
(paren
id|fmt
)paren
suffix:semicolon
multiline_comment|/* console_print (error_buf); */
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s&quot;
comma
id|error_buf
)paren
suffix:semicolon
)brace
DECL|function|reiserfs_debug
r_void
id|reiserfs_debug
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
id|level
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|do_reiserfs_warning
c_func
(paren
id|fmt
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s&quot;
comma
id|error_buf
)paren
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* The format:&n;&n;           maintainer-errorid: [function-name:] message&n;&n;    where errorid is unique to the maintainer and function-name is&n;    optional, is recommended, so that anyone can easily find the bug&n;    with a simple grep for the short to type string&n;    maintainer-errorid.  Don&squot;t bother with reusing errorids, there are&n;    lots of numbers out there.&n;&n;    Example: &n;    &n;    reiserfs_panic(&n;&t;p_sb, &quot;reiser-29: reiserfs_new_blocknrs: &quot;&n;&t;&quot;one of search_start or rn(%d) is equal to MAX_B_NUM,&quot;&n;&t;&quot;which means that we are optimizing location based on the bogus location of a temp buffer (%p).&quot;, &n;&t;rn, bh&n;    );&n;&n;    Regular panic()s sometimes clear the screen before the message can&n;    be read, thus the need for the while loop.  &n;&n;    Numbering scheme for panic used by Vladimir and Anatoly( Hans completely ignores this scheme, and considers it&n;    pointless complexity):&n;&n;    panics in reiserfs_fs.h have numbers from 1000 to 1999&n;    super.c&t;&t;&t;&t;        2000 to 2999&n;    preserve.c (unused)&t;&t;&t;    3000 to 3999&n;    bitmap.c&t;&t;&t;&t;    4000 to 4999&n;    stree.c&t;&t;&t;&t;        5000 to 5999&n;    prints.c&t;&t;&t;&t;    6000 to 6999&n;    namei.c                     7000 to 7999&n;    fix_nodes.c                 8000 to 8999&n;    dir.c                       9000 to 9999&n;&t;lbalance.c&t;&t;&t;&t;&t;10000 to 10999&n;&t;ibalance.c&t;&t;11000 to 11999 not ready&n;&t;do_balan.c&t;&t;12000 to 12999&n;&t;inode.c&t;&t;&t;13000 to 13999&n;&t;file.c&t;&t;&t;14000 to 14999&n;    objectid.c                       15000 - 15999&n;    buffer.c                         16000 - 16999&n;    symlink.c                        17000 - 17999&n;&n;   .  */
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_extern
r_struct
id|tree_balance
op_star
id|cur_tb
suffix:semicolon
macro_line|#endif
DECL|function|reiserfs_panic
r_void
id|reiserfs_panic
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|show_reiserfs_locks
c_func
(paren
)paren
suffix:semicolon
id|do_reiserfs_warning
c_func
(paren
id|fmt
)paren
suffix:semicolon
id|printk
(paren
id|KERN_EMERG
l_string|&quot;%s&quot;
comma
id|error_buf
)paren
suffix:semicolon
id|BUG
(paren
)paren
suffix:semicolon
multiline_comment|/* this is not actually called, but makes reiserfs_panic() &quot;noreturn&quot; */
id|panic
(paren
l_string|&quot;REISERFS: panic (device %s): %s&bslash;n&quot;
comma
id|sb
ques
c_cond
id|sb-&gt;s_id
suffix:colon
l_string|&quot;sb == 0&quot;
comma
id|error_buf
)paren
suffix:semicolon
)brace
DECL|function|print_virtual_node
r_void
id|print_virtual_node
(paren
r_struct
id|virtual_node
op_star
id|vn
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|virtual_item
op_star
id|vi
suffix:semicolon
id|printk
(paren
l_string|&quot;VIRTUAL NODE CONTAINS %d items, has size %d,%s,%s, ITEM_POS=%d POS_IN_ITEM=%d MODE=&bslash;&squot;%c&bslash;&squot;&bslash;n&quot;
comma
id|vn-&gt;vn_nr_item
comma
id|vn-&gt;vn_size
comma
(paren
id|vn-&gt;vn_vi
(braket
l_int|0
)braket
dot
id|vi_type
op_amp
id|VI_TYPE_LEFT_MERGEABLE
)paren
ques
c_cond
l_string|&quot;left mergeable&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|vn-&gt;vn_vi
(braket
id|vn-&gt;vn_nr_item
op_minus
l_int|1
)braket
dot
id|vi_type
op_amp
id|VI_TYPE_RIGHT_MERGEABLE
)paren
ques
c_cond
l_string|&quot;right mergeable&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|vn-&gt;vn_affected_item_num
comma
id|vn-&gt;vn_pos_in_item
comma
id|vn-&gt;vn_mode
)paren
suffix:semicolon
id|vi
op_assign
id|vn-&gt;vn_vi
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|vn-&gt;vn_nr_item
suffix:semicolon
id|i
op_increment
comma
id|vi
op_increment
)paren
id|op_print_vi
(paren
id|vi
)paren
suffix:semicolon
)brace
DECL|function|print_path
r_void
id|print_path
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_struct
id|path
op_star
id|path
)paren
(brace
r_int
id|h
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|tb
)paren
(brace
r_while
c_loop
(paren
id|tb-&gt;insert_size
(braket
id|h
)braket
)paren
(brace
id|bh
op_assign
id|PATH_H_PBUFFER
(paren
id|path
comma
id|h
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;block %lu (level=%d), position %d&bslash;n&quot;
comma
id|bh
ques
c_cond
id|bh-&gt;b_blocknr
suffix:colon
l_int|0
comma
id|bh
ques
c_cond
id|B_LEVEL
(paren
id|bh
)paren
suffix:colon
l_int|0
comma
id|PATH_H_POSITION
(paren
id|path
comma
id|h
)paren
)paren
suffix:semicolon
id|h
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|offset
op_assign
id|path-&gt;path_length
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|printk
(paren
l_string|&quot;Offset    Bh     (b_blocknr, b_count) Position Nr_item&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|offset
OG
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
(brace
id|bh
op_assign
id|PATH_OFFSET_PBUFFER
(paren
id|path
comma
id|offset
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%6d %10p (%9lu, %7d) %8d %7d&bslash;n&quot;
comma
id|offset
comma
id|bh
comma
id|bh
ques
c_cond
id|bh-&gt;b_blocknr
suffix:colon
l_int|0
comma
id|bh
ques
c_cond
id|atomic_read
(paren
op_amp
(paren
id|bh-&gt;b_count
)paren
)paren
suffix:colon
l_int|0
comma
id|PATH_OFFSET_POSITION
(paren
id|path
comma
id|offset
)paren
comma
id|bh
ques
c_cond
id|B_NR_ITEMS
(paren
id|bh
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
id|offset
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* this prints internal nodes (4 keys/items in line) (dc_number,&n;   dc_size)[k_dirid, k_objectid, k_offset, k_uniqueness](dc_number,&n;   dc_size)...*/
DECL|function|print_internal
r_static
r_int
id|print_internal
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|first
comma
r_int
id|last
)paren
(brace
r_struct
id|key
op_star
id|key
suffix:semicolon
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|from
comma
id|to
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|B_IS_KEYS_LEVEL
(paren
id|bh
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|check_internal
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
op_eq
op_minus
l_int|1
)paren
(brace
id|from
op_assign
l_int|0
suffix:semicolon
id|to
op_assign
id|B_NR_ITEMS
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|from
op_assign
id|first
suffix:semicolon
id|to
op_assign
id|last
OL
id|B_NR_ITEMS
(paren
id|bh
)paren
ques
c_cond
id|last
suffix:colon
id|B_NR_ITEMS
(paren
id|bh
)paren
suffix:semicolon
)brace
id|reiserfs_warning
(paren
l_string|&quot;INTERNAL NODE (%ld) contains %z&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|bh
)paren
suffix:semicolon
id|dc
op_assign
id|B_N_CHILD
(paren
id|bh
comma
id|from
)paren
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;PTR %d: %y &quot;
comma
id|from
comma
id|dc
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|from
comma
id|key
op_assign
id|B_N_PDELIM_KEY
(paren
id|bh
comma
id|from
)paren
comma
id|dc
op_increment
suffix:semicolon
id|i
OL
id|to
suffix:semicolon
id|i
op_increment
comma
id|key
op_increment
comma
id|dc
op_increment
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;KEY %d: %k PTR %d: %y &quot;
comma
id|i
comma
id|key
comma
id|i
op_plus
l_int|1
comma
id|dc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
id|i
op_mod
l_int|4
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|print_leaf
r_static
r_int
id|print_leaf
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|print_mode
comma
r_int
id|first
comma
r_int
id|last
)paren
(brace
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
id|from
comma
id|to
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|B_IS_ITEMS_LEVEL
(paren
id|bh
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|check_leaf
(paren
id|bh
)paren
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
(paren
id|bh
)paren
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|nr
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n===================================================================&bslash;n&quot;
)paren
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;LEAF NODE (%ld) contains %z&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|print_mode
op_amp
id|PRINT_LEAF_ITEMS
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;FIRST ITEM_KEY: %k, LAST ITEM KEY: %k&bslash;n&quot;
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
op_amp
(paren
(paren
id|ih
op_plus
id|nr
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|ih_key
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first
template_param
id|nr
op_minus
l_int|1
)paren
id|from
op_assign
l_int|0
suffix:semicolon
r_else
id|from
op_assign
id|first
suffix:semicolon
r_if
c_cond
(paren
id|last
template_param
id|nr
)paren
id|to
op_assign
id|nr
suffix:semicolon
r_else
id|to
op_assign
id|last
suffix:semicolon
id|ih
op_add_assign
id|from
suffix:semicolon
id|printk
(paren
l_string|&quot;-------------------------------------------------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;|##|   type    |           key           | ilen | free_space | version | loc  |&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|from
suffix:semicolon
id|i
OL
id|to
suffix:semicolon
id|i
op_increment
comma
id|ih
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;-------------------------------------------------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;|%2d| %h |&bslash;n&quot;
comma
id|i
comma
id|ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|print_mode
op_amp
id|PRINT_LEAF_ITEMS
)paren
id|op_print_item
(paren
id|ih
comma
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;===================================================================&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return 1 if this is not super block */
DECL|function|print_super_block
r_static
r_int
id|print_super_block
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_super_block
op_star
id|rs
op_assign
(paren
r_struct
id|reiserfs_super_block
op_star
)paren
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
r_int
id|skipped
comma
id|data_blocks
suffix:semicolon
r_char
op_star
id|version
suffix:semicolon
r_if
c_cond
(paren
id|is_reiserfs_3_5
c_func
(paren
id|rs
)paren
)paren
(brace
id|version
op_assign
l_string|&quot;3.5&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_reiserfs_3_6
c_func
(paren
id|rs
)paren
)paren
(brace
id|version
op_assign
l_string|&quot;3.6&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_reiserfs_jr
c_func
(paren
id|rs
)paren
)paren
(brace
id|version
op_assign
(paren
(paren
id|sb_version
c_func
(paren
id|rs
)paren
op_eq
id|REISERFS_VERSION_2
)paren
ques
c_cond
l_string|&quot;3.6&quot;
suffix:colon
l_string|&quot;3.5&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s&bslash;&squot;s super block in block %ld&bslash;n======================&bslash;n&quot;
comma
id|kdevname
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Reiserfs version %s&bslash;n&quot;
comma
id|version
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Block count %u&bslash;n&quot;
comma
id|sb_block_count
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Blocksize %d&bslash;n&quot;
comma
id|sb_blocksize
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Free blocks %u&bslash;n&quot;
comma
id|sb_free_blocks
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
singleline_comment|// FIXME: this would be confusing if
singleline_comment|// someone stores reiserfs super block in some data block ;)
singleline_comment|//    skipped = (bh-&gt;b_blocknr * bh-&gt;b_size) / sb_blocksize(rs);
id|skipped
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|data_blocks
op_assign
id|sb_block_count
c_func
(paren
id|rs
)paren
op_minus
id|skipped
op_minus
l_int|1
op_minus
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
op_minus
(paren
op_logical_neg
id|is_reiserfs_jr
c_func
(paren
id|rs
)paren
ques
c_cond
id|sb_jp_journal_size
c_func
(paren
id|rs
)paren
op_plus
l_int|1
suffix:colon
id|sb_reserved_for_journal
c_func
(paren
id|rs
)paren
)paren
op_minus
id|sb_free_blocks
c_func
(paren
id|rs
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Busy blocks (skipped %d, bitmaps - %d, journal (or reserved) blocks - %d&bslash;n&quot;
l_string|&quot;1 super block, %d data blocks&bslash;n&quot;
comma
id|skipped
comma
id|sb_bmap_nr
c_func
(paren
id|rs
)paren
comma
(paren
op_logical_neg
id|is_reiserfs_jr
c_func
(paren
id|rs
)paren
ques
c_cond
(paren
id|sb_jp_journal_size
c_func
(paren
id|rs
)paren
op_plus
l_int|1
)paren
suffix:colon
id|sb_reserved_for_journal
c_func
(paren
id|rs
)paren
)paren
comma
id|data_blocks
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Root block %u&bslash;n&quot;
comma
id|sb_root_block
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Journal block (first) %d&bslash;n&quot;
comma
id|sb_jp_journal_1st_block
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Journal dev %d&bslash;n&quot;
comma
id|sb_jp_journal_dev
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Journal orig size %d&bslash;n&quot;
comma
id|sb_jp_journal_size
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;FS state %d&bslash;n&quot;
comma
id|sb_fs_state
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Hash function &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|sb_hash_function_code
c_func
(paren
id|rs
)paren
op_eq
id|TEA_HASH
ques
c_cond
l_string|&quot;tea&quot;
suffix:colon
(paren
id|sb_hash_function_code
c_func
(paren
id|rs
)paren
op_eq
id|YURA_HASH
ques
c_cond
l_string|&quot;rupasov&quot;
suffix:colon
(paren
id|sb_hash_function_code
c_func
(paren
id|rs
)paren
op_eq
id|R5_HASH
ques
c_cond
l_string|&quot;r5&quot;
suffix:colon
l_string|&quot;unknown&quot;
)paren
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Tree height %d&bslash;n&quot;
comma
id|sb_tree_height
c_func
(paren
id|rs
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|print_desc_block
r_static
r_int
id|print_desc_block
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|reiserfs_journal_desc
op_star
id|desc
suffix:semicolon
id|desc
op_assign
(paren
r_struct
id|reiserfs_journal_desc
op_star
)paren
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|desc-&gt;j_magic
comma
id|JOURNAL_DESC_MAGIC
comma
l_int|8
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|printk
(paren
l_string|&quot;Desc block %lu (j_trans_id %d, j_mount_id %d, j_len %d)&quot;
comma
id|bh-&gt;b_blocknr
comma
id|desc-&gt;j_trans_id
comma
id|desc-&gt;j_mount_id
comma
id|desc-&gt;j_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|print_block
r_void
id|print_block
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
dot
dot
dot
)paren
singleline_comment|//int print_mode, int first, int last)
(brace
id|va_list
id|args
suffix:semicolon
r_int
id|mode
comma
id|first
comma
id|last
suffix:semicolon
id|va_start
(paren
id|args
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;print_block: buffer is NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mode
op_assign
id|va_arg
(paren
id|args
comma
r_int
)paren
suffix:semicolon
id|first
op_assign
id|va_arg
(paren
id|args
comma
r_int
)paren
suffix:semicolon
id|last
op_assign
id|va_arg
(paren
id|args
comma
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|print_leaf
(paren
id|bh
comma
id|mode
comma
id|first
comma
id|last
)paren
)paren
r_if
c_cond
(paren
id|print_internal
(paren
id|bh
comma
id|first
comma
id|last
)paren
)paren
r_if
c_cond
(paren
id|print_super_block
(paren
id|bh
)paren
)paren
r_if
c_cond
(paren
id|print_desc_block
(paren
id|bh
)paren
)paren
id|printk
(paren
l_string|&quot;Block %ld contains unformatted data&bslash;n&quot;
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
)brace
DECL|variable|print_tb_buf
r_char
id|print_tb_buf
(braket
l_int|2048
)braket
suffix:semicolon
multiline_comment|/* this stores initial state of tree balance in the print_tb_buf */
DECL|function|store_print_tb
r_void
id|store_print_tb
(paren
r_struct
id|tree_balance
op_star
id|tb
)paren
(brace
r_int
id|h
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tbSh
comma
op_star
id|tbFh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tb
)paren
r_return
suffix:semicolon
id|sprintf
(paren
id|print_tb_buf
comma
l_string|&quot;&bslash;n&quot;
l_string|&quot;BALANCING %d&bslash;n&quot;
l_string|&quot;MODE=%c, ITEM_POS=%d POS_IN_ITEM=%d&bslash;n&quot;
l_string|&quot;=====================================================================&bslash;n&quot;
l_string|&quot;* h *    S    *    L    *    R    *   F   *   FL  *   FR  *  CFL  *  CFR  *&bslash;n&quot;
comma
id|tb-&gt;tb_sb-&gt;u.reiserfs_sb.s_do_balance
comma
id|tb-&gt;tb_mode
comma
id|PATH_LAST_POSITION
(paren
id|tb-&gt;tb_path
)paren
comma
id|tb-&gt;tb_path-&gt;pos_in_item
)paren
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
r_sizeof
(paren
id|tb-&gt;insert_size
)paren
op_div
r_sizeof
(paren
id|tb-&gt;insert_size
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|h
op_increment
)paren
(brace
r_if
c_cond
(paren
id|PATH_H_PATH_OFFSET
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
op_le
id|tb-&gt;tb_path-&gt;path_length
op_logical_and
id|PATH_H_PATH_OFFSET
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
OG
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
(brace
id|tbSh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|tbFh
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
)brace
r_else
(brace
id|tbSh
op_assign
l_int|0
suffix:semicolon
id|tbFh
op_assign
l_int|0
suffix:semicolon
)brace
id|sprintf
(paren
id|print_tb_buf
op_plus
id|strlen
(paren
id|print_tb_buf
)paren
comma
l_string|&quot;* %d * %3ld(%2d) * %3ld(%2d) * %3ld(%2d) * %5ld * %5ld * %5ld * %5ld * %5ld *&bslash;n&quot;
comma
id|h
comma
(paren
id|tbSh
)paren
ques
c_cond
(paren
id|tbSh-&gt;b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
comma
(paren
id|tbSh
)paren
ques
c_cond
id|atomic_read
(paren
op_amp
(paren
id|tbSh-&gt;b_count
)paren
)paren
suffix:colon
op_minus
l_int|1
comma
(paren
id|tb-&gt;L
(braket
id|h
)braket
)paren
ques
c_cond
(paren
id|tb-&gt;L
(braket
id|h
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
comma
(paren
id|tb-&gt;L
(braket
id|h
)braket
)paren
ques
c_cond
id|atomic_read
(paren
op_amp
(paren
id|tb-&gt;L
(braket
id|h
)braket
op_member_access_from_pointer
id|b_count
)paren
)paren
suffix:colon
op_minus
l_int|1
comma
(paren
id|tb-&gt;R
(braket
id|h
)braket
)paren
ques
c_cond
(paren
id|tb-&gt;R
(braket
id|h
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
comma
(paren
id|tb-&gt;R
(braket
id|h
)braket
)paren
ques
c_cond
id|atomic_read
(paren
op_amp
(paren
id|tb-&gt;R
(braket
id|h
)braket
op_member_access_from_pointer
id|b_count
)paren
)paren
suffix:colon
op_minus
l_int|1
comma
(paren
id|tbFh
)paren
ques
c_cond
(paren
id|tbFh-&gt;b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
comma
(paren
id|tb-&gt;FL
(braket
id|h
)braket
)paren
ques
c_cond
(paren
id|tb-&gt;FL
(braket
id|h
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
comma
(paren
id|tb-&gt;FR
(braket
id|h
)braket
)paren
ques
c_cond
(paren
id|tb-&gt;FR
(braket
id|h
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
comma
(paren
id|tb-&gt;CFL
(braket
id|h
)braket
)paren
ques
c_cond
(paren
id|tb-&gt;CFL
(braket
id|h
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
comma
(paren
id|tb-&gt;CFR
(braket
id|h
)braket
)paren
ques
c_cond
(paren
id|tb-&gt;CFR
(braket
id|h
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:colon
(paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|sprintf
(paren
id|print_tb_buf
op_plus
id|strlen
(paren
id|print_tb_buf
)paren
comma
l_string|&quot;=====================================================================&bslash;n&quot;
l_string|&quot;* h * size * ln * lb * rn * rb * blkn * s0 * s1 * s1b * s2 * s2b * curb * lk * rk *&bslash;n&quot;
l_string|&quot;* 0 * %4d * %2d * %2d * %2d * %2d * %4d * %2d * %2d * %3d * %2d * %3d * %4d * %2d * %2d *&bslash;n&quot;
comma
id|tb-&gt;insert_size
(braket
l_int|0
)braket
comma
id|tb-&gt;lnum
(braket
l_int|0
)braket
comma
id|tb-&gt;lbytes
comma
id|tb-&gt;rnum
(braket
l_int|0
)braket
comma
id|tb-&gt;rbytes
comma
id|tb-&gt;blknum
(braket
l_int|0
)braket
comma
id|tb-&gt;s0num
comma
id|tb-&gt;s1num
comma
id|tb-&gt;s1bytes
comma
id|tb-&gt;s2num
comma
id|tb-&gt;s2bytes
comma
id|tb-&gt;cur_blknum
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* this prints balance parameters for non-leaf levels */
id|h
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|h
op_increment
suffix:semicolon
id|sprintf
(paren
id|print_tb_buf
op_plus
id|strlen
(paren
id|print_tb_buf
)paren
comma
l_string|&quot;* %d * %4d * %2d *    * %2d *    * %2d *&bslash;n&quot;
comma
id|h
comma
id|tb-&gt;insert_size
(braket
id|h
)braket
comma
id|tb-&gt;lnum
(braket
id|h
)braket
comma
id|tb-&gt;rnum
(braket
id|h
)braket
comma
id|tb-&gt;blknum
(braket
id|h
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tb-&gt;insert_size
(braket
id|h
)braket
)paren
suffix:semicolon
id|sprintf
(paren
id|print_tb_buf
op_plus
id|strlen
(paren
id|print_tb_buf
)paren
comma
l_string|&quot;=====================================================================&bslash;n&quot;
l_string|&quot;FEB list: &quot;
)paren
suffix:semicolon
multiline_comment|/* print FEB list (list of buffers in form (bh (b_blocknr, b_count), that will be used for new nodes) */
id|h
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|tb-&gt;FEB
)paren
op_div
r_sizeof
(paren
id|tb-&gt;FEB
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
id|sprintf
(paren
id|print_tb_buf
op_plus
id|strlen
(paren
id|print_tb_buf
)paren
comma
l_string|&quot;%p (%lu %d)%s&quot;
comma
id|tb-&gt;FEB
(braket
id|i
)braket
comma
id|tb-&gt;FEB
(braket
id|i
)braket
ques
c_cond
id|tb-&gt;FEB
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
suffix:colon
l_int|0
comma
id|tb-&gt;FEB
(braket
id|i
)braket
ques
c_cond
id|atomic_read
(paren
op_amp
(paren
id|tb-&gt;FEB
(braket
id|i
)braket
op_member_access_from_pointer
id|b_count
)paren
)paren
suffix:colon
l_int|0
comma
(paren
id|i
op_eq
r_sizeof
(paren
id|tb-&gt;FEB
)paren
op_div
r_sizeof
(paren
id|tb-&gt;FEB
(braket
l_int|0
)braket
)paren
op_minus
l_int|1
)paren
ques
c_cond
l_string|&quot;&bslash;n&quot;
suffix:colon
l_string|&quot;, &quot;
)paren
suffix:semicolon
id|sprintf
(paren
id|print_tb_buf
op_plus
id|strlen
(paren
id|print_tb_buf
)paren
comma
l_string|&quot;======================== the end ====================================&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|print_cur_tb
r_void
id|print_cur_tb
(paren
r_char
op_star
id|mes
)paren
(brace
id|printk
(paren
l_string|&quot;%s&bslash;n%s&quot;
comma
id|mes
comma
id|print_tb_buf
)paren
suffix:semicolon
)brace
DECL|function|check_leaf_block_head
r_static
r_void
id|check_leaf_block_head
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
(paren
id|bh
)paren
suffix:semicolon
id|nr
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
(paren
id|bh-&gt;b_size
op_minus
id|BLKH_SIZE
)paren
op_div
id|IH_SIZE
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-6010: check_leaf_block_head: invalid item number %z&quot;
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkh_free_space
c_func
(paren
id|blkh
)paren
OG
id|bh-&gt;b_size
op_minus
id|BLKH_SIZE
op_minus
id|IH_SIZE
op_star
id|nr
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-6020: check_leaf_block_head: invalid free space %z&quot;
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|check_internal_block_head
r_static
r_void
id|check_internal_block_head
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|B_LEVEL
(paren
id|bh
)paren
OG
id|DISK_LEAF_NODE_LEVEL
op_logical_and
id|B_LEVEL
(paren
id|bh
)paren
op_le
id|MAX_HEIGHT
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-6025: check_internal_block_head: invalid level %z&quot;
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|B_NR_ITEMS
(paren
id|bh
)paren
OG
(paren
id|bh-&gt;b_size
op_minus
id|BLKH_SIZE
)paren
op_div
id|IH_SIZE
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-6030: check_internal_block_head: invalid item number %z&quot;
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|B_FREE_SPACE
(paren
id|bh
)paren
op_ne
id|bh-&gt;b_size
op_minus
id|BLKH_SIZE
op_minus
id|KEY_SIZE
op_star
id|B_NR_ITEMS
(paren
id|bh
)paren
op_minus
id|DC_SIZE
op_star
(paren
id|B_NR_ITEMS
(paren
id|bh
)paren
op_plus
l_int|1
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-6040: check_internal_block_head: invalid free space %z&quot;
comma
id|bh
)paren
suffix:semicolon
)brace
DECL|function|check_leaf
r_void
id|check_leaf
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
suffix:semicolon
id|check_leaf_block_head
(paren
id|bh
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|i
OL
id|B_NR_ITEMS
(paren
id|bh
)paren
suffix:semicolon
id|i
op_increment
comma
id|ih
op_increment
)paren
id|op_check_item
(paren
id|ih
comma
id|B_I_PITEM
(paren
id|bh
comma
id|ih
)paren
)paren
suffix:semicolon
)brace
DECL|function|check_internal
r_void
id|check_internal
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
suffix:semicolon
id|check_internal_block_head
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|print_statistics
r_void
id|print_statistics
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
multiline_comment|/*&n;  printk (&quot;reiserfs_put_super: session statistics: balances %d, fix_nodes %d, &bslash;&n;bmap with search %d, without %d, dir2ind %d, ind2dir %d&bslash;n&quot;,&n;&t;  s-&gt;u.reiserfs_sb.s_do_balance, s-&gt;u.reiserfs_sb.s_fix_nodes,&n;&t;  s-&gt;u.reiserfs_sb.s_bmaps, s-&gt;u.reiserfs_sb.s_bmaps_without_search,&n;&t;  s-&gt;u.reiserfs_sb.s_direct2indirect, s-&gt;u.reiserfs_sb.s_indirect2direct);&n;  */
)brace
eof
