multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
multiline_comment|/* this is one and only function that is used outside (do_balance.c) */
r_int
id|balance_internal
(paren
r_struct
id|tree_balance
op_star
comma
r_int
comma
r_int
comma
r_struct
id|item_head
op_star
comma
r_struct
id|buffer_head
op_star
op_star
)paren
suffix:semicolon
multiline_comment|/* modes of internal_shift_left, internal_shift_right and internal_insert_childs */
DECL|macro|INTERNAL_SHIFT_FROM_S_TO_L
mdefine_line|#define INTERNAL_SHIFT_FROM_S_TO_L 0
DECL|macro|INTERNAL_SHIFT_FROM_R_TO_S
mdefine_line|#define INTERNAL_SHIFT_FROM_R_TO_S 1
DECL|macro|INTERNAL_SHIFT_FROM_L_TO_S
mdefine_line|#define INTERNAL_SHIFT_FROM_L_TO_S 2
DECL|macro|INTERNAL_SHIFT_FROM_S_TO_R
mdefine_line|#define INTERNAL_SHIFT_FROM_S_TO_R 3
DECL|macro|INTERNAL_INSERT_TO_S
mdefine_line|#define INTERNAL_INSERT_TO_S 4
DECL|macro|INTERNAL_INSERT_TO_L
mdefine_line|#define INTERNAL_INSERT_TO_L 5
DECL|macro|INTERNAL_INSERT_TO_R
mdefine_line|#define INTERNAL_INSERT_TO_R 6
DECL|function|internal_define_dest_src_infos
r_static
r_void
id|internal_define_dest_src_infos
(paren
r_int
id|shift_mode
comma
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_info
op_star
id|src_bi
comma
r_int
op_star
id|d_key
comma
r_struct
id|buffer_head
op_star
op_star
id|cf
)paren
(brace
id|memset
(paren
id|dest_bi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_info
)paren
)paren
suffix:semicolon
id|memset
(paren
id|src_bi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_info
)paren
)paren
suffix:semicolon
multiline_comment|/* define dest, src, dest parent, dest position */
r_switch
c_cond
(paren
id|shift_mode
)paren
(brace
r_case
id|INTERNAL_SHIFT_FROM_S_TO_L
suffix:colon
multiline_comment|/* used in internal_shift_left */
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;L
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FL
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
op_star
id|d_key
op_assign
id|tb-&gt;lkey
(braket
id|h
)braket
suffix:semicolon
op_star
id|cf
op_assign
id|tb-&gt;CFL
(braket
id|h
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_SHIFT_FROM_L_TO_S
suffix:colon
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|tb-&gt;L
(braket
id|h
)braket
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|tb-&gt;FL
(braket
id|h
)braket
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* dest position is analog of dest-&gt;b_item_order */
op_star
id|d_key
op_assign
id|tb-&gt;lkey
(braket
id|h
)braket
suffix:semicolon
op_star
id|cf
op_assign
id|tb-&gt;CFL
(braket
id|h
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_SHIFT_FROM_R_TO_S
suffix:colon
multiline_comment|/* used in internal_shift_left */
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|tb-&gt;R
(braket
id|h
)braket
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|tb-&gt;FR
(braket
id|h
)braket
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|d_key
op_assign
id|tb-&gt;rkey
(braket
id|h
)braket
suffix:semicolon
op_star
id|cf
op_assign
id|tb-&gt;CFR
(braket
id|h
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_SHIFT_FROM_S_TO_R
suffix:colon
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;R
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FR
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
op_star
id|d_key
op_assign
id|tb-&gt;rkey
(braket
id|h
)braket
suffix:semicolon
op_star
id|cf
op_assign
id|tb-&gt;CFR
(braket
id|h
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_INSERT_TO_L
suffix:colon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;L
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FL
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_INSERT_TO_S
suffix:colon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|INTERNAL_INSERT_TO_R
suffix:colon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;R
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FR
(braket
id|h
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;internal_define_dest_src_infos: shift type is unknown (%d)&quot;
comma
id|shift_mode
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert count node pointers into buffer cur before position to + 1.&n; * Insert count items into buffer cur before position to.&n; * Items and node pointers are specified by inserted and bh respectively.&n; */
DECL|function|internal_insert_childs
r_static
r_void
id|internal_insert_childs
(paren
r_struct
id|buffer_info
op_star
id|cur_bi
comma
r_int
id|to
comma
r_int
id|count
comma
r_struct
id|item_head
op_star
id|inserted
comma
r_struct
id|buffer_head
op_star
op_star
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|cur
op_assign
id|cur_bi-&gt;bi_bh
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_struct
id|key
op_star
id|ih
suffix:semicolon
r_struct
id|disk_child
id|new_dc
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
r_return
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|cur
)paren
suffix:semicolon
id|nr
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|count
OG
l_int|2
comma
l_string|&quot;too many children (%d) are to be inserted&quot;
comma
id|count
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|B_FREE_SPACE
(paren
id|cur
)paren
OL
id|count
op_star
(paren
id|KEY_SIZE
op_plus
id|DC_SIZE
)paren
comma
l_string|&quot;no enough free space (%d), needed %d bytes&quot;
comma
id|B_FREE_SPACE
(paren
id|cur
)paren
comma
id|count
op_star
(paren
id|KEY_SIZE
op_plus
id|DC_SIZE
)paren
)paren
suffix:semicolon
multiline_comment|/* prepare space for count disk_child */
id|dc
op_assign
id|B_N_CHILD
c_func
(paren
id|cur
comma
id|to
op_plus
l_int|1
)paren
suffix:semicolon
id|memmove
(paren
id|dc
op_plus
id|count
comma
id|dc
comma
(paren
id|nr
op_plus
l_int|1
op_minus
(paren
id|to
op_plus
l_int|1
)paren
)paren
op_star
id|DC_SIZE
)paren
suffix:semicolon
multiline_comment|/* copy to_be_insert disk children */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|put_dc_size
c_func
(paren
op_amp
(paren
id|new_dc
(braket
id|i
)braket
)paren
comma
id|MAX_CHILD_SIZE
c_func
(paren
id|bh
(braket
id|i
)braket
)paren
op_minus
id|B_FREE_SPACE
c_func
(paren
id|bh
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|put_dc_block_number
c_func
(paren
op_amp
(paren
id|new_dc
(braket
id|i
)braket
)paren
comma
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:semicolon
)brace
id|memcpy
(paren
id|dc
comma
id|new_dc
comma
id|DC_SIZE
op_star
id|count
)paren
suffix:semicolon
multiline_comment|/* prepare space for count items  */
id|ih
op_assign
id|B_N_PDELIM_KEY
(paren
id|cur
comma
(paren
(paren
id|to
op_eq
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
id|to
)paren
)paren
suffix:semicolon
id|memmove
(paren
id|ih
op_plus
id|count
comma
id|ih
comma
(paren
id|nr
op_minus
id|to
)paren
op_star
id|KEY_SIZE
op_plus
(paren
id|nr
op_plus
l_int|1
op_plus
id|count
)paren
op_star
id|DC_SIZE
)paren
suffix:semicolon
multiline_comment|/* copy item headers (keys) */
id|memcpy
(paren
id|ih
comma
id|inserted
comma
id|KEY_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|1
)paren
id|memcpy
(paren
id|ih
op_plus
l_int|1
comma
id|inserted
op_plus
l_int|1
comma
id|KEY_SIZE
)paren
suffix:semicolon
multiline_comment|/* sizes, item number */
id|set_blkh_nr_item
c_func
(paren
id|blkh
comma
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
op_plus
id|count
)paren
suffix:semicolon
id|set_blkh_free_space
c_func
(paren
id|blkh
comma
id|blkh_free_space
c_func
(paren
id|blkh
)paren
op_minus
id|count
op_star
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|cur_bi-&gt;tb
comma
id|cur
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|check_internal
(paren
id|cur
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
r_if
c_cond
(paren
id|cur_bi-&gt;bi_parent
)paren
(brace
r_struct
id|disk_child
op_star
id|t_dc
op_assign
id|B_N_CHILD
(paren
id|cur_bi-&gt;bi_parent
comma
id|cur_bi-&gt;bi_position
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|t_dc
comma
id|dc_size
c_func
(paren
id|t_dc
)paren
op_plus
(paren
id|count
op_star
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
)paren
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
c_func
(paren
id|cur_bi-&gt;tb
comma
id|cur_bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|check_internal
(paren
id|cur_bi-&gt;bi_parent
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
)brace
)brace
multiline_comment|/* Delete del_num items and node pointers from buffer cur starting from *&n; * the first_i&squot;th item and first_p&squot;th pointers respectively.&t;&t;*/
DECL|function|internal_delete_pointers_items
r_static
r_void
id|internal_delete_pointers_items
(paren
r_struct
id|buffer_info
op_star
id|cur_bi
comma
r_int
id|first_p
comma
r_int
id|first_i
comma
r_int
id|del_num
)paren
(brace
r_struct
id|buffer_head
op_star
id|cur
op_assign
id|cur_bi-&gt;bi_bh
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
id|RFALSE
c_func
(paren
id|cur
op_eq
l_int|NULL
comma
l_string|&quot;buffer is 0&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|del_num
OL
l_int|0
comma
l_string|&quot;negative number of items (%d) can not be deleted&quot;
comma
id|del_num
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|first_p
template_param
id|B_NR_ITEMS
(paren
id|cur
)paren
op_plus
l_int|1
op_logical_or
id|first_i
OL
l_int|0
comma
l_string|&quot;first pointer order (%d) &lt; 0 or &quot;
l_string|&quot;no so many pointers (%d), only (%d) or &quot;
l_string|&quot;first key order %d &lt; 0&quot;
comma
id|first_p
comma
id|first_p
op_plus
id|del_num
comma
id|B_NR_ITEMS
(paren
id|cur
)paren
op_plus
l_int|1
comma
id|first_i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_num
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|cur
)paren
suffix:semicolon
id|nr
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_p
op_eq
l_int|0
op_logical_and
id|del_num
op_eq
id|nr
op_plus
l_int|1
)paren
(brace
id|RFALSE
c_func
(paren
id|first_i
op_ne
l_int|0
comma
l_string|&quot;1st deleted key must have order 0, not %d&quot;
comma
id|first_i
)paren
suffix:semicolon
id|make_empty_node
(paren
id|cur_bi
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|first_i
op_plus
id|del_num
OG
id|B_NR_ITEMS
(paren
id|cur
)paren
comma
l_string|&quot;first_i = %d del_num = %d &quot;
l_string|&quot;no so many keys (%d) in the node (%b)(%z)&quot;
comma
id|first_i
comma
id|del_num
comma
id|first_i
op_plus
id|del_num
comma
id|cur
comma
id|cur
)paren
suffix:semicolon
multiline_comment|/* deleting */
id|dc
op_assign
id|B_N_CHILD
(paren
id|cur
comma
id|first_p
)paren
suffix:semicolon
id|memmove
(paren
id|dc
comma
id|dc
op_plus
id|del_num
comma
(paren
id|nr
op_plus
l_int|1
op_minus
id|first_p
op_minus
id|del_num
)paren
op_star
id|DC_SIZE
)paren
suffix:semicolon
id|key
op_assign
id|B_N_PDELIM_KEY
(paren
id|cur
comma
id|first_i
)paren
suffix:semicolon
id|memmove
(paren
id|key
comma
id|key
op_plus
id|del_num
comma
(paren
id|nr
op_minus
id|first_i
op_minus
id|del_num
)paren
op_star
id|KEY_SIZE
op_plus
(paren
id|nr
op_plus
l_int|1
op_minus
id|del_num
)paren
op_star
id|DC_SIZE
)paren
suffix:semicolon
multiline_comment|/* sizes, item number */
id|set_blkh_nr_item
c_func
(paren
id|blkh
comma
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
op_minus
id|del_num
)paren
suffix:semicolon
id|set_blkh_free_space
c_func
(paren
id|blkh
comma
id|blkh_free_space
c_func
(paren
id|blkh
)paren
op_plus
(paren
id|del_num
op_star
(paren
id|KEY_SIZE
op_plus
id|DC_SIZE
)paren
)paren
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|cur_bi-&gt;tb
comma
id|cur
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|check_internal
(paren
id|cur
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
r_if
c_cond
(paren
id|cur_bi-&gt;bi_parent
)paren
(brace
r_struct
id|disk_child
op_star
id|t_dc
suffix:semicolon
id|t_dc
op_assign
id|B_N_CHILD
(paren
id|cur_bi-&gt;bi_parent
comma
id|cur_bi-&gt;bi_position
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|t_dc
comma
id|dc_size
c_func
(paren
id|t_dc
)paren
op_minus
(paren
id|del_num
op_star
(paren
id|KEY_SIZE
op_plus
id|DC_SIZE
)paren
)paren
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|cur_bi-&gt;tb
comma
id|cur_bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|check_internal
(paren
id|cur_bi-&gt;bi_parent
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
)brace
)brace
multiline_comment|/* delete n node pointers and items starting from given position */
DECL|function|internal_delete_childs
r_static
r_void
id|internal_delete_childs
(paren
r_struct
id|buffer_info
op_star
id|cur_bi
comma
r_int
id|from
comma
r_int
id|n
)paren
(brace
r_int
id|i_from
suffix:semicolon
id|i_from
op_assign
(paren
id|from
op_eq
l_int|0
)paren
ques
c_cond
id|from
suffix:colon
id|from
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* delete n pointers starting from `from&squot; position in CUR;&n;     delete n keys starting from &squot;i_from&squot; position in CUR;&n;     */
id|internal_delete_pointers_items
(paren
id|cur_bi
comma
id|from
comma
id|i_from
comma
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/* copy cpy_num node pointers and cpy_num - 1 items from buffer src to buffer dest&n;* last_first == FIRST_TO_LAST means, that we copy first items from src to tail of dest&n; * last_first == LAST_TO_FIRST means, that we copy last items from src to head of dest &n; */
DECL|function|internal_copy_pointers_items
r_static
r_void
id|internal_copy_pointers_items
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_head
op_star
id|src
comma
r_int
id|last_first
comma
r_int
id|cpy_num
)paren
(brace
multiline_comment|/* ATTENTION! Number of node pointers in DEST is equal to number of items in DEST *&n;   * as delimiting key have already inserted to buffer dest.*/
r_struct
id|buffer_head
op_star
id|dest
op_assign
id|dest_bi-&gt;bi_bh
suffix:semicolon
r_int
id|nr_dest
comma
id|nr_src
suffix:semicolon
r_int
id|dest_order
comma
id|src_order
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
id|nr_src
op_assign
id|B_NR_ITEMS
(paren
id|src
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|dest
op_eq
l_int|NULL
op_logical_or
id|src
op_eq
l_int|NULL
comma
l_string|&quot;src (%p) or dest (%p) buffer is 0&quot;
comma
id|src
comma
id|dest
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|last_first
op_ne
id|FIRST_TO_LAST
op_logical_and
id|last_first
op_ne
id|LAST_TO_FIRST
comma
l_string|&quot;invalid last_first parameter (%d)&quot;
comma
id|last_first
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|nr_src
OL
id|cpy_num
op_minus
l_int|1
comma
l_string|&quot;no so many items (%d) in src (%d)&quot;
comma
id|cpy_num
comma
id|nr_src
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|cpy_num
OL
l_int|0
comma
l_string|&quot;cpy_num less than 0 (%d)&quot;
comma
id|cpy_num
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|cpy_num
op_minus
l_int|1
op_plus
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
OG
(paren
r_int
)paren
id|MAX_NR_KEY
c_func
(paren
id|dest
)paren
comma
l_string|&quot;cpy_num (%d) + item number in dest (%d) can not be &gt; MAX_NR_KEY(%d)&quot;
comma
id|cpy_num
comma
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
comma
id|MAX_NR_KEY
c_func
(paren
id|dest
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpy_num
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* coping */
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|dest
)paren
suffix:semicolon
id|nr_dest
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
multiline_comment|/*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest;*/
multiline_comment|/*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0;*/
(paren
id|last_first
op_eq
id|LAST_TO_FIRST
)paren
ques
c_cond
(paren
id|dest_order
op_assign
l_int|0
comma
id|src_order
op_assign
id|nr_src
op_minus
id|cpy_num
op_plus
l_int|1
)paren
suffix:colon
(paren
id|dest_order
op_assign
id|nr_dest
comma
id|src_order
op_assign
l_int|0
)paren
suffix:semicolon
multiline_comment|/* prepare space for cpy_num pointers */
id|dc
op_assign
id|B_N_CHILD
(paren
id|dest
comma
id|dest_order
)paren
suffix:semicolon
id|memmove
(paren
id|dc
op_plus
id|cpy_num
comma
id|dc
comma
(paren
id|nr_dest
op_minus
id|dest_order
)paren
op_star
id|DC_SIZE
)paren
suffix:semicolon
multiline_comment|/* insert pointers */
id|memcpy
(paren
id|dc
comma
id|B_N_CHILD
(paren
id|src
comma
id|src_order
)paren
comma
id|DC_SIZE
op_star
id|cpy_num
)paren
suffix:semicolon
multiline_comment|/* prepare space for cpy_num - 1 item headers */
id|key
op_assign
id|B_N_PDELIM_KEY
c_func
(paren
id|dest
comma
id|dest_order
)paren
suffix:semicolon
id|memmove
(paren
id|key
op_plus
id|cpy_num
op_minus
l_int|1
comma
id|key
comma
id|KEY_SIZE
op_star
(paren
id|nr_dest
op_minus
id|dest_order
)paren
op_plus
id|DC_SIZE
op_star
(paren
id|nr_dest
op_plus
id|cpy_num
)paren
)paren
suffix:semicolon
multiline_comment|/* insert headers */
id|memcpy
(paren
id|key
comma
id|B_N_PDELIM_KEY
(paren
id|src
comma
id|src_order
)paren
comma
id|KEY_SIZE
op_star
(paren
id|cpy_num
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* sizes, item number */
id|set_blkh_nr_item
c_func
(paren
id|blkh
comma
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
op_plus
(paren
id|cpy_num
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|set_blkh_free_space
c_func
(paren
id|blkh
comma
id|blkh_free_space
c_func
(paren
id|blkh
)paren
op_minus
(paren
id|KEY_SIZE
op_star
(paren
id|cpy_num
op_minus
l_int|1
)paren
op_plus
id|DC_SIZE
op_star
id|cpy_num
)paren
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|dest_bi-&gt;tb
comma
id|dest
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|check_internal
(paren
id|dest
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
r_if
c_cond
(paren
id|dest_bi-&gt;bi_parent
)paren
(brace
r_struct
id|disk_child
op_star
id|t_dc
suffix:semicolon
id|t_dc
op_assign
id|B_N_CHILD
c_func
(paren
id|dest_bi-&gt;bi_parent
comma
id|dest_bi-&gt;bi_position
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|t_dc
comma
id|dc_size
c_func
(paren
id|t_dc
)paren
op_plus
(paren
id|KEY_SIZE
op_star
(paren
id|cpy_num
op_minus
l_int|1
)paren
op_plus
id|DC_SIZE
op_star
id|cpy_num
)paren
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|dest_bi-&gt;tb
comma
id|dest_bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|check_internal
(paren
id|dest_bi-&gt;bi_parent
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
)brace
)brace
multiline_comment|/* Copy cpy_num node pointers and cpy_num - 1 items from buffer src to buffer dest.&n; * Delete cpy_num - del_par items and node pointers from buffer src.&n; * last_first == FIRST_TO_LAST means, that we copy/delete first items from src.&n; * last_first == LAST_TO_FIRST means, that we copy/delete last items from src.&n; */
DECL|function|internal_move_pointers_items
r_static
r_void
id|internal_move_pointers_items
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_info
op_star
id|src_bi
comma
r_int
id|last_first
comma
r_int
id|cpy_num
comma
r_int
id|del_par
)paren
(brace
r_int
id|first_pointer
suffix:semicolon
r_int
id|first_item
suffix:semicolon
id|internal_copy_pointers_items
(paren
id|dest_bi
comma
id|src_bi-&gt;bi_bh
comma
id|last_first
comma
id|cpy_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
(brace
multiline_comment|/* shift_left occurs */
id|first_pointer
op_assign
l_int|0
suffix:semicolon
id|first_item
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* delete cpy_num - del_par pointers and keys starting for pointers with first_pointer, &n;&t;   for key - with first_item */
id|internal_delete_pointers_items
(paren
id|src_bi
comma
id|first_pointer
comma
id|first_item
comma
id|cpy_num
op_minus
id|del_par
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* shift_right occurs */
r_int
id|i
comma
id|j
suffix:semicolon
id|i
op_assign
(paren
id|cpy_num
op_minus
id|del_par
op_eq
(paren
id|j
op_assign
id|B_NR_ITEMS
c_func
(paren
id|src_bi-&gt;bi_bh
)paren
)paren
op_plus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
id|j
op_minus
id|cpy_num
op_plus
id|del_par
suffix:semicolon
id|internal_delete_pointers_items
(paren
id|src_bi
comma
id|j
op_plus
l_int|1
op_minus
id|cpy_num
op_plus
id|del_par
comma
id|i
comma
id|cpy_num
op_minus
id|del_par
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert n_src&squot;th key of buffer src before n_dest&squot;th key of buffer dest. */
DECL|function|internal_insert_key
r_static
r_void
id|internal_insert_key
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_int
id|dest_position_before
comma
multiline_comment|/* insert key before key with n_dest number */
r_struct
id|buffer_head
op_star
id|src
comma
r_int
id|src_position
)paren
(brace
r_struct
id|buffer_head
op_star
id|dest
op_assign
id|dest_bi-&gt;bi_bh
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|key
op_star
id|key
suffix:semicolon
id|RFALSE
c_func
(paren
id|dest
op_eq
l_int|NULL
op_logical_or
id|src
op_eq
l_int|NULL
comma
l_string|&quot;source(%p) or dest(%p) buffer is 0&quot;
comma
id|src
comma
id|dest
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|dest_position_before
OL
l_int|0
op_logical_or
id|src_position
OL
l_int|0
comma
l_string|&quot;source(%d) or dest(%d) key number less than 0&quot;
comma
id|src_position
comma
id|dest_position_before
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|dest_position_before
OG
id|B_NR_ITEMS
(paren
id|dest
)paren
op_logical_or
id|src_position
op_ge
id|B_NR_ITEMS
c_func
(paren
id|src
)paren
comma
l_string|&quot;invalid position in dest (%d (key number %d)) or in src (%d (key number %d))&quot;
comma
id|dest_position_before
comma
id|B_NR_ITEMS
(paren
id|dest
)paren
comma
id|src_position
comma
id|B_NR_ITEMS
c_func
(paren
id|src
)paren
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|B_FREE_SPACE
(paren
id|dest
)paren
OL
id|KEY_SIZE
comma
l_string|&quot;no enough free space (%d) in dest buffer&quot;
comma
id|B_FREE_SPACE
(paren
id|dest
)paren
)paren
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|dest
)paren
suffix:semicolon
id|nr
op_assign
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
suffix:semicolon
multiline_comment|/* prepare space for inserting key */
id|key
op_assign
id|B_N_PDELIM_KEY
(paren
id|dest
comma
id|dest_position_before
)paren
suffix:semicolon
id|memmove
(paren
id|key
op_plus
l_int|1
comma
id|key
comma
(paren
id|nr
op_minus
id|dest_position_before
)paren
op_star
id|KEY_SIZE
op_plus
(paren
id|nr
op_plus
l_int|1
)paren
op_star
id|DC_SIZE
)paren
suffix:semicolon
multiline_comment|/* insert key */
id|memcpy
(paren
id|key
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|src
comma
id|src_position
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
multiline_comment|/* Change dirt, free space, item number fields. */
id|set_blkh_nr_item
c_func
(paren
id|blkh
comma
id|blkh_nr_item
c_func
(paren
id|blkh
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|set_blkh_free_space
c_func
(paren
id|blkh
comma
id|blkh_free_space
c_func
(paren
id|blkh
)paren
op_minus
id|KEY_SIZE
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|dest_bi-&gt;tb
comma
id|dest
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest_bi-&gt;bi_parent
)paren
(brace
r_struct
id|disk_child
op_star
id|t_dc
suffix:semicolon
id|t_dc
op_assign
id|B_N_CHILD
c_func
(paren
id|dest_bi-&gt;bi_parent
comma
id|dest_bi-&gt;bi_position
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|t_dc
comma
id|dc_size
c_func
(paren
id|t_dc
)paren
op_plus
id|KEY_SIZE
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|dest_bi-&gt;tb
comma
id|dest_bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert d_key&squot;th (delimiting) key from buffer cfl to tail of dest. &n; * Copy pointer_amount node pointers and pointer_amount - 1 items from buffer src to buffer dest.&n; * Replace  d_key&squot;th key in buffer cfl.&n; * Delete pointer_amount items and node pointers from buffer src.&n; */
multiline_comment|/* this can be invoked both to shift from S to L and from R to S */
DECL|function|internal_shift_left
r_static
r_void
id|internal_shift_left
(paren
r_int
id|mode
comma
multiline_comment|/* INTERNAL_FROM_S_TO_L | INTERNAL_FROM_R_TO_S */
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|pointer_amount
)paren
(brace
r_struct
id|buffer_info
id|dest_bi
comma
id|src_bi
suffix:semicolon
r_struct
id|buffer_head
op_star
id|cf
suffix:semicolon
r_int
id|d_key_position
suffix:semicolon
id|internal_define_dest_src_infos
(paren
id|mode
comma
id|tb
comma
id|h
comma
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
op_amp
id|d_key_position
comma
op_amp
id|cf
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;pointer_amount = %d&bslash;n&quot;,pointer_amount);*/
r_if
c_cond
(paren
id|pointer_amount
)paren
(brace
multiline_comment|/* insert delimiting key from common father of dest and src to node dest into position B_NR_ITEM(dest) */
id|internal_insert_key
(paren
op_amp
id|dest_bi
comma
id|B_NR_ITEMS
c_func
(paren
id|dest_bi.bi_bh
)paren
comma
id|cf
comma
id|d_key_position
)paren
suffix:semicolon
r_if
c_cond
(paren
id|B_NR_ITEMS
c_func
(paren
id|src_bi.bi_bh
)paren
op_eq
id|pointer_amount
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|src_bi.bi_position
multiline_comment|/*src-&gt;b_item_order*/
op_eq
l_int|0
)paren
id|replace_key
(paren
id|tb
comma
id|cf
comma
id|d_key_position
comma
id|src_bi.bi_parent
multiline_comment|/*src-&gt;b_parent*/
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|replace_key
(paren
id|tb
comma
id|cf
comma
id|d_key_position
comma
id|src_bi.bi_bh
comma
id|pointer_amount
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* last parameter is del_parameter */
id|internal_move_pointers_items
(paren
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
id|FIRST_TO_LAST
comma
id|pointer_amount
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert delimiting key to L[h].&n; * Copy n node pointers and n - 1 items from buffer S[h] to L[h].&n; * Delete n - 1 items and node pointers from buffer S[h].&n; */
multiline_comment|/* it always shifts from S[h] to L[h] */
DECL|function|internal_shift1_left
r_static
r_void
id|internal_shift1_left
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|pointer_amount
)paren
(brace
r_struct
id|buffer_info
id|dest_bi
comma
id|src_bi
suffix:semicolon
r_struct
id|buffer_head
op_star
id|cf
suffix:semicolon
r_int
id|d_key_position
suffix:semicolon
id|internal_define_dest_src_infos
(paren
id|INTERNAL_SHIFT_FROM_S_TO_L
comma
id|tb
comma
id|h
comma
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
op_amp
id|d_key_position
comma
op_amp
id|cf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pointer_amount
OG
l_int|0
)paren
multiline_comment|/* insert lkey[h]-th key  from CFL[h] to left neighbor L[h] */
id|internal_insert_key
(paren
op_amp
id|dest_bi
comma
id|B_NR_ITEMS
c_func
(paren
id|dest_bi.bi_bh
)paren
comma
id|cf
comma
id|d_key_position
)paren
suffix:semicolon
multiline_comment|/*&t;&t;internal_insert_key (tb-&gt;L[h], B_NR_ITEM(tb-&gt;L[h]), tb-&gt;CFL[h], tb-&gt;lkey[h]);*/
multiline_comment|/* last parameter is del_parameter */
id|internal_move_pointers_items
(paren
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
id|FIRST_TO_LAST
comma
id|pointer_amount
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&t;internal_move_pointers_items (tb-&gt;L[h], tb-&gt;S[h], FIRST_TO_LAST, pointer_amount, 1);*/
)brace
multiline_comment|/* Insert d_key&squot;th (delimiting) key from buffer cfr to head of dest. &n; * Copy n node pointers and n - 1 items from buffer src to buffer dest.&n; * Replace  d_key&squot;th key in buffer cfr.&n; * Delete n items and node pointers from buffer src.&n; */
DECL|function|internal_shift_right
r_static
r_void
id|internal_shift_right
(paren
r_int
id|mode
comma
multiline_comment|/* INTERNAL_FROM_S_TO_R | INTERNAL_FROM_L_TO_S */
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|pointer_amount
)paren
(brace
r_struct
id|buffer_info
id|dest_bi
comma
id|src_bi
suffix:semicolon
r_struct
id|buffer_head
op_star
id|cf
suffix:semicolon
r_int
id|d_key_position
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|internal_define_dest_src_infos
(paren
id|mode
comma
id|tb
comma
id|h
comma
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
op_amp
id|d_key_position
comma
op_amp
id|cf
)paren
suffix:semicolon
id|nr
op_assign
id|B_NR_ITEMS
(paren
id|src_bi.bi_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pointer_amount
OG
l_int|0
)paren
(brace
multiline_comment|/* insert delimiting key from common father of dest and src to dest node into position 0 */
id|internal_insert_key
(paren
op_amp
id|dest_bi
comma
l_int|0
comma
id|cf
comma
id|d_key_position
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
id|pointer_amount
op_minus
l_int|1
)paren
(brace
id|RFALSE
c_func
(paren
id|src_bi.bi_bh
op_ne
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
multiline_comment|/*tb-&gt;S[h]*/
op_logical_or
id|dest_bi.bi_bh
op_ne
id|tb-&gt;R
(braket
id|h
)braket
comma
l_string|&quot;src (%p) must be == tb-&gt;S[h](%p) when it disappears&quot;
comma
id|src_bi.bi_bh
comma
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
suffix:semicolon
multiline_comment|/* when S[h] disappers replace left delemiting key as well */
r_if
c_cond
(paren
id|tb-&gt;CFL
(braket
id|h
)braket
)paren
id|replace_key
(paren
id|tb
comma
id|cf
comma
id|d_key_position
comma
id|tb-&gt;CFL
(braket
id|h
)braket
comma
id|tb-&gt;lkey
(braket
id|h
)braket
)paren
suffix:semicolon
)brace
r_else
id|replace_key
(paren
id|tb
comma
id|cf
comma
id|d_key_position
comma
id|src_bi.bi_bh
comma
id|nr
op_minus
id|pointer_amount
)paren
suffix:semicolon
)brace
multiline_comment|/* last parameter is del_parameter */
id|internal_move_pointers_items
(paren
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
id|LAST_TO_FIRST
comma
id|pointer_amount
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert delimiting key to R[h].&n; * Copy n node pointers and n - 1 items from buffer S[h] to R[h].&n; * Delete n - 1 items and node pointers from buffer S[h].&n; */
multiline_comment|/* it always shift from S[h] to R[h] */
DECL|function|internal_shift1_right
r_static
r_void
id|internal_shift1_right
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|pointer_amount
)paren
(brace
r_struct
id|buffer_info
id|dest_bi
comma
id|src_bi
suffix:semicolon
r_struct
id|buffer_head
op_star
id|cf
suffix:semicolon
r_int
id|d_key_position
suffix:semicolon
id|internal_define_dest_src_infos
(paren
id|INTERNAL_SHIFT_FROM_S_TO_R
comma
id|tb
comma
id|h
comma
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
op_amp
id|d_key_position
comma
op_amp
id|cf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pointer_amount
OG
l_int|0
)paren
multiline_comment|/* insert rkey from CFR[h] to right neighbor R[h] */
id|internal_insert_key
(paren
op_amp
id|dest_bi
comma
l_int|0
comma
id|cf
comma
id|d_key_position
)paren
suffix:semicolon
multiline_comment|/*&t;&t;internal_insert_key (tb-&gt;R[h], 0, tb-&gt;CFR[h], tb-&gt;rkey[h]);*/
multiline_comment|/* last parameter is del_parameter */
id|internal_move_pointers_items
(paren
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
id|LAST_TO_FIRST
comma
id|pointer_amount
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&t;internal_move_pointers_items (tb-&gt;R[h], tb-&gt;S[h], LAST_TO_FIRST, pointer_amount, 1);*/
)brace
multiline_comment|/* Delete insert_num node pointers together with their left items&n; * and balance current node.*/
DECL|function|balance_internal_when_delete
r_static
r_void
id|balance_internal_when_delete
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_int
id|child_pos
)paren
(brace
r_int
id|insert_num
suffix:semicolon
r_int
id|n
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tbSh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
r_struct
id|buffer_info
id|bi
suffix:semicolon
id|insert_num
op_assign
id|tb-&gt;insert_size
(braket
id|h
)braket
op_div
(paren
(paren
r_int
)paren
(paren
id|DC_SIZE
op_plus
id|KEY_SIZE
)paren
)paren
suffix:semicolon
multiline_comment|/* delete child-node-pointer(s) together with their left item(s) */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tbSh
suffix:semicolon
id|bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|internal_delete_childs
(paren
op_amp
id|bi
comma
id|child_pos
comma
op_minus
id|insert_num
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|tb-&gt;blknum
(braket
id|h
)braket
OG
l_int|1
comma
l_string|&quot;tb-&gt;blknum[%d]=%d when insert_size &lt; 0&quot;
comma
id|h
comma
id|tb-&gt;blknum
(braket
id|h
)braket
)paren
suffix:semicolon
id|n
op_assign
id|B_NR_ITEMS
c_func
(paren
id|tbSh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_eq
l_int|0
op_logical_and
id|tb-&gt;rnum
(braket
id|h
)braket
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tb-&gt;blknum
(braket
id|h
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* node S[h] (root of the tree) is empty now */
r_struct
id|buffer_head
op_star
id|new_root
suffix:semicolon
id|RFALSE
c_func
(paren
id|n
op_logical_or
id|B_FREE_SPACE
(paren
id|tbSh
)paren
op_ne
id|MAX_CHILD_SIZE
c_func
(paren
id|tbSh
)paren
op_minus
id|DC_SIZE
comma
l_string|&quot;buffer must have only 0 keys (%d)&quot;
comma
id|n
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|bi.bi_parent
comma
l_string|&quot;root has parent (%p)&quot;
comma
id|bi.bi_parent
)paren
suffix:semicolon
multiline_comment|/* choose a new root */
r_if
c_cond
(paren
op_logical_neg
id|tb-&gt;L
(braket
id|h
op_minus
l_int|1
)braket
op_logical_or
op_logical_neg
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;L
(braket
id|h
op_minus
l_int|1
)braket
)paren
)paren
id|new_root
op_assign
id|tb-&gt;R
(braket
id|h
op_minus
l_int|1
)braket
suffix:semicolon
r_else
id|new_root
op_assign
id|tb-&gt;L
(braket
id|h
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* switch super block&squot;s tree root block number to the new value */
id|PUT_SB_ROOT_BLOCK
c_func
(paren
id|tb-&gt;tb_sb
comma
id|new_root-&gt;b_blocknr
)paren
suffix:semicolon
singleline_comment|//REISERFS_SB(tb-&gt;tb_sb)-&gt;s_rs-&gt;s_tree_height --;
id|PUT_SB_TREE_HEIGHT
c_func
(paren
id|tb-&gt;tb_sb
comma
id|SB_TREE_HEIGHT
c_func
(paren
id|tb-&gt;tb_sb
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|do_balance_mark_sb_dirty
(paren
id|tb
comma
id|REISERFS_SB
c_func
(paren
id|tb-&gt;tb_sb
)paren
op_member_access_from_pointer
id|s_sbh
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
r_if
c_cond
(paren
id|h
OG
l_int|1
)paren
multiline_comment|/* use check_internal if new root is an internal node */
id|check_internal
(paren
id|new_root
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|tb-&gt;tb_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* do what is needed for buffer thrown from tree */
id|reiserfs_invalidate_buffer
c_func
(paren
id|tb
comma
id|tbSh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;L
(braket
id|h
)braket
op_logical_and
id|tb-&gt;lnum
(braket
id|h
)braket
op_eq
op_minus
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;L
(braket
id|h
)braket
)paren
op_minus
l_int|1
)paren
(brace
multiline_comment|/* join S[h] with L[h] */
id|RFALSE
c_func
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_ne
l_int|0
comma
l_string|&quot;invalid tb-&gt;rnum[%d]==%d when joining S[h] with L[h]&quot;
comma
id|h
comma
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
id|internal_shift_left
(paren
id|INTERNAL_SHIFT_FROM_S_TO_L
comma
id|tb
comma
id|h
comma
id|n
op_plus
l_int|1
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
c_func
(paren
id|tb
comma
id|tbSh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;R
(braket
id|h
)braket
op_logical_and
id|tb-&gt;rnum
(braket
id|h
)braket
op_eq
op_minus
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;R
(braket
id|h
)braket
)paren
op_minus
l_int|1
)paren
(brace
multiline_comment|/* join S[h] with R[h] */
id|RFALSE
c_func
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_ne
l_int|0
comma
l_string|&quot;invalid tb-&gt;lnum[%d]==%d when joining S[h] with R[h]&quot;
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
)paren
suffix:semicolon
id|internal_shift_right
(paren
id|INTERNAL_SHIFT_FROM_S_TO_R
comma
id|tb
comma
id|h
comma
id|n
op_plus
l_int|1
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
c_func
(paren
id|tb
comma
id|tbSh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
OL
l_int|0
)paren
(brace
multiline_comment|/* borrow from left neighbor L[h] */
id|RFALSE
c_func
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_ne
l_int|0
comma
l_string|&quot;wrong tb-&gt;rnum[%d]==%d when borrow from L[h]&quot;
comma
id|h
comma
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
multiline_comment|/*internal_shift_right (tb, h, tb-&gt;L[h], tb-&gt;CFL[h], tb-&gt;lkey[h], tb-&gt;S[h], -tb-&gt;lnum[h]);*/
id|internal_shift_right
(paren
id|INTERNAL_SHIFT_FROM_L_TO_S
comma
id|tb
comma
id|h
comma
op_minus
id|tb-&gt;lnum
(braket
id|h
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
OL
l_int|0
)paren
(brace
multiline_comment|/* borrow from right neighbor R[h] */
id|RFALSE
c_func
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_ne
l_int|0
comma
l_string|&quot;invalid tb-&gt;lnum[%d]==%d when borrow from R[h]&quot;
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
)paren
suffix:semicolon
id|internal_shift_left
(paren
id|INTERNAL_SHIFT_FROM_R_TO_S
comma
id|tb
comma
id|h
comma
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
multiline_comment|/*tb-&gt;S[h], tb-&gt;CFR[h], tb-&gt;rkey[h], tb-&gt;R[h], -tb-&gt;rnum[h]);*/
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
OG
l_int|0
)paren
(brace
multiline_comment|/* split S[h] into two parts and put them into neighbors */
id|RFALSE
c_func
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
op_eq
l_int|0
op_logical_or
id|tb-&gt;lnum
(braket
id|h
)braket
op_plus
id|tb-&gt;rnum
(braket
id|h
)braket
op_ne
id|n
op_plus
l_int|1
comma
l_string|&quot;invalid tb-&gt;lnum[%d]==%d or tb-&gt;rnum[%d]==%d when S[h](item number == %d) is split between them&quot;
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
comma
id|h
comma
id|tb-&gt;rnum
(braket
id|h
)braket
comma
id|n
)paren
suffix:semicolon
id|internal_shift_left
(paren
id|INTERNAL_SHIFT_FROM_S_TO_L
comma
id|tb
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
)paren
suffix:semicolon
multiline_comment|/*tb-&gt;L[h], tb-&gt;CFL[h], tb-&gt;lkey[h], tb-&gt;S[h], tb-&gt;lnum[h]);*/
id|internal_shift_right
(paren
id|INTERNAL_SHIFT_FROM_S_TO_R
comma
id|tb
comma
id|h
comma
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
id|reiserfs_invalidate_buffer
(paren
id|tb
comma
id|tbSh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;balance_internal_when_delete: unexpected tb-&gt;lnum[%d]==%d or tb-&gt;rnum[%d]==%d&quot;
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
comma
id|h
comma
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Replace delimiting key of buffers L[h] and S[h] by the given key.*/
DECL|function|replace_lkey
r_void
id|replace_lkey
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_struct
id|item_head
op_star
id|key
)paren
(brace
id|RFALSE
c_func
(paren
id|tb-&gt;L
(braket
id|h
)braket
op_eq
l_int|NULL
op_logical_or
id|tb-&gt;CFL
(braket
id|h
)braket
op_eq
l_int|NULL
comma
l_string|&quot;L[h](%p) and CFL[h](%p) must exist in replace_lkey&quot;
comma
id|tb-&gt;L
(braket
id|h
)braket
comma
id|tb-&gt;CFL
(braket
id|h
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|B_NR_ITEMS
c_func
(paren
id|PATH_H_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|memcpy
(paren
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFL
(braket
id|h
)braket
comma
id|tb-&gt;lkey
(braket
id|h
)braket
)paren
comma
id|key
comma
id|KEY_SIZE
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
id|h
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Replace delimiting key of buffers S[h] and R[h] by the given key.*/
DECL|function|replace_rkey
r_void
id|replace_rkey
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|h
comma
r_struct
id|item_head
op_star
id|key
)paren
(brace
id|RFALSE
c_func
(paren
id|tb-&gt;R
(braket
id|h
)braket
op_eq
l_int|NULL
op_logical_or
id|tb-&gt;CFR
(braket
id|h
)braket
op_eq
l_int|NULL
comma
l_string|&quot;R[h](%p) and CFR[h](%p) must exist in replace_rkey&quot;
comma
id|tb-&gt;R
(braket
id|h
)braket
comma
id|tb-&gt;CFR
(braket
id|h
)braket
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;R
(braket
id|h
)braket
)paren
op_eq
l_int|0
comma
l_string|&quot;R[h] can not be empty if it exists (item number=%d)&quot;
comma
id|B_NR_ITEMS
c_func
(paren
id|tb-&gt;R
(braket
id|h
)braket
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|B_N_PDELIM_KEY
c_func
(paren
id|tb-&gt;CFR
(braket
id|h
)braket
comma
id|tb-&gt;rkey
(braket
id|h
)braket
)paren
comma
id|key
comma
id|KEY_SIZE
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
id|h
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|balance_internal
r_int
id|balance_internal
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
multiline_comment|/* tree_balance structure &t;&t;*/
r_int
id|h
comma
multiline_comment|/* level of the tree &t;&t;&t;*/
r_int
id|child_pos
comma
r_struct
id|item_head
op_star
id|insert_key
comma
multiline_comment|/* key for insertion on higher level   &t;*/
r_struct
id|buffer_head
op_star
op_star
id|insert_ptr
multiline_comment|/* node for insertion on higher level*/
)paren
multiline_comment|/* if inserting/pasting&n;       {&n;       child_pos is the position of the node-pointer in S[h] that&t; *&n;       pointed to S[h-1] before balancing of the h-1 level;&t;&t; *&n;       this means that new pointers and items must be inserted AFTER *&n;       child_pos&n;       }&n;       else &n;       {&n;   it is the position of the leftmost pointer that must be deleted (together with&n;   its corresponding key to the left of the pointer)&n;   as a result of the previous level&squot;s balancing.&n;   }&n;*/
(brace
r_struct
id|buffer_head
op_star
id|tbSh
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
r_struct
id|buffer_info
id|bi
suffix:semicolon
r_int
id|order
suffix:semicolon
multiline_comment|/* we return this: it is 0 if there is no S[h], else it is tb-&gt;S[h]-&gt;b_item_order */
r_int
id|insert_num
comma
id|n
comma
id|k
suffix:semicolon
r_struct
id|buffer_head
op_star
id|S_new
suffix:semicolon
r_struct
id|item_head
id|new_insert_key
suffix:semicolon
r_struct
id|buffer_head
op_star
id|new_insert_ptr
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|item_head
op_star
id|new_insert_key_addr
op_assign
id|insert_key
suffix:semicolon
id|RFALSE
c_func
(paren
id|h
OL
l_int|1
comma
l_string|&quot;h (%d) can not be &lt; 1 on internal level&quot;
comma
id|h
)paren
suffix:semicolon
id|PROC_INFO_INC
c_func
(paren
id|tb
op_member_access_from_pointer
id|tb_sb
comma
id|balance_at
(braket
id|h
)braket
)paren
suffix:semicolon
id|order
op_assign
(paren
id|tbSh
)paren
ques
c_cond
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
multiline_comment|/*tb-&gt;S[h]-&gt;b_item_order*/
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Using insert_size[h] calculate the number insert_num of items&n;     that must be inserted to or deleted from S[h]. */
id|insert_num
op_assign
id|tb-&gt;insert_size
(braket
id|h
)braket
op_div
(paren
(paren
r_int
)paren
(paren
id|KEY_SIZE
op_plus
id|DC_SIZE
)paren
)paren
suffix:semicolon
multiline_comment|/* Check whether insert_num is proper **/
id|RFALSE
c_func
(paren
id|insert_num
template_param
l_int|2
comma
l_string|&quot;incorrect number of items inserted to the internal node (%d)&quot;
comma
id|insert_num
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|h
OG
l_int|1
op_logical_and
(paren
id|insert_num
OG
l_int|1
op_logical_or
id|insert_num
OL
op_minus
l_int|1
)paren
comma
l_string|&quot;incorrect number of items (%d) inserted to the internal node on a level (h=%d) higher than last internal level&quot;
comma
id|insert_num
comma
id|h
)paren
suffix:semicolon
multiline_comment|/* Make balance in case insert_num &lt; 0 */
r_if
c_cond
(paren
id|insert_num
OL
l_int|0
)paren
(brace
id|balance_internal_when_delete
(paren
id|tb
comma
id|h
comma
id|child_pos
)paren
suffix:semicolon
r_return
id|order
suffix:semicolon
)brace
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
OG
l_int|0
)paren
(brace
multiline_comment|/* shift lnum[h] items from S[h] to the left neighbor L[h].&n;&t;   check how many of new items fall into L[h] or CFL[h] after&n;&t;   shifting */
id|n
op_assign
id|B_NR_ITEMS
(paren
id|tb-&gt;L
(braket
id|h
)braket
)paren
suffix:semicolon
multiline_comment|/* number of items in L[h] */
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
op_le
id|child_pos
)paren
(brace
multiline_comment|/* new items don&squot;t fall into L[h] or CFL[h] */
id|internal_shift_left
(paren
id|INTERNAL_SHIFT_FROM_S_TO_L
comma
id|tb
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
)paren
suffix:semicolon
multiline_comment|/*internal_shift_left (tb-&gt;L[h],tb-&gt;CFL[h],tb-&gt;lkey[h],tbSh,tb-&gt;lnum[h]);*/
id|child_pos
op_sub_assign
id|tb-&gt;lnum
(braket
id|h
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tb-&gt;lnum
(braket
id|h
)braket
OG
id|child_pos
op_plus
id|insert_num
)paren
(brace
multiline_comment|/* all new items fall into L[h] */
id|internal_shift_left
(paren
id|INTERNAL_SHIFT_FROM_S_TO_L
comma
id|tb
comma
id|h
comma
id|tb-&gt;lnum
(braket
id|h
)braket
op_minus
id|insert_num
)paren
suffix:semicolon
multiline_comment|/*&t;&t;&t;internal_shift_left(tb-&gt;L[h],tb-&gt;CFL[h],tb-&gt;lkey[h],tbSh,&n;&t;&t;&t;&t;tb-&gt;lnum[h]-insert_num);&n;&t;    */
multiline_comment|/* insert insert_num keys and node-pointers into L[h] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;L
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FL
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|internal_insert_childs
(paren
op_amp
id|bi
comma
multiline_comment|/*tb-&gt;L[h], tb-&gt;S[h-1]-&gt;b_next*/
id|n
op_plus
id|child_pos
op_plus
l_int|1
comma
id|insert_num
comma
id|insert_key
comma
id|insert_ptr
)paren
suffix:semicolon
id|insert_num
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
multiline_comment|/* some items fall into L[h] or CFL[h], but some don&squot;t fall */
id|internal_shift1_left
c_func
(paren
id|tb
comma
id|h
comma
id|child_pos
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* calculate number of new items that fall into L[h] */
id|k
op_assign
id|tb-&gt;lnum
(braket
id|h
)braket
op_minus
id|child_pos
op_minus
l_int|1
suffix:semicolon
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;L
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FL
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|internal_insert_childs
(paren
op_amp
id|bi
comma
multiline_comment|/*tb-&gt;L[h], tb-&gt;S[h-1]-&gt;b_next,*/
id|n
op_plus
id|child_pos
op_plus
l_int|1
comma
id|k
comma
id|insert_key
comma
id|insert_ptr
)paren
suffix:semicolon
id|replace_lkey
c_func
(paren
id|tb
comma
id|h
comma
id|insert_key
op_plus
id|k
)paren
suffix:semicolon
multiline_comment|/* replace the first node-ptr in S[h] by node-ptr to insert_ptr[k] */
id|dc
op_assign
id|B_N_CHILD
c_func
(paren
id|tbSh
comma
l_int|0
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|dc
comma
id|MAX_CHILD_SIZE
c_func
(paren
id|insert_ptr
(braket
id|k
)braket
)paren
op_minus
id|B_FREE_SPACE
(paren
id|insert_ptr
(braket
id|k
)braket
)paren
)paren
suffix:semicolon
id|put_dc_block_number
c_func
(paren
id|dc
comma
id|insert_ptr
(braket
id|k
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|tbSh
comma
l_int|0
)paren
suffix:semicolon
id|k
op_increment
suffix:semicolon
id|insert_key
op_add_assign
id|k
suffix:semicolon
id|insert_ptr
op_add_assign
id|k
suffix:semicolon
id|insert_num
op_sub_assign
id|k
suffix:semicolon
id|child_pos
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* tb-&gt;lnum[h] &gt; 0 */
r_if
c_cond
(paren
id|tb-&gt;rnum
(braket
id|h
)braket
OG
l_int|0
)paren
(brace
multiline_comment|/*shift rnum[h] items from S[h] to the right neighbor R[h]*/
multiline_comment|/* check how many of new items fall into R or CFR after shifting */
id|n
op_assign
id|B_NR_ITEMS
(paren
id|tbSh
)paren
suffix:semicolon
multiline_comment|/* number of items in S[h] */
r_if
c_cond
(paren
id|n
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
op_ge
id|child_pos
)paren
multiline_comment|/* new items fall into S[h] */
multiline_comment|/*internal_shift_right(tb,h,tbSh,tb-&gt;CFR[h],tb-&gt;rkey[h],tb-&gt;R[h],tb-&gt;rnum[h]);*/
id|internal_shift_right
(paren
id|INTERNAL_SHIFT_FROM_S_TO_R
comma
id|tb
comma
id|h
comma
id|tb-&gt;rnum
(braket
id|h
)braket
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|n
op_plus
id|insert_num
op_minus
id|tb-&gt;rnum
(braket
id|h
)braket
OL
id|child_pos
)paren
(brace
multiline_comment|/* all new items fall into R[h] */
multiline_comment|/*internal_shift_right(tb,h,tbSh,tb-&gt;CFR[h],tb-&gt;rkey[h],tb-&gt;R[h],&n;&t;    tb-&gt;rnum[h] - insert_num);*/
id|internal_shift_right
(paren
id|INTERNAL_SHIFT_FROM_S_TO_R
comma
id|tb
comma
id|h
comma
id|tb-&gt;rnum
(braket
id|h
)braket
op_minus
id|insert_num
)paren
suffix:semicolon
multiline_comment|/* insert insert_num keys and node-pointers into R[h] */
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;R
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FR
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|internal_insert_childs
(paren
op_amp
id|bi
comma
multiline_comment|/*tb-&gt;R[h],tb-&gt;S[h-1]-&gt;b_next*/
id|child_pos
op_minus
id|n
op_minus
id|insert_num
op_plus
id|tb-&gt;rnum
(braket
id|h
)braket
op_minus
l_int|1
comma
id|insert_num
comma
id|insert_key
comma
id|insert_ptr
)paren
suffix:semicolon
id|insert_num
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
multiline_comment|/* one of the items falls into CFR[h] */
id|internal_shift1_right
c_func
(paren
id|tb
comma
id|h
comma
id|n
op_minus
id|child_pos
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* calculate number of new items that fall into R[h] */
id|k
op_assign
id|tb-&gt;rnum
(braket
id|h
)braket
op_minus
id|n
op_plus
id|child_pos
op_minus
l_int|1
suffix:semicolon
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tb-&gt;R
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_parent
op_assign
id|tb-&gt;FR
(braket
id|h
)braket
suffix:semicolon
id|bi.bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
id|h
)paren
suffix:semicolon
id|internal_insert_childs
(paren
op_amp
id|bi
comma
multiline_comment|/*tb-&gt;R[h], tb-&gt;R[h]-&gt;b_child,*/
l_int|0
comma
id|k
comma
id|insert_key
op_plus
l_int|1
comma
id|insert_ptr
op_plus
l_int|1
)paren
suffix:semicolon
id|replace_rkey
c_func
(paren
id|tb
comma
id|h
comma
id|insert_key
op_plus
id|insert_num
op_minus
id|k
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* replace the first node-ptr in R[h] by node-ptr insert_ptr[insert_num-k-1]*/
id|dc
op_assign
id|B_N_CHILD
c_func
(paren
id|tb-&gt;R
(braket
id|h
)braket
comma
l_int|0
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|dc
comma
id|MAX_CHILD_SIZE
c_func
(paren
id|insert_ptr
(braket
id|insert_num
op_minus
id|k
op_minus
l_int|1
)braket
)paren
op_minus
id|B_FREE_SPACE
(paren
id|insert_ptr
(braket
id|insert_num
op_minus
id|k
op_minus
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|put_dc_block_number
c_func
(paren
id|dc
comma
id|insert_ptr
(braket
id|insert_num
op_minus
id|k
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|tb-&gt;R
(braket
id|h
)braket
comma
l_int|0
)paren
suffix:semicolon
id|insert_num
op_sub_assign
(paren
id|k
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/** Fill new node that appears instead of S[h] **/
id|RFALSE
c_func
(paren
id|tb-&gt;blknum
(braket
id|h
)braket
OG
l_int|2
comma
l_string|&quot;blknum can not be &gt; 2 for internal level&quot;
)paren
suffix:semicolon
id|RFALSE
c_func
(paren
id|tb-&gt;blknum
(braket
id|h
)braket
OL
l_int|0
comma
l_string|&quot;blknum can not be &lt; 0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tb-&gt;blknum
(braket
id|h
)braket
)paren
(brace
multiline_comment|/* node S[h] is empty now */
id|RFALSE
c_func
(paren
op_logical_neg
id|tbSh
comma
l_string|&quot;S[h] is equal NULL&quot;
)paren
suffix:semicolon
multiline_comment|/* do what is needed for buffer thrown from tree */
id|reiserfs_invalidate_buffer
c_func
(paren
id|tb
comma
id|tbSh
)paren
suffix:semicolon
r_return
id|order
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tbSh
)paren
(brace
multiline_comment|/* create new root */
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tbSh_1
op_assign
id|PATH_H_PBUFFER
(paren
id|tb-&gt;tb_path
comma
id|h
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;blknum
(braket
id|h
)braket
op_ne
l_int|1
)paren
id|reiserfs_panic
c_func
(paren
l_int|0
comma
l_string|&quot;balance_internal: One new node required for creating the new root&quot;
)paren
suffix:semicolon
multiline_comment|/* S[h] = empty buffer from the list FEB. */
id|tbSh
op_assign
id|get_FEB
(paren
id|tb
)paren
suffix:semicolon
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|tbSh
)paren
suffix:semicolon
id|set_blkh_level
c_func
(paren
id|blkh
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Put the unique node-pointer to S[h] that points to S[h-1]. */
id|dc
op_assign
id|B_N_CHILD
c_func
(paren
id|tbSh
comma
l_int|0
)paren
suffix:semicolon
id|put_dc_block_number
c_func
(paren
id|dc
comma
id|tbSh_1-&gt;b_blocknr
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|dc
comma
(paren
id|MAX_CHILD_SIZE
(paren
id|tbSh_1
)paren
op_minus
id|B_FREE_SPACE
(paren
id|tbSh_1
)paren
)paren
)paren
suffix:semicolon
id|tb-&gt;insert_size
(braket
id|h
)braket
op_sub_assign
id|DC_SIZE
suffix:semicolon
id|set_blkh_free_space
c_func
(paren
id|blkh
comma
id|blkh_free_space
c_func
(paren
id|blkh
)paren
op_minus
id|DC_SIZE
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|tbSh
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
id|check_internal
(paren
id|tbSh
)paren
suffix:semicolon
multiline_comment|/*&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;*/
multiline_comment|/* put new root into path structure */
id|PATH_OFFSET_PBUFFER
c_func
(paren
id|tb-&gt;tb_path
comma
id|ILLEGAL_PATH_ELEMENT_OFFSET
)paren
op_assign
id|tbSh
suffix:semicolon
multiline_comment|/* Change root in structure super block. */
id|PUT_SB_ROOT_BLOCK
c_func
(paren
id|tb-&gt;tb_sb
comma
id|tbSh-&gt;b_blocknr
)paren
suffix:semicolon
id|PUT_SB_TREE_HEIGHT
c_func
(paren
id|tb-&gt;tb_sb
comma
id|SB_TREE_HEIGHT
c_func
(paren
id|tb-&gt;tb_sb
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|do_balance_mark_sb_dirty
(paren
id|tb
comma
id|REISERFS_SB
c_func
(paren
id|tb-&gt;tb_sb
)paren
op_member_access_from_pointer
id|s_sbh
comma
l_int|1
)paren
suffix:semicolon
id|tb-&gt;tb_sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tb-&gt;blknum
(braket
id|h
)braket
op_eq
l_int|2
)paren
(brace
r_int
id|snum
suffix:semicolon
r_struct
id|buffer_info
id|dest_bi
comma
id|src_bi
suffix:semicolon
multiline_comment|/* S_new = free buffer from list FEB */
id|S_new
op_assign
id|get_FEB
c_func
(paren
id|tb
)paren
suffix:semicolon
id|set_blkh_level
c_func
(paren
id|B_BLK_HEAD
c_func
(paren
id|S_new
)paren
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|dest_bi.tb
op_assign
id|tb
suffix:semicolon
id|dest_bi.bi_bh
op_assign
id|S_new
suffix:semicolon
id|dest_bi.bi_parent
op_assign
l_int|0
suffix:semicolon
id|dest_bi.bi_position
op_assign
l_int|0
suffix:semicolon
id|src_bi.tb
op_assign
id|tb
suffix:semicolon
id|src_bi.bi_bh
op_assign
id|tbSh
suffix:semicolon
id|src_bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|src_bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|n
op_assign
id|B_NR_ITEMS
(paren
id|tbSh
)paren
suffix:semicolon
multiline_comment|/* number of items in S[h] */
id|snum
op_assign
(paren
id|insert_num
op_plus
id|n
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|n
op_minus
id|snum
op_ge
id|child_pos
)paren
(brace
multiline_comment|/* new items don&squot;t fall into S_new */
multiline_comment|/*&t;store the delimiting key for the next level */
multiline_comment|/* new_insert_key = (n - snum)&squot;th key in S[h] */
id|memcpy
(paren
op_amp
id|new_insert_key
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|tbSh
comma
id|n
op_minus
id|snum
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
multiline_comment|/* last parameter is del_par */
id|internal_move_pointers_items
(paren
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
id|LAST_TO_FIRST
comma
id|snum
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*            internal_move_pointers_items(S_new, tbSh, LAST_TO_FIRST, snum, 0);*/
)brace
r_else
r_if
c_cond
(paren
id|n
op_plus
id|insert_num
op_minus
id|snum
OL
id|child_pos
)paren
(brace
multiline_comment|/* all new items fall into S_new */
multiline_comment|/*&t;store the delimiting key for the next level */
multiline_comment|/* new_insert_key = (n + insert_item - snum)&squot;th key in S[h] */
id|memcpy
c_func
(paren
op_amp
id|new_insert_key
comma
id|B_N_PDELIM_KEY
c_func
(paren
id|tbSh
comma
id|n
op_plus
id|insert_num
op_minus
id|snum
)paren
comma
id|KEY_SIZE
)paren
suffix:semicolon
multiline_comment|/* last parameter is del_par */
id|internal_move_pointers_items
(paren
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
id|LAST_TO_FIRST
comma
id|snum
op_minus
id|insert_num
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&t;&t;&t;internal_move_pointers_items(S_new,tbSh,1,snum - insert_num,0);*/
multiline_comment|/* insert insert_num keys and node-pointers into S_new */
id|internal_insert_childs
(paren
op_amp
id|dest_bi
comma
multiline_comment|/*S_new,tb-&gt;S[h-1]-&gt;b_next,*/
id|child_pos
op_minus
id|n
op_minus
id|insert_num
op_plus
id|snum
op_minus
l_int|1
comma
id|insert_num
comma
id|insert_key
comma
id|insert_ptr
)paren
suffix:semicolon
id|insert_num
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|disk_child
op_star
id|dc
suffix:semicolon
multiline_comment|/* some items fall into S_new, but some don&squot;t fall */
multiline_comment|/* last parameter is del_par */
id|internal_move_pointers_items
(paren
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
id|LAST_TO_FIRST
comma
id|n
op_minus
id|child_pos
op_plus
l_int|1
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&t;&t;&t;internal_move_pointers_items(S_new,tbSh,1,n - child_pos + 1,1);*/
multiline_comment|/* calculate number of new items that fall into S_new */
id|k
op_assign
id|snum
op_minus
id|n
op_plus
id|child_pos
op_minus
l_int|1
suffix:semicolon
id|internal_insert_childs
(paren
op_amp
id|dest_bi
comma
multiline_comment|/*S_new,*/
l_int|0
comma
id|k
comma
id|insert_key
op_plus
l_int|1
comma
id|insert_ptr
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* new_insert_key = insert_key[insert_num - k - 1] */
id|memcpy
c_func
(paren
op_amp
id|new_insert_key
comma
id|insert_key
op_plus
id|insert_num
op_minus
id|k
op_minus
l_int|1
comma
id|KEY_SIZE
)paren
suffix:semicolon
multiline_comment|/* replace first node-ptr in S_new by node-ptr to insert_ptr[insert_num-k-1] */
id|dc
op_assign
id|B_N_CHILD
c_func
(paren
id|S_new
comma
l_int|0
)paren
suffix:semicolon
id|put_dc_size
c_func
(paren
id|dc
comma
(paren
id|MAX_CHILD_SIZE
c_func
(paren
id|insert_ptr
(braket
id|insert_num
op_minus
id|k
op_minus
l_int|1
)braket
)paren
op_minus
id|B_FREE_SPACE
c_func
(paren
id|insert_ptr
(braket
id|insert_num
op_minus
id|k
op_minus
l_int|1
)braket
)paren
)paren
)paren
suffix:semicolon
id|put_dc_block_number
c_func
(paren
id|dc
comma
id|insert_ptr
(braket
id|insert_num
op_minus
id|k
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|tb
comma
id|S_new
comma
l_int|0
)paren
suffix:semicolon
id|insert_num
op_sub_assign
(paren
id|k
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* new_insert_ptr = node_pointer to S_new */
id|new_insert_ptr
op_assign
id|S_new
suffix:semicolon
id|RFALSE
c_func
(paren
(paren
id|buffer_locked
c_func
(paren
id|S_new
)paren
op_logical_or
id|atomic_read
(paren
op_amp
(paren
id|S_new-&gt;b_count
)paren
)paren
op_ne
l_int|1
)paren
op_logical_and
(paren
id|buffer_locked
c_func
(paren
id|S_new
)paren
op_logical_or
id|atomic_read
c_func
(paren
op_amp
(paren
id|S_new-&gt;b_count
)paren
)paren
OG
l_int|2
op_logical_or
op_logical_neg
(paren
id|buffer_journaled
c_func
(paren
id|S_new
)paren
op_logical_or
id|buffer_journal_dirty
c_func
(paren
id|S_new
)paren
)paren
)paren
comma
l_string|&quot;cm-00001: bad S_new (%b)&quot;
comma
id|S_new
)paren
suffix:semicolon
singleline_comment|// S_new is released in unfix_nodes
)brace
id|n
op_assign
id|B_NR_ITEMS
(paren
id|tbSh
)paren
suffix:semicolon
multiline_comment|/*number of items in S[h] */
r_if
c_cond
(paren
l_int|0
op_le
id|child_pos
op_logical_and
id|child_pos
op_le
id|n
op_logical_and
id|insert_num
OG
l_int|0
)paren
(brace
id|bi.tb
op_assign
id|tb
suffix:semicolon
id|bi.bi_bh
op_assign
id|tbSh
suffix:semicolon
id|bi.bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
id|h
)paren
suffix:semicolon
id|bi.bi_position
op_assign
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
id|h
op_plus
l_int|1
)paren
suffix:semicolon
id|internal_insert_childs
(paren
op_amp
id|bi
comma
multiline_comment|/*tbSh,*/
multiline_comment|/*&t;&t;( tb-&gt;S[h-1]-&gt;b_parent == tb-&gt;S[h] ) ? tb-&gt;S[h-1]-&gt;b_next :  tb-&gt;S[h]-&gt;b_child-&gt;b_next,*/
id|child_pos
comma
id|insert_num
comma
id|insert_key
comma
id|insert_ptr
)paren
suffix:semicolon
)brace
id|memcpy
(paren
id|new_insert_key_addr
comma
op_amp
id|new_insert_key
comma
id|KEY_SIZE
)paren
suffix:semicolon
id|insert_ptr
(braket
l_int|0
)braket
op_assign
id|new_insert_ptr
suffix:semicolon
r_return
id|order
suffix:semicolon
)brace
eof
