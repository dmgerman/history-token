multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; *&n; * Trivial changes by Alan Cox to remove EHASHCOLLISION for compatibility&n; *&n; * Trivial Changes:&n; * Rights granted to Hans Reiser to redistribute under other terms providing&n; * he accepts all liability including but not limited to patent, fitness&n; * for purpose, and direct or indirect claims arising from failure to perform.&n; *&n; * NO WARRANTY&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/bitops.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|INC_DIR_INODE_NLINK
mdefine_line|#define INC_DIR_INODE_NLINK(i) if (i-&gt;i_nlink != 1) { i-&gt;i_nlink++; if (i-&gt;i_nlink &gt;= REISERFS_LINK_MAX) i-&gt;i_nlink=1; }
DECL|macro|DEC_DIR_INODE_NLINK
mdefine_line|#define DEC_DIR_INODE_NLINK(i) if (i-&gt;i_nlink != 1) i-&gt;i_nlink--;
singleline_comment|// directory item contains array of entry headers. This performs
singleline_comment|// binary search through that array
DECL|function|bin_search_in_dir_item
r_static
r_int
id|bin_search_in_dir_item
(paren
r_struct
id|reiserfs_dir_entry
op_star
id|de
comma
id|loff_t
id|off
)paren
(brace
r_struct
id|item_head
op_star
id|ih
op_assign
id|de-&gt;de_ih
suffix:semicolon
r_struct
id|reiserfs_de_head
op_star
id|deh
op_assign
id|de-&gt;de_deh
suffix:semicolon
r_int
id|rbound
comma
id|lbound
comma
id|j
suffix:semicolon
id|lbound
op_assign
l_int|0
suffix:semicolon
id|rbound
op_assign
id|I_ENTRY_COUNT
(paren
id|ih
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
(paren
id|rbound
op_plus
id|lbound
)paren
op_div
l_int|2
suffix:semicolon
id|lbound
op_le
id|rbound
suffix:semicolon
id|j
op_assign
(paren
id|rbound
op_plus
id|lbound
)paren
op_div
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|off
OL
id|deh_offset
(paren
id|deh
op_plus
id|j
)paren
)paren
(brace
id|rbound
op_assign
id|j
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|off
OG
id|deh_offset
(paren
id|deh
op_plus
id|j
)paren
)paren
(brace
id|lbound
op_assign
id|j
op_plus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// this is not name found, but matched third key component
id|de-&gt;de_entry_num
op_assign
id|j
suffix:semicolon
r_return
id|NAME_FOUND
suffix:semicolon
)brace
id|de-&gt;de_entry_num
op_assign
id|lbound
suffix:semicolon
r_return
id|NAME_NOT_FOUND
suffix:semicolon
)brace
singleline_comment|// comment?  maybe something like set de to point to what the path points to?
DECL|function|set_de_item_location
r_static
r_inline
r_void
id|set_de_item_location
(paren
r_struct
id|reiserfs_dir_entry
op_star
id|de
comma
r_struct
id|path
op_star
id|path
)paren
(brace
id|de-&gt;de_bh
op_assign
id|get_last_bh
(paren
id|path
)paren
suffix:semicolon
id|de-&gt;de_ih
op_assign
id|get_ih
(paren
id|path
)paren
suffix:semicolon
id|de-&gt;de_deh
op_assign
id|B_I_DEH
(paren
id|de-&gt;de_bh
comma
id|de-&gt;de_ih
)paren
suffix:semicolon
id|de-&gt;de_item_num
op_assign
id|PATH_LAST_POSITION
(paren
id|path
)paren
suffix:semicolon
)brace
singleline_comment|// de_bh, de_ih, de_deh (points to first element of array), de_item_num is set
DECL|function|set_de_name_and_namelen
r_inline
r_void
id|set_de_name_and_namelen
(paren
r_struct
id|reiserfs_dir_entry
op_star
id|de
)paren
(brace
r_struct
id|reiserfs_de_head
op_star
id|deh
op_assign
id|de-&gt;de_deh
op_plus
id|de-&gt;de_entry_num
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;de_entry_num
op_ge
id|ih_entry_count
(paren
id|de-&gt;de_ih
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
id|de-&gt;de_entrylen
op_assign
id|entry_length
(paren
id|de-&gt;de_bh
comma
id|de-&gt;de_ih
comma
id|de-&gt;de_entry_num
)paren
suffix:semicolon
id|de-&gt;de_namelen
op_assign
id|de-&gt;de_entrylen
op_minus
(paren
id|de_with_sd
(paren
id|deh
)paren
ques
c_cond
id|SD_SIZE
suffix:colon
l_int|0
)paren
suffix:semicolon
id|de-&gt;de_name
op_assign
id|B_I_PITEM
(paren
id|de-&gt;de_bh
comma
id|de-&gt;de_ih
)paren
op_plus
id|deh_location
c_func
(paren
id|deh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;de_name
(braket
id|de-&gt;de_namelen
op_minus
l_int|1
)braket
op_eq
l_int|0
)paren
id|de-&gt;de_namelen
op_assign
id|strlen
(paren
id|de-&gt;de_name
)paren
suffix:semicolon
)brace
singleline_comment|// what entry points to
DECL|function|set_de_object_key
r_static
r_inline
r_void
id|set_de_object_key
(paren
r_struct
id|reiserfs_dir_entry
op_star
id|de
)paren
(brace
r_if
c_cond
(paren
id|de-&gt;de_entry_num
op_ge
id|ih_entry_count
(paren
id|de-&gt;de_ih
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
id|de-&gt;de_dir_id
op_assign
id|deh_dir_id
c_func
(paren
op_amp
(paren
id|de-&gt;de_deh
(braket
id|de-&gt;de_entry_num
)braket
)paren
)paren
suffix:semicolon
id|de-&gt;de_objectid
op_assign
id|deh_objectid
c_func
(paren
op_amp
(paren
id|de-&gt;de_deh
(braket
id|de-&gt;de_entry_num
)braket
)paren
)paren
suffix:semicolon
)brace
DECL|function|store_de_entry_key
r_static
r_inline
r_void
id|store_de_entry_key
(paren
r_struct
id|reiserfs_dir_entry
op_star
id|de
)paren
(brace
r_struct
id|reiserfs_de_head
op_star
id|deh
op_assign
id|de-&gt;de_deh
op_plus
id|de-&gt;de_entry_num
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;de_entry_num
op_ge
id|ih_entry_count
(paren
id|de-&gt;de_ih
)paren
)paren
id|BUG
(paren
)paren
suffix:semicolon
multiline_comment|/* store key of the found entry */
id|de-&gt;de_entry_key.version
op_assign
id|KEY_FORMAT_3_5
suffix:semicolon
id|de-&gt;de_entry_key.on_disk_key.k_dir_id
op_assign
id|le32_to_cpu
(paren
id|de-&gt;de_ih-&gt;ih_key.k_dir_id
)paren
suffix:semicolon
id|de-&gt;de_entry_key.on_disk_key.k_objectid
op_assign
id|le32_to_cpu
(paren
id|de-&gt;de_ih-&gt;ih_key.k_objectid
)paren
suffix:semicolon
id|set_cpu_key_k_offset
(paren
op_amp
(paren
id|de-&gt;de_entry_key
)paren
comma
id|deh_offset
(paren
id|deh
)paren
)paren
suffix:semicolon
id|set_cpu_key_k_type
(paren
op_amp
(paren
id|de-&gt;de_entry_key
)paren
comma
id|TYPE_DIRENTRY
)paren
suffix:semicolon
)brace
multiline_comment|/* We assign a key to each directory item, and place multiple entries&n;in a single directory item.  A directory item has a key equal to the&n;key of the first directory entry in it.&n;&n;This function first calls search_by_key, then, if item whose first&n;entry matches is not found it looks for the entry inside directory&n;item found by search_by_key. Fills the path to the entry, and to the&n;entry position in the item &n;&n;*/
multiline_comment|/* The function is NOT SCHEDULE-SAFE! */
DECL|function|search_by_entry_key
r_int
id|search_by_entry_key
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_struct
id|cpu_key
op_star
id|key
comma
r_struct
id|path
op_star
id|path
comma
r_struct
id|reiserfs_dir_entry
op_star
id|de
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|search_item
(paren
id|sb
comma
id|key
comma
id|path
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|retval
)paren
(brace
r_case
id|ITEM_NOT_FOUND
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|PATH_LAST_POSITION
(paren
id|path
)paren
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-7000: search_by_entry_key: search_by_key returned item position == 0&quot;
)paren
suffix:semicolon
id|pathrelse
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
id|PATH_LAST_POSITION
(paren
id|path
)paren
op_decrement
suffix:semicolon
r_case
id|ITEM_FOUND
suffix:colon
r_break
suffix:semicolon
r_case
id|IO_ERROR
suffix:colon
r_return
id|retval
suffix:semicolon
r_default
suffix:colon
id|pathrelse
(paren
id|path
)paren
suffix:semicolon
id|reiserfs_warning
(paren
l_string|&quot;vs-7002: search_by_entry_key: no path to here&quot;
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
id|set_de_item_location
(paren
id|de
comma
id|path
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|is_direntry_le_ih
(paren
id|de-&gt;de_ih
)paren
op_logical_or
id|COMP_SHORT_KEYS
(paren
op_amp
(paren
id|de-&gt;de_ih-&gt;ih_key
)paren
comma
id|key
)paren
)paren
(brace
id|print_block
(paren
id|de-&gt;de_bh
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|sb
comma
l_string|&quot;vs-7005: search_by_entry_key: found item %h is not directory item or &quot;
l_string|&quot;does not belong to the same directory as key %K&quot;
comma
id|de-&gt;de_ih
comma
id|key
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_REISERFS_CHECK */
multiline_comment|/* binary search in directory item by third componen t of the&n;       key. sets de-&gt;de_entry_num of de */
id|retval
op_assign
id|bin_search_in_dir_item
(paren
id|de
comma
id|cpu_key_k_offset
(paren
id|key
)paren
)paren
suffix:semicolon
id|path-&gt;pos_in_item
op_assign
id|de-&gt;de_entry_num
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|NAME_NOT_FOUND
)paren
(brace
singleline_comment|// ugly, but rename needs de_bh, de_deh, de_name, de_namelen, de_objectid set
id|set_de_name_and_namelen
(paren
id|de
)paren
suffix:semicolon
id|set_de_object_key
(paren
id|de
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Keyed 32-bit hash function using TEA in a Davis-Meyer function */
multiline_comment|/* The third component is hashed, and you can choose from more than&n;   one hash function.  Per directory hashes are not yet implemented&n;   but are thought about. This function should be moved to hashes.c&n;   Jedi, please do so.  -Hans */
DECL|function|get_third_component
r_static
id|__u32
id|get_third_component
(paren
r_struct
id|super_block
op_star
id|s
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
id|__u32
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
(paren
id|len
op_eq
l_int|1
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
r_return
id|DOT_OFFSET
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_return
id|DOT_DOT_OFFSET
suffix:semicolon
id|res
op_assign
id|REISERFS_SB
c_func
(paren
id|s
)paren
op_member_access_from_pointer
id|s_hash_function
(paren
id|name
comma
id|len
)paren
suffix:semicolon
singleline_comment|// take bits from 7-th to 30-th including both bounds
id|res
op_assign
id|GET_HASH_VALUE
c_func
(paren
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|0
)paren
singleline_comment|// needed to have no names before &quot;.&quot; and &quot;..&quot; those have hash
singleline_comment|// value == 0 and generation conters 1 and 2 accordingly
id|res
op_assign
l_int|128
suffix:semicolon
r_return
id|res
op_plus
id|MAX_GENERATION_NUMBER
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_match
r_static
r_int
id|reiserfs_match
(paren
r_struct
id|reiserfs_dir_entry
op_star
id|de
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_int
id|retval
op_assign
id|NAME_NOT_FOUND
suffix:semicolon
r_if
c_cond
(paren
(paren
id|namelen
op_eq
id|de-&gt;de_namelen
)paren
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|de-&gt;de_name
comma
id|name
comma
id|de-&gt;de_namelen
)paren
)paren
id|retval
op_assign
(paren
id|de_visible
(paren
id|de-&gt;de_deh
op_plus
id|de-&gt;de_entry_num
)paren
ques
c_cond
id|NAME_FOUND
suffix:colon
id|NAME_FOUND_INVISIBLE
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* de&squot;s de_bh, de_ih, de_deh, de_item_num, de_entry_num are set already */
multiline_comment|/* used when hash collisions exist */
DECL|function|linear_search_in_dir_item
r_static
r_int
id|linear_search_in_dir_item
(paren
r_struct
id|cpu_key
op_star
id|key
comma
r_struct
id|reiserfs_dir_entry
op_star
id|de
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_struct
id|reiserfs_de_head
op_star
id|deh
op_assign
id|de-&gt;de_deh
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|i
suffix:semicolon
id|i
op_assign
id|de-&gt;de_entry_num
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|I_ENTRY_COUNT
(paren
id|de-&gt;de_ih
)paren
op_logical_or
id|GET_HASH_VALUE
(paren
id|deh_offset
(paren
id|deh
op_plus
id|i
)paren
)paren
op_ne
id|GET_HASH_VALUE
(paren
id|cpu_key_k_offset
(paren
id|key
)paren
)paren
)paren
(brace
id|i
op_decrement
suffix:semicolon
)brace
id|RFALSE
c_func
(paren
id|de-&gt;de_deh
op_ne
id|B_I_DEH
(paren
id|de-&gt;de_bh
comma
id|de-&gt;de_ih
)paren
comma
l_string|&quot;vs-7010: array of entry headers not found&quot;
)paren
suffix:semicolon
id|deh
op_add_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
comma
id|deh
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|GET_HASH_VALUE
(paren
id|deh_offset
(paren
id|deh
)paren
)paren
op_ne
id|GET_HASH_VALUE
(paren
id|cpu_key_k_offset
(paren
id|key
)paren
)paren
)paren
(brace
singleline_comment|// hash value does not match, no need to check whole name
r_return
id|NAME_NOT_FOUND
suffix:semicolon
)brace
multiline_comment|/* mark, that this generation number is used */
r_if
c_cond
(paren
id|de-&gt;de_gen_number_bit_string
)paren
id|set_bit
(paren
id|GET_GENERATION_NUMBER
(paren
id|deh_offset
(paren
id|deh
)paren
)paren
comma
id|de-&gt;de_gen_number_bit_string
)paren
suffix:semicolon
singleline_comment|// calculate pointer to name and namelen
id|de-&gt;de_entry_num
op_assign
id|i
suffix:semicolon
id|set_de_name_and_namelen
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|reiserfs_match
(paren
id|de
comma
id|name
comma
id|namelen
)paren
)paren
op_ne
id|NAME_NOT_FOUND
)paren
(brace
singleline_comment|// de&squot;s de_name, de_namelen, de_recordlen are set. Fill the rest:
singleline_comment|// key of pointed object
id|set_de_object_key
(paren
id|de
)paren
suffix:semicolon
id|store_de_entry_key
(paren
id|de
)paren
suffix:semicolon
singleline_comment|// retval can be NAME_FOUND or NAME_FOUND_INVISIBLE
r_return
id|retval
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|GET_GENERATION_NUMBER
(paren
id|le_ih_k_offset
(paren
id|de-&gt;de_ih
)paren
)paren
op_eq
l_int|0
)paren
multiline_comment|/* we have reached left most entry in the node. In common we&n;           have to go to the left neighbor, but if generation counter&n;           is 0 already, we know for sure, that there is no name with&n;           the same hash value */
singleline_comment|// FIXME: this work correctly only because hash value can not
singleline_comment|// be 0. Btw, in case of Yura&squot;s hash it is probably possible,
singleline_comment|// so, this is a bug
r_return
id|NAME_NOT_FOUND
suffix:semicolon
id|RFALSE
c_func
(paren
id|de-&gt;de_item_num
comma
l_string|&quot;vs-7015: two diritems of the same directory in one node?&quot;
)paren
suffix:semicolon
r_return
id|GOTO_PREVIOUS_ITEM
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
singleline_comment|// may return NAME_FOUND, NAME_FOUND_INVISIBLE, NAME_NOT_FOUND
singleline_comment|// FIXME: should add something like IOERROR
DECL|function|reiserfs_find_entry
r_static
r_int
id|reiserfs_find_entry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_struct
id|path
op_star
id|path_to_entry
comma
r_struct
id|reiserfs_dir_entry
op_star
id|de
)paren
(brace
r_struct
id|cpu_key
id|key_to_search
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
id|REISERFS_MAX_NAME_LEN
(paren
id|dir-&gt;i_sb-&gt;s_blocksize
)paren
)paren
r_return
id|NAME_NOT_FOUND
suffix:semicolon
multiline_comment|/* we will search for this key in the tree */
id|make_cpu_key
(paren
op_amp
id|key_to_search
comma
id|dir
comma
id|get_third_component
(paren
id|dir-&gt;i_sb
comma
id|name
comma
id|namelen
)paren
comma
id|TYPE_DIRENTRY
comma
l_int|3
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|retval
op_assign
id|search_by_entry_key
(paren
id|dir-&gt;i_sb
comma
op_amp
id|key_to_search
comma
id|path_to_entry
comma
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;zam-7001: io error in &quot;
id|__FUNCTION__
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
multiline_comment|/* compare names for all entries having given hash value */
id|retval
op_assign
id|linear_search_in_dir_item
(paren
op_amp
id|key_to_search
comma
id|de
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|GOTO_PREVIOUS_ITEM
)paren
(brace
multiline_comment|/* there is no need to scan directory anymore. Given entry found or does not exist */
id|path_to_entry-&gt;pos_in_item
op_assign
id|de-&gt;de_entry_num
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* there is left neighboring item of this directory and given entry can be there */
id|set_cpu_key_k_offset
(paren
op_amp
id|key_to_search
comma
id|le_ih_k_offset
(paren
id|de-&gt;de_ih
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|pathrelse
(paren
id|path_to_entry
)paren
suffix:semicolon
)brace
multiline_comment|/* while (1) */
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_lookup
r_static
r_struct
id|dentry
op_star
id|reiserfs_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path_to_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|REISERFS_MAX_NAME_LEN
(paren
id|dir-&gt;i_sb-&gt;s_blocksize
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENAMETOOLONG
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|de.de_gen_number_bit_string
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|reiserfs_find_entry
(paren
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|path_to_entry
comma
op_amp
id|de
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path_to_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|NAME_FOUND
)paren
(brace
id|inode
op_assign
id|reiserfs_iget
(paren
id|dir-&gt;i_sb
comma
(paren
r_struct
id|cpu_key
op_star
)paren
op_amp
(paren
id|de.de_dir_id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
id|IS_ERR
c_func
(paren
id|inode
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
multiline_comment|/* add entry to the directory (entry can be hidden). &n;&n;insert definition of when hidden directories are used here -Hans&n;&n; Does not mark dir   inode dirty, do it after successesfull call to it */
DECL|function|reiserfs_add_entry
r_static
r_int
id|reiserfs_add_entry
(paren
r_struct
id|reiserfs_transaction_handle
op_star
id|th
comma
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|visible
)paren
(brace
r_struct
id|cpu_key
id|entry_key
suffix:semicolon
r_struct
id|reiserfs_de_head
op_star
id|deh
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
r_int
id|bit_string
(braket
id|MAX_GENERATION_NUMBER
op_div
(paren
r_sizeof
(paren
r_int
)paren
op_star
l_int|8
)paren
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|gen_number
suffix:semicolon
r_char
id|small_buf
(braket
l_int|32
op_plus
id|DEH_SIZE
)braket
suffix:semicolon
multiline_comment|/* 48 bytes now and we avoid kmalloc&n;                                     if we create file with short name */
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|buflen
comma
id|paste_size
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/* cannot allow items to be added into a busy deleted directory */
r_if
c_cond
(paren
op_logical_neg
id|namelen
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
id|REISERFS_MAX_NAME_LEN
(paren
id|dir-&gt;i_sb-&gt;s_blocksize
)paren
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
multiline_comment|/* each entry has unique key. compose it */
id|make_cpu_key
(paren
op_amp
id|entry_key
comma
id|dir
comma
id|get_third_component
(paren
id|dir-&gt;i_sb
comma
id|name
comma
id|namelen
)paren
comma
id|TYPE_DIRENTRY
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* get memory for composing the entry */
id|buflen
op_assign
id|DEH_SIZE
op_plus
id|ROUND_UP
(paren
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buflen
OG
r_sizeof
(paren
id|small_buf
)paren
)paren
(brace
id|buffer
op_assign
id|reiserfs_kmalloc
(paren
id|buflen
comma
id|GFP_NOFS
comma
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
id|buffer
op_assign
id|small_buf
suffix:semicolon
id|paste_size
op_assign
(paren
id|old_format_only
(paren
id|dir-&gt;i_sb
)paren
)paren
ques
c_cond
(paren
id|DEH_SIZE
op_plus
id|namelen
)paren
suffix:colon
id|buflen
suffix:semicolon
multiline_comment|/* fill buffer : directory entry head, name[, dir objectid | , stat data | ,stat data, dir objectid ] */
id|deh
op_assign
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
id|buffer
suffix:semicolon
id|deh-&gt;deh_location
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* JDM Endian safe if 0 */
id|put_deh_offset
c_func
(paren
id|deh
comma
id|cpu_key_k_offset
c_func
(paren
op_amp
id|entry_key
)paren
)paren
suffix:semicolon
id|deh-&gt;deh_state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* JDM Endian safe if 0 */
multiline_comment|/* put key (ino analog) to de */
id|deh-&gt;deh_dir_id
op_assign
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_dir_id
suffix:semicolon
multiline_comment|/* safe: k_dir_id is le */
id|deh-&gt;deh_objectid
op_assign
id|INODE_PKEY
(paren
id|inode
)paren
op_member_access_from_pointer
id|k_objectid
suffix:semicolon
multiline_comment|/* safe: k_objectid is le */
multiline_comment|/* copy name */
id|memcpy
(paren
(paren
r_char
op_star
)paren
(paren
id|deh
op_plus
l_int|1
)paren
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
multiline_comment|/* padd by 0s to the 4 byte boundary */
id|padd_item
(paren
(paren
r_char
op_star
)paren
(paren
id|deh
op_plus
l_int|1
)paren
comma
id|ROUND_UP
(paren
id|namelen
)paren
comma
id|namelen
)paren
suffix:semicolon
multiline_comment|/* entry is ready to be pasted into tree, set &squot;visibility&squot; and &squot;stat data in entry&squot; attributes */
id|mark_de_without_sd
(paren
id|deh
)paren
suffix:semicolon
id|visible
ques
c_cond
id|mark_de_visible
(paren
id|deh
)paren
suffix:colon
id|mark_de_hidden
(paren
id|deh
)paren
suffix:semicolon
multiline_comment|/* find the proper place for the new entry */
id|memset
(paren
id|bit_string
comma
l_int|0
comma
r_sizeof
(paren
id|bit_string
)paren
)paren
suffix:semicolon
id|de.de_gen_number_bit_string
op_assign
(paren
r_char
op_star
)paren
id|bit_string
suffix:semicolon
id|retval
op_assign
id|reiserfs_find_entry
(paren
id|dir
comma
id|name
comma
id|namelen
comma
op_amp
id|path
comma
op_amp
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|NAME_NOT_FOUND
)paren
(brace
r_if
c_cond
(paren
id|buffer
op_ne
id|small_buf
)paren
id|reiserfs_kfree
(paren
id|buffer
comma
id|buflen
comma
id|dir-&gt;i_sb
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_ne
id|NAME_FOUND
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;zam-7002:&quot;
id|__FUNCTION__
l_string|&quot;: &bslash;&quot;reiserfs_find_entry&bslash;&quot; has returned&quot;
l_string|&quot; unexpected value (%d)&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
id|gen_number
op_assign
id|find_first_zero_bit
(paren
id|bit_string
comma
id|MAX_GENERATION_NUMBER
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gen_number
OG
id|MAX_GENERATION_NUMBER
)paren
(brace
multiline_comment|/* there is no free generation number */
id|reiserfs_warning
(paren
l_string|&quot;reiserfs_add_entry: Congratulations! we have got hash function screwed up&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_ne
id|small_buf
)paren
id|reiserfs_kfree
(paren
id|buffer
comma
id|buflen
comma
id|dir-&gt;i_sb
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* adjust offset of directory enrty */
id|put_deh_offset
c_func
(paren
id|deh
comma
id|SET_GENERATION_NUMBER
c_func
(paren
id|deh_offset
c_func
(paren
id|deh
)paren
comma
id|gen_number
)paren
)paren
suffix:semicolon
id|set_cpu_key_k_offset
(paren
op_amp
id|entry_key
comma
id|deh_offset
c_func
(paren
id|deh
)paren
)paren
suffix:semicolon
multiline_comment|/* update max-hash-collisions counter in reiserfs_sb_info */
id|PROC_INFO_MAX
c_func
(paren
id|th
op_member_access_from_pointer
id|t_super
comma
id|max_hash_collisions
comma
id|gen_number
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gen_number
op_ne
l_int|0
)paren
(brace
multiline_comment|/* we need to re-search for the insertion point */
r_if
c_cond
(paren
id|search_by_entry_key
(paren
id|dir-&gt;i_sb
comma
op_amp
id|entry_key
comma
op_amp
id|path
comma
op_amp
id|de
)paren
op_ne
id|NAME_NOT_FOUND
)paren
(brace
id|reiserfs_warning
(paren
l_string|&quot;vs-7032: reiserfs_add_entry: &quot;
l_string|&quot;entry with this key (%K) already exists&bslash;n&quot;
comma
op_amp
id|entry_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_ne
id|small_buf
)paren
id|reiserfs_kfree
(paren
id|buffer
comma
id|buflen
comma
id|dir-&gt;i_sb
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
multiline_comment|/* perform the insertion of the entry that we have prepared */
id|retval
op_assign
id|reiserfs_paste_into_item
(paren
id|th
comma
op_amp
id|path
comma
op_amp
id|entry_key
comma
id|buffer
comma
id|paste_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_ne
id|small_buf
)paren
id|reiserfs_kfree
(paren
id|buffer
comma
id|buflen
comma
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|dir-&gt;i_size
op_add_assign
id|paste_size
suffix:semicolon
id|dir-&gt;i_blocks
op_assign
(paren
(paren
id|dir-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
id|dir-&gt;i_mtime
op_assign
id|dir-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|visible
)paren
singleline_comment|// reiserfs_mkdir or reiserfs_rename will do that by itself
id|reiserfs_update_sd
(paren
id|th
comma
id|dir
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_create
r_static
r_int
id|reiserfs_create
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|th.t_caller
op_assign
l_string|&quot;create&quot;
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_create&quot;
)paren
suffix:semicolon
id|inode
op_assign
id|reiserfs_new_inode
(paren
op_amp
id|th
comma
id|dir
comma
id|mode
comma
l_int|0
comma
l_int|0
multiline_comment|/*i_size*/
comma
id|dentry
comma
id|inode
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_file_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|reiserfs_file_operations
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|reiserfs_address_space_operations
suffix:semicolon
id|retval
op_assign
id|reiserfs_add_entry
(paren
op_amp
id|th
comma
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|inode
comma
l_int|1
multiline_comment|/*visible*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
singleline_comment|// FIXME: should we put iput here and have stat data deleted
singleline_comment|// in the same transactioin
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|dir
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_mknod
r_static
r_int
id|reiserfs_mknod
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|rdev
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_mknod&quot;
)paren
suffix:semicolon
id|inode
op_assign
id|reiserfs_new_inode
(paren
op_amp
id|th
comma
id|dir
comma
id|mode
comma
l_int|0
comma
l_int|0
multiline_comment|/*i_size*/
comma
id|dentry
comma
id|inode
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|init_special_inode
c_func
(paren
id|inode
comma
id|mode
comma
id|rdev
)paren
suffix:semicolon
singleline_comment|//FIXME: needed for block and char devices only
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|dir
)paren
suffix:semicolon
id|retval
op_assign
id|reiserfs_add_entry
(paren
op_amp
id|th
comma
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|inode
comma
l_int|1
multiline_comment|/*visible*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_mkdir
r_static
r_int
id|reiserfs_mkdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_mkdir&quot;
)paren
suffix:semicolon
multiline_comment|/* inc the link count now, so another writer doesn&squot;t overflow it while&n;    ** we sleep later on.&n;    */
id|INC_DIR_INODE_NLINK
c_func
(paren
id|dir
)paren
id|mode
op_assign
id|S_IFDIR
op_or
id|mode
suffix:semicolon
id|inode
op_assign
id|reiserfs_new_inode
(paren
op_amp
id|th
comma
id|dir
comma
id|mode
comma
l_int|0
multiline_comment|/*symlink*/
comma
id|old_format_only
(paren
id|dir-&gt;i_sb
)paren
ques
c_cond
id|EMPTY_DIR_SIZE_V1
suffix:colon
id|EMPTY_DIR_SIZE
comma
id|dentry
comma
id|inode
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|dir-&gt;i_nlink
op_decrement
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|dir
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|reiserfs_dir_inode_operations
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|reiserfs_dir_operations
suffix:semicolon
singleline_comment|// note, _this_ add_entry will not update dir&squot;s stat data
id|retval
op_assign
id|reiserfs_add_entry
(paren
op_amp
id|th
comma
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|inode
comma
l_int|1
multiline_comment|/*visible*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|DEC_DIR_INODE_NLINK
c_func
(paren
id|dir
)paren
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
singleline_comment|// the above add_entry did not update dir&squot;s stat data
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|dir
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|reiserfs_empty_dir
r_static
r_inline
r_int
id|reiserfs_empty_dir
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
multiline_comment|/* we can cheat because an old format dir cannot have&n;    ** EMPTY_DIR_SIZE, and a new format dir cannot have&n;    ** EMPTY_DIR_SIZE_V1.  So, if the inode is either size, &n;    ** regardless of disk format version, the directory is empty.&n;    */
r_if
c_cond
(paren
id|inode-&gt;i_size
op_ne
id|EMPTY_DIR_SIZE
op_logical_and
id|inode-&gt;i_size
op_ne
id|EMPTY_DIR_SIZE_V1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_rmdir
r_static
r_int
id|reiserfs_rmdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
multiline_comment|/* we will be doing 2 balancings and update 2 stat data */
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
op_plus
l_int|2
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_rmdir&quot;
)paren
suffix:semicolon
id|de.de_gen_number_bit_string
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|reiserfs_find_entry
(paren
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|path
comma
op_amp
id|de
)paren
)paren
op_eq
id|NAME_NOT_FOUND
)paren
(brace
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|end_rmdir
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|end_rmdir
suffix:semicolon
)brace
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de.de_objectid
op_ne
id|inode-&gt;i_ino
)paren
(brace
singleline_comment|// FIXME: compare key of an object and a key found in the
singleline_comment|// entry
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|end_rmdir
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_empty_dir
c_func
(paren
id|inode
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_goto
id|end_rmdir
suffix:semicolon
)brace
multiline_comment|/* cut entry from dir directory */
id|retval
op_assign
id|reiserfs_cut_from_item
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
(paren
id|de.de_entry_key
)paren
comma
id|dir
comma
l_int|NULL
comma
multiline_comment|/* page */
l_int|0
multiline_comment|/*new file size - not used here*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|end_rmdir
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_ne
l_int|2
op_logical_and
id|inode-&gt;i_nlink
op_ne
l_int|1
)paren
id|printk
(paren
l_string|&quot;reiserfs_rmdir: empty directory has nlink != 2 (%d)&bslash;n&quot;
comma
id|inode-&gt;i_nlink
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|DEC_DIR_INODE_NLINK
c_func
(paren
id|dir
)paren
id|dir-&gt;i_size
op_sub_assign
(paren
id|DEH_SIZE
op_plus
id|de.de_entrylen
)paren
suffix:semicolon
id|dir-&gt;i_blocks
op_assign
(paren
(paren
id|dir-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|dir
)paren
suffix:semicolon
multiline_comment|/* prevent empty directory from getting lost */
id|add_save_link
(paren
op_amp
id|th
comma
id|inode
comma
l_int|0
multiline_comment|/* not truncate */
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|end_rmdir
suffix:colon
multiline_comment|/* we must release path, because we did not call&n;       reiserfs_cut_from_item, or reiserfs_cut_from_item does not&n;       release path if operation was not complete */
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_unlink
r_static
r_int
id|reiserfs_unlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|de
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|path
)paren
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* in this transaction we can be doing at max two balancings and update&n;       two stat datas */
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|2
op_plus
l_int|2
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_unlink&quot;
)paren
suffix:semicolon
id|de.de_gen_number_bit_string
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|reiserfs_find_entry
(paren
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|path
comma
op_amp
id|de
)paren
)paren
op_eq
id|NAME_NOT_FOUND
)paren
(brace
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|end_unlink
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|end_unlink
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de.de_objectid
op_ne
id|inode-&gt;i_ino
)paren
(brace
singleline_comment|// FIXME: compare key of an object and a key found in the
singleline_comment|// entry
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|end_unlink
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_nlink
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reiserfs_unlink: deleting nonexistent file (%s:%lu), %d&bslash;n&quot;
comma
id|inode-&gt;i_sb-&gt;s_id
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_nlink
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
)brace
id|retval
op_assign
id|reiserfs_cut_from_item
(paren
op_amp
id|th
comma
op_amp
id|path
comma
op_amp
(paren
id|de.de_entry_key
)paren
comma
id|dir
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|end_unlink
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|dir-&gt;i_size
op_sub_assign
(paren
id|de.de_entrylen
op_plus
id|DEH_SIZE
)paren
suffix:semicolon
id|dir-&gt;i_blocks
op_assign
(paren
(paren
id|dir-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_nlink
)paren
multiline_comment|/* prevent file from getting lost */
id|add_save_link
(paren
op_amp
id|th
comma
id|inode
comma
l_int|0
multiline_comment|/* not truncate */
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|end_unlink
suffix:colon
id|pathrelse
(paren
op_amp
id|path
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|reiserfs_check_path
c_func
(paren
op_amp
id|path
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_symlink
r_static
r_int
id|reiserfs_symlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|item_len
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|item_len
op_assign
id|ROUND_UP
(paren
id|strlen
(paren
id|symname
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item_len
OG
id|MAX_DIRECT_ITEM_LEN
(paren
id|dir-&gt;i_sb-&gt;s_blocksize
)paren
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|name
op_assign
id|reiserfs_kmalloc
(paren
id|item_len
comma
id|GFP_NOFS
comma
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memcpy
(paren
id|name
comma
id|symname
comma
id|strlen
(paren
id|symname
)paren
)paren
suffix:semicolon
id|padd_item
(paren
id|name
comma
id|item_len
comma
id|strlen
(paren
id|symname
)paren
)paren
suffix:semicolon
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_symlink&quot;
)paren
suffix:semicolon
id|inode
op_assign
id|reiserfs_new_inode
(paren
op_amp
id|th
comma
id|dir
comma
id|S_IFLNK
op_or
id|S_IRWXUGO
comma
id|name
comma
id|strlen
(paren
id|symname
)paren
comma
id|dentry
comma
id|inode
comma
op_amp
id|retval
)paren
suffix:semicolon
id|reiserfs_kfree
(paren
id|name
comma
id|item_len
comma
id|dir-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
l_int|0
)paren
(brace
multiline_comment|/* reiserfs_new_inode iputs for us */
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|dir
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|page_symlink_inode_operations
suffix:semicolon
id|inode-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|reiserfs_address_space_operations
suffix:semicolon
singleline_comment|// must be sure this inode is written with this transaction
singleline_comment|//
singleline_comment|//reiserfs_update_sd (&amp;th, inode, READ_BLOCKS);
id|retval
op_assign
id|reiserfs_add_entry
(paren
op_amp
id|th
comma
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|inode
comma
l_int|1
multiline_comment|/*visible*/
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
DECL|function|reiserfs_link
r_static
r_int
id|reiserfs_link
(paren
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_ge
id|REISERFS_LINK_MAX
)paren
(brace
singleline_comment|//FIXME: sd_nlink is 32 bit for new files
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EMLINK
suffix:semicolon
)brace
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_link&quot;
)paren
suffix:semicolon
multiline_comment|/* create new entry */
id|retval
op_assign
id|reiserfs_add_entry
(paren
op_amp
id|th
comma
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|inode
comma
l_int|1
multiline_comment|/*visible*/
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|inode
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|inode-&gt;i_nlink
op_increment
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|inode
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// de contains information pointing to an entry which 
DECL|function|de_still_valid
r_static
r_int
id|de_still_valid
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|reiserfs_dir_entry
op_star
id|de
)paren
(brace
r_struct
id|reiserfs_dir_entry
id|tmp
op_assign
op_star
id|de
suffix:semicolon
singleline_comment|// recalculate pointer to name and name length
id|set_de_name_and_namelen
(paren
op_amp
id|tmp
)paren
suffix:semicolon
singleline_comment|// FIXME: could check more
r_if
c_cond
(paren
id|tmp.de_namelen
op_ne
id|len
op_logical_or
id|memcmp
(paren
id|name
comma
id|de-&gt;de_name
comma
id|len
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|entry_points_to_object
r_static
r_int
id|entry_points_to_object
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|reiserfs_dir_entry
op_star
id|de
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de_still_valid
(paren
id|name
comma
id|len
comma
id|de
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de_visible
(paren
id|de-&gt;de_deh
op_plus
id|de-&gt;de_entry_num
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-7042: entry_points_to_object: entry must be visible&quot;
)paren
suffix:semicolon
r_return
(paren
id|de-&gt;de_objectid
op_eq
id|inode-&gt;i_ino
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* this must be added hidden entry */
r_if
c_cond
(paren
id|de_visible
(paren
id|de-&gt;de_deh
op_plus
id|de-&gt;de_entry_num
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-7043: entry_points_to_object: entry must be visible&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* sets key of objectid the entry has to point to */
DECL|function|set_ino_in_dir_entry
r_static
r_void
id|set_ino_in_dir_entry
(paren
r_struct
id|reiserfs_dir_entry
op_star
id|de
comma
r_struct
id|key
op_star
id|key
)paren
(brace
multiline_comment|/* JDM These operations are endian safe - both are le */
id|de-&gt;de_deh
(braket
id|de-&gt;de_entry_num
)braket
dot
id|deh_dir_id
op_assign
id|key-&gt;k_dir_id
suffix:semicolon
id|de-&gt;de_deh
(braket
id|de-&gt;de_entry_num
)braket
dot
id|deh_objectid
op_assign
id|key-&gt;k_objectid
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// a portion of this function, particularly the VFS interface portion,
singleline_comment|// was derived from minix or ext2&squot;s analog and evolved as the
singleline_comment|// prototype did. You should be able to tell which portion by looking
singleline_comment|// at the ext2 code and comparing. It&squot;s subfunctions contain no code
singleline_comment|// used as a template unless they are so labeled.
singleline_comment|//
multiline_comment|/* &n; * process, that is going to call fix_nodes/do_balance must hold only&n; * one path. If it holds 2 or more, it can get into endless waiting in&n; * get_empty_nodes or its clones &n; */
DECL|function|reiserfs_rename
r_static
r_int
id|reiserfs_rename
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|retval
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|old_entry_path
)paren
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|new_entry_path
)paren
suffix:semicolon
id|INITIALIZE_PATH
(paren
id|dot_dot_entry_path
)paren
suffix:semicolon
r_struct
id|item_head
id|new_entry_ih
comma
id|old_entry_ih
comma
id|dot_dot_ih
suffix:semicolon
r_struct
id|reiserfs_dir_entry
id|old_de
comma
id|new_de
comma
id|dot_dot_de
suffix:semicolon
r_struct
id|inode
op_star
id|old_inode
comma
op_star
id|new_inode
suffix:semicolon
r_int
id|windex
suffix:semicolon
r_struct
id|reiserfs_transaction_handle
id|th
suffix:semicolon
r_int
id|jbegin_count
suffix:semicolon
multiline_comment|/* two balancings: old name removal, new name insertion or &quot;save&quot; link,&n;       stat data updates: old directory and new directory and maybe block&n;       containing &quot;..&quot; of renamed directory */
id|jbegin_count
op_assign
id|JOURNAL_PER_BALANCE_CNT
op_star
l_int|3
op_plus
l_int|3
suffix:semicolon
id|old_inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
id|new_inode
op_assign
id|new_dentry-&gt;d_inode
suffix:semicolon
singleline_comment|// make sure, that oldname still exists and points to an object we
singleline_comment|// are going to rename
id|old_de.de_gen_number_bit_string
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|reiserfs_find_entry
(paren
id|old_dir
comma
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
comma
op_amp
id|old_entry_path
comma
op_amp
id|old_de
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|old_entry_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|IO_ERROR
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_ne
id|NAME_FOUND
op_logical_or
id|old_de.de_objectid
op_ne
id|old_inode-&gt;i_ino
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_inode-&gt;i_mode
)paren
)paren
(brace
singleline_comment|// make sure, that directory being renamed has correct &quot;..&quot; 
singleline_comment|// and that its new parent directory has not too many links
singleline_comment|// already
r_if
c_cond
(paren
id|new_inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reiserfs_empty_dir
c_func
(paren
id|new_inode
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
)brace
multiline_comment|/* directory is renamed, its parent directory will be changed, &n;&t;** so find &quot;..&quot; entry &n;&t;*/
id|dot_dot_de.de_gen_number_bit_string
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|reiserfs_find_entry
(paren
id|old_inode
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
op_amp
id|dot_dot_entry_path
comma
op_amp
id|dot_dot_de
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|dot_dot_entry_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|NAME_FOUND
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* inode number of .. must equal old_dir-&gt;i_ino */
r_if
c_cond
(paren
id|dot_dot_de.de_objectid
op_ne
id|old_dir-&gt;i_ino
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|journal_begin
c_func
(paren
op_amp
id|th
comma
id|old_dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|windex
op_assign
id|push_journal_writer
c_func
(paren
l_string|&quot;reiserfs_rename&quot;
)paren
suffix:semicolon
multiline_comment|/* add new entry (or find the existing one) */
id|retval
op_assign
id|reiserfs_add_entry
(paren
op_amp
id|th
comma
id|new_dir
comma
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.len
comma
id|old_inode
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
op_minus
id|EEXIST
)paren
(brace
singleline_comment|// FIXME: is it possible, that new_inode == 0 here? If yes, it
singleline_comment|// is not clear how does ext2 handle that
r_if
c_cond
(paren
op_logical_neg
id|new_inode
)paren
(brace
id|reiserfs_panic
(paren
id|old_dir-&gt;i_sb
comma
l_string|&quot;vs-7050: new entry is found, new inode == 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|retval
)paren
(brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|old_dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|reiserfs_update_inode_transaction
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|reiserfs_update_inode_transaction
c_func
(paren
id|new_dir
)paren
suffix:semicolon
multiline_comment|/* this makes it so an fsync on an open fd for the old name will&n;    ** commit the rename operation&n;    */
id|reiserfs_update_inode_transaction
c_func
(paren
id|old_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_inode
)paren
id|reiserfs_update_inode_transaction
c_func
(paren
id|new_inode
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
singleline_comment|// look for old name using corresponding entry key (found by reiserfs_find_entry)
r_if
c_cond
(paren
id|search_by_entry_key
(paren
id|new_dir-&gt;i_sb
comma
op_amp
id|old_de.de_entry_key
comma
op_amp
id|old_entry_path
comma
op_amp
id|old_de
)paren
op_ne
id|NAME_FOUND
)paren
id|BUG
(paren
)paren
suffix:semicolon
id|copy_item_head
c_func
(paren
op_amp
id|old_entry_ih
comma
id|get_ih
c_func
(paren
op_amp
id|old_entry_path
)paren
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|old_inode-&gt;i_sb
comma
id|old_de.de_bh
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// look for new name by reiserfs_find_entry
id|new_de.de_gen_number_bit_string
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|reiserfs_find_entry
(paren
id|new_dir
comma
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.len
comma
op_amp
id|new_entry_path
comma
op_amp
id|new_de
)paren
suffix:semicolon
singleline_comment|// reiserfs_add_entry should not return IO_ERROR, because it is called with essentially same parameters from
singleline_comment|// reiserfs_add_entry above, and we&squot;ll catch any i/o errors before we get here.
r_if
c_cond
(paren
id|retval
op_ne
id|NAME_FOUND_INVISIBLE
op_logical_and
id|retval
op_ne
id|NAME_FOUND
)paren
id|BUG
(paren
)paren
suffix:semicolon
id|copy_item_head
c_func
(paren
op_amp
id|new_entry_ih
comma
id|get_ih
c_func
(paren
op_amp
id|new_entry_path
)paren
)paren
suffix:semicolon
id|reiserfs_prepare_for_journal
c_func
(paren
id|old_inode-&gt;i_sb
comma
id|new_de.de_bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|search_by_entry_key
(paren
id|new_dir-&gt;i_sb
comma
op_amp
id|dot_dot_de.de_entry_key
comma
op_amp
id|dot_dot_entry_path
comma
op_amp
id|dot_dot_de
)paren
op_ne
id|NAME_FOUND
)paren
id|BUG
(paren
)paren
suffix:semicolon
id|copy_item_head
c_func
(paren
op_amp
id|dot_dot_ih
comma
id|get_ih
c_func
(paren
op_amp
id|dot_dot_entry_path
)paren
)paren
suffix:semicolon
singleline_comment|// node containing &quot;..&quot; gets into transaction
id|reiserfs_prepare_for_journal
c_func
(paren
id|old_inode-&gt;i_sb
comma
id|dot_dot_de.de_bh
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* we should check seals here, not do&n;                                   this stuff, yes? Then, having&n;                                   gathered everything into RAM we&n;                                   should lock the buffers, yes?  -Hans */
multiline_comment|/* probably.  our rename needs to hold more &n;&t;&t;&t;&t;** than one path at once.  The seals would &n;&t;&t;&t;&t;** have to be written to deal with multi-path &n;&t;&t;&t;&t;** issues -chris&n;&t;&t;&t;&t;*/
multiline_comment|/* sanity checking before doing the rename - avoid races many&n;&t;** of the above checks could have scheduled.  We have to be&n;&t;** sure our items haven&squot;t been shifted by another process.&n;&t;*/
r_if
c_cond
(paren
id|item_moved
c_func
(paren
op_amp
id|new_entry_ih
comma
op_amp
id|new_entry_path
)paren
op_logical_or
op_logical_neg
id|entry_points_to_object
c_func
(paren
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.len
comma
op_amp
id|new_de
comma
id|new_inode
)paren
op_logical_or
id|item_moved
c_func
(paren
op_amp
id|old_entry_ih
comma
op_amp
id|old_entry_path
)paren
op_logical_or
op_logical_neg
id|entry_points_to_object
(paren
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
comma
op_amp
id|old_de
comma
id|old_inode
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
(paren
id|old_inode-&gt;i_sb
comma
id|new_de.de_bh
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|old_inode-&gt;i_sb
comma
id|old_de.de_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_inode-&gt;i_mode
)paren
)paren
id|reiserfs_restore_prepared_buffer
(paren
id|old_inode-&gt;i_sb
comma
id|dot_dot_de.de_bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|item_moved
c_func
(paren
op_amp
id|dot_dot_ih
comma
op_amp
id|dot_dot_entry_path
)paren
op_logical_or
op_logical_neg
id|entry_points_to_object
(paren
l_string|&quot;..&quot;
comma
l_int|2
comma
op_amp
id|dot_dot_de
comma
id|old_dir
)paren
)paren
(brace
id|reiserfs_restore_prepared_buffer
(paren
id|old_inode-&gt;i_sb
comma
id|old_de.de_bh
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|old_inode-&gt;i_sb
comma
id|new_de.de_bh
)paren
suffix:semicolon
id|reiserfs_restore_prepared_buffer
(paren
id|old_inode-&gt;i_sb
comma
id|dot_dot_de.de_bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|RFALSE
c_func
(paren
id|S_ISDIR
c_func
(paren
id|old_inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|reiserfs_buffer_prepared
c_func
(paren
id|dot_dot_de.de_bh
)paren
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* ok, all the changes can be done in one fell swoop when we&n;       have claimed all the buffers needed.*/
id|mark_de_visible
(paren
id|new_de.de_deh
op_plus
id|new_de.de_entry_num
)paren
suffix:semicolon
id|set_ino_in_dir_entry
(paren
op_amp
id|new_de
comma
id|INODE_PKEY
(paren
id|old_inode
)paren
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
op_amp
id|th
comma
id|old_dir-&gt;i_sb
comma
id|new_de.de_bh
)paren
suffix:semicolon
id|mark_de_hidden
(paren
id|old_de.de_deh
op_plus
id|old_de.de_entry_num
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
op_amp
id|th
comma
id|old_dir-&gt;i_sb
comma
id|old_de.de_bh
)paren
suffix:semicolon
id|old_dir-&gt;i_ctime
op_assign
id|old_dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|new_dir-&gt;i_ctime
op_assign
id|new_dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|new_inode
)paren
(brace
singleline_comment|// adjust link number of the victim
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|new_inode-&gt;i_mode
)paren
)paren
(brace
id|new_inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|new_inode-&gt;i_nlink
op_decrement
suffix:semicolon
)brace
id|new_inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_inode-&gt;i_mode
)paren
)paren
(brace
singleline_comment|// adjust &quot;..&quot; of renamed directory 
id|set_ino_in_dir_entry
(paren
op_amp
id|dot_dot_de
comma
id|INODE_PKEY
(paren
id|new_dir
)paren
)paren
suffix:semicolon
id|journal_mark_dirty
(paren
op_amp
id|th
comma
id|new_dir-&gt;i_sb
comma
id|dot_dot_de.de_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_inode
)paren
multiline_comment|/* there (in new_dir) was no directory, so it got new link&n;&t;       (&quot;..&quot;  of renamed directory) */
id|INC_DIR_INODE_NLINK
c_func
(paren
id|new_dir
)paren
suffix:semicolon
multiline_comment|/* old directory lost one link - &quot;.. &quot; of renamed directory */
id|DEC_DIR_INODE_NLINK
c_func
(paren
id|old_dir
)paren
suffix:semicolon
)brace
singleline_comment|// looks like in 2.3.99pre3 brelse is atomic. so we can use pathrelse
id|pathrelse
(paren
op_amp
id|new_entry_path
)paren
suffix:semicolon
id|pathrelse
(paren
op_amp
id|dot_dot_entry_path
)paren
suffix:semicolon
singleline_comment|// FIXME: this reiserfs_cut_from_item&squot;s return value may screw up
singleline_comment|// anybody, but it will panic if will not be able to find the
singleline_comment|// entry. This needs one more clean up
r_if
c_cond
(paren
id|reiserfs_cut_from_item
(paren
op_amp
id|th
comma
op_amp
id|old_entry_path
comma
op_amp
(paren
id|old_de.de_entry_key
)paren
comma
id|old_dir
comma
l_int|NULL
comma
l_int|0
)paren
OL
l_int|0
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-7060: reiserfs_rename: couldn&squot;t not cut old name. Fsck later?&bslash;n&quot;
)paren
suffix:semicolon
id|old_dir-&gt;i_size
op_sub_assign
id|DEH_SIZE
op_plus
id|old_de.de_entrylen
suffix:semicolon
id|old_dir-&gt;i_blocks
op_assign
(paren
(paren
id|old_dir-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|old_dir
)paren
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|new_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_inode
)paren
(brace
r_if
c_cond
(paren
id|new_inode-&gt;i_nlink
op_eq
l_int|0
)paren
id|add_save_link
(paren
op_amp
id|th
comma
id|new_inode
comma
l_int|0
multiline_comment|/* not truncate */
)paren
suffix:semicolon
id|reiserfs_update_sd
(paren
op_amp
id|th
comma
id|new_inode
)paren
suffix:semicolon
)brace
id|pop_journal_writer
c_func
(paren
id|windex
)paren
suffix:semicolon
id|journal_end
c_func
(paren
op_amp
id|th
comma
id|old_dir-&gt;i_sb
comma
id|jbegin_count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * directories can handle most operations...&n; */
DECL|variable|reiserfs_dir_inode_operations
r_struct
id|inode_operations
id|reiserfs_dir_inode_operations
op_assign
(brace
singleline_comment|//&amp;reiserfs_dir_operations,&t;/* default_file_ops */
id|create
suffix:colon
id|reiserfs_create
comma
id|lookup
suffix:colon
id|reiserfs_lookup
comma
id|link
suffix:colon
id|reiserfs_link
comma
id|unlink
suffix:colon
id|reiserfs_unlink
comma
id|symlink
suffix:colon
id|reiserfs_symlink
comma
id|mkdir
suffix:colon
id|reiserfs_mkdir
comma
id|rmdir
suffix:colon
id|reiserfs_rmdir
comma
id|mknod
suffix:colon
id|reiserfs_mknod
comma
id|rename
suffix:colon
id|reiserfs_rename
comma
)brace
suffix:semicolon
eof
