multiline_comment|/*&n; * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/reiserfs_fs.h&gt;
multiline_comment|/* these are used in do_balance.c */
multiline_comment|/* leaf_move_items&n;   leaf_shift_left&n;   leaf_shift_right&n;   leaf_delete_items&n;   leaf_insert_into_buf&n;   leaf_paste_in_buffer&n;   leaf_cut_from_buffer&n;   leaf_paste_entries&n;   */
multiline_comment|/* copy copy_count entries from source directory item to dest buffer (creating new item if needed) */
DECL|function|leaf_copy_dir_entries
r_static
r_void
id|leaf_copy_dir_entries
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_head
op_star
id|source
comma
r_int
id|last_first
comma
r_int
id|item_num
comma
r_int
id|from
comma
r_int
id|copy_count
)paren
(brace
r_struct
id|buffer_head
op_star
id|dest
op_assign
id|dest_bi-&gt;bi_bh
suffix:semicolon
r_int
id|item_num_in_dest
suffix:semicolon
multiline_comment|/* either the number of target item,&n;&t;&t;&t;&t;&t;   or if we must create a new item,&n;&t;&t;&t;&t;&t;   the number of the item we will&n;&t;&t;&t;&t;&t;   create it next to */
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_struct
id|reiserfs_de_head
op_star
id|deh
suffix:semicolon
r_int
id|copy_records_len
suffix:semicolon
multiline_comment|/* length of all records in item to be copied */
r_char
op_star
id|records
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|source
comma
id|item_num
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
id|reiserfs_panic
c_func
(paren
l_int|0
comma
l_string|&quot;vs-10000: leaf_copy_dir_entries: item must be directory item&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* length of all record to be copied and first byte of the last of them */
id|deh
op_assign
id|B_I_DEH
(paren
id|source
comma
id|ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_count
)paren
(brace
id|copy_records_len
op_assign
(paren
id|from
ques
c_cond
id|deh
(braket
id|from
op_minus
l_int|1
)braket
dot
id|deh_location
suffix:colon
id|ih-&gt;ih_item_len
)paren
op_minus
id|deh
(braket
id|from
op_plus
id|copy_count
op_minus
l_int|1
)braket
dot
id|deh_location
suffix:semicolon
id|records
op_assign
id|source-&gt;b_data
op_plus
id|ih-&gt;ih_item_location
op_plus
id|deh
(braket
id|from
op_plus
id|copy_count
op_minus
l_int|1
)braket
dot
id|deh_location
suffix:semicolon
)brace
r_else
(brace
id|copy_records_len
op_assign
l_int|0
suffix:semicolon
id|records
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* when copy last to first, dest buffer can contain 0 items */
id|item_num_in_dest
op_assign
(paren
id|last_first
op_eq
id|LAST_TO_FIRST
)paren
ques
c_cond
(paren
(paren
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
)paren
suffix:colon
(paren
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if there are no items in dest or the first/last item in dest is not item of the same directory */
r_if
c_cond
(paren
(paren
id|item_num_in_dest
op_eq
op_minus
l_int|1
)paren
op_logical_or
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
op_logical_and
id|le_key_k_offset
(paren
id|ih_version
(paren
id|ih
)paren
comma
op_amp
(paren
id|ih-&gt;ih_key
)paren
)paren
op_eq
id|DOT_OFFSET
)paren
op_logical_or
(paren
id|last_first
op_eq
id|LAST_TO_FIRST
op_logical_and
id|comp_short_le_keys
multiline_comment|/*COMP_SHORT_KEYS*/
(paren
op_amp
id|ih-&gt;ih_key
comma
id|B_N_PKEY
(paren
id|dest
comma
id|item_num_in_dest
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* create new item in dest */
r_struct
id|item_head
id|new_ih
suffix:semicolon
multiline_comment|/* form item header */
id|memcpy
(paren
op_amp
id|new_ih.ih_key
comma
op_amp
id|ih-&gt;ih_key
comma
id|KEY_SIZE
)paren
suffix:semicolon
id|new_ih.ih_version
op_assign
id|cpu_to_le16
(paren
id|ITEM_VERSION_1
)paren
suffix:semicolon
multiline_comment|/* calculate item len */
id|new_ih.ih_item_len
op_assign
id|cpu_to_le16
(paren
id|DEH_SIZE
op_star
id|copy_count
op_plus
id|copy_records_len
)paren
suffix:semicolon
id|I_ENTRY_COUNT
c_func
(paren
op_amp
id|new_ih
)paren
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|last_first
op_eq
id|LAST_TO_FIRST
)paren
(brace
multiline_comment|/* form key by the following way */
r_if
c_cond
(paren
id|from
OL
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
)paren
(brace
id|set_le_ih_k_offset
(paren
op_amp
id|new_ih
comma
id|cpu_to_le32
(paren
id|le32_to_cpu
(paren
id|deh
(braket
id|from
)braket
dot
id|deh_offset
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*memcpy (&amp;new_ih.ih_key.k_offset, &amp;deh[from].deh_offset, SHORT_KEY_SIZE);*/
)brace
r_else
(brace
multiline_comment|/* no entries will be copied to this item in this function */
id|set_le_ih_k_offset
(paren
op_amp
id|new_ih
comma
id|cpu_to_le32
(paren
id|U32_MAX
)paren
)paren
suffix:semicolon
multiline_comment|/* this item is not yet valid, but we want I_IS_DIRECTORY_ITEM to return 1 for it, so we -1 */
)brace
id|set_le_key_k_type
(paren
id|ITEM_VERSION_1
comma
op_amp
(paren
id|new_ih.ih_key
)paren
comma
id|TYPE_DIRENTRY
)paren
suffix:semicolon
)brace
multiline_comment|/* insert item into dest buffer */
id|leaf_insert_into_buf
(paren
id|dest_bi
comma
(paren
id|last_first
op_eq
id|LAST_TO_FIRST
)paren
ques
c_cond
l_int|0
suffix:colon
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
comma
op_amp
id|new_ih
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* prepare space for entries */
id|leaf_paste_in_buffer
(paren
id|dest_bi
comma
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
ques
c_cond
(paren
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
op_minus
l_int|1
)paren
suffix:colon
l_int|0
comma
id|MAX_US_INT
comma
id|DEH_SIZE
op_star
id|copy_count
op_plus
id|copy_records_len
comma
id|records
comma
l_int|0
)paren
suffix:semicolon
)brace
id|item_num_in_dest
op_assign
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
ques
c_cond
(paren
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
op_minus
l_int|1
)paren
suffix:colon
l_int|0
suffix:semicolon
id|leaf_paste_entries
(paren
id|dest_bi-&gt;bi_bh
comma
id|item_num_in_dest
comma
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
ques
c_cond
id|I_ENTRY_COUNT
c_func
(paren
id|B_N_PITEM_HEAD
(paren
id|dest
comma
id|item_num_in_dest
)paren
)paren
suffix:colon
l_int|0
comma
id|copy_count
comma
id|deh
op_plus
id|from
comma
id|records
comma
id|DEH_SIZE
op_star
id|copy_count
op_plus
id|copy_records_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy the first (if last_first == FIRST_TO_LAST) or last (last_first == LAST_TO_FIRST) item or &n;   part of it or nothing (see the return 0 below) from SOURCE to the end &n;   (if last_first) or beginning (!last_first) of the DEST */
multiline_comment|/* returns 1 if anything was copied, else 0 */
DECL|function|leaf_copy_boundary_item
r_static
r_int
id|leaf_copy_boundary_item
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_head
op_star
id|src
comma
r_int
id|last_first
comma
r_int
id|bytes_or_entries
)paren
(brace
r_struct
id|buffer_head
op_star
id|dest
op_assign
id|dest_bi-&gt;bi_bh
suffix:semicolon
r_int
id|dest_nr_item
comma
id|src_nr_item
suffix:semicolon
multiline_comment|/* number of items in the source and destination buffers */
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_struct
id|item_head
op_star
id|dih
suffix:semicolon
id|dest_nr_item
op_assign
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
(brace
multiline_comment|/* if ( DEST is empty or first item of SOURCE and last item of DEST are the items of different objects&n;       or of different types ) then there is no need to treat this item differently from the other items&n;       that we copy, so we return */
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|src
comma
l_int|0
)paren
suffix:semicolon
id|dih
op_assign
id|B_N_PITEM_HEAD
(paren
id|dest
comma
id|dest_nr_item
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest_nr_item
op_logical_or
(paren
op_logical_neg
id|op_is_left_mergeable
(paren
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
id|src-&gt;b_size
)paren
)paren
)paren
multiline_comment|/* there is nothing to merge */
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|ih-&gt;ih_item_len
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10010: leaf_copy_boundary_item: item can not have empty dynamic length&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
(brace
r_if
c_cond
(paren
id|bytes_or_entries
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* copy all entries to dest */
id|bytes_or_entries
op_assign
id|le16_to_cpu
(paren
id|ih-&gt;u.ih_entry_count
)paren
suffix:semicolon
id|leaf_copy_dir_entries
(paren
id|dest_bi
comma
id|src
comma
id|FIRST_TO_LAST
comma
l_int|0
comma
l_int|0
comma
id|bytes_or_entries
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* copy part of the body of the first item of SOURCE to the end of the body of the last item of the DEST&n;       part defined by &squot;bytes_or_entries&squot;; if bytes_or_entries == -1 copy whole body; don&squot;t create new item header&n;       */
r_if
c_cond
(paren
id|bytes_or_entries
op_eq
op_minus
l_int|1
)paren
id|bytes_or_entries
op_assign
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_else
(brace
r_if
c_cond
(paren
id|bytes_or_entries
op_eq
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_logical_and
id|is_indirect_le_ih
c_func
(paren
id|ih
)paren
)paren
r_if
c_cond
(paren
id|get_ih_free_space
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10020: leaf_copy_boundary_item: &quot;
l_string|&quot;last unformatted node must be filled entirely (%h)&quot;
comma
id|ih
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* merge first item (or its part) of src buffer with the last&n;       item of dest buffer. Both are of the same file */
id|leaf_paste_in_buffer
(paren
id|dest_bi
comma
id|dest_nr_item
op_minus
l_int|1
comma
id|dih-&gt;ih_item_len
comma
id|bytes_or_entries
comma
id|B_I_PITEM
c_func
(paren
id|src
comma
id|ih
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|dih
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|get_ih_free_space
(paren
id|dih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10030: leaf_copy_boundary_item: &quot;
l_string|&quot;merge to left: last unformatted node of non-last indirect item %h must have zerto free space&quot;
comma
id|ih
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|bytes_or_entries
op_eq
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
)paren
id|set_ih_free_space
(paren
id|dih
comma
id|get_ih_free_space
(paren
id|ih
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* copy boundary item to right (last_first == LAST_TO_FIRST) */
multiline_comment|/* ( DEST is empty or last item of SOURCE and first item of DEST&n;     are the items of different object or of different types )&n;     */
id|src_nr_item
op_assign
id|B_NR_ITEMS
(paren
id|src
)paren
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|src
comma
id|src_nr_item
op_minus
l_int|1
)paren
suffix:semicolon
id|dih
op_assign
id|B_N_PITEM_HEAD
(paren
id|dest
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest_nr_item
op_logical_or
op_logical_neg
id|op_is_left_mergeable
(paren
op_amp
(paren
id|dih-&gt;ih_key
)paren
comma
id|src-&gt;b_size
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
(brace
r_if
c_cond
(paren
id|bytes_or_entries
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* bytes_or_entries = entries number in last item body of SOURCE */
id|bytes_or_entries
op_assign
id|le16_to_cpu
(paren
id|ih-&gt;u.ih_entry_count
)paren
suffix:semicolon
id|leaf_copy_dir_entries
(paren
id|dest_bi
comma
id|src
comma
id|LAST_TO_FIRST
comma
id|src_nr_item
op_minus
l_int|1
comma
id|le16_to_cpu
(paren
id|ih-&gt;u.ih_entry_count
)paren
op_minus
id|bytes_or_entries
comma
id|bytes_or_entries
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* copy part of the body of the last item of SOURCE to the begin of the body of the first item of the DEST;&n;     part defined by &squot;bytes_or_entries&squot;; if byte_or_entriess == -1 copy whole body; change first item key of the DEST;&n;     don&squot;t create new item header&n;     */
macro_line|#ifdef CONFIG_REISERFS_CHECK  
r_if
c_cond
(paren
id|is_indirect_le_ih
c_func
(paren
id|ih
)paren
op_logical_and
id|get_ih_free_space
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10040: leaf_copy_boundary_item: &quot;
l_string|&quot;merge to right: last unformatted node of non-last indirect item must be filled entirely (%h)&quot;
comma
id|ih
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|bytes_or_entries
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* bytes_or_entries = length of last item body of SOURCE */
id|bytes_or_entries
op_assign
id|ih-&gt;ih_item_len
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|le_ih_k_offset
(paren
id|dih
)paren
op_ne
id|le_ih_k_offset
(paren
id|ih
)paren
op_plus
id|op_bytes_number
(paren
id|ih
comma
id|src-&gt;b_size
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10050: leaf_copy_boundary_item: items %h and %h do not match&quot;
comma
id|ih
comma
id|dih
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* change first item key of the DEST */
id|set_le_ih_k_offset
(paren
id|dih
comma
id|le_ih_k_offset
(paren
id|ih
)paren
)paren
suffix:semicolon
multiline_comment|/* item becomes non-mergeable */
multiline_comment|/* or mergeable if left item was */
id|set_le_ih_k_type
(paren
id|dih
comma
id|le_ih_k_type
(paren
id|ih
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* merge to right only part of item */
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_le
id|bytes_or_entries
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10060: leaf_copy_boundary_item: no so much bytes %lu (needed %lu)&quot;
comma
id|ih-&gt;ih_item_len
comma
id|bytes_or_entries
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* change first item key of the DEST */
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|dih
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|le_ih_k_offset
(paren
id|dih
)paren
op_le
(paren
r_int
r_int
)paren
id|bytes_or_entries
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10070: leaf_copy_boundary_item: dih %h, bytes_or_entries(%d)&quot;
comma
id|dih
comma
id|bytes_or_entries
)paren
suffix:semicolon
macro_line|#endif
id|set_le_ih_k_offset
(paren
id|dih
comma
id|le_ih_k_offset
(paren
id|dih
)paren
op_minus
id|bytes_or_entries
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|le_ih_k_offset
(paren
id|dih
)paren
op_le
(paren
id|bytes_or_entries
op_div
id|UNFM_P_SIZE
)paren
op_star
id|dest-&gt;b_size
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10080: leaf_copy_boundary_item: dih %h, bytes_or_entries(%d)&quot;
comma
id|dih
comma
(paren
id|bytes_or_entries
op_div
id|UNFM_P_SIZE
)paren
op_star
id|dest-&gt;b_size
)paren
suffix:semicolon
macro_line|#endif
id|set_le_ih_k_offset
(paren
id|dih
comma
id|le_ih_k_offset
(paren
id|dih
)paren
op_minus
(paren
(paren
id|bytes_or_entries
op_div
id|UNFM_P_SIZE
)paren
op_star
id|dest-&gt;b_size
)paren
)paren
suffix:semicolon
)brace
)brace
id|leaf_paste_in_buffer
(paren
id|dest_bi
comma
l_int|0
comma
l_int|0
comma
id|bytes_or_entries
comma
id|B_I_PITEM
c_func
(paren
id|src
comma
id|ih
)paren
op_plus
id|ih-&gt;ih_item_len
op_minus
id|bytes_or_entries
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* copy cpy_mun items from buffer src to buffer dest&n; * last_first == FIRST_TO_LAST means, that we copy cpy_num  items beginning from first-th item in src to tail of dest&n; * last_first == LAST_TO_FIRST means, that we copy cpy_num  items beginning from first-th item in src to head of dest&n; */
DECL|function|leaf_copy_items_entirely
r_static
r_void
id|leaf_copy_items_entirely
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_head
op_star
id|src
comma
r_int
id|last_first
comma
r_int
id|first
comma
r_int
id|cpy_num
)paren
(brace
r_struct
id|buffer_head
op_star
id|dest
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_int
id|dest_before
suffix:semicolon
r_int
id|last_loc
comma
id|last_inserted_loc
comma
id|location
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|last_first
op_ne
id|LAST_TO_FIRST
op_logical_and
id|last_first
op_ne
id|FIRST_TO_LAST
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10090: leaf_copy_items_entirely: bad last_first parameter %d&quot;
comma
id|last_first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|B_NR_ITEMS
(paren
id|src
)paren
op_minus
id|first
OL
id|cpy_num
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10100: leaf_copy_items_entirely: too few items in source %d, required %d from %d&quot;
comma
id|B_NR_ITEMS
c_func
(paren
id|src
)paren
comma
id|cpy_num
comma
id|first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpy_num
OL
l_int|0
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10110: leaf_copy_items_entirely: can not copy negative amount of items&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest_bi
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10120: leaf_copy_items_entirely: can not copy negative amount of items&quot;
)paren
suffix:semicolon
macro_line|#endif
id|dest
op_assign
id|dest_bi-&gt;bi_bh
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10130: leaf_copy_items_entirely: can not copy negative amount of items&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cpy_num
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|nr
op_assign
id|le16_to_cpu
(paren
(paren
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|dest
)paren
)paren
op_member_access_from_pointer
id|blk_nr_item
)paren
suffix:semicolon
multiline_comment|/* we will insert items before 0-th or nr-th item in dest buffer. It depends of last_first parameter */
id|dest_before
op_assign
(paren
id|last_first
op_eq
id|LAST_TO_FIRST
)paren
ques
c_cond
l_int|0
suffix:colon
id|nr
suffix:semicolon
multiline_comment|/* location of head of first new item */
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|dest
comma
id|dest_before
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
OL
id|cpy_num
op_star
id|IH_SIZE
)paren
(brace
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10140: leaf_copy_items_entirely: &quot;
l_string|&quot;not enough free space for headers %d (needed %d)&quot;
comma
id|B_FREE_SPACE
(paren
id|dest
)paren
comma
id|cpy_num
op_star
id|IH_SIZE
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* prepare space for headers */
id|memmove
(paren
id|ih
op_plus
id|cpy_num
comma
id|ih
comma
(paren
id|nr
op_minus
id|dest_before
)paren
op_star
id|IH_SIZE
)paren
suffix:semicolon
multiline_comment|/* copy item headers */
id|memcpy
(paren
id|ih
comma
id|B_N_PITEM_HEAD
(paren
id|src
comma
id|first
)paren
comma
id|cpy_num
op_star
id|IH_SIZE
)paren
suffix:semicolon
id|blkh-&gt;blk_free_space
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
op_minus
id|IH_SIZE
op_star
id|cpy_num
)paren
suffix:semicolon
multiline_comment|/* location of unmovable item */
id|j
op_assign
id|location
op_assign
(paren
id|dest_before
op_eq
l_int|0
)paren
ques
c_cond
id|dest-&gt;b_size
suffix:colon
(paren
id|ih
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|ih_item_location
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|dest_before
suffix:semicolon
id|i
OL
id|nr
op_plus
id|cpy_num
suffix:semicolon
id|i
op_increment
)paren
id|ih
(braket
id|i
op_minus
id|dest_before
)braket
dot
id|ih_item_location
op_assign
(paren
id|location
op_sub_assign
id|ih
(braket
id|i
op_minus
id|dest_before
)braket
dot
id|ih_item_len
)paren
suffix:semicolon
multiline_comment|/* prepare space for items */
id|last_loc
op_assign
id|ih
(braket
id|nr
op_plus
id|cpy_num
op_minus
l_int|1
op_minus
id|dest_before
)braket
dot
id|ih_item_location
suffix:semicolon
id|last_inserted_loc
op_assign
id|ih
(braket
id|cpy_num
op_minus
l_int|1
)braket
dot
id|ih_item_location
suffix:semicolon
multiline_comment|/* check free space */
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
OL
id|j
op_minus
id|last_inserted_loc
)paren
(brace
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10150: leaf_copy_items_entirely: not enough free space for items %d (needed %d)&quot;
comma
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
comma
id|j
op_minus
id|last_inserted_loc
)paren
suffix:semicolon
)brace
macro_line|#endif
id|memmove
(paren
id|dest-&gt;b_data
op_plus
id|last_loc
comma
id|dest-&gt;b_data
op_plus
id|last_loc
op_plus
id|j
op_minus
id|last_inserted_loc
comma
id|last_inserted_loc
op_minus
id|last_loc
)paren
suffix:semicolon
multiline_comment|/* copy items */
id|memcpy
(paren
id|dest-&gt;b_data
op_plus
id|last_inserted_loc
comma
id|B_N_PITEM
c_func
(paren
id|src
comma
(paren
id|first
op_plus
id|cpy_num
op_minus
l_int|1
)paren
)paren
comma
id|j
op_minus
id|last_inserted_loc
)paren
suffix:semicolon
multiline_comment|/* sizes, item number */
id|blkh-&gt;blk_nr_item
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_nr_item
)paren
op_plus
id|cpy_num
)paren
suffix:semicolon
id|blkh-&gt;blk_free_space
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
op_minus
(paren
id|j
op_minus
id|last_inserted_loc
)paren
)paren
suffix:semicolon
id|do_balance_mark_leaf_dirty
(paren
id|dest_bi-&gt;tb
comma
id|dest
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest_bi-&gt;bi_parent
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|B_N_CHILD
(paren
id|dest_bi-&gt;bi_parent
comma
id|dest_bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_block_number
op_ne
id|dest-&gt;b_blocknr
)paren
(brace
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10160: leaf_copy_items_entirely: &quot;
l_string|&quot;block number in bh does not match to field in disk_child structure %lu and %lu&quot;
comma
id|dest-&gt;b_blocknr
comma
id|B_N_CHILD
(paren
id|dest_bi-&gt;bi_parent
comma
id|dest_bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_block_number
)paren
suffix:semicolon
)brace
macro_line|#endif
id|B_N_CHILD
(paren
id|dest_bi-&gt;bi_parent
comma
id|dest_bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_size
op_add_assign
id|j
op_minus
id|last_inserted_loc
op_plus
id|IH_SIZE
op_star
id|cpy_num
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|dest_bi-&gt;tb
comma
id|dest_bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This function splits the (liquid) item into two items (useful when&n;   shifting part of an item into another node.) */
DECL|function|leaf_item_bottle
r_static
r_void
id|leaf_item_bottle
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_head
op_star
id|src
comma
r_int
id|last_first
comma
r_int
id|item_num
comma
r_int
id|cpy_bytes
)paren
(brace
r_struct
id|buffer_head
op_star
id|dest
op_assign
id|dest_bi-&gt;bi_bh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK  
r_if
c_cond
(paren
id|cpy_bytes
op_eq
op_minus
l_int|1
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10170: leaf_item_bottle: bytes == - 1 means: do not split item&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
(brace
multiline_comment|/* if ( if item in position item_num in buffer SOURCE is directory item ) */
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|src
comma
id|item_num
)paren
)paren
)paren
id|leaf_copy_dir_entries
(paren
id|dest_bi
comma
id|src
comma
id|FIRST_TO_LAST
comma
id|item_num
comma
l_int|0
comma
id|cpy_bytes
)paren
suffix:semicolon
r_else
(brace
r_struct
id|item_head
id|n_ih
suffix:semicolon
multiline_comment|/* copy part of the body of the item number &squot;item_num&squot; of SOURCE to the end of the DEST &n;&t;       part defined by &squot;cpy_bytes&squot;; create new item header; change old item_header (????);&n;&t;       n_ih = new item_header;&n;&t;    */
id|memcpy
(paren
op_amp
id|n_ih
comma
id|ih
comma
id|IH_SIZE
)paren
suffix:semicolon
id|n_ih.ih_item_len
op_assign
id|cpu_to_le16
(paren
id|cpy_bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|ih
)paren
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|cpy_bytes
op_eq
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_logical_and
id|get_ih_free_space
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10180: leaf_item_bottle: &quot;
l_string|&quot;when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)&quot;
comma
id|get_ih_free_space
(paren
id|ih
)paren
)paren
suffix:semicolon
macro_line|#endif
id|set_ih_free_space
(paren
op_amp
id|n_ih
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|op_is_left_mergeable
(paren
op_amp
(paren
id|ih-&gt;ih_key
)paren
comma
id|src-&gt;b_size
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10190: leaf_item_bottle: bad mergeability of item %h&quot;
comma
id|ih
)paren
suffix:semicolon
macro_line|#endif
id|n_ih.ih_version
op_assign
id|ih-&gt;ih_version
suffix:semicolon
suffix:semicolon
id|leaf_insert_into_buf
(paren
id|dest_bi
comma
id|B_NR_ITEMS
c_func
(paren
id|dest
)paren
comma
op_amp
id|n_ih
comma
id|B_N_PITEM
(paren
id|src
comma
id|item_num
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*  if ( if item in position item_num in buffer SOURCE is directory item ) */
r_if
c_cond
(paren
id|is_direntry_le_ih
c_func
(paren
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|src
comma
id|item_num
)paren
)paren
)paren
id|leaf_copy_dir_entries
(paren
id|dest_bi
comma
id|src
comma
id|LAST_TO_FIRST
comma
id|item_num
comma
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
op_minus
id|cpy_bytes
comma
id|cpy_bytes
)paren
suffix:semicolon
r_else
(brace
r_struct
id|item_head
id|n_ih
suffix:semicolon
multiline_comment|/* copy part of the body of the item number &squot;item_num&squot; of SOURCE to the begin of the DEST &n;&t;       part defined by &squot;cpy_bytes&squot;; create new item header;&n;&t;       n_ih = new item_header;&n;&t;    */
id|memcpy
(paren
op_amp
id|n_ih
comma
id|ih
comma
id|SHORT_KEY_SIZE
)paren
suffix:semicolon
id|n_ih.ih_version
op_assign
id|cpu_to_le16
(paren
id|ih_version
(paren
id|ih
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|ih
)paren
)paren
(brace
id|set_le_ih_k_offset
(paren
op_amp
id|n_ih
comma
id|le_ih_k_offset
(paren
id|ih
)paren
op_plus
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_minus
id|cpy_bytes
)paren
suffix:semicolon
id|set_le_ih_k_type
(paren
op_amp
id|n_ih
comma
id|TYPE_DIRECT
)paren
suffix:semicolon
id|set_ih_free_space
(paren
op_amp
id|n_ih
comma
id|MAX_US_INT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* indirect item */
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|cpy_bytes
op_logical_and
id|get_ih_free_space
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10200: leaf_item_bottle: ih-&gt;ih_free_space must be 0 when indirect item will be appended&quot;
)paren
suffix:semicolon
macro_line|#endif
id|set_le_ih_k_offset
(paren
op_amp
id|n_ih
comma
id|le_ih_k_offset
(paren
id|ih
)paren
op_plus
(paren
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_minus
id|cpy_bytes
)paren
op_div
id|UNFM_P_SIZE
op_star
id|dest-&gt;b_size
)paren
suffix:semicolon
id|set_le_ih_k_type
(paren
op_amp
id|n_ih
comma
id|TYPE_INDIRECT
)paren
suffix:semicolon
id|set_ih_free_space
(paren
op_amp
id|n_ih
comma
id|get_ih_free_space
(paren
id|ih
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* set item length */
id|n_ih.ih_item_len
op_assign
id|cpu_to_le16
(paren
id|cpy_bytes
)paren
suffix:semicolon
id|n_ih.ih_version
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|ih-&gt;ih_version
)paren
)paren
suffix:semicolon
id|leaf_insert_into_buf
(paren
id|dest_bi
comma
l_int|0
comma
op_amp
id|n_ih
comma
id|B_N_PITEM
c_func
(paren
id|src
comma
id|item_num
)paren
op_plus
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_minus
id|cpy_bytes
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If cpy_bytes equals minus one than copy cpy_num whole items from SOURCE to DEST.&n;   If cpy_bytes not equal to minus one than copy cpy_num-1 whole items from SOURCE to DEST.&n;   From last item copy cpy_num bytes for regular item and cpy_num directory entries for&n;   directory item. */
DECL|function|leaf_copy_items
r_static
r_int
id|leaf_copy_items
(paren
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_head
op_star
id|src
comma
r_int
id|last_first
comma
r_int
id|cpy_num
comma
r_int
id|cpy_bytes
)paren
(brace
r_struct
id|buffer_head
op_star
id|dest
suffix:semicolon
r_int
id|pos
comma
id|i
comma
id|src_nr_item
comma
id|bytes
suffix:semicolon
id|dest
op_assign
id|dest_bi-&gt;bi_bh
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|dest
op_logical_or
op_logical_neg
id|src
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10210: leaf_copy_items: !dest || !src&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_first
op_ne
id|FIRST_TO_LAST
op_logical_and
id|last_first
op_ne
id|LAST_TO_FIRST
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10220: leaf_copy_items: last_first != FIRST_TO_LAST &amp;&amp; last_first != LAST_TO_FIRST&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|B_NR_ITEMS
c_func
(paren
id|src
)paren
OL
id|cpy_num
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10230: leaf_copy_items: No enough items: %d, required %d&quot;
comma
id|B_NR_ITEMS
c_func
(paren
id|src
)paren
comma
id|cpy_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpy_num
OL
l_int|0
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10240: leaf_copy_items: cpy_num &lt; 0 (%d)&quot;
comma
id|cpy_num
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|cpy_num
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
(brace
multiline_comment|/* copy items to left */
id|pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cpy_num
op_eq
l_int|1
)paren
id|bytes
op_assign
id|cpy_bytes
suffix:semicolon
r_else
id|bytes
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* copy the first item or it part or nothing to the end of the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,0,bytes)) */
id|i
op_assign
id|leaf_copy_boundary_item
(paren
id|dest_bi
comma
id|src
comma
id|FIRST_TO_LAST
comma
id|bytes
)paren
suffix:semicolon
id|cpy_num
op_sub_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cpy_num
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
id|pos
op_add_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cpy_bytes
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* copy first cpy_num items starting from position &squot;pos&squot; of SOURCE to end of DEST */
id|leaf_copy_items_entirely
(paren
id|dest_bi
comma
id|src
comma
id|FIRST_TO_LAST
comma
id|pos
comma
id|cpy_num
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* copy first cpy_num-1 items starting from position &squot;pos-1&squot; of the SOURCE to the end of the DEST */
id|leaf_copy_items_entirely
(paren
id|dest_bi
comma
id|src
comma
id|FIRST_TO_LAST
comma
id|pos
comma
id|cpy_num
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* copy part of the item which number is cpy_num+pos-1 to the end of the DEST */
id|leaf_item_bottle
(paren
id|dest_bi
comma
id|src
comma
id|FIRST_TO_LAST
comma
id|cpy_num
op_plus
id|pos
op_minus
l_int|1
comma
id|cpy_bytes
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* copy items to right */
id|src_nr_item
op_assign
id|B_NR_ITEMS
(paren
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpy_num
op_eq
l_int|1
)paren
id|bytes
op_assign
id|cpy_bytes
suffix:semicolon
r_else
id|bytes
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* copy the last item or it part or nothing to the begin of the DEST (i = leaf_copy_boundary_item(DEST,SOURCE,1,bytes)); */
id|i
op_assign
id|leaf_copy_boundary_item
(paren
id|dest_bi
comma
id|src
comma
id|LAST_TO_FIRST
comma
id|bytes
)paren
suffix:semicolon
id|cpy_num
op_sub_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cpy_num
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
id|pos
op_assign
id|src_nr_item
op_minus
id|cpy_num
op_minus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cpy_bytes
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* starting from position &squot;pos&squot; copy last cpy_num items of SOURCE to begin of DEST */
id|leaf_copy_items_entirely
(paren
id|dest_bi
comma
id|src
comma
id|LAST_TO_FIRST
comma
id|pos
comma
id|cpy_num
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* copy last cpy_num-1 items starting from position &squot;pos+1&squot; of the SOURCE to the begin of the DEST; */
id|leaf_copy_items_entirely
(paren
id|dest_bi
comma
id|src
comma
id|LAST_TO_FIRST
comma
id|pos
op_plus
l_int|1
comma
id|cpy_num
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* copy part of the item which number is pos to the begin of the DEST */
id|leaf_item_bottle
(paren
id|dest_bi
comma
id|src
comma
id|LAST_TO_FIRST
comma
id|pos
comma
id|cpy_bytes
)paren
suffix:semicolon
)brace
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* there are types of coping: from S[0] to L[0], from S[0] to R[0],&n;   from R[0] to L[0]. for each of these we have to define parent and&n;   positions of destination and source buffers */
DECL|function|leaf_define_dest_src_infos
r_static
r_void
id|leaf_define_dest_src_infos
(paren
r_int
id|shift_mode
comma
r_struct
id|tree_balance
op_star
id|tb
comma
r_struct
id|buffer_info
op_star
id|dest_bi
comma
r_struct
id|buffer_info
op_star
id|src_bi
comma
r_int
op_star
id|first_last
comma
r_struct
id|buffer_head
op_star
id|Snew
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
id|memset
(paren
id|dest_bi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_info
)paren
)paren
suffix:semicolon
id|memset
(paren
id|src_bi
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_info
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* define dest, src, dest parent, dest position */
r_switch
c_cond
(paren
id|shift_mode
)paren
(brace
r_case
id|LEAF_FROM_S_TO_L
suffix:colon
multiline_comment|/* it is used in leaf_shift_left */
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|PATH_H_B_ITEM_ORDER
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* src-&gt;b_item_order */
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
op_star
id|first_last
op_assign
id|FIRST_TO_LAST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LEAF_FROM_S_TO_R
suffix:colon
multiline_comment|/* it is used in leaf_shift_right */
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|PATH_H_B_ITEM_ORDER
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
op_star
id|first_last
op_assign
id|LAST_TO_FIRST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LEAF_FROM_R_TO_L
suffix:colon
multiline_comment|/* it is used in balance_leaf_when_delete */
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
op_star
id|first_last
op_assign
id|FIRST_TO_LAST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LEAF_FROM_L_TO_R
suffix:colon
multiline_comment|/* it is used in balance_leaf_when_delete */
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|tb-&gt;L
(braket
l_int|0
)braket
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|tb-&gt;FL
(braket
l_int|0
)braket
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|get_left_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|tb-&gt;R
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
id|tb-&gt;FR
(braket
l_int|0
)braket
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
id|get_right_neighbor_position
(paren
id|tb
comma
l_int|0
)paren
suffix:semicolon
op_star
id|first_last
op_assign
id|LAST_TO_FIRST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LEAF_FROM_S_TO_SNEW
suffix:colon
id|src_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|src_bi-&gt;bi_bh
op_assign
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
id|src_bi-&gt;bi_parent
op_assign
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|src_bi-&gt;bi_position
op_assign
id|PATH_H_B_ITEM_ORDER
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
suffix:semicolon
id|dest_bi-&gt;tb
op_assign
id|tb
suffix:semicolon
id|dest_bi-&gt;bi_bh
op_assign
id|Snew
suffix:semicolon
id|dest_bi-&gt;bi_parent
op_assign
l_int|0
suffix:semicolon
id|dest_bi-&gt;bi_position
op_assign
l_int|0
suffix:semicolon
op_star
id|first_last
op_assign
id|LAST_TO_FIRST
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10250: leaf_define_dest_src_infos: shift type is unknown (%d)&quot;
comma
id|shift_mode
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|src_bi-&gt;bi_bh
op_eq
l_int|0
op_logical_or
id|dest_bi-&gt;bi_bh
op_eq
l_int|0
)paren
(brace
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10260: leaf_define_dest_src_etc: mode==%d, source (%p) or dest (%p) buffer is initialized incorrectly&quot;
comma
id|shift_mode
comma
id|src_bi-&gt;bi_bh
comma
id|dest_bi-&gt;bi_bh
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* copy mov_num items and mov_bytes of the (mov_num-1)th item to&n;   neighbor. Delete them from source */
DECL|function|leaf_move_items
r_int
id|leaf_move_items
(paren
r_int
id|shift_mode
comma
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|mov_num
comma
r_int
id|mov_bytes
comma
r_struct
id|buffer_head
op_star
id|Snew
)paren
(brace
r_int
id|ret_value
suffix:semicolon
r_struct
id|buffer_info
id|dest_bi
comma
id|src_bi
suffix:semicolon
r_int
id|first_last
suffix:semicolon
id|leaf_define_dest_src_infos
(paren
id|shift_mode
comma
id|tb
comma
op_amp
id|dest_bi
comma
op_amp
id|src_bi
comma
op_amp
id|first_last
comma
id|Snew
)paren
suffix:semicolon
id|ret_value
op_assign
id|leaf_copy_items
(paren
op_amp
id|dest_bi
comma
id|src_bi.bi_bh
comma
id|first_last
comma
id|mov_num
comma
id|mov_bytes
)paren
suffix:semicolon
id|leaf_delete_items
(paren
op_amp
id|src_bi
comma
id|first_last
comma
(paren
id|first_last
op_eq
id|FIRST_TO_LAST
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|B_NR_ITEMS
c_func
(paren
id|src_bi.bi_bh
)paren
op_minus
id|mov_num
)paren
comma
id|mov_num
comma
id|mov_bytes
)paren
suffix:semicolon
r_return
id|ret_value
suffix:semicolon
)brace
multiline_comment|/* Shift shift_num items (and shift_bytes of last shifted item if shift_bytes != -1)&n;   from S[0] to L[0] and replace the delimiting key */
DECL|function|leaf_shift_left
r_int
id|leaf_shift_left
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|shift_num
comma
r_int
id|shift_bytes
)paren
(brace
r_struct
id|buffer_head
op_star
id|S0
op_assign
id|PATH_PLAST_BUFFER
(paren
id|tb-&gt;tb_path
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* move shift_num (and shift_bytes bytes) items from S[0] to left neighbor L[0] */
id|i
op_assign
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_L
comma
id|tb
comma
id|shift_num
comma
id|shift_bytes
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shift_num
)paren
(brace
r_if
c_cond
(paren
id|B_NR_ITEMS
(paren
id|S0
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* number of items in S[0] == 0 */
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|shift_bytes
op_ne
op_minus
l_int|1
)paren
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-10270: leaf_shift_left: S0 is empty now, but shift_bytes != -1 (%d)&quot;
comma
id|shift_bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;tb_mode
op_eq
id|M_PASTE
op_logical_or
id|tb-&gt;tb_mode
op_eq
id|M_INSERT
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;vs-10275&quot;
)paren
suffix:semicolon
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-10275: leaf_shift_left: balance condition corrupted (%c)&quot;
comma
id|tb-&gt;tb_mode
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|PATH_H_POSITION
(paren
id|tb-&gt;tb_path
comma
l_int|1
)paren
op_eq
l_int|0
)paren
id|replace_key
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|PATH_H_PPARENT
(paren
id|tb-&gt;tb_path
comma
l_int|0
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 0      
multiline_comment|/* change right_delimiting_key field in L0&squot;s block header */
id|copy_key
(paren
id|B_PRIGHT_DELIM_KEY
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
comma
id|B_PRIGHT_DELIM_KEY
(paren
id|S0
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* replace lkey in CFL[0] by 0-th key from S[0]; */
id|replace_key
(paren
id|tb
comma
id|tb-&gt;CFL
(braket
l_int|0
)braket
comma
id|tb-&gt;lkey
(braket
l_int|0
)braket
comma
id|S0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* change right_delimiting_key field in L0&squot;s block header */
id|copy_key
(paren
id|B_PRIGHT_DELIM_KEY
c_func
(paren
id|tb-&gt;L
(braket
l_int|0
)braket
)paren
comma
id|B_N_PKEY
(paren
id|S0
comma
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|shift_bytes
op_ne
op_minus
l_int|1
op_logical_and
op_logical_neg
(paren
id|is_direntry_le_ih
(paren
id|B_N_PITEM_HEAD
(paren
id|S0
comma
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
id|I_ENTRY_COUNT
(paren
id|B_N_PITEM_HEAD
(paren
id|S0
comma
l_int|0
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|op_is_left_mergeable
(paren
id|B_N_PKEY
(paren
id|S0
comma
l_int|0
)paren
comma
id|S0-&gt;b_size
)paren
)paren
(brace
id|reiserfs_panic
(paren
id|tb-&gt;tb_sb
comma
l_string|&quot;vs-10280: leaf_shift_left: item must be mergeable&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* CLEANING STOPPED HERE */
multiline_comment|/* Shift shift_num (shift_bytes) items from S[0] to the right neighbor, and replace the delimiting key */
DECL|function|leaf_shift_right
r_int
id|leaf_shift_right
c_func
(paren
r_struct
id|tree_balance
op_star
id|tb
comma
r_int
id|shift_num
comma
r_int
id|shift_bytes
)paren
(brace
singleline_comment|//  struct buffer_head * S0 = PATH_PLAST_BUFFER (tb-&gt;tb_path);
r_int
id|ret_value
suffix:semicolon
multiline_comment|/* move shift_num (and shift_bytes) items from S[0] to right neighbor R[0] */
id|ret_value
op_assign
id|leaf_move_items
(paren
id|LEAF_FROM_S_TO_R
comma
id|tb
comma
id|shift_num
comma
id|shift_bytes
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* replace rkey in CFR[0] by the 0-th key from R[0] */
r_if
c_cond
(paren
id|shift_num
)paren
(brace
id|replace_key
(paren
id|tb
comma
id|tb-&gt;CFR
(braket
l_int|0
)braket
comma
id|tb-&gt;rkey
(braket
l_int|0
)braket
comma
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* change right_delimiting_key field in S0&squot;s block header */
id|copy_key
(paren
id|B_PRIGHT_DELIM_KEY
c_func
(paren
id|S0
)paren
comma
id|B_N_PKEY
(paren
id|tb-&gt;R
(braket
l_int|0
)braket
comma
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|ret_value
suffix:semicolon
)brace
r_static
r_void
id|leaf_delete_items_entirely
(paren
r_struct
id|buffer_info
op_star
id|bi
comma
r_int
id|first
comma
r_int
id|del_num
)paren
suffix:semicolon
multiline_comment|/*  If del_bytes == -1, starting from position &squot;first&squot; delete del_num items in whole in buffer CUR.&n;    If not. &n;    If last_first == 0. Starting from position &squot;first&squot; delete del_num-1 items in whole. Delete part of body of&n;    the first item. Part defined by del_bytes. Don&squot;t delete first item header&n;    If last_first == 1. Starting from position &squot;first+1&squot; delete del_num-1 items in whole. Delete part of body of&n;    the last item . Part defined by del_bytes. Don&squot;t delete last item header.&n;*/
DECL|function|leaf_delete_items
r_void
id|leaf_delete_items
(paren
r_struct
id|buffer_info
op_star
id|cur_bi
comma
r_int
id|last_first
comma
r_int
id|first
comma
r_int
id|del_num
comma
r_int
id|del_bytes
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|item_amount
op_assign
id|B_NR_ITEMS
(paren
id|bh
op_assign
id|cur_bi-&gt;bi_bh
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_delete_items: 10155: bh is not defined&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_num
OL
l_int|0
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_delete_items: 10160: del_num can not be &lt; 0. del_num==%d&quot;
comma
id|del_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first
template_param
id|item_amount
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_delete_items: 10165: invalid number of first item to be deleted (%d) or &quot;
l_string|&quot;no so much items (%d) to delete (only %d)&quot;
comma
id|first
comma
id|first
op_plus
id|del_num
comma
id|item_amount
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|del_num
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|first
op_eq
l_int|0
op_logical_and
id|del_num
op_eq
id|item_amount
op_logical_and
id|del_bytes
op_eq
op_minus
l_int|1
)paren
(brace
id|make_empty_node
(paren
id|cur_bi
)paren
suffix:semicolon
id|do_balance_mark_leaf_dirty
(paren
id|cur_bi-&gt;tb
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|del_bytes
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* delete del_num items beginning from item in position first */
id|leaf_delete_items_entirely
(paren
id|cur_bi
comma
id|first
comma
id|del_num
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|last_first
op_eq
id|FIRST_TO_LAST
)paren
(brace
multiline_comment|/* delete del_num-1 items beginning from item in position first  */
id|leaf_delete_items_entirely
(paren
id|cur_bi
comma
id|first
comma
id|del_num
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* delete the part of the first item of the bh&n;&t;       do not delete item header&n;&t;    */
id|leaf_cut_from_buffer
(paren
id|cur_bi
comma
l_int|0
comma
l_int|0
comma
id|del_bytes
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* delete del_num-1 items beginning from item in position first+1  */
id|leaf_delete_items_entirely
(paren
id|cur_bi
comma
id|first
op_plus
l_int|1
comma
id|del_num
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|bh
comma
id|B_NR_ITEMS
c_func
(paren
id|bh
)paren
op_minus
l_int|1
)paren
)paren
)paren
multiline_comment|/* the last item is directory  */
multiline_comment|/* len = numbers of directory entries in this item */
id|len
op_assign
id|le16_to_cpu
(paren
id|ih-&gt;u.ih_entry_count
)paren
suffix:semicolon
r_else
multiline_comment|/* len = body len of item */
id|len
op_assign
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
suffix:semicolon
multiline_comment|/* delete the part of the last item of the bh &n;&t;       do not delete item header&n;&t;    */
id|leaf_cut_from_buffer
(paren
id|cur_bi
comma
id|B_NR_ITEMS
c_func
(paren
id|bh
)paren
op_minus
l_int|1
comma
id|len
op_minus
id|del_bytes
comma
id|del_bytes
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* insert item into the leaf node in position before */
DECL|function|leaf_insert_into_buf
r_void
id|leaf_insert_into_buf
(paren
r_struct
id|buffer_info
op_star
id|bi
comma
r_int
id|before
comma
r_struct
id|item_head
op_star
id|inserted_item_ih
comma
r_const
r_char
op_star
id|inserted_item_body
comma
r_int
id|zeros_number
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|bi-&gt;bi_bh
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|last_loc
comma
id|unmoved_loc
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
id|nr
op_assign
id|le16_to_cpu
(paren
(paren
id|blkh
op_assign
id|B_BLK_HEAD
(paren
id|bh
)paren
)paren
op_member_access_from_pointer
id|blk_nr_item
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
multiline_comment|/* check free space */
r_if
c_cond
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
OL
id|le16_to_cpu
(paren
id|inserted_item_ih-&gt;ih_item_len
)paren
op_plus
id|IH_SIZE
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_insert_into_buf: 10170: &quot;
l_string|&quot;not enough free space in block %z, new item %h&quot;
comma
id|bh
comma
id|inserted_item_ih
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zeros_number
OG
id|inserted_item_ih-&gt;ih_item_len
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10172: leaf_insert_into_buf: &quot;
l_string|&quot;zero number == %d, item length == %d&quot;
comma
id|zeros_number
comma
id|inserted_item_ih-&gt;ih_item_len
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_REISERFS_CHECK */
multiline_comment|/* get item new item must be inserted before */
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|bh
comma
id|before
)paren
suffix:semicolon
multiline_comment|/* prepare space for the body of new item */
id|last_loc
op_assign
id|nr
ques
c_cond
id|ih
(braket
id|nr
op_minus
id|before
op_minus
l_int|1
)braket
dot
id|ih_item_location
suffix:colon
id|bh-&gt;b_size
suffix:semicolon
id|unmoved_loc
op_assign
id|before
ques
c_cond
(paren
id|ih
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|ih_item_location
suffix:colon
id|bh-&gt;b_size
suffix:semicolon
id|memmove
(paren
id|bh-&gt;b_data
op_plus
id|last_loc
op_minus
id|inserted_item_ih-&gt;ih_item_len
comma
id|bh-&gt;b_data
op_plus
id|last_loc
comma
id|unmoved_loc
op_minus
id|last_loc
)paren
suffix:semicolon
id|to
op_assign
id|bh-&gt;b_data
op_plus
id|unmoved_loc
op_minus
id|inserted_item_ih-&gt;ih_item_len
suffix:semicolon
id|memset
(paren
id|to
comma
l_int|0
comma
id|zeros_number
)paren
suffix:semicolon
id|to
op_add_assign
id|zeros_number
suffix:semicolon
multiline_comment|/* copy body to prepared space */
r_if
c_cond
(paren
id|inserted_item_body
)paren
id|memmove
(paren
id|to
comma
id|inserted_item_body
comma
id|inserted_item_ih-&gt;ih_item_len
op_minus
id|zeros_number
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
id|to
comma
l_char|&squot;&bslash;0&squot;
comma
id|inserted_item_ih-&gt;ih_item_len
op_minus
id|zeros_number
)paren
suffix:semicolon
multiline_comment|/* insert item header */
id|memmove
(paren
id|ih
op_plus
l_int|1
comma
id|ih
comma
id|IH_SIZE
op_star
(paren
id|nr
op_minus
id|before
)paren
)paren
suffix:semicolon
id|memmove
(paren
id|ih
comma
id|inserted_item_ih
comma
id|IH_SIZE
)paren
suffix:semicolon
multiline_comment|/* change locations */
r_for
c_loop
(paren
id|i
op_assign
id|before
suffix:semicolon
id|i
OL
id|nr
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|ih
(braket
id|i
op_minus
id|before
)braket
dot
id|ih_item_location
op_assign
(paren
id|unmoved_loc
op_sub_assign
id|ih
(braket
id|i
op_minus
id|before
)braket
dot
id|ih_item_len
)paren
suffix:semicolon
multiline_comment|/* sizes, free space, item number */
id|blkh-&gt;blk_nr_item
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_nr_item
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|blkh-&gt;blk_free_space
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
op_minus
(paren
id|IH_SIZE
op_plus
id|inserted_item_ih-&gt;ih_item_len
)paren
)paren
suffix:semicolon
id|do_balance_mark_leaf_dirty
(paren
id|bi-&gt;tb
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bi-&gt;bi_parent
)paren
(brace
id|B_N_CHILD
(paren
id|bi-&gt;bi_parent
comma
id|bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_size
op_add_assign
(paren
id|IH_SIZE
op_plus
id|inserted_item_ih-&gt;ih_item_len
)paren
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|bi-&gt;tb
comma
id|bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* paste paste_size bytes to affected_item_num-th item. &n;   When item is a directory, this only prepare space for new entries */
DECL|function|leaf_paste_in_buffer
r_void
id|leaf_paste_in_buffer
(paren
r_struct
id|buffer_info
op_star
id|bi
comma
r_int
id|affected_item_num
comma
r_int
id|pos_in_item
comma
r_int
id|paste_size
comma
r_const
r_char
op_star
id|body
comma
r_int
id|zeros_number
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|bi-&gt;bi_bh
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|last_loc
comma
id|unmoved_loc
suffix:semicolon
id|nr
op_assign
id|le16_to_cpu
(paren
(paren
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|bh
)paren
)paren
op_member_access_from_pointer
id|blk_nr_item
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
multiline_comment|/* check free space */
r_if
c_cond
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
OL
id|paste_size
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_paste_in_buffer: 10175: not enough free space: needed %d, available %d&quot;
comma
id|paste_size
comma
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zeros_number
OG
id|paste_size
)paren
(brace
id|print_cur_tb
(paren
l_string|&quot;10177&quot;
)paren
suffix:semicolon
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;vs-10177: leaf_paste_in_buffer: zero number == %d, paste_size == %d&quot;
comma
id|zeros_number
comma
id|paste_size
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_REISERFS_CHECK */
multiline_comment|/* item to be appended */
id|ih
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|bh
comma
id|affected_item_num
)paren
suffix:semicolon
id|last_loc
op_assign
id|ih
(braket
id|nr
op_minus
id|affected_item_num
op_minus
l_int|1
)braket
dot
id|ih_item_location
suffix:semicolon
id|unmoved_loc
op_assign
id|affected_item_num
ques
c_cond
(paren
id|ih
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|ih_item_location
suffix:colon
id|bh-&gt;b_size
suffix:semicolon
multiline_comment|/* prepare space */
id|memmove
(paren
id|bh-&gt;b_data
op_plus
id|last_loc
op_minus
id|paste_size
comma
id|bh-&gt;b_data
op_plus
id|last_loc
comma
id|unmoved_loc
op_minus
id|last_loc
)paren
suffix:semicolon
multiline_comment|/* change locations */
r_for
c_loop
(paren
id|i
op_assign
id|affected_item_num
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|ih
(braket
id|i
op_minus
id|affected_item_num
)braket
dot
id|ih_item_location
op_sub_assign
id|paste_size
suffix:semicolon
r_if
c_cond
(paren
id|body
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pos_in_item
)paren
(brace
multiline_comment|/* shift data to right */
id|memmove
(paren
id|bh-&gt;b_data
op_plus
id|ih-&gt;ih_item_location
op_plus
id|paste_size
comma
id|bh-&gt;b_data
op_plus
id|ih-&gt;ih_item_location
comma
id|ih-&gt;ih_item_len
)paren
suffix:semicolon
multiline_comment|/* paste data in the head of item */
id|memset
(paren
id|bh-&gt;b_data
op_plus
id|ih-&gt;ih_item_location
comma
l_int|0
comma
id|zeros_number
)paren
suffix:semicolon
id|memcpy
(paren
id|bh-&gt;b_data
op_plus
id|ih-&gt;ih_item_location
op_plus
id|zeros_number
comma
id|body
comma
id|paste_size
op_minus
id|zeros_number
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
(paren
id|bh-&gt;b_data
op_plus
id|unmoved_loc
op_minus
id|paste_size
comma
l_int|0
comma
id|zeros_number
)paren
suffix:semicolon
id|memcpy
(paren
id|bh-&gt;b_data
op_plus
id|unmoved_loc
op_minus
id|paste_size
op_plus
id|zeros_number
comma
id|body
comma
id|paste_size
op_minus
id|zeros_number
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
id|memset
c_func
(paren
id|bh-&gt;b_data
op_plus
id|unmoved_loc
op_minus
id|paste_size
comma
l_char|&squot;&bslash;0&squot;
comma
id|paste_size
)paren
suffix:semicolon
id|ih-&gt;ih_item_len
op_add_assign
id|paste_size
suffix:semicolon
multiline_comment|/* change free space */
id|blkh-&gt;blk_free_space
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
op_minus
id|paste_size
)paren
suffix:semicolon
id|do_balance_mark_leaf_dirty
(paren
id|bi-&gt;tb
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bi-&gt;bi_parent
)paren
(brace
id|B_N_CHILD
(paren
id|bi-&gt;bi_parent
comma
id|bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_size
op_add_assign
id|paste_size
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|bi-&gt;tb
comma
id|bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* cuts DEL_COUNT entries beginning from FROM-th entry. Directory item&n;   does not have free space, so it moves DEHs and remaining records as&n;   necessary. Return value is size of removed part of directory item&n;   in bytes. */
DECL|function|leaf_cut_entries
r_static
r_int
id|leaf_cut_entries
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|item_head
op_star
id|ih
comma
r_int
id|from
comma
r_int
id|del_count
)paren
(brace
r_char
op_star
id|item
suffix:semicolon
r_struct
id|reiserfs_de_head
op_star
id|deh
suffix:semicolon
r_int
id|prev_record_offset
suffix:semicolon
multiline_comment|/* offset of record, that is (from-1)th */
r_char
op_star
id|prev_record
suffix:semicolon
multiline_comment|/* */
r_int
id|cut_records_len
suffix:semicolon
multiline_comment|/* length of all removed records */
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
multiline_comment|/* make sure, that item is directory and there are enough entries to&n;     remove */
r_if
c_cond
(paren
op_logical_neg
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_cut_entries: 10180: item is not directory item&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
OL
id|from
op_plus
id|del_count
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_cut_entries: 10185: item contains not enough entries: entry_cout = %d, from = %d, to delete = %d&quot;
comma
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
comma
id|from
comma
id|del_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|del_count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* first byte of item */
id|item
op_assign
id|bh-&gt;b_data
op_plus
id|ih-&gt;ih_item_location
suffix:semicolon
multiline_comment|/* entry head array */
id|deh
op_assign
id|B_I_DEH
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* first byte of remaining entries, those are BEFORE cut entries&n;     (prev_record) and length of all removed records (cut_records_len) */
id|prev_record_offset
op_assign
(paren
id|from
ques
c_cond
id|deh
(braket
id|from
op_minus
l_int|1
)braket
dot
id|deh_location
suffix:colon
id|ih-&gt;ih_item_len
)paren
suffix:semicolon
id|cut_records_len
op_assign
id|prev_record_offset
multiline_comment|/*from_record*/
op_minus
id|deh
(braket
id|from
op_plus
id|del_count
op_minus
l_int|1
)braket
dot
id|deh_location
suffix:semicolon
id|prev_record
op_assign
id|item
op_plus
id|prev_record_offset
suffix:semicolon
multiline_comment|/* adjust locations of remaining entries */
r_for
c_loop
(paren
id|i
op_assign
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
op_minus
l_int|1
suffix:semicolon
id|i
OG
id|from
op_plus
id|del_count
op_minus
l_int|1
suffix:semicolon
id|i
op_decrement
)paren
id|deh
(braket
id|i
)braket
dot
id|deh_location
op_sub_assign
(paren
id|DEH_SIZE
op_star
id|del_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|from
suffix:semicolon
id|i
op_increment
)paren
id|deh
(braket
id|i
)braket
dot
id|deh_location
op_sub_assign
id|DEH_SIZE
op_star
id|del_count
op_plus
id|cut_records_len
suffix:semicolon
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
op_sub_assign
id|del_count
suffix:semicolon
multiline_comment|/* shift entry head array and entries those are AFTER removed entries */
id|memmove
(paren
(paren
r_char
op_star
)paren
(paren
id|deh
op_plus
id|from
)paren
comma
id|deh
op_plus
id|from
op_plus
id|del_count
comma
id|prev_record
op_minus
id|cut_records_len
op_minus
(paren
r_char
op_star
)paren
(paren
id|deh
op_plus
id|from
op_plus
id|del_count
)paren
)paren
suffix:semicolon
multiline_comment|/* shift records, those are BEFORE removed entries */
id|memmove
(paren
id|prev_record
op_minus
id|cut_records_len
op_minus
id|DEH_SIZE
op_star
id|del_count
comma
id|prev_record
comma
id|item
op_plus
id|ih-&gt;ih_item_len
op_minus
id|prev_record
)paren
suffix:semicolon
r_return
id|DEH_SIZE
op_star
id|del_count
op_plus
id|cut_records_len
suffix:semicolon
)brace
multiline_comment|/*  when cut item is part of regular file&n;        pos_in_item - first byte that must be cut&n;        cut_size - number of bytes to be cut beginning from pos_in_item&n; &n;   when cut item is part of directory&n;        pos_in_item - number of first deleted entry&n;        cut_size - count of deleted entries&n;    */
DECL|function|leaf_cut_from_buffer
r_void
id|leaf_cut_from_buffer
(paren
r_struct
id|buffer_info
op_star
id|bi
comma
r_int
id|cut_item_num
comma
r_int
id|pos_in_item
comma
r_int
id|cut_size
)paren
(brace
r_int
id|nr
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|bi-&gt;bi_bh
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_int
id|last_loc
comma
id|unmoved_loc
suffix:semicolon
r_int
id|i
suffix:semicolon
id|nr
op_assign
id|le16_to_cpu
(paren
(paren
id|blkh
op_assign
id|B_BLK_HEAD
(paren
id|bh
)paren
)paren
op_member_access_from_pointer
id|blk_nr_item
)paren
suffix:semicolon
multiline_comment|/* item head of truncated item */
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|bh
comma
id|cut_item_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
(brace
multiline_comment|/* first cut entry ()*/
id|cut_size
op_assign
id|leaf_cut_entries
(paren
id|bh
comma
id|ih
comma
id|pos_in_item
comma
id|cut_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos_in_item
op_eq
l_int|0
)paren
(brace
multiline_comment|/* change key */
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|cut_item_num
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_cut_from_buffer: 10190: &quot;
l_string|&quot;when 0-th enrty of item is cut, that item must be first in the node, not %d-th&quot;
comma
id|cut_item_num
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* change item key by key of first entry in the item */
id|set_le_ih_k_offset
(paren
id|ih
comma
id|le32_to_cpu
(paren
id|B_I_DEH
(paren
id|bh
comma
id|ih
)paren
op_member_access_from_pointer
id|deh_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*memcpy (&amp;ih-&gt;ih_key.k_offset, &amp;(B_I_DEH (bh, ih)-&gt;deh_offset), SHORT_KEY_SIZE);*/
)brace
)brace
r_else
(brace
multiline_comment|/* item is direct or indirect */
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|is_statdata_le_ih
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_cut_from_buffer: 10195: item is stat data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos_in_item
op_logical_and
id|pos_in_item
op_plus
id|cut_size
op_ne
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;cut_from_buf: 10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)&quot;
comma
id|pos_in_item
comma
id|cut_size
comma
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* shift item body to left if cut is from the head of item */
r_if
c_cond
(paren
id|pos_in_item
op_eq
l_int|0
)paren
(brace
id|memmove
(paren
id|bh-&gt;b_data
op_plus
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_location
)paren
comma
id|bh-&gt;b_data
op_plus
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_location
)paren
op_plus
id|cut_size
comma
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_minus
id|cut_size
)paren
suffix:semicolon
multiline_comment|/* change key of item */
r_if
c_cond
(paren
id|is_direct_le_ih
(paren
id|ih
)paren
)paren
id|set_le_ih_k_offset
(paren
id|ih
comma
id|le_ih_k_offset
(paren
id|ih
)paren
op_plus
id|cut_size
)paren
suffix:semicolon
r_else
(brace
id|set_le_ih_k_offset
(paren
id|ih
comma
id|le_ih_k_offset
(paren
id|ih
)paren
op_plus
(paren
id|cut_size
op_div
id|UNFM_P_SIZE
)paren
op_star
id|bh-&gt;b_size
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_eq
id|cut_size
op_logical_and
id|get_ih_free_space
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_cut_from_buf: 10205: invalid ih_free_space (%h)&quot;
comma
id|ih
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
multiline_comment|/* location of the last item */
id|last_loc
op_assign
id|le16_to_cpu
(paren
id|ih
(braket
id|nr
op_minus
id|cut_item_num
op_minus
l_int|1
)braket
dot
id|ih_item_location
)paren
suffix:semicolon
multiline_comment|/* location of the item, which is remaining at the same place */
id|unmoved_loc
op_assign
id|cut_item_num
ques
c_cond
id|le16_to_cpu
(paren
(paren
id|ih
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|ih_item_location
)paren
suffix:colon
id|bh-&gt;b_size
suffix:semicolon
multiline_comment|/* shift */
id|memmove
(paren
id|bh-&gt;b_data
op_plus
id|last_loc
op_plus
id|cut_size
comma
id|bh-&gt;b_data
op_plus
id|last_loc
comma
id|unmoved_loc
op_minus
id|last_loc
op_minus
id|cut_size
)paren
suffix:semicolon
multiline_comment|/* change item length */
multiline_comment|/*    ih-&gt;ih_item_len -= cut_size;*/
id|ih-&gt;ih_item_len
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|ih-&gt;ih_item_len
)paren
op_minus
id|cut_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_indirect_le_ih
(paren
id|ih
)paren
)paren
(brace
r_if
c_cond
(paren
id|pos_in_item
)paren
id|set_ih_free_space
(paren
id|ih
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* change locations */
r_for
c_loop
(paren
id|i
op_assign
id|cut_item_num
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/*        ih[i-cut_item_num].ih_item_location += cut_size;*/
id|ih
(braket
id|i
op_minus
id|cut_item_num
)braket
dot
id|ih_item_location
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|ih
(braket
id|i
op_minus
id|cut_item_num
)braket
dot
id|ih_item_location
)paren
op_plus
id|cut_size
)paren
suffix:semicolon
multiline_comment|/* size, free space */
id|blkh-&gt;blk_free_space
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
op_plus
id|cut_size
)paren
suffix:semicolon
id|do_balance_mark_leaf_dirty
(paren
id|bi-&gt;tb
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bi-&gt;bi_parent
)paren
(brace
id|B_N_CHILD
(paren
id|bi-&gt;bi_parent
comma
id|bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_size
op_sub_assign
id|cut_size
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|bi-&gt;tb
comma
id|bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* delete del_num items from buffer starting from the first&squot;th item */
DECL|function|leaf_delete_items_entirely
r_static
r_void
id|leaf_delete_items_entirely
(paren
r_struct
id|buffer_info
op_star
id|bi
comma
r_int
id|first
comma
r_int
id|del_num
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|bi-&gt;bi_bh
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|last_loc
comma
id|last_removed_loc
suffix:semicolon
r_struct
id|block_head
op_star
id|blkh
suffix:semicolon
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_delete_items_entirely: 10210: buffer is 0&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|del_num
OL
l_int|0
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_delete_items_entirely: 10215: del_num less than 0 (%d)&quot;
comma
id|del_num
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_REISERFS_CHECK */
r_if
c_cond
(paren
id|del_num
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|nr
op_assign
id|le16_to_cpu
(paren
(paren
id|blkh
op_assign
id|B_BLK_HEAD
c_func
(paren
id|bh
)paren
)paren
op_member_access_from_pointer
id|blk_nr_item
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
r_if
c_cond
(paren
id|first
template_param
id|nr
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_delete_items_entirely: 10220: first=%d, number=%d, there is %d items&quot;
comma
id|first
comma
id|del_num
comma
id|nr
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_REISERFS_CHECK */
r_if
c_cond
(paren
id|first
op_eq
l_int|0
op_logical_and
id|del_num
op_eq
id|nr
)paren
(brace
multiline_comment|/* this does not work */
id|make_empty_node
(paren
id|bi
)paren
suffix:semicolon
id|do_balance_mark_leaf_dirty
(paren
id|bi-&gt;tb
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ih
op_assign
id|B_N_PITEM_HEAD
(paren
id|bh
comma
id|first
)paren
suffix:semicolon
multiline_comment|/* location of unmovable item */
id|j
op_assign
(paren
id|first
op_eq
l_int|0
)paren
ques
c_cond
id|bh-&gt;b_size
suffix:colon
(paren
id|ih
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|ih_item_location
suffix:semicolon
multiline_comment|/* delete items */
id|last_loc
op_assign
id|ih
(braket
id|nr
op_minus
l_int|1
op_minus
id|first
)braket
dot
id|ih_item_location
suffix:semicolon
id|last_removed_loc
op_assign
id|ih
(braket
id|del_num
op_minus
l_int|1
)braket
dot
id|ih_item_location
suffix:semicolon
id|memmove
(paren
id|bh-&gt;b_data
op_plus
id|last_loc
op_plus
id|j
op_minus
id|last_removed_loc
comma
id|bh-&gt;b_data
op_plus
id|last_loc
comma
id|last_removed_loc
op_minus
id|last_loc
)paren
suffix:semicolon
multiline_comment|/* delete item headers */
id|memmove
(paren
id|ih
comma
id|ih
op_plus
id|del_num
comma
(paren
id|nr
op_minus
id|first
op_minus
id|del_num
)paren
op_star
id|IH_SIZE
)paren
suffix:semicolon
multiline_comment|/* change item location */
r_for
c_loop
(paren
id|i
op_assign
id|first
suffix:semicolon
id|i
OL
id|nr
op_minus
id|del_num
suffix:semicolon
id|i
op_increment
)paren
id|ih
(braket
id|i
op_minus
id|first
)braket
dot
id|ih_item_location
op_add_assign
id|j
op_minus
id|last_removed_loc
suffix:semicolon
multiline_comment|/* sizes, item number */
id|blkh-&gt;blk_nr_item
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_nr_item
)paren
op_minus
id|del_num
)paren
suffix:semicolon
id|blkh-&gt;blk_free_space
op_assign
id|cpu_to_le16
(paren
id|le16_to_cpu
(paren
id|blkh-&gt;blk_free_space
)paren
op_plus
(paren
id|j
op_minus
id|last_removed_loc
op_plus
id|IH_SIZE
op_star
id|del_num
)paren
)paren
suffix:semicolon
id|do_balance_mark_leaf_dirty
(paren
id|bi-&gt;tb
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bi-&gt;bi_parent
)paren
(brace
id|B_N_CHILD
(paren
id|bi-&gt;bi_parent
comma
id|bi-&gt;bi_position
)paren
op_member_access_from_pointer
id|dc_size
op_sub_assign
id|j
op_minus
id|last_removed_loc
op_plus
id|IH_SIZE
op_star
id|del_num
suffix:semicolon
id|do_balance_mark_internal_dirty
(paren
id|bi-&gt;tb
comma
id|bi-&gt;bi_parent
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* paste new_entry_count entries (new_dehs, records) into position before to item_num-th item */
DECL|function|leaf_paste_entries
r_void
id|leaf_paste_entries
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|item_num
comma
r_int
id|before
comma
r_int
id|new_entry_count
comma
r_struct
id|reiserfs_de_head
op_star
id|new_dehs
comma
r_const
r_char
op_star
id|records
comma
r_int
id|paste_size
)paren
(brace
r_struct
id|item_head
op_star
id|ih
suffix:semicolon
r_char
op_star
id|item
suffix:semicolon
r_struct
id|reiserfs_de_head
op_star
id|deh
suffix:semicolon
r_char
op_star
id|insert_point
suffix:semicolon
r_int
id|i
comma
id|old_entry_num
suffix:semicolon
r_if
c_cond
(paren
id|new_entry_count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|ih
op_assign
id|B_N_PITEM_HEAD
c_func
(paren
id|bh
comma
id|item_num
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REISERFS_CHECK
multiline_comment|/* make sure, that item is directory, and there are enough records in it */
r_if
c_cond
(paren
op_logical_neg
id|is_direntry_le_ih
(paren
id|ih
)paren
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_paste_entries: 10225: item is not directory item&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_ENTRY_COUNT
(paren
id|ih
)paren
OL
id|before
)paren
id|reiserfs_panic
(paren
l_int|0
comma
l_string|&quot;leaf_paste_entries: 10230: there are no entry we paste entries before. entry_count = %d, before = %d&quot;
comma
id|I_ENTRY_COUNT
(paren
id|ih
)paren
comma
id|before
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* first byte of dest item */
id|item
op_assign
id|bh-&gt;b_data
op_plus
id|ih-&gt;ih_item_location
suffix:semicolon
multiline_comment|/* entry head array */
id|deh
op_assign
id|B_I_DEH
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
multiline_comment|/* new records will be pasted at this point */
id|insert_point
op_assign
id|item
op_plus
(paren
id|before
ques
c_cond
id|deh
(braket
id|before
op_minus
l_int|1
)braket
dot
id|deh_location
suffix:colon
(paren
id|ih-&gt;ih_item_len
op_minus
id|paste_size
)paren
)paren
suffix:semicolon
multiline_comment|/* adjust locations of records that will be AFTER new records */
r_for
c_loop
(paren
id|i
op_assign
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
id|before
suffix:semicolon
id|i
op_decrement
)paren
id|deh
(braket
id|i
)braket
dot
id|deh_location
op_add_assign
id|DEH_SIZE
op_star
id|new_entry_count
suffix:semicolon
multiline_comment|/* adjust locations of records that will be BEFORE new records */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|before
suffix:semicolon
id|i
op_increment
)paren
id|deh
(braket
id|i
)braket
dot
id|deh_location
op_add_assign
id|paste_size
suffix:semicolon
id|old_entry_num
op_assign
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
suffix:semicolon
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
op_add_assign
id|new_entry_count
suffix:semicolon
multiline_comment|/* prepare space for pasted records */
id|memmove
(paren
id|insert_point
op_plus
id|paste_size
comma
id|insert_point
comma
id|item
op_plus
(paren
id|ih-&gt;ih_item_len
op_minus
id|paste_size
)paren
op_minus
id|insert_point
)paren
suffix:semicolon
multiline_comment|/* copy new records */
id|memcpy
(paren
id|insert_point
op_plus
id|DEH_SIZE
op_star
id|new_entry_count
comma
id|records
comma
id|paste_size
op_minus
id|DEH_SIZE
op_star
id|new_entry_count
)paren
suffix:semicolon
multiline_comment|/* prepare space for new entry heads */
id|deh
op_add_assign
id|before
suffix:semicolon
id|memmove
(paren
(paren
r_char
op_star
)paren
(paren
id|deh
op_plus
id|new_entry_count
)paren
comma
id|deh
comma
id|insert_point
op_minus
(paren
r_char
op_star
)paren
id|deh
)paren
suffix:semicolon
multiline_comment|/* copy new entry heads */
id|deh
op_assign
(paren
r_struct
id|reiserfs_de_head
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|deh
)paren
suffix:semicolon
id|memcpy
(paren
id|deh
comma
id|new_dehs
comma
id|DEH_SIZE
op_star
id|new_entry_count
)paren
suffix:semicolon
multiline_comment|/* set locations of new records */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|new_entry_count
suffix:semicolon
id|i
op_increment
)paren
id|deh
(braket
id|i
)braket
dot
id|deh_location
op_add_assign
(paren
op_minus
id|new_dehs
(braket
id|new_entry_count
op_minus
l_int|1
)braket
dot
id|deh_location
op_plus
id|insert_point
op_plus
id|DEH_SIZE
op_star
id|new_entry_count
op_minus
id|item
)paren
suffix:semicolon
multiline_comment|/* change item key if neccessary (when we paste before 0-th entry */
r_if
c_cond
(paren
op_logical_neg
id|before
)paren
(brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
multiline_comment|/*&n;      if ( old_entry_num &amp;&amp; COMP_SHORT_KEYS ((unsigned long *)&amp;ih-&gt;ih_key.k_offset,&n;&t;&t;&t;&t;&t;     &amp;(new_dehs-&gt;deh_offset)) &lt;= 0)&n;&t;reiserfs_panic (0, &quot;leaf_paste_entries: 10235: new key must be less, that old key&quot;);&n;*/
macro_line|#endif
id|set_le_ih_k_offset
(paren
id|ih
comma
id|le32_to_cpu
(paren
id|new_dehs-&gt;deh_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*      memcpy (&amp;ih-&gt;ih_key.k_offset, &n;&t;&t;       &amp;new_dehs-&gt;deh_offset, SHORT_KEY_SIZE);*/
)brace
macro_line|#ifdef CONFIG_REISERFS_CHECK
(brace
r_int
id|prev
comma
id|next
suffix:semicolon
multiline_comment|/* check record locations */
id|deh
op_assign
id|B_I_DEH
(paren
id|bh
comma
id|ih
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|next
op_assign
(paren
id|i
OL
id|I_ENTRY_COUNT
c_func
(paren
id|ih
)paren
op_minus
l_int|1
)paren
ques
c_cond
id|deh
(braket
id|i
op_plus
l_int|1
)braket
dot
id|deh_location
suffix:colon
l_int|0
suffix:semicolon
id|prev
op_assign
(paren
id|i
op_ne
l_int|0
)paren
ques
c_cond
id|deh
(braket
id|i
op_minus
l_int|1
)braket
dot
id|deh_location
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_logical_and
id|prev
op_le
id|deh
(braket
id|i
)braket
dot
id|deh_location
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-10240: leaf_paste_entries: directory item (%h) corrupted (prev %a, cur(%d) %a)&bslash;n&quot;
comma
id|ih
comma
id|deh
op_plus
id|i
op_minus
l_int|1
comma
id|i
comma
id|deh
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
op_logical_and
id|next
op_ge
id|deh
(braket
id|i
)braket
dot
id|deh_location
)paren
id|reiserfs_warning
(paren
l_string|&quot;vs-10250: leaf_paste_entries: directory item (%h) corrupted (cur(%d) %a, next %a)&bslash;n&quot;
comma
id|ih
comma
id|i
comma
id|deh
op_plus
id|i
comma
id|deh
op_plus
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
eof
