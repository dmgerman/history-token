multiline_comment|/*&n; *  linux/fs/binfmt_flat.c&n; *&n; *&t;Copyright (C) 2000, 2001 Lineo, by David McCullough &lt;davidm@uclinux.org&gt;&n; *&t;Copyright (C) 2002 Greg Ungerer &lt;gerg@snapgear.com&gt;&n; *&n; *  based heavily on:&n; *&n; *  linux/fs/binfmt_aout.c:&n; *      Copyright (C) 1991, 1992, 1996  Linus Torvalds&n; *  linux/fs/binfmt_flat.c for 2.0 kernel&n; *&t;Copyright (C) 1998  Kenneth Albanowski &lt;kjahds@kjahds.com&gt;&n; *&t;JAN/99 -- coded full program relocation (gerg@snapgear.com)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/flat.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG
macro_line|#ifdef DEBUG
DECL|macro|DBG_FLT
mdefine_line|#define&t;DBG_FLT(a...)&t;printk(##a)
macro_line|#else
DECL|macro|DBG_FLT
mdefine_line|#define&t;DBG_FLT(a...)
macro_line|#endif
r_static
r_int
id|load_flat_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|load_flat_library
c_func
(paren
r_struct
id|file
op_star
)paren
suffix:semicolon
r_extern
r_void
id|dump_thread
c_func
(paren
r_struct
id|pt_regs
op_star
comma
r_struct
id|user
op_star
)paren
suffix:semicolon
DECL|variable|flat_format
r_static
r_struct
id|linux_binfmt
id|flat_format
op_assign
(brace
l_int|NULL
comma
id|THIS_MODULE
comma
id|load_flat_binary
comma
id|load_flat_library
comma
l_int|NULL
comma
id|PAGE_SIZE
)brace
suffix:semicolon
multiline_comment|/*&n; * create_flat_tables() parses the env- and arg-strings in new user&n; * memory and creates the pointer tables from them, and puts their&n; * addresses on the &quot;stack&quot;, returning the new stack pointer value.&n; */
DECL|function|create_flat_tables
r_static
r_int
r_int
id|create_flat_tables
c_func
(paren
r_int
r_int
id|pp
comma
r_struct
id|linux_binprm
op_star
id|bprm
)paren
(brace
r_int
r_int
op_star
id|argv
comma
op_star
id|envp
suffix:semicolon
r_int
r_int
op_star
id|sp
suffix:semicolon
r_char
op_star
id|p
op_assign
(paren
r_char
op_star
)paren
id|pp
suffix:semicolon
r_int
id|argc
op_assign
id|bprm-&gt;argc
suffix:semicolon
r_int
id|envc
op_assign
id|bprm-&gt;envc
suffix:semicolon
r_char
id|dummy
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
op_minus
(paren
r_int
r_int
)paren
r_sizeof
(paren
r_char
op_star
)paren
)paren
op_amp
(paren
r_int
r_int
)paren
id|p
)paren
suffix:semicolon
id|sp
op_sub_assign
id|envc
op_plus
l_int|1
suffix:semicolon
id|envp
op_assign
id|sp
suffix:semicolon
id|sp
op_sub_assign
id|argc
op_plus
l_int|1
suffix:semicolon
id|argv
op_assign
id|sp
suffix:semicolon
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|envp
comma
op_decrement
id|sp
)paren
suffix:semicolon
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|argv
comma
op_decrement
id|sp
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|argc
comma
op_decrement
id|sp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_start
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
OG
l_int|0
)paren
(brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|p
comma
id|argv
op_increment
)paren
suffix:semicolon
r_do
(brace
id|get_user
c_func
(paren
id|dummy
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dummy
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
l_int|NULL
comma
id|argv
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_end
op_assign
id|current-&gt;mm-&gt;env_start
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_while
c_loop
(paren
id|envc
op_decrement
OG
l_int|0
)paren
(brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|p
comma
id|envp
)paren
suffix:semicolon
id|envp
op_increment
suffix:semicolon
r_do
(brace
id|get_user
c_func
(paren
id|dummy
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dummy
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
l_int|NULL
comma
id|envp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;env_end
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BINFMT_ZFLAT
macro_line|#include &lt;linux/zlib.h&gt;
DECL|macro|LBUFSIZE
mdefine_line|#define LBUFSIZE&t;4000
multiline_comment|/* gzip flag byte */
DECL|macro|ASCII_FLAG
mdefine_line|#define ASCII_FLAG   0x01 /* bit 0 set: file probably ASCII text */
DECL|macro|CONTINUATION
mdefine_line|#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
DECL|macro|EXTRA_FIELD
mdefine_line|#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
DECL|macro|ORIG_NAME
mdefine_line|#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
DECL|macro|COMMENT
mdefine_line|#define COMMENT      0x10 /* bit 4 set: file comment present */
DECL|macro|ENCRYPTED
mdefine_line|#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
DECL|macro|RESERVED
mdefine_line|#define RESERVED     0xC0 /* bit 6,7:   reserved */
DECL|function|decompress_exec
r_static
r_int
id|decompress_exec
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_int
r_int
id|offset
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
id|fd
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
id|z_stream
id|strm
suffix:semicolon
id|loff_t
id|fpos
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;decompress_exec(offset=%x,buf=%x,len=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
(paren
r_int
)paren
id|dst
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|strm
comma
l_int|0
comma
r_sizeof
(paren
id|strm
)paren
)paren
suffix:semicolon
id|strm.workspace
op_assign
id|kmalloc
c_func
(paren
id|zlib_inflate_workspacesize
c_func
(paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strm.workspace
op_eq
l_int|NULL
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: no memory for decompress workspace&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|buf
op_assign
id|kmalloc
c_func
(paren
id|LBUFSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: no memory for read buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Read in first chunk of data and parse gzip header. */
id|fpos
op_assign
id|offset
suffix:semicolon
id|ret
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
id|buf
comma
id|LBUFSIZE
comma
op_amp
id|fpos
)paren
suffix:semicolon
id|strm.next_in
op_assign
id|buf
suffix:semicolon
id|strm.avail_in
op_assign
id|ret
suffix:semicolon
id|strm.total_in
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check minimum size -- gzip header */
r_if
c_cond
(paren
id|ret
OL
l_int|10
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: file too small?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Check gzip magic number */
r_if
c_cond
(paren
(paren
id|buf
(braket
l_int|0
)braket
op_ne
l_int|037
)paren
op_logical_or
(paren
(paren
id|buf
(braket
l_int|1
)braket
op_ne
l_int|0213
)paren
op_logical_and
(paren
id|buf
(braket
l_int|1
)braket
op_ne
l_int|0236
)paren
)paren
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: unknown compression magic?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Check gzip method */
r_if
c_cond
(paren
id|buf
(braket
l_int|2
)braket
op_ne
l_int|8
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: unknown compression method?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Check gzip flags */
r_if
c_cond
(paren
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|ENCRYPTED
)paren
op_logical_or
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|CONTINUATION
)paren
op_logical_or
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|RESERVED
)paren
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: unknown flags?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
id|ret
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|EXTRA_FIELD
)paren
id|ret
op_add_assign
l_int|2
op_plus
id|buf
(braket
l_int|10
)braket
op_plus
(paren
id|buf
(braket
l_int|11
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|ORIG_NAME
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
(paren
id|buf
(braket
id|ret
)braket
op_ne
l_int|0
)paren
suffix:semicolon
id|ret
op_increment
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|COMMENT
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
(paren
id|buf
(braket
id|ret
)braket
op_ne
l_int|0
)paren
suffix:semicolon
id|ret
op_increment
)paren
suffix:semicolon
)brace
id|strm.next_in
op_add_assign
id|ret
suffix:semicolon
id|strm.avail_in
op_sub_assign
id|ret
suffix:semicolon
id|strm.next_out
op_assign
id|dst
suffix:semicolon
id|strm.avail_out
op_assign
id|len
suffix:semicolon
id|strm.total_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|zlib_inflateInit2
c_func
(paren
op_amp
id|strm
comma
op_minus
id|MAX_WBITS
)paren
op_ne
id|Z_OK
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: zlib init failed?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ret
op_assign
id|zlib_inflate
c_func
(paren
op_amp
id|strm
comma
id|Z_NO_FLUSH
)paren
)paren
op_eq
id|Z_OK
)paren
(brace
id|ret
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
id|buf
comma
id|LBUFSIZE
comma
op_amp
id|fpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
r_break
suffix:semicolon
id|len
op_sub_assign
id|ret
suffix:semicolon
id|strm.next_in
op_assign
id|buf
suffix:semicolon
id|strm.avail_in
op_assign
id|ret
suffix:semicolon
id|strm.total_in
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: decompression failed (%d), %s&bslash;n&quot;
comma
id|ret
comma
id|strm.msg
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
id|zlib_inflateEnd
c_func
(paren
op_amp
id|strm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|strm.workspace
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BINFMT_ZFLAT */
r_static
r_int
r_int
DECL|function|calc_reloc
id|calc_reloc
c_func
(paren
r_int
r_int
id|r
comma
r_int
r_int
id|text_len
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|r
OG
id|current-&gt;mm-&gt;start_brk
op_minus
id|current-&gt;mm-&gt;start_data
op_plus
id|text_len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x), killing!&bslash;n&quot;
comma
(paren
r_int
)paren
id|r
comma
(paren
r_int
)paren
(paren
id|current-&gt;mm-&gt;start_brk
op_minus
id|current-&gt;mm-&gt;start_code
)paren
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
id|current-&gt;mm-&gt;start_brk
suffix:semicolon
multiline_comment|/* return something safe to write to */
)brace
r_if
c_cond
(paren
id|r
OL
id|text_len
)paren
(brace
multiline_comment|/* In text segment */
r_return
id|r
op_plus
id|current-&gt;mm-&gt;start_code
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we allow inclusive ranges here so that programs may do things&n;&t; * like reference the end of data (_end) without failing these tests&n;&t; */
id|addr
op_assign
id|r
op_minus
id|text_len
op_plus
id|current-&gt;mm-&gt;start_data
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ge
id|current-&gt;mm-&gt;start_code
op_logical_and
id|addr
op_le
id|current-&gt;mm-&gt;start_code
op_plus
id|text_len
)paren
r_return
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ge
id|current-&gt;mm-&gt;start_data
op_logical_and
id|addr
op_le
id|current-&gt;mm-&gt;start_brk
)paren
r_return
id|addr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: reloc addr outside text/data 0x%x &quot;
l_string|&quot;code(0x%x - 0x%x) data(0x%x - 0x%x) killing&bslash;n&quot;
comma
(paren
r_int
)paren
id|addr
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_code
comma
(paren
r_int
)paren
(paren
id|current-&gt;mm-&gt;start_code
op_plus
id|text_len
)paren
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_data
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_brk
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
id|current-&gt;mm-&gt;start_brk
suffix:semicolon
multiline_comment|/* return something safe to write to */
)brace
DECL|function|old_reloc
r_void
id|old_reloc
c_func
(paren
r_int
r_int
id|rl
)paren
(brace
macro_line|#ifdef DEBUG
r_char
op_star
id|segment
(braket
)braket
op_assign
(brace
l_string|&quot;TEXT&quot;
comma
l_string|&quot;DATA&quot;
comma
l_string|&quot;BSS&quot;
comma
l_string|&quot;*UNKNOWN*&quot;
)brace
suffix:semicolon
macro_line|#endif
id|flat_v2_reloc_t
id|r
suffix:semicolon
r_int
r_int
op_star
id|ptr
suffix:semicolon
id|r.value
op_assign
id|rl
suffix:semicolon
macro_line|#if defined(CONFIG_COLDFIRE)
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|current-&gt;mm-&gt;start_code
op_plus
id|r.reloc.offset
)paren
suffix:semicolon
macro_line|#else
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|current-&gt;mm-&gt;start_data
op_plus
id|r.reloc.offset
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Relocation of variable at DATASEG+%x &quot;
l_string|&quot;(address %p, currently %x) into segment %s&bslash;n&quot;
comma
id|r.reloc.offset
comma
id|ptr
comma
(paren
r_int
)paren
op_star
id|ptr
comma
id|segment
(braket
id|r.reloc.type
)braket
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|r.reloc.type
)paren
(brace
r_case
id|OLD_FLAT_RELOC_TYPE_TEXT
suffix:colon
op_star
id|ptr
op_add_assign
id|current-&gt;mm-&gt;start_code
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OLD_FLAT_RELOC_TYPE_DATA
suffix:colon
op_star
id|ptr
op_add_assign
id|current-&gt;mm-&gt;start_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OLD_FLAT_RELOC_TYPE_BSS
suffix:colon
op_star
id|ptr
op_add_assign
id|current-&gt;mm-&gt;end_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: Unknown relocation type=%x&bslash;n&quot;
comma
id|r.reloc.type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Relocation became %x&bslash;n&quot;
comma
(paren
r_int
)paren
op_star
id|ptr
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * These are the functions used to load flat style executables and shared&n; * libraries.  There is no binary dependent code anywhere else.&n; */
DECL|function|load_flat_binary
r_static
r_int
id|load_flat_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|flat_hdr
op_star
id|hdr
suffix:semicolon
r_int
r_int
id|textpos
op_assign
l_int|0
comma
id|datapos
op_assign
l_int|0
comma
id|result
suffix:semicolon
r_int
r_int
id|text_len
comma
id|data_len
comma
id|bss_len
comma
id|stack_len
comma
id|flags
suffix:semicolon
r_int
r_int
id|memp
op_assign
l_int|0
comma
id|memkasked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for finding the brk area */
r_int
r_int
id|extra
comma
id|rlim
suffix:semicolon
r_int
r_int
id|p
op_assign
id|bprm-&gt;p
suffix:semicolon
r_int
r_int
op_star
id|reloc
op_assign
l_int|0
comma
op_star
id|rp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|i
comma
id|rev
comma
id|relocs
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|fpos
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;BINFMT_FLAT: Loading file: %x&bslash;n&quot;
comma
id|bprm-&gt;file
)paren
suffix:semicolon
id|hdr
op_assign
(paren
(paren
r_struct
id|flat_hdr
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
multiline_comment|/* exec-header */
id|inode
op_assign
id|bprm-&gt;file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|text_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
id|data_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;data_end
)paren
op_minus
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
id|bss_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;bss_end
)paren
op_minus
id|ntohl
c_func
(paren
id|hdr-&gt;data_end
)paren
suffix:semicolon
id|stack_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;stack_size
)paren
suffix:semicolon
id|relocs
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;reloc_count
)paren
suffix:semicolon
id|flags
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;flags
)paren
suffix:semicolon
id|rev
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;rev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to add the size of our arguments to our stack size&n;&t; * otherwise it&squot;s too easy for users to create stack overflows&n;&t; * by passing in a huge argument list.  And yes,  we have to be&n;&t; * pedantic and include space for the argv/envp array as it may have&n;&t; * a lot of entries.&n;&t; */
DECL|macro|TOP_OF_ARGS
mdefine_line|#define TOP_OF_ARGS (PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *))
id|stack_len
op_add_assign
id|TOP_OF_ARGS
op_minus
id|bprm-&gt;p
suffix:semicolon
multiline_comment|/* the strings */
id|stack_len
op_add_assign
(paren
id|bprm-&gt;argc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* the argv array */
id|stack_len
op_add_assign
(paren
id|bprm-&gt;envc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* the envp array */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|hdr-&gt;magic
comma
l_string|&quot;bFLT&quot;
comma
l_int|4
)paren
op_logical_or
(paren
id|rev
op_ne
id|FLAT_VERSION
op_logical_and
id|rev
op_ne
id|OLD_FLAT_VERSION
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * because a lot of people do not manage to produce good&n;&t;&t; * flat binaries,  we leave this printk to help them realise&n;&t;&t; * the problem.  We only print the error if its * not a script file&n;&t;&t; */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|hdr-&gt;magic
comma
l_string|&quot;#!&quot;
comma
l_int|2
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: bad magic/rev (0x%x, need 0x%x)&bslash;n&quot;
comma
id|rev
comma
(paren
r_int
)paren
id|FLAT_VERSION
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * fix up the flags for the older format,  there were all kinds&n;&t; * of endian hacks,  this only works for the simple cases&n;&t; */
r_if
c_cond
(paren
id|rev
op_eq
id|OLD_FLAT_VERSION
op_logical_and
id|flags
)paren
id|flags
op_assign
id|FLAT_FLAG_RAM
suffix:semicolon
macro_line|#ifndef CONFIG_BINFMT_ZFLAT
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|FLAT_FLAG_GZIP
op_or
id|FLAT_FLAG_GZDATA
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Support for ZFLAT executables is not enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Check initial limits. This avoids letting people circumvent&n;&t; * size limits imposed on them by creating programs with large&n;&t; * arrays in the data or bss.&n;&t; */
id|rlim
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_DATA
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|rlim
op_ge
id|RLIM_INFINITY
)paren
id|rlim
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data_len
op_plus
id|bss_len
OG
id|rlim
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Flush all traces of the currently running executable */
id|result
op_assign
id|flush_old_exec
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* OK, This is the point of no return */
id|set_personality
c_func
(paren
id|PER_LINUX
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * there are a couple of cases here,  the separate code/data&n;&t; * case,  and then the fully copied to RAM case which lumps&n;&t; * it all together.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|FLAT_FLAG_RAM
op_or
id|FLAT_FLAG_GZIP
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * this should give us a ROM ptr,  but if it doesn&squot;t we don&squot;t&n;&t;&t; * really care&n;&t;&t; */
id|DBG_FLT
c_func
(paren
l_string|&quot;BINFMT_FLAT: ROM mapping of file (we hope)&bslash;n&quot;
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|textpos
op_assign
id|do_mmap
c_func
(paren
id|bprm-&gt;file
comma
l_int|0
comma
id|text_len
comma
id|PROT_READ
op_or
id|PROT_EXEC
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|textpos
op_logical_or
id|textpos
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|textpos
)paren
id|textpos
op_assign
(paren
r_int
r_int
)paren
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to mmap process text, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|textpos
)paren
suffix:semicolon
)brace
id|extra
op_assign
id|max
c_func
(paren
id|bss_len
op_plus
id|stack_len
comma
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|datapos
op_assign
id|do_mmap
c_func
(paren
l_int|0
comma
l_int|0
comma
id|data_len
op_plus
id|extra
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|datapos
op_eq
l_int|0
op_logical_or
id|datapos
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|datapos
)paren
id|datapos
op_assign
(paren
r_int
r_int
)paren
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to allocate RAM for process data, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|datapos
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|textpos
comma
id|text_len
)paren
suffix:semicolon
r_return
id|datapos
suffix:semicolon
)brace
id|DBG_FLT
c_func
(paren
l_string|&quot;BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x&bslash;n&quot;
comma
id|data_len
op_plus
id|bss_len
op_plus
id|stack_len
comma
id|datapos
)paren
suffix:semicolon
id|fpos
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BINFMT_ZFLAT
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GZDATA
)paren
(brace
id|result
op_assign
id|decompress_exec
c_func
(paren
id|bprm
comma
id|fpos
comma
(paren
r_char
op_star
)paren
id|datapos
comma
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|result
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
(paren
r_char
op_star
)paren
id|datapos
comma
id|data_len
op_plus
id|extra
comma
op_amp
id|fpos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to read data+bss, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|result
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|textpos
comma
id|text_len
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|datapos
comma
id|data_len
op_plus
id|extra
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|reloc
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|datapos
op_plus
(paren
id|ntohl
c_func
(paren
id|hdr-&gt;reloc_start
)paren
op_minus
id|text_len
)paren
)paren
suffix:semicolon
id|memp
op_assign
id|datapos
suffix:semicolon
id|memkasked
op_assign
id|data_len
op_plus
id|extra
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * calculate the extra space we need to map in&n;&t;&t; */
id|extra
op_assign
id|max
c_func
(paren
id|bss_len
op_plus
id|stack_len
comma
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|textpos
op_assign
id|do_mmap
c_func
(paren
l_int|0
comma
l_int|0
comma
id|text_len
op_plus
id|data_len
op_plus
id|extra
comma
id|PROT_READ
op_or
id|PROT_EXEC
op_or
id|PROT_WRITE
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|textpos
op_logical_or
id|textpos
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|textpos
)paren
id|textpos
op_assign
(paren
r_int
r_int
)paren
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to allocate RAM for process text/data, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|textpos
)paren
suffix:semicolon
)brace
id|datapos
op_assign
id|textpos
op_plus
id|ntohl
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
id|reloc
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|textpos
op_plus
id|ntohl
c_func
(paren
id|hdr-&gt;reloc_start
)paren
)paren
suffix:semicolon
id|memp
op_assign
id|textpos
suffix:semicolon
id|memkasked
op_assign
id|text_len
op_plus
id|data_len
op_plus
id|extra
suffix:semicolon
macro_line|#ifdef CONFIG_BINFMT_ZFLAT
multiline_comment|/*&n;&t;&t; * load it all in and treat it like a RAM load from now on&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GZIP
)paren
(brace
id|result
op_assign
id|decompress_exec
c_func
(paren
id|bprm
comma
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
comma
(paren
(paren
(paren
r_char
op_star
)paren
id|textpos
)paren
op_plus
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
)paren
comma
(paren
id|text_len
op_plus
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
op_minus
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GZDATA
)paren
(brace
id|fpos
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
(paren
r_char
op_star
)paren
id|textpos
comma
id|text_len
comma
op_amp
id|fpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
id|result
op_assign
id|decompress_exec
c_func
(paren
id|bprm
comma
id|text_len
comma
(paren
r_char
op_star
)paren
id|datapos
comma
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|fpos
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
(paren
r_char
op_star
)paren
id|textpos
comma
id|text_len
op_plus
id|data_len
op_plus
id|extra
comma
op_amp
id|fpos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to read code+data+bss, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|result
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|textpos
comma
id|text_len
op_plus
id|data_len
op_plus
id|extra
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
)brace
id|DBG_FLT
c_func
(paren
l_string|&quot;Mapping is %x, Entry point is %x, data_start is %x&bslash;n&quot;
comma
id|textpos
comma
id|ntohl
c_func
(paren
id|hdr-&gt;entry
)paren
comma
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
)paren
suffix:semicolon
id|current-&gt;mm-&gt;start_code
op_assign
id|textpos
op_plus
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
id|textpos
op_plus
id|text_len
suffix:semicolon
id|current-&gt;mm-&gt;start_data
op_assign
id|datapos
suffix:semicolon
id|current-&gt;mm-&gt;end_data
op_assign
id|datapos
op_plus
id|data_len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;set up the brk stuff (uses any slack left in data/bss/stack allocation&n;&t; *&t;We put the brk after the bss (between the bss and stack) like other&n;&t; *&t;platforms.&n;&t; */
id|current-&gt;mm-&gt;start_brk
op_assign
id|datapos
op_plus
id|data_len
op_plus
id|bss_len
suffix:semicolon
id|current-&gt;mm-&gt;brk
op_assign
(paren
id|current-&gt;mm-&gt;start_brk
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
id|current-&gt;mm-&gt;context.end_brk
op_assign
id|memp
op_plus
id|ksize
c_func
(paren
(paren
r_void
op_star
)paren
id|memp
)paren
op_minus
id|stack_len
suffix:semicolon
id|current-&gt;mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;Load %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x&bslash;n&quot;
comma
id|bprm-&gt;filename
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_code
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_code
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_data
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_data
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;end_data
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;brk
)paren
suffix:semicolon
id|text_len
op_sub_assign
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
suffix:semicolon
multiline_comment|/* the real code len */
multiline_comment|/*&n;&t; * We just load the allocations into some temporary memory to&n;&t; * help simplify all this mumbo jumbo&n;&t; *&n;&t; * We&squot;ve got two different sections of relocation entries.&n;&t; * The first is the GOT which resides at the begining of the data segment&n;&t; * and is terminated with a -1.  This one can be relocated in place.&n;&t; * The second is the extra relocation entries tacked after the image&squot;s&n;&t; * data segment. These require a little more processing as the entry is&n;&t; * really an offset into the image which contains an offset into the&n;&t; * image.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GOTPIC
)paren
(brace
r_for
c_loop
(paren
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|datapos
suffix:semicolon
op_star
id|rp
op_ne
l_int|0xffffffff
suffix:semicolon
id|rp
op_increment
)paren
op_star
id|rp
op_assign
id|calc_reloc
c_func
(paren
op_star
id|rp
comma
id|text_len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now run through the relocation entries.&n;&t; * We&squot;ve got to be careful here as C++ produces relocatable zero&n;&t; * entries in the constructor and destructor tables which are then&n;&t; * tested for being not zero (which will always occur unless we&squot;re&n;&t; * based from address zero).  This causes an endless loop as __start&n;&t; * is at zero.  The solution used is to not relocate zero addresses.&n;&t; * This has the negative side effect of not allowing a global data&n;&t; * reference to be statically initialised to _stext (I&squot;ve moved&n;&t; * __start to address 4 so that is okay).&n;&t; */
r_if
c_cond
(paren
id|rev
OG
id|OLD_FLAT_VERSION
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|relocs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
multiline_comment|/* Get the address of the pointer to be&n;&t;&t;&t;   relocated (of course, the address has to be&n;&t;&t;&t;   relocated first).  */
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|calc_reloc
c_func
(paren
id|ntohl
c_func
(paren
id|reloc
(braket
id|i
)braket
)paren
comma
id|text_len
)paren
suffix:semicolon
multiline_comment|/* Get the pointer&squot;s value.  */
id|addr
op_assign
id|get_unaligned
(paren
id|rp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do the relocation.  PIC relocs in the data section are&n;&t;&t;&t;&t; * already in target order&n;&t;&t;&t;&t; */
id|addr
op_assign
id|calc_reloc
c_func
(paren
(paren
id|flags
op_amp
id|FLAT_FLAG_GOTPIC
)paren
ques
c_cond
id|addr
suffix:colon
id|ntohl
c_func
(paren
id|addr
)paren
comma
id|text_len
)paren
suffix:semicolon
multiline_comment|/* Write back the relocated pointer.  */
id|put_unaligned
(paren
id|addr
comma
id|rp
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|relocs
suffix:semicolon
id|i
op_increment
)paren
id|old_reloc
c_func
(paren
id|ntohl
c_func
(paren
id|reloc
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* zero the BSS,  BRK and stack areas */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|datapos
op_plus
id|data_len
)paren
comma
l_int|0
comma
id|bss_len
op_plus
(paren
id|current-&gt;mm-&gt;context.end_brk
op_minus
id|current-&gt;mm-&gt;start_brk
)paren
op_plus
id|stack_len
)paren
suffix:semicolon
id|compute_creds
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
id|flush_icache_range
c_func
(paren
id|current-&gt;mm-&gt;start_code
comma
id|current-&gt;mm-&gt;end_code
)paren
suffix:semicolon
id|set_binfmt
c_func
(paren
op_amp
id|flat_format
)paren
suffix:semicolon
id|p
op_assign
(paren
(paren
id|current-&gt;mm-&gt;context.end_brk
op_plus
id|stack_len
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
op_minus
l_int|4
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;p=%x&bslash;n&quot;
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* copy the arg pages onto the stack, this could be more efficient :-) */
r_for
c_loop
(paren
id|i
op_assign
id|TOP_OF_ARGS
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
id|bprm-&gt;p
suffix:semicolon
id|i
op_decrement
)paren
op_star
(paren
r_char
op_star
)paren
op_decrement
id|p
op_assign
(paren
(paren
r_char
op_star
)paren
id|page_address
c_func
(paren
id|bprm-&gt;page
(braket
id|i
op_div
id|PAGE_SIZE
)braket
)paren
)paren
(braket
id|i
op_mod
id|PAGE_SIZE
)braket
suffix:semicolon
id|current-&gt;mm-&gt;start_stack
op_assign
(paren
r_int
r_int
)paren
id|create_flat_tables
c_func
(paren
id|p
comma
id|bprm
)paren
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)&bslash;n&quot;
comma
id|regs
comma
id|textpos
op_plus
id|ntohl
c_func
(paren
id|hdr-&gt;entry
)paren
comma
id|current-&gt;mm-&gt;start_stack
)paren
suffix:semicolon
id|start_thread
c_func
(paren
id|regs
comma
id|textpos
op_plus
id|ntohl
c_func
(paren
id|hdr-&gt;entry
)paren
comma
id|current-&gt;mm-&gt;start_stack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|load_flat_library
r_static
r_int
id|load_flat_library
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
DECL|function|init_flat_binfmt
r_static
r_int
id|__init
id|init_flat_binfmt
c_func
(paren
r_void
)paren
(brace
r_return
id|register_binfmt
c_func
(paren
op_amp
id|flat_format
)paren
suffix:semicolon
)brace
DECL|function|exit_flat_binfmt
r_static
r_void
id|__exit
id|exit_flat_binfmt
c_func
(paren
r_void
)paren
(brace
id|unregister_binfmt
c_func
(paren
op_amp
id|flat_format
)paren
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|variable|init_flat_binfmt
id|module_init
c_func
(paren
id|init_flat_binfmt
)paren
suffix:semicolon
DECL|variable|exit_flat_binfmt
id|module_exit
c_func
(paren
id|exit_flat_binfmt
)paren
suffix:semicolon
eof
