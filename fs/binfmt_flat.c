multiline_comment|/****************************************************************************/
multiline_comment|/*&n; *  linux/fs/binfmt_flat.c&n; *&n; *&t;Copyright (C) 2000-2003 David McCullough &lt;davidm@snapgear.com&gt;&n; *&t;Copyright (C) 2002 Greg Ungerer &lt;gerg@snapgear.com&gt;&n; *&t;Copyright (C) 2002 SnapGear, by Paul Dale &lt;pauli@snapgear.com&gt;&n; *&t;Copyright (C) 2000, 2001 Lineo, by David McCullough &lt;davidm@lineo.com&gt;&n; *  based heavily on:&n; *&n; *  linux/fs/binfmt_aout.c:&n; *      Copyright (C) 1991, 1992, 1996  Linus Torvalds&n; *  linux/fs/binfmt_flat.c for 2.0 kernel&n; *&t;    Copyright (C) 1998  Kenneth Albanowski &lt;kjahds@kjahds.com&gt;&n; *&t;JAN/99 -- coded full program relocation (gerg@snapgear.com)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/flat.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/cacheflush.h&gt;
multiline_comment|/****************************************************************************/
macro_line|#if 0
mdefine_line|#define DEBUG 1
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|DBG_FLT
mdefine_line|#define&t;DBG_FLT(a...)&t;printk(a)
macro_line|#else
DECL|macro|DBG_FLT
mdefine_line|#define&t;DBG_FLT(a...)
macro_line|#endif
DECL|macro|RELOC_FAILED
mdefine_line|#define RELOC_FAILED 0xff00ff01&t;&t;/* Relocation incorrect somewhere */
DECL|macro|UNLOADED_LIB
mdefine_line|#define UNLOADED_LIB 0x7ff000ff&t;&t;/* Placeholder for unused library */
DECL|struct|lib_info
r_struct
id|lib_info
(brace
r_struct
(brace
DECL|member|start_code
r_int
r_int
id|start_code
suffix:semicolon
multiline_comment|/* Start of text segment */
DECL|member|start_data
r_int
r_int
id|start_data
suffix:semicolon
multiline_comment|/* Start of data segment */
DECL|member|start_brk
r_int
r_int
id|start_brk
suffix:semicolon
multiline_comment|/* End of data segment */
DECL|member|text_len
r_int
r_int
id|text_len
suffix:semicolon
multiline_comment|/* Length of text segment */
DECL|member|entry
r_int
r_int
id|entry
suffix:semicolon
multiline_comment|/* Start address for this module */
DECL|member|build_date
r_int
r_int
id|build_date
suffix:semicolon
multiline_comment|/* When this one was compiled */
DECL|member|loaded
r_int
id|loaded
suffix:semicolon
multiline_comment|/* Has this library been loaded? */
DECL|member|lib_list
)brace
id|lib_list
(braket
id|MAX_SHARED_LIBS
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_BINFMT_SHARED_FLAT
r_static
r_int
id|load_flat_shared_library
c_func
(paren
r_int
id|id
comma
r_struct
id|lib_info
op_star
id|p
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|load_flat_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|flat_core_dump
c_func
(paren
r_int
id|signr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_extern
r_void
id|dump_thread
c_func
(paren
r_struct
id|pt_regs
op_star
comma
r_struct
id|user
op_star
)paren
suffix:semicolon
DECL|variable|flat_format
r_static
r_struct
id|linux_binfmt
id|flat_format
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|load_binary
op_assign
id|load_flat_binary
comma
dot
id|core_dump
op_assign
id|flat_core_dump
comma
dot
id|min_coredump
op_assign
id|PAGE_SIZE
)brace
suffix:semicolon
multiline_comment|/****************************************************************************/
multiline_comment|/*&n; * Routine writes a core dump image in the current directory.&n; * Currently only a stub-function.&n; */
DECL|function|flat_core_dump
r_static
r_int
id|flat_core_dump
c_func
(paren
r_int
id|signr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Process %s:%d received signr %d and should have core dumped&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
r_int
)paren
id|signr
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
multiline_comment|/*&n; * create_flat_tables() parses the env- and arg-strings in new user&n; * memory and creates the pointer tables from them, and puts their&n; * addresses on the &quot;stack&quot;, returning the new stack pointer value.&n; */
DECL|function|create_flat_tables
r_static
r_int
r_int
id|create_flat_tables
c_func
(paren
r_int
r_int
id|pp
comma
r_struct
id|linux_binprm
op_star
id|bprm
)paren
(brace
r_int
r_int
op_star
id|argv
comma
op_star
id|envp
suffix:semicolon
r_int
r_int
op_star
id|sp
suffix:semicolon
r_char
op_star
id|p
op_assign
(paren
r_char
op_star
)paren
id|pp
suffix:semicolon
r_int
id|argc
op_assign
id|bprm-&gt;argc
suffix:semicolon
r_int
id|envc
op_assign
id|bprm-&gt;envc
suffix:semicolon
r_char
id|dummy
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
(paren
op_minus
(paren
r_int
r_int
)paren
r_sizeof
(paren
r_char
op_star
)paren
)paren
op_amp
(paren
r_int
r_int
)paren
id|p
)paren
suffix:semicolon
id|sp
op_sub_assign
id|envc
op_plus
l_int|1
suffix:semicolon
id|envp
op_assign
id|sp
suffix:semicolon
id|sp
op_sub_assign
id|argc
op_plus
l_int|1
suffix:semicolon
id|argv
op_assign
id|sp
suffix:semicolon
id|flat_stack_align
c_func
(paren
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flat_argvp_envp_on_stack
c_func
(paren
)paren
)paren
(brace
op_decrement
id|sp
suffix:semicolon
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|envp
comma
id|sp
)paren
suffix:semicolon
op_decrement
id|sp
suffix:semicolon
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|argv
comma
id|sp
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|argc
comma
op_decrement
id|sp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_start
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
OG
l_int|0
)paren
(brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|p
comma
id|argv
op_increment
)paren
suffix:semicolon
r_do
(brace
id|get_user
c_func
(paren
id|dummy
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dummy
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
l_int|NULL
comma
id|argv
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_end
op_assign
id|current-&gt;mm-&gt;env_start
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_while
c_loop
(paren
id|envc
op_decrement
OG
l_int|0
)paren
(brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
id|p
comma
id|envp
)paren
suffix:semicolon
id|envp
op_increment
suffix:semicolon
r_do
(brace
id|get_user
c_func
(paren
id|dummy
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dummy
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
(paren
r_int
r_int
)paren
l_int|NULL
comma
id|envp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;env_end
op_assign
(paren
r_int
r_int
)paren
id|p
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
macro_line|#ifdef CONFIG_BINFMT_ZFLAT
macro_line|#include &lt;linux/zlib.h&gt;
DECL|macro|LBUFSIZE
mdefine_line|#define LBUFSIZE&t;4000
multiline_comment|/* gzip flag byte */
DECL|macro|ASCII_FLAG
mdefine_line|#define ASCII_FLAG   0x01 /* bit 0 set: file probably ASCII text */
DECL|macro|CONTINUATION
mdefine_line|#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
DECL|macro|EXTRA_FIELD
mdefine_line|#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
DECL|macro|ORIG_NAME
mdefine_line|#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
DECL|macro|COMMENT
mdefine_line|#define COMMENT      0x10 /* bit 4 set: file comment present */
DECL|macro|ENCRYPTED
mdefine_line|#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
DECL|macro|RESERVED
mdefine_line|#define RESERVED     0xC0 /* bit 6,7:   reserved */
DECL|function|decompress_exec
r_static
r_int
id|decompress_exec
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_int
r_int
id|offset
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
id|fd
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
id|z_stream
id|strm
suffix:semicolon
id|loff_t
id|fpos
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;decompress_exec(offset=%x,buf=%x,len=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
(paren
r_int
)paren
id|dst
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|strm
comma
l_int|0
comma
r_sizeof
(paren
id|strm
)paren
)paren
suffix:semicolon
id|strm.workspace
op_assign
id|kmalloc
c_func
(paren
id|zlib_inflate_workspacesize
c_func
(paren
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strm.workspace
op_eq
l_int|NULL
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: no memory for decompress workspace&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|buf
op_assign
id|kmalloc
c_func
(paren
id|LBUFSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: no memory for read buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Read in first chunk of data and parse gzip header. */
id|fpos
op_assign
id|offset
suffix:semicolon
id|ret
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
id|buf
comma
id|LBUFSIZE
comma
op_amp
id|fpos
)paren
suffix:semicolon
id|strm.next_in
op_assign
id|buf
suffix:semicolon
id|strm.avail_in
op_assign
id|ret
suffix:semicolon
id|strm.total_in
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check minimum size -- gzip header */
r_if
c_cond
(paren
id|ret
OL
l_int|10
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: file too small?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Check gzip magic number */
r_if
c_cond
(paren
(paren
id|buf
(braket
l_int|0
)braket
op_ne
l_int|037
)paren
op_logical_or
(paren
(paren
id|buf
(braket
l_int|1
)braket
op_ne
l_int|0213
)paren
op_logical_and
(paren
id|buf
(braket
l_int|1
)braket
op_ne
l_int|0236
)paren
)paren
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: unknown compression magic?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Check gzip method */
r_if
c_cond
(paren
id|buf
(braket
l_int|2
)braket
op_ne
l_int|8
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: unknown compression method?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Check gzip flags */
r_if
c_cond
(paren
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|ENCRYPTED
)paren
op_logical_or
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|CONTINUATION
)paren
op_logical_or
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|RESERVED
)paren
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: unknown flags?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
id|ret
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|EXTRA_FIELD
)paren
(brace
id|ret
op_add_assign
l_int|2
op_plus
id|buf
(braket
l_int|10
)braket
op_plus
(paren
id|buf
(braket
l_int|11
)braket
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|LBUFSIZE
op_eq
id|ret
)paren
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: buffer overflow (EXTRA)?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|ORIG_NAME
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|ret
OL
id|LBUFSIZE
op_logical_and
(paren
id|buf
(braket
id|ret
)braket
op_ne
l_int|0
)paren
suffix:semicolon
id|ret
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|LBUFSIZE
op_eq
id|ret
)paren
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: buffer overflow (ORIG_NAME)?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
id|COMMENT
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|ret
OL
id|LBUFSIZE
op_logical_and
(paren
id|buf
(braket
id|ret
)braket
op_ne
l_int|0
)paren
suffix:semicolon
id|ret
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|LBUFSIZE
op_eq
id|ret
)paren
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: buffer overflow (COMMENT)?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
)brace
id|strm.next_in
op_add_assign
id|ret
suffix:semicolon
id|strm.avail_in
op_sub_assign
id|ret
suffix:semicolon
id|strm.next_out
op_assign
id|dst
suffix:semicolon
id|strm.avail_out
op_assign
id|len
suffix:semicolon
id|strm.total_out
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|zlib_inflateInit2
c_func
(paren
op_amp
id|strm
comma
op_minus
id|MAX_WBITS
)paren
op_ne
id|Z_OK
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: zlib init failed?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ret
op_assign
id|zlib_inflate
c_func
(paren
op_amp
id|strm
comma
id|Z_NO_FLUSH
)paren
)paren
op_eq
id|Z_OK
)paren
(brace
id|ret
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
id|buf
comma
id|LBUFSIZE
comma
op_amp
id|fpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
r_break
suffix:semicolon
id|len
op_sub_assign
id|ret
suffix:semicolon
id|strm.next_in
op_assign
id|buf
suffix:semicolon
id|strm.avail_in
op_assign
id|ret
suffix:semicolon
id|strm.total_in
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|DBG_FLT
c_func
(paren
l_string|&quot;binfmt_flat: decompression failed (%d), %s&bslash;n&quot;
comma
id|ret
comma
id|strm.msg
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
id|zlib_inflateEnd
c_func
(paren
op_amp
id|strm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|strm.workspace
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BINFMT_ZFLAT */
multiline_comment|/****************************************************************************/
r_static
r_int
r_int
DECL|function|calc_reloc
id|calc_reloc
c_func
(paren
r_int
r_int
id|r
comma
r_struct
id|lib_info
op_star
id|p
comma
r_int
id|curid
comma
r_int
id|internalp
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|id
suffix:semicolon
r_int
r_int
id|start_brk
suffix:semicolon
r_int
r_int
id|start_data
suffix:semicolon
r_int
r_int
id|text_len
suffix:semicolon
r_int
r_int
id|start_code
suffix:semicolon
macro_line|#ifdef CONFIG_BINFMT_SHARED_FLAT
r_if
c_cond
(paren
id|r
op_eq
l_int|0
)paren
id|id
op_assign
id|curid
suffix:semicolon
multiline_comment|/* Relocs of 0 are always self referring */
r_else
(brace
id|id
op_assign
(paren
id|r
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* Find ID for this reloc */
id|r
op_and_assign
l_int|0x00ffffff
suffix:semicolon
multiline_comment|/* Trim ID off here */
)brace
r_if
c_cond
(paren
id|id
op_ge
id|MAX_SHARED_LIBS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: reference 0x%x to shared library %d&quot;
comma
(paren
r_int
)paren
id|r
comma
id|id
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curid
op_ne
id|id
)paren
(brace
r_if
c_cond
(paren
id|internalp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: reloc address 0x%x not in same module &quot;
l_string|&quot;(%d != %d)&quot;
comma
(paren
r_int
)paren
id|r
comma
id|curid
comma
id|id
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;lib_list
(braket
id|id
)braket
dot
id|loaded
op_logical_and
id|load_flat_shared_library
c_func
(paren
id|id
comma
id|p
)paren
OG
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: failed to load library %d&quot;
comma
id|id
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
multiline_comment|/* Check versioning information (i.e. time stamps) */
r_if
c_cond
(paren
id|p-&gt;lib_list
(braket
id|id
)braket
dot
id|build_date
op_logical_and
id|p-&gt;lib_list
(braket
id|curid
)braket
dot
id|build_date
op_logical_and
id|p-&gt;lib_list
(braket
id|curid
)braket
dot
id|build_date
OL
id|p-&gt;lib_list
(braket
id|id
)braket
dot
id|build_date
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: library %d is younger than %d&quot;
comma
id|id
comma
id|curid
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
)brace
macro_line|#else
id|id
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|start_brk
op_assign
id|p-&gt;lib_list
(braket
id|id
)braket
dot
id|start_brk
suffix:semicolon
id|start_data
op_assign
id|p-&gt;lib_list
(braket
id|id
)braket
dot
id|start_data
suffix:semicolon
id|start_code
op_assign
id|p-&gt;lib_list
(braket
id|id
)braket
dot
id|start_code
suffix:semicolon
id|text_len
op_assign
id|p-&gt;lib_list
(braket
id|id
)braket
dot
id|text_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flat_reloc_valid
c_func
(paren
id|r
comma
id|start_brk
op_minus
id|start_data
op_plus
id|text_len
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: reloc outside program 0x%x (0 - 0x%x/0x%x)&quot;
comma
(paren
r_int
)paren
id|r
comma
(paren
r_int
)paren
(paren
id|start_brk
op_minus
id|start_code
)paren
comma
(paren
r_int
)paren
id|text_len
)paren
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
OL
id|text_len
)paren
multiline_comment|/* In text segment */
id|addr
op_assign
id|r
op_plus
id|start_code
suffix:semicolon
r_else
multiline_comment|/* In data segment */
id|addr
op_assign
id|r
op_minus
id|text_len
op_plus
id|start_data
suffix:semicolon
multiline_comment|/* Range checked already above so doing the range tests is redundant...*/
r_return
id|addr
suffix:semicolon
id|failed
suffix:colon
id|printk
c_func
(paren
l_string|&quot;, killing %s!&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
id|RELOC_FAILED
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
DECL|function|old_reloc
r_void
id|old_reloc
c_func
(paren
r_int
r_int
id|rl
)paren
(brace
macro_line|#ifdef DEBUG
r_char
op_star
id|segment
(braket
)braket
op_assign
(brace
l_string|&quot;TEXT&quot;
comma
l_string|&quot;DATA&quot;
comma
l_string|&quot;BSS&quot;
comma
l_string|&quot;*UNKNOWN*&quot;
)brace
suffix:semicolon
macro_line|#endif
id|flat_v2_reloc_t
id|r
suffix:semicolon
r_int
r_int
op_star
id|ptr
suffix:semicolon
id|r.value
op_assign
id|rl
suffix:semicolon
macro_line|#if defined(CONFIG_COLDFIRE)
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|current-&gt;mm-&gt;start_code
op_plus
id|r.reloc.offset
)paren
suffix:semicolon
macro_line|#else
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|current-&gt;mm-&gt;start_data
op_plus
id|r.reloc.offset
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Relocation of variable at DATASEG+%x &quot;
l_string|&quot;(address %p, currently %x) into segment %s&bslash;n&quot;
comma
id|r.reloc.offset
comma
id|ptr
comma
(paren
r_int
)paren
op_star
id|ptr
comma
id|segment
(braket
id|r.reloc.type
)braket
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|r.reloc.type
)paren
(brace
r_case
id|OLD_FLAT_RELOC_TYPE_TEXT
suffix:colon
op_star
id|ptr
op_add_assign
id|current-&gt;mm-&gt;start_code
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OLD_FLAT_RELOC_TYPE_DATA
suffix:colon
op_star
id|ptr
op_add_assign
id|current-&gt;mm-&gt;start_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OLD_FLAT_RELOC_TYPE_BSS
suffix:colon
op_star
id|ptr
op_add_assign
id|current-&gt;mm-&gt;end_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: Unknown relocation type=%x&bslash;n&quot;
comma
id|r.reloc.type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Relocation became %x&bslash;n&quot;
comma
(paren
r_int
)paren
op_star
id|ptr
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/****************************************************************************/
DECL|function|load_flat_file
r_static
r_int
id|load_flat_file
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|lib_info
op_star
id|libinfo
comma
r_int
id|id
comma
r_int
r_int
op_star
id|extra_stack
)paren
(brace
r_struct
id|flat_hdr
op_star
id|hdr
suffix:semicolon
r_int
r_int
id|textpos
op_assign
l_int|0
comma
id|datapos
op_assign
l_int|0
comma
id|result
suffix:semicolon
r_int
r_int
id|realdatastart
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|text_len
comma
id|data_len
comma
id|bss_len
comma
id|stack_len
comma
id|flags
suffix:semicolon
r_int
r_int
id|memp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for finding the brk area */
r_int
r_int
id|extra
comma
id|rlim
suffix:semicolon
r_int
r_int
op_star
id|reloc
op_assign
l_int|0
comma
op_star
id|rp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|i
comma
id|rev
comma
id|relocs
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|fpos
suffix:semicolon
r_int
r_int
id|start_code
comma
id|end_code
suffix:semicolon
id|hdr
op_assign
(paren
(paren
r_struct
id|flat_hdr
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
multiline_comment|/* exec-header */
id|inode
op_assign
id|bprm-&gt;file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|text_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
id|data_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;data_end
)paren
op_minus
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
id|bss_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;bss_end
)paren
op_minus
id|ntohl
c_func
(paren
id|hdr-&gt;data_end
)paren
suffix:semicolon
id|stack_len
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;stack_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|extra_stack
)paren
(brace
id|stack_len
op_add_assign
op_star
id|extra_stack
suffix:semicolon
op_star
id|extra_stack
op_assign
id|stack_len
suffix:semicolon
)brace
id|relocs
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;reloc_count
)paren
suffix:semicolon
id|flags
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;flags
)paren
suffix:semicolon
id|rev
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;rev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_KTRACE
)paren
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: Loading file: %s&bslash;n&quot;
comma
id|bprm-&gt;filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|hdr-&gt;magic
comma
l_string|&quot;bFLT&quot;
comma
l_int|4
)paren
op_logical_or
(paren
id|rev
op_ne
id|FLAT_VERSION
op_logical_and
id|rev
op_ne
id|OLD_FLAT_VERSION
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * because a lot of people do not manage to produce good&n;&t;&t; * flat binaries,  we leave this printk to help them realise&n;&t;&t; * the problem.  We only print the error if its not a script file&n;&t;&t; */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|hdr-&gt;magic
comma
l_string|&quot;#!&quot;
comma
l_int|2
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: bad magic/rev (0x%x, need 0x%x)&bslash;n&quot;
comma
id|rev
comma
(paren
r_int
)paren
id|FLAT_VERSION
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t allow old format executables to use shared libraries */
r_if
c_cond
(paren
id|rev
op_eq
id|OLD_FLAT_VERSION
op_logical_and
id|id
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BINFMT_FLAT: shared libraries are not available before rev 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|FLAT_VERSION
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * fix up the flags for the older format,  there were all kinds&n;&t; * of endian hacks,  this only works for the simple cases&n;&t; */
r_if
c_cond
(paren
id|rev
op_eq
id|OLD_FLAT_VERSION
op_logical_and
id|flat_old_ram_flag
c_func
(paren
id|flags
)paren
)paren
id|flags
op_assign
id|FLAT_FLAG_RAM
suffix:semicolon
macro_line|#ifndef CONFIG_BINFMT_ZFLAT
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|FLAT_FLAG_GZIP
op_or
id|FLAT_FLAG_GZDATA
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Support for ZFLAT executables is not enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Check initial limits. This avoids letting people circumvent&n;&t; * size limits imposed on them by creating programs with large&n;&t; * arrays in the data or bss.&n;&t; */
id|rlim
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_DATA
)braket
dot
id|rlim_cur
suffix:semicolon
r_if
c_cond
(paren
id|rlim
op_ge
id|RLIM_INFINITY
)paren
id|rlim
op_assign
op_complement
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|data_len
op_plus
id|bss_len
OG
id|rlim
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* Flush all traces of the currently running executable */
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
id|result
op_assign
id|flush_old_exec
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_return
id|result
suffix:semicolon
multiline_comment|/* OK, This is the point of no return */
id|set_personality
c_func
(paren
id|PER_LINUX
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * calculate the extra space we need to map in&n;&t; */
id|extra
op_assign
id|max
c_func
(paren
id|bss_len
op_plus
id|stack_len
comma
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * there are a couple of cases here,  the separate code/data&n;&t; * case,  and then the fully copied to RAM case which lumps&n;&t; * it all together.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|FLAT_FLAG_RAM
op_or
id|FLAT_FLAG_GZIP
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * this should give us a ROM ptr,  but if it doesn&squot;t we don&squot;t&n;&t;&t; * really care&n;&t;&t; */
id|DBG_FLT
c_func
(paren
l_string|&quot;BINFMT_FLAT: ROM mapping of file (we hope)&bslash;n&quot;
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|textpos
op_assign
id|do_mmap
c_func
(paren
id|bprm-&gt;file
comma
l_int|0
comma
id|text_len
comma
id|PROT_READ
op_or
id|PROT_EXEC
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|textpos
op_logical_or
id|textpos
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|textpos
)paren
id|textpos
op_assign
(paren
r_int
r_int
)paren
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to mmap process text, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|textpos
)paren
suffix:semicolon
r_return
id|textpos
suffix:semicolon
)brace
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|realdatastart
op_assign
id|do_mmap
c_func
(paren
l_int|0
comma
l_int|0
comma
id|data_len
op_plus
id|extra
op_plus
id|MAX_SHARED_LIBS
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|realdatastart
op_eq
l_int|0
op_logical_or
id|realdatastart
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|realdatastart
)paren
id|realdatastart
op_assign
(paren
r_int
r_int
)paren
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to allocate RAM for process data, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|datapos
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|textpos
comma
id|text_len
)paren
suffix:semicolon
r_return
id|realdatastart
suffix:semicolon
)brace
id|datapos
op_assign
id|realdatastart
op_plus
id|MAX_SHARED_LIBS
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;BINFMT_FLAT: Allocated data+bss+stack (%d bytes): %x&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
id|data_len
op_plus
id|bss_len
op_plus
id|stack_len
)paren
comma
(paren
r_int
)paren
id|datapos
)paren
suffix:semicolon
id|fpos
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BINFMT_ZFLAT
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GZDATA
)paren
(brace
id|result
op_assign
id|decompress_exec
c_func
(paren
id|bprm
comma
id|fpos
comma
(paren
r_char
op_star
)paren
id|datapos
comma
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|result
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
(paren
r_char
op_star
)paren
id|datapos
comma
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
op_amp
id|fpos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to read data+bss, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|result
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|textpos
comma
id|text_len
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|realdatastart
comma
id|data_len
op_plus
id|extra
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|reloc
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|datapos
op_plus
(paren
id|ntohl
c_func
(paren
id|hdr-&gt;reloc_start
)paren
op_minus
id|text_len
)paren
)paren
suffix:semicolon
id|memp
op_assign
id|realdatastart
suffix:semicolon
)brace
r_else
(brace
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|textpos
op_assign
id|do_mmap
c_func
(paren
l_int|0
comma
l_int|0
comma
id|text_len
op_plus
id|data_len
op_plus
id|extra
op_plus
id|MAX_SHARED_LIBS
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
id|PROT_READ
op_or
id|PROT_EXEC
op_or
id|PROT_WRITE
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|textpos
op_logical_or
id|textpos
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|textpos
)paren
id|textpos
op_assign
(paren
r_int
r_int
)paren
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to allocate RAM for process text/data, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|textpos
)paren
suffix:semicolon
r_return
id|textpos
suffix:semicolon
)brace
id|realdatastart
op_assign
id|textpos
op_plus
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
id|datapos
op_assign
id|realdatastart
op_plus
id|MAX_SHARED_LIBS
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|reloc
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|textpos
op_plus
id|ntohl
c_func
(paren
id|hdr-&gt;reloc_start
)paren
op_plus
id|MAX_SHARED_LIBS
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|memp
op_assign
id|textpos
suffix:semicolon
macro_line|#ifdef CONFIG_BINFMT_ZFLAT
multiline_comment|/*&n;&t;&t; * load it all in and treat it like a RAM load from now on&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GZIP
)paren
(brace
id|result
op_assign
id|decompress_exec
c_func
(paren
id|bprm
comma
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
comma
(paren
(paren
(paren
r_char
op_star
)paren
id|textpos
)paren
op_plus
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
)paren
comma
(paren
id|text_len
op_plus
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
op_minus
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|memmove
c_func
(paren
(paren
r_void
op_star
)paren
id|datapos
comma
(paren
r_void
op_star
)paren
id|realdatastart
comma
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GZDATA
)paren
(brace
id|fpos
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
(paren
r_char
op_star
)paren
id|textpos
comma
id|text_len
comma
op_amp
id|fpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
id|result
op_assign
id|decompress_exec
c_func
(paren
id|bprm
comma
id|text_len
comma
(paren
r_char
op_star
)paren
id|datapos
comma
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|fpos
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
(paren
r_char
op_star
)paren
id|textpos
comma
id|text_len
comma
op_amp
id|fpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
id|fpos
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
suffix:semicolon
id|result
op_assign
id|bprm-&gt;file-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|bprm-&gt;file
comma
(paren
r_char
op_star
)paren
id|datapos
comma
id|data_len
op_plus
(paren
id|relocs
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
comma
op_amp
id|fpos
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_ge
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to read code+data+bss, errno %d&bslash;n&quot;
comma
(paren
r_int
)paren
op_minus
id|result
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|current-&gt;mm
comma
id|textpos
comma
id|text_len
op_plus
id|data_len
op_plus
id|extra
op_plus
id|MAX_SHARED_LIBS
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_KTRACE
)paren
id|printk
c_func
(paren
l_string|&quot;Mapping is %x, Entry point is %x, data_start is %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|textpos
comma
l_int|0x00ffffff
op_amp
id|ntohl
c_func
(paren
id|hdr-&gt;entry
)paren
comma
id|ntohl
c_func
(paren
id|hdr-&gt;data_start
)paren
)paren
suffix:semicolon
multiline_comment|/* The main program needs a little extra setup in the task structure */
id|start_code
op_assign
id|textpos
op_plus
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
suffix:semicolon
id|end_code
op_assign
id|textpos
op_plus
id|text_len
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
id|current-&gt;mm-&gt;start_code
op_assign
id|start_code
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
id|end_code
suffix:semicolon
id|current-&gt;mm-&gt;start_data
op_assign
id|datapos
suffix:semicolon
id|current-&gt;mm-&gt;end_data
op_assign
id|datapos
op_plus
id|data_len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set up the brk stuff, uses any slack left in data/bss/stack&n;&t;&t; * allocation.  We put the brk after the bss (between the bss&n;&t;&t; * and stack) like other platforms.&n;&t;&t; */
id|current-&gt;mm-&gt;start_brk
op_assign
id|datapos
op_plus
id|data_len
op_plus
id|bss_len
suffix:semicolon
id|current-&gt;mm-&gt;brk
op_assign
(paren
id|current-&gt;mm-&gt;start_brk
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
id|current-&gt;mm-&gt;context.end_brk
op_assign
id|memp
op_plus
id|ksize
c_func
(paren
(paren
r_void
op_star
)paren
id|memp
)paren
op_minus
id|stack_len
suffix:semicolon
id|current-&gt;mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_KTRACE
)paren
id|printk
c_func
(paren
l_string|&quot;%s %s: TEXT=%x-%x DATA=%x-%x BSS=%x-%x&bslash;n&quot;
comma
id|id
ques
c_cond
l_string|&quot;Lib&quot;
suffix:colon
l_string|&quot;Load&quot;
comma
id|bprm-&gt;filename
comma
(paren
r_int
)paren
id|start_code
comma
(paren
r_int
)paren
id|end_code
comma
(paren
r_int
)paren
id|datapos
comma
(paren
r_int
)paren
(paren
id|datapos
op_plus
id|data_len
)paren
comma
(paren
r_int
)paren
(paren
id|datapos
op_plus
id|data_len
)paren
comma
(paren
r_int
)paren
(paren
(paren
(paren
id|datapos
op_plus
id|data_len
op_plus
id|bss_len
)paren
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
id|text_len
op_sub_assign
r_sizeof
(paren
r_struct
id|flat_hdr
)paren
suffix:semicolon
multiline_comment|/* the real code len */
multiline_comment|/* Store the current module values into the global library structure */
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|start_code
op_assign
id|start_code
suffix:semicolon
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|start_data
op_assign
id|datapos
suffix:semicolon
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|start_brk
op_assign
id|datapos
op_plus
id|data_len
op_plus
id|bss_len
suffix:semicolon
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|text_len
op_assign
id|text_len
suffix:semicolon
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|loaded
op_assign
l_int|1
suffix:semicolon
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|entry
op_assign
(paren
l_int|0x00ffffff
op_amp
id|ntohl
c_func
(paren
id|hdr-&gt;entry
)paren
)paren
op_plus
id|textpos
suffix:semicolon
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|build_date
op_assign
id|ntohl
c_func
(paren
id|hdr-&gt;build_date
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We just load the allocations into some temporary memory to&n;&t; * help simplify all this mumbo jumbo&n;&t; *&n;&t; * We&squot;ve got two different sections of relocation entries.&n;&t; * The first is the GOT which resides at the begining of the data segment&n;&t; * and is terminated with a -1.  This one can be relocated in place.&n;&t; * The second is the extra relocation entries tacked after the image&squot;s&n;&t; * data segment. These require a little more processing as the entry is&n;&t; * really an offset into the image which contains an offset into the&n;&t; * image.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|FLAT_FLAG_GOTPIC
)paren
(brace
r_for
c_loop
(paren
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|datapos
suffix:semicolon
op_star
id|rp
op_ne
l_int|0xffffffff
suffix:semicolon
id|rp
op_increment
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rp
)paren
(brace
id|addr
op_assign
id|calc_reloc
c_func
(paren
op_star
id|rp
comma
id|libinfo
comma
id|id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
id|RELOC_FAILED
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
op_star
id|rp
op_assign
id|addr
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Now run through the relocation entries.&n;&t; * We&squot;ve got to be careful here as C++ produces relocatable zero&n;&t; * entries in the constructor and destructor tables which are then&n;&t; * tested for being not zero (which will always occur unless we&squot;re&n;&t; * based from address zero).  This causes an endless loop as __start&n;&t; * is at zero.  The solution used is to not relocate zero addresses.&n;&t; * This has the negative side effect of not allowing a global data&n;&t; * reference to be statically initialised to _stext (I&squot;ve moved&n;&t; * __start to address 4 so that is okay).&n;&t; */
r_if
c_cond
(paren
id|rev
OG
id|OLD_FLAT_VERSION
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|relocs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|addr
comma
id|relval
suffix:semicolon
multiline_comment|/* Get the address of the pointer to be&n;&t;&t;&t;   relocated (of course, the address has to be&n;&t;&t;&t;   relocated first).  */
id|relval
op_assign
id|ntohl
c_func
(paren
id|reloc
(braket
id|i
)braket
)paren
suffix:semicolon
id|addr
op_assign
id|flat_get_relocate_addr
c_func
(paren
id|relval
)paren
suffix:semicolon
id|rp
op_assign
(paren
r_int
r_int
op_star
)paren
id|calc_reloc
c_func
(paren
id|addr
comma
id|libinfo
comma
id|id
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
(paren
r_int
r_int
op_star
)paren
id|RELOC_FAILED
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
multiline_comment|/* Get the pointer&squot;s value.  */
id|addr
op_assign
id|flat_get_addr_from_rp
c_func
(paren
id|rp
comma
id|relval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Do the relocation.  PIC relocs in the data section are&n;&t;&t;&t;&t; * already in target order&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FLAT_FLAG_GOTPIC
)paren
op_eq
l_int|0
)paren
id|addr
op_assign
id|ntohl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|addr
op_assign
id|calc_reloc
c_func
(paren
id|addr
comma
id|libinfo
comma
id|id
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
id|RELOC_FAILED
)paren
r_return
op_minus
id|ENOEXEC
suffix:semicolon
multiline_comment|/* Write back the relocated pointer.  */
id|flat_put_addr_at_rp
c_func
(paren
id|rp
comma
id|addr
comma
id|relval
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|relocs
suffix:semicolon
id|i
op_increment
)paren
id|old_reloc
c_func
(paren
id|ntohl
c_func
(paren
id|reloc
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|flush_icache_range
c_func
(paren
id|start_code
comma
id|end_code
)paren
suffix:semicolon
multiline_comment|/* zero the BSS,  BRK and stack areas */
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|datapos
op_plus
id|data_len
)paren
comma
l_int|0
comma
id|bss_len
op_plus
(paren
id|memp
op_plus
id|ksize
c_func
(paren
(paren
r_void
op_star
)paren
id|memp
)paren
op_minus
id|stack_len
op_minus
multiline_comment|/* end brk */
id|libinfo-&gt;lib_list
(braket
id|id
)braket
dot
id|start_brk
)paren
op_plus
multiline_comment|/* start brk */
id|stack_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
macro_line|#ifdef CONFIG_BINFMT_SHARED_FLAT
multiline_comment|/*&n; * Load a shared library into memory.  The library gets its own data&n; * segment (including bss) but not argv/argc/environ.&n; */
DECL|function|load_flat_shared_library
r_static
r_int
id|load_flat_shared_library
c_func
(paren
r_int
id|id
comma
r_struct
id|lib_info
op_star
id|libs
)paren
(brace
r_struct
id|linux_binprm
id|bprm
suffix:semicolon
r_int
id|res
suffix:semicolon
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Create the file name */
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;/lib/lib%d.so&quot;
comma
id|id
)paren
suffix:semicolon
multiline_comment|/* Open the file up */
id|bprm.filename
op_assign
id|buf
suffix:semicolon
id|bprm.file
op_assign
id|open_exec
c_func
(paren
id|bprm.filename
)paren
suffix:semicolon
id|res
op_assign
id|PTR_ERR
c_func
(paren
id|bprm.file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bprm.file
)paren
)paren
r_return
id|res
suffix:semicolon
id|res
op_assign
id|prepare_binprm
c_func
(paren
op_amp
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_le
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
id|res
op_assign
id|load_flat_file
c_func
(paren
op_amp
id|bprm
comma
id|libs
comma
id|id
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bprm.file
)paren
(brace
id|allow_write_access
c_func
(paren
id|bprm.file
)paren
suffix:semicolon
id|fput
c_func
(paren
id|bprm.file
)paren
suffix:semicolon
id|bprm.file
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BINFMT_SHARED_FLAT */
multiline_comment|/****************************************************************************/
multiline_comment|/*&n; * These are the functions used to load flat style executables and shared&n; * libraries.  There is no binary dependent code anywhere else.&n; */
DECL|function|load_flat_binary
r_static
r_int
id|load_flat_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|lib_info
id|libinfo
suffix:semicolon
r_int
r_int
id|p
op_assign
id|bprm-&gt;p
suffix:semicolon
r_int
r_int
id|stack_len
suffix:semicolon
r_int
r_int
id|start_addr
suffix:semicolon
r_int
r_int
op_star
id|sp
suffix:semicolon
r_int
id|res
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|libinfo
comma
l_int|0
comma
r_sizeof
(paren
id|libinfo
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to add the size of our arguments to our stack size&n;&t; * otherwise it&squot;s too easy for users to create stack overflows&n;&t; * by passing in a huge argument list.  And yes,  we have to be&n;&t; * pedantic and include space for the argv/envp array as it may have&n;&t; * a lot of entries.&n;&t; */
DECL|macro|TOP_OF_ARGS
mdefine_line|#define TOP_OF_ARGS (PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *))
id|stack_len
op_assign
id|TOP_OF_ARGS
op_minus
id|bprm-&gt;p
suffix:semicolon
multiline_comment|/* the strings */
id|stack_len
op_add_assign
(paren
id|bprm-&gt;argc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* the argv array */
id|stack_len
op_add_assign
(paren
id|bprm-&gt;envc
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_char
op_star
)paren
suffix:semicolon
multiline_comment|/* the envp array */
id|res
op_assign
id|load_flat_file
c_func
(paren
id|bprm
comma
op_amp
id|libinfo
comma
l_int|0
comma
op_amp
id|stack_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OG
(paren
r_int
r_int
)paren
op_minus
l_int|4096
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* Update data segment pointers for all libraries */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SHARED_LIBS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|libinfo.lib_list
(braket
id|i
)braket
dot
id|loaded
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_SHARED_LIBS
suffix:semicolon
id|j
op_increment
)paren
(paren
op_minus
(paren
id|j
op_plus
l_int|1
)paren
)paren
(braket
(paren
r_int
r_int
op_star
)paren
(paren
id|libinfo.lib_list
(braket
id|i
)braket
dot
id|start_data
)paren
)braket
op_assign
(paren
id|libinfo.lib_list
(braket
id|j
)braket
dot
id|loaded
)paren
ques
c_cond
id|libinfo.lib_list
(braket
id|j
)braket
dot
id|start_data
suffix:colon
id|UNLOADED_LIB
suffix:semicolon
id|compute_creds
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
id|set_binfmt
c_func
(paren
op_amp
id|flat_format
)paren
suffix:semicolon
id|p
op_assign
(paren
(paren
id|current-&gt;mm-&gt;context.end_brk
op_plus
id|stack_len
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
op_minus
l_int|4
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;p=%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|p
)paren
suffix:semicolon
multiline_comment|/* copy the arg pages onto the stack, this could be more efficient :-) */
r_for
c_loop
(paren
id|i
op_assign
id|TOP_OF_ARGS
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
id|bprm-&gt;p
suffix:semicolon
id|i
op_decrement
)paren
op_star
(paren
r_char
op_star
)paren
op_decrement
id|p
op_assign
(paren
(paren
r_char
op_star
)paren
id|page_address
c_func
(paren
id|bprm-&gt;page
(braket
id|i
op_div
id|PAGE_SIZE
)braket
)paren
)paren
(braket
id|i
op_mod
id|PAGE_SIZE
)braket
suffix:semicolon
id|sp
op_assign
(paren
r_int
r_int
op_star
)paren
id|create_flat_tables
c_func
(paren
id|p
comma
id|bprm
)paren
suffix:semicolon
multiline_comment|/* Fake some return addresses to ensure the call chain will&n;&t; * initialise library in order for us.  We are required to call&n;&t; * lib 1 first, then 2, ... and finally the main program (id 0).&n;&t; */
id|start_addr
op_assign
id|libinfo.lib_list
(braket
l_int|0
)braket
dot
id|entry
suffix:semicolon
macro_line|#ifdef CONFIG_BINFMT_SHARED_FLAT
r_for
c_loop
(paren
id|i
op_assign
id|MAX_SHARED_LIBS
op_minus
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|libinfo.lib_list
(braket
id|i
)braket
dot
id|loaded
)paren
(brace
multiline_comment|/* Push previos first to call address */
op_decrement
id|sp
suffix:semicolon
id|put_user
c_func
(paren
id|start_addr
comma
id|sp
)paren
suffix:semicolon
id|start_addr
op_assign
id|libinfo.lib_list
(braket
id|i
)braket
dot
id|entry
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Stash our initial stack pointer into the mm structure */
id|current-&gt;mm-&gt;start_stack
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|DBG_FLT
c_func
(paren
l_string|&quot;start_thread(regs=0x%x, entry=0x%x, start_stack=0x%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|regs
comma
(paren
r_int
)paren
id|start_addr
comma
(paren
r_int
)paren
id|current-&gt;mm-&gt;start_stack
)paren
suffix:semicolon
id|start_thread
c_func
(paren
id|regs
comma
id|start_addr
comma
id|current-&gt;mm-&gt;start_stack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
DECL|function|init_flat_binfmt
r_static
r_int
id|__init
id|init_flat_binfmt
c_func
(paren
r_void
)paren
(brace
r_return
id|register_binfmt
c_func
(paren
op_amp
id|flat_format
)paren
suffix:semicolon
)brace
DECL|function|exit_flat_binfmt
r_static
r_void
id|__exit
id|exit_flat_binfmt
c_func
(paren
r_void
)paren
(brace
id|unregister_binfmt
c_func
(paren
op_amp
id|flat_format
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************/
DECL|variable|init_flat_binfmt
id|module_init
c_func
(paren
id|init_flat_binfmt
)paren
suffix:semicolon
DECL|variable|exit_flat_binfmt
id|module_exit
c_func
(paren
id|exit_flat_binfmt
)paren
suffix:semicolon
multiline_comment|/****************************************************************************/
eof
