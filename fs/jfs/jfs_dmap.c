multiline_comment|/*&n; *   Copyright (c) International Business Machines Corp., 2000-2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_dmap.h&quot;
macro_line|#include &quot;jfs_imap.h&quot;
macro_line|#include &quot;jfs_lock.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/*&n; *&t;Debug code for double-checking block map&n; */
multiline_comment|/* #define&t;_JFS_DEBUG_DMAP&t;1 */
macro_line|#ifdef&t;_JFS_DEBUG_DMAP
DECL|macro|DBINITMAP
mdefine_line|#define DBINITMAP(size,ipbmap,results) &bslash;&n;&t;DBinitmap(size,ipbmap,results)
DECL|macro|DBALLOC
mdefine_line|#define DBALLOC(dbmap,mapsize,blkno,nblocks) &bslash;&n;&t;DBAlloc(dbmap,mapsize,blkno,nblocks)
DECL|macro|DBFREE
mdefine_line|#define DBFREE(dbmap,mapsize,blkno,nblocks) &bslash;&n;&t;DBFree(dbmap,mapsize,blkno,nblocks)
DECL|macro|DBALLOCCK
mdefine_line|#define DBALLOCCK(dbmap,mapsize,blkno,nblocks) &bslash;&n;&t;DBAllocCK(dbmap,mapsize,blkno,nblocks)
DECL|macro|DBFREECK
mdefine_line|#define DBFREECK(dbmap,mapsize,blkno,nblocks) &bslash;&n;&t;DBFreeCK(dbmap,mapsize,blkno,nblocks)
r_static
r_void
id|DBinitmap
c_func
(paren
id|s64
comma
r_struct
id|inode
op_star
comma
id|u32
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|DBAlloc
c_func
(paren
id|uint
op_star
comma
id|s64
comma
id|s64
comma
id|s64
)paren
suffix:semicolon
r_static
r_void
id|DBFree
c_func
(paren
id|uint
op_star
comma
id|s64
comma
id|s64
comma
id|s64
)paren
suffix:semicolon
r_static
r_void
id|DBAllocCK
c_func
(paren
id|uint
op_star
comma
id|s64
comma
id|s64
comma
id|s64
)paren
suffix:semicolon
r_static
r_void
id|DBFreeCK
c_func
(paren
id|uint
op_star
comma
id|s64
comma
id|s64
comma
id|s64
)paren
suffix:semicolon
macro_line|#else
DECL|macro|DBINITMAP
mdefine_line|#define DBINITMAP(size,ipbmap,results)
DECL|macro|DBALLOC
mdefine_line|#define DBALLOC(dbmap, mapsize, blkno, nblocks)
DECL|macro|DBFREE
mdefine_line|#define DBFREE(dbmap, mapsize, blkno, nblocks)
DECL|macro|DBALLOCCK
mdefine_line|#define DBALLOCCK(dbmap, mapsize, blkno, nblocks)
DECL|macro|DBFREECK
mdefine_line|#define DBFREECK(dbmap, mapsize, blkno, nblocks)
macro_line|#endif&t;&t;&t;&t;/* _JFS_DEBUG_DMAP */
multiline_comment|/*&n; *&t;SERIALIZATION of the Block Allocation Map.&n; *&n; *&t;the working state of the block allocation map is accessed in&n; *&t;two directions:&n; *&t;&n; *&t;1) allocation and free requests that start at the dmap&n; *&t;   level and move up through the dmap control pages (i.e.&n; *&t;   the vast majority of requests).&n; * &n; * &t;2) allocation requests that start at dmap control page&n; *&t;   level and work down towards the dmaps.&n; *&t;&n; *&t;the serialization scheme used here is as follows. &n; *&n; *&t;requests which start at the bottom are serialized against each &n; *&t;other through buffers and each requests holds onto its buffers &n; *&t;as it works it way up from a single dmap to the required level &n; *&t;of dmap control page.&n; *&t;requests that start at the top are serialized against each other&n; *&t;and request that start from the bottom by the multiple read/single&n; *&t;write inode lock of the bmap inode. requests starting at the top&n; *&t;take this lock in write mode while request starting at the bottom&n; *&t;take the lock in read mode.  a single top-down request may proceed&n; *&t;exclusively while multiple bottoms-up requests may proceed &n; * &t;simultaneously (under the protection of busy buffers).&n; *&t;&n; *&t;in addition to information found in dmaps and dmap control pages,&n; *&t;the working state of the block allocation map also includes read/&n; *&t;write information maintained in the bmap descriptor (i.e. total&n; *&t;free block count, allocation group level free block counts).&n; *&t;a single exclusive lock (BMAP_LOCK) is used to guard this information&n; *&t;in the face of multiple-bottoms up requests.&n; *&t;(lock ordering: IREAD_LOCK, BMAP_LOCK);&n; *&t;&n; *&t;accesses to the persistent state of the block allocation map (limited&n; *&t;to the persistent bitmaps in dmaps) is guarded by (busy) buffers.&n; */
DECL|macro|BMAP_LOCK_INIT
mdefine_line|#define BMAP_LOCK_INIT(bmp)&t;init_MUTEX(&amp;bmp-&gt;db_bmaplock)
DECL|macro|BMAP_LOCK
mdefine_line|#define BMAP_LOCK(bmp)&t;&t;down(&amp;bmp-&gt;db_bmaplock)
DECL|macro|BMAP_UNLOCK
mdefine_line|#define BMAP_UNLOCK(bmp)&t;up(&amp;bmp-&gt;db_bmaplock)
multiline_comment|/*&n; * forward references&n; */
r_static
r_void
id|dbAllocBits
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_void
id|dbSplit
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
comma
r_int
id|splitsz
comma
r_int
id|newval
)paren
suffix:semicolon
r_static
r_void
id|dbBackSplit
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
)paren
suffix:semicolon
r_static
r_void
id|dbJoin
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
comma
r_int
id|newval
)paren
suffix:semicolon
r_static
r_void
id|dbAdjTree
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
comma
r_int
id|newval
)paren
suffix:semicolon
r_static
r_int
id|dbAdjCtl
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|s64
id|blkno
comma
r_int
id|newval
comma
r_int
id|alloc
comma
r_int
id|level
)paren
suffix:semicolon
r_static
r_int
id|dbAllocAny
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|s64
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
suffix:semicolon
r_static
r_int
id|dbAllocNext
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|dbAllocNear
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
suffix:semicolon
r_static
r_int
id|dbAllocDmap
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|dbAllocDmapLev
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
r_int
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
suffix:semicolon
r_static
r_int
id|dbAllocAG
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
r_int
id|agno
comma
id|s64
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
suffix:semicolon
r_static
r_int
id|dbAllocCtl
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|s64
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
id|blkno
comma
id|s64
op_star
id|results
)paren
suffix:semicolon
r_int
id|dbExtend
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
comma
id|s64
id|addnblocks
)paren
suffix:semicolon
r_static
r_int
id|dbFindBits
c_func
(paren
id|u32
id|word
comma
r_int
id|l2nb
)paren
suffix:semicolon
r_static
r_int
id|dbFindCtl
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
r_int
id|l2nb
comma
r_int
id|level
comma
id|s64
op_star
id|blkno
)paren
suffix:semicolon
r_static
r_int
id|dbFindLeaf
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|l2nb
comma
r_int
op_star
id|leafidx
)paren
suffix:semicolon
r_static
r_void
id|dbFreeBits
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|dbFreeDmap
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|dbMaxBud
c_func
(paren
id|u8
op_star
id|cp
)paren
suffix:semicolon
id|s64
id|dbMapFileSizeToMapSize
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
)paren
suffix:semicolon
r_int
id|blkstol2
c_func
(paren
id|s64
id|nb
)paren
suffix:semicolon
r_void
id|fsDirty
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|cntlz
c_func
(paren
id|u32
id|value
)paren
suffix:semicolon
r_int
id|cnttz
c_func
(paren
id|u32
id|word
)paren
suffix:semicolon
r_static
r_int
id|dbAllocDmapBU
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|dbInitDmap
c_func
(paren
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
suffix:semicolon
r_static
r_int
id|dbInitDmapTree
c_func
(paren
id|dmap_t
op_star
id|dp
)paren
suffix:semicolon
r_static
r_int
id|dbInitTree
c_func
(paren
id|dmaptree_t
op_star
id|dtp
)paren
suffix:semicolon
r_static
r_int
id|dbInitDmapCtl
c_func
(paren
id|dmapctl_t
op_star
id|dcp
comma
r_int
id|level
comma
r_int
id|i
)paren
suffix:semicolon
r_static
r_int
id|dbGetL2AGSize
c_func
(paren
id|s64
id|nblocks
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;buddy table&n; *&n; * table used for determining buddy sizes within characters of &n; * dmap bitmap words.  the characters themselves serve as indexes&n; * into the table, with the table elements yielding the maximum&n; * binary buddy of free bits within the character.&n; */
DECL|variable|budtab
r_int
r_char
id|budtab
(braket
l_int|256
)braket
op_assign
(brace
l_int|3
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/*&n; * NAME:    &t;dbMount()&n; *&n; * FUNCTION:&t;initializate the block allocation map.&n; *&n; *&t;&t;memory is allocated for the in-core bmap descriptor and&n; *&t;&t;the in-core descriptor is initialized from disk.&n; *&n; * PARAMETERS:&n; *      ipbmap&t;-  pointer to in-core inode for the block map.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOMEM&t;- insufficient memory&n; *      EIO&t;- i/o error&n; */
DECL|function|dbMount
r_int
id|dbMount
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
)paren
(brace
id|bmap_t
op_star
id|bmp
suffix:semicolon
id|dbmap_t
op_star
id|dbmp_le
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * allocate/initialize the in-memory bmap descriptor&n;&t; */
multiline_comment|/* allocate memory for the in-memory bmap descriptor */
id|bmp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|bmap_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmp
op_eq
l_int|NULL
)paren
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* read the on-disk bmap descriptor. */
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|BMAPBLKNO
op_lshift
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2nbperpage
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|bmp
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* copy the on-disk bmap descriptor to its in-memory version. */
id|dbmp_le
op_assign
(paren
id|dbmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|bmp-&gt;db_mapsize
op_assign
id|le64_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_mapsize
)paren
suffix:semicolon
id|bmp-&gt;db_nfree
op_assign
id|le64_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_nfree
)paren
suffix:semicolon
id|bmp-&gt;db_l2nbperpage
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_l2nbperpage
)paren
suffix:semicolon
id|bmp-&gt;db_numag
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_numag
)paren
suffix:semicolon
id|bmp-&gt;db_maxlevel
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_maxlevel
)paren
suffix:semicolon
id|bmp-&gt;db_maxag
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_maxag
)paren
suffix:semicolon
id|bmp-&gt;db_agpref
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_agpref
)paren
suffix:semicolon
id|bmp-&gt;db_aglevel
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_aglevel
)paren
suffix:semicolon
id|bmp-&gt;db_agheigth
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_agheigth
)paren
suffix:semicolon
id|bmp-&gt;db_agwidth
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_agwidth
)paren
suffix:semicolon
id|bmp-&gt;db_agstart
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_agstart
)paren
suffix:semicolon
id|bmp-&gt;db_agl2size
op_assign
id|le32_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_agl2size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXAG
suffix:semicolon
id|i
op_increment
)paren
id|bmp-&gt;db_agfree
(braket
id|i
)braket
op_assign
id|le64_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_agfree
(braket
id|i
)braket
)paren
suffix:semicolon
id|bmp-&gt;db_agsize
op_assign
id|le64_to_cpu
c_func
(paren
id|dbmp_le-&gt;dn_agsize
)paren
suffix:semicolon
id|bmp-&gt;db_maxfreebud
op_assign
id|dbmp_le-&gt;dn_maxfreebud
suffix:semicolon
multiline_comment|/* release the buffer. */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* bind the bmap inode and the bmap descriptor to each other. */
id|bmp-&gt;db_ipbmap
op_assign
id|ipbmap
suffix:semicolon
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
op_assign
id|bmp
suffix:semicolon
id|DBINITMAP
c_func
(paren
id|bmp-&gt;db_mapsize
comma
id|ipbmap
comma
op_amp
id|bmp-&gt;db_DBmap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allocate/initialize the bmap lock&n;&t; */
id|BMAP_LOCK_INIT
c_func
(paren
id|bmp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:    &t;dbUnmount()&n; *&n; * FUNCTION:&t;terminate the block allocation map in preparation for&n; *&t;&t;file system unmount.&n; *&n; * &t;&t;the in-core bmap descriptor is written to disk and&n; *&t;&t;the memory for this descriptor is freed.&n; *&n; * PARAMETERS:&n; *      ipbmap&t;-  pointer to in-core inode for the block map.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      EIO&t;- i/o error&n; */
DECL|function|dbUnmount
r_int
id|dbUnmount
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
comma
r_int
id|mounterror
)paren
(brace
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mounterror
op_logical_or
id|isReadOnly
c_func
(paren
id|ipbmap
)paren
)paren
)paren
id|dbSync
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Invalidate the page cache buffers&n;&t; */
id|truncate_inode_pages
c_func
(paren
id|ipbmap-&gt;i_mapping
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* free the memory for the in-memory bmap. */
id|kfree
c_func
(paren
id|bmp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dbSync()&n; */
DECL|function|dbSync
r_int
id|dbSync
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
)paren
(brace
id|dbmap_t
op_star
id|dbmp_le
suffix:semicolon
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * write bmap global control page&n;&t; */
multiline_comment|/* get the buffer for the on-disk bmap descriptor. */
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|BMAPBLKNO
op_lshift
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2nbperpage
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;dbSync: read_metapage failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* copy the in-memory version of the bmap to the on-disk version */
id|dbmp_le
op_assign
(paren
id|dbmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|dbmp_le-&gt;dn_mapsize
op_assign
id|cpu_to_le64
c_func
(paren
id|bmp-&gt;db_mapsize
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_nfree
op_assign
id|cpu_to_le64
c_func
(paren
id|bmp-&gt;db_nfree
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_l2nbperpage
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_numag
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_numag
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_maxlevel
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_maxlevel
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_maxag
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_maxag
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_agpref
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_agpref
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_aglevel
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_aglevel
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_agheigth
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_agheigth
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_agwidth
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_agwidth
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_agstart
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_agstart
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_agl2size
op_assign
id|cpu_to_le32
c_func
(paren
id|bmp-&gt;db_agl2size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXAG
suffix:semicolon
id|i
op_increment
)paren
id|dbmp_le-&gt;dn_agfree
(braket
id|i
)braket
op_assign
id|cpu_to_le64
c_func
(paren
id|bmp-&gt;db_agfree
(braket
id|i
)braket
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_agsize
op_assign
id|cpu_to_le64
c_func
(paren
id|bmp-&gt;db_agsize
)paren
suffix:semicolon
id|dbmp_le-&gt;dn_maxfreebud
op_assign
id|bmp-&gt;db_maxfreebud
suffix:semicolon
multiline_comment|/* write the buffer */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * write out dirty pages of bmap&n;&t; */
id|fsync_inode_data_buffers
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
id|ipbmap-&gt;i_state
op_or_assign
id|I_DIRTY
suffix:semicolon
id|diWriteSpecial
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:    &t;dbFree()&n; *&n; * FUNCTION:&t;free the specified block range from the working block&n; *&t;&t;allocation map.&n; *&n; *&t;&t;the blocks will be free from the working map one dmap&n; *&t;&t;at a time.&n; *&n; * PARAMETERS:&n; *      ip&t;-  pointer to in-core inode;&n; *      blkno&t;-  starting block number to be freed.&n; *      nblocks&t;-  number of blocks to be freed.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      EIO&t;- i/o error&n; */
DECL|function|dbFree
r_int
id|dbFree
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
)paren
(brace
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
r_int
id|nb
comma
id|rc
suffix:semicolon
id|s64
id|lblkno
comma
id|rem
suffix:semicolon
r_struct
id|inode
op_star
id|ipbmap
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipbmap
suffix:semicolon
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
id|IREAD_LOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/* block to be freed better be within the mapsize. */
m_assert
(paren
id|blkno
op_plus
id|nblocks
op_le
id|bmp-&gt;db_mapsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free the blocks a dmap at a time.&n;&t; */
id|mp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|rem
op_assign
id|nblocks
suffix:semicolon
id|rem
OG
l_int|0
suffix:semicolon
id|rem
op_sub_assign
id|nb
comma
id|blkno
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* release previous dmap if any */
r_if
c_cond
(paren
id|mp
)paren
(brace
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* get the buffer for the current dmap. */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* determine the number of blocks to be freed from&n;&t;&t; * this dmap.&n;&t;&t; */
id|nb
op_assign
id|min
c_func
(paren
id|rem
comma
id|BPERDMAP
op_minus
(paren
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|DBALLOCCK
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
id|blkno
comma
id|nb
)paren
suffix:semicolon
multiline_comment|/* free the blocks. */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbFreeDmap
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nb
)paren
)paren
)paren
(brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|DBFREE
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
id|blkno
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/* write the last buffer. */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbUpdatePMap()&n; *&n; * FUNCTION:    update the allocation state (free or allocate) of the&n; *&t;&t;specified block range in the persistent block allocation map.&n; *&t;&t;&n; *&t;&t;the blocks will be updated in the persistent map one&n; *&t;&t;dmap at a time.&n; *&n; * PARAMETERS:&n; *      ipbmap&t;-  pointer to in-core inode for the block map.&n; *      free&t;- TRUE if block range is to be freed from the persistent&n; *&t;&t;  map; FALSE if it is to   be allocated.&n; *      blkno&t;-  starting block number of the range.&n; *      nblocks&t;-  number of contiguous blocks in the range.&n; *      tblk&t;-  transaction block;&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      EIO&t;- i/o error&n; */
r_int
DECL|function|dbUpdatePMap
id|dbUpdatePMap
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
comma
r_int
id|free
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
comma
id|tblock_t
op_star
id|tblk
)paren
(brace
r_int
id|nblks
comma
id|dbitno
comma
id|wbitno
comma
id|rbits
suffix:semicolon
r_int
id|word
comma
id|nbits
comma
id|nwords
suffix:semicolon
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
id|s64
id|lblkno
comma
id|rem
comma
id|lastlblkno
suffix:semicolon
id|u32
id|mask
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|log_t
op_star
id|log
suffix:semicolon
r_int
id|lsn
comma
id|difft
comma
id|diffp
suffix:semicolon
multiline_comment|/* the blocks better be within the mapsize. */
m_assert
(paren
id|blkno
op_plus
id|nblocks
op_le
id|bmp-&gt;db_mapsize
)paren
suffix:semicolon
multiline_comment|/* compute delta of transaction lsn from log syncpt */
id|lsn
op_assign
id|tblk-&gt;lsn
suffix:semicolon
id|log
op_assign
(paren
id|log_t
op_star
)paren
id|JFS_SBI
c_func
(paren
id|tblk-&gt;sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
id|logdiff
c_func
(paren
id|difft
comma
id|lsn
comma
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * update the block state a dmap at a time.&n;&t; */
id|mp
op_assign
l_int|NULL
suffix:semicolon
id|lastlblkno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|rem
op_assign
id|nblocks
suffix:semicolon
id|rem
OG
l_int|0
suffix:semicolon
id|rem
op_sub_assign
id|nblks
comma
id|blkno
op_add_assign
id|nblks
)paren
(brace
multiline_comment|/* get the buffer for the current dmap. */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lblkno
op_ne
id|lastlblkno
)paren
(brace
r_if
c_cond
(paren
id|mp
)paren
(brace
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|mp
op_assign
id|read_metapage
c_func
(paren
id|bmp-&gt;db_ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* determine the bit number and word within the dmap of&n;&t;&t; * the starting block.  also determine how many blocks&n;&t;&t; * are to be updated within this dmap.&n;&t;&t; */
id|dbitno
op_assign
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
suffix:semicolon
id|word
op_assign
id|dbitno
op_rshift
id|L2DBWORD
suffix:semicolon
id|nblks
op_assign
id|min
c_func
(paren
id|rem
comma
(paren
id|s64
)paren
id|BPERDMAP
op_minus
id|dbitno
)paren
suffix:semicolon
multiline_comment|/* update the bits of the dmap words. the first and last&n;&t;&t; * words may only have a subset of their bits updated. if&n;&t;&t; * this is the case, we&squot;ll work against that word (i.e.&n;&t;&t; * partial first and/or last) only in a single pass.  a &n;&t;&t; * single pass will also be used to update all words that&n;&t;&t; * are to have all their bits updated.&n;&t;&t; */
r_for
c_loop
(paren
id|rbits
op_assign
id|nblks
suffix:semicolon
id|rbits
OG
l_int|0
suffix:semicolon
id|rbits
op_sub_assign
id|nbits
comma
id|dbitno
op_add_assign
id|nbits
)paren
(brace
multiline_comment|/* determine the bit number within the word and&n;&t;&t;&t; * the number of bits within the word.&n;&t;&t;&t; */
id|wbitno
op_assign
id|dbitno
op_amp
(paren
id|DBWORD
op_minus
l_int|1
)paren
suffix:semicolon
id|nbits
op_assign
id|min
c_func
(paren
id|rbits
comma
id|DBWORD
op_minus
id|wbitno
)paren
suffix:semicolon
multiline_comment|/* check if only part of the word is to be updated. */
r_if
c_cond
(paren
id|nbits
OL
id|DBWORD
)paren
(brace
multiline_comment|/* update (free or allocate) the bits&n;&t;&t;&t;&t; * in this word.&n;&t;&t;&t;&t; */
id|mask
op_assign
(paren
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nbits
)paren
op_rshift
id|wbitno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free
)paren
id|dp-&gt;pmap
(braket
id|word
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|mask
)paren
suffix:semicolon
r_else
id|dp-&gt;pmap
(braket
id|word
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|mask
)paren
suffix:semicolon
id|word
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one or more words are to have all&n;&t;&t;&t;&t; * their bits updated.  determine how&n;&t;&t;&t;&t; * many words and how many bits.&n;&t;&t;&t;&t; */
id|nwords
op_assign
id|rbits
op_rshift
id|L2DBWORD
suffix:semicolon
id|nbits
op_assign
id|nwords
op_lshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* update (free or allocate) the bits&n;&t;&t;&t;&t; * in these words.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|free
)paren
id|memset
c_func
(paren
op_amp
id|dp-&gt;pmap
(braket
id|word
)braket
comma
l_int|0
comma
id|nwords
op_star
l_int|4
)paren
suffix:semicolon
r_else
id|memset
c_func
(paren
op_amp
id|dp-&gt;pmap
(braket
id|word
)braket
comma
(paren
r_int
)paren
id|ONES
comma
id|nwords
op_star
l_int|4
)paren
suffix:semicolon
id|word
op_add_assign
id|nwords
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * update dmap lsn&n;&t;&t; */
r_if
c_cond
(paren
id|lblkno
op_eq
id|lastlblkno
)paren
r_continue
suffix:semicolon
id|lastlblkno
op_assign
id|lblkno
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;lsn
op_ne
l_int|0
)paren
(brace
multiline_comment|/* inherit older/smaller lsn */
id|logdiff
c_func
(paren
id|diffp
comma
id|mp-&gt;lsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|difft
OL
id|diffp
)paren
(brace
id|mp-&gt;lsn
op_assign
id|lsn
suffix:semicolon
multiline_comment|/* move bp after tblock in logsync list */
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mp-&gt;synclist
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mp-&gt;synclist
comma
op_amp
id|tblk-&gt;synclist
)paren
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
multiline_comment|/* inherit younger/larger clsn */
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|difft
comma
id|tblk-&gt;clsn
comma
id|log
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|diffp
comma
id|mp-&gt;clsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|difft
OG
id|diffp
)paren
id|mp-&gt;clsn
op_assign
id|tblk-&gt;clsn
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;log
op_assign
id|log
suffix:semicolon
id|mp-&gt;lsn
op_assign
id|lsn
suffix:semicolon
multiline_comment|/* insert bp after tblock in logsync list */
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|log-&gt;count
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mp-&gt;synclist
comma
op_amp
id|tblk-&gt;synclist
)paren
suffix:semicolon
id|mp-&gt;clsn
op_assign
id|tblk-&gt;clsn
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* write the last buffer. */
r_if
c_cond
(paren
id|mp
)paren
(brace
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbNextAG()&n; *&n; * FUNCTION:    find the preferred allocation group for new allocations.&n; *&n; *&t;&t;we try to keep the trailing (rightmost) allocation groups&n; *&t;&t;free for large allocations.  we try to do this by targeting&n; *&t;&t;new inode allocations towards the leftmost or &squot;active&squot;&n; *&t;&t;allocation groups while keeping the rightmost or &squot;inactive&squot;&n; *&t;&t;allocation groups free. once the active allocation groups&n; *&t;&t;have dropped to a certain percentage of free space, we add&n; *&t;&t;the leftmost inactive allocation group to the active set.&n; *&n; *&t;&t;within the active allocation groups, we maintain a preferred&n; *&t;&t;allocation group which consists of a group with at least&n; *&t;&t;average free space over the active set. it is the preferred&n; *&t;&t;group that we target new inode allocation towards.  the &n; *&t;&t;tie-in between inode allocation and block allocation occurs&n; *&t;&t;as we allocate the first (data) block of an inode and specify&n; *&t;&t;the inode (block) as the allocation hint for this block.&n; *&n; * PARAMETERS:&n; *      ipbmap&t;-  pointer to in-core inode for the block map.&n; *&n; * RETURN VALUES:&n; *      the preferred allocation group number.&n; *&n; * note: only called by dbAlloc();&n; */
DECL|function|dbNextAG
r_int
id|dbNextAG
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
)paren
(brace
id|s64
id|avgfree
comma
id|inactfree
comma
id|actfree
comma
id|rem
suffix:semicolon
r_int
id|actags
comma
id|inactags
comma
id|l2agsize
suffix:semicolon
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
id|BMAP_LOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
multiline_comment|/* determine the number of active allocation groups (i.e.&n;&t; * the number of allocation groups up to and including&n;&t; * the rightmost allocation group with blocks allocated&n;&t; * in it.&n;&t; */
id|actags
op_assign
id|bmp-&gt;db_maxag
op_plus
l_int|1
suffix:semicolon
m_assert
(paren
id|actags
op_le
id|bmp-&gt;db_numag
)paren
suffix:semicolon
multiline_comment|/* get the number of inactive allocation groups (i.e. the&n;&t; * number of allocation group following the rightmost group&n;&t; * with allocation in it.&n;&t; */
id|inactags
op_assign
id|bmp-&gt;db_numag
op_minus
id|actags
suffix:semicolon
multiline_comment|/* determine how many blocks are in the inactive allocation&n;&t; * groups. in doing this, we must account for the fact that&n;&t; * the rightmost group might be a partial group (i.e. file&n;&t; * system size is not a multiple of the group size).&n;&t; */
id|l2agsize
op_assign
id|bmp-&gt;db_agl2size
suffix:semicolon
id|rem
op_assign
id|bmp-&gt;db_mapsize
op_amp
(paren
id|bmp-&gt;db_agsize
op_minus
l_int|1
)paren
suffix:semicolon
id|inactfree
op_assign
(paren
id|inactags
op_logical_and
id|rem
)paren
ques
c_cond
(paren
(paren
id|inactags
op_minus
l_int|1
)paren
op_lshift
id|l2agsize
)paren
op_plus
id|rem
suffix:colon
id|inactags
op_lshift
id|l2agsize
suffix:semicolon
multiline_comment|/* now determine how many free blocks are in the active&n;&t; * allocation groups plus the average number of free blocks&n;&t; * within the active ags.&n;&t; */
id|actfree
op_assign
id|bmp-&gt;db_nfree
op_minus
id|inactfree
suffix:semicolon
id|avgfree
op_assign
(paren
id|u32
)paren
id|actfree
op_div
(paren
id|u32
)paren
id|actags
suffix:semicolon
multiline_comment|/* check if not all of the allocation groups are active.&n;&t; */
r_if
c_cond
(paren
id|actags
OL
id|bmp-&gt;db_numag
)paren
(brace
multiline_comment|/* not all of the allocation groups are active.  determine&n;&t;&t; * if we should extend the active set by 1 (i.e. add the&n;&t;&t; * group following the current active set).  we do so if&n;&t;&t; * the number of free blocks within the active set is less&n;&t;&t; * than the allocation group set and average free within&n;&t;&t; * the active set is less than 60%.  we activate a new group&n;&t;&t; * by setting the allocation group preference to the new&n;&t;&t; * group.&n;&t;&t; */
r_if
c_cond
(paren
id|actfree
OL
id|bmp-&gt;db_agsize
op_logical_and
(paren
(paren
id|avgfree
op_star
l_int|100
)paren
op_rshift
id|l2agsize
)paren
OL
l_int|60
)paren
id|bmp-&gt;db_agpref
op_assign
id|actags
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* all allocation groups are in the active set.  check if&n;&t;&t; * the preferred allocation group has average free space.&n;&t;&t; * if not, re-establish the preferred group as the leftmost&n;&t;&t; * group with average free space.&n;&t;&t; */
r_if
c_cond
(paren
id|bmp-&gt;db_agfree
(braket
id|bmp-&gt;db_agpref
)braket
OL
id|avgfree
)paren
(brace
r_for
c_loop
(paren
id|bmp-&gt;db_agpref
op_assign
l_int|0
suffix:semicolon
id|bmp-&gt;db_agpref
OL
id|actags
suffix:semicolon
id|bmp-&gt;db_agpref
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bmp-&gt;db_agfree
(braket
id|bmp-&gt;db_agpref
)braket
op_le
id|avgfree
)paren
r_break
suffix:semicolon
)brace
m_assert
(paren
id|bmp-&gt;db_agpref
OL
id|bmp-&gt;db_numag
)paren
suffix:semicolon
)brace
)brace
id|BMAP_UNLOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
multiline_comment|/* return the preferred group.&n;&t; */
r_return
(paren
id|bmp-&gt;db_agpref
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAlloc()&n; *&n; * FUNCTION:    attempt to allocate a specified number of contiguous free&n; *&t;&t;blocks from the working allocation block map.&n; *&n; *&t;&t;the block allocation policy uses hints and a multi-step&n; *&t;&t;approach.&n; *&n; *&t;  &t;for allocation requests smaller than the number of blocks&n; *&t;&t;per dmap, we first try to allocate the new blocks&n; *&t;&t;immediately following the hint.  if these blocks are not&n; *&t;&t;available, we try to allocate blocks near the hint.  if&n; *&t;&t;no blocks near the hint are available, we next try to &n; *&t;&t;allocate within the same dmap as contains the hint.&n; *&n; *&t;&t;if no blocks are available in the dmap or the allocation&n; *&t;&t;request is larger than the dmap size, we try to allocate&n; *&t;&t;within the same allocation group as contains the hint. if&n; *&t;&t;this does not succeed, we finally try to allocate anywhere&n; *&t;&t;within the aggregate.&n; *&n; *&t;&t;we also try to allocate anywhere within the aggregate for&n; *&t;&t;for allocation requests larger than the allocation group&n; *&t;&t;size or requests that specify no hint value.&n; *&n; * PARAMETERS:&n; *      ip&t;-  pointer to in-core inode;&n; *      hint&t;- allocation hint.&n; *      nblocks&t;- number of contiguous blocks in the range.&n; *      results&t;- on successful return, set to the starting block number&n; *&t;&t;  of the newly allocated contiguous range.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; */
DECL|function|dbAlloc
r_int
id|dbAlloc
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|hint
comma
id|s64
id|nblocks
comma
id|s64
op_star
id|results
)paren
(brace
r_int
id|rc
comma
id|agno
suffix:semicolon
r_struct
id|inode
op_star
id|ipbmap
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipbmap
suffix:semicolon
id|bmap_t
op_star
id|bmp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|s64
id|lblkno
comma
id|blkno
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
r_int
id|l2nb
suffix:semicolon
id|s64
id|mapSize
suffix:semicolon
multiline_comment|/* assert that nblocks is valid */
m_assert
(paren
id|nblocks
OG
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/* DASD limit check                                     F226941 */
r_if
c_cond
(paren
id|OVER_LIMIT
c_func
(paren
id|ip
comma
id|nblocks
)paren
)paren
r_return
id|ENOSPC
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
multiline_comment|/* get the log2 number of blocks to be allocated.&n;&t; * if the number of blocks is not a log2 multiple, &n;&t; * it will be rounded up to the next log2 multiple.&n;&t; */
id|l2nb
op_assign
id|BLKSTOL2
c_func
(paren
id|nblocks
)paren
suffix:semicolon
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
singleline_comment|//retry:        /* serialize w.r.t.extendfs() */
id|mapSize
op_assign
id|bmp-&gt;db_mapsize
suffix:semicolon
multiline_comment|/* the hint should be within the map */
m_assert
(paren
id|hint
OL
id|mapSize
)paren
suffix:semicolon
multiline_comment|/* if no hint was specified or the number of blocks to be&n;&t; * allocated is greater than the allocation group size, try&n;&t; * to allocate anywhere.&n;&t; */
r_if
c_cond
(paren
id|hint
op_eq
l_int|0
op_logical_or
id|l2nb
OG
id|bmp-&gt;db_agl2size
)paren
(brace
id|IWRITE_LOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
id|rc
op_assign
id|dbAllocAny
c_func
(paren
id|bmp
comma
id|nblocks
comma
id|l2nb
comma
id|results
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
op_star
id|results
comma
id|nblocks
)paren
suffix:semicolon
)brace
id|IWRITE_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* we would like to allocate close to the hint.  adjust the&n;&t; * hint to the block following the hint since the allocators&n;&t; * will start looking for free space starting at this point.&n;&t; * if the hint was the last block of the file system, try to&n;&t; * allocate in the same allocation group as the hint.&n;&t; */
id|blkno
op_assign
id|hint
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|blkno
op_ge
id|bmp-&gt;db_mapsize
)paren
(brace
id|blkno
op_decrement
suffix:semicolon
r_goto
id|tryag
suffix:semicolon
)brace
multiline_comment|/* check if blkno crosses over into a new allocation group.&n;&t; * if so, check if we should allow allocations within this&n;&t; * allocation group.  we try to keep the trailing (rightmost)&n;&t; * allocation groups of the file system free for large&n;&t; * allocations and may want to prevent this allocation from&n;&t; * spilling over into this space.&n;&t; */
r_if
c_cond
(paren
(paren
id|blkno
op_amp
(paren
id|bmp-&gt;db_agsize
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check if the AG is beyond the rightmost AG with&n;&t;&t; * allocations in it.  if so, call dbNextAG() to&n;&t;&t; * determine if the allocation should be allowed&n;&t;&t; * to proceed within this AG or should be targeted&n;&t;&t; * to another AG.&n;&t;&t; */
id|agno
op_assign
id|blkno
op_rshift
id|bmp-&gt;db_agl2size
suffix:semicolon
r_if
c_cond
(paren
id|agno
OG
id|bmp-&gt;db_maxag
)paren
(brace
id|agno
op_assign
id|dbNextAG
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
id|blkno
op_assign
(paren
id|s64
)paren
id|agno
op_lshift
id|bmp-&gt;db_agl2size
suffix:semicolon
r_goto
id|tryag
suffix:semicolon
)brace
)brace
multiline_comment|/* check if the allocation request size can be satisfied from a&n;&t; * single dmap.  if so, try to allocate from the dmap containing&n;&t; * the hint using a tiered strategy.&n;&t; */
r_if
c_cond
(paren
id|nblocks
op_le
id|BPERDMAP
)paren
(brace
id|IREAD_LOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/* get the buffer for the dmap containing the hint.&n;&t;&t; */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* first, try to satisfy the allocation request with the&n;&t;&t; * blocks beginning at the hint.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocNext
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
(paren
r_int
)paren
id|nblocks
)paren
)paren
op_ne
id|ENOSPC
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
op_star
id|results
op_assign
id|blkno
suffix:semicolon
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
op_star
id|results
comma
id|nblocks
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
m_assert
(paren
id|rc
op_eq
id|EIO
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* next, try to satisfy the allocation request with blocks&n;&t;&t; * near the hint.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocNear
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
(paren
r_int
)paren
id|nblocks
comma
id|l2nb
comma
id|results
)paren
)paren
op_ne
id|ENOSPC
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
op_star
id|results
comma
id|nblocks
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* try to satisfy the allocation request with blocks within&n;&t;&t; * the same allocation group as the hint.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocDmapLev
c_func
(paren
id|bmp
comma
id|dp
comma
(paren
r_int
)paren
id|nblocks
comma
id|l2nb
comma
id|results
)paren
)paren
op_ne
id|ENOSPC
)paren
(brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
op_star
id|results
comma
id|nblocks
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
)brace
id|tryag
suffix:colon
id|IWRITE_LOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/* determine the allocation group number of the hint and try to&n;&t; * allocate within this allocation group.  if that fails, try to&n;&t; * allocate anywhere in the map.&n;&t; */
id|agno
op_assign
id|blkno
op_rshift
id|bmp-&gt;db_agl2size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocAG
c_func
(paren
id|bmp
comma
id|agno
comma
id|nblocks
comma
id|l2nb
comma
id|results
)paren
)paren
op_eq
id|ENOSPC
)paren
id|rc
op_assign
id|dbAllocAny
c_func
(paren
id|bmp
comma
id|nblocks
comma
id|l2nb
comma
id|results
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
op_star
id|results
comma
id|nblocks
)paren
suffix:semicolon
)brace
id|IWRITE_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocExact()&n; *&n; * FUNCTION:    try to allocate the requested extent;&n; *&n; * PARAMETERS:&n; *      ip&t;- pointer to in-core inode;&n; *      blkno&t;- extent address;&n; *      nblocks&t;- extent length;&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; */
DECL|function|dbAllocExact
r_int
id|dbAllocExact
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|inode
op_star
id|ipbmap
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipbmap
suffix:semicolon
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
id|s64
id|lblkno
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|IREAD_LOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * validate extent request:&n;&t; *&n;&t; * note: defragfs policy:&n;&t; *  max 64 blocks will be moved.  &n;&t; *  allocation request size must be satisfied from a single dmap.&n;&t; */
r_if
c_cond
(paren
id|nblocks
op_le
l_int|0
op_logical_or
id|nblocks
OG
id|BPERDMAP
op_logical_or
id|blkno
op_ge
id|bmp-&gt;db_mapsize
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nblocks
OG
(paren
(paren
id|s64
)paren
l_int|1
op_lshift
id|bmp-&gt;db_maxfreebud
)paren
)paren
(brace
multiline_comment|/* the free space is no longer available */
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/* read in the dmap covering the extent */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* try to allocate the requested extent */
id|rc
op_assign
id|dbAllocNext
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbReAlloc()&n; *&n; * FUNCTION:    attempt to extend a current allocation by a specified&n; *&t;&t;number of blocks.&n; *&n; *&t;&t;this routine attempts to satisfy the allocation request&n; *&t;&t;by first trying to extend the existing allocation in&n; *&t;&t;place by allocating the additional blocks as the blocks&n; *&t;&t;immediately following the current allocation.  if these&n; *&t;&t;blocks are not available, this routine will attempt to&n; *&t;&t;allocate a new set of contiguous blocks large enough&n; *&t;&t;to cover the existing allocation plus the additional&n; *&t;&t;number of blocks required.&n; *&n; * PARAMETERS:&n; *      ip&t;    -  pointer to in-core inode requiring allocation.&n; *      blkno&t;    -  starting block of the current allocation.&n; *      nblocks&t;    -  number of contiguous blocks within the current&n; *&t;&t;       allocation.&n; *      addnblocks  -  number of blocks to add to the allocation.&n; *      results&t;-      on successful return, set to the starting block number&n; *&t;&t;       of the existing allocation if the existing allocation&n; *&t;&t;       was extended in place or to a newly allocated contiguous&n; *&t;&t;       range if the existing allocation could not be extended&n; *&t;&t;       in place.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; */
r_int
DECL|function|dbReAlloc
id|dbReAlloc
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
comma
id|s64
id|addnblocks
comma
id|s64
op_star
id|results
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* try to extend the allocation in place.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbExtend
c_func
(paren
id|ip
comma
id|blkno
comma
id|nblocks
comma
id|addnblocks
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|results
op_assign
id|blkno
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rc
op_ne
id|ENOSPC
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* could not extend the allocation in place, so allocate a&n;&t; * new set of blocks for the entire request (i.e. try to get&n;&t; * a range of contiguous blocks large enough to cover the&n;&t; * existing allocation plus the additional blocks.)&n;&t; */
r_return
(paren
id|dbAlloc
(paren
id|ip
comma
id|blkno
op_plus
id|nblocks
op_minus
l_int|1
comma
id|addnblocks
op_plus
id|nblocks
comma
id|results
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbExtend()&n; *&n; * FUNCTION:    attempt to extend a current allocation by a specified&n; *&t;&t;number of blocks.&n; *&n; *&t;&t;this routine attempts to satisfy the allocation request&n; *&t;&t;by first trying to extend the existing allocation in&n; *&t;&t;place by allocating the additional blocks as the blocks&n; *&t;&t;immediately following the current allocation.&n; *&n; * PARAMETERS:&n; *      ip&t;    -  pointer to in-core inode requiring allocation.&n; *      blkno&t;    -  starting block of the current allocation.&n; *      nblocks&t;    -  number of contiguous blocks within the current&n; *&t;&t;       allocation.&n; *      addnblocks  -  number of blocks to add to the allocation.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; */
DECL|function|dbExtend
r_int
id|dbExtend
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
comma
id|s64
id|addnblocks
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
id|s64
id|lblkno
comma
id|lastblkno
comma
id|extblkno
suffix:semicolon
id|uint
id|rel_block
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_struct
id|inode
op_star
id|ipbmap
op_assign
id|sbi-&gt;ipbmap
suffix:semicolon
id|bmap_t
op_star
id|bmp
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t want a non-aligned extent to cross a page boundary&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|rel_block
op_assign
id|blkno
op_amp
(paren
id|sbi-&gt;nbperpage
op_minus
l_int|1
)paren
)paren
)paren
op_logical_and
(paren
id|rel_block
op_plus
id|nblocks
op_plus
id|addnblocks
OG
id|sbi-&gt;nbperpage
)paren
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/* get the last block of the current allocation */
id|lastblkno
op_assign
id|blkno
op_plus
id|nblocks
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* determine the block number of the block following&n;&t; * the existing allocation.&n;&t; */
id|extblkno
op_assign
id|lastblkno
op_plus
l_int|1
suffix:semicolon
id|IREAD_LOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/* better be within the file system */
id|bmp
op_assign
id|sbi-&gt;bmap
suffix:semicolon
m_assert
(paren
id|lastblkno
op_ge
l_int|0
op_logical_and
id|lastblkno
OL
id|bmp-&gt;db_mapsize
)paren
suffix:semicolon
multiline_comment|/* we&squot;ll attempt to extend the current allocation in place by&n;&t; * allocating the additional blocks as the blocks immediately&n;&t; * following the current allocation.  we only try to extend the&n;&t; * current allocation in place if the number of additional blocks&n;&t; * can fit into a dmap, the last block of the current allocation&n;&t; * is not the last block of the file system, and the start of the&n;&t; * inplace extension is not on an allocation group boundry.&n;&t; */
r_if
c_cond
(paren
id|addnblocks
OG
id|BPERDMAP
op_logical_or
id|extblkno
op_ge
id|bmp-&gt;db_mapsize
op_logical_or
(paren
id|extblkno
op_amp
(paren
id|bmp-&gt;db_agsize
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/* get the buffer for the dmap containing the first block&n;&t; * of the extension.&n;&t; */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|extblkno
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|DBALLOCCK
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* try to allocate the blocks immediately following the&n;&t; * current allocation.&n;&t; */
id|rc
op_assign
id|dbAllocNext
c_func
(paren
id|bmp
comma
id|dp
comma
id|extblkno
comma
(paren
r_int
)paren
id|addnblocks
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/* were we successful ? */
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
(brace
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
id|extblkno
comma
id|addnblocks
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we were not successful */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
m_assert
(paren
id|rc
op_eq
id|ENOSPC
op_logical_or
id|rc
op_eq
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocNext()&n; *&n; * FUNCTION:    attempt to allocate the blocks of the specified block&n; *&t;&t;range within a dmap.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      dp&t;-  pointer to dmap.&n; *      blkno&t;-  starting block number of the range.&n; *      nblocks&t;-  number of contiguous free blocks of the range.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; *&n; * serialization: IREAD_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbAllocNext
r_static
r_int
id|dbAllocNext
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
(brace
r_int
id|dbitno
comma
id|word
comma
id|rembits
comma
id|nb
comma
id|nwords
comma
id|wbitno
comma
id|nw
suffix:semicolon
r_int
id|l2size
suffix:semicolon
id|s8
op_star
id|leaf
suffix:semicolon
id|u32
id|mask
suffix:semicolon
multiline_comment|/* pick up a pointer to the leaves of the dmap tree.&n;&t; */
id|leaf
op_assign
id|dp-&gt;tree.stree
op_plus
id|le32_to_cpu
c_func
(paren
id|dp-&gt;tree.leafidx
)paren
suffix:semicolon
multiline_comment|/* determine the bit number and word within the dmap of the&n;&t; * starting block.&n;&t; */
id|dbitno
op_assign
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
suffix:semicolon
id|word
op_assign
id|dbitno
op_rshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* check if the specified block range is contained within&n;&t; * this dmap.&n;&t; */
r_if
c_cond
(paren
id|dbitno
op_plus
id|nblocks
OG
id|BPERDMAP
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/* check if the starting leaf indicates that anything&n;&t; * is free.&n;&t; */
r_if
c_cond
(paren
id|leaf
(braket
id|word
)braket
op_eq
id|NOFREE
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/* check the dmaps words corresponding to block range to see&n;&t; * if the block range is free.  not all bits of the first and&n;&t; * last words may be contained within the block range.  if this&n;&t; * is the case, we&squot;ll work against those words (i.e. partial first&n;&t; * and/or last) on an individual basis (a single pass) and examine&n;&t; * the actual bits to determine if they are free.  a single pass&n;&t; * will be used for all dmap words fully contained within the&n;&t; * specified range.  within this pass, the leaves of the dmap&n;&t; * tree will be examined to determine if the blocks are free. a&n;&t; * single leaf may describe the free space of multiple dmap&n;&t; * words, so we may visit only a subset of the actual leaves&n;&t; * corresponding to the dmap words of the block range.&n;&t; */
r_for
c_loop
(paren
id|rembits
op_assign
id|nblocks
suffix:semicolon
id|rembits
OG
l_int|0
suffix:semicolon
id|rembits
op_sub_assign
id|nb
comma
id|dbitno
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* determine the bit number within the word and&n;&t;&t; * the number of bits within the word.&n;&t;&t; */
id|wbitno
op_assign
id|dbitno
op_amp
(paren
id|DBWORD
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|rembits
comma
id|DBWORD
op_minus
id|wbitno
)paren
suffix:semicolon
multiline_comment|/* check if only part of the word is to be examined.&n;&t;&t; */
r_if
c_cond
(paren
id|nb
OL
id|DBWORD
)paren
(brace
multiline_comment|/* check if the bits are free.&n;&t;&t;&t; */
id|mask
op_assign
(paren
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nb
)paren
op_rshift
id|wbitno
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_amp
op_complement
id|le32_to_cpu
c_func
(paren
id|dp-&gt;wmap
(braket
id|word
)braket
)paren
)paren
op_ne
id|mask
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
id|word
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one or more dmap words are fully contained&n;&t;&t;&t; * within the block range.  determine how many&n;&t;&t;&t; * words and how many bits.&n;&t;&t;&t; */
id|nwords
op_assign
id|rembits
op_rshift
id|L2DBWORD
suffix:semicolon
id|nb
op_assign
id|nwords
op_lshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* now examine the appropriate leaves to determine&n;&t;&t;&t; * if the blocks are free.&n;&t;&t;&t; */
r_while
c_loop
(paren
id|nwords
OG
l_int|0
)paren
(brace
multiline_comment|/* does the leaf describe any free space ?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|leaf
(braket
id|word
)braket
OL
id|BUDMIN
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/* determine the l2 number of bits provided&n;&t;&t;&t;&t; * by this leaf.&n;&t;&t;&t;&t; */
id|l2size
op_assign
id|min
c_func
(paren
(paren
r_int
)paren
id|leaf
(braket
id|word
)braket
comma
id|NLSTOL2BSZ
c_func
(paren
id|nwords
)paren
)paren
suffix:semicolon
multiline_comment|/* determine how many words were handled.&n;&t;&t;&t;&t; */
id|nw
op_assign
id|BUDSIZE
c_func
(paren
id|l2size
comma
id|BUDMIN
)paren
suffix:semicolon
id|nwords
op_sub_assign
id|nw
suffix:semicolon
id|word
op_add_assign
id|nw
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* allocate the blocks.&n;&t; */
r_return
(paren
id|dbAllocDmap
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocNear()&n; *&n; * FUNCTION:    attempt to allocate a number of contiguous free blocks near&n; *&t;&t;a specified block (hint) within a dmap.&n; *&n; *&t;&t;starting with the dmap leaf that covers the hint, we&squot;ll&n; *&t;&t;check the next four contiguous leaves for sufficient free&n; *&t;&t;space.  if sufficient free space is found, we&squot;ll allocate&n; *&t;&t;the desired free space.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      dp&t;-  pointer to dmap.&n; *      blkno&t;-  block number to allocate near.&n; *      nblocks&t;-  actual number of contiguous free blocks desired.&n; *      l2nb&t;-  log2 number of contiguous free blocks desired.&n; *      results&t;-  on successful return, set to the starting block number&n; *&t;&t;   of the newly allocated range.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; *&n; * serialization: IREAD_LOCK(ipbmap) held on entry/exit;&n; */
r_static
r_int
DECL|function|dbAllocNear
id|dbAllocNear
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
(brace
r_int
id|word
comma
id|lword
comma
id|rc
suffix:semicolon
id|s8
op_star
id|leaf
op_assign
id|dp-&gt;tree.stree
op_plus
id|le32_to_cpu
c_func
(paren
id|dp-&gt;tree.leafidx
)paren
suffix:semicolon
multiline_comment|/* determine the word within the dmap that holds the hint&n;&t; * (i.e. blkno).  also, determine the last word in the dmap&n;&t; * that we&squot;ll include in our examination.&n;&t; */
id|word
op_assign
(paren
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
)paren
op_rshift
id|L2DBWORD
suffix:semicolon
id|lword
op_assign
id|min
c_func
(paren
id|word
op_plus
l_int|4
comma
id|LPERDMAP
)paren
suffix:semicolon
multiline_comment|/* examine the leaves for sufficient free space.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|word
OL
id|lword
suffix:semicolon
id|word
op_increment
)paren
(brace
multiline_comment|/* does the leaf describe sufficient free space ?&n;&t;&t; */
r_if
c_cond
(paren
id|leaf
(braket
id|word
)braket
OL
id|l2nb
)paren
r_continue
suffix:semicolon
multiline_comment|/* determine the block number within the file system&n;&t;&t; * of the first block described by this dmap word.&n;&t;&t; */
id|blkno
op_assign
id|le64_to_cpu
c_func
(paren
id|dp-&gt;start
)paren
op_plus
(paren
id|word
op_lshift
id|L2DBWORD
)paren
suffix:semicolon
multiline_comment|/* if not all bits of the dmap word are free, get the&n;&t;&t; * starting bit number within the dmap word of the required&n;&t;&t; * string of free bits and adjust the block number with the&n;&t;&t; * value.&n;&t;&t; */
r_if
c_cond
(paren
id|leaf
(braket
id|word
)braket
OL
id|BUDMIN
)paren
id|blkno
op_add_assign
id|dbFindBits
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;wmap
(braket
id|word
)braket
)paren
comma
id|l2nb
)paren
suffix:semicolon
multiline_comment|/* allocate the blocks.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocDmap
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
)paren
op_eq
l_int|0
)paren
op_star
id|results
op_assign
id|blkno
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocAG()&n; *&n; * FUNCTION:    attempt to allocate the specified number of contiguous&n; *&t;&t;free blocks within the specified allocation group.&n; *&n; *&t;&t;unless the allocation group size is equal to the number&n; *&t;&t;of blocks per dmap, the dmap control pages will be used to&n; *&t;&t;find the required free space, if available.  we start the&n; *&t;&t;search at the highest dmap control page level which&n; *&t;&t;distinctly describes the allocation group&squot;s free space&n; *&t;&t;(i.e. the highest level at which the allocation group&squot;s&n; *&t;&t;free space is not mixed in with that of any other group).&n; *&t;&t;in addition, we start the search within this level at a&n; *&t;&t;height of the dmapctl dmtree at which the nodes distinctly&n; *&t;&t;describe the allocation group&squot;s free space.  at this height,&n; *&t;&t;the allocation group&squot;s free space may be represented by 1&n; *&t;&t;or two sub-trees, depending on the allocation group size.&n; *&t;&t;we search the top nodes of these subtrees left to right for&n; *&t;&t;sufficient free space.  if sufficient free space is found,&n; *&t;&t;the subtree is searched to find the leftmost leaf that &n; *&t;&t;has free space.  once we have made it to the leaf, we&n; *&t;&t;move the search to the next lower level dmap control page&n; *&t;&t;corresponding to this leaf.  we continue down the dmap control&n; *&t;&t;pages until we find the dmap that contains or starts the&n; *&t;&t;sufficient free space and we allocate at this dmap.&n; *&n; *&t;&t;if the allocation group size is equal to the dmap size,&n; *&t;&t;we&squot;ll start at the dmap corresponding to the allocation&n; *&t;&t;group and attempt the allocation at this level.&n; *&n; *&t;&t;the dmap control page search is also not performed if the&n; *&t;&t;allocation group is completely free and we go to the first&n; *&t;&t;dmap of the allocation group to do the allocation.  this is&n; *&t;&t;done because the allocation group may be part (not the first&n; *&t;&t;part) of a larger binary buddy system, causing the dmap&n; *&t;&t;control pages to indicate no free space (NOFREE) within&n; *&t;&t;the allocation group.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *&t;agno&t;- allocation group number.&n; *      nblocks&t;-  actual number of contiguous free blocks desired.&n; *      l2nb&t;-  log2 number of contiguous free blocks desired.&n; *      results&t;-  on successful return, set to the starting block number&n; *&t;&t;   of the newly allocated range.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; *&n; * note: IWRITE_LOCK(ipmap) held on entry/exit;&n; */
r_static
r_int
DECL|function|dbAllocAG
id|dbAllocAG
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
r_int
id|agno
comma
id|s64
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
(brace
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dmapctl_t
op_star
id|dcp
suffix:semicolon
r_int
id|rc
comma
id|ti
comma
id|i
comma
id|k
comma
id|m
comma
id|n
comma
id|agperlev
suffix:semicolon
id|s64
id|blkno
comma
id|lblkno
suffix:semicolon
r_int
id|budmin
suffix:semicolon
multiline_comment|/* allocation request should not be for more than the&n;&t; * allocation group size.&n;&t; */
m_assert
(paren
id|l2nb
op_le
id|bmp-&gt;db_agl2size
)paren
suffix:semicolon
multiline_comment|/* determine the starting block number of the allocation&n;&t; * group.&n;&t; */
id|blkno
op_assign
(paren
id|s64
)paren
id|agno
op_lshift
id|bmp-&gt;db_agl2size
suffix:semicolon
multiline_comment|/* check if the allocation group size is the minimum allocation&n;&t; * group size or if the allocation group is completely free. if&n;&t; * the allocation group size is the minimum size of BPERDMAP (i.e.&n;&t; * 1 dmap), there is no need to search the dmap control page (below)&n;&t; * that fully describes the allocation group since the allocation&n;&t; * group is already fully described by a dmap.  in this case, we&n;&t; * just call dbAllocCtl() to search the dmap tree and allocate the&n;&t; * required space if available.  &n;&t; *&n;&t; * if the allocation group is completely free, dbAllocCtl() is&n;&t; * also called to allocate the required space.  this is done for&n;&t; * two reasons.  first, it makes no sense searching the dmap control&n;&t; * pages for free space when we know that free space exists.  second,&n;&t; * the dmap control pages may indicate that the allocation group&n;&t; * has no free space if the allocation group is part (not the first&n;&t; * part) of a larger binary buddy system.&n;&t; */
r_if
c_cond
(paren
id|bmp-&gt;db_agsize
op_eq
id|BPERDMAP
op_logical_or
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_eq
id|bmp-&gt;db_agsize
)paren
(brace
id|rc
op_assign
id|dbAllocCtl
c_func
(paren
id|bmp
comma
id|nblocks
comma
id|l2nb
comma
id|blkno
comma
id|results
)paren
suffix:semicolon
multiline_comment|/* assert(!(rc == ENOSPC &amp;&amp; bmp-&gt;db_agfree[agno] == bmp-&gt;db_agsize)); */
r_if
c_cond
(paren
(paren
id|rc
op_eq
id|ENOSPC
)paren
op_logical_and
(paren
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_eq
id|bmp-&gt;db_agsize
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;dbAllocAG: removed assert, but still need to debug here&bslash;nblkno = 0x%Lx, nblocks = 0x%Lx&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|blkno
comma
(paren
r_int
r_int
r_int
)paren
id|nblocks
)paren
)paren
suffix:semicolon
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* the buffer for the dmap control page that fully describes the&n;&t; * allocation group.&n;&t; */
id|lblkno
op_assign
id|BLKTOCTL
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
comma
id|bmp-&gt;db_aglevel
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|bmp-&gt;db_ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
id|dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|budmin
op_assign
id|dcp-&gt;budmin
suffix:semicolon
multiline_comment|/* search the subtree(s) of the dmap control page that describes&n;&t; * the allocation group, looking for sufficient free space.  to begin,&n;&t; * determine how many allocation groups are represented in a dmap&n;&t; * control page at the control page level (i.e. L0, L1, L2) that&n;&t; * fully describes an allocation group. next, determine the starting&n;&t; * tree index of this allocation group within the control page.&n;&t; */
id|agperlev
op_assign
(paren
l_int|1
op_lshift
(paren
id|L2LPERCTL
op_minus
(paren
id|bmp-&gt;db_agheigth
op_lshift
l_int|1
)paren
)paren
)paren
op_div
id|bmp-&gt;db_agwidth
suffix:semicolon
id|ti
op_assign
id|bmp-&gt;db_agstart
op_plus
id|bmp-&gt;db_agwidth
op_star
(paren
id|agno
op_amp
(paren
id|agperlev
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* dmap control page trees fan-out by 4 and a single allocation &n;&t; * group may be described by 1 or 2 subtrees within the ag level&n;&t; * dmap control page, depending upon the ag size. examine the ag&squot;s&n;&t; * subtrees for sufficient free space, starting with the leftmost&n;&t; * subtree.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bmp-&gt;db_agwidth
suffix:semicolon
id|i
op_increment
comma
id|ti
op_increment
)paren
(brace
multiline_comment|/* is there sufficient free space ?&n;&t;&t; */
r_if
c_cond
(paren
id|l2nb
OG
id|dcp-&gt;stree
(braket
id|ti
)braket
)paren
r_continue
suffix:semicolon
multiline_comment|/* sufficient free space found in a subtree. now search down&n;&t;&t; * the subtree to find the leftmost leaf that describes this&n;&t;&t; * free space.&n;&t;&t; */
r_for
c_loop
(paren
id|k
op_assign
id|bmp-&gt;db_agheigth
suffix:semicolon
id|k
OG
l_int|0
suffix:semicolon
id|k
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
comma
id|m
op_assign
(paren
id|ti
op_lshift
l_int|2
)paren
op_plus
l_int|1
suffix:semicolon
id|n
OL
l_int|4
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|l2nb
op_le
id|dcp-&gt;stree
(braket
id|m
op_plus
id|n
)braket
)paren
(brace
id|ti
op_assign
id|m
op_plus
id|n
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
m_assert
(paren
id|n
OL
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* determine the block number within the file system&n;&t;&t; * that corresponds to this leaf.&n;&t;&t; */
r_if
c_cond
(paren
id|bmp-&gt;db_aglevel
op_eq
l_int|2
)paren
id|blkno
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bmp-&gt;db_aglevel
op_eq
l_int|1
)paren
id|blkno
op_and_assign
op_complement
(paren
id|MAXL1SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/* bmp-&gt;db_aglevel == 0 */
id|blkno
op_and_assign
op_complement
(paren
id|MAXL0SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|blkno
op_add_assign
(paren
(paren
id|s64
)paren
(paren
id|ti
op_minus
id|le32_to_cpu
c_func
(paren
id|dcp-&gt;leafidx
)paren
)paren
)paren
op_lshift
id|budmin
suffix:semicolon
multiline_comment|/* release the buffer in preparation for going down&n;&t;&t; * the next level of dmap control pages.&n;&t;&t; */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* check if we need to continue to search down the lower&n;&t;&t; * level dmap control pages.  we need to if the number of&n;&t;&t; * blocks required is less than maximum number of blocks&n;&t;&t; * described at the next lower level.&n;&t;&t; */
r_if
c_cond
(paren
id|l2nb
OL
id|budmin
)paren
(brace
multiline_comment|/* search the lower level dmap control pages to get&n;&t;&t;&t; * the starting block number of the the dmap that&n;&t;&t;&t; * contains or starts off the free space.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbFindCtl
c_func
(paren
id|bmp
comma
id|l2nb
comma
id|bmp-&gt;db_aglevel
op_minus
l_int|1
comma
op_amp
id|blkno
)paren
)paren
)paren
(brace
m_assert
(paren
id|rc
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* allocate the blocks.&n;&t;&t; */
id|rc
op_assign
id|dbAllocCtl
c_func
(paren
id|bmp
comma
id|nblocks
comma
id|l2nb
comma
id|blkno
comma
id|results
)paren
suffix:semicolon
m_assert
(paren
id|rc
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* no space in the allocation group.  release the buffer and&n;&t; * return ENOSPC.&n;&t; */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocAny()&n; *&n; * FUNCTION:    attempt to allocate the specified number of contiguous&n; *&t;&t;free blocks anywhere in the file system.&n; *&n; *&t;&t;dbAllocAny() attempts to find the sufficient free space by&n; *&t;&t;searching down the dmap control pages, starting with the&n; *&t;&t;highest level (i.e. L0, L1, L2) control page.  if free space&n; *&t;&t;large enough to satisfy the desired free space is found, the&n; *&t;&t;desired free space is allocated.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      nblocks&t; -  actual number of contiguous free blocks desired.&n; *      l2nb&t; -  log2 number of contiguous free blocks desired.&n; *      results&t;-  on successful return, set to the starting block number&n; *&t;&t;   of the newly allocated range.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; *&n; * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbAllocAny
r_static
r_int
id|dbAllocAny
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|s64
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
(brace
r_int
id|rc
suffix:semicolon
id|s64
id|blkno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* starting with the top level dmap control page, search&n;&t; * down the dmap control levels for sufficient free space.&n;&t; * if free space is found, dbFindCtl() returns the starting&n;&t; * block number of the dmap that contains or starts off the&n;&t; * range of free space.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbFindCtl
c_func
(paren
id|bmp
comma
id|l2nb
comma
id|bmp-&gt;db_maxlevel
comma
op_amp
id|blkno
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
multiline_comment|/* allocate the blocks.&n;&t; */
id|rc
op_assign
id|dbAllocCtl
c_func
(paren
id|bmp
comma
id|nblocks
comma
id|l2nb
comma
id|blkno
comma
id|results
)paren
suffix:semicolon
m_assert
(paren
id|rc
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbFindCtl()&n; *&n; * FUNCTION:    starting at a specified dmap control page level and block&n; *&t;&t;number, search down the dmap control levels for a range of&n; *&t;        contiguous free blocks large enough to satisfy an allocation&n; *&t;&t;request for the specified number of free blocks.&n; *&n; *&t;&t;if sufficient contiguous free blocks are found, this routine&n; *&t;&t;returns the starting block number within a dmap page that&n; *&t;&t;contains or starts a range of contiqious free blocks that&n; *&t;&t;is sufficient in size.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      level&t;-  starting dmap control page level.&n; *      l2nb&t;-  log2 number of contiguous free blocks desired.&n; *      *blkno&t;-  on entry, starting block number for conducting the search.&n; *&t;&t;   on successful return, the first block within a dmap page&n; *&t;&t;   that contains or starts a range of contiguous free blocks.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; *&n; * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbFindCtl
r_static
r_int
id|dbFindCtl
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
r_int
id|l2nb
comma
r_int
id|level
comma
id|s64
op_star
id|blkno
)paren
(brace
r_int
id|rc
comma
id|leafidx
comma
id|lev
suffix:semicolon
id|s64
id|b
comma
id|lblkno
suffix:semicolon
id|dmapctl_t
op_star
id|dcp
suffix:semicolon
r_int
id|budmin
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* starting at the specified dmap control page level and block&n;&t; * number, search down the dmap control levels for the starting&n;&t; * block number of a dmap page that contains or starts off &n;&t; * sufficient free blocks.&n;&t; */
r_for
c_loop
(paren
id|lev
op_assign
id|level
comma
id|b
op_assign
op_star
id|blkno
suffix:semicolon
id|lev
op_ge
l_int|0
suffix:semicolon
id|lev
op_decrement
)paren
(brace
multiline_comment|/* get the buffer of the dmap control page for the block&n;&t;&t; * number and level (i.e. L0, L1, L2).&n;&t;&t; */
id|lblkno
op_assign
id|BLKTOCTL
c_func
(paren
id|b
comma
id|bmp-&gt;db_l2nbperpage
comma
id|lev
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|bmp-&gt;db_ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
id|dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|budmin
op_assign
id|dcp-&gt;budmin
suffix:semicolon
multiline_comment|/* search the tree within the dmap control page for&n;&t;&t; * sufficent free space.  if sufficient free space is found,&n;&t;&t; * dbFindLeaf() returns the index of the leaf at which&n;&t;&t; * free space was found.&n;&t;&t; */
id|rc
op_assign
id|dbFindLeaf
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
id|dcp
comma
id|l2nb
comma
op_amp
id|leafidx
)paren
suffix:semicolon
multiline_comment|/* release the buffer.&n;&t;&t; */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* space found ?&n;&t;&t; */
r_if
c_cond
(paren
id|rc
)paren
(brace
m_assert
(paren
id|lev
op_eq
id|level
)paren
suffix:semicolon
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/* adjust the block number to reflect the location within&n;&t;&t; * the dmap control page (i.e. the leaf) at which free &n;&t;&t; * space was found.&n;&t;&t; */
id|b
op_add_assign
(paren
(paren
(paren
id|s64
)paren
id|leafidx
)paren
op_lshift
id|budmin
)paren
suffix:semicolon
multiline_comment|/* we stop the search at this dmap control page level if&n;&t;&t; * the number of blocks required is greater than or equal&n;&t;&t; * to the maximum number of blocks described at the next&n;&t;&t; * (lower) level.&n;&t;&t; */
r_if
c_cond
(paren
id|l2nb
op_ge
id|budmin
)paren
r_break
suffix:semicolon
)brace
op_star
id|blkno
op_assign
id|b
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocCtl()&n; *&n; * FUNCTION:    attempt to allocate a specified number of contiguous&n; *&t;&t;blocks starting within a specific dmap.  &n; *&t;&t;&n; *&t;&t;this routine is called by higher level routines that search&n; *&t;&t;the dmap control pages above the actual dmaps for contiguous&n; *&t;&t;free space.  the result of successful searches by these&n; * &t;&t;routines are the starting block numbers within dmaps, with&n; *&t;&t;the dmaps themselves containing the desired contiguous free&n; *&t;&t;space or starting a contiguous free space of desired size&n; *&t;&t;that is made up of the blocks of one or more dmaps. these&n; *&t;&t;calls should not fail due to insufficent resources.&n; *&n; *&t;&t;this routine is called in some cases where it is not known&n; *&t;&t;whether it will fail due to insufficient resources.  more&n; *&t;&t;specifically, this occurs when allocating from an allocation&n; *&t;&t;group whose size is equal to the number of blocks per dmap.&n; *&t;&t;in this case, the dmap control pages are not examined prior&n; *&t;&t;to calling this routine (to save pathlength) and the call&n; *&t;&t;might fail.&n; *&n; *&t;&t;for a request size that fits within a dmap, this routine relies&n; *&t;&t;upon the dmap&squot;s dmtree to find the requested contiguous free&n; *&t;&t;space.  for request sizes that are larger than a dmap, the&n; *&t;&t;requested free space will start at the first block of the&n; *&t;&t;first dmap (i.e. blkno).&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      nblocks&t; -  actual number of contiguous free blocks to allocate.&n; *      l2nb&t; -  log2 number of contiguous free blocks to allocate.&n; *      blkno&t; -  starting block number of the dmap to start the allocation&n; *&t;&t;    from.&n; *      results&t;-  on successful return, set to the starting block number&n; *&t;&t;   of the newly allocated range.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; *&n; * serialization: IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
r_static
r_int
DECL|function|dbAllocCtl
id|dbAllocCtl
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|s64
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
id|blkno
comma
id|s64
op_star
id|results
)paren
(brace
r_int
id|rc
comma
id|nb
suffix:semicolon
id|s64
id|b
comma
id|lblkno
comma
id|n
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* check if the allocation request is confined to a single dmap.&n;&t; */
r_if
c_cond
(paren
id|l2nb
op_le
id|L2BPERDMAP
)paren
(brace
multiline_comment|/* get the buffer for the dmap.&n;&t;&t; */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|bmp-&gt;db_ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* try to allocate the blocks.&n;&t;&t; */
id|rc
op_assign
id|dbAllocDmapLev
c_func
(paren
id|bmp
comma
id|dp
comma
(paren
r_int
)paren
id|nblocks
comma
id|l2nb
comma
id|results
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* allocation request involving multiple dmaps. it must start on&n;&t; * a dmap boundary.&n;&t; */
m_assert
(paren
(paren
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* allocate the blocks dmap by dmap.&n;&t; */
r_for
c_loop
(paren
id|n
op_assign
id|nblocks
comma
id|b
op_assign
id|blkno
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
id|n
op_sub_assign
id|nb
comma
id|b
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* get the buffer for the dmap.&n;&t;&t; */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|b
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|bmp-&gt;db_ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
id|EIO
suffix:semicolon
r_goto
id|backout
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* the dmap better be all free.&n;&t;&t; */
m_assert
(paren
id|dp-&gt;tree.stree
(braket
id|ROOT
)braket
op_eq
id|L2BPERDMAP
)paren
suffix:semicolon
multiline_comment|/* determine how many blocks to allocate from this dmap.&n;&t;&t; */
id|nb
op_assign
id|min
c_func
(paren
id|n
comma
(paren
id|s64
)paren
id|BPERDMAP
)paren
suffix:semicolon
multiline_comment|/* allocate the blocks from the dmap.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocDmap
c_func
(paren
id|bmp
comma
id|dp
comma
id|b
comma
id|nb
)paren
)paren
)paren
(brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|backout
suffix:semicolon
)brace
multiline_comment|/* write the buffer.&n;&t;&t; */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* set the results (starting block number) and return.&n;&t; */
op_star
id|results
op_assign
id|blkno
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* something failed in handling an allocation request involving&n;&t; * multiple dmaps.  we&squot;ll try to clean up by backing out any&n;&t; * allocation that has already happened for this request.  if&n;&t; * we fail in backing out the allocation, we&squot;ll mark the file&n;&t; * system to indicate that blocks have been leaked.&n;&t; */
id|backout
suffix:colon
multiline_comment|/* try to backout the allocations dmap by dmap.&n;&t; */
r_for
c_loop
(paren
id|n
op_assign
id|nblocks
op_minus
id|n
comma
id|b
op_assign
id|blkno
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
id|n
op_sub_assign
id|BPERDMAP
comma
id|b
op_add_assign
id|BPERDMAP
)paren
(brace
multiline_comment|/* get the buffer for this dmap.&n;&t;&t; */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|b
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|bmp-&gt;db_ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* could not back out.  mark the file system&n;&t;&t;&t; * to indicate that we have leaked blocks.&n;&t;&t;&t; */
id|fsDirty
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* !!! */
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;dbAllocCtl: I/O Error: Block Leakage.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* free the blocks is this dmap.&n;&t;&t; */
r_if
c_cond
(paren
id|dbFreeDmap
c_func
(paren
id|bmp
comma
id|dp
comma
id|b
comma
id|BPERDMAP
)paren
)paren
(brace
multiline_comment|/* could not back out.  mark the file system&n;&t;&t;&t; * to indicate that we have leaked blocks.&n;&t;&t;&t; */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|fsDirty
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* !!! */
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;dbAllocCtl: Block Leakage.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* write the buffer.&n;&t;&t; */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocDmapLev()&n; *&n; * FUNCTION:    attempt to allocate a specified number of contiguous blocks&n; *&t;&t;from a specified dmap.&n; *&t;&t;&n; *&t;&t;this routine checks if the contiguous blocks are available.&n; *&t;&t;if so, nblocks of blocks are allocated; otherwise, ENOSPC is&n; *&t;&t;returned.&n; *&n; * PARAMETERS:&n; *      mp&t;-  pointer to bmap descriptor&n; *      dp&t;-  pointer to dmap to attempt to allocate blocks from. &n; *      l2nb&t;-  log2 number of contiguous block desired.&n; *      nblocks&t;-  actual number of contiguous block desired.&n; *      results&t;-  on successful return, set to the starting block number&n; *&t;&t;   of the newly allocated range.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient disk resources&n; *      EIO&t;- i/o error&n; *&n; * serialization: IREAD_LOCK(ipbmap), e.g., from dbAlloc(), or &n; *&t;IWRITE_LOCK(ipbmap), e.g., dbAllocCtl(), held on entry/exit;&n; */
r_static
r_int
DECL|function|dbAllocDmapLev
id|dbAllocDmapLev
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
r_int
id|nblocks
comma
r_int
id|l2nb
comma
id|s64
op_star
id|results
)paren
(brace
id|s64
id|blkno
suffix:semicolon
r_int
id|leafidx
comma
id|rc
suffix:semicolon
multiline_comment|/* can&squot;t be more than a dmaps worth of blocks */
m_assert
(paren
id|l2nb
op_le
id|L2BPERDMAP
)paren
suffix:semicolon
multiline_comment|/* search the tree within the dmap page for sufficient&n;&t; * free space.  if sufficient free space is found, dbFindLeaf()&n;&t; * returns the index of the leaf at which free space was found.&n;&t; */
r_if
c_cond
(paren
id|dbFindLeaf
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
op_amp
id|dp-&gt;tree
comma
id|l2nb
comma
op_amp
id|leafidx
)paren
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/* determine the block number within the file system corresponding&n;&t; * to the leaf at which free space was found.&n;&t; */
id|blkno
op_assign
id|le64_to_cpu
c_func
(paren
id|dp-&gt;start
)paren
op_plus
(paren
id|leafidx
op_lshift
id|L2DBWORD
)paren
suffix:semicolon
multiline_comment|/* if not all bits of the dmap word are free, get the starting&n;&t; * bit number within the dmap word of the required string of free&n;&t; * bits and adjust the block number with this value.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;tree.stree
(braket
id|leafidx
op_plus
id|LEAFIND
)braket
OL
id|BUDMIN
)paren
id|blkno
op_add_assign
id|dbFindBits
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;wmap
(braket
id|leafidx
)braket
)paren
comma
id|l2nb
)paren
suffix:semicolon
multiline_comment|/* allocate the blocks */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocDmap
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
)paren
op_eq
l_int|0
)paren
op_star
id|results
op_assign
id|blkno
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocDmap()&n; *&n; * FUNCTION:    adjust the disk allocation map to reflect the allocation&n; *&t;&t;of a specified block range within a dmap.&n; *&n; *&t;&t;this routine allocates the specified blocks from the dmap&n; *&t;&t;through a call to dbAllocBits(). if the allocation of the&n; *&t;&t;block range causes the maximum string of free blocks within&n; *&t;&t;the dmap to change (i.e. the value of the root of the dmap&squot;s&n; *&t;&t;dmtree), this routine will cause this change to be reflected&n; *&t;&t;up through the appropriate levels of the dmap control pages&n; *&t;&t;by a call to dbAdjCtl() for the L0 dmap control page that&n; *&t;&t;covers this dmap.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      dp&t;-  pointer to dmap to allocate the block range from.&n; *      blkno&t;-  starting block number of the block to be allocated.&n; *      nblocks&t;-  number of blocks to be allocated.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      EIO&t;- i/o error&n; *&n; * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbAllocDmap
r_static
r_int
id|dbAllocDmap
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
(brace
id|s8
id|oldroot
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* save the current value of the root (i.e. maximum free string)&n;&t; * of the dmap tree.&n;&t; */
id|oldroot
op_assign
id|dp-&gt;tree.stree
(braket
id|ROOT
)braket
suffix:semicolon
multiline_comment|/* allocate the specified (blocks) bits */
id|dbAllocBits
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
multiline_comment|/* if the root has not changed, done. */
r_if
c_cond
(paren
id|dp-&gt;tree.stree
(braket
id|ROOT
)braket
op_eq
id|oldroot
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* root changed. bubble the change up to the dmap control pages.&n;&t; * if the adjustment of the upper level control pages fails,&n;&t; * backout the bit allocation (thus making everything consistent).&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAdjCtl
c_func
(paren
id|bmp
comma
id|blkno
comma
id|dp-&gt;tree.stree
(braket
id|ROOT
)braket
comma
l_int|1
comma
l_int|0
)paren
)paren
)paren
id|dbFreeBits
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbFreeDmap()&n; *&n; * FUNCTION:    adjust the disk allocation map to reflect the allocation&n; *&t;&t;of a specified block range within a dmap.&n; *&n; *&t;&t;this routine frees the specified blocks from the dmap through&n; *&t;&t;a call to dbFreeBits(). if the deallocation of the block range&n; *&t;&t;causes the maximum string of free blocks within the dmap to&n; *&t;&t;change (i.e. the value of the root of the dmap&squot;s dmtree), this&n; *&t;&t;routine will cause this change to be reflected up through the&n; *&t;        appropriate levels of the dmap control pages by a call to&n; *&t;&t;dbAdjCtl() for the L0 dmap control page that covers this dmap.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      dp&t;-  pointer to dmap to free the block range from.&n; *      blkno&t;-  starting block number of the block to be freed.&n; *      nblocks&t;-  number of blocks to be freed.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      EIO&t;- i/o error&n; *&n; * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbFreeDmap
r_static
r_int
id|dbFreeDmap
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
(brace
id|s8
id|oldroot
suffix:semicolon
r_int
id|rc
comma
id|word
suffix:semicolon
multiline_comment|/* save the current value of the root (i.e. maximum free string)&n;&t; * of the dmap tree.&n;&t; */
id|oldroot
op_assign
id|dp-&gt;tree.stree
(braket
id|ROOT
)braket
suffix:semicolon
multiline_comment|/* free the specified (blocks) bits */
id|dbFreeBits
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
multiline_comment|/* if the root has not changed, done. */
r_if
c_cond
(paren
id|dp-&gt;tree.stree
(braket
id|ROOT
)braket
op_eq
id|oldroot
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* root changed. bubble the change up to the dmap control pages.&n;&t; * if the adjustment of the upper level control pages fails,&n;&t; * backout the deallocation. &n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAdjCtl
c_func
(paren
id|bmp
comma
id|blkno
comma
id|dp-&gt;tree.stree
(braket
id|ROOT
)braket
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
id|word
op_assign
(paren
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
)paren
op_rshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* as part of backing out the deallocation, we will have&n;&t;&t; * to back split the dmap tree if the deallocation caused&n;&t;&t; * the freed blocks to become part of a larger binary buddy&n;&t;&t; * system.&n;&t;&t; */
r_if
c_cond
(paren
id|dp-&gt;tree.stree
(braket
id|word
)braket
op_eq
id|NOFREE
)paren
id|dbBackSplit
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
op_amp
id|dp-&gt;tree
comma
id|word
)paren
suffix:semicolon
id|dbAllocBits
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
)brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAllocBits()&n; *&n; * FUNCTION:    allocate a specified block range from a dmap.&n; *&n; *&t;&t;this routine updates the dmap to reflect the working&n; *&t;&t;state allocation of the specified block range. it directly&n; *&t;&t;updates the bits of the working map and causes the adjustment&n; *&t;&t;of the binary buddy system described by the dmap&squot;s dmtree&n; *&t;&t;leaves to reflect the bits allocated.  it also causes the&n; *&t;&t;dmap&squot;s dmtree, as a whole, to reflect the allocated range.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      dp&t;-  pointer to dmap to allocate bits from.&n; *      blkno&t;-  starting block number of the bits to be allocated.&n; *      nblocks&t;-  number of bits to be allocated.&n; *&n; * RETURN VALUES: none&n; *&n; * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbAllocBits
r_static
r_void
id|dbAllocBits
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
(brace
r_int
id|dbitno
comma
id|word
comma
id|rembits
comma
id|nb
comma
id|nwords
comma
id|wbitno
comma
id|nw
comma
id|agno
suffix:semicolon
id|dmtree_t
op_star
id|tp
op_assign
(paren
id|dmtree_t
op_star
)paren
op_amp
id|dp-&gt;tree
suffix:semicolon
r_int
id|size
suffix:semicolon
id|s8
op_star
id|leaf
suffix:semicolon
multiline_comment|/* pick up a pointer to the leaves of the dmap tree */
id|leaf
op_assign
id|dp-&gt;tree.stree
op_plus
id|LEAFIND
suffix:semicolon
multiline_comment|/* determine the bit number and word within the dmap of the&n;&t; * starting block.&n;&t; */
id|dbitno
op_assign
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
suffix:semicolon
id|word
op_assign
id|dbitno
op_rshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* block range better be within the dmap */
m_assert
(paren
id|dbitno
op_plus
id|nblocks
op_le
id|BPERDMAP
)paren
suffix:semicolon
multiline_comment|/* allocate the bits of the dmap&squot;s words corresponding to the block&n;&t; * range. not all bits of the first and last words may be contained&n;&t; * within the block range.  if this is the case, we&squot;ll work against&n;&t; * those words (i.e. partial first and/or last) on an individual basis&n;&t; * (a single pass), allocating the bits of interest by hand and&n;&t; * updating the leaf corresponding to the dmap word. a single pass&n;&t; * will be used for all dmap words fully contained within the&n;&t; * specified range.  within this pass, the bits of all fully contained&n;&t; * dmap words will be marked as free in a single shot and the leaves&n;&t; * will be updated. a single leaf may describe the free space of&n;&t; * multiple dmap words, so we may update only a subset of the actual&n;&t; * leaves corresponding to the dmap words of the block range.&n;&t; */
r_for
c_loop
(paren
id|rembits
op_assign
id|nblocks
suffix:semicolon
id|rembits
OG
l_int|0
suffix:semicolon
id|rembits
op_sub_assign
id|nb
comma
id|dbitno
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* determine the bit number within the word and&n;&t;&t; * the number of bits within the word.&n;&t;&t; */
id|wbitno
op_assign
id|dbitno
op_amp
(paren
id|DBWORD
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|rembits
comma
id|DBWORD
op_minus
id|wbitno
)paren
suffix:semicolon
multiline_comment|/* check if only part of a word is to be allocated.&n;&t;&t; */
r_if
c_cond
(paren
id|nb
OL
id|DBWORD
)paren
(brace
multiline_comment|/* allocate (set to 1) the appropriate bits within&n;&t;&t;&t; * this dmap word.&n;&t;&t;&t; */
id|dp-&gt;wmap
(braket
id|word
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nb
)paren
op_rshift
id|wbitno
)paren
suffix:semicolon
multiline_comment|/* update the leaf for this dmap word. in addition&n;&t;&t;&t; * to setting the leaf value to the binary buddy max&n;&t;&t;&t; * of the updated dmap word, dbSplit() will split&n;&t;&t;&t; * the binary system of the leaves if need be.&n;&t;&t;&t; */
id|dbSplit
c_func
(paren
id|tp
comma
id|word
comma
id|BUDMIN
comma
id|dbMaxBud
c_func
(paren
(paren
id|u8
op_star
)paren
op_amp
id|dp-&gt;wmap
(braket
id|word
)braket
)paren
)paren
suffix:semicolon
id|word
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one or more dmap words are fully contained&n;&t;&t;&t; * within the block range.  determine how many&n;&t;&t;&t; * words and allocate (set to 1) the bits of these&n;&t;&t;&t; * words.&n;&t;&t;&t; */
id|nwords
op_assign
id|rembits
op_rshift
id|L2DBWORD
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dp-&gt;wmap
(braket
id|word
)braket
comma
(paren
r_int
)paren
id|ONES
comma
id|nwords
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* determine how many bits.&n;&t;&t;&t; */
id|nb
op_assign
id|nwords
op_lshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* now update the appropriate leaves to reflect&n;&t;&t;&t; * the allocated words.&n;&t;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|nwords
OG
l_int|0
suffix:semicolon
id|nwords
op_sub_assign
id|nw
)paren
(brace
m_assert
(paren
id|leaf
(braket
id|word
)braket
op_ge
id|BUDMIN
)paren
suffix:semicolon
multiline_comment|/* determine what the leaf value should be&n;&t;&t;&t;&t; * updated to as the minimum of the l2 number&n;&t;&t;&t;&t; * of bits being allocated and the l2 number&n;&t;&t;&t;&t; * of bits currently described by this leaf.&n;&t;&t;&t;&t; */
id|size
op_assign
id|min
c_func
(paren
(paren
r_int
)paren
id|leaf
(braket
id|word
)braket
comma
id|NLSTOL2BSZ
c_func
(paren
id|nwords
)paren
)paren
suffix:semicolon
multiline_comment|/* update the leaf to reflect the allocation.&n;&t;&t;&t;&t; * in addition to setting the leaf value to&n;&t;&t;&t;&t; * NOFREE, dbSplit() will split the binary&n;&t;&t;&t;&t; * system of the leaves to reflect the current&n;&t;&t;&t;&t; * allocation (size).&n;&t;&t;&t;&t; */
id|dbSplit
c_func
(paren
id|tp
comma
id|word
comma
id|size
comma
id|NOFREE
)paren
suffix:semicolon
multiline_comment|/* get the number of dmap words handled */
id|nw
op_assign
id|BUDSIZE
c_func
(paren
id|size
comma
id|BUDMIN
)paren
suffix:semicolon
id|word
op_add_assign
id|nw
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* update the free count for this dmap */
id|dp-&gt;nfree
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;nfree
)paren
op_minus
id|nblocks
)paren
suffix:semicolon
id|BMAP_LOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
multiline_comment|/* if this allocation group is completely free,&n;&t; * update the maximum allocation group number if this allocation&n;&t; * group is the new max.&n;&t; */
id|agno
op_assign
id|blkno
op_rshift
id|bmp-&gt;db_agl2size
suffix:semicolon
r_if
c_cond
(paren
id|agno
OG
id|bmp-&gt;db_maxag
)paren
id|bmp-&gt;db_maxag
op_assign
id|agno
suffix:semicolon
multiline_comment|/* update the free count for the allocation group and map */
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_sub_assign
id|nblocks
suffix:semicolon
id|bmp-&gt;db_nfree
op_sub_assign
id|nblocks
suffix:semicolon
id|BMAP_UNLOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbFreeBits()&n; *&n; * FUNCTION:    free a specified block range from a dmap.&n; *&n; *&t;&t;this routine updates the dmap to reflect the working&n; *&t;&t;state allocation of the specified block range. it directly&n; *&t;&t;updates the bits of the working map and causes the adjustment&n; *&t;&t;of the binary buddy system described by the dmap&squot;s dmtree&n; *&t;&t;leaves to reflect the bits freed.  it also causes the dmap&squot;s&n; *&t;&t;dmtree, as a whole, to reflect the deallocated range.&n; *&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      dp&t;-  pointer to dmap to free bits from.&n; *      blkno&t;-  starting block number of the bits to be freed.&n; *      nblocks&t;-  number of bits to be freed.&n; *&n; * RETURN VALUES: none&n; *&n; * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbFreeBits
r_static
r_void
id|dbFreeBits
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
(brace
r_int
id|dbitno
comma
id|word
comma
id|rembits
comma
id|nb
comma
id|nwords
comma
id|wbitno
comma
id|nw
comma
id|agno
suffix:semicolon
id|dmtree_t
op_star
id|tp
op_assign
(paren
id|dmtree_t
op_star
)paren
op_amp
id|dp-&gt;tree
suffix:semicolon
r_int
id|size
suffix:semicolon
multiline_comment|/* determine the bit number and word within the dmap of the&n;&t; * starting block.&n;&t; */
id|dbitno
op_assign
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
suffix:semicolon
id|word
op_assign
id|dbitno
op_rshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* block range better be within the dmap.&n;&t; */
m_assert
(paren
id|dbitno
op_plus
id|nblocks
op_le
id|BPERDMAP
)paren
suffix:semicolon
multiline_comment|/* free the bits of the dmaps words corresponding to the block range.&n;&t; * not all bits of the first and last words may be contained within&n;&t; * the block range.  if this is the case, we&squot;ll work against those&n;&t; * words (i.e. partial first and/or last) on an individual basis&n;&t; * (a single pass), freeing the bits of interest by hand and updating&n;&t; * the leaf corresponding to the dmap word. a single pass will be used&n;&t; * for all dmap words fully contained within the specified range.  &n;&t; * within this pass, the bits of all fully contained dmap words will&n;&t; * be marked as free in a single shot and the leaves will be updated. a&n;&t; * single leaf may describe the free space of multiple dmap words,&n;&t; * so we may update only a subset of the actual leaves corresponding&n;&t; * to the dmap words of the block range.&n;&t; *&n;&t; * dbJoin() is used to update leaf values and will join the binary&n;&t; * buddy system of the leaves if the new leaf values indicate this&n;&t; * should be done.&n;&t; */
r_for
c_loop
(paren
id|rembits
op_assign
id|nblocks
suffix:semicolon
id|rembits
OG
l_int|0
suffix:semicolon
id|rembits
op_sub_assign
id|nb
comma
id|dbitno
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* determine the bit number within the word and&n;&t;&t; * the number of bits within the word.&n;&t;&t; */
id|wbitno
op_assign
id|dbitno
op_amp
(paren
id|DBWORD
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|rembits
comma
id|DBWORD
op_minus
id|wbitno
)paren
suffix:semicolon
multiline_comment|/* check if only part of a word is to be freed.&n;&t;&t; */
r_if
c_cond
(paren
id|nb
OL
id|DBWORD
)paren
(brace
multiline_comment|/* free (zero) the appropriate bits within this&n;&t;&t;&t; * dmap word. &n;&t;&t;&t; */
id|dp-&gt;wmap
(braket
id|word
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
(paren
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nb
)paren
op_rshift
id|wbitno
)paren
)paren
suffix:semicolon
multiline_comment|/* update the leaf for this dmap word.&n;&t;&t;&t; */
id|dbJoin
c_func
(paren
id|tp
comma
id|word
comma
id|dbMaxBud
c_func
(paren
(paren
id|u8
op_star
)paren
op_amp
id|dp-&gt;wmap
(braket
id|word
)braket
)paren
)paren
suffix:semicolon
id|word
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one or more dmap words are fully contained&n;&t;&t;&t; * within the block range.  determine how many&n;&t;&t;&t; * words and free (zero) the bits of these words.&n;&t;&t;&t; */
id|nwords
op_assign
id|rembits
op_rshift
id|L2DBWORD
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dp-&gt;wmap
(braket
id|word
)braket
comma
l_int|0
comma
id|nwords
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* determine how many bits.&n;&t;&t;&t; */
id|nb
op_assign
id|nwords
op_lshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* now update the appropriate leaves to reflect&n;&t;&t;&t; * the freed words.&n;&t;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|nwords
OG
l_int|0
suffix:semicolon
id|nwords
op_sub_assign
id|nw
)paren
(brace
multiline_comment|/* determine what the leaf value should be&n;&t;&t;&t;&t; * updated to as the minimum of the l2 number&n;&t;&t;&t;&t; * of bits being freed and the l2 (max) number&n;&t;&t;&t;&t; * of bits that can be described by this leaf.&n;&t;&t;&t;&t; */
id|size
op_assign
id|min
c_func
(paren
id|LITOL2BSZ
(paren
id|word
comma
id|L2LPERDMAP
comma
id|BUDMIN
)paren
comma
id|NLSTOL2BSZ
c_func
(paren
id|nwords
)paren
)paren
suffix:semicolon
multiline_comment|/* update the leaf.&n;&t;&t;&t;&t; */
id|dbJoin
c_func
(paren
id|tp
comma
id|word
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* get the number of dmap words handled.&n;&t;&t;&t;&t; */
id|nw
op_assign
id|BUDSIZE
c_func
(paren
id|size
comma
id|BUDMIN
)paren
suffix:semicolon
id|word
op_add_assign
id|nw
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* update the free count for this dmap.&n;&t; */
id|dp-&gt;nfree
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;nfree
)paren
op_plus
id|nblocks
)paren
suffix:semicolon
id|BMAP_LOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
multiline_comment|/* update the free count for the allocation group and &n;&t; * map.&n;&t; */
id|agno
op_assign
id|blkno
op_rshift
id|bmp-&gt;db_agl2size
suffix:semicolon
id|bmp-&gt;db_nfree
op_add_assign
id|nblocks
suffix:semicolon
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_add_assign
id|nblocks
suffix:semicolon
multiline_comment|/* check if this allocation group is not completely free and&n;&t; * if it is currently the maximum (rightmost) allocation group.&n;&t; * if so, establish the new maximum allocation group number by&n;&t; * searching left for the first allocation group with allocation.&n;&t; */
r_if
c_cond
(paren
(paren
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_eq
id|bmp-&gt;db_agsize
op_logical_and
id|agno
op_eq
id|bmp-&gt;db_maxag
)paren
op_logical_or
(paren
id|agno
op_eq
id|bmp-&gt;db_numag
op_minus
l_int|1
op_logical_and
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_eq
(paren
id|bmp
op_member_access_from_pointer
id|db_mapsize
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|bmp-&gt;db_maxag
OG
l_int|0
)paren
(brace
id|bmp-&gt;db_maxag
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bmp-&gt;db_agfree
(braket
id|bmp-&gt;db_maxag
)braket
op_ne
id|bmp-&gt;db_agsize
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* re-establish the allocation group preference if the&n;&t;&t; * current preference is right of the maximum allocation&n;&t;&t; * group.&n;&t;&t; */
r_if
c_cond
(paren
id|bmp-&gt;db_agpref
OG
id|bmp-&gt;db_maxag
)paren
id|bmp-&gt;db_agpref
op_assign
id|bmp-&gt;db_maxag
suffix:semicolon
)brace
id|BMAP_UNLOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAdjCtl()&n; *&n; * FUNCTION:&t;adjust a dmap control page at a specified level to reflect&n; *&t;&t;the change in a lower level dmap or dmap control page&squot;s&n; *&t;&t;maximum string of free blocks (i.e. a change in the root&n; *&t;&t;of the lower level object&squot;s dmtree) due to the allocation&n; *&t;&t;or deallocation of a range of blocks with a single dmap.&n; *&n; *&t;&t;on entry, this routine is provided with the new value of&n; *&t;&t;the lower level dmap or dmap control page root and the&n; *&t;&t;starting block number of the block range whose allocation&n; *&t;&t;or deallocation resulted in the root change.  this range&n; *&t;&t;is respresented by a single leaf of the current dmapctl&n; *&t;&t;and the leaf will be updated with this value, possibly&n; *&t;&t;causing a binary buddy system within the leaves to be &n; *&t;&t;split or joined.  the update may also cause the dmapctl&squot;s&n; *&t;&t;dmtree to be updated.&n; *&n; *&t;&t;if the adjustment of the dmap control page, itself, causes its&n; *&t;&t;root to change, this change will be bubbled up to the next dmap&n; *&t;&t;control level by a recursive call to this routine, specifying&n; *&t;&t;the new root value and the next dmap control page level to&n; *&t;&t;be adjusted.&n; * PARAMETERS:&n; *      bmp&t;-  pointer to bmap descriptor&n; *      blkno&t;-  the first block of a block range within a dmap.  it is&n; *&t;&t;   the allocation or deallocation of this block range that&n; *&t;&t;   requires the dmap control page to be adjusted.&n; *      newval&t;-  the new value of the lower level dmap or dmap control&n; *&t;&t;   page root.&n; *      alloc&t;-  TRUE if adjustment is due to an allocation.&n; *      level&t;-  current level of dmap control page (i.e. L0, L1, L2) to&n; *&t;&t;   be adjusted.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      EIO&t;- i/o error&n; *&n; * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
r_static
r_int
DECL|function|dbAdjCtl
id|dbAdjCtl
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|s64
id|blkno
comma
r_int
id|newval
comma
r_int
id|alloc
comma
r_int
id|level
)paren
(brace
id|metapage_t
op_star
id|mp
suffix:semicolon
id|s8
id|oldroot
suffix:semicolon
r_int
id|oldval
suffix:semicolon
id|s64
id|lblkno
suffix:semicolon
id|dmapctl_t
op_star
id|dcp
suffix:semicolon
r_int
id|rc
comma
id|leafno
comma
id|ti
suffix:semicolon
multiline_comment|/* get the buffer for the dmap control page for the specified&n;&t; * block number and control page level.&n;&t; */
id|lblkno
op_assign
id|BLKTOCTL
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
comma
id|level
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|bmp-&gt;db_ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
id|dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* determine the leaf number corresponding to the block and&n;&t; * the index within the dmap control tree.&n;&t; */
id|leafno
op_assign
id|BLKTOCTLLEAF
c_func
(paren
id|blkno
comma
id|dcp-&gt;budmin
)paren
suffix:semicolon
id|ti
op_assign
id|leafno
op_plus
id|le32_to_cpu
c_func
(paren
id|dcp-&gt;leafidx
)paren
suffix:semicolon
multiline_comment|/* save the current leaf value and the current root level (i.e.&n;&t; * maximum l2 free string described by this dmapctl).&n;&t; */
id|oldval
op_assign
id|dcp-&gt;stree
(braket
id|ti
)braket
suffix:semicolon
id|oldroot
op_assign
id|dcp-&gt;stree
(braket
id|ROOT
)braket
suffix:semicolon
multiline_comment|/* check if this is a control page update for an allocation.&n;&t; * if so, update the leaf to reflect the new leaf value using&n;&t; * dbSplit(); otherwise (deallocation), use dbJoin() to udpate&n;&t; * the leaf with the new value.  in addition to updating the&n;&t; * leaf, dbSplit() will also split the binary buddy system of&n;&t; * the leaves, if required, and bubble new values within the&n;&t; * dmapctl tree, if required.  similarly, dbJoin() will join&n;&t; * the binary buddy system of leaves and bubble new values up&n;&t; * the dmapctl tree as required by the new leaf value.&n;&t; */
r_if
c_cond
(paren
id|alloc
)paren
(brace
multiline_comment|/* check if we are in the middle of a binary buddy&n;&t;&t; * system.  this happens when we are performing the&n;&t;&t; * first allocation out of an allocation group that&n;&t;&t; * is part (not the first part) of a larger binary&n;&t;&t; * buddy system.  if we are in the middle, back split&n;&t;&t; * the system prior to calling dbSplit() which assumes&n;&t;&t; * that it is at the front of a binary buddy system.&n;&t;&t; */
r_if
c_cond
(paren
id|oldval
op_eq
id|NOFREE
)paren
(brace
id|dbBackSplit
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
id|dcp
comma
id|leafno
)paren
suffix:semicolon
id|oldval
op_assign
id|dcp-&gt;stree
(braket
id|ti
)braket
suffix:semicolon
)brace
id|dbSplit
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
id|dcp
comma
id|leafno
comma
id|dcp-&gt;budmin
comma
id|newval
)paren
suffix:semicolon
)brace
r_else
(brace
id|dbJoin
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
id|dcp
comma
id|leafno
comma
id|newval
)paren
suffix:semicolon
)brace
multiline_comment|/* check if the root of the current dmap control page changed due&n;&t; * to the update and if the current dmap control page is not at&n;&t; * the current top level (i.e. L0, L1, L2) of the map.  if so (i.e.&n;&t; * root changed and this is not the top level), call this routine&n;&t; * again (recursion) for the next higher level of the mapping to&n;&t; * reflect the change in root for the current dmap control page.&n;&t; */
r_if
c_cond
(paren
id|dcp-&gt;stree
(braket
id|ROOT
)braket
op_ne
id|oldroot
)paren
(brace
multiline_comment|/* are we below the top level of the map.  if so,&n;&t;&t; * bubble the root up to the next higher level.&n;&t;&t; */
r_if
c_cond
(paren
id|level
OL
id|bmp-&gt;db_maxlevel
)paren
(brace
multiline_comment|/* bubble up the new root of this dmap control page to&n;&t;&t;&t; * the next level.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAdjCtl
c_func
(paren
id|bmp
comma
id|blkno
comma
id|dcp-&gt;stree
(braket
id|ROOT
)braket
comma
id|alloc
comma
id|level
op_plus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* something went wrong in bubbling up the new&n;&t;&t;&t;&t; * root value, so backout the changes to the&n;&t;&t;&t;&t; * current dmap control page.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|alloc
)paren
(brace
id|dbJoin
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
id|dcp
comma
id|leafno
comma
id|oldval
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the dbJoin() above might have&n;&t;&t;&t;&t;&t; * caused a larger binary buddy system&n;&t;&t;&t;&t;&t; * to form and we may now be in the&n;&t;&t;&t;&t;&t; * middle of it.  if this is the case,&n;&t;&t;&t;&t;&t; * back split the buddies.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|dcp-&gt;stree
(braket
id|ti
)braket
op_eq
id|NOFREE
)paren
id|dbBackSplit
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
id|dcp
comma
id|leafno
)paren
suffix:semicolon
id|dbSplit
c_func
(paren
(paren
id|dmtree_t
op_star
)paren
id|dcp
comma
id|leafno
comma
id|dcp-&gt;budmin
comma
id|oldval
)paren
suffix:semicolon
)brace
multiline_comment|/* release the buffer and return the error.&n;&t;&t;&t;&t; */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* we&squot;re at the top level of the map. update&n;&t;&t;&t; * the bmap control page to reflect the size&n;&t;&t;&t; * of the maximum free buddy system.&n;&t;&t;&t; */
m_assert
(paren
id|level
op_eq
id|bmp-&gt;db_maxlevel
)paren
suffix:semicolon
m_assert
(paren
id|bmp-&gt;db_maxfreebud
op_eq
id|oldroot
)paren
suffix:semicolon
id|bmp-&gt;db_maxfreebud
op_assign
id|dcp-&gt;stree
(braket
id|ROOT
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* write the buffer.&n;&t; */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbSplit()&n; *&n; * FUNCTION:    update the leaf of a dmtree with a new value, splitting&n; *&t;&t;the leaf from the binary buddy system of the dmtree&squot;s&n; *&t;&t;leaves, as required.&n; *&n; * PARAMETERS:&n; *      tp&t;- pointer to the tree containing the leaf.&n; *      leafno&t;- the number of the leaf to be updated.&n; *      splitsz&t;- the size the binary buddy system starting at the leaf&n; *&t;&t;  must be split to, specified as the log2 number of blocks.&n; *      newval&t;- the new value for the leaf.&n; *&n; * RETURN VALUES: none&n; *&n; * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbSplit
r_static
r_void
id|dbSplit
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
comma
r_int
id|splitsz
comma
r_int
id|newval
)paren
(brace
r_int
id|budsz
suffix:semicolon
r_int
id|cursz
suffix:semicolon
id|s8
op_star
id|leaf
op_assign
id|tp-&gt;dmt_stree
op_plus
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_leafidx
)paren
suffix:semicolon
multiline_comment|/* check if the leaf needs to be split.&n;&t; */
r_if
c_cond
(paren
id|leaf
(braket
id|leafno
)braket
OG
id|tp-&gt;dmt_budmin
)paren
(brace
multiline_comment|/* the split occurs by cutting the buddy system in half&n;&t;&t; * at the specified leaf until we reach the specified&n;&t;&t; * size.  pick up the starting split size (current size&n;&t;&t; * - 1 in l2) and the corresponding buddy size.&n;&t;&t; */
id|cursz
op_assign
id|leaf
(braket
id|leafno
)braket
op_minus
l_int|1
suffix:semicolon
id|budsz
op_assign
id|BUDSIZE
c_func
(paren
id|cursz
comma
id|tp-&gt;dmt_budmin
)paren
suffix:semicolon
multiline_comment|/* split until we reach the specified size.&n;&t;&t; */
r_while
c_loop
(paren
id|cursz
op_ge
id|splitsz
)paren
(brace
multiline_comment|/* update the buddy&squot;s leaf with its new value.&n;&t;&t;&t; */
id|dbAdjTree
c_func
(paren
id|tp
comma
id|leafno
op_xor
id|budsz
comma
id|cursz
)paren
suffix:semicolon
multiline_comment|/* on to the next size and buddy.&n;&t;&t;&t; */
id|cursz
op_sub_assign
l_int|1
suffix:semicolon
id|budsz
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* adjust the dmap tree to reflect the specified leaf&squot;s new &n;&t; * value.&n;&t; */
id|dbAdjTree
c_func
(paren
id|tp
comma
id|leafno
comma
id|newval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbBackSplit()&n; *&n; * FUNCTION:    back split the binary buddy system of dmtree leaves&n; *&t;&t;that hold a specified leaf until the specified leaf&n; *&t;&t;starts its own binary buddy system.&n; *&n; *&t;&t;the allocators typically perform allocations at the start&n; *&t;&t;of binary buddy systems and dbSplit() is used to accomplish&n; *&t;&t;any required splits.  in some cases, however, allocation&n; *&t;&t;may occur in the middle of a binary system and requires a&n; *&t;&t;back split, with the split proceeding out from the middle of&n; *&t;&t;the system (less efficient) rather than the start of the&n; *&t;&t;system (more efficient).  the cases in which a back split&n; *&t;&t;is required are rare and are limited to the first allocation&n; *&t;&t;within an allocation group which is a part (not first part)&n; *&t;&t;of a larger binary buddy system and a few exception cases&n; *&t;&t;in which a previous join operation must be backed out.&n; *&n; * PARAMETERS:&n; *      tp&t;- pointer to the tree containing the leaf.&n; *      leafno&t;- the number of the leaf to be updated.&n; *&n; * RETURN VALUES: none&n; *&n; * serialization: IREAD_LOCK(ipbmap) or IWRITE_LOCK(ipbmap) held on entry/exit;&n; */
DECL|function|dbBackSplit
r_static
r_void
id|dbBackSplit
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
)paren
(brace
r_int
id|budsz
comma
id|bud
comma
id|w
comma
id|bsz
comma
id|size
suffix:semicolon
r_int
id|cursz
suffix:semicolon
id|s8
op_star
id|leaf
op_assign
id|tp-&gt;dmt_stree
op_plus
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_leafidx
)paren
suffix:semicolon
multiline_comment|/* leaf should be part (not first part) of a binary&n;&t; * buddy system.&n;&t; */
m_assert
(paren
id|leaf
(braket
id|leafno
)braket
op_eq
id|NOFREE
)paren
suffix:semicolon
multiline_comment|/* the back split is accomplished by iteratively finding the leaf&n;&t; * that starts the buddy system that contains the specified leaf and&n;&t; * splitting that system in two.  this iteration continues until&n;&t; * the specified leaf becomes the start of a buddy system. &n;&t; *&n;&t; * determine maximum possible l2 size for the specified leaf.&n;&t; */
id|size
op_assign
id|LITOL2BSZ
c_func
(paren
id|leafno
comma
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_l2nleafs
)paren
comma
id|tp-&gt;dmt_budmin
)paren
suffix:semicolon
multiline_comment|/* determine the number of leaves covered by this size.  this&n;&t; * is the buddy size that we will start with as we search for&n;&t; * the buddy system that contains the specified leaf.&n;&t; */
id|budsz
op_assign
id|BUDSIZE
c_func
(paren
id|size
comma
id|tp-&gt;dmt_budmin
)paren
suffix:semicolon
multiline_comment|/* back split.&n;&t; */
r_while
c_loop
(paren
id|leaf
(braket
id|leafno
)braket
op_eq
id|NOFREE
)paren
(brace
multiline_comment|/* find the leftmost buddy leaf.&n;&t;&t; */
r_for
c_loop
(paren
id|w
op_assign
id|leafno
comma
id|bsz
op_assign
id|budsz
suffix:semicolon
suffix:semicolon
id|bsz
op_lshift_assign
l_int|1
comma
id|w
op_assign
(paren
id|w
OL
id|bud
)paren
ques
c_cond
id|w
suffix:colon
id|bud
)paren
(brace
m_assert
(paren
id|bsz
OL
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_nleafs
)paren
)paren
suffix:semicolon
multiline_comment|/* determine the buddy.&n;&t;&t;&t; */
id|bud
op_assign
id|w
op_xor
id|bsz
suffix:semicolon
multiline_comment|/* check if this buddy is the start of the system.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|leaf
(braket
id|bud
)braket
op_ne
id|NOFREE
)paren
(brace
multiline_comment|/* split the leaf at the start of the&n;&t;&t;&t;&t; * system in two.&n;&t;&t;&t;&t; */
id|cursz
op_assign
id|leaf
(braket
id|bud
)braket
op_minus
l_int|1
suffix:semicolon
id|dbSplit
c_func
(paren
id|tp
comma
id|bud
comma
id|cursz
comma
id|cursz
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
m_assert
(paren
id|leaf
(braket
id|leafno
)braket
op_eq
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbJoin()&n; *&n; * FUNCTION:    update the leaf of a dmtree with a new value, joining&n; *&t;&t;the leaf with other leaves of the dmtree into a multi-leaf&n; *&t;&t;binary buddy system, as required.&n; *&n; * PARAMETERS:&n; *      tp&t;- pointer to the tree containing the leaf.&n; *      leafno&t;- the number of the leaf to be updated.&n; *      newval&t;- the new value for the leaf.&n; *&n; * RETURN VALUES: none&n; */
DECL|function|dbJoin
r_static
r_void
id|dbJoin
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
comma
r_int
id|newval
)paren
(brace
r_int
id|budsz
comma
id|buddy
suffix:semicolon
id|s8
op_star
id|leaf
suffix:semicolon
multiline_comment|/* can the new leaf value require a join with other leaves ?&n;&t; */
r_if
c_cond
(paren
id|newval
op_ge
id|tp-&gt;dmt_budmin
)paren
(brace
multiline_comment|/* pickup a pointer to the leaves of the tree.&n;&t;&t; */
id|leaf
op_assign
id|tp-&gt;dmt_stree
op_plus
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_leafidx
)paren
suffix:semicolon
multiline_comment|/* try to join the specified leaf into a large binary&n;&t;&t; * buddy system.  the join proceeds by attempting to join&n;&t;&t; * the specified leafno with its buddy (leaf) at new value.&n;&t;&t; * if the join occurs, we attempt to join the left leaf&n;&t;&t; * of the joined buddies with its buddy at new value + 1.&n;&t;&t; * we continue to join until we find a buddy that cannot be&n;&t;&t; * joined (does not have a value equal to the size of the&n;&t;&t; * last join) or until all leaves have been joined into a&n;&t;&t; * single system.&n;&t;&t; *&n;&t;&t; * get the buddy size (number of words covered) of&n;&t;&t; * the new value.&n;&t;&t; */
id|budsz
op_assign
id|BUDSIZE
c_func
(paren
id|newval
comma
id|tp-&gt;dmt_budmin
)paren
suffix:semicolon
multiline_comment|/* try to join.&n;&t;&t; */
r_while
c_loop
(paren
id|budsz
OL
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_nleafs
)paren
)paren
(brace
multiline_comment|/* get the buddy leaf.&n;&t;&t;&t; */
id|buddy
op_assign
id|leafno
op_xor
id|budsz
suffix:semicolon
multiline_comment|/* if the leaf&squot;s new value is greater than its&n;&t;&t;&t; * buddy&squot;s value, we join no more.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|newval
OG
id|leaf
(braket
id|buddy
)braket
)paren
r_break
suffix:semicolon
m_assert
(paren
id|newval
op_eq
id|leaf
(braket
id|buddy
)braket
)paren
suffix:semicolon
multiline_comment|/* check which (leafno or buddy) is the left buddy.&n;&t;&t;&t; * the left buddy gets to claim the blocks resulting&n;&t;&t;&t; * from the join while the right gets to claim none.&n;&t;&t;&t; * the left buddy is also eligable to participate in&n;&t;&t;&t; * a join at the next higher level while the right&n;&t;&t;&t; * is not.&n;&t;&t;&t; *&n;&t;&t;&t; */
r_if
c_cond
(paren
id|leafno
OL
id|buddy
)paren
(brace
multiline_comment|/* leafno is the left buddy.&n;&t;&t;&t;&t; */
id|dbAdjTree
c_func
(paren
id|tp
comma
id|buddy
comma
id|NOFREE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* buddy is the left buddy and becomes&n;&t;&t;&t;&t; * leafno.&n;&t;&t;&t;&t; */
id|dbAdjTree
c_func
(paren
id|tp
comma
id|leafno
comma
id|NOFREE
)paren
suffix:semicolon
id|leafno
op_assign
id|buddy
suffix:semicolon
)brace
multiline_comment|/* on to try the next join.&n;&t;&t;&t; */
id|newval
op_add_assign
l_int|1
suffix:semicolon
id|budsz
op_lshift_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* update the leaf value.&n;&t; */
id|dbAdjTree
c_func
(paren
id|tp
comma
id|leafno
comma
id|newval
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbAdjTree()&n; *&n; * FUNCTION:    update a leaf of a dmtree with a new value, adjusting&n; *&t;&t;the dmtree, as required, to reflect the new leaf value.&n; *&t;&t;the combination of any buddies must already be done before&n; *&t;&t;this is called.&n; *&n; * PARAMETERS:&n; *      tp&t;- pointer to the tree to be adjusted.&n; *      leafno&t;- the number of the leaf to be updated.&n; *      newval&t;- the new value for the leaf.&n; *&n; * RETURN VALUES: none&n; */
DECL|function|dbAdjTree
r_static
r_void
id|dbAdjTree
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|leafno
comma
r_int
id|newval
)paren
(brace
r_int
id|lp
comma
id|pp
comma
id|k
suffix:semicolon
r_int
id|max
suffix:semicolon
multiline_comment|/* pick up the index of the leaf for this leafno.&n;&t; */
id|lp
op_assign
id|leafno
op_plus
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_leafidx
)paren
suffix:semicolon
multiline_comment|/* is the current value the same as the old value ?  if so,&n;&t; * there is nothing to do.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;dmt_stree
(braket
id|lp
)braket
op_eq
id|newval
)paren
r_return
suffix:semicolon
multiline_comment|/* set the new value.&n;&t; */
id|tp-&gt;dmt_stree
(braket
id|lp
)braket
op_assign
id|newval
suffix:semicolon
multiline_comment|/* bubble the new value up the tree as required.&n;&t; */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_height
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/* get the index of the first leaf of the 4 leaf&n;&t;&t; * group containing the specified leaf (leafno).&n;&t;&t; */
id|lp
op_assign
(paren
(paren
id|lp
op_minus
l_int|1
)paren
op_amp
op_complement
l_int|0x03
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* get the index of the parent of this 4 leaf group.&n;&t;&t; */
id|pp
op_assign
(paren
id|lp
op_minus
l_int|1
)paren
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* determine the maximum of the 4 leaves.&n;&t;&t; */
id|max
op_assign
id|TREEMAX
c_func
(paren
op_amp
id|tp-&gt;dmt_stree
(braket
id|lp
)braket
)paren
suffix:semicolon
multiline_comment|/* if the maximum of the 4 is the same as the&n;&t;&t; * parent&squot;s value, we&squot;re done.&n;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;dmt_stree
(braket
id|pp
)braket
op_eq
id|max
)paren
r_break
suffix:semicolon
multiline_comment|/* parent gets new value.&n;&t;&t; */
id|tp-&gt;dmt_stree
(braket
id|pp
)braket
op_assign
id|max
suffix:semicolon
multiline_comment|/* parent becomes leaf for next go-round.&n;&t;&t; */
id|lp
op_assign
id|pp
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NAME:&t;dbFindLeaf()&n; *&n; * FUNCTION:    search a dmtree_t for sufficient free blocks, returning&n; *&t;&t;the index of a leaf describing the free blocks if &n; *&t;&t;sufficient free blocks are found.&n; *&n; *&t;&t;the search starts at the top of the dmtree_t tree and&n; *&t;&t;proceeds down the tree to the leftmost leaf with sufficient&n; *&t;&t;free space.&n; *&n; * PARAMETERS:&n; *      tp&t;- pointer to the tree to be searched.&n; *      l2nb&t;- log2 number of free blocks to search for.&n; *&t;leafidx&t;- return pointer to be set to the index of the leaf&n; *&t;&t;  describing at least l2nb free blocks if sufficient&n; *&t;&t;  free blocks are found.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      ENOSPC&t;- insufficient free blocks. &n; */
DECL|function|dbFindLeaf
r_static
r_int
id|dbFindLeaf
c_func
(paren
id|dmtree_t
op_star
id|tp
comma
r_int
id|l2nb
comma
r_int
op_star
id|leafidx
)paren
(brace
r_int
id|ti
comma
id|n
op_assign
l_int|0
comma
id|k
comma
id|x
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first check the root of the tree to see if there is&n;&t; * sufficient free space.&n;&t; */
r_if
c_cond
(paren
id|l2nb
OG
id|tp-&gt;dmt_stree
(braket
id|ROOT
)braket
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/* sufficient free space available. now search down the tree&n;&t; * starting at the next level for the leftmost leaf that&n;&t; * describes sufficient free space.&n;&t; */
r_for
c_loop
(paren
id|k
op_assign
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_height
)paren
comma
id|ti
op_assign
l_int|1
suffix:semicolon
id|k
OG
l_int|0
suffix:semicolon
id|k
op_decrement
comma
id|ti
op_assign
(paren
(paren
id|ti
op_plus
id|n
)paren
op_lshift
l_int|2
)paren
op_plus
l_int|1
)paren
(brace
multiline_comment|/* search the four nodes at this level, starting from&n;&t;&t; * the left.&n;&t;&t; */
r_for
c_loop
(paren
id|x
op_assign
id|ti
comma
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|4
suffix:semicolon
id|n
op_increment
)paren
(brace
multiline_comment|/* sufficient free space found.  move to the next&n;&t;&t;&t; * level (or quit if this is the last level).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|l2nb
op_le
id|tp-&gt;dmt_stree
(braket
id|x
op_plus
id|n
)braket
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* better have found something since the higher&n;&t;&t; * levels of the tree said it was here.&n;&t;&t; */
m_assert
(paren
id|n
OL
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* set the return to the leftmost leaf describing sufficient&n;&t; * free space.&n;&t; */
op_star
id|leafidx
op_assign
id|x
op_plus
id|n
op_minus
id|le32_to_cpu
c_func
(paren
id|tp-&gt;dmt_leafidx
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbFindBits()&n; *&n; * FUNCTION:    find a specified number of binary buddy free bits within a&n; *&t;&t;dmap bitmap word value.&n; *&n; *&t;&t;this routine searches the bitmap value for (1 &lt;&lt; l2nb) free&n; *&t;&t;bits at (1 &lt;&lt; l2nb) alignments within the value.&n; *&n; * PARAMETERS:&n; *      word&t;-  dmap bitmap word value.&n; *      l2nb&t;-  number of free bits specified as a log2 number.&n; *&n; * RETURN VALUES:&n; *      starting bit number of free bits.&n; */
DECL|function|dbFindBits
r_static
r_int
id|dbFindBits
c_func
(paren
id|u32
id|word
comma
r_int
id|l2nb
)paren
(brace
r_int
id|bitno
comma
id|nb
suffix:semicolon
id|u32
id|mask
suffix:semicolon
multiline_comment|/* get the number of bits.&n;&t; */
id|nb
op_assign
l_int|1
op_lshift
id|l2nb
suffix:semicolon
m_assert
(paren
id|nb
op_le
id|DBWORD
)paren
suffix:semicolon
multiline_comment|/* complement the word so we can use a mask (i.e. 0s represent&n;&t; * free bits) and compute the mask.&n;&t; */
id|word
op_assign
op_complement
id|word
suffix:semicolon
id|mask
op_assign
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nb
)paren
suffix:semicolon
multiline_comment|/* scan the word for nb free bits at nb alignments.&n;&t; */
r_for
c_loop
(paren
id|bitno
op_assign
l_int|0
suffix:semicolon
id|mask
op_ne
l_int|0
suffix:semicolon
id|bitno
op_add_assign
id|nb
comma
id|mask
op_rshift_assign
id|nb
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|word
)paren
op_eq
id|mask
)paren
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bitno
OL
l_int|32
)paren
suffix:semicolon
multiline_comment|/* return the bit number.&n;&t; */
r_return
(paren
id|bitno
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbMaxBud(u8 *cp)&n; *&n; * FUNCTION:    determine the largest binary buddy string of free&n; *&t;&t;bits within 32-bits of the map.&n; *&n; * PARAMETERS:&n; *      cp&t;-  pointer to the 32-bit value.&n; *&n; * RETURN VALUES:&n; *      largest binary buddy of free bits within a dmap word.&n; */
DECL|function|dbMaxBud
r_static
r_int
id|dbMaxBud
c_func
(paren
id|u8
op_star
id|cp
)paren
(brace
r_int
r_char
id|tmp1
comma
id|tmp2
suffix:semicolon
multiline_comment|/* check if the wmap word is all free. if so, the&n;&t; * free buddy size is BUDMIN.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
(paren
id|uint
op_star
)paren
id|cp
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|BUDMIN
)paren
suffix:semicolon
multiline_comment|/* check if the wmap word is half free. if so, the&n;&t; * free buddy size is BUDMIN-1.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
(paren
id|u16
op_star
)paren
id|cp
)paren
op_eq
l_int|0
op_logical_or
op_star
(paren
(paren
id|u16
op_star
)paren
id|cp
op_plus
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|BUDMIN
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* not all free or half free. determine the free buddy&n;&t; * size thru table lookup using quarters of the wmap word.&n;&t; */
id|tmp1
op_assign
id|max
c_func
(paren
id|budtab
(braket
id|cp
(braket
l_int|2
)braket
)braket
comma
id|budtab
(braket
id|cp
(braket
l_int|3
)braket
)braket
)paren
suffix:semicolon
id|tmp2
op_assign
id|max
c_func
(paren
id|budtab
(braket
id|cp
(braket
l_int|0
)braket
)braket
comma
id|budtab
(braket
id|cp
(braket
l_int|1
)braket
)braket
)paren
suffix:semicolon
r_return
(paren
id|max
c_func
(paren
id|tmp1
comma
id|tmp2
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;cnttz(uint word)&n; *&n; * FUNCTION:    determine the number of trailing zeros within a 32-bit&n; *&t;&t;value.&n; *&n; * PARAMETERS:&n; *      value&t;-  32-bit value to be examined.&n; *&n; * RETURN VALUES:&n; *      count of trailing zeros&n; */
DECL|function|cnttz
r_int
id|cnttz
c_func
(paren
id|u32
id|word
)paren
(brace
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|32
suffix:semicolon
id|n
op_increment
comma
id|word
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|word
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;cntlz(u32 value)&n; *&n; * FUNCTION:    determine the number of leading zeros within a 32-bit&n; *&t;&t;value.&n; *&n; * PARAMETERS:&n; *      value&t;-  32-bit value to be examined.&n; *&n; * RETURN VALUES:&n; *      count of leading zeros&n; */
DECL|function|cntlz
r_int
id|cntlz
c_func
(paren
id|u32
id|value
)paren
(brace
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|32
suffix:semicolon
id|n
op_increment
comma
id|value
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|value
op_amp
id|HIGHORDER
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|n
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;blkstol2(s64 nb)&n; *&n; * FUNCTION:&t;convert a block count to its log2 value. if the block&n; *&t;        count is not a l2 multiple, it is rounded up to the next&n; *&t;&t;larger l2 multiple.&n; *&n; * PARAMETERS:&n; *      nb&t;-  number of blocks&n; *&n; * RETURN VALUES:&n; *      log2 number of blocks&n; */
DECL|function|blkstol2
r_int
id|blkstol2
c_func
(paren
id|s64
id|nb
)paren
(brace
r_int
id|l2nb
suffix:semicolon
id|s64
id|mask
suffix:semicolon
multiline_comment|/* meant to be signed */
id|mask
op_assign
(paren
id|s64
)paren
l_int|1
op_lshift
(paren
l_int|64
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* count the leading bits.&n;&t; */
r_for
c_loop
(paren
id|l2nb
op_assign
l_int|0
suffix:semicolon
id|l2nb
OL
l_int|64
suffix:semicolon
id|l2nb
op_increment
comma
id|mask
op_rshift_assign
l_int|1
)paren
(brace
multiline_comment|/* leading bit found.&n;&t;&t; */
r_if
c_cond
(paren
id|nb
op_amp
id|mask
)paren
(brace
multiline_comment|/* determine the l2 value.&n;&t;&t;&t; */
id|l2nb
op_assign
(paren
l_int|64
op_minus
l_int|1
)paren
op_minus
id|l2nb
suffix:semicolon
multiline_comment|/* check if we need to round up.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_complement
id|mask
op_amp
id|nb
)paren
id|l2nb
op_increment
suffix:semicolon
r_return
(paren
id|l2nb
)paren
suffix:semicolon
)brace
)brace
m_assert
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* fix compiler warning */
)brace
multiline_comment|/*&n; * NAME:&t;fsDirty()&n; *&n; * FUNCTION:    xxx&n; *&n; * PARAMETERS:&n; *      ipmnt&t;- mount inode&n; *&n; * RETURN VALUES:&n; *      none&n; */
DECL|function|fsDirty
r_void
id|fsDirty
c_func
(paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fsDirty(): bye-bye&bslash;n&quot;
)paren
suffix:semicolon
m_assert
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:    &t;dbAllocBottomUp()&n; *&n; * FUNCTION:&t;alloc the specified block range from the working block&n; *&t;&t;allocation map.&n; *&n; *&t;&t;the blocks will be alloc from the working map one dmap&n; *&t;&t;at a time.&n; *&n; * PARAMETERS:&n; *      ip&t;-  pointer to in-core inode;&n; *      blkno&t;-  starting block number to be freed.&n; *      nblocks&t;-  number of blocks to be freed.&n; *&n; * RETURN VALUES:&n; *      0&t;- success&n; *      EIO&t;- i/o error&n; */
DECL|function|dbAllocBottomUp
r_int
id|dbAllocBottomUp
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
)paren
(brace
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
r_int
id|nb
comma
id|rc
suffix:semicolon
id|s64
id|lblkno
comma
id|rem
suffix:semicolon
r_struct
id|inode
op_star
id|ipbmap
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipbmap
suffix:semicolon
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
id|IREAD_LOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
multiline_comment|/* block to be allocated better be within the mapsize. */
id|ASSERT
c_func
(paren
id|nblocks
op_le
id|bmp-&gt;db_mapsize
op_minus
id|blkno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allocate the blocks a dmap at a time.&n;&t; */
id|mp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|rem
op_assign
id|nblocks
suffix:semicolon
id|rem
OG
l_int|0
suffix:semicolon
id|rem
op_sub_assign
id|nb
comma
id|blkno
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* release previous dmap if any */
r_if
c_cond
(paren
id|mp
)paren
(brace
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* get the buffer for the current dmap. */
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|blkno
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* determine the number of blocks to be allocated from&n;&t;&t; * this dmap.&n;&t;&t; */
id|nb
op_assign
id|min
c_func
(paren
id|rem
comma
id|BPERDMAP
op_minus
(paren
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|DBFREECK
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
id|blkno
comma
id|nb
)paren
suffix:semicolon
multiline_comment|/* allocate the blocks. */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocDmapBU
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nb
)paren
)paren
)paren
(brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|DBALLOC
c_func
(paren
id|bmp-&gt;db_DBmap
comma
id|bmp-&gt;db_mapsize
comma
id|blkno
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/* write the last buffer. */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipbmap
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|dbAllocDmapBU
r_static
r_int
id|dbAllocDmapBU
c_func
(paren
id|bmap_t
op_star
id|bmp
comma
id|dmap_t
op_star
id|dp
comma
id|s64
id|blkno
comma
r_int
id|nblocks
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|dbitno
comma
id|word
comma
id|rembits
comma
id|nb
comma
id|nwords
comma
id|wbitno
comma
id|agno
suffix:semicolon
id|s8
id|oldroot
comma
op_star
id|leaf
suffix:semicolon
id|dmaptree_t
op_star
id|tp
op_assign
(paren
id|dmaptree_t
op_star
)paren
op_amp
id|dp-&gt;tree
suffix:semicolon
multiline_comment|/* save the current value of the root (i.e. maximum free string)&n;&t; * of the dmap tree.&n;&t; */
id|oldroot
op_assign
id|tp-&gt;stree
(braket
id|ROOT
)braket
suffix:semicolon
multiline_comment|/* pick up a pointer to the leaves of the dmap tree */
id|leaf
op_assign
id|tp-&gt;stree
op_plus
id|LEAFIND
suffix:semicolon
multiline_comment|/* determine the bit number and word within the dmap of the&n;&t; * starting block.&n;&t; */
id|dbitno
op_assign
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
suffix:semicolon
id|word
op_assign
id|dbitno
op_rshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* block range better be within the dmap */
m_assert
(paren
id|dbitno
op_plus
id|nblocks
op_le
id|BPERDMAP
)paren
suffix:semicolon
multiline_comment|/* allocate the bits of the dmap&squot;s words corresponding to the block&n;&t; * range. not all bits of the first and last words may be contained&n;&t; * within the block range.  if this is the case, we&squot;ll work against&n;&t; * those words (i.e. partial first and/or last) on an individual basis&n;&t; * (a single pass), allocating the bits of interest by hand and&n;&t; * updating the leaf corresponding to the dmap word. a single pass&n;&t; * will be used for all dmap words fully contained within the&n;&t; * specified range.  within this pass, the bits of all fully contained&n;&t; * dmap words will be marked as free in a single shot and the leaves&n;&t; * will be updated. a single leaf may describe the free space of&n;&t; * multiple dmap words, so we may update only a subset of the actual&n;&t; * leaves corresponding to the dmap words of the block range.&n;&t; */
r_for
c_loop
(paren
id|rembits
op_assign
id|nblocks
suffix:semicolon
id|rembits
OG
l_int|0
suffix:semicolon
id|rembits
op_sub_assign
id|nb
comma
id|dbitno
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* determine the bit number within the word and&n;&t;&t; * the number of bits within the word.&n;&t;&t; */
id|wbitno
op_assign
id|dbitno
op_amp
(paren
id|DBWORD
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|rembits
comma
id|DBWORD
op_minus
id|wbitno
)paren
suffix:semicolon
multiline_comment|/* check if only part of a word is to be allocated.&n;&t;&t; */
r_if
c_cond
(paren
id|nb
OL
id|DBWORD
)paren
(brace
multiline_comment|/* allocate (set to 1) the appropriate bits within&n;&t;&t;&t; * this dmap word.&n;&t;&t;&t; */
id|dp-&gt;wmap
(braket
id|word
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nb
)paren
op_rshift
id|wbitno
)paren
suffix:semicolon
id|word
op_add_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one or more dmap words are fully contained&n;&t;&t;&t; * within the block range.  determine how many&n;&t;&t;&t; * words and allocate (set to 1) the bits of these&n;&t;&t;&t; * words.&n;&t;&t;&t; */
id|nwords
op_assign
id|rembits
op_rshift
id|L2DBWORD
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dp-&gt;wmap
(braket
id|word
)braket
comma
(paren
r_int
)paren
id|ONES
comma
id|nwords
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* determine how many bits */
id|nb
op_assign
id|nwords
op_lshift
id|L2DBWORD
suffix:semicolon
)brace
)brace
multiline_comment|/* update the free count for this dmap */
id|dp-&gt;nfree
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;nfree
)paren
op_minus
id|nblocks
)paren
suffix:semicolon
multiline_comment|/* reconstruct summary tree */
id|dbInitDmapTree
c_func
(paren
id|dp
)paren
suffix:semicolon
id|BMAP_LOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
multiline_comment|/* if this allocation group is completely free,&n;&t; * update the highest active allocation group number &n;&t; * if this allocation group is the new max.&n;&t; */
id|agno
op_assign
id|blkno
op_rshift
id|bmp-&gt;db_agl2size
suffix:semicolon
r_if
c_cond
(paren
id|agno
OG
id|bmp-&gt;db_maxag
)paren
id|bmp-&gt;db_maxag
op_assign
id|agno
suffix:semicolon
multiline_comment|/* update the free count for the allocation group and map */
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_sub_assign
id|nblocks
suffix:semicolon
id|bmp-&gt;db_nfree
op_sub_assign
id|nblocks
suffix:semicolon
id|BMAP_UNLOCK
c_func
(paren
id|bmp
)paren
suffix:semicolon
multiline_comment|/* if the root has not changed, done. */
r_if
c_cond
(paren
id|tp-&gt;stree
(braket
id|ROOT
)braket
op_eq
id|oldroot
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* root changed. bubble the change up to the dmap control pages.&n;&t; * if the adjustment of the upper level control pages fails,&n;&t; * backout the bit allocation (thus making everything consistent).&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAdjCtl
c_func
(paren
id|bmp
comma
id|blkno
comma
id|tp-&gt;stree
(braket
id|ROOT
)braket
comma
l_int|1
comma
l_int|0
)paren
)paren
)paren
id|dbFreeBits
c_func
(paren
id|bmp
comma
id|dp
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbExtendFS()&n; *&n; * FUNCTION:&t;extend bmap from blkno for nblocks;&n; * &t;&t;dbExtendFS() updates bmap ready for dbAllocBottomUp();&n; *&n; * L2&n; *  |&n; *   L1---------------------------------L1&n; *    |                                  |&n; *     L0---------L0---------L0           L0---------L0---------L0&n; *      |          |          |            |          |          |&n; *       d0,...,dn  d0,...,dn  d0,...,dn    d0,...,dn  d0,...,dn  d0,.,dm;&n; * L2L1L0d0,...,dnL0d0,...,dnL0d0,...,dnL1L0d0,...,dnL0d0,...,dnL0d0,..dm&n; *&n; * &lt;---old---&gt;&lt;----------------------------extend-----------------------&gt;   &n; */
DECL|function|dbExtendFS
r_int
id|dbExtendFS
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
suffix:semicolon
r_int
id|nbperpage
op_assign
id|sbi-&gt;nbperpage
suffix:semicolon
r_int
id|i
comma
id|i0
op_assign
id|TRUE
comma
id|j
comma
id|j0
op_assign
id|TRUE
comma
id|k
comma
id|n
suffix:semicolon
id|s64
id|newsize
suffix:semicolon
id|s64
id|p
suffix:semicolon
id|metapage_t
op_star
id|mp
comma
op_star
id|l2mp
comma
op_star
id|l1mp
comma
op_star
id|l0mp
suffix:semicolon
id|dmapctl_t
op_star
id|l2dcp
comma
op_star
id|l1dcp
comma
op_star
id|l0dcp
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
id|s8
op_star
id|l0leaf
comma
op_star
id|l1leaf
comma
op_star
id|l2leaf
suffix:semicolon
id|bmap_t
op_star
id|bmp
op_assign
id|sbi-&gt;bmap
suffix:semicolon
r_int
id|agno
comma
id|l2agsize
comma
id|oldl2agsize
suffix:semicolon
id|s64
id|ag_rem
suffix:semicolon
id|newsize
op_assign
id|blkno
op_plus
id|nblocks
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dbExtendFS: blkno:%Ld nblocks:%Ld newsize:%Ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|blkno
comma
(paren
r_int
r_int
)paren
id|nblocks
comma
(paren
r_int
r_int
)paren
id|newsize
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      initialize bmap control page.&n;&t; *&n;&t; * all the data in bmap control page should exclude&n;&t; * the mkfs hidden dmap page.&n;&t; */
multiline_comment|/* update mapsize */
id|bmp-&gt;db_mapsize
op_assign
id|newsize
suffix:semicolon
id|bmp-&gt;db_maxlevel
op_assign
id|BMAPSZTOLEV
c_func
(paren
id|bmp-&gt;db_mapsize
)paren
suffix:semicolon
multiline_comment|/* compute new AG size */
id|l2agsize
op_assign
id|dbGetL2AGSize
c_func
(paren
id|newsize
)paren
suffix:semicolon
id|oldl2agsize
op_assign
id|bmp-&gt;db_agl2size
suffix:semicolon
id|bmp-&gt;db_agl2size
op_assign
id|l2agsize
suffix:semicolon
id|bmp-&gt;db_agsize
op_assign
l_int|1
op_lshift
id|l2agsize
suffix:semicolon
multiline_comment|/* compute new number of AG */
id|agno
op_assign
id|bmp-&gt;db_numag
suffix:semicolon
id|bmp-&gt;db_numag
op_assign
id|newsize
op_rshift
id|l2agsize
suffix:semicolon
id|bmp-&gt;db_numag
op_add_assign
(paren
(paren
id|u32
)paren
id|newsize
op_mod
(paren
id|u32
)paren
id|bmp-&gt;db_agsize
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      reconfigure db_agfree[] &n;&t; * from old AG configuration to new AG configuration;&n;&t; *&n;&t; * coalesce contiguous k (newAGSize/oldAGSize) AGs;&n;&t; * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;&n;&t; * note: new AG size = old AG size * (2**x).&n;&t; */
r_if
c_cond
(paren
id|l2agsize
op_eq
id|oldl2agsize
)paren
r_goto
id|extend
suffix:semicolon
id|k
op_assign
l_int|1
op_lshift
(paren
id|l2agsize
op_minus
id|oldl2agsize
)paren
suffix:semicolon
id|ag_rem
op_assign
id|bmp-&gt;db_agfree
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* save agfree[0] */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|n
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|agno
suffix:semicolon
id|n
op_increment
)paren
(brace
id|bmp-&gt;db_agfree
(braket
id|n
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* init collection point */
multiline_comment|/* coalesce cotiguous k AGs; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|k
op_logical_and
id|i
OL
id|agno
suffix:semicolon
id|j
op_increment
comma
id|i
op_increment
)paren
(brace
multiline_comment|/* merge AGi to AGn */
id|bmp-&gt;db_agfree
(braket
id|n
)braket
op_add_assign
id|bmp-&gt;db_agfree
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|bmp-&gt;db_agfree
(braket
l_int|0
)braket
op_add_assign
id|ag_rem
suffix:semicolon
multiline_comment|/* restore agfree[0] */
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|MAXAG
suffix:semicolon
id|n
op_increment
)paren
id|bmp-&gt;db_agfree
(braket
id|n
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * update highest active ag number&n;&t; */
id|bmp-&gt;db_maxag
op_assign
id|bmp-&gt;db_maxag
op_div
id|k
suffix:semicolon
multiline_comment|/*&n;&t; *      extend bmap&n;&t; *&n;&t; * update bit maps and corresponding level control pages;&n;&t; * global control page db_nfree, db_agfree[agno], db_maxfreebud;&n;&t; */
id|extend
suffix:colon
multiline_comment|/* get L2 page */
id|p
op_assign
id|BMAPBLKNO
op_plus
id|nbperpage
suffix:semicolon
multiline_comment|/* L2 page */
id|l2mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|p
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|l2mp
)paren
suffix:semicolon
id|l2dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|l2mp-&gt;data
suffix:semicolon
multiline_comment|/* compute start L1 */
id|k
op_assign
id|blkno
op_rshift
id|L2MAXL1SIZE
suffix:semicolon
id|l2leaf
op_assign
id|l2dcp-&gt;stree
op_plus
id|CTLLEAFIND
op_plus
id|k
suffix:semicolon
id|p
op_assign
id|BLKTOL1
c_func
(paren
id|blkno
comma
id|sbi-&gt;l2nbperpage
)paren
suffix:semicolon
multiline_comment|/* L1 page */
multiline_comment|/*&n;&t; * extend each L1 in L2&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|k
OL
id|LPERCTL
suffix:semicolon
id|k
op_increment
comma
id|p
op_add_assign
id|nbperpage
)paren
(brace
multiline_comment|/* get L1 page */
r_if
c_cond
(paren
id|j0
)paren
(brace
multiline_comment|/* read in L1 page: (blkno &amp; (MAXL1SIZE - 1)) */
id|l1mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|p
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l1mp
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
id|l1dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|l1mp-&gt;data
suffix:semicolon
multiline_comment|/* compute start L0 */
id|j
op_assign
(paren
id|blkno
op_amp
(paren
id|MAXL1SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|L2MAXL0SIZE
suffix:semicolon
id|l1leaf
op_assign
id|l1dcp-&gt;stree
op_plus
id|CTLLEAFIND
op_plus
id|j
suffix:semicolon
id|p
op_assign
id|BLKTOL0
c_func
(paren
id|blkno
comma
id|sbi-&gt;l2nbperpage
)paren
suffix:semicolon
id|j0
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assign/init L1 page */
id|l1mp
op_assign
id|get_metapage
c_func
(paren
id|ipbmap
comma
id|p
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l1mp
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
id|l1dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|l1mp-&gt;data
suffix:semicolon
multiline_comment|/* compute start L0 */
id|j
op_assign
l_int|0
suffix:semicolon
id|l1leaf
op_assign
id|l1dcp-&gt;stree
op_plus
id|CTLLEAFIND
suffix:semicolon
id|p
op_add_assign
id|nbperpage
suffix:semicolon
multiline_comment|/* 1st L0 of L1.k  */
)brace
multiline_comment|/*&n;&t;&t; * extend each L0 in L1&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|j
OL
id|LPERCTL
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* get L0 page */
r_if
c_cond
(paren
id|i0
)paren
(brace
multiline_comment|/* read in L0 page: (blkno &amp; (MAXL0SIZE - 1)) */
id|l0mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|p
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l0mp
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
id|l0dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|l0mp-&gt;data
suffix:semicolon
multiline_comment|/* compute start dmap */
id|i
op_assign
(paren
id|blkno
op_amp
(paren
id|MAXL0SIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|L2BPERDMAP
suffix:semicolon
id|l0leaf
op_assign
id|l0dcp-&gt;stree
op_plus
id|CTLLEAFIND
op_plus
id|i
suffix:semicolon
id|p
op_assign
id|BLKTODMAP
c_func
(paren
id|blkno
comma
id|sbi-&gt;l2nbperpage
)paren
suffix:semicolon
id|i0
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assign/init L0 page */
id|l0mp
op_assign
id|get_metapage
c_func
(paren
id|ipbmap
comma
id|p
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l0mp
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
id|l0dcp
op_assign
(paren
id|dmapctl_t
op_star
)paren
id|l0mp-&gt;data
suffix:semicolon
multiline_comment|/* compute start dmap */
id|i
op_assign
l_int|0
suffix:semicolon
id|l0leaf
op_assign
id|l0dcp-&gt;stree
op_plus
id|CTLLEAFIND
suffix:semicolon
id|p
op_add_assign
id|nbperpage
suffix:semicolon
multiline_comment|/* 1st dmap of L0.j */
)brace
multiline_comment|/*&n;&t;&t;&t; * extend each dmap in L0&n;&t;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|LPERCTL
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * reconstruct the dmap page, and&n;&t;&t;&t;&t; * initialize corresponding parent L0 leaf&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|n
op_assign
id|blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* read in dmap page: */
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|p
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
id|n
op_assign
id|min
c_func
(paren
id|nblocks
comma
(paren
id|s64
)paren
id|BPERDMAP
op_minus
id|n
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* assign/init dmap page */
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|p
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
r_goto
id|errout
suffix:semicolon
id|n
op_assign
id|min
c_func
(paren
id|nblocks
comma
(paren
id|s64
)paren
id|BPERDMAP
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
op_star
id|l0leaf
op_assign
id|dbInitDmap
c_func
(paren
id|dp
comma
id|blkno
comma
id|n
)paren
suffix:semicolon
id|bmp-&gt;db_nfree
op_add_assign
id|n
suffix:semicolon
id|agno
op_assign
id|le64_to_cpu
c_func
(paren
id|dp-&gt;start
)paren
op_rshift
id|l2agsize
suffix:semicolon
id|bmp-&gt;db_agfree
(braket
id|agno
)braket
op_add_assign
id|n
suffix:semicolon
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|l0leaf
op_increment
suffix:semicolon
id|p
op_add_assign
id|nbperpage
suffix:semicolon
id|blkno
op_add_assign
id|n
suffix:semicolon
id|nblocks
op_sub_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* for each dmap in a L0 */
multiline_comment|/*&n;&t;&t;&t; * build current L0 page from its leaves, and &n;&t;&t;&t; * initialize corresponding parent L1 leaf&n;&t;&t;&t; */
op_star
id|l1leaf
op_assign
id|dbInitDmapCtl
c_func
(paren
id|l0dcp
comma
l_int|0
comma
op_increment
id|i
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|l0mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
)paren
id|l1leaf
op_increment
suffix:semicolon
multiline_comment|/* continue for next L0 */
r_else
(brace
multiline_comment|/* more than 1 L0 ? */
r_if
c_cond
(paren
id|j
OG
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* build L1 page */
r_else
(brace
multiline_comment|/* summarize in global bmap page */
id|bmp-&gt;db_maxfreebud
op_assign
op_star
id|l1leaf
suffix:semicolon
id|release_metapage
c_func
(paren
id|l1mp
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|l2mp
)paren
suffix:semicolon
r_goto
id|finalize
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* for each L0 in a L1 */
multiline_comment|/*&n;&t;&t; * build current L1 page from its leaves, and &n;&t;&t; * initialize corresponding parent L2 leaf&n;&t;&t; */
op_star
id|l2leaf
op_assign
id|dbInitDmapCtl
c_func
(paren
id|l1dcp
comma
l_int|1
comma
op_increment
id|j
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|l1mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
)paren
id|l2leaf
op_increment
suffix:semicolon
multiline_comment|/* continue for next L1 */
r_else
(brace
multiline_comment|/* more than 1 L1 ? */
r_if
c_cond
(paren
id|k
OG
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* build L2 page */
r_else
(brace
multiline_comment|/* summarize in global bmap page */
id|bmp-&gt;db_maxfreebud
op_assign
op_star
id|l2leaf
suffix:semicolon
id|release_metapage
c_func
(paren
id|l2mp
)paren
suffix:semicolon
r_goto
id|finalize
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* for each L1 in a L2 */
m_assert
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      finalize bmap control page&n;&t; */
id|finalize
suffix:colon
r_return
l_int|0
suffix:semicolon
id|errout
suffix:colon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dbFinalizeBmap()&n; */
DECL|function|dbFinalizeBmap
r_void
id|dbFinalizeBmap
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
)paren
(brace
id|bmap_t
op_star
id|bmp
op_assign
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
r_int
id|actags
comma
id|inactags
comma
id|l2nl
suffix:semicolon
id|s64
id|ag_rem
comma
id|actfree
comma
id|inactfree
comma
id|avgfree
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
multiline_comment|/*&n;&t; *      finalize bmap control page&n;&t; */
singleline_comment|//finalize:
multiline_comment|/* &n;&t; * compute db_agpref: preferred ag to allocate from&n;&t; * (the leftmost ag with average free space in it);&n;&t; */
singleline_comment|//agpref:
multiline_comment|/* get the number of active ags and inacitve ags */
id|actags
op_assign
id|bmp-&gt;db_maxag
op_plus
l_int|1
suffix:semicolon
id|inactags
op_assign
id|bmp-&gt;db_numag
op_minus
id|actags
suffix:semicolon
id|ag_rem
op_assign
id|bmp-&gt;db_mapsize
op_amp
(paren
id|bmp-&gt;db_agsize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* ??? */
multiline_comment|/* determine how many blocks are in the inactive allocation&n;&t; * groups. in doing this, we must account for the fact that&n;&t; * the rightmost group might be a partial group (i.e. file&n;&t; * system size is not a multiple of the group size).&n;&t; */
id|inactfree
op_assign
(paren
id|inactags
op_logical_and
id|ag_rem
)paren
ques
c_cond
(paren
(paren
id|inactags
op_minus
l_int|1
)paren
op_lshift
id|bmp-&gt;db_agl2size
)paren
op_plus
id|ag_rem
suffix:colon
id|inactags
op_lshift
id|bmp-&gt;db_agl2size
suffix:semicolon
multiline_comment|/* determine how many free blocks are in the active&n;&t; * allocation groups plus the average number of free blocks&n;&t; * within the active ags.&n;&t; */
id|actfree
op_assign
id|bmp-&gt;db_nfree
op_minus
id|inactfree
suffix:semicolon
id|avgfree
op_assign
(paren
id|u32
)paren
id|actfree
op_div
(paren
id|u32
)paren
id|actags
suffix:semicolon
multiline_comment|/* if the preferred allocation group has not average free space.&n;&t; * re-establish the preferred group as the leftmost&n;&t; * group with average free space.&n;&t; */
r_if
c_cond
(paren
id|bmp-&gt;db_agfree
(braket
id|bmp-&gt;db_agpref
)braket
OL
id|avgfree
)paren
(brace
r_for
c_loop
(paren
id|bmp-&gt;db_agpref
op_assign
l_int|0
suffix:semicolon
id|bmp-&gt;db_agpref
OL
id|actags
suffix:semicolon
id|bmp-&gt;db_agpref
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bmp-&gt;db_agfree
(braket
id|bmp-&gt;db_agpref
)braket
op_ge
id|avgfree
)paren
r_break
suffix:semicolon
)brace
m_assert
(paren
id|bmp-&gt;db_agpref
OL
id|bmp-&gt;db_numag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * compute db_aglevel, db_agheigth, db_width, db_agstart:&n;&t; * an ag is covered in aglevel dmapctl summary tree, &n;&t; * at agheight level height (from leaf) with agwidth number of nodes &n;&t; * each, which starts at agstart index node of the smmary tree node &n;&t; * array;&n;&t; */
id|bmp-&gt;db_aglevel
op_assign
id|BMAPSZTOLEV
c_func
(paren
id|bmp-&gt;db_agsize
)paren
suffix:semicolon
id|l2nl
op_assign
id|bmp-&gt;db_agl2size
op_minus
(paren
id|L2BPERDMAP
op_plus
id|bmp-&gt;db_aglevel
op_star
id|L2LPERCTL
)paren
suffix:semicolon
id|bmp-&gt;db_agheigth
op_assign
id|l2nl
op_rshift
l_int|1
suffix:semicolon
id|bmp-&gt;db_agwidth
op_assign
l_int|1
op_lshift
(paren
id|l2nl
op_minus
(paren
id|bmp-&gt;db_agheigth
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|5
op_minus
id|bmp-&gt;db_agheigth
comma
id|bmp-&gt;db_agstart
op_assign
l_int|0
comma
id|n
op_assign
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|bmp-&gt;db_agstart
op_add_assign
id|n
suffix:semicolon
id|n
op_lshift_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;printk(&quot;bmap: agpref:%d aglevel:%d agheigth:%d agwidth:%d&bslash;n&quot;,&n;&t;bmp-&gt;db_agpref, bmp-&gt;db_aglevel, bmp-&gt;db_agheigth, bmp-&gt;db_agwidth);&n;*/
)brace
multiline_comment|/*&n; * NAME:&t;dbInitDmap()/ujfs_idmap_page()&n; *                                                                    &n; * FUNCTION:&t;initialize working/persistent bitmap of the dmap page&n; *&t;&t;for the specified number of blocks:&n; *                                                                    &n; *&t;&t;at entry, the bitmaps had been initialized as free (ZEROS);&n; *&t;&t;The number of blocks will only account for the actually &n; *&t;&t;existing blocks. Blocks which don&squot;t actually exist in &n; *&t;&t;the aggregate will be marked as allocated (ONES);&n; *&n; * PARAMETERS:&n; *&t;dp&t;- pointer to page of map&n; *&t;nblocks&t;- number of blocks this page&n; *&n; * RETURNS: NONE&n; */
DECL|function|dbInitDmap
r_static
r_int
id|dbInitDmap
c_func
(paren
id|dmap_t
op_star
id|dp
comma
id|s64
id|Blkno
comma
r_int
id|nblocks
)paren
(brace
r_int
id|blkno
comma
id|w
comma
id|b
comma
id|r
comma
id|nw
comma
id|nb
comma
id|i
suffix:semicolon
multiline_comment|/*&n;printk(&quot;sbh_dmap:  in dbInitDmap blkno:%Ld nblocks:%ld&bslash;n&quot;, Blkno, nblocks); &n;*/
multiline_comment|/* starting block number within the dmap */
id|blkno
op_assign
id|Blkno
op_amp
(paren
id|BPERDMAP
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
op_eq
l_int|0
)paren
(brace
id|dp-&gt;nblocks
op_assign
id|dp-&gt;nfree
op_assign
id|cpu_to_le32
c_func
(paren
id|nblocks
)paren
suffix:semicolon
id|dp-&gt;start
op_assign
id|cpu_to_le64
c_func
(paren
id|Blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
op_eq
id|BPERDMAP
)paren
(brace
id|memset
c_func
(paren
op_amp
id|dp-&gt;wmap
(braket
l_int|0
)braket
comma
l_int|0
comma
id|LPERDMAP
op_star
l_int|4
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dp-&gt;pmap
(braket
l_int|0
)braket
comma
l_int|0
comma
id|LPERDMAP
op_star
l_int|4
)paren
suffix:semicolon
r_goto
id|initTree
suffix:semicolon
)brace
)brace
r_else
(brace
id|dp-&gt;nblocks
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;nblocks
)paren
op_plus
id|nblocks
)paren
suffix:semicolon
id|dp-&gt;nfree
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;nfree
)paren
op_plus
id|nblocks
)paren
suffix:semicolon
)brace
multiline_comment|/* word number containing start block number */
id|w
op_assign
id|blkno
op_rshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/*&n;&t; * free the bits corresponding to the block range (ZEROS):&n;&t; * note: not all bits of the first and last words may be contained &n;&t; * within the block range.&n;&t; */
r_for
c_loop
(paren
id|r
op_assign
id|nblocks
suffix:semicolon
id|r
OG
l_int|0
suffix:semicolon
id|r
op_sub_assign
id|nb
comma
id|blkno
op_add_assign
id|nb
)paren
(brace
multiline_comment|/* number of bits preceding range to be freed in the word */
id|b
op_assign
id|blkno
op_amp
(paren
id|DBWORD
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* number of bits to free in the word */
id|nb
op_assign
id|min
c_func
(paren
id|r
comma
id|DBWORD
op_minus
id|b
)paren
suffix:semicolon
multiline_comment|/* is partial word to be freed ? */
r_if
c_cond
(paren
id|nb
OL
id|DBWORD
)paren
(brace
multiline_comment|/* free (set to 0) from the bitmap word */
id|dp-&gt;wmap
(braket
id|w
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
(paren
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nb
)paren
op_rshift
id|b
)paren
)paren
suffix:semicolon
id|dp-&gt;pmap
(braket
id|w
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
(paren
id|ONES
op_lshift
(paren
id|DBWORD
op_minus
id|nb
)paren
op_rshift
id|b
)paren
)paren
suffix:semicolon
multiline_comment|/* skip the word freed */
id|w
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* free (set to 0) contiguous bitmap words */
id|nw
op_assign
id|r
op_rshift
id|L2DBWORD
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dp-&gt;wmap
(braket
id|w
)braket
comma
l_int|0
comma
id|nw
op_star
l_int|4
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dp-&gt;pmap
(braket
id|w
)braket
comma
l_int|0
comma
id|nw
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* skip the words freed */
id|nb
op_assign
id|nw
op_lshift
id|L2DBWORD
suffix:semicolon
id|w
op_add_assign
id|nw
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * mark bits following the range to be freed (non-existing &n;&t; * blocks) as allocated (ONES)&n;&t; */
multiline_comment|/*&n;printk(&quot;sbh_dmap:  in dbInitDmap, preparing to mark unbacked, blkno:%ld nblocks:%ld&bslash;n&quot;,&n;&t;&t;blkno, nblocks); &n;*/
r_if
c_cond
(paren
id|blkno
op_eq
id|BPERDMAP
)paren
r_goto
id|initTree
suffix:semicolon
multiline_comment|/* the first word beyond the end of existing blocks */
id|w
op_assign
id|blkno
op_rshift
id|L2DBWORD
suffix:semicolon
multiline_comment|/* does nblocks fall on a 32-bit boundary ? */
id|b
op_assign
id|blkno
op_amp
(paren
id|DBWORD
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;printk(&quot;sbh_dmap:  in dbInitDmap, b:%ld w:%ld mask: %lx&bslash;n&quot;, b, w, (ONES&gt;&gt;b)); &n;*/
r_if
c_cond
(paren
id|b
)paren
(brace
multiline_comment|/* mark a partial word allocated */
id|dp-&gt;wmap
(braket
id|w
)braket
op_assign
id|dp-&gt;pmap
(braket
id|w
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|ONES
op_rshift
id|b
)paren
suffix:semicolon
id|w
op_increment
suffix:semicolon
)brace
multiline_comment|/* set the rest of the words in the page to allocated (ONES) */
r_for
c_loop
(paren
id|i
op_assign
id|w
suffix:semicolon
id|i
OL
id|LPERDMAP
suffix:semicolon
id|i
op_increment
)paren
id|dp-&gt;pmap
(braket
id|i
)braket
op_assign
id|dp-&gt;wmap
(braket
id|i
)braket
op_assign
id|ONES
suffix:semicolon
multiline_comment|/*&n;&t; * init tree&n;&t; */
id|initTree
suffix:colon
r_return
(paren
id|dbInitDmapTree
c_func
(paren
id|dp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbInitDmapTree()/ujfs_complete_dmap()&n; *                                                                    &n; * FUNCTION:&t;initialize summary tree of the specified dmap:&n; *&n; *&t;&t;at entry, bitmap of the dmap has been initialized;&n; *                                                                    &n; * PARAMETERS:&n; *&t;dp&t;- dmap to complete&n; *&t;blkno&t;- starting block number for this dmap&n; *&t;treemax&t;- will be filled in with max free for this dmap&n; *&n; * RETURNS:&t;max free string at the root of the tree&n; */
DECL|function|dbInitDmapTree
r_static
r_int
id|dbInitDmapTree
c_func
(paren
id|dmap_t
op_star
id|dp
)paren
(brace
id|dmaptree_t
op_star
id|tp
suffix:semicolon
id|s8
op_star
id|cp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* init fixed info of tree */
id|tp
op_assign
op_amp
id|dp-&gt;tree
suffix:semicolon
id|tp-&gt;nleafs
op_assign
id|cpu_to_le32
c_func
(paren
id|LPERDMAP
)paren
suffix:semicolon
id|tp-&gt;l2nleafs
op_assign
id|cpu_to_le32
c_func
(paren
id|L2LPERDMAP
)paren
suffix:semicolon
id|tp-&gt;leafidx
op_assign
id|cpu_to_le32
c_func
(paren
id|LEAFIND
)paren
suffix:semicolon
id|tp-&gt;height
op_assign
id|cpu_to_le32
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|tp-&gt;budmin
op_assign
id|BUDMIN
suffix:semicolon
multiline_comment|/* init each leaf from corresponding wmap word:&n;&t; * note: leaf is set to NOFREE(-1) if all blocks of corresponding&n;&t; * bitmap word are allocated. &n;&t; */
id|cp
op_assign
id|tp-&gt;stree
op_plus
id|le32_to_cpu
c_func
(paren
id|tp-&gt;leafidx
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LPERDMAP
suffix:semicolon
id|i
op_increment
)paren
op_star
id|cp
op_increment
op_assign
id|dbMaxBud
c_func
(paren
(paren
id|u8
op_star
)paren
op_amp
id|dp-&gt;wmap
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* build the dmap&squot;s binary buddy summary tree */
r_return
(paren
id|dbInitTree
c_func
(paren
id|tp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbInitTree()/ujfs_adjtree()&n; *                                                                    &n; * FUNCTION:&t;initialize binary buddy summary tree of a dmap or dmapctl.&n; *&n; *&t;&t;at entry, the leaves of the tree has been initialized &n; *&t;&t;from corresponding bitmap word or root of summary tree&n; *&t;&t;of the child control page;&n; *&t;&t;configure binary buddy system at the leaf level, then&n; *&t;&t;bubble up the values of the leaf nodes up the tree.&n; *&n; * PARAMETERS:&n; *&t;cp&t;- Pointer to the root of the tree&n; *&t;l2leaves- Number of leaf nodes as a power of 2&n; *&t;l2min&t;- Number of blocks that can be covered by a leaf&n; *&t;&t;  as a power of 2&n; *&n; * RETURNS: max free string at the root of the tree&n; */
DECL|function|dbInitTree
r_static
r_int
id|dbInitTree
c_func
(paren
id|dmaptree_t
op_star
id|dtp
)paren
(brace
r_int
id|l2max
comma
id|l2free
comma
id|bsize
comma
id|nextb
comma
id|i
suffix:semicolon
r_int
id|child
comma
id|parent
comma
id|nparent
suffix:semicolon
id|s8
op_star
id|tp
comma
op_star
id|cp
comma
op_star
id|cp1
suffix:semicolon
id|tp
op_assign
id|dtp-&gt;stree
suffix:semicolon
multiline_comment|/* Determine the maximum free string possible for the leaves */
id|l2max
op_assign
id|le32_to_cpu
c_func
(paren
id|dtp-&gt;l2nleafs
)paren
op_plus
id|dtp-&gt;budmin
suffix:semicolon
multiline_comment|/*&n;&t; * configure the leaf levevl into binary buddy system&n;&t; *&n;&t; * Try to combine buddies starting with a buddy size of 1 &n;&t; * (i.e. two leaves). At a buddy size of 1 two buddy leaves &n;&t; * can be combined if both buddies have a maximum free of l2min; &n;&t; * the combination will result in the left-most buddy leaf having &n;&t; * a maximum free of l2min+1.  &n;&t; * After processing all buddies for a given size, process buddies &n;&t; * at the next higher buddy size (i.e. current size * 2) and &n;&t; * the next maximum free (current free + 1).  &n;&t; * This continues until the maximum possible buddy combination &n;&t; * yields maximum free.&n;&t; */
r_for
c_loop
(paren
id|l2free
op_assign
id|dtp-&gt;budmin
comma
id|bsize
op_assign
l_int|1
suffix:semicolon
id|l2free
OL
id|l2max
suffix:semicolon
id|l2free
op_increment
comma
id|bsize
op_assign
id|nextb
)paren
(brace
multiline_comment|/* get next buddy size == current buddy pair size */
id|nextb
op_assign
id|bsize
op_lshift
l_int|1
suffix:semicolon
multiline_comment|/* scan each adjacent buddy pair at current buddy size */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cp
op_assign
id|tp
op_plus
id|le32_to_cpu
c_func
(paren
id|dtp-&gt;leafidx
)paren
suffix:semicolon
id|i
OL
id|le32_to_cpu
c_func
(paren
id|dtp-&gt;nleafs
)paren
suffix:semicolon
id|i
op_add_assign
id|nextb
comma
id|cp
op_add_assign
id|nextb
)paren
(brace
multiline_comment|/* coalesce if both adjacent buddies are max free */
r_if
c_cond
(paren
op_star
id|cp
op_eq
id|l2free
op_logical_and
op_star
(paren
id|cp
op_plus
id|bsize
)paren
op_eq
id|l2free
)paren
(brace
op_star
id|cp
op_assign
id|l2free
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* left take right */
op_star
(paren
id|cp
op_plus
id|bsize
)paren
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* right give left */
)brace
)brace
)brace
multiline_comment|/*&n;&t; * bubble summary information of leaves up the tree.&n;&t; *&n;&t; * Starting at the leaf node level, the four nodes described by&n;&t; * the higher level parent node are compared for a maximum free and &n;&t; * this maximum becomes the value of the parent node.  &n;&t; * when all lower level nodes are processed in this fashion then &n;&t; * move up to the next level (parent becomes a lower level node) and &n;&t; * continue the process for that level.&n;&t; */
r_for
c_loop
(paren
id|child
op_assign
id|le32_to_cpu
c_func
(paren
id|dtp-&gt;leafidx
)paren
comma
id|nparent
op_assign
id|le32_to_cpu
c_func
(paren
id|dtp-&gt;nleafs
)paren
op_rshift
l_int|2
suffix:semicolon
id|nparent
OG
l_int|0
suffix:semicolon
id|nparent
op_rshift_assign
l_int|2
comma
id|child
op_assign
id|parent
)paren
(brace
multiline_comment|/* get index of 1st node of parent level */
id|parent
op_assign
(paren
id|child
op_minus
l_int|1
)paren
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/* set the value of the parent node as the maximum &n;&t;&t; * of the four nodes of the current level.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cp
op_assign
id|tp
op_plus
id|child
comma
id|cp1
op_assign
id|tp
op_plus
id|parent
suffix:semicolon
id|i
OL
id|nparent
suffix:semicolon
id|i
op_increment
comma
id|cp
op_add_assign
l_int|4
comma
id|cp1
op_increment
)paren
op_star
id|cp1
op_assign
id|TREEMAX
c_func
(paren
id|cp
)paren
suffix:semicolon
)brace
r_return
(paren
op_star
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dbInitDmapCtl()&n; *&n; * function: initialize dmapctl page&n; */
DECL|function|dbInitDmapCtl
r_static
r_int
id|dbInitDmapCtl
c_func
(paren
id|dmapctl_t
op_star
id|dcp
comma
r_int
id|level
comma
r_int
id|i
)paren
(brace
multiline_comment|/* start leaf index not covered by range */
id|s8
op_star
id|cp
suffix:semicolon
id|dcp-&gt;nleafs
op_assign
id|cpu_to_le32
c_func
(paren
id|LPERCTL
)paren
suffix:semicolon
id|dcp-&gt;l2nleafs
op_assign
id|cpu_to_le32
c_func
(paren
id|L2LPERCTL
)paren
suffix:semicolon
id|dcp-&gt;leafidx
op_assign
id|cpu_to_le32
c_func
(paren
id|CTLLEAFIND
)paren
suffix:semicolon
id|dcp-&gt;height
op_assign
id|cpu_to_le32
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|dcp-&gt;budmin
op_assign
id|L2BPERDMAP
op_plus
id|L2LPERCTL
op_star
id|level
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the leaves of current level that were not covered &n;&t; * by the specified input block range (i.e. the leaves have no &n;&t; * low level dmapctl or dmap).&n;&t; */
id|cp
op_assign
op_amp
id|dcp-&gt;stree
(braket
id|CTLLEAFIND
op_plus
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|LPERCTL
suffix:semicolon
id|i
op_increment
)paren
op_star
id|cp
op_increment
op_assign
id|NOFREE
suffix:semicolon
multiline_comment|/* build the dmap&squot;s binary buddy summary tree */
r_return
(paren
id|dbInitTree
c_func
(paren
(paren
id|dmaptree_t
op_star
)paren
id|dcp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbGetL2AGSize()/ujfs_getagl2size()&n; *                                                                    &n; * FUNCTION:&t;Determine log2(allocation group size) from aggregate size&n; *                                                                    &n; * PARAMETERS:&n; *&t;nblocks&t;- Number of blocks in aggregate&n; *&n; * RETURNS: log2(allocation group size) in aggregate blocks&n; */
DECL|function|dbGetL2AGSize
r_static
r_int
id|dbGetL2AGSize
c_func
(paren
id|s64
id|nblocks
)paren
(brace
id|s64
id|sz
suffix:semicolon
id|s64
id|m
suffix:semicolon
r_int
id|l2sz
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
OL
id|BPERDMAP
op_star
id|MAXAG
)paren
r_return
(paren
id|L2BPERDMAP
)paren
suffix:semicolon
multiline_comment|/* round up aggregate size to power of 2 */
id|m
op_assign
(paren
(paren
id|u64
)paren
l_int|1
op_lshift
(paren
l_int|64
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|l2sz
op_assign
l_int|64
suffix:semicolon
id|l2sz
op_ge
l_int|0
suffix:semicolon
id|l2sz
op_decrement
comma
id|m
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|m
op_amp
id|nblocks
)paren
r_break
suffix:semicolon
)brace
id|sz
op_assign
(paren
id|s64
)paren
l_int|1
op_lshift
id|l2sz
suffix:semicolon
r_if
c_cond
(paren
id|sz
OL
id|nblocks
)paren
id|l2sz
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* agsize = roundupSize/max_number_of_ag */
r_return
(paren
id|l2sz
op_minus
id|L2MAXAG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dbMapFileSizeToMapSize()&n; *                                                                    &n; * FUNCTION:&t;compute number of blocks the block allocation map file &n; *&t;&t;can cover from the map file size;&n; *&n; * RETURNS:&t;Number of blocks which can be covered by this block map file;&n; */
multiline_comment|/*&n; * maximum number of map pages at each level including control pages&n; */
DECL|macro|MAXL0PAGES
mdefine_line|#define MAXL0PAGES&t;(1 + LPERCTL)
DECL|macro|MAXL1PAGES
mdefine_line|#define MAXL1PAGES&t;(1 + LPERCTL * MAXL0PAGES)
DECL|macro|MAXL2PAGES
mdefine_line|#define MAXL2PAGES&t;(1 + LPERCTL * MAXL1PAGES)
multiline_comment|/*&n; * convert number of map pages to the zero origin top dmapctl level&n; */
DECL|macro|BMAPPGTOLEV
mdefine_line|#define BMAPPGTOLEV(npages)&t;&bslash;&n;&t;(((npages) &lt;= 3 + MAXL0PAGES) ? 0 &bslash;&n;       : ((npages) &lt;= 2 + MAXL1PAGES) ? 1 : 2)
DECL|function|dbMapFileSizeToMapSize
id|s64
id|dbMapFileSizeToMapSize
c_func
(paren
r_struct
id|inode
op_star
id|ipbmap
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ipbmap-&gt;i_sb
suffix:semicolon
id|s64
id|nblocks
suffix:semicolon
id|s64
id|npages
comma
id|ndmaps
suffix:semicolon
r_int
id|level
comma
id|i
suffix:semicolon
r_int
id|complete
comma
id|factor
suffix:semicolon
id|nblocks
op_assign
id|ipbmap-&gt;i_size
op_rshift
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
id|npages
op_assign
id|nblocks
op_rshift
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|l2nbperpage
suffix:semicolon
id|level
op_assign
id|BMAPPGTOLEV
c_func
(paren
id|npages
)paren
suffix:semicolon
multiline_comment|/* At each level, accumulate the number of dmap pages covered by &n;&t; * the number of full child levels below it;&n;&t; * repeat for the last incomplete child level.&n;&t; */
id|ndmaps
op_assign
l_int|0
suffix:semicolon
id|npages
op_decrement
suffix:semicolon
multiline_comment|/* skip the first global control page */
multiline_comment|/* skip higher level control pages above top level covered by map */
id|npages
op_sub_assign
(paren
l_int|2
op_minus
id|level
)paren
suffix:semicolon
id|npages
op_decrement
suffix:semicolon
multiline_comment|/* skip top level&squot;s control page */
r_for
c_loop
(paren
id|i
op_assign
id|level
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|factor
op_assign
(paren
id|i
op_eq
l_int|2
)paren
ques
c_cond
id|MAXL1PAGES
suffix:colon
(paren
(paren
id|i
op_eq
l_int|1
)paren
ques
c_cond
id|MAXL0PAGES
suffix:colon
l_int|1
)paren
suffix:semicolon
id|complete
op_assign
(paren
id|u32
)paren
id|npages
op_div
id|factor
suffix:semicolon
id|ndmaps
op_add_assign
id|complete
op_star
(paren
(paren
id|i
op_eq
l_int|2
)paren
ques
c_cond
id|LPERCTL
op_star
id|LPERCTL
suffix:colon
(paren
(paren
id|i
op_eq
l_int|1
)paren
ques
c_cond
id|LPERCTL
suffix:colon
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* pages in last/incomplete child */
id|npages
op_assign
(paren
id|u32
)paren
id|npages
op_mod
id|factor
suffix:semicolon
multiline_comment|/* skip incomplete child&squot;s level control page */
id|npages
op_decrement
suffix:semicolon
)brace
multiline_comment|/* convert the number of dmaps into the number of blocks &n;&t; * which can be covered by the dmaps;&n;&t; */
id|nblocks
op_assign
id|ndmaps
op_lshift
id|L2BPERDMAP
suffix:semicolon
r_return
(paren
id|nblocks
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;_JFS_DEBUG_DMAP
multiline_comment|/*&n; *&t;DBinitmap()&n; */
DECL|function|DBinitmap
r_static
r_void
id|DBinitmap
c_func
(paren
id|s64
id|size
comma
r_struct
id|inode
op_star
id|ipbmap
comma
id|u32
op_star
op_star
id|results
)paren
(brace
r_int
id|npages
suffix:semicolon
id|u32
op_star
id|dbmap
comma
op_star
id|d
suffix:semicolon
r_int
id|n
suffix:semicolon
id|s64
id|lblkno
comma
id|cur_block
suffix:semicolon
id|dmap_t
op_star
id|dp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|npages
op_assign
id|size
op_div
l_int|32768
suffix:semicolon
id|npages
op_add_assign
(paren
id|size
op_mod
l_int|32768
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|dbmap
op_assign
(paren
id|u32
op_star
)paren
id|xmalloc
c_func
(paren
id|npages
op_star
l_int|4096
comma
id|L2PSIZE
comma
id|kernel_heap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dbmap
op_eq
l_int|NULL
)paren
m_assert
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
comma
id|d
op_assign
id|dbmap
suffix:semicolon
id|n
OL
id|npages
suffix:semicolon
id|n
op_increment
comma
id|d
op_add_assign
l_int|1024
)paren
id|bzero
c_func
(paren
id|d
comma
l_int|4096
)paren
suffix:semicolon
multiline_comment|/* Need to initialize from disk map pages&n;&t; */
r_for
c_loop
(paren
id|d
op_assign
id|dbmap
comma
id|cur_block
op_assign
l_int|0
suffix:semicolon
id|cur_block
OL
id|size
suffix:semicolon
id|cur_block
op_add_assign
id|BPERDMAP
comma
id|d
op_add_assign
id|LPERDMAP
)paren
(brace
id|lblkno
op_assign
id|BLKTODMAP
c_func
(paren
id|cur_block
comma
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
op_member_access_from_pointer
id|db_l2nbperpage
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipbmap
comma
id|lblkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
m_assert
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dmap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|LPERDMAP
suffix:semicolon
id|n
op_increment
)paren
id|d
(braket
id|n
)braket
op_assign
id|le32_to_cpu
c_func
(paren
id|dp-&gt;wmap
(braket
id|n
)braket
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
op_star
id|results
op_assign
id|dbmap
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;DBAlloc()&n; */
DECL|function|DBAlloc
r_void
id|DBAlloc
c_func
(paren
id|uint
op_star
id|dbmap
comma
id|s64
id|mapsize
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
)paren
(brace
r_int
id|word
comma
id|nb
comma
id|bitno
suffix:semicolon
id|u32
id|mask
suffix:semicolon
m_assert
(paren
id|blkno
OG
l_int|0
op_logical_and
id|blkno
OL
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|nblocks
OG
l_int|0
op_logical_and
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|blkno
op_plus
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
id|dbmap
op_add_assign
(paren
id|blkno
op_div
l_int|32
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nblocks
OG
l_int|0
)paren
(brace
id|bitno
op_assign
id|blkno
op_amp
(paren
l_int|32
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|nblocks
comma
l_int|32
op_minus
id|bitno
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|0xffffffff
op_lshift
(paren
l_int|32
op_minus
id|nb
)paren
op_rshift
id|bitno
)paren
suffix:semicolon
m_assert
(paren
(paren
id|mask
op_amp
op_star
id|dbmap
)paren
op_eq
l_int|0
)paren
suffix:semicolon
op_star
id|dbmap
op_or_assign
id|mask
suffix:semicolon
id|dbmap
op_increment
suffix:semicolon
id|blkno
op_add_assign
id|nb
suffix:semicolon
id|nblocks
op_sub_assign
id|nb
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;DBFree()&n; */
DECL|function|DBFree
r_static
r_void
id|DBFree
c_func
(paren
id|uint
op_star
id|dbmap
comma
id|s64
id|mapsize
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
)paren
(brace
r_int
id|word
comma
id|nb
comma
id|bitno
suffix:semicolon
id|u32
id|mask
suffix:semicolon
m_assert
(paren
id|blkno
OG
l_int|0
op_logical_and
id|blkno
OL
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|nblocks
OG
l_int|0
op_logical_and
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|blkno
op_plus
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
id|dbmap
op_add_assign
(paren
id|blkno
op_div
l_int|32
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nblocks
OG
l_int|0
)paren
(brace
id|bitno
op_assign
id|blkno
op_amp
(paren
l_int|32
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|nblocks
comma
l_int|32
op_minus
id|bitno
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|0xffffffff
op_lshift
(paren
l_int|32
op_minus
id|nb
)paren
op_rshift
id|bitno
)paren
suffix:semicolon
m_assert
(paren
(paren
id|mask
op_amp
op_star
id|dbmap
)paren
op_eq
id|mask
)paren
suffix:semicolon
op_star
id|dbmap
op_and_assign
op_complement
id|mask
suffix:semicolon
id|dbmap
op_increment
suffix:semicolon
id|blkno
op_add_assign
id|nb
suffix:semicolon
id|nblocks
op_sub_assign
id|nb
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;DBAllocCK()&n; */
DECL|function|DBAllocCK
r_static
r_void
id|DBAllocCK
c_func
(paren
id|uint
op_star
id|dbmap
comma
id|s64
id|mapsize
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
)paren
(brace
r_int
id|word
comma
id|nb
comma
id|bitno
suffix:semicolon
id|u32
id|mask
suffix:semicolon
m_assert
(paren
id|blkno
OG
l_int|0
op_logical_and
id|blkno
OL
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|nblocks
OG
l_int|0
op_logical_and
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|blkno
op_plus
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
id|dbmap
op_add_assign
(paren
id|blkno
op_div
l_int|32
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nblocks
OG
l_int|0
)paren
(brace
id|bitno
op_assign
id|blkno
op_amp
(paren
l_int|32
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|nblocks
comma
l_int|32
op_minus
id|bitno
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|0xffffffff
op_lshift
(paren
l_int|32
op_minus
id|nb
)paren
op_rshift
id|bitno
)paren
suffix:semicolon
m_assert
(paren
(paren
id|mask
op_amp
op_star
id|dbmap
)paren
op_eq
id|mask
)paren
suffix:semicolon
id|dbmap
op_increment
suffix:semicolon
id|blkno
op_add_assign
id|nb
suffix:semicolon
id|nblocks
op_sub_assign
id|nb
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;DBFreeCK()&n; */
DECL|function|DBFreeCK
r_static
r_void
id|DBFreeCK
c_func
(paren
id|uint
op_star
id|dbmap
comma
id|s64
id|mapsize
comma
id|s64
id|blkno
comma
id|s64
id|nblocks
)paren
(brace
r_int
id|word
comma
id|nb
comma
id|bitno
suffix:semicolon
id|u32
id|mask
suffix:semicolon
m_assert
(paren
id|blkno
OG
l_int|0
op_logical_and
id|blkno
OL
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|nblocks
OG
l_int|0
op_logical_and
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
m_assert
(paren
id|blkno
op_plus
id|nblocks
op_le
id|mapsize
)paren
suffix:semicolon
id|dbmap
op_add_assign
(paren
id|blkno
op_div
l_int|32
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nblocks
OG
l_int|0
)paren
(brace
id|bitno
op_assign
id|blkno
op_amp
(paren
l_int|32
op_minus
l_int|1
)paren
suffix:semicolon
id|nb
op_assign
id|min
c_func
(paren
id|nblocks
comma
l_int|32
op_minus
id|bitno
)paren
suffix:semicolon
id|mask
op_assign
(paren
l_int|0xffffffff
op_lshift
(paren
l_int|32
op_minus
id|nb
)paren
op_rshift
id|bitno
)paren
suffix:semicolon
m_assert
(paren
(paren
id|mask
op_amp
op_star
id|dbmap
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|dbmap
op_increment
suffix:semicolon
id|blkno
op_add_assign
id|nb
suffix:semicolon
id|nblocks
op_sub_assign
id|nb
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;dbPrtMap()&n; */
DECL|function|dbPrtMap
r_static
r_void
id|dbPrtMap
c_func
(paren
id|bmap_t
op_star
id|bmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;   mapsize:   %d%d&bslash;n&quot;
comma
id|bmp-&gt;db_mapsize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   nfree:     %d%d&bslash;n&quot;
comma
id|bmp-&gt;db_nfree
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   numag:     %d&bslash;n&quot;
comma
id|bmp-&gt;db_numag
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   agsize:    %d%d&bslash;n&quot;
comma
id|bmp-&gt;db_agsize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   agl2size:  %d&bslash;n&quot;
comma
id|bmp-&gt;db_agl2size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   agwidth:   %d&bslash;n&quot;
comma
id|bmp-&gt;db_agwidth
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   agstart:   %d&bslash;n&quot;
comma
id|bmp-&gt;db_agstart
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   agheigth:  %d&bslash;n&quot;
comma
id|bmp-&gt;db_agheigth
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   aglevel:   %d&bslash;n&quot;
comma
id|bmp-&gt;db_aglevel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   maxlevel:  %d&bslash;n&quot;
comma
id|bmp-&gt;db_maxlevel
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   maxag:     %d&bslash;n&quot;
comma
id|bmp-&gt;db_maxag
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   agpref:    %d&bslash;n&quot;
comma
id|bmp-&gt;db_agpref
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   l2nbppg:   %d&bslash;n&quot;
comma
id|bmp-&gt;db_l2nbperpage
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dbPrtCtl()&n; */
DECL|function|dbPrtCtl
r_static
r_void
id|dbPrtCtl
c_func
(paren
id|dmapctl_t
op_star
id|dcp
)paren
(brace
r_int
id|i
comma
id|j
comma
id|n
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   height:    %08x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|dcp-&gt;height
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   leafidx:   %08x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|dcp-&gt;leafidx
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   budmin:    %08x&bslash;n&quot;
comma
id|dcp-&gt;budmin
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   nleafs:    %08x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|dcp-&gt;nleafs
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   l2nleafs:  %08x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|dcp-&gt;l2nleafs
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n Tree:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CTLLEAFIND
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
id|n
op_assign
id|min
c_func
(paren
l_int|8
comma
id|CTLLEAFIND
op_minus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
id|j
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;  [%03x]: %02x&quot;
comma
id|i
op_plus
id|j
comma
(paren
r_char
)paren
id|dcp-&gt;stree
(braket
id|i
op_plus
id|j
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n Tree Leaves:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LPERCTL
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
id|n
op_assign
id|min
c_func
(paren
l_int|8
comma
id|LPERCTL
op_minus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
id|j
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;  [%03x]: %02x&quot;
comma
id|i
op_plus
id|j
comma
(paren
r_char
)paren
id|dcp-&gt;stree
(braket
id|i
op_plus
id|j
op_plus
id|CTLLEAFIND
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_DEBUG_DMAP */
eof
