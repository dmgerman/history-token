multiline_comment|/*&n; *   Copyright (c) International Business Machines Corp., 2000-2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
multiline_comment|/*&n; *      jfs_xtree.c: extent allocation descriptor B+-tree manager&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_filsys.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_dmap.h&quot;
macro_line|#include &quot;jfs_dinode.h&quot;
macro_line|#include &quot;jfs_superblock.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/*&n; * xtree local flag&n; */
DECL|macro|XT_INSERT
mdefine_line|#define XT_INSERT       0x00000001
multiline_comment|/*&n; *       xtree key/entry comparison: extent offset&n; *&n; * return:&n; *      -1: k &lt; start of extent&n; *       0: start_of_extent &lt;= k &lt;= end_of_extent&n; *       1: k &gt; end_of_extent&n; */
DECL|macro|XT_CMP
mdefine_line|#define XT_CMP(CMP, K, X, OFFSET64)&bslash;&n;{&bslash;&n;        OFFSET64 = offsetXAD(X);&bslash;&n;        (CMP) = ((K) &gt;= OFFSET64 + lengthXAD(X)) ? 1 :&bslash;&n;              ((K) &lt; OFFSET64) ? -1 : 0;&bslash;&n;}
multiline_comment|/* write a xad entry */
DECL|macro|XT_PUTENTRY
mdefine_line|#define XT_PUTENTRY(XAD, FLAG, OFF, LEN, ADDR)&bslash;&n;{&bslash;&n;        (XAD)-&gt;flag = (FLAG);&bslash;&n;        XADoffset((XAD), (OFF));&bslash;&n;        XADlength((XAD), (LEN));&bslash;&n;        XADaddress((XAD), (ADDR));&bslash;&n;}
DECL|macro|XT_PAGE
mdefine_line|#define XT_PAGE(IP, MP) BT_PAGE(IP, MP, xtpage_t, i_xtroot)
multiline_comment|/* get page buffer for specified block address */
DECL|macro|XT_GETPAGE
mdefine_line|#define XT_GETPAGE(IP, BN, MP, SIZE, P, RC)&bslash;&n;{&bslash;&n;        BT_GETPAGE(IP, BN, MP, xtpage_t, SIZE, P, RC, i_xtroot)&bslash;&n;        if (!(RC))&bslash;&n;        {&bslash;&n;                if ((le16_to_cpu((P)-&gt;header.nextindex) &lt; XTENTRYSTART) ||&bslash;&n;                    (le16_to_cpu((P)-&gt;header.nextindex) &gt; le16_to_cpu((P)-&gt;header.maxentry)) ||&bslash;&n;                    (le16_to_cpu((P)-&gt;header.maxentry) &gt; (((BN)==0)?XTROOTMAXSLOT:PSIZE&gt;&gt;L2XTSLOTSIZE)))&bslash;&n;                {&bslash;&n;                        jERROR(1,(&quot;XT_GETPAGE: xtree page corrupt&bslash;n&quot;));&bslash;&n;&t;&t;&t;BT_PUTPAGE(MP);&bslash;&n;&t;&t;&t;updateSuper((IP)-&gt;i_sb, FM_DIRTY);&bslash;&n;&t;&t;&t;MP = NULL;&bslash;&n;                        RC = EIO;&bslash;&n;                }&bslash;&n;        }&bslash;&n;}
multiline_comment|/* for consistency */
DECL|macro|XT_PUTPAGE
mdefine_line|#define XT_PUTPAGE(MP) BT_PUTPAGE(MP)
DECL|macro|XT_GETSEARCH
mdefine_line|#define XT_GETSEARCH(IP, LEAF, BN, MP,  P, INDEX) &bslash;&n;&t;BT_GETSEARCH(IP, LEAF, BN, MP, xtpage_t, P, INDEX, i_xtroot)
multiline_comment|/* xtree entry parameter descriptor */
r_typedef
r_struct
(brace
DECL|member|mp
id|metapage_t
op_star
id|mp
suffix:semicolon
DECL|member|index
id|s16
id|index
suffix:semicolon
DECL|member|flag
id|u8
id|flag
suffix:semicolon
DECL|member|off
id|s64
id|off
suffix:semicolon
DECL|member|addr
id|s64
id|addr
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|pxdlist
id|pxdlist_t
op_star
id|pxdlist
suffix:semicolon
DECL|typedef|xtsplit_t
)brace
id|xtsplit_t
suffix:semicolon
multiline_comment|/*&n; *      statistics&n; */
macro_line|#ifdef CONFIG_JFS_STATISTICS
r_static
r_struct
(brace
DECL|member|search
id|uint
id|search
suffix:semicolon
DECL|member|fastSearch
id|uint
id|fastSearch
suffix:semicolon
DECL|member|split
id|uint
id|split
suffix:semicolon
DECL|variable|xtStat
)brace
id|xtStat
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * forward references&n; */
r_static
r_int
id|xtSearch
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|xoff
comma
r_int
op_star
id|cmpp
comma
id|btstack_t
op_star
id|btstack
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_int
id|xtSplitUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtsplit_t
op_star
id|split
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|xtSplitPage
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
comma
id|s64
op_star
id|rbnp
)paren
suffix:semicolon
r_static
r_int
id|xtSplitRoot
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
)paren
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
r_static
r_int
id|xtDeleteUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|metapage_t
op_star
id|fmp
comma
id|xtpage_t
op_star
id|fp
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|xtSearchNode
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|xad_t
op_star
id|xad
comma
r_int
op_star
id|cmpp
comma
id|btstack_t
op_star
id|btstack
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_int
id|xtRelink
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtpage_t
op_star
id|fp
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
multiline_comment|/* External references */
multiline_comment|/*&n; *      debug control&n; */
multiline_comment|/*      #define _JFS_DEBUG_XTREE        1 */
multiline_comment|/*&n; *      xtLookup()&n; *&n; * function: map a single page into a physical extent;&n; */
DECL|function|xtLookup
r_int
id|xtLookup
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|lstart
comma
id|s64
id|llen
comma
r_int
op_star
id|pflag
comma
id|s64
op_star
id|paddr
comma
id|s32
op_star
id|plen
comma
r_int
id|no_check
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|s64
id|size
comma
id|xoff
comma
id|xend
suffix:semicolon
r_int
id|xlen
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
op_star
id|plen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|no_check
)paren
(brace
multiline_comment|/* is lookup offset beyond eof ? */
id|size
op_assign
(paren
(paren
id|u64
)paren
id|ip-&gt;i_size
op_plus
(paren
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bsize
op_minus
l_int|1
)paren
)paren
op_rshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
r_if
c_cond
(paren
id|lstart
op_ge
id|size
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLookup: lstart (0x%lx) &gt;= size (0x%lx)&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|lstart
comma
(paren
id|ulong
)paren
id|size
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * search for the xad entry covering the logical extent&n;&t; */
singleline_comment|//search:
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|lstart
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
l_int|0
)paren
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLookup: xtSearch returned %d&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      compute the physical extent covering logical extent&n;&t; *&n;&t; * N.B. search may have failed (e.g., hole in sparse file),&n;&t; * and returned the index of the next entry.&n;&t; */
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* is xad found covering start of logical extent ?&n;&t; * lstart is a page start address,&n;&t; * i.e., lstart cannot start in a hole;&n;&t; */
r_if
c_cond
(paren
id|cmp
)paren
(brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLookup: cmp = %d&bslash;n&quot;
comma
id|cmp
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * lxd covered by xad&n;&t; */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xend
op_assign
id|xoff
op_plus
id|xlen
suffix:semicolon
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;index = %d, xoff = 0x%lx, xlen = 0x%x, xaddr = 0x%lx&bslash;n&quot;
comma
id|index
comma
(paren
id|ulong
)paren
id|xoff
comma
id|xlen
comma
(paren
id|ulong
)paren
id|xaddr
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize new pxd */
op_star
id|pflag
op_assign
id|xad-&gt;flag
suffix:semicolon
op_star
id|paddr
op_assign
id|xaddr
op_plus
(paren
id|lstart
op_minus
id|xoff
)paren
suffix:semicolon
multiline_comment|/* a page must be fully covered by an xad */
op_star
id|plen
op_assign
id|min
c_func
(paren
id|xend
op_minus
id|lstart
comma
id|llen
)paren
suffix:semicolon
id|out
suffix:colon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtLookupList()&n; *&n; * function: map a single logical extent into a list of physical extent;&n; *&n; * parameter:&n; *      struct inode    *ip,&n; *      lxdlist_t       *lxdlist,       lxd list (in)&n; *      xadlist_t       *xadlist,       xad list (in/out)&n; *      int&t;&t;flag)&n; *&n; * coverage of lxd by xad under assumption of&n; * . lxd&squot;s are ordered and disjoint.&n; * . xad&squot;s are ordered and disjoint.&n; *&n; * return:&n; *      0:      success&n; *&n; * note: a page being written (even a single byte) is backed fully,&n; *      except the last page which is only backed with blocks&n; *      required to cover the last byte;&n; *      the extent backing a page is fully contained within an xad;&n; */
DECL|function|xtLookupList
r_int
id|xtLookupList
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|lxdlist_t
op_star
id|lxdlist
comma
multiline_comment|/* lxd list (in) */
id|xadlist_t
op_star
id|xadlist
comma
multiline_comment|/* xad list (in/out) */
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
suffix:semicolon
id|lxd_t
op_star
id|lxd
suffix:semicolon
id|xad_t
op_star
id|xad
comma
op_star
id|pxd
suffix:semicolon
id|s64
id|size
comma
id|lstart
comma
id|lend
comma
id|xstart
comma
id|xend
comma
id|pstart
suffix:semicolon
id|s64
id|llen
comma
id|xlen
comma
id|plen
suffix:semicolon
id|s64
id|xaddr
comma
id|paddr
suffix:semicolon
r_int
id|nlxd
comma
id|npxd
comma
id|maxnpxd
suffix:semicolon
id|npxd
op_assign
id|xadlist-&gt;nxad
op_assign
l_int|0
suffix:semicolon
id|maxnpxd
op_assign
id|xadlist-&gt;maxnxad
suffix:semicolon
id|pxd
op_assign
id|xadlist-&gt;xad
suffix:semicolon
id|nlxd
op_assign
id|lxdlist-&gt;nlxd
suffix:semicolon
id|lxd
op_assign
id|lxdlist-&gt;lxd
suffix:semicolon
id|lstart
op_assign
id|offsetLXD
c_func
(paren
id|lxd
)paren
suffix:semicolon
id|llen
op_assign
id|lengthLXD
c_func
(paren
id|lxd
)paren
suffix:semicolon
id|lend
op_assign
id|lstart
op_plus
id|llen
suffix:semicolon
id|size
op_assign
(paren
id|ip-&gt;i_size
op_plus
(paren
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bsize
op_minus
l_int|1
)paren
)paren
op_rshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
multiline_comment|/*&n;&t; * search for the xad entry covering the logical extent&n;&t; */
id|search
suffix:colon
r_if
c_cond
(paren
id|lstart
op_ge
id|size
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|lstart
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
l_int|0
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; *      compute the physical extent covering logical extent&n;&t; *&n;&t; * N.B. search may have failed (e.g., hole in sparse file),&n;&t; * and returned the index of the next entry.&n;&t; */
singleline_comment|//map:
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* is xad on the next sibling page ? */
r_if
c_cond
(paren
id|index
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
r_goto
id|mapend
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|mapend
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* get next sibling page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|index
op_assign
id|XTENTRYSTART
suffix:semicolon
)brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * is lxd covered by xad ?&n;&t; */
id|compare
suffix:colon
id|xstart
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xend
op_assign
id|xstart
op_plus
id|xlen
suffix:semicolon
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|compare1
suffix:colon
r_if
c_cond
(paren
id|xstart
OL
id|lstart
)paren
r_goto
id|compare2
suffix:semicolon
multiline_comment|/* (lstart &lt;= xstart) */
multiline_comment|/* lxd is NOT covered by xad */
r_if
c_cond
(paren
id|lend
op_le
id|xstart
)paren
(brace
multiline_comment|/*&n;&t;&t; * get next lxd&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|nlxd
op_eq
l_int|0
)paren
r_goto
id|mapend
suffix:semicolon
id|lxd
op_increment
suffix:semicolon
id|lstart
op_assign
id|offsetLXD
c_func
(paren
id|lxd
)paren
suffix:semicolon
id|llen
op_assign
id|lengthLXD
c_func
(paren
id|lxd
)paren
suffix:semicolon
id|lend
op_assign
id|lstart
op_plus
id|llen
suffix:semicolon
r_if
c_cond
(paren
id|lstart
op_ge
id|size
)paren
r_goto
id|mapend
suffix:semicolon
multiline_comment|/* compare with the current xad  */
r_goto
id|compare1
suffix:semicolon
)brace
multiline_comment|/* lxd is covered by xad */
r_else
(brace
multiline_comment|/* (xstart &lt; lend) */
multiline_comment|/* initialize new pxd */
id|pstart
op_assign
id|xstart
suffix:semicolon
id|plen
op_assign
id|min
c_func
(paren
id|lend
op_minus
id|xstart
comma
id|xlen
)paren
suffix:semicolon
id|paddr
op_assign
id|xaddr
suffix:semicolon
r_goto
id|cover
suffix:semicolon
)brace
multiline_comment|/* (xstart &lt; lstart) */
id|compare2
suffix:colon
multiline_comment|/* lxd is covered by xad */
r_if
c_cond
(paren
id|lstart
OL
id|xend
)paren
(brace
multiline_comment|/* initialize new pxd */
id|pstart
op_assign
id|lstart
suffix:semicolon
id|plen
op_assign
id|min
c_func
(paren
id|xend
op_minus
id|lstart
comma
id|llen
)paren
suffix:semicolon
id|paddr
op_assign
id|xaddr
op_plus
(paren
id|lstart
op_minus
id|xstart
)paren
suffix:semicolon
r_goto
id|cover
suffix:semicolon
)brace
multiline_comment|/* lxd is NOT covered by xad */
r_else
(brace
multiline_comment|/* (xend &lt;= lstart) */
multiline_comment|/*&n;&t;&t; * get next xad&n;&t;&t; *&n;&t;&t; * linear search next xad covering lxd on&n;&t;&t; * the current xad page, and then tree search&n;&t;&t; */
r_if
c_cond
(paren
id|index
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
r_goto
id|mapend
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|search
suffix:semicolon
)brace
r_else
(brace
id|index
op_increment
suffix:semicolon
id|xad
op_increment
suffix:semicolon
multiline_comment|/* compare with new xad */
r_goto
id|compare
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * lxd is covered by xad and a new pxd has been initialized&n;&t; * (lstart &lt;= xstart &lt; lend) or (xstart &lt; lstart &lt; xend)&n;&t; */
id|cover
suffix:colon
multiline_comment|/* finalize pxd corresponding to current xad */
id|XT_PUTENTRY
c_func
(paren
id|pxd
comma
id|xad-&gt;flag
comma
id|pstart
comma
id|plen
comma
id|paddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|npxd
op_ge
id|maxnpxd
)paren
r_goto
id|mapend
suffix:semicolon
id|pxd
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * lxd is fully covered by xad&n;&t; */
r_if
c_cond
(paren
id|lend
op_le
id|xend
)paren
(brace
multiline_comment|/*&n;&t;&t; * get next lxd&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|nlxd
op_eq
l_int|0
)paren
r_goto
id|mapend
suffix:semicolon
id|lxd
op_increment
suffix:semicolon
id|lstart
op_assign
id|offsetLXD
c_func
(paren
id|lxd
)paren
suffix:semicolon
id|llen
op_assign
id|lengthLXD
c_func
(paren
id|lxd
)paren
suffix:semicolon
id|lend
op_assign
id|lstart
op_plus
id|llen
suffix:semicolon
r_if
c_cond
(paren
id|lstart
op_ge
id|size
)paren
r_goto
id|mapend
suffix:semicolon
multiline_comment|/*&n;&t;&t; * test for old xad covering new lxd&n;&t;&t; * (old xstart &lt; new lstart)&n;&t;&t; */
r_goto
id|compare2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * lxd is partially covered by xad&n;&t; */
r_else
(brace
multiline_comment|/* (xend &lt; lend)  */
multiline_comment|/*&n;&t;&t; * get next xad&n;&t;&t; *&n;&t;&t; * linear search next xad covering lxd on&n;&t;&t; * the current xad page, and then next xad page search&n;&t;&t; */
r_if
c_cond
(paren
id|index
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
r_goto
id|mapend
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|mapend
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* get next sibling page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|index
op_assign
id|XTENTRYSTART
suffix:semicolon
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
)brace
r_else
(brace
id|index
op_increment
suffix:semicolon
id|xad
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * test for new xad covering old lxd&n;&t;&t; * (old lstart &lt; new xstart)&n;&t;&t; */
r_goto
id|compare
suffix:semicolon
)brace
id|mapend
suffix:colon
id|xadlist-&gt;nxad
op_assign
id|npxd
suffix:semicolon
singleline_comment|//out:
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtSearch()&n; *&n; * function:    search for the xad entry covering specified offset.&n; *&n; * parameters:&n; *      ip      - file object;&n; *      xoff    - extent offset;&n; *      cmpp    - comparison result:&n; *      btstack - traverse stack;&n; *      flag    - search process flag (XT_INSERT);&n; *&n; * returns:&n; *      btstack contains (bn, index) of search path traversed to the entry.&n; *      *cmpp is set to result of comparison with the entry returned.&n; *      the page containing the entry is pinned at exit.&n; */
DECL|function|xtSearch
r_static
r_int
id|xtSearch
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|xoff
comma
multiline_comment|/* offset of extent */
r_int
op_star
id|cmpp
comma
id|btstack_t
op_star
id|btstack
comma
r_int
id|flag
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|cmp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* init for empty page */
id|s64
id|bn
suffix:semicolon
multiline_comment|/* block number */
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* page buffer */
id|xtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* page */
id|xad_t
op_star
id|xad
suffix:semicolon
r_int
id|base
comma
id|index
comma
id|lim
comma
id|btindex
suffix:semicolon
id|btframe_t
op_star
id|btsp
suffix:semicolon
r_int
id|nsplit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of pages to split */
id|s64
id|t64
suffix:semicolon
id|INCREMENT
c_func
(paren
id|xtStat.search
)paren
suffix:semicolon
id|BT_CLR
c_func
(paren
id|btstack
)paren
suffix:semicolon
id|btstack-&gt;nsplit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      search down tree from root:&n;&t; *&n;&t; * between two consecutive entries of &lt;Ki, Pi&gt; and &lt;Kj, Pj&gt; of&n;&t; * internal page, child page Pi contains entry with k, Ki &lt;= K &lt; Kj.&n;&t; *&n;&t; * if entry with search key K is not found&n;&t; * internal page search find the entry with largest key Ki&n;&t; * less than K which point to the child page to search;&n;&t; * leaf page search find the entry with smallest key Kj&n;&t; * greater than K so that the returned index is the position of&n;&t; * the entry to be shifted right for insertion of new entry.&n;&t; * for empty tree, search key is greater than any key of the tree.&n;&t; *&n;&t; * by convention, root bn = 0.&n;&t; */
r_for
c_loop
(paren
id|bn
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* get/pin the page to search */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* try sequential access heuristics with the previous&n;&t;&t; * access entry in target leaf page:&n;&t;&t; * once search narrowed down into the target leaf,&n;&t;&t; * key must either match an entry in the leaf or&n;&t;&t; * key entry does not exist in the tree;&n;&t;&t; */
singleline_comment|//fastSearch:
r_if
c_cond
(paren
(paren
id|jfs_ip-&gt;btorder
op_amp
id|BT_SEQUENTIAL
)paren
op_logical_and
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
op_logical_and
(paren
id|index
op_assign
id|jfs_ip-&gt;btindex
)paren
OL
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
)paren
(brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|t64
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xoff
OL
id|t64
op_plus
id|lengthXAD
c_func
(paren
id|xad
)paren
)paren
(brace
r_if
c_cond
(paren
id|xoff
op_ge
id|t64
)paren
(brace
op_star
id|cmpp
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* stop sequential access heuristics */
r_goto
id|binarySearch
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (t64 + lengthXAD(xad)) &lt;= xoff */
multiline_comment|/* try next sequential entry */
id|index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
)paren
(brace
id|xad
op_increment
suffix:semicolon
id|t64
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xoff
OL
id|t64
op_plus
id|lengthXAD
c_func
(paren
id|xad
)paren
)paren
(brace
r_if
c_cond
(paren
id|xoff
op_ge
id|t64
)paren
(brace
op_star
id|cmpp
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* miss: key falls between&n;&t;&t;&t;&t;&t;&t; * previous and this entry&n;&t;&t;&t;&t;&t;&t; */
op_star
id|cmpp
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* (xoff &gt;= t64 + lengthXAD(xad));&n;&t;&t;&t;&t;&t; * matching entry may be further out:&n;&t;&t;&t;&t;&t; * stop heuristic search&n;&t;&t;&t;&t;&t; */
multiline_comment|/* stop sequential access heuristics */
r_goto
id|binarySearch
suffix:semicolon
)brace
multiline_comment|/* (index == p-&gt;header.nextindex);&n;&t;&t;&t;&t; * miss: key entry does not exist in&n;&t;&t;&t;&t; * the target leaf/tree&n;&t;&t;&t;&t; */
op_star
id|cmpp
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * if hit, return index of the entry found, and&n;&t;&t;&t; * if miss, where new entry with search key is&n;&t;&t;&t; * to be inserted;&n;&t;&t;&t; */
id|out
suffix:colon
multiline_comment|/* compute number of pages to split */
r_if
c_cond
(paren
id|flag
op_amp
id|XT_INSERT
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
multiline_comment|/* little-endian */
id|p-&gt;header.maxentry
)paren
id|nsplit
op_increment
suffix:semicolon
r_else
id|nsplit
op_assign
l_int|0
suffix:semicolon
id|btstack-&gt;nsplit
op_assign
id|nsplit
suffix:semicolon
)brace
multiline_comment|/* save search result */
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|index
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
multiline_comment|/* update sequential access heuristics */
id|jfs_ip-&gt;btindex
op_assign
id|index
suffix:semicolon
id|INCREMENT
c_func
(paren
id|xtStat.fastSearch
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* well, ... full search now */
id|binarySearch
suffix:colon
id|lim
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|XTENTRYSTART
suffix:semicolon
multiline_comment|/*&n;&t;&t; * binary search with search key K on the current page&n;&t;&t; */
r_for
c_loop
(paren
id|base
op_assign
id|XTENTRYSTART
suffix:semicolon
id|lim
suffix:semicolon
id|lim
op_rshift_assign
l_int|1
)paren
(brace
id|index
op_assign
id|base
op_plus
(paren
id|lim
op_rshift
l_int|1
)paren
suffix:semicolon
id|XT_CMP
c_func
(paren
id|cmp
comma
id|xoff
comma
op_amp
id|p-&gt;xad
(braket
id|index
)braket
comma
id|t64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *      search hit&n;&t;&t;&t;&t; */
multiline_comment|/* search hit - leaf page:&n;&t;&t;&t;&t; * return the entry found&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
op_star
id|cmpp
op_assign
id|cmp
suffix:semicolon
multiline_comment|/* compute number of pages to split */
r_if
c_cond
(paren
id|flag
op_amp
id|XT_INSERT
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|p-&gt;header.maxentry
)paren
id|nsplit
op_increment
suffix:semicolon
r_else
id|nsplit
op_assign
l_int|0
suffix:semicolon
id|btstack-&gt;nsplit
op_assign
id|nsplit
suffix:semicolon
)brace
multiline_comment|/* save search result */
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|index
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
multiline_comment|/* init sequential access heuristics */
id|btindex
op_assign
id|jfs_ip-&gt;btindex
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|btindex
op_logical_or
id|index
op_eq
id|btindex
op_plus
l_int|1
)paren
id|jfs_ip-&gt;btorder
op_assign
id|BT_SEQUENTIAL
suffix:semicolon
r_else
id|jfs_ip-&gt;btorder
op_assign
id|BT_RANDOM
suffix:semicolon
id|jfs_ip-&gt;btindex
op_assign
id|index
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* search hit - internal page:&n;&t;&t;&t;&t; * descend/search its child page&n;&t;&t;&t;&t; */
r_goto
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
(brace
id|base
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
op_decrement
id|lim
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *      search miss&n;&t;&t; *&n;&t;&t; * base is the smallest index with key (Kj) greater than&n;&t;&t; * search key (K) and may be zero or maxentry index.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * search miss - leaf page:&n;&t;&t; *&n;&t;&t; * return location of entry (base) where new entry with&n;&t;&t; * search key K is to be inserted.&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
op_star
id|cmpp
op_assign
id|cmp
suffix:semicolon
multiline_comment|/* compute number of pages to split */
r_if
c_cond
(paren
id|flag
op_amp
id|XT_INSERT
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|p-&gt;header.maxentry
)paren
id|nsplit
op_increment
suffix:semicolon
r_else
id|nsplit
op_assign
l_int|0
suffix:semicolon
id|btstack-&gt;nsplit
op_assign
id|nsplit
suffix:semicolon
)brace
multiline_comment|/* save search result */
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|base
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
multiline_comment|/* init sequential access heuristics */
id|btindex
op_assign
id|jfs_ip-&gt;btindex
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
id|btindex
op_logical_or
id|base
op_eq
id|btindex
op_plus
l_int|1
)paren
id|jfs_ip-&gt;btorder
op_assign
id|BT_SEQUENTIAL
suffix:semicolon
r_else
id|jfs_ip-&gt;btorder
op_assign
id|BT_RANDOM
suffix:semicolon
id|jfs_ip-&gt;btindex
op_assign
id|base
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * search miss - non-leaf page:&n;&t;&t; *&n;&t;&t; * if base is non-zero, decrement base by one to get the parent&n;&t;&t; * entry of the child page to search.&n;&t;&t; */
id|index
op_assign
id|base
ques
c_cond
id|base
op_minus
l_int|1
suffix:colon
id|base
suffix:semicolon
multiline_comment|/*&n;&t;&t; * go down to child page&n;&t;&t; */
id|next
suffix:colon
multiline_comment|/* update number of pages to split */
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|p-&gt;header.maxentry
)paren
id|nsplit
op_increment
suffix:semicolon
r_else
id|nsplit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* push (bn, index) of the parent page/entry */
id|BT_PUSH
c_func
(paren
id|btstack
comma
id|bn
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* get the child page block number */
id|bn
op_assign
id|addressXAD
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
)paren
suffix:semicolon
multiline_comment|/* unpin the parent page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      xtInsert()&n; *&n; * function:&n; *&n; * parameter:&n; *      tid     - transaction id;&n; *      ip      - file object;&n; *      xflag   - extent flag (XAD_NOTRECORDED):&n; *      xoff    - extent offset;&n; *      xlen    - extent length;&n; *      xaddrp  - extent address pointer (in/out):&n; *              if (*xaddrp)&n; *                      caller allocated data extent at *xaddrp;&n; *              else&n; *                      allocate data extent and return its xaddr;&n; *      flag    -&n; *&n; * return:&n; */
DECL|function|xtInsert
r_int
id|xtInsert
c_func
(paren
id|tid_t
id|tid
comma
multiline_comment|/* transaction id */
r_struct
id|inode
op_star
id|ip
comma
r_int
id|xflag
comma
id|s64
id|xoff
comma
id|s32
id|xlen
comma
id|s64
op_star
id|xaddrp
comma
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s64
id|xaddr
comma
id|hint
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|xtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* base B+-tree index page */
id|s64
id|bn
suffix:semicolon
r_int
id|index
comma
id|nextindex
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
multiline_comment|/* traverse stack */
id|xtsplit_t
id|split
suffix:semicolon
multiline_comment|/* split information */
id|xad_t
op_star
id|xad
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtInsert: nxoff:0x%lx nxlen:0x%x&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xoff
comma
id|xlen
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      search for the entry location at which to insert:&n;&t; *&n;&t; * xtFastSearch() and xtSearch() both returns (leaf page&n;&t; * pinned, index at which to insert).&n;&t; * n.b. xtSearch() may return index of maxentry of&n;&t; * the full page.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
id|XT_INSERT
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* This test must follow XT_GETSEARCH since mp must be valid if&n;&t; * we branch to out: */
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|EEXIST
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate data extent requested&n;&t; *&n;&t; * allocation hint: last xad&n;&t; */
r_if
c_cond
(paren
(paren
id|xaddr
op_assign
op_star
id|xaddrp
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|index
OG
id|XTENTRYSTART
)paren
(brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
op_minus
l_int|1
)braket
suffix:semicolon
id|hint
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
op_plus
id|lengthXAD
c_func
(paren
id|xad
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_else
id|hint
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ip
comma
id|hint
comma
(paren
id|s64
)paren
id|xlen
comma
op_amp
id|xaddr
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      insert entry for new extent&n;&t; */
id|xflag
op_or_assign
id|XAD_NEW
suffix:semicolon
multiline_comment|/*&n;&t; *      if the leaf page is full, split the page and&n;&t; *      propagate up the router entry for the new page from split&n;&t; *&n;&t; * The xtSplitUp() will insert the entry and unpin the leaf page.&n;&t; */
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextindex
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
)paren
(brace
id|split.mp
op_assign
id|mp
suffix:semicolon
id|split.index
op_assign
id|index
suffix:semicolon
id|split.flag
op_assign
id|xflag
suffix:semicolon
id|split.off
op_assign
id|xoff
suffix:semicolon
id|split.len
op_assign
id|xlen
suffix:semicolon
id|split.addr
op_assign
id|xaddr
suffix:semicolon
id|split.pxdlist
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSplitUp
c_func
(paren
id|tid
comma
id|ip
comma
op_amp
id|split
comma
op_amp
id|btstack
)paren
)paren
)paren
(brace
multiline_comment|/* undo data extent allocation */
r_if
c_cond
(paren
op_star
id|xaddrp
op_eq
l_int|0
)paren
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
op_star
id|xaddrp
op_assign
id|xaddr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      insert the new entry into the leaf page&n;&t; */
multiline_comment|/*&n;&t; * acquire a transaction lock on the leaf page;&n;&t; *&n;&t; * action: xad insertion/extension;&n;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/* if insert into middle, shift right remaining entries. */
r_if
c_cond
(paren
id|index
OL
id|nextindex
)paren
id|memmove
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|index
)braket
comma
(paren
id|nextindex
op_minus
id|index
)paren
op_star
r_sizeof
(paren
id|xad_t
)paren
)paren
suffix:semicolon
multiline_comment|/* insert the new entry: mark the entry NEW */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|xflag
comma
id|xoff
comma
id|xlen
comma
id|xaddr
)paren
suffix:semicolon
multiline_comment|/* advance next available entry index */
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t log it if there are no links to the file */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
)brace
op_star
id|xaddrp
op_assign
id|xaddr
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtSplitUp()&n; *&n; * function:&n; *      split full pages as propagating insertion up the tree&n; *&n; * parameter:&n; *      tid     - transaction id;&n; *      ip      - file object;&n; *      split   - entry parameter descriptor;&n; *      btstack - traverse stack from xtSearch()&n; *&n; * return:&n; */
r_static
r_int
DECL|function|xtSplitUp
id|xtSplitUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtsplit_t
op_star
id|split
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|smp
suffix:semicolon
id|xtpage_t
op_star
id|sp
suffix:semicolon
multiline_comment|/* split page */
id|metapage_t
op_star
id|rmp
suffix:semicolon
id|s64
id|rbn
suffix:semicolon
multiline_comment|/* new right page block number */
id|metapage_t
op_star
id|rcmp
suffix:semicolon
id|xtpage_t
op_star
id|rcp
suffix:semicolon
multiline_comment|/* right child page */
id|s64
id|rcbn
suffix:semicolon
multiline_comment|/* right child page block number */
r_int
id|skip
suffix:semicolon
multiline_comment|/* index of entry of insertion */
r_int
id|nextindex
suffix:semicolon
multiline_comment|/* next available entry index of p */
id|btframe_t
op_star
id|parent
suffix:semicolon
multiline_comment|/* parent page entry on traverse stack */
id|xad_t
op_star
id|xad
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
r_int
id|xlen
suffix:semicolon
r_int
id|nsplit
suffix:semicolon
multiline_comment|/* number of pages split */
id|pxdlist_t
id|pxdlist
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
id|smp
op_assign
id|split-&gt;mp
suffix:semicolon
id|sp
op_assign
id|XT_PAGE
c_func
(paren
id|ip
comma
id|smp
)paren
suffix:semicolon
multiline_comment|/* is inode xtree root extension/inline EA area free ? */
r_if
c_cond
(paren
(paren
id|sp-&gt;header.flag
op_amp
id|BT_ROOT
)paren
op_logical_and
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
op_logical_and
(paren
id|sp-&gt;header.maxentry
OL
id|cpu_to_le16
c_func
(paren
id|XTROOTMAXSLOT
)paren
)paren
op_logical_and
(paren
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|mode2
op_amp
id|INLINEEA
)paren
)paren
(brace
id|sp-&gt;header.maxentry
op_assign
id|cpu_to_le16
c_func
(paren
id|XTROOTMAXSLOT
)paren
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|mode2
op_and_assign
op_complement
id|INLINEEA
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|smp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the leaf page;&n;&t;&t; *&n;&t;&t; * action: xad insertion/extension;&n;&t;&t; */
multiline_comment|/* if insert into middle, shift right remaining entries. */
id|skip
op_assign
id|split-&gt;index
suffix:semicolon
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.nextindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skip
OL
id|nextindex
)paren
id|memmove
c_func
(paren
op_amp
id|sp-&gt;xad
(braket
id|skip
op_plus
l_int|1
)braket
comma
op_amp
id|sp-&gt;xad
(braket
id|skip
)braket
comma
(paren
id|nextindex
op_minus
id|skip
)paren
op_star
r_sizeof
(paren
id|xad_t
)paren
)paren
suffix:semicolon
multiline_comment|/* insert the new entry: mark the entry NEW */
id|xad
op_assign
op_amp
id|sp-&gt;xad
(braket
id|skip
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|split-&gt;flag
comma
id|split-&gt;off
comma
id|split-&gt;len
comma
id|split-&gt;addr
)paren
suffix:semicolon
multiline_comment|/* advance next available entry index */
id|sp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t log it if there are no links to the file */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|smp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|skip
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|skip
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate new index blocks to cover index page split(s)&n;&t; *&n;&t; * allocation hint: ?&n;&t; */
r_if
c_cond
(paren
id|split-&gt;pxdlist
op_eq
l_int|NULL
)paren
(brace
id|nsplit
op_assign
id|btstack-&gt;nsplit
suffix:semicolon
id|split-&gt;pxdlist
op_assign
op_amp
id|pxdlist
suffix:semicolon
id|pxdlist.maxnpxd
op_assign
id|pxdlist.npxd
op_assign
l_int|0
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist.pxd
(braket
l_int|0
)braket
suffix:semicolon
id|xlen
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|nsplit
OG
l_int|0
suffix:semicolon
id|nsplit
op_decrement
comma
id|pxd
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ip
comma
(paren
id|s64
)paren
l_int|0
comma
(paren
id|s64
)paren
id|xlen
comma
op_amp
id|xaddr
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|PXDaddress
c_func
(paren
id|pxd
comma
id|xaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|xlen
)paren
suffix:semicolon
id|pxdlist.maxnpxd
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* undo allocation */
id|XT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Split leaf page &lt;sp&gt; into &lt;sp&gt; and a new right page &lt;rp&gt;.&n;&t; *&n;&t; * The split routines insert the new entry into the leaf page,&n;&t; * and acquire txLock as appropriate.&n;&t; * return &lt;rp&gt; pinned and its block number &lt;rpbn&gt;.&n;&t; */
id|rc
op_assign
(paren
id|sp-&gt;header.flag
op_amp
id|BT_ROOT
)paren
ques
c_cond
id|xtSplitRoot
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
)paren
suffix:colon
id|xtSplitPage
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
comma
op_amp
id|rbn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|EIO
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * propagate up the router entry for the leaf page just split&n;&t; *&n;&t; * insert a router entry for the new page into the parent page,&n;&t; * propagate the insert/split up the tree by walking back the stack&n;&t; * of (bn of parent page, index of child page entry in parent page)&n;&t; * that were traversed during the search for the page that split.&n;&t; *&n;&t; * the propagation of insert/split up the tree stops if the root&n;&t; * splits or the page inserted into doesn&squot;t have to split to hold&n;&t; * the new entry.&n;&t; *&n;&t; * the parent entry for the split page remains the same, and&n;&t; * a new entry is inserted at its right with the first key and&n;&t; * block number of the new right page.&n;&t; *&n;&t; * There are a maximum of 3 pages pinned at any time:&n;&t; * right child, left parent and right parent (when the parent splits)&n;&t; * to keep the child page pinned while working on the parent.&n;&t; * make sure that all pins are released at exit.&n;&t; */
r_while
c_loop
(paren
(paren
id|parent
op_assign
id|BT_POP
c_func
(paren
id|btstack
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* parent page specified by stack frame &lt;parent&gt; */
multiline_comment|/* keep current child pages &lt;rcp&gt; pinned */
id|rcmp
op_assign
id|rmp
suffix:semicolon
id|rcbn
op_assign
id|rbn
suffix:semicolon
id|rcp
op_assign
id|XT_PAGE
c_func
(paren
id|ip
comma
id|rcmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * insert router entry in parent for new right child page &lt;rp&gt;&n;&t;&t; */
multiline_comment|/* get/pin the parent page &lt;sp&gt; */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|parent-&gt;bn
comma
id|smp
comma
id|PSIZE
comma
id|sp
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|errout2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The new key entry goes ONE AFTER the index of parent entry,&n;&t;&t; * because the split was to the right.&n;&t;&t; */
id|skip
op_assign
id|parent-&gt;index
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * split or shift right remaining entries of the parent page&n;&t;&t; */
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.nextindex
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * parent page is full - split the parent page&n;&t;&t; */
r_if
c_cond
(paren
id|nextindex
op_eq
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.maxentry
)paren
)paren
(brace
multiline_comment|/* init for parent page split */
id|split-&gt;mp
op_assign
id|smp
suffix:semicolon
id|split-&gt;index
op_assign
id|skip
suffix:semicolon
multiline_comment|/* index at insert */
id|split-&gt;flag
op_assign
id|XAD_NEW
suffix:semicolon
id|split-&gt;off
op_assign
id|offsetXAD
c_func
(paren
op_amp
id|rcp-&gt;xad
(braket
id|XTENTRYSTART
)braket
)paren
suffix:semicolon
id|split-&gt;len
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
suffix:semicolon
id|split-&gt;addr
op_assign
id|rcbn
suffix:semicolon
multiline_comment|/* unpin previous right child page */
id|XT_PUTPAGE
c_func
(paren
id|rcmp
)paren
suffix:semicolon
multiline_comment|/* The split routines insert the new entry,&n;&t;&t;&t; * and acquire txLock as appropriate.&n;&t;&t;&t; * return &lt;rp&gt; pinned and its block number &lt;rpbn&gt;.&n;&t;&t;&t; */
id|rc
op_assign
(paren
id|sp-&gt;header.flag
op_amp
id|BT_ROOT
)paren
ques
c_cond
id|xtSplitRoot
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
)paren
suffix:colon
id|xtSplitPage
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
comma
op_amp
id|rbn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|errout1
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
multiline_comment|/* keep new child page &lt;rp&gt; pinned */
)brace
multiline_comment|/*&n;&t;&t; * parent page is not full - insert in parent page&n;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * insert router entry in parent for the right child&n;&t;&t;&t; * page from the first entry of the right child page:&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * acquire a transaction lock on the parent page;&n;&t;&t;&t; *&n;&t;&t;&t; * action: router xad insertion;&n;&t;&t;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|smp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * if insert into middle, shift right remaining entries&n;&t;&t;&t; */
r_if
c_cond
(paren
id|skip
OL
id|nextindex
)paren
id|memmove
c_func
(paren
op_amp
id|sp-&gt;xad
(braket
id|skip
op_plus
l_int|1
)braket
comma
op_amp
id|sp-&gt;xad
(braket
id|skip
)braket
comma
(paren
id|nextindex
op_minus
id|skip
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* insert the router entry */
id|xad
op_assign
op_amp
id|sp-&gt;xad
(braket
id|skip
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|XAD_NEW
comma
id|offsetXAD
c_func
(paren
op_amp
id|rcp-&gt;xad
(braket
id|XTENTRYSTART
)braket
)paren
comma
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
comma
id|rcbn
)paren
suffix:semicolon
multiline_comment|/* advance next available entry index. */
id|sp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t log it if there are no links to the file */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|smp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|skip
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|skip
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
)brace
multiline_comment|/* unpin parent page */
id|XT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
multiline_comment|/* exit propagate up */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* unpin current right page */
id|XT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If something fails in the above loop we were already walking back&n;&t; * up the tree and the tree is now inconsistent.&n;&t; * release all pages we&squot;re holding.&n;&t; */
id|errout1
suffix:colon
id|XT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
id|errout2
suffix:colon
id|XT_PUTPAGE
c_func
(paren
id|rcmp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtSplitPage()&n; *&n; * function:&n; *      split a full non-root page into&n; *      original/split/left page and new right page&n; *      i.e., the original/split page remains as left page.&n; *&n; * parameter:&n; *      int&t;&t;tid,&n; *      struct inode    *ip,&n; *      xtsplit_t       *split,&n; *      metapage_t&t;**rmpp,&n; *      u64&t;&t;*rbnp,&n; *&n; * return:&n; *      Pointer to page in which to insert or NULL on error.&n; */
r_static
r_int
DECL|function|xtSplitPage
id|xtSplitPage
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
comma
id|s64
op_star
id|rbnp
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|smp
suffix:semicolon
id|xtpage_t
op_star
id|sp
suffix:semicolon
id|metapage_t
op_star
id|rmp
suffix:semicolon
id|xtpage_t
op_star
id|rp
suffix:semicolon
multiline_comment|/* new right page allocated */
id|s64
id|rbn
suffix:semicolon
multiline_comment|/* new right page block number */
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
id|s64
id|nextbn
suffix:semicolon
r_int
id|skip
comma
id|maxentry
comma
id|middle
comma
id|righthalf
comma
id|n
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|pxdlist_t
op_star
id|pxdlist
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|sxtlck
op_assign
l_int|0
comma
op_star
id|rxtlck
op_assign
l_int|0
suffix:semicolon
id|smp
op_assign
id|split-&gt;mp
suffix:semicolon
id|sp
op_assign
id|XT_PAGE
c_func
(paren
id|ip
comma
id|smp
)paren
suffix:semicolon
id|INCREMENT
c_func
(paren
id|xtStat.split
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allocate the new right page for the split&n;&t; */
id|pxdlist
op_assign
id|split-&gt;pxdlist
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist-&gt;pxd
(braket
id|pxdlist-&gt;npxd
)braket
suffix:semicolon
id|pxdlist-&gt;npxd
op_increment
suffix:semicolon
id|rbn
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|rmp
op_assign
id|get_metapage
c_func
(paren
id|ip
comma
id|rbn
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmp
op_eq
l_int|NULL
)paren
r_return
id|EIO
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtSplitPage: ip:0x%p smp:0x%p rmp:0x%p&bslash;n&quot;
comma
id|ip
comma
id|smp
comma
id|rmp
)paren
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|rmp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * action: new page;&n;&t; */
id|rp
op_assign
(paren
id|xtpage_t
op_star
)paren
id|rmp-&gt;data
suffix:semicolon
id|rp-&gt;header.self
op_assign
op_star
id|pxd
suffix:semicolon
id|rp-&gt;header.flag
op_assign
id|sp-&gt;header.flag
op_amp
id|BT_TYPE
suffix:semicolon
id|rp-&gt;header.maxentry
op_assign
id|sp-&gt;header.maxentry
suffix:semicolon
multiline_comment|/* little-endian */
id|rp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|smp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t log it if there are no links to the file */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the new right page;&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|rmp
comma
id|tlckXTREE
op_or
id|tlckNEW
)paren
suffix:semicolon
id|rxtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|rxtlck-&gt;lwm.offset
op_assign
id|XTENTRYSTART
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the split page&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|smp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|sxtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * initialize/update sibling pointers of &lt;sp&gt; and &lt;rp&gt;&n;&t; */
id|nextbn
op_assign
id|le64_to_cpu
c_func
(paren
id|sp-&gt;header.next
)paren
suffix:semicolon
id|rp-&gt;header.next
op_assign
id|cpu_to_le64
c_func
(paren
id|nextbn
)paren
suffix:semicolon
id|rp-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|addressPXD
c_func
(paren
op_amp
id|sp-&gt;header.self
)paren
)paren
suffix:semicolon
id|sp-&gt;header.next
op_assign
id|cpu_to_le64
c_func
(paren
id|rbn
)paren
suffix:semicolon
id|skip
op_assign
id|split-&gt;index
suffix:semicolon
multiline_comment|/*&n;&t; *      sequential append at tail (after last entry of last page)&n;&t; *&n;&t; * if splitting the last page on a level because of appending&n;&t; * a entry to it (skip is maxentry), it&squot;s likely that the access is&n;&t; * sequential. adding an empty page on the side of the level is less&n;&t; * work and can push the fill factor much higher than normal.&n;&t; * if we&squot;re wrong it&squot;s no big deal -  we will do the split the right&n;&t; * way next time.&n;&t; * (it may look like it&squot;s equally easy to do a similar hack for&n;&t; * reverse sorted data, that is, split the tree left, but it&squot;s not.&n;&t; * Be my guest.)&n;&t; */
r_if
c_cond
(paren
id|nextbn
op_eq
l_int|0
op_logical_and
id|skip
op_eq
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.maxentry
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the new/right page;&n;&t;&t; *&n;&t;&t; * action: xad insertion;&n;&t;&t; */
multiline_comment|/* insert entry at the first entry of the new right page */
id|xad
op_assign
op_amp
id|rp-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|split-&gt;flag
comma
id|split-&gt;off
comma
id|split-&gt;len
comma
id|split-&gt;addr
)paren
suffix:semicolon
id|rp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
multiline_comment|/* rxtlck-&gt;lwm.offset = XTENTRYSTART; */
id|rxtlck-&gt;lwm.length
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|rmpp
op_assign
id|rmp
suffix:semicolon
op_star
id|rbnp
op_assign
id|rbn
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|lengthPXD
c_func
(paren
id|pxd
)paren
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtSplitPage: sp:0x%p rp:0x%p&bslash;n&quot;
comma
id|sp
comma
id|rp
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      non-sequential insert (at possibly middle page)&n;&t; */
multiline_comment|/*&n;&t; * update previous pointer of old next/right page of &lt;sp&gt;&n;&t; */
r_if
c_cond
(paren
id|nextbn
op_ne
l_int|0
)paren
(brace
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|nextbn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the next page;&n;&t;&t; *&n;&t;&t; * action:sibling pointer update;&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|p-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|rbn
)paren
suffix:semicolon
multiline_comment|/* sibling page may have been updated previously, or&n;&t;&t; * it may be updated later;&n;&t;&t; */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * split the data between the split and new/right pages&n;&t; */
id|maxentry
op_assign
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.maxentry
)paren
suffix:semicolon
id|middle
op_assign
id|maxentry
op_rshift
l_int|1
suffix:semicolon
id|righthalf
op_assign
id|maxentry
op_minus
id|middle
suffix:semicolon
multiline_comment|/*&n;&t; * skip index in old split/left page - insert into left page:&n;&t; */
r_if
c_cond
(paren
id|skip
op_le
id|middle
)paren
(brace
multiline_comment|/* move right half of split page to the new right page */
id|memmove
c_func
(paren
op_amp
id|rp-&gt;xad
(braket
id|XTENTRYSTART
)braket
comma
op_amp
id|sp-&gt;xad
(braket
id|middle
)braket
comma
id|righthalf
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* shift right tail of left half to make room for new entry */
r_if
c_cond
(paren
id|skip
OL
id|middle
)paren
id|memmove
c_func
(paren
op_amp
id|sp-&gt;xad
(braket
id|skip
op_plus
l_int|1
)braket
comma
op_amp
id|sp-&gt;xad
(braket
id|skip
)braket
comma
(paren
id|middle
op_minus
id|skip
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* insert new entry */
id|xad
op_assign
op_amp
id|sp-&gt;xad
(braket
id|skip
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|split-&gt;flag
comma
id|split-&gt;off
comma
id|split-&gt;len
comma
id|split-&gt;addr
)paren
suffix:semicolon
multiline_comment|/* update page header */
id|sp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|middle
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|sxtlck-&gt;lwm.offset
op_assign
(paren
id|sxtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|skip
comma
(paren
r_int
)paren
id|sxtlck-&gt;lwm.offset
)paren
suffix:colon
id|skip
suffix:semicolon
)brace
id|rp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
id|righthalf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * skip index in new right page - insert into right page:&n;&t; */
r_else
(brace
multiline_comment|/* move left head of right half to right page */
id|n
op_assign
id|skip
op_minus
id|middle
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|rp-&gt;xad
(braket
id|XTENTRYSTART
)braket
comma
op_amp
id|sp-&gt;xad
(braket
id|middle
)braket
comma
id|n
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* insert new entry */
id|n
op_add_assign
id|XTENTRYSTART
suffix:semicolon
id|xad
op_assign
op_amp
id|rp-&gt;xad
(braket
id|n
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|split-&gt;flag
comma
id|split-&gt;off
comma
id|split-&gt;len
comma
id|split-&gt;addr
)paren
suffix:semicolon
multiline_comment|/* move right tail of right half to right page */
r_if
c_cond
(paren
id|skip
OL
id|maxentry
)paren
id|memmove
c_func
(paren
op_amp
id|rp-&gt;xad
(braket
id|n
op_plus
l_int|1
)braket
comma
op_amp
id|sp-&gt;xad
(braket
id|skip
)braket
comma
(paren
id|maxentry
op_minus
id|skip
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* update page header */
id|sp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|middle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|sxtlck-&gt;lwm.offset
op_assign
(paren
id|sxtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|middle
comma
(paren
r_int
)paren
id|sxtlck-&gt;lwm.offset
)paren
suffix:colon
id|middle
suffix:semicolon
)brace
id|rp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
id|righthalf
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|sxtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.nextindex
)paren
op_minus
id|sxtlck-&gt;lwm.offset
suffix:semicolon
multiline_comment|/* rxtlck-&gt;lwm.offset = XTENTRYSTART; */
id|rxtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|rp-&gt;header.nextindex
)paren
op_minus
id|XTENTRYSTART
suffix:semicolon
)brace
op_star
id|rmpp
op_assign
id|rmp
suffix:semicolon
op_star
id|rbnp
op_assign
id|rbn
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|lengthPXD
c_func
(paren
id|pxd
)paren
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtSplitPage: sp:0x%p rp:0x%p&bslash;n&quot;
comma
id|sp
comma
id|rp
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtSplitRoot()&n; *&n; * function:&n; *      split the full root page into&n; *      original/root/split page and new right page&n; *      i.e., root remains fixed in tree anchor (inode) and&n; *      the root is copied to a single new right child page&n; *      since root page &lt;&lt; non-root page, and&n; *      the split root page contains a single entry for the&n; *      new right child page.&n; *&n; * parameter:&n; *      int&t;&t;tid,&n; *      struct inode    *ip,&n; *      xtsplit_t       *split,&n; *      metapage_t&t;**rmpp)&n; *&n; * return:&n; *      Pointer to page in which to insert or NULL on error.&n; */
r_static
r_int
DECL|function|xtSplitRoot
id|xtSplitRoot
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
)paren
(brace
id|xtpage_t
op_star
id|sp
suffix:semicolon
id|metapage_t
op_star
id|rmp
suffix:semicolon
id|xtpage_t
op_star
id|rp
suffix:semicolon
id|s64
id|rbn
suffix:semicolon
r_int
id|skip
comma
id|nextindex
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|pxdlist_t
op_star
id|pxdlist
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
id|sp
op_assign
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|i_xtroot
suffix:semicolon
id|INCREMENT
c_func
(paren
id|xtStat.split
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      allocate a single (right) child page&n;&t; */
id|pxdlist
op_assign
id|split-&gt;pxdlist
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist-&gt;pxd
(braket
id|pxdlist-&gt;npxd
)braket
suffix:semicolon
id|pxdlist-&gt;npxd
op_increment
suffix:semicolon
id|rbn
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|rmp
op_assign
id|get_metapage
c_func
(paren
id|ip
comma
id|rbn
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmp
op_eq
l_int|NULL
)paren
r_return
id|EIO
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtSplitRoot: ip:0x%p rmp:0x%p&bslash;n&quot;
comma
id|ip
comma
id|rmp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the new right page;&n;&t; *&n;&t; * action: new page;&n;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|rmp
comma
id|ip
)paren
suffix:semicolon
id|rp
op_assign
(paren
id|xtpage_t
op_star
)paren
id|rmp-&gt;data
suffix:semicolon
id|rp-&gt;header.flag
op_assign
(paren
id|sp-&gt;header.flag
op_amp
id|BT_LEAF
)paren
ques
c_cond
id|BT_LEAF
suffix:colon
id|BT_INTERNAL
suffix:semicolon
id|rp-&gt;header.self
op_assign
op_star
id|pxd
suffix:semicolon
id|rp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
suffix:semicolon
id|rp-&gt;header.maxentry
op_assign
id|cpu_to_le16
c_func
(paren
id|PSIZE
op_rshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* initialize sibling pointers */
id|rp-&gt;header.next
op_assign
l_int|0
suffix:semicolon
id|rp-&gt;header.prev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * copy the in-line root page into new right page extent&n;&t; */
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|sp-&gt;header.maxentry
)paren
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|rp-&gt;xad
(braket
id|XTENTRYSTART
)braket
comma
op_amp
id|sp-&gt;xad
(braket
id|XTENTRYSTART
)braket
comma
(paren
id|nextindex
op_minus
id|XTENTRYSTART
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * insert the new entry into the new right/child page&n;&t; * (skip index in the new right page will not change)&n;&t; */
id|skip
op_assign
id|split-&gt;index
suffix:semicolon
multiline_comment|/* if insert into middle, shift right remaining entries */
r_if
c_cond
(paren
id|skip
op_ne
id|nextindex
)paren
id|memmove
c_func
(paren
op_amp
id|rp-&gt;xad
(braket
id|skip
op_plus
l_int|1
)braket
comma
op_amp
id|rp-&gt;xad
(braket
id|skip
)braket
comma
(paren
id|nextindex
op_minus
id|skip
)paren
op_star
r_sizeof
(paren
id|xad_t
)paren
)paren
suffix:semicolon
id|xad
op_assign
op_amp
id|rp-&gt;xad
(braket
id|skip
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|split-&gt;flag
comma
id|split-&gt;off
comma
id|split-&gt;len
comma
id|split-&gt;addr
)paren
suffix:semicolon
multiline_comment|/* update page header */
id|rp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|nextindex
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|rmp
comma
id|tlckXTREE
op_or
id|tlckNEW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
id|XTENTRYSTART
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|rp-&gt;header.nextindex
)paren
op_minus
id|XTENTRYSTART
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      reset the root&n;&t; *&n;&t; * init root with the single entry for the new right page&n;&t; * set the 1st entry offset to 0, which force the left-most key&n;&t; * at any level of the tree to be less than any search key.&n;&t; */
multiline_comment|/*&n;&t; * acquire a transaction lock on the root page (in-memory inode);&n;&t; *&n;&t; * action: root split;&n;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|split-&gt;mp
comma
id|ip
)paren
suffix:semicolon
id|xad
op_assign
op_amp
id|sp-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|XAD_NEW
comma
l_int|0
comma
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
comma
id|rbn
)paren
suffix:semicolon
multiline_comment|/* update page header of root */
id|sp-&gt;header.flag
op_and_assign
op_complement
id|BT_LEAF
suffix:semicolon
id|sp-&gt;header.flag
op_or_assign
id|BT_INTERNAL
suffix:semicolon
id|sp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|split-&gt;mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
id|XTENTRYSTART
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|rmpp
op_assign
id|rmp
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|lengthPXD
c_func
(paren
id|pxd
)paren
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtSplitRoot: sp:0x%p rp:0x%p&bslash;n&quot;
comma
id|sp
comma
id|rp
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtExtend()&n; *&n; * function: extend in-place;&n; *&n; * note: existing extent may or may not have been committed.&n; * caller is responsible for pager buffer cache update, and&n; * working block allocation map update;&n; * update pmap: alloc whole extended extent;&n; */
DECL|function|xtExtend
r_int
id|xtExtend
c_func
(paren
id|tid_t
id|tid
comma
multiline_comment|/* transaction id */
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|xoff
comma
multiline_comment|/* delta extent offset */
id|s32
id|xlen
comma
multiline_comment|/* delta extent length */
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|xtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* base B+-tree index page */
id|s64
id|bn
suffix:semicolon
r_int
id|index
comma
id|nextindex
comma
id|len
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
multiline_comment|/* traverse stack */
id|xtsplit_t
id|split
suffix:semicolon
multiline_comment|/* split information */
id|xad_t
op_star
id|xad
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
op_assign
l_int|0
suffix:semicolon
r_int
id|rootsplit
op_assign
l_int|0
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtExtend: nxoff:0x%lx nxlen:0x%x&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xoff
comma
id|xlen
)paren
)paren
suffix:semicolon
multiline_comment|/* there must exist extent to be extended */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
op_minus
l_int|1
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
id|XT_INSERT
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
m_assert
(paren
id|cmp
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* extension must be contiguous */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|jFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtExtend: xoff:0x%lx xlen:0x%x xaddr:0x%lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|offsetXAD
c_func
(paren
id|xad
)paren
comma
id|lengthXAD
c_func
(paren
id|xad
)paren
comma
(paren
id|ulong
)paren
id|addressXAD
c_func
(paren
id|xad
)paren
)paren
)paren
suffix:semicolon
m_assert
(paren
(paren
id|offsetXAD
c_func
(paren
id|xad
)paren
op_plus
id|lengthXAD
c_func
(paren
id|xad
)paren
)paren
op_eq
id|xoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the leaf page;&n;&t; *&n;&t; * action: xad insertion/extension;&n;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
multiline_comment|/* extend will overflow extent ? */
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
op_plus
id|xlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|xlen
op_minus
id|MAXXLEN
)paren
op_le
l_int|0
)paren
r_goto
id|extendOld
suffix:semicolon
multiline_comment|/*&n;&t; *      extent overflow: insert entry for new extent&n;&t; */
singleline_comment|//insertNew:
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
op_plus
id|MAXXLEN
suffix:semicolon
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
op_plus
id|MAXXLEN
suffix:semicolon
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      if the leaf page is full, insert the new entry and&n;&t; *      propagate up the router entry for the new page from split&n;&t; *&n;&t; * The xtSplitUp() will insert the entry and unpin the leaf page.&n;&t; */
r_if
c_cond
(paren
id|nextindex
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
)paren
(brace
id|rootsplit
op_assign
id|p-&gt;header.flag
op_amp
id|BT_ROOT
suffix:semicolon
multiline_comment|/* xtSpliUp() unpins leaf pages */
id|split.mp
op_assign
id|mp
suffix:semicolon
id|split.index
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|split.flag
op_assign
id|XAD_NEW
suffix:semicolon
id|split.off
op_assign
id|xoff
suffix:semicolon
multiline_comment|/* split offset */
id|split.len
op_assign
id|len
suffix:semicolon
id|split.addr
op_assign
id|xaddr
suffix:semicolon
id|split.pxdlist
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSplitUp
c_func
(paren
id|tid
comma
id|ip
comma
op_amp
id|split
comma
op_amp
id|btstack
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if leaf root has been split, original root has been&n;&t;&t; * copied to new child page, i.e., original entry now&n;&t;&t; * resides on the new child page;&n;&t;&t; */
r_if
c_cond
(paren
id|rootsplit
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
l_int|1
)paren
)paren
(brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|bn
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/* get new child page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* get back old page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      insert the new entry into the leaf page&n;&t; */
r_else
(brace
multiline_comment|/* insert the new entry: mark the entry NEW */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|XAD_NEW
comma
id|xoff
comma
id|len
comma
id|xaddr
)paren
suffix:semicolon
multiline_comment|/* advance next available entry index */
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* get back old entry */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|xlen
op_assign
id|MAXXLEN
suffix:semicolon
multiline_comment|/*&n;&t; * extend old extent&n;&t; */
id|extendOld
suffix:colon
id|XADlength
c_func
(paren
id|xad
comma
id|xlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xad-&gt;flag
op_amp
id|XAD_NEW
)paren
)paren
id|xad-&gt;flag
op_or_assign
id|XAD_EXTENDED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
)brace
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtTailgate()&n; *&n; * function: split existing &squot;tail&squot; extent&n; *      (split offset &gt;= start offset of tail extent), and&n; *      relocate and extend the split tail half;&n; *&n; * note: existing extent may or may not have been committed.&n; * caller is responsible for pager buffer cache update, and&n; * working block allocation map update;&n; * update pmap: free old split tail extent, alloc new extent;&n; */
DECL|function|xtTailgate
r_int
id|xtTailgate
c_func
(paren
id|tid_t
id|tid
comma
multiline_comment|/* transaction id */
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|xoff
comma
multiline_comment|/* split/new extent offset */
id|s32
id|xlen
comma
multiline_comment|/* new extent length */
id|s64
id|xaddr
comma
multiline_comment|/* new extent address */
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|xtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* base B+-tree index page */
id|s64
id|bn
suffix:semicolon
r_int
id|index
comma
id|nextindex
comma
id|llen
comma
id|rlen
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
multiline_comment|/* traverse stack */
id|xtsplit_t
id|split
suffix:semicolon
multiline_comment|/* split information */
id|xad_t
op_star
id|xad
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
op_assign
l_int|0
suffix:semicolon
id|tlock_t
op_star
id|mtlck
suffix:semicolon
id|maplock_t
op_star
id|pxdlock
suffix:semicolon
r_int
id|rootsplit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;printf(&quot;xtTailgate: nxoff:0x%lx nxlen:0x%x nxaddr:0x%lx&bslash;n&quot;,&n;        (ulong)xoff, xlen, (ulong)xaddr);&n;*/
multiline_comment|/* there must exist extent to be tailgated */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
id|XT_INSERT
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
m_assert
(paren
id|cmp
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* entry found must be last entry */
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
m_assert
(paren
id|index
op_eq
id|nextindex
op_minus
l_int|1
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire tlock of the leaf page containing original entry&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
multiline_comment|/* completely replace extent ? */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;printf(&quot;xtTailgate: xoff:0x%lx xlen:0x%x xaddr:0x%lx&bslash;n&quot;,&n;        (ulong)offsetXAD(xad), lengthXAD(xad), (ulong)addressXAD(xad));&n;*/
r_if
c_cond
(paren
(paren
id|llen
op_assign
id|xoff
op_minus
id|offsetXAD
c_func
(paren
id|xad
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|updateOld
suffix:semicolon
multiline_comment|/*&n;&t; *      partially replace extent: insert entry for new extent&n;&t; */
singleline_comment|//insertNew:
multiline_comment|/*&n;&t; *      if the leaf page is full, insert the new entry and&n;&t; *      propagate up the router entry for the new page from split&n;&t; *&n;&t; * The xtSplitUp() will insert the entry and unpin the leaf page.&n;&t; */
r_if
c_cond
(paren
id|nextindex
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
)paren
(brace
id|rootsplit
op_assign
id|p-&gt;header.flag
op_amp
id|BT_ROOT
suffix:semicolon
multiline_comment|/* xtSpliUp() unpins leaf pages */
id|split.mp
op_assign
id|mp
suffix:semicolon
id|split.index
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|split.flag
op_assign
id|XAD_NEW
suffix:semicolon
id|split.off
op_assign
id|xoff
suffix:semicolon
multiline_comment|/* split offset */
id|split.len
op_assign
id|xlen
suffix:semicolon
id|split.addr
op_assign
id|xaddr
suffix:semicolon
id|split.pxdlist
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSplitUp
c_func
(paren
id|tid
comma
id|ip
comma
op_amp
id|split
comma
op_amp
id|btstack
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if leaf root has been split, original root has been&n;&t;&t; * copied to new child page, i.e., original entry now&n;&t;&t; * resides on the new child page;&n;&t;&t; */
r_if
c_cond
(paren
id|rootsplit
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
l_int|1
)paren
)paren
(brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|bn
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/* get new child page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* get back old page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      insert the new entry into the leaf page&n;&t; */
r_else
(brace
multiline_comment|/* insert the new entry: mark the entry NEW */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|XAD_NEW
comma
id|xoff
comma
id|xlen
comma
id|xaddr
)paren
suffix:semicolon
multiline_comment|/* advance next available entry index */
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* get back old XAD */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * truncate/relocate old extent at split offset&n;&t; */
id|updateOld
suffix:colon
multiline_comment|/* update dmap for old/committed/truncated extent */
id|rlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
op_minus
id|llen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xad-&gt;flag
op_amp
id|XAD_NEW
)paren
)paren
(brace
multiline_comment|/* free from PWMAP at commit */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|mtlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckMAP
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|maplock_t
op_star
)paren
op_amp
id|mtlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|addressXAD
c_func
(paren
id|xad
)paren
op_plus
id|llen
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|rlen
)paren
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
)brace
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtTailgate: free extent xaddr:0x%lx xlen:0x%x&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|addressPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
comma
id|lengthPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* free from WMAP */
id|dbFree
c_func
(paren
id|ip
comma
id|addressXAD
c_func
(paren
id|xad
)paren
op_plus
id|llen
comma
(paren
id|s64
)paren
id|rlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|llen
)paren
multiline_comment|/* truncate */
id|XADlength
c_func
(paren
id|xad
comma
id|llen
)paren
suffix:semicolon
r_else
multiline_comment|/* replace */
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|XAD_NEW
comma
id|xoff
comma
id|xlen
comma
id|xaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
)brace
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtUpdate()&n; *&n; * function: update XAD;&n; *&n; *      update extent for allocated_but_not_recorded or&n; *      compressed extent;&n; *&n; * parameter:&n; *      nxad    - new XAD;&n; *                logical extent of the specified XAD must be completely&n; *                contained by an existing XAD;&n; */
DECL|function|xtUpdate
r_int
id|xtUpdate
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xad_t
op_star
id|nxad
)paren
(brace
multiline_comment|/* new XAD */
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|xtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* base B+-tree index page */
id|s64
id|bn
suffix:semicolon
r_int
id|index0
comma
id|index
comma
id|newindex
comma
id|nextindex
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
multiline_comment|/* traverse stack */
id|xtsplit_t
id|split
suffix:semicolon
multiline_comment|/* split information */
id|xad_t
op_star
id|xad
comma
op_star
id|lxad
comma
op_star
id|rxad
suffix:semicolon
r_int
id|xflag
suffix:semicolon
id|s64
id|nxoff
comma
id|xoff
suffix:semicolon
r_int
id|nxlen
comma
id|xlen
comma
id|lxlen
comma
id|rxlen
suffix:semicolon
id|s64
id|nxaddr
comma
id|xaddr
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
op_assign
l_int|0
suffix:semicolon
r_int
id|rootsplit
op_assign
l_int|0
comma
id|newpage
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* there must exist extent to be tailgated */
id|nxoff
op_assign
id|offsetXAD
c_func
(paren
id|nxad
)paren
suffix:semicolon
id|nxlen
op_assign
id|lengthXAD
c_func
(paren
id|nxad
)paren
suffix:semicolon
id|nxaddr
op_assign
id|addressXAD
c_func
(paren
id|nxad
)paren
suffix:semicolon
multiline_comment|/*&n;printf(&quot;xtUpdate: nxflag:0x%x nxoff:0x%lx nxlen:0x%x nxaddr:0x%lx&bslash;n&quot;,&n;        nxad-&gt;flag, (ulong)nxoff, nxlen, (ulong)nxaddr);&n;*/
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|nxoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
id|XT_INSERT
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
m_assert
(paren
id|cmp
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index0
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire tlock of the leaf page containing original entry&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index0
)braket
suffix:semicolon
id|xflag
op_assign
id|xad-&gt;flag
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/*&n;printf(&quot;xtUpdate: xflag:0x%x xoff:0x%lx xlen:0x%x xaddr:0x%lx&bslash;n&quot;,&n;        xflag, (ulong)xoff, xlen, (ulong)xaddr);&n;*/
multiline_comment|/* nXAD must be completely contained within XAD */
m_assert
(paren
id|xoff
op_le
id|nxoff
)paren
suffix:semicolon
m_assert
(paren
id|nxoff
op_plus
id|nxlen
op_le
id|xoff
op_plus
id|xlen
)paren
suffix:semicolon
id|index
op_assign
id|index0
suffix:semicolon
id|newindex
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
macro_line|#ifdef  _JFS_WIP_NOCOALESCE
r_if
c_cond
(paren
id|xoff
OL
id|nxoff
)paren
r_goto
id|updateRight
suffix:semicolon
multiline_comment|/*&n;&t; * replace XAD with nXAD&n;&t; */
id|replace
suffix:colon
multiline_comment|/* (nxoff == xoff) */
r_if
c_cond
(paren
id|nxlen
op_eq
id|xlen
)paren
(brace
multiline_comment|/* replace XAD with nXAD:recorded */
op_star
id|xad
op_assign
op_star
id|nxad
suffix:semicolon
id|xad-&gt;flag
op_assign
id|xflag
op_amp
op_complement
id|XAD_NOTRECORDED
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
multiline_comment|/* (nxlen &lt; xlen) */
r_goto
id|updateLeft
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* _JFS_WIP_NOCOALESCE */
multiline_comment|/* #ifdef _JFS_WIP_COALESCE */
r_if
c_cond
(paren
id|xoff
OL
id|nxoff
)paren
r_goto
id|coalesceRight
suffix:semicolon
multiline_comment|/*&n;&t; * coalesce with left XAD&n;&t; */
singleline_comment|//coalesceLeft: /* (xoff == nxoff) */
multiline_comment|/* is XAD first entry of page ? */
r_if
c_cond
(paren
id|index
op_eq
id|XTENTRYSTART
)paren
r_goto
id|replace
suffix:semicolon
multiline_comment|/* is nXAD logically and physically contiguous with lXAD ? */
id|lxad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
op_minus
l_int|1
)braket
suffix:semicolon
id|lxlen
op_assign
id|lengthXAD
c_func
(paren
id|lxad
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|lxad-&gt;flag
op_amp
id|XAD_NOTRECORDED
)paren
op_logical_and
(paren
id|nxoff
op_eq
id|offsetXAD
c_func
(paren
id|lxad
)paren
op_plus
id|lxlen
)paren
op_logical_and
(paren
id|nxaddr
op_eq
id|addressXAD
c_func
(paren
id|lxad
)paren
op_plus
id|lxlen
)paren
op_logical_and
(paren
id|lxlen
op_plus
id|nxlen
OL
id|MAXXLEN
)paren
)paren
(brace
multiline_comment|/* extend right lXAD */
id|index0
op_assign
id|index
op_minus
l_int|1
suffix:semicolon
id|XADlength
c_func
(paren
id|lxad
comma
id|lxlen
op_plus
id|nxlen
)paren
suffix:semicolon
multiline_comment|/* If we just merged two extents together, need to make sure the&n;&t;&t; * right extent gets logged.  If the left one is marked XAD_NEW,&n;&t;&t; * then we know it will be logged.  Otherwise, mark as&n;&t;&t; * XAD_EXTENDED&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lxad-&gt;flag
op_amp
id|XAD_NEW
)paren
)paren
id|lxad-&gt;flag
op_or_assign
id|XAD_EXTENDED
suffix:semicolon
r_if
c_cond
(paren
id|xlen
OG
id|nxlen
)paren
(brace
multiline_comment|/* truncate XAD */
id|XADoffset
c_func
(paren
id|xad
comma
id|xoff
op_plus
id|nxlen
)paren
suffix:semicolon
id|XADlength
c_func
(paren
id|xad
comma
id|xlen
op_minus
id|nxlen
)paren
suffix:semicolon
id|XADaddress
c_func
(paren
id|xad
comma
id|xaddr
op_plus
id|nxlen
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (xlen == nxlen) */
multiline_comment|/* remove XAD */
r_if
c_cond
(paren
id|index
OL
id|nextindex
op_minus
l_int|1
)paren
id|memmove
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
comma
(paren
id|nextindex
op_minus
id|index
op_minus
l_int|1
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|index
op_assign
id|index0
suffix:semicolon
id|newindex
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
id|xoff
op_assign
id|nxoff
op_assign
id|offsetXAD
c_func
(paren
id|lxad
)paren
suffix:semicolon
id|xlen
op_assign
id|nxlen
op_assign
id|lxlen
op_plus
id|nxlen
suffix:semicolon
id|xaddr
op_assign
id|nxaddr
op_assign
id|addressXAD
c_func
(paren
id|lxad
)paren
suffix:semicolon
r_goto
id|coalesceRight
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * replace XAD with nXAD&n;&t; */
id|replace
suffix:colon
multiline_comment|/* (nxoff == xoff) */
r_if
c_cond
(paren
id|nxlen
op_eq
id|xlen
)paren
(brace
multiline_comment|/* replace XAD with nXAD:recorded */
op_star
id|xad
op_assign
op_star
id|nxad
suffix:semicolon
id|xad-&gt;flag
op_assign
id|xflag
op_amp
op_complement
id|XAD_NOTRECORDED
suffix:semicolon
r_goto
id|coalesceRight
suffix:semicolon
)brace
r_else
multiline_comment|/* (nxlen &lt; xlen) */
r_goto
id|updateLeft
suffix:semicolon
multiline_comment|/*&n;&t; * coalesce with right XAD&n;&t; */
id|coalesceRight
suffix:colon
multiline_comment|/* (xoff &lt;= nxoff) */
multiline_comment|/* is XAD last entry of page ? */
r_if
c_cond
(paren
id|newindex
op_eq
id|nextindex
)paren
(brace
r_if
c_cond
(paren
id|xoff
op_eq
id|nxoff
)paren
r_goto
id|out
suffix:semicolon
r_goto
id|updateRight
suffix:semicolon
)brace
multiline_comment|/* is nXAD logically and physically contiguous with rXAD ? */
id|rxad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
id|rxlen
op_assign
id|lengthXAD
c_func
(paren
id|rxad
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rxad-&gt;flag
op_amp
id|XAD_NOTRECORDED
)paren
op_logical_and
(paren
id|nxoff
op_plus
id|nxlen
op_eq
id|offsetXAD
c_func
(paren
id|rxad
)paren
)paren
op_logical_and
(paren
id|nxaddr
op_plus
id|nxlen
op_eq
id|addressXAD
c_func
(paren
id|rxad
)paren
)paren
op_logical_and
(paren
id|rxlen
op_plus
id|nxlen
OL
id|MAXXLEN
)paren
)paren
(brace
multiline_comment|/* extend left rXAD */
id|XADoffset
c_func
(paren
id|rxad
comma
id|nxoff
)paren
suffix:semicolon
id|XADlength
c_func
(paren
id|rxad
comma
id|rxlen
op_plus
id|nxlen
)paren
suffix:semicolon
id|XADaddress
c_func
(paren
id|rxad
comma
id|nxaddr
)paren
suffix:semicolon
multiline_comment|/* If we just merged two extents together, need to make sure&n;&t;&t; * the left extent gets logged.  If the right one is marked&n;&t;&t; * XAD_NEW, then we know it will be logged.  Otherwise, mark as&n;&t;&t; * XAD_EXTENDED&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|rxad-&gt;flag
op_amp
id|XAD_NEW
)paren
)paren
id|rxad-&gt;flag
op_or_assign
id|XAD_EXTENDED
suffix:semicolon
r_if
c_cond
(paren
id|xlen
OG
id|nxlen
)paren
multiline_comment|/* truncate XAD */
id|XADlength
c_func
(paren
id|xad
comma
id|xlen
op_minus
id|nxlen
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* (xlen == nxlen) */
multiline_comment|/* remove XAD */
id|memmove
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
comma
(paren
id|nextindex
op_minus
id|index
op_minus
l_int|1
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xoff
op_eq
id|nxoff
)paren
r_goto
id|out
suffix:semicolon
m_assert
(paren
id|xoff
OL
id|nxoff
)paren
suffix:semicolon
multiline_comment|/* #endif _JFS_WIP_COALESCE */
multiline_comment|/*&n;&t; * split XAD into (lXAD, nXAD):&n;&t; *&n;&t; *          |---nXAD---&gt;&n;&t; * --|----------XAD----------|--&n;&t; *   |-lXAD-|&n;&t; */
id|updateRight
suffix:colon
multiline_comment|/* (xoff &lt; nxoff) */
multiline_comment|/* truncate old XAD as lXAD:not_recorded */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|XADlength
c_func
(paren
id|xad
comma
id|nxoff
op_minus
id|xoff
)paren
suffix:semicolon
multiline_comment|/* insert nXAD:recorded */
r_if
c_cond
(paren
id|nextindex
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
)paren
(brace
multiline_comment|/*&n;printf(&quot;xtUpdate.updateRight.split p:0x%p&bslash;n&quot;, p);&n;*/
id|rootsplit
op_assign
id|p-&gt;header.flag
op_amp
id|BT_ROOT
suffix:semicolon
multiline_comment|/* xtSpliUp() unpins leaf pages */
id|split.mp
op_assign
id|mp
suffix:semicolon
id|split.index
op_assign
id|newindex
suffix:semicolon
id|split.flag
op_assign
id|xflag
op_amp
op_complement
id|XAD_NOTRECORDED
suffix:semicolon
id|split.off
op_assign
id|nxoff
suffix:semicolon
id|split.len
op_assign
id|nxlen
suffix:semicolon
id|split.addr
op_assign
id|nxaddr
suffix:semicolon
id|split.pxdlist
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSplitUp
c_func
(paren
id|tid
comma
id|ip
comma
op_amp
id|split
comma
op_amp
id|btstack
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if leaf root has been split, original root has been&n;&t;&t; * copied to new child page, i.e., original entry now&n;&t;&t; * resides on the new child page;&n;&t;&t; */
r_if
c_cond
(paren
id|rootsplit
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
l_int|1
)paren
)paren
(brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|bn
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/* get new child page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* get back old page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
multiline_comment|/* is nXAD on new page ? */
r_if
c_cond
(paren
id|newindex
OG
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
op_rshift
l_int|1
)paren
)paren
(brace
id|newindex
op_assign
id|newindex
op_minus
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_plus
id|XTENTRYSTART
suffix:semicolon
id|newpage
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* if insert into middle, shift right remaining entries */
r_if
c_cond
(paren
id|newindex
OL
id|nextindex
)paren
id|memmove
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|newindex
op_plus
l_int|1
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|newindex
)braket
comma
(paren
id|nextindex
op_minus
id|newindex
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* insert the entry */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|newindex
)braket
suffix:semicolon
op_star
id|xad
op_assign
op_star
id|nxad
suffix:semicolon
id|xad-&gt;flag
op_assign
id|xflag
op_amp
op_complement
id|XAD_NOTRECORDED
suffix:semicolon
multiline_comment|/* advance next available entry index. */
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * does nXAD force 3-way split ?&n;&t; *&n;&t; *          |---nXAD---&gt;|&n;&t; * --|----------XAD-------------|--&n;&t; *   |-lXAD-|           |-rXAD -|&n;&t; */
r_if
c_cond
(paren
id|nxoff
op_plus
id|nxlen
op_eq
id|xoff
op_plus
id|xlen
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* reorient nXAD as XAD for further split XAD into (nXAD, rXAD) */
r_if
c_cond
(paren
id|newpage
)paren
(brace
multiline_comment|/* close out old page */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index0
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index0
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
)brace
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* get new right page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
id|index0
op_assign
id|index
op_assign
id|newindex
suffix:semicolon
)brace
r_else
id|index
op_increment
suffix:semicolon
id|newindex
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
id|xlen
op_assign
id|xlen
op_minus
(paren
id|nxoff
op_minus
id|xoff
)paren
suffix:semicolon
id|xoff
op_assign
id|nxoff
suffix:semicolon
id|xaddr
op_assign
id|nxaddr
suffix:semicolon
multiline_comment|/* recompute split pages */
r_if
c_cond
(paren
id|nextindex
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
)paren
(brace
multiline_comment|/*&n;printf(&quot;xtUpdate: updateRight+Left recompute split pages: p:0x%p&bslash;n&quot;, p);&n;*/
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|nxoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
id|XT_INSERT
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
m_assert
(paren
id|cmp
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index0
)paren
suffix:semicolon
m_assert
(paren
id|index0
op_eq
id|index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * split XAD into (nXAD, rXAD)&n;&t; *&n;&t; *          ---nXAD---|&n;&t; * --|----------XAD----------|--&n;&t; *                    |-rXAD-|&n;&t; */
id|updateLeft
suffix:colon
multiline_comment|/* (nxoff == xoff) &amp;&amp; (nxlen &lt; xlen) */
multiline_comment|/* update old XAD with nXAD:recorded */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
op_star
id|xad
op_assign
op_star
id|nxad
suffix:semicolon
id|xad-&gt;flag
op_assign
id|xflag
op_amp
op_complement
id|XAD_NOTRECORDED
suffix:semicolon
multiline_comment|/* insert rXAD:not_recorded */
id|xoff
op_assign
id|xoff
op_plus
id|nxlen
suffix:semicolon
id|xlen
op_assign
id|xlen
op_minus
id|nxlen
suffix:semicolon
id|xaddr
op_assign
id|xaddr
op_plus
id|nxlen
suffix:semicolon
r_if
c_cond
(paren
id|nextindex
op_eq
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
)paren
(brace
id|rootsplit
op_assign
id|p-&gt;header.flag
op_amp
id|BT_ROOT
suffix:semicolon
multiline_comment|/*&n;printf(&quot;xtUpdate.updateLeft.split p:0x%p&bslash;n&quot;, p);&n;*/
multiline_comment|/* xtSpliUp() unpins leaf pages */
id|split.mp
op_assign
id|mp
suffix:semicolon
id|split.index
op_assign
id|newindex
suffix:semicolon
id|split.flag
op_assign
id|xflag
suffix:semicolon
id|split.off
op_assign
id|xoff
suffix:semicolon
id|split.len
op_assign
id|xlen
suffix:semicolon
id|split.addr
op_assign
id|xaddr
suffix:semicolon
id|split.pxdlist
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSplitUp
c_func
(paren
id|tid
comma
id|ip
comma
op_amp
id|split
comma
op_amp
id|btstack
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if leaf root has been split, original root has been&n;&t;&t; * copied to new child page, i.e., original entry now&n;&t;&t; * resides on the new child page;&n;&t;&t; */
r_if
c_cond
(paren
id|rootsplit
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
op_plus
l_int|1
)paren
)paren
(brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|bn
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/* get new child page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
)brace
)brace
r_else
multiline_comment|/* get back old page */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if insert into middle, shift right remaining entries */
r_if
c_cond
(paren
id|newindex
OL
id|nextindex
)paren
id|memmove
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|newindex
op_plus
l_int|1
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|newindex
)braket
comma
(paren
id|nextindex
op_minus
id|newindex
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
multiline_comment|/* insert the entry */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|newindex
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|xflag
comma
id|xoff
comma
id|xlen
comma
id|xaddr
)paren
suffix:semicolon
multiline_comment|/* advance next available entry index. */
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
(brace
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index0
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index0
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
)brace
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/*&n; *      xtAppend()&n; *&n; * function: grow in append mode from contiguous region specified ;&n; *&n; * parameter:&n; *      tid             - transaction id;&n; *      ip              - file object;&n; *      xflag           - extent flag:&n; *      xoff            - extent offset;&n; *      maxblocks       - max extent length;&n; *      xlen            - extent length (in/out);&n; *      xaddrp          - extent address pointer (in/out):&n; *      flag            -&n; *&n; * return:&n; */
DECL|function|xtAppend
r_int
id|xtAppend
c_func
(paren
id|tid_t
id|tid
comma
multiline_comment|/* transaction id */
r_struct
id|inode
op_star
id|ip
comma
r_int
id|xflag
comma
id|s64
id|xoff
comma
id|s32
id|maxblocks
comma
multiline_comment|/* @GD1 */
id|s32
op_star
id|xlenp
comma
multiline_comment|/* (in/out) */
id|s64
op_star
id|xaddrp
comma
multiline_comment|/* (in/out) */
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|xtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* base B+-tree index page */
id|s64
id|bn
comma
id|xaddr
suffix:semicolon
r_int
id|index
comma
id|nextindex
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
multiline_comment|/* traverse stack */
id|xtsplit_t
id|split
suffix:semicolon
multiline_comment|/* split information */
id|xad_t
op_star
id|xad
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
r_int
id|nsplit
comma
id|nblocks
comma
id|xlen
suffix:semicolon
id|pxdlist_t
id|pxdlist
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|xaddr
op_assign
op_star
id|xaddrp
suffix:semicolon
id|xlen
op_assign
op_star
id|xlenp
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtAppend: xoff:0x%lx maxblocks:%d xlen:%d xaddr:0x%lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xoff
comma
id|maxblocks
comma
id|xlen
comma
(paren
id|ulong
)paren
id|xaddr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      search for the entry location at which to insert:&n;&t; *&n;&t; * xtFastSearch() and xtSearch() both returns (leaf page&n;&t; * pinned, index at which to insert).&n;&t; * n.b. xtSearch() may return index of maxentry of&n;&t; * the full page.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
id|XT_INSERT
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|EEXIST
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
singleline_comment|//insert:
multiline_comment|/*&n;&t; *      insert entry for new extent&n;&t; */
id|xflag
op_or_assign
id|XAD_NEW
suffix:semicolon
multiline_comment|/*&n;&t; *      if the leaf page is full, split the page and&n;&t; *      propagate up the router entry for the new page from split&n;&t; *&n;&t; * The xtSplitUp() will insert the entry and unpin the leaf page.&n;&t; */
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextindex
OL
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
)paren
r_goto
id|insertLeaf
suffix:semicolon
multiline_comment|/*&n;&t; * allocate new index blocks to cover index page split(s)&n;&t; */
id|nsplit
op_assign
id|btstack.nsplit
suffix:semicolon
id|split.pxdlist
op_assign
op_amp
id|pxdlist
suffix:semicolon
id|pxdlist.maxnpxd
op_assign
id|pxdlist.npxd
op_assign
l_int|0
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist.pxd
(braket
l_int|0
)braket
suffix:semicolon
id|nblocks
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|nsplit
OG
l_int|0
suffix:semicolon
id|nsplit
op_decrement
comma
id|pxd
op_increment
comma
id|xaddr
op_add_assign
id|nblocks
comma
id|maxblocks
op_sub_assign
id|nblocks
)paren
(brace
multiline_comment|/* @GD1 */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocBottomUp
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|nblocks
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|PXDaddress
c_func
(paren
id|pxd
comma
id|xaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|nblocks
)paren
suffix:semicolon
id|pxdlist.maxnpxd
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* undo allocation */
r_goto
id|out
suffix:semicolon
)brace
id|xlen
op_assign
id|min
c_func
(paren
id|xlen
comma
id|maxblocks
)paren
suffix:semicolon
multiline_comment|/* @GD1 */
multiline_comment|/*&n;&t; * allocate data extent requested&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocBottomUp
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|split.mp
op_assign
id|mp
suffix:semicolon
id|split.index
op_assign
id|index
suffix:semicolon
id|split.flag
op_assign
id|xflag
suffix:semicolon
id|split.off
op_assign
id|xoff
suffix:semicolon
id|split.len
op_assign
id|xlen
suffix:semicolon
id|split.addr
op_assign
id|xaddr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSplitUp
c_func
(paren
id|tid
comma
id|ip
comma
op_amp
id|split
comma
op_amp
id|btstack
)paren
)paren
)paren
(brace
multiline_comment|/* undo data extent allocation */
id|dbFree
c_func
(paren
id|ip
comma
op_star
id|xaddrp
comma
(paren
id|s64
)paren
op_star
id|xlenp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
op_star
id|xaddrp
op_assign
id|xaddr
suffix:semicolon
op_star
id|xlenp
op_assign
id|xlen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      insert the new entry into the leaf page&n;&t; */
id|insertLeaf
suffix:colon
multiline_comment|/*&n;&t; * allocate data extent requested&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAllocBottomUp
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the leaf page;&n;&t; *&n;&t; * action: xad insertion/extension;&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* insert the new entry: mark the entry NEW */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|XT_PUTENTRY
c_func
(paren
id|xad
comma
id|xflag
comma
id|xoff
comma
id|xlen
comma
id|xaddr
)paren
suffix:semicolon
multiline_comment|/* advance next available entry index */
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index
comma
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
op_star
id|xaddrp
op_assign
id|xaddr
suffix:semicolon
op_star
id|xlenp
op_assign
id|xlen
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* - TBD for defragmentaion/reorganization -&n; *&n; *      xtDelete()&n; *&n; * function:&n; *      delete the entry with the specified key.&n; *&n; *      N.B.: whole extent of the entry is assumed to be deleted.&n; *&n; * parameter:&n; *&n; * return:&n; *       ENOENT: if the entry is not found.&n; *&n; * exception:&n; */
DECL|function|xtDelete
r_int
id|xtDelete
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|xoff
comma
id|s32
id|xlen
comma
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
r_int
id|cmp
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
comma
id|nextindex
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
multiline_comment|/*&n;&t; * find the matching entry; xtSearch() pins the page&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
l_int|0
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
(brace
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * delete the entry from the leaf page&n;&t; */
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if the leaf page bocome empty, free the page&n;&t; */
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
)paren
r_return
(paren
id|xtDeleteUp
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|p
comma
op_amp
id|btstack
)paren
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the leaf page;&n;&t; *&n;&t; * action:xad deletion;&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index
comma
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index
suffix:semicolon
multiline_comment|/* if delete from middle, shift left/compact the remaining entries */
r_if
c_cond
(paren
id|index
OL
id|nextindex
op_minus
l_int|1
)paren
id|memmove
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
comma
(paren
id|nextindex
op_minus
id|index
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xad_t
)paren
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* - TBD for defragmentaion/reorganization -&n; *&n; *      xtDeleteUp()&n; *&n; * function:&n; *      free empty pages as propagating deletion up the tree&n; *&n; * parameter:&n; *&n; * return:&n; */
r_static
r_int
DECL|function|xtDeleteUp
id|xtDeleteUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|metapage_t
op_star
id|fmp
comma
id|xtpage_t
op_star
id|fp
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
comma
id|nextindex
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
r_int
id|xlen
suffix:semicolon
id|btframe_t
op_star
id|parent
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
multiline_comment|/*&n;&t; * keep root leaf page which has become empty&n;&t; */
r_if
c_cond
(paren
id|fp-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
multiline_comment|/* keep the root page */
id|fp-&gt;header.flag
op_and_assign
op_complement
id|BT_INTERNAL
suffix:semicolon
id|fp-&gt;header.flag
op_or_assign
id|BT_LEAF
suffix:semicolon
id|fp-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
suffix:semicolon
multiline_comment|/* XT_PUTPAGE(fmp); */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * free non-root leaf page&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtRelink
c_func
(paren
id|tid
comma
id|ip
comma
id|fp
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
op_amp
id|fp-&gt;header.self
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|fp-&gt;header.self
)paren
suffix:semicolon
multiline_comment|/* free the page extent */
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
multiline_comment|/* free the buffer page */
id|discard_metapage
c_func
(paren
id|fmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * propagate page deletion up the index tree&n;&t; *&n;&t; * If the delete from the parent page makes it empty,&n;&t; * continue all the way up the tree.&n;&t; * stop if the root page is reached (which is never deleted) or&n;&t; * if the entry deletion does not empty the page.&n;&t; */
r_while
c_loop
(paren
(paren
id|parent
op_assign
id|BT_POP
c_func
(paren
id|btstack
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* get/pin the parent page &lt;sp&gt; */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|parent-&gt;bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|index
op_assign
id|parent-&gt;index
suffix:semicolon
multiline_comment|/* delete the entry for the freed child page from parent.&n;&t;&t; */
id|nextindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * the parent has the single entry being deleted:&n;&t;&t; * free the parent page which has become empty.&n;&t;&t; */
r_if
c_cond
(paren
id|nextindex
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
multiline_comment|/* keep the root page */
id|p-&gt;header.flag
op_and_assign
op_complement
id|BT_INTERNAL
suffix:semicolon
id|p-&gt;header.flag
op_or_assign
id|BT_LEAF
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
suffix:semicolon
multiline_comment|/* XT_PUTPAGE(fmp); */
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* free the parent page */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtRelink
c_func
(paren
id|tid
comma
id|ip
comma
id|p
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
op_amp
id|p-&gt;header.self
)paren
suffix:semicolon
multiline_comment|/* free the page extent */
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
)paren
suffix:semicolon
multiline_comment|/* unpin/free the buffer page */
id|discard_metapage
c_func
(paren
id|fmp
)paren
suffix:semicolon
multiline_comment|/* propagate up */
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * the parent has other entries remaining:&n;&t;&t; * delete the router entry from the parent page.&n;&t;&t; */
r_else
(brace
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * acquire a transaction lock on the leaf page;&n;&t;&t;&t; *&n;&t;&t;&t; * action:xad deletion;&n;&t;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index
comma
id|xtlck-&gt;lwm
dot
id|offset
)paren
suffix:colon
id|index
suffix:semicolon
multiline_comment|/* if delete from middle,&n;&t;&t;&t; * shift left/compact the remaining entries in the page&n;&t;&t;&t; */
r_if
c_cond
(paren
id|index
OL
id|nextindex
op_minus
l_int|1
)paren
id|memmove
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
comma
(paren
id|nextindex
op_minus
id|index
op_minus
l_int|1
)paren
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtDeleteUp(entry): 0x%lx[%d]&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|parent-&gt;bn
comma
id|index
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* unpin the parent page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* exit propagation up */
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        xtRelocate()&n; *&n; * FUNCTION:    relocate xtpage or data extent of regular file;&n; *              This function is mainly used by defragfs utility.&n; *&n; * NOTE:        This routine does not have the logic to handle&n; *              uncommitted allocated extent. The caller should call&n; *              txCommit() to commit all the allocation before call&n; *              this routine.&n; */
DECL|function|xtRelocate
id|xtRelocate
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xad_t
op_star
id|oxad
comma
multiline_comment|/* old XAD */
id|s64
id|nxaddr
comma
multiline_comment|/* new xaddr */
r_int
id|xtype
)paren
(brace
multiline_comment|/* extent type: XTPAGE or DATAEXT */
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
id|metapage_t
op_star
id|mp
comma
op_star
id|pmp
comma
op_star
id|lmp
comma
op_star
id|rmp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|xtpage_t
op_star
id|p
comma
op_star
id|pp
comma
op_star
id|rp
comma
op_star
id|lp
suffix:semicolon
multiline_comment|/* base B+-tree index page */
id|xad_t
op_star
id|xad
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|s64
id|xoff
comma
id|xsize
suffix:semicolon
r_int
id|xlen
suffix:semicolon
id|s64
id|oxaddr
comma
id|sxaddr
comma
id|dxaddr
comma
id|nextbn
comma
id|prevbn
suffix:semicolon
id|cbuf_t
op_star
id|cp
suffix:semicolon
id|s64
id|offset
comma
id|nbytes
comma
id|nbrd
comma
id|pno
suffix:semicolon
r_int
id|nb
comma
id|npages
comma
id|nblks
suffix:semicolon
id|s64
id|bn
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_int
id|index
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
multiline_comment|/* traverse stack */
id|xtype
op_assign
id|xtype
op_amp
id|EXTENT_TYPE
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|oxad
)paren
suffix:semicolon
id|oxaddr
op_assign
id|addressXAD
c_func
(paren
id|oxad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|oxad
)paren
suffix:semicolon
multiline_comment|/* validate extent offset */
id|offset
op_assign
id|xoff
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|ip-&gt;i_size
)paren
r_return
id|ESTALE
suffix:semicolon
multiline_comment|/* stale extent */
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtRelocate: xtype:%d xoff:0x%lx xlen:0x%x xaddr:0x%lx:0x%lx&bslash;n&quot;
comma
id|xtype
comma
(paren
id|ulong
)paren
id|xoff
comma
id|xlen
comma
(paren
id|ulong
)paren
id|oxaddr
comma
(paren
id|ulong
)paren
id|nxaddr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      1. get and validate the parent xtpage/xad entry&n;&t; *      covering the source extent to be relocated;&n;&t; */
r_if
c_cond
(paren
id|xtype
op_eq
id|DATAEXT
)paren
(brace
multiline_comment|/* search in leaf entry */
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
id|ESTALE
suffix:semicolon
)brace
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|pmp
comma
id|pp
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* validate for exact match with a single entry */
id|xad
op_assign
op_amp
id|pp-&gt;xad
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|addressXAD
c_func
(paren
id|xad
)paren
op_ne
id|oxaddr
op_logical_or
id|lengthXAD
c_func
(paren
id|xad
)paren
op_ne
id|xlen
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
id|ESTALE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* (xtype == XTPAGE) */
multiline_comment|/* search in internal entry */
id|rc
op_assign
id|xtSearchNode
c_func
(paren
id|ip
comma
id|oxad
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
id|ESTALE
suffix:semicolon
)brace
multiline_comment|/* retrieve search result */
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|pmp
comma
id|pp
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* xtSearchNode() validated for exact match with a single entry&n;&t;&t; */
id|xad
op_assign
op_amp
id|pp-&gt;xad
(braket
id|index
)braket
suffix:semicolon
)brace
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtRelocate: parent xad entry validated.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      2. relocate the extent&n;&t; */
r_if
c_cond
(paren
id|xtype
op_eq
id|DATAEXT
)paren
(brace
multiline_comment|/* if the extent is allocated-but-not-recorded&n;&t;&t; * there is no real data to be moved in this extent,&n;&t;&t; */
r_if
c_cond
(paren
id|xad-&gt;flag
op_amp
id|XAD_NOTRECORDED
)paren
r_goto
id|out
suffix:semicolon
r_else
multiline_comment|/* release xtpage for cmRead()/xtLookup() */
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      cmRelocate()&n;&t;&t; *&n;&t;&t; * copy target data pages to be relocated;&n;&t;&t; *&n;&t;&t; * data extent must start at page boundary and&n;&t;&t; * multiple of page size (except the last data extent);&n;&t;&t; * read in each page of the source data extent into cbuf,&n;&t;&t; * update the cbuf extent descriptor of the page to be&n;&t;&t; * homeward bound to new dst data extent&n;&t;&t; * copy the data from the old extent to new extent.&n;&t;&t; * copy is essential for compressed files to avoid problems&n;&t;&t; * that can arise if there was a change in compression&n;&t;&t; * algorithms.&n;&t;&t; * it is a good strategy because it may disrupt cache&n;&t;&t; * policy to keep the pages in memory afterwards.&n;&t;&t; */
id|offset
op_assign
id|xoff
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
m_assert
(paren
(paren
id|offset
op_amp
id|CM_OFFSET
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|nbytes
op_assign
id|xlen
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
id|pno
op_assign
id|offset
op_rshift
id|CM_L2BSIZE
suffix:semicolon
id|npages
op_assign
(paren
id|nbytes
op_plus
(paren
id|CM_BSIZE
op_minus
l_int|1
)paren
)paren
op_rshift
id|CM_L2BSIZE
suffix:semicolon
multiline_comment|/*&n;                npages = ((offset + nbytes - 1) &gt;&gt; CM_L2BSIZE) -&n;                         (offset &gt;&gt; CM_L2BSIZE) + 1;&n;*/
id|sxaddr
op_assign
id|oxaddr
suffix:semicolon
id|dxaddr
op_assign
id|nxaddr
suffix:semicolon
multiline_comment|/* process the request one cache buffer at a time */
r_for
c_loop
(paren
id|nbrd
op_assign
l_int|0
suffix:semicolon
id|nbrd
OL
id|nbytes
suffix:semicolon
id|nbrd
op_add_assign
id|nb
comma
id|offset
op_add_assign
id|nb
comma
id|pno
op_increment
comma
id|npages
op_decrement
)paren
(brace
multiline_comment|/* compute page size */
id|nb
op_assign
id|min
c_func
(paren
id|nbytes
op_minus
id|nbrd
comma
id|CM_BSIZE
)paren
suffix:semicolon
multiline_comment|/* get the cache buffer of the page */
r_if
c_cond
(paren
id|rc
op_assign
id|cmRead
c_func
(paren
id|ip
comma
id|offset
comma
id|npages
comma
op_amp
id|cp
)paren
)paren
r_break
suffix:semicolon
m_assert
(paren
id|addressPXD
c_func
(paren
op_amp
id|cp-&gt;cm_pxd
)paren
op_eq
id|sxaddr
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
id|cp-&gt;cm_modified
)paren
suffix:semicolon
multiline_comment|/* bind buffer with the new extent address */
id|nblks
op_assign
id|nb
op_rshift
id|JFS_IP
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
id|cmSetXD
c_func
(paren
id|ip
comma
id|cp
comma
id|pno
comma
id|dxaddr
comma
id|nblks
)paren
suffix:semicolon
multiline_comment|/* release the cbuf, mark it as modified */
id|cmPut
c_func
(paren
id|cp
comma
id|TRUE
)paren
suffix:semicolon
id|dxaddr
op_add_assign
id|nblks
suffix:semicolon
id|sxaddr
op_add_assign
id|nblks
suffix:semicolon
)brace
multiline_comment|/* get back parent page */
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
l_int|0
)paren
suffix:semicolon
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|pmp
comma
id|pp
comma
id|index
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtRelocate: target data extent relocated.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (xtype  == XTPAGE) */
multiline_comment|/*&n;&t;&t; * read in the target xtpage from the source extent;&n;&t;&t; */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|oxaddr
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * read in sibling pages if any to update sibling pointers;&n;&t;&t; */
id|rmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.next
)paren
(brace
id|nextbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|nextbn
comma
id|rmp
comma
id|PSIZE
comma
id|rp
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
id|lmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.prev
)paren
(brace
id|prevbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.prev
)paren
suffix:semicolon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|prevbn
comma
id|lmp
comma
id|PSIZE
comma
id|lp
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmp
)paren
id|XT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* at this point, all xtpages to be updated are in memory */
multiline_comment|/*&n;&t;&t; * update sibling pointers of sibling xtpages if any;&n;&t;&t; */
r_if
c_cond
(paren
id|lmp
)paren
(brace
id|BT_MARK_DIRTY
c_func
(paren
id|lmp
comma
id|ip
)paren
suffix:semicolon
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|lmp
comma
id|tlckXTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|lp-&gt;header.next
op_assign
id|cpu_to_le64
c_func
(paren
id|nxaddr
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|lmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rmp
)paren
(brace
id|BT_MARK_DIRTY
c_func
(paren
id|rmp
comma
id|ip
)paren
suffix:semicolon
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|rmp
comma
id|tlckXTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|rp-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|nxaddr
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * update the target xtpage to be relocated&n;&t;&t; *&n;&t;&t; * update the self address of the target page&n;&t;&t; * and write to destination extent;&n;&t;&t; * redo image covers the whole xtpage since it is new page&n;&t;&t; * to the destination extent;&n;&t;&t; * update of bmap for the free of source extent&n;&t;&t; * of the target xtpage itself:&n;&t;&t; * update of bmap for the allocation of destination extent&n;&t;&t; * of the target xtpage itself:&n;&t;&t; * update of bmap for the extents covered by xad entries in&n;&t;&t; * the target xtpage is not necessary since they are not&n;&t;&t; * updated;&n;&t;&t; * if not committed before this relocation,&n;&t;&t; * target page may contain XAD_NEW entries which must&n;&t;&t; * be scanned for bmap update (logredo() always&n;&t;&t; * scan xtpage REDOPAGE image for bmap update);&n;&t;&t; * if committed before this relocation (tlckRELOCATE),&n;&t;&t; * scan may be skipped by commit() and logredo();&n;&t;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/* tlckNEW init  xtlck-&gt;lwm.offset = XTENTRYSTART; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckNEW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* update the self address in the xtpage header */
id|pxd
op_assign
op_amp
id|p-&gt;header.self
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|nxaddr
)paren
suffix:semicolon
multiline_comment|/* linelock for the after image of the whole page */
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
multiline_comment|/* update the buffer extent descriptor of target xtpage */
id|xsize
op_assign
id|xlen
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
id|bmSetXD
c_func
(paren
id|mp
comma
id|nxaddr
comma
id|xsize
)paren
suffix:semicolon
multiline_comment|/* unpin the target page to new homeward bound */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtRelocate: target xtpage relocated.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      3. acquire maplock for the source extent to be freed;&n;&t; *&n;&t; * acquire a maplock saving the src relocated extent address;&n;&t; * to free of the extent at commit time;&n;&t; */
id|out
suffix:colon
multiline_comment|/* if DATAEXT relocation, write a LOG_UPDATEMAP record for&n;&t; * free PXD of the source data extent (logredo() will update&n;&t; * bmap for free of source data extent), and update bmap for&n;&t; * free of the source data extent;&n;&t; */
r_if
c_cond
(paren
id|xtype
op_eq
id|DATAEXT
)paren
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckMAP
)paren
suffix:semicolon
multiline_comment|/* if XTPAGE relocation, write a LOG_NOREDOPAGE record&n;&t; * for the source xtpage (logredo() will init NoRedoPage&n;&t; * filter and will also update bmap for free of the source&n;&t; * xtpage), and update bmap for free of the source xtpage;&n;&t; * N.B. We use tlckMAP instead of tlkcXTREE because there&n;&t; *      is no buffer associated with this lock since the buffer&n;&t; *      has been redirected to the target location.&n;&t; */
r_else
multiline_comment|/* (xtype  == XTPAGE) */
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckMAP
op_or
id|tlckRELOCATE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|oxaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|xlen
)paren
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *      4. update the parent xad entry for relocation;&n;&t; *&n;&t; * acquire tlck for the parent entry with XAD_NEW as entry&n;&t; * update which will write LOG_REDOPAGE and update bmap for&n;&t; * allocation of XAD_NEW destination extent;&n;&t; */
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;xtRelocate: update parent xad entry.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|pmp
comma
id|ip
)paren
suffix:semicolon
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|pmp
comma
id|tlckXTREE
op_or
id|tlckGROW
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* update the XAD with the new destination extent; */
id|xad
op_assign
op_amp
id|pp-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|xad-&gt;flag
op_or_assign
id|XAD_NEW
suffix:semicolon
id|XADaddress
c_func
(paren
id|xad
comma
id|nxaddr
)paren
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
id|min
c_func
(paren
id|index
comma
id|xtlck-&gt;lwm.offset
)paren
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|le16_to_cpu
c_func
(paren
id|pp-&gt;header.nextindex
)paren
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
multiline_comment|/* unpin the parent xtpage */
id|XT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtSearchNode()&n; *&n; * function:    search for the internal xad entry covering specified extent.&n; *              This function is mainly used by defragfs utility.&n; *&n; * parameters:&n; *      ip      - file object;&n; *      xad     - extent to find;&n; *      cmpp    - comparison result:&n; *      btstack - traverse stack;&n; *      flag    - search process flag;&n; *&n; * returns:&n; *      btstack contains (bn, index) of search path traversed to the entry.&n; *      *cmpp is set to result of comparison with the entry returned.&n; *      the page containing the entry is pinned at exit.&n; */
DECL|function|xtSearchNode
r_static
r_int
id|xtSearchNode
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|xad_t
op_star
id|xad
comma
multiline_comment|/* required XAD entry */
r_int
op_star
id|cmpp
comma
id|btstack_t
op_star
id|btstack
comma
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s64
id|xoff
comma
id|xaddr
suffix:semicolon
r_int
id|xlen
suffix:semicolon
r_int
id|cmp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* init for empty page */
id|s64
id|bn
suffix:semicolon
multiline_comment|/* block number */
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|xtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* page */
r_int
id|base
comma
id|index
comma
id|lim
suffix:semicolon
id|btframe_t
op_star
id|btsp
suffix:semicolon
id|s64
id|t64
suffix:semicolon
id|BT_CLR
c_func
(paren
id|btstack
)paren
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      search down tree from root:&n;&t; *&n;&t; * between two consecutive entries of &lt;Ki, Pi&gt; and &lt;Kj, Pj&gt; of&n;&t; * internal page, child page Pi contains entry with k, Ki &lt;= K &lt; Kj.&n;&t; *&n;&t; * if entry with search key K is not found&n;&t; * internal page search find the entry with largest key Ki&n;&t; * less than K which point to the child page to search;&n;&t; * leaf page search find the entry with smallest key Kj&n;&t; * greater than K so that the returned index is the position of&n;&t; * the entry to be shifted right for insertion of new entry.&n;&t; * for empty tree, search key is greater than any key of the tree.&n;&t; *&n;&t; * by convention, root bn = 0.&n;&t; */
r_for
c_loop
(paren
id|bn
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* get/pin the page to search */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
r_return
id|ESTALE
suffix:semicolon
id|lim
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|XTENTRYSTART
suffix:semicolon
multiline_comment|/*&n;&t;&t; * binary search with search key K on the current page&n;&t;&t; */
r_for
c_loop
(paren
id|base
op_assign
id|XTENTRYSTART
suffix:semicolon
id|lim
suffix:semicolon
id|lim
op_rshift_assign
l_int|1
)paren
(brace
id|index
op_assign
id|base
op_plus
(paren
id|lim
op_rshift
l_int|1
)paren
suffix:semicolon
id|XT_CMP
c_func
(paren
id|cmp
comma
id|xoff
comma
op_amp
id|p-&gt;xad
(braket
id|index
)braket
comma
id|t64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *      search hit&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * verify for exact match;&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|xaddr
op_eq
id|addressXAD
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
)paren
op_logical_and
id|xoff
op_eq
id|offsetXAD
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
)paren
)paren
(brace
op_star
id|cmpp
op_assign
id|cmp
suffix:semicolon
multiline_comment|/* save search result */
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|index
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* descend/search its child page */
r_goto
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
(brace
id|base
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
op_decrement
id|lim
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *      search miss - non-leaf page:&n;&t;&t; *&n;&t;&t; * base is the smallest index with key (Kj) greater than&n;&t;&t; * search key (K) and may be zero or maxentry index.&n;&t;&t; * if base is non-zero, decrement base by one to get the parent&n;&t;&t; * entry of the child page to search.&n;&t;&t; */
id|index
op_assign
id|base
ques
c_cond
id|base
op_minus
l_int|1
suffix:colon
id|base
suffix:semicolon
multiline_comment|/*&n;&t;&t; * go down to child page&n;&t;&t; */
id|next
suffix:colon
multiline_comment|/* get the child page block number */
id|bn
op_assign
id|addressXAD
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
)paren
suffix:semicolon
multiline_comment|/* unpin the parent page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      xtRelink()&n; *&n; * function:&n; *      link around a freed page.&n; *&n; * Parameter:&n; *      int           tid,&n; *      struct inode    *ip,&n; *      xtpage_t        *p)&n; *&n; * returns:&n; */
DECL|function|xtRelink
r_static
r_int
id|xtRelink
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|xtpage_t
op_star
id|p
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|s64
id|nextbn
comma
id|prevbn
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|nextbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
id|prevbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.prev
)paren
suffix:semicolon
multiline_comment|/* update prev pointer of the next page */
r_if
c_cond
(paren
id|nextbn
op_ne
l_int|0
)paren
(brace
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|nextbn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the page;&n;&t;&t; *&n;&t;&t; * action: update prev pointer;&n;&t;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
multiline_comment|/* the page may already have been tlock&squot;d */
id|p-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|prevbn
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* update next pointer of the previous page */
r_if
c_cond
(paren
id|prevbn
op_ne
l_int|0
)paren
(brace
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|prevbn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the page;&n;&t;&t; *&n;&t;&t; * action: update next pointer;&n;&t;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
multiline_comment|/* the page may already have been tlock&squot;d */
id|p-&gt;header.next
op_assign
id|le64_to_cpu
c_func
(paren
id|nextbn
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
multiline_comment|/*&n; *      xtInitRoot()&n; *&n; * initialize file root (inline in inode)&n; */
DECL|function|xtInitRoot
r_void
id|xtInitRoot
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
id|xtpage_t
op_star
id|p
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the root&n;&t; *&n;&t; * action:&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
(paren
id|metapage_t
op_star
)paren
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|bxflag
comma
id|tlckXTREE
op_or
id|tlckNEW
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|i_xtroot
suffix:semicolon
id|p-&gt;header.flag
op_assign
id|DXD_INDEX
op_or
id|BT_ROOT
op_or
id|BT_LEAF
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
id|p-&gt;header.maxentry
op_assign
id|cpu_to_le16
c_func
(paren
id|XTROOTINITSLOT_DIR
)paren
suffix:semicolon
r_else
(brace
id|p-&gt;header.maxentry
op_assign
id|cpu_to_le16
c_func
(paren
id|XTROOTINITSLOT
)paren
suffix:semicolon
id|ip-&gt;i_size
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * We can run into a deadlock truncating a file with a large number of&n; * xtree pages (large fragmented file).  A robust fix would entail a&n; * reservation system where we would reserve a number of metadata pages&n; * and tlocks which we would be guaranteed without a deadlock.  Without&n; * this, a partial fix is to limit number of metadata pages we will lock&n; * in a single transaction.  Currently we will truncate the file so that&n; * no more than 50 leaf pages will be locked.  The caller of xtTruncate&n; * will be responsible for ensuring that the current transaction gets&n; * committed, and that subsequent transactions are created to truncate&n; * the file further if needed.&n; */
DECL|macro|MAX_TRUNCATE_LEAVES
mdefine_line|#define MAX_TRUNCATE_LEAVES 50
multiline_comment|/*&n; *      xtTruncate()&n; *&n; * function:&n; *      traverse for truncation logging backward bottom up;&n; *      terminate at the last extent entry at the current subtree&n; *      root page covering new down size.&n; *      truncation may occur within the last extent entry.&n; *&n; * parameter:&n; *      int           tid,&n; *      struct inode    *ip,&n; *      s64           newsize,&n; *      int           type)   {PWMAP, PMAP, WMAP; DELETE, TRUNCATE}&n; *&n; * return:&n; *&n; * note:&n; *      PWMAP:&n; *       1. truncate (non-COMMIT_NOLINK file)&n; *          by jfs_truncate() or jfs_open(O_TRUNC):&n; *          xtree is updated;&n; *&t; 2. truncate index table of directory when last entry removed&n; *       map update via tlock at commit time;&n; *      PMAP:&n; *&t; Call xtTruncate_pmap instead&n; *      WMAP:&n; *       1. remove (free zero link count) on last reference release&n; *          (pmap has been freed at commit zero link count);&n; *       2. truncate (COMMIT_NOLINK file, i.e., tmp file):&n; *          xtree is updated;&n; *       map update directly at truncation time;&n; *&n; *      if (DELETE)&n; *              no LOG_NOREDOPAGE is required (NOREDOFILE is sufficient);&n; *      else if (TRUNCATE)&n; *              must write LOG_NOREDOPAGE for deleted index page;&n; *&n; * pages may already have been tlocked by anonymous transactions&n; * during file growth (i.e., write) before truncation;&n; *&n; * except last truncated entry, deleted entries remains as is&n; * in the page (nextindex is updated) for other use&n; * (e.g., log/update allocation map): this avoid copying the page&n; * info but delay free of pages;&n; *&n; */
DECL|function|xtTruncate
id|s64
id|xtTruncate
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|newsize
comma
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s64
id|teof
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
id|s64
id|bn
suffix:semicolon
r_int
id|index
comma
id|nextindex
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|s64
id|xoff
comma
id|xaddr
suffix:semicolon
r_int
id|xlen
comma
id|len
comma
id|freexlen
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
id|btframe_t
op_star
id|parent
suffix:semicolon
id|tblock_t
op_star
id|tblk
op_assign
l_int|0
suffix:semicolon
id|tlock_t
op_star
id|tlck
op_assign
l_int|0
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
op_assign
l_int|0
suffix:semicolon
id|xdlistlock_t
id|xadlock
suffix:semicolon
multiline_comment|/* maplock for COMMIT_WMAP */
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
multiline_comment|/* maplock for COMMIT_WMAP */
id|s64
id|nfreed
suffix:semicolon
r_int
id|freed
comma
id|log
suffix:semicolon
r_int
id|locked_leaves
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* save object truncation type */
r_if
c_cond
(paren
id|tid
)paren
(brace
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
id|tblk-&gt;xflag
op_or_assign
id|flag
suffix:semicolon
)brace
id|nfreed
op_assign
l_int|0
suffix:semicolon
id|flag
op_and_assign
id|COMMIT_MAP
suffix:semicolon
m_assert
(paren
id|flag
op_ne
id|COMMIT_PMAP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
id|COMMIT_PWMAP
)paren
id|log
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|log
op_assign
l_int|0
suffix:semicolon
id|xadlock.flag
op_assign
id|mlckFREEXADLIST
suffix:semicolon
id|xadlock.index
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if the newsize is not an integral number of pages,&n;&t; * the file between newsize and next page boundary will&n;&t; * be cleared.&n;&t; * if truncating into a file hole, it will cause&n;&t; * a full block to be allocated for the logical block.&n;&t; */
multiline_comment|/*&n;&t; * release page blocks of truncated region &lt;teof, eof&gt;&n;&t; *&n;&t; * free the data blocks from the leaf index blocks.&n;&t; * delete the parent index entries corresponding to&n;&t; * the freed child data/index blocks.&n;&t; * free the index blocks themselves which aren&squot;t needed&n;&t; * in new sized file.&n;&t; *&n;&t; * index blocks are updated only if the blocks are to be&n;&t; * retained in the new sized file.&n;&t; * if type is PMAP, the data and index pages are NOT&n;&t; * freed, and the data and index blocks are NOT freed&n;&t; * from  working map.&n;&t; * (this will allow continued access of data/index of&n;&t; * temporary file (zerolink count file truncated to zero-length)).&n;&t; */
id|teof
op_assign
(paren
id|newsize
op_plus
(paren
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bsize
op_minus
l_int|1
)paren
)paren
op_rshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
multiline_comment|/* clear stack */
id|BT_CLR
c_func
(paren
op_amp
id|btstack
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * start with root&n;&t; *&n;&t; * root resides in the inode&n;&t; */
id|bn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each page:&n;&t; */
id|getPage
suffix:colon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
op_minus
id|rc
suffix:semicolon
multiline_comment|/* process entries backward from last index */
id|index
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_INTERNAL
)paren
r_goto
id|getChild
suffix:semicolon
multiline_comment|/*&n;&t; *      leaf page&n;&t; */
multiline_comment|/* Since this is the rightmost leaf, and we may have already freed&n;&t; * a page that was formerly to the right, let&squot;s make sure that the&n;&t; * next pointer is zero.&n;&t; */
id|p-&gt;header.next
op_assign
l_int|0
suffix:semicolon
id|freed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* does region covered by leaf page precede Teof ? */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
r_if
c_cond
(paren
id|teof
op_ge
id|xoff
op_plus
id|xlen
)paren
(brace
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|getParent
suffix:semicolon
)brace
multiline_comment|/* (re)acquire tlock of the leaf page */
r_if
c_cond
(paren
id|log
)paren
(brace
r_if
c_cond
(paren
op_increment
id|locked_leaves
OG
id|MAX_TRUNCATE_LEAVES
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We need to limit the size of the transaction&n;&t;&t;&t; * to avoid exhausting pagecache &amp; tlocks&n;&t;&t;&t; */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|newsize
op_assign
(paren
id|xoff
op_plus
id|xlen
)paren
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
r_goto
id|getParent
suffix:semicolon
)brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
)paren
suffix:semicolon
id|tlck-&gt;type
op_assign
id|tlckXTREE
op_or
id|tlckTRUNCATE
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;hwm.offset
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * scan backward leaf page entries&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|index
op_ge
id|XTENTRYSTART
suffix:semicolon
id|index
op_decrement
)paren
(brace
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * entry beyond eof: continue scan of current page&n;&t;&t; *          xad&n;&t;&t; * ---|---=======-------&gt;&n;&t;&t; *   eof&n;&t;&t; */
r_if
c_cond
(paren
id|teof
OL
id|xoff
)paren
(brace
id|nfreed
op_add_assign
id|xlen
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * (xoff &lt;= teof): last entry to be deleted from page;&n;&t;&t; * If other entries remain in page: keep and update the page.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * eof == entry_start: delete the entry&n;&t;&t; *           xad&n;&t;&t; * -------|=======-------&gt;&n;&t;&t; *       eof&n;&t;&t; *&n;&t;&t; */
r_if
c_cond
(paren
id|teof
op_eq
id|xoff
)paren
(brace
id|nfreed
op_add_assign
id|xlen
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|XTENTRYSTART
)paren
r_break
suffix:semicolon
id|nextindex
op_assign
id|index
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * eof within the entry: truncate the entry.&n;&t;&t; *          xad&n;&t;&t; * -------===|===-------&gt;&n;&t;&t; *          eof&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|teof
OL
id|xoff
op_plus
id|xlen
)paren
(brace
multiline_comment|/* update truncated entry */
id|len
op_assign
id|teof
op_minus
id|xoff
suffix:semicolon
id|freexlen
op_assign
id|xlen
op_minus
id|len
suffix:semicolon
id|XADlength
c_func
(paren
id|xad
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* save pxd of truncated extent in tlck */
id|xaddr
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|log
)paren
(brace
multiline_comment|/* COMMIT_PWMAP */
id|xtlck-&gt;lwm.offset
op_assign
(paren
id|xtlck-&gt;lwm.offset
)paren
ques
c_cond
id|min
c_func
(paren
id|index
comma
(paren
r_int
)paren
id|xtlck-&gt;lwm.offset
)paren
suffix:colon
id|index
suffix:semicolon
id|xtlck-&gt;lwm.length
op_assign
id|index
op_plus
l_int|1
op_minus
id|xtlck-&gt;lwm.offset
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|xtlck-&gt;pxdlock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|xaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|freexlen
)paren
suffix:semicolon
)brace
multiline_comment|/* free truncated extent */
r_else
(brace
multiline_comment|/* COMMIT_WMAP */
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|xadlock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|xaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|freexlen
)paren
suffix:semicolon
id|txFreeMap
c_func
(paren
id|ip
comma
id|pxdlock
comma
l_int|0
comma
id|COMMIT_WMAP
)paren
suffix:semicolon
multiline_comment|/* reset map lock */
id|xadlock.flag
op_assign
id|mlckFREEXADLIST
suffix:semicolon
)brace
multiline_comment|/* current entry is new last entry; */
id|nextindex
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|nfreed
op_add_assign
id|freexlen
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * eof beyond the entry:&n;&t;&t; *          xad&n;&t;&t; * -------=======---|---&gt;&n;&t;&t; *                 eof&n;&t;&t; */
r_else
(brace
multiline_comment|/* (xoff + xlen &lt; teof) */
id|nextindex
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nextindex
OL
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|log
)paren
(brace
multiline_comment|/* COMMIT_WAMP */
id|xadlock.xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|nextindex
)braket
suffix:semicolon
id|xadlock.count
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|nextindex
suffix:semicolon
id|txFreeMap
c_func
(paren
id|ip
comma
(paren
id|maplock_t
op_star
)paren
op_amp
id|xadlock
comma
l_int|0
comma
id|COMMIT_WMAP
)paren
suffix:semicolon
)brace
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|nextindex
)paren
suffix:semicolon
)brace
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* assert(freed == 0); */
r_goto
id|getParent
suffix:semicolon
)brace
multiline_comment|/* end scan of leaf page entries */
id|freed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * leaf page become empty: free the page if type != PMAP&n;&t; */
r_if
c_cond
(paren
id|log
)paren
(brace
multiline_comment|/* COMMIT_PWMAP */
multiline_comment|/* txCommit() with tlckFREE:&n;&t;&t; * free data extents covered by leaf [XTENTRYSTART:hwm);&n;&t;&t; * invalidate leaf if COMMIT_PWMAP;&n;&t;&t; * if (TRUNCATE), will write LOG_NOREDOPAGE;&n;&t;&t; */
id|tlck-&gt;type
op_assign
id|tlckXTREE
op_or
id|tlckFREE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* COMMIT_WAMP */
multiline_comment|/* free data extents covered by leaf */
id|xadlock.xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|xadlock.count
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|XTENTRYSTART
suffix:semicolon
id|txFreeMap
c_func
(paren
id|ip
comma
(paren
id|maplock_t
op_star
)paren
op_amp
id|xadlock
comma
l_int|0
comma
id|COMMIT_WMAP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
id|p-&gt;header.flag
op_and_assign
op_complement
id|BT_INTERNAL
suffix:semicolon
id|p-&gt;header.flag
op_or_assign
id|BT_LEAF
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* debug */
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|log
)paren
(brace
multiline_comment|/* COMMIT_PWMAP */
multiline_comment|/* page will be invalidated at tx completion&n;&t;&t;&t; */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* COMMIT_WMAP */
r_if
c_cond
(paren
id|mp-&gt;lid
)paren
id|lid_to_tlock
c_func
(paren
id|mp-&gt;lid
)paren
op_member_access_from_pointer
id|flag
op_or_assign
id|tlckFREELOCK
suffix:semicolon
multiline_comment|/* invalidate empty leaf page */
id|discard_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * the leaf page become empty: delete the parent entry&n;&t; * for the leaf page if the parent page is to be kept&n;&t; * in the new sized file.&n;&t; */
multiline_comment|/*&n;&t; * go back up to the parent page&n;&t; */
id|getParent
suffix:colon
multiline_comment|/* pop/restore parent entry for the current child page */
r_if
c_cond
(paren
(paren
id|parent
op_assign
id|BT_POP
c_func
(paren
op_amp
id|btstack
)paren
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* current page must have been root */
r_goto
id|out
suffix:semicolon
multiline_comment|/* get back the parent page */
id|bn
op_assign
id|parent-&gt;bn
suffix:semicolon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
op_minus
id|rc
suffix:semicolon
id|index
op_assign
id|parent-&gt;index
suffix:semicolon
multiline_comment|/*&n;&t; * child page was not empty:&n;&t; */
r_if
c_cond
(paren
id|freed
op_eq
l_int|0
)paren
(brace
multiline_comment|/* has any entry deleted from parent ? */
r_if
c_cond
(paren
id|index
OL
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
)paren
(brace
multiline_comment|/* (re)acquire tlock on the parent page */
r_if
c_cond
(paren
id|log
)paren
(brace
multiline_comment|/* COMMIT_PWMAP */
multiline_comment|/* txCommit() with tlckTRUNCATE:&n;&t;&t;&t;&t; * free child extents covered by parent [);&n;&t;&t;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;twm.offset
op_assign
id|index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tlck-&gt;type
op_amp
id|tlckTRUNCATE
)paren
)paren
(brace
id|xtlck-&gt;hwm.offset
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header
dot
id|nextindex
)paren
op_minus
l_int|1
suffix:semicolon
id|tlck-&gt;type
op_assign
id|tlckXTREE
op_or
id|tlckTRUNCATE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* COMMIT_WMAP */
multiline_comment|/* free child extents covered by parent */
id|xadlock.xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
op_plus
l_int|1
)braket
suffix:semicolon
id|xadlock.count
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|index
op_minus
l_int|1
suffix:semicolon
id|txFreeMap
c_func
(paren
id|ip
comma
(paren
id|maplock_t
op_star
)paren
op_amp
id|xadlock
comma
l_int|0
comma
id|COMMIT_WMAP
)paren
suffix:semicolon
)brace
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|index
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|getParent
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * child page was empty:&n;&t; */
id|nfreed
op_add_assign
id|lengthXAD
c_func
(paren
op_amp
id|p-&gt;xad
(braket
id|index
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * During working map update, child page&squot;s tlock must be handled&n;&t; * before parent&squot;s.  This is because the parent&squot;s tlock will cause&n;&t; * the child&squot;s disk space to be marked available in the wmap, so&n;&t; * it&squot;s important that the child page be released by that time.&n;&t; *&n;&t; * ToDo:  tlocks should be on doubly-linked list, so we can&n;&t; * quickly remove it and add it to the end.&n;&t; */
multiline_comment|/*&n;&t; * Move parent page&squot;s tlock to the end of the tid&squot;s tlock list&n;&t; */
r_if
c_cond
(paren
id|log
op_logical_and
id|mp-&gt;lid
op_logical_and
(paren
id|tblk-&gt;last
op_ne
id|mp-&gt;lid
)paren
op_logical_and
id|lid_to_tlock
c_func
(paren
id|mp-&gt;lid
)paren
op_member_access_from_pointer
id|tid
)paren
(brace
id|lid_t
id|lid
op_assign
id|mp-&gt;lid
suffix:semicolon
id|tlock_t
op_star
id|prev
suffix:semicolon
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;next
op_eq
id|lid
)paren
id|tblk-&gt;next
op_assign
id|tlck-&gt;next
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|prev
op_assign
id|lid_to_tlock
c_func
(paren
id|tblk-&gt;next
)paren
suffix:semicolon
id|prev-&gt;next
op_ne
id|lid
suffix:semicolon
id|prev
op_assign
id|lid_to_tlock
c_func
(paren
id|prev-&gt;next
)paren
)paren
(brace
m_assert
(paren
id|prev-&gt;next
)paren
suffix:semicolon
)brace
id|prev-&gt;next
op_assign
id|tlck-&gt;next
suffix:semicolon
)brace
id|lid_to_tlock
c_func
(paren
id|tblk-&gt;last
)paren
op_member_access_from_pointer
id|next
op_assign
id|lid
suffix:semicolon
id|tlck-&gt;next
op_assign
l_int|0
suffix:semicolon
id|tblk-&gt;last
op_assign
id|lid
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * parent page become empty: free the page&n;&t; */
r_if
c_cond
(paren
id|index
op_eq
id|XTENTRYSTART
)paren
(brace
r_if
c_cond
(paren
id|log
)paren
(brace
multiline_comment|/* COMMIT_PWMAP */
multiline_comment|/* txCommit() with tlckFREE:&n;&t;&t;&t; * free child extents covered by parent;&n;&t;&t;&t; * invalidate parent if COMMIT_PWMAP;&n;&t;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;twm.offset
op_assign
id|index
suffix:semicolon
id|xtlck-&gt;hwm.offset
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
suffix:semicolon
id|tlck-&gt;type
op_assign
id|tlckXTREE
op_or
id|tlckFREE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* COMMIT_WMAP */
multiline_comment|/* free child extents covered by parent */
id|xadlock.xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
id|xadlock.count
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
id|XTENTRYSTART
suffix:semicolon
id|txFreeMap
c_func
(paren
id|ip
comma
(paren
id|maplock_t
op_star
)paren
op_amp
id|xadlock
comma
l_int|0
comma
id|COMMIT_WMAP
)paren
suffix:semicolon
)brace
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
id|p-&gt;header.flag
op_and_assign
op_complement
id|BT_INTERNAL
suffix:semicolon
id|p-&gt;header.flag
op_or_assign
id|BT_LEAF
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
id|cpu_to_le16
c_func
(paren
id|XTENTRYSTART
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.maxentry
)paren
op_eq
id|XTROOTMAXSLOT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Shrink root down to allow inline&n;&t;&t;&t;&t; * EA (otherwise fsck complains)&n;&t;&t;&t;&t; */
id|p-&gt;header.maxentry
op_assign
id|cpu_to_le16
c_func
(paren
id|XTROOTINITSLOT
)paren
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|mode2
op_or_assign
id|INLINEEA
suffix:semicolon
)brace
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* debug */
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|log
)paren
(brace
multiline_comment|/* COMMIT_PWMAP */
multiline_comment|/* page will be invalidated at tx completion&n;&t;&t;&t;&t; */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* COMMIT_WMAP */
r_if
c_cond
(paren
id|mp-&gt;lid
)paren
id|lid_to_tlock
c_func
(paren
id|mp-&gt;lid
)paren
op_member_access_from_pointer
id|flag
op_or_assign
id|tlckFREELOCK
suffix:semicolon
multiline_comment|/* invalidate parent page */
id|discard_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* parent has become empty and freed:&n;&t;&t;&t; * go back up to its parent page&n;&t;&t;&t; */
multiline_comment|/* freed = 1; */
r_goto
id|getParent
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * parent page still has entries for front region;&n;&t; */
r_else
(brace
multiline_comment|/* try truncate region covered by preceding entry&n;&t;&t; * (process backward)&n;&t;&t; */
id|index
op_decrement
suffix:semicolon
multiline_comment|/* go back down to the child page corresponding&n;&t;&t; * to the entry&n;&t;&t; */
r_goto
id|getChild
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      internal page: go down to child page of current entry&n;&t; */
id|getChild
suffix:colon
multiline_comment|/* save current parent entry for the child page */
id|BT_PUSH
c_func
(paren
op_amp
id|btstack
comma
id|bn
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* get child page */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|bn
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each internal entry:&n;&t; */
multiline_comment|/* release parent page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* process the child page */
r_goto
id|getPage
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * update file resource stat&n;&t; */
multiline_comment|/* set size&n;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|newsize
)paren
id|ip-&gt;i_size
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* fsck hates zero-length directories */
r_else
id|ip-&gt;i_size
op_assign
id|newsize
suffix:semicolon
multiline_comment|/* update nblocks to reflect freed blocks */
id|ip-&gt;i_blocks
op_sub_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|nfreed
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free tlock of invalidated pages&n;&t; */
r_if
c_cond
(paren
id|flag
op_eq
id|COMMIT_WMAP
)paren
id|txFreelock
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
id|newsize
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtTruncate_pmap()&n; *&n; * function:&n; *&t;Perform truncate to zero lenghth for deleted file, leaving the&n; *&t;the xtree and working map untouched.  This allows the file to&n; *&t;be accessed via open file handles, while the delete of the file&n; *&t;is committed to disk.&n; *&n; * parameter:&n; *      tid_t&t;&t;tid,&n; *      struct inode&t;*ip,&n; *      s64&t;&t;committed_size)&n; *&n; * return: new committed size&n; *&n; * note:&n; *&n; *&t;To avoid deadlock by holding too many transaction locks, the&n; *&t;truncation may be broken up into multiple transactions.&n; *&t;The committed_size keeps track of part of the file has been&n; *&t;freed from the pmaps.&n; */
DECL|function|xtTruncate_pmap
id|s64
id|xtTruncate_pmap
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|committed_size
)paren
(brace
id|s64
id|bn
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|locked_leaves
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
id|btframe_t
op_star
id|parent
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|tlock_t
op_star
id|tlck
op_assign
l_int|0
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
r_int
id|xlen
suffix:semicolon
id|s64
id|xoff
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* save object truncation type */
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
id|tblk-&gt;xflag
op_or_assign
id|COMMIT_PMAP
suffix:semicolon
multiline_comment|/* clear stack */
id|BT_CLR
c_func
(paren
op_amp
id|btstack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|committed_size
)paren
(brace
id|xoff
op_assign
(paren
id|committed_size
op_rshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
)paren
op_minus
l_int|1
suffix:semicolon
id|rc
op_assign
id|xtSearch
c_func
(paren
id|ip
comma
id|xoff
comma
op_amp
id|cmp
comma
op_amp
id|btstack
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
op_minus
id|rc
suffix:semicolon
m_assert
(paren
id|cmp
op_eq
l_int|0
)paren
suffix:semicolon
id|XT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * start with root&n;&t;&t; *&n;&t;&t; * root resides in the inode&n;&t;&t; */
id|bn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * first access of each page:&n;&t;&t; */
id|getPage
suffix:colon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
op_minus
id|rc
suffix:semicolon
multiline_comment|/* process entries backward from last index */
id|index
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_INTERNAL
)paren
r_goto
id|getChild
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      leaf page&n;&t; */
r_if
c_cond
(paren
op_increment
id|locked_leaves
OG
id|MAX_TRUNCATE_LEAVES
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need to limit the size of the transaction&n;&t;&t; * to avoid exhausting pagecache &amp; tlocks&n;&t;&t; */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|xoff
op_plus
id|xlen
)paren
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
)brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
)paren
suffix:semicolon
id|tlck-&gt;type
op_assign
id|tlckXTREE
op_or
id|tlckTRUNCATE
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;hwm.offset
op_assign
id|index
suffix:semicolon
id|tlck-&gt;type
op_assign
id|tlckXTREE
op_or
id|tlckFREE
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * go back up to the parent page&n;&t; */
id|getParent
suffix:colon
multiline_comment|/* pop/restore parent entry for the current child page */
r_if
c_cond
(paren
(paren
id|parent
op_assign
id|BT_POP
c_func
(paren
op_amp
id|btstack
)paren
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* current page must have been root */
r_goto
id|out
suffix:semicolon
multiline_comment|/* get back the parent page */
id|bn
op_assign
id|parent-&gt;bn
suffix:semicolon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
op_minus
id|rc
suffix:semicolon
id|index
op_assign
id|parent-&gt;index
suffix:semicolon
multiline_comment|/*&n;&t; * parent page become empty: free the page&n;&t; */
r_if
c_cond
(paren
id|index
op_eq
id|XTENTRYSTART
)paren
(brace
multiline_comment|/* txCommit() with tlckFREE:&n;&t;&t; * free child extents covered by parent;&n;&t;&t; * invalidate parent if COMMIT_PWMAP;&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckXTREE
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xtlck-&gt;twm.offset
op_assign
id|index
suffix:semicolon
id|xtlck-&gt;hwm.offset
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
suffix:semicolon
id|tlck-&gt;type
op_assign
id|tlckXTREE
op_or
id|tlckFREE
suffix:semicolon
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
r_goto
id|getParent
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * parent page still has entries for front region;&n;&t; */
r_else
id|index
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; *      internal page: go down to child page of current entry&n;&t; */
id|getChild
suffix:colon
multiline_comment|/* save current parent entry for the child page */
id|BT_PUSH
c_func
(paren
op_amp
id|btstack
comma
id|bn
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* get child page */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|bn
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each internal entry:&n;&t; */
multiline_comment|/* release parent page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* process the child page */
r_goto
id|getPage
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef _JFS_DEBUG_XTREE
multiline_comment|/*&n; *      xtDisplayTree()&n; *&n; * function: traverse forward&n; */
DECL|function|xtDisplayTree
r_int
id|xtDisplayTree
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
id|s64
id|bn
comma
id|pbn
suffix:semicolon
r_int
id|index
comma
id|lastindex
comma
id|v
comma
id|h
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
id|btframe_t
op_star
id|btsp
suffix:semicolon
id|btframe_t
op_star
id|parent
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;display B+-tree.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* clear stack */
id|btsp
op_assign
id|btstack.stack
suffix:semicolon
multiline_comment|/*&n;&t; * start with root&n;&t; *&n;&t; * root resides in the inode&n;&t; */
id|bn
op_assign
l_int|0
suffix:semicolon
id|v
op_assign
id|h
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each page:&n;&t; */
id|getPage
suffix:colon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* process entries forward from first index */
id|index
op_assign
id|XTENTRYSTART
suffix:semicolon
id|lastindex
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_INTERNAL
)paren
(brace
multiline_comment|/*&n;&t;&t; * first access of each internal page&n;&t;&t; */
r_goto
id|getChild
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (p-&gt;header.flag &amp; BT_LEAF) */
multiline_comment|/*&n;&t;&t; * first access of each leaf page&n;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;leaf page &quot;
)paren
suffix:semicolon
id|xtDisplayPage
c_func
(paren
id|ip
comma
id|bn
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * go back up to the parent page&n;&t; */
id|getParent
suffix:colon
multiline_comment|/* pop/restore parent entry for the current child page */
r_if
c_cond
(paren
(paren
id|parent
op_assign
(paren
id|btsp
op_eq
id|btstack.stack
ques
c_cond
l_int|NULL
suffix:colon
op_decrement
id|btsp
)paren
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* current page must have been root */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * parent page scan completed&n;&t; */
r_if
c_cond
(paren
(paren
id|index
op_assign
id|parent-&gt;index
)paren
op_eq
(paren
id|lastindex
op_assign
id|parent-&gt;lastindex
)paren
)paren
(brace
multiline_comment|/* go back up to the parent page */
r_goto
id|getParent
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * parent page has entries remaining&n;&t; */
multiline_comment|/* get back the parent page */
id|bn
op_assign
id|parent-&gt;bn
suffix:semicolon
multiline_comment|/* v = parent-&gt;level; */
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* get next parent entry */
id|index
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * internal page: go down to child page of current entry&n;&t; */
id|getChild
suffix:colon
multiline_comment|/* push/save current parent entry for the child page */
id|btsp-&gt;bn
op_assign
id|pbn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|index
suffix:semicolon
id|btsp-&gt;lastindex
op_assign
id|lastindex
suffix:semicolon
multiline_comment|/* btsp-&gt;level = v; */
multiline_comment|/* btsp-&gt;node = h; */
op_increment
id|btsp
suffix:semicolon
multiline_comment|/* get child page */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
id|bn
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each internal entry:&n;&t; */
multiline_comment|/* release parent page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;traverse down 0x%lx[%d]-&gt;0x%lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|pbn
comma
id|index
comma
(paren
id|ulong
)paren
id|bn
)paren
suffix:semicolon
id|v
op_increment
suffix:semicolon
id|h
op_assign
id|index
suffix:semicolon
multiline_comment|/* process the child page */
r_goto
id|getPage
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtDisplayPage()&n; *&n; * function: display page&n; */
DECL|function|xtDisplayPage
r_int
id|xtDisplayPage
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|bn
comma
id|xtpage_t
op_star
id|p
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|s64
id|xaddr
comma
id|xoff
suffix:semicolon
r_int
id|xlen
comma
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* display page control */
id|printf
c_func
(paren
l_string|&quot;bn:0x%lx flag:0x%x nextindex:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|bn
comma
id|p-&gt;header.flag
comma
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
)paren
suffix:semicolon
multiline_comment|/* display entries */
id|xad
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|XTENTRYSTART
comma
id|j
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
id|i
op_increment
comma
id|xad
op_increment
comma
id|j
op_increment
)paren
(brace
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t[%d] 0x%lx:0x%lx(0x%x)&quot;
comma
id|i
comma
(paren
id|ulong
)paren
id|xoff
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_DEBUG_XTREE */
macro_line|#ifdef _JFS_WIP
multiline_comment|/*&n; *      xtGather()&n; *&n; * function:&n; *      traverse for allocation acquiring tlock at commit time&n; *      (vs at the time of update) logging backward top down&n; *&n; * note:&n; *      problem - establishing that all new allocation have been&n; *      processed both for append and random write in sparse file&n; *      at the current entry at the current subtree root page&n; *&n; */
DECL|function|xtGather
r_int
id|xtGather
c_func
(paren
id|t
)paren
id|btree_t
op_star
id|t
suffix:semicolon
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
id|u64
id|bn
suffix:semicolon
r_int
id|index
suffix:semicolon
id|btentry_t
op_star
id|e
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
r_struct
id|btsf
op_star
id|parent
suffix:semicolon
multiline_comment|/* clear stack */
id|BT_CLR
c_func
(paren
op_amp
id|btstack
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * start with root&n;&t; *&n;&t; * root resides in the inode&n;&t; */
id|bn
op_assign
l_int|0
suffix:semicolon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* new root is NOT pointed by a new entry&n;&t;   if (p-&gt;header.flag &amp; NEW)&n;&t;   allocate new page lock;&n;&t;   write a NEWPAGE log;&n;&t; */
id|dopage
suffix:colon
multiline_comment|/*&n;&t; * first access of each page:&n;&t; */
multiline_comment|/* process entries backward from last index */
id|index
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
multiline_comment|/*&n;&t;&t; * first access of each leaf page&n;&t;&t; */
multiline_comment|/* process leaf page entries backward */
r_for
c_loop
(paren
suffix:semicolon
id|index
op_ge
id|XTENTRYSTART
suffix:semicolon
id|index
op_decrement
)paren
(brace
id|e
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * if newpage, log NEWPAGE.&n;&t;&t;&t; *&n;&t;&t;&t; if (e-&gt;flag &amp; XAD_NEW) {&n;&t;&t;&t; nfound =+ entry-&gt;length;&n;&t;&t;&t; update current page lock for the entry;&n;&t;&t;&t; newpage(entry);&n;&t;&t;&t; *&n;&t;&t;&t; * if moved, log move.&n;&t;&t;&t; *&n;&t;&t;&t; } else if (e-&gt;flag &amp; XAD_MOVED) {&n;&t;&t;&t; reset flag;&n;&t;&t;&t; update current page lock for the entry;&n;&t;&t;&t; }&n;&t;&t;&t; */
)brace
multiline_comment|/* unpin the leaf page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * go back up to the parent page&n;&t;&t; */
id|getParent
suffix:colon
multiline_comment|/* restore parent entry for the current child page */
r_if
c_cond
(paren
(paren
id|parent
op_assign
id|BT_POP
c_func
(paren
op_amp
id|btstack
)paren
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* current page must have been root */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_assign
id|parent-&gt;index
)paren
op_eq
id|XTENTRYSTART
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * parent page scan completed&n;&t;&t;&t; */
multiline_comment|/* go back up to the parent page */
r_goto
id|getParent
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * parent page has entries remaining&n;&t;&t;&t; */
multiline_comment|/* get back the parent page */
id|bn
op_assign
id|parent-&gt;bn
suffix:semicolon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|EIO
suffix:semicolon
multiline_comment|/* first subroot page which&n;&t;&t;&t; * covers all new allocated blocks&n;&t;&t;&t; * itself not new/modified.&n;&t;&t;&t; * (if modified from split of descendent,&n;&t;&t;&t; * go down path of split page)&n;&n;&t;&t;&t; if (nfound == nnew &amp;&amp;&n;&t;&t;&t; !(p-&gt;header.flag &amp; (NEW | MOD)))&n;&t;&t;&t; exit scan;&n;&t;&t;&t; */
multiline_comment|/* process parent page entries backward */
id|index
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * first access of each internal page&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * internal page: go down to child page of current entry&n;&t; */
multiline_comment|/* save current parent entry for the child page */
id|BT_PUSH
c_func
(paren
op_amp
id|btstack
comma
id|bn
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* get current entry for the child page */
id|e
op_assign
op_amp
id|p-&gt;xad
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each internal entry:&n;&t; */
multiline_comment|/*&n;&t; * if new entry, log btree_tnewentry.&n;&t; *&n;&t; if (e-&gt;flag &amp; XAD_NEW)&n;&t; update parent page lock for the entry;&n;&t; */
multiline_comment|/* release parent page */
id|XT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* get child page */
id|bn
op_assign
id|e-&gt;bn
suffix:semicolon
id|XT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each non-root page:&n;&t; */
multiline_comment|/*&n;&t; * if new, log btree_newpage.&n;&t; *&n;&t; if (p-&gt;header.flag &amp; NEW)&n;&t; allocate new page lock;&n;&t; write a NEWPAGE log (next, prev);&n;&t; */
multiline_comment|/* process the child page */
r_goto
id|dopage
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_WIP */
macro_line|#ifdef CONFIG_JFS_STATISTICS
DECL|function|jfs_xtstat_read
r_int
id|jfs_xtstat_read
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;JFS Xtree statistics&bslash;n&quot;
l_string|&quot;====================&bslash;n&quot;
l_string|&quot;searches = %d&bslash;n&quot;
l_string|&quot;fast searches = %d&bslash;n&quot;
l_string|&quot;splits = %d&bslash;n&quot;
comma
id|xtStat.search
comma
id|xtStat.fastSearch
comma
id|xtStat.split
)paren
suffix:semicolon
id|begin
op_assign
id|offset
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|begin
suffix:semicolon
id|len
op_sub_assign
id|begin
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_else
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
eof
