multiline_comment|/*&n; *&n; *   Copyright (c) International Business Machines  Corp., 2000&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; *&n;*/
multiline_comment|/*&n; *&t;jfs_logmgr.c: log manager&n; *&n; * for related information, see transaction manager (jfs_txnmgr.c), and&n; * recovery manager (jfs_logredo.c).&n; *&n; * note: for detail, RTFS.&n; *&n; *&t;log buffer manager:&n; * special purpose buffer manager supporting log i/o requirements.&n; * per log serial pageout of logpage&n; * queuing i/o requests and redrive i/o at iodone&n; * maintain current logpage buffer&n; * no caching since append only&n; * appropriate jfs buffer cache buffers as needed&n; *&n; *&t;group commit:&n; * transactions which wrote COMMIT records in the same in-memory&n; * log page during the pageout of previous/current log page(s) are&n; * committed together by the pageout of the page.&n; *&n; *&t;TBD lazy commit:&n; * transactions are committed asynchronously when the log page&n; * containing it COMMIT is paged out when it becomes full;&n; *&n; *&t;serialization:&n; * . a per log lock serialize log write.&n; * . a per log lock serialize group commit.&n; * . a per log lock serialize log open/close;&n; *&n; *&t;TBD log integrity:&n; * careful-write (ping-pong) of last logpage to recover from crash&n; * in overwrite.&n; * detection of split (out-of-order) write of physical sectors&n; * of last logpage via timestamp at end of each sector&n; * with its mirror data array at trailer).&n; *&n; *&t;alternatives:&n; * lsn - 64-bit monotonically increasing integer vs&n; * 32-bit lspn and page eor.&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_filsys.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_txnmgr.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/*&n; * lbuf&squot;s ready to be redriven.  Protected by log_redrive_lock (jfsIOtask)&n; */
DECL|variable|log_redrive_list
r_static
id|lbuf_t
op_star
id|log_redrive_list
suffix:semicolon
DECL|variable|log_redrive_lock
r_static
id|spinlock_t
id|log_redrive_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; *&t;log read/write serialization (per log)&n; */
DECL|macro|LOG_LOCK_INIT
mdefine_line|#define LOG_LOCK_INIT(log)&t;init_MUTEX(&amp;(log)-&gt;loglock)
DECL|macro|LOG_LOCK
mdefine_line|#define LOG_LOCK(log)&t;&t;down(&amp;((log)-&gt;loglock))
DECL|macro|LOG_UNLOCK
mdefine_line|#define LOG_UNLOCK(log)&t;&t;up(&amp;((log)-&gt;loglock))
multiline_comment|/*&n; *&t;log group commit serialization (per log)&n; */
DECL|macro|LOGGC_LOCK_INIT
mdefine_line|#define LOGGC_LOCK_INIT(log)&t;spin_lock_init(&amp;(log)-&gt;gclock)
DECL|macro|LOGGC_LOCK
mdefine_line|#define LOGGC_LOCK(log)&t;&t;spin_lock_irq(&amp;(log)-&gt;gclock)
DECL|macro|LOGGC_UNLOCK
mdefine_line|#define LOGGC_UNLOCK(log)&t;spin_unlock_irq(&amp;(log)-&gt;gclock)
DECL|macro|LOGGC_WAKEUP
mdefine_line|#define LOGGC_WAKEUP(tblk)&t;wake_up(&amp;(tblk)-&gt;gcwait)
multiline_comment|/*&n; *&t;log sync serialization (per log)&n; */
DECL|macro|LOGSYNC_DELTA
mdefine_line|#define&t;LOGSYNC_DELTA(logsize)&t;&t;min((logsize)/8, 128*LOGPSIZE)
DECL|macro|LOGSYNC_BARRIER
mdefine_line|#define&t;LOGSYNC_BARRIER(logsize)&t;((logsize)/4)
multiline_comment|/*&n;#define&t;LOGSYNC_DELTA(logsize)&t;&t;min((logsize)/4, 256*LOGPSIZE)&n;#define&t;LOGSYNC_BARRIER(logsize)&t;((logsize)/2)&n;*/
multiline_comment|/*&n; *&t;log buffer cache synchronization&n; */
DECL|variable|jfsLCacheLock
r_static
id|spinlock_t
id|jfsLCacheLock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|LCACHE_LOCK
mdefine_line|#define&t;LCACHE_LOCK(flags)&t;spin_lock_irqsave(&amp;jfsLCacheLock, flags)
DECL|macro|LCACHE_UNLOCK
mdefine_line|#define&t;LCACHE_UNLOCK(flags)&t;spin_unlock_irqrestore(&amp;jfsLCacheLock, flags)
multiline_comment|/*&n; * See __SLEEP_COND in jfs_locks.h&n; */
DECL|macro|LCACHE_SLEEP_COND
mdefine_line|#define LCACHE_SLEEP_COND(wq, cond, flags)&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (cond)&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&bslash;&n;&t;__SLEEP_COND(wq, cond, LCACHE_LOCK(flags), LCACHE_UNLOCK(flags)); &bslash;&n;} while (0)
DECL|macro|LCACHE_WAKEUP
mdefine_line|#define&t;LCACHE_WAKEUP(event)&t;wake_up(event)
multiline_comment|/*&n; *&t;lbuf buffer cache (lCache) control&n; */
multiline_comment|/* log buffer manager pageout control (cumulative, inclusive) */
DECL|macro|lbmREAD
mdefine_line|#define&t;lbmREAD&t;&t;0x0001
DECL|macro|lbmWRITE
mdefine_line|#define&t;lbmWRITE&t;0x0002&t;/* enqueue at tail of write queue;&n;&t;&t;&t;&t; * init pageout if at head of queue;&n;&t;&t;&t;&t; */
DECL|macro|lbmRELEASE
mdefine_line|#define&t;lbmRELEASE&t;0x0004&t;/* remove from write queue&n;&t;&t;&t;&t; * at completion of pageout;&n;&t;&t;&t;&t; * do not free/recycle it yet:&n;&t;&t;&t;&t; * caller will free it;&n;&t;&t;&t;&t; */
DECL|macro|lbmSYNC
mdefine_line|#define&t;lbmSYNC&t;&t;0x0008&t;/* do not return to freelist&n;&t;&t;&t;&t; * when removed from write queue;&n;&t;&t;&t;&t; */
DECL|macro|lbmFREE
mdefine_line|#define lbmFREE&t;&t;0x0010&t;/* return to freelist&n;&t;&t;&t;&t; * at completion of pageout;&n;&t;&t;&t;&t; * the buffer may be recycled;&n;&t;&t;&t;&t; */
DECL|macro|lbmDONE
mdefine_line|#define&t;lbmDONE&t;&t;0x0020
DECL|macro|lbmERROR
mdefine_line|#define&t;lbmERROR&t;0x0040
DECL|macro|lbmGC
mdefine_line|#define lbmGC&t;&t;0x0080&t;/* lbmIODone to perform post-GC processing&n;&t;&t;&t;&t; * of log page&n;&t;&t;&t;&t; */
DECL|macro|lbmDIRECT
mdefine_line|#define lbmDIRECT&t;0x0100
multiline_comment|/*&n; * external references&n; */
r_extern
r_void
id|vPut
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
suffix:semicolon
r_extern
r_void
id|txLazyUnlock
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
suffix:semicolon
r_extern
r_int
id|jfs_thread_stopped
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|jfsIOtask
suffix:semicolon
r_extern
r_struct
id|completion
id|jfsIOwait
suffix:semicolon
multiline_comment|/*&n; * forward references&n; */
r_static
r_int
id|lmWriteRecord
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
suffix:semicolon
r_static
r_int
id|lmNextPage
c_func
(paren
id|log_t
op_star
id|log
)paren
suffix:semicolon
r_static
r_int
id|lmLogInit
c_func
(paren
id|log_t
op_star
id|log
)paren
suffix:semicolon
r_static
r_int
id|lmLogShutdown
c_func
(paren
id|log_t
op_star
id|log
)paren
suffix:semicolon
r_static
r_int
id|lbmLogInit
c_func
(paren
id|log_t
op_star
id|log
)paren
suffix:semicolon
r_static
r_void
id|lbmLogShutdown
c_func
(paren
id|log_t
op_star
id|log
)paren
suffix:semicolon
r_static
id|lbuf_t
op_star
id|lbmAllocate
c_func
(paren
id|log_t
op_star
id|log
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|lbmFree
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_void
id|lbmfree
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|lbmRead
c_func
(paren
id|log_t
op_star
id|log
comma
r_int
id|pn
comma
id|lbuf_t
op_star
op_star
id|bpp
)paren
suffix:semicolon
r_static
r_void
id|lbmWrite
c_func
(paren
id|log_t
op_star
id|log
comma
id|lbuf_t
op_star
id|bp
comma
r_int
id|flag
comma
r_int
id|cant_block
)paren
suffix:semicolon
r_static
r_void
id|lbmDirectWrite
c_func
(paren
id|log_t
op_star
id|log
comma
id|lbuf_t
op_star
id|bp
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_int
id|lbmIOWait
c_func
(paren
id|lbuf_t
op_star
id|bp
comma
r_int
id|flag
)paren
suffix:semicolon
DECL|variable|lbmIODone
r_static
id|bio_end_io_t
id|lbmIODone
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
r_static
r_void
id|lbmDirectIODone
c_func
(paren
id|iobuf_t
op_star
id|ddbp
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
r_void
id|lbmStartIO
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
suffix:semicolon
r_void
id|lmGCwrite
c_func
(paren
id|log_t
op_star
id|log
comma
r_int
id|cant_block
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;statistics&n; */
macro_line|#ifdef CONFIG_JFS_STATISTICS
DECL|struct|lmStat
r_struct
id|lmStat
(brace
DECL|member|commit
id|uint
id|commit
suffix:semicolon
multiline_comment|/* # of commit */
DECL|member|pagedone
id|uint
id|pagedone
suffix:semicolon
multiline_comment|/* # of page written */
DECL|member|submitted
id|uint
id|submitted
suffix:semicolon
multiline_comment|/* # of pages submitted */
DECL|variable|lmStat
)brace
id|lmStat
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * NAME:&t;lmLog()&n; *&n; * FUNCTION:&t;write a log record;&n; *&n; * PARAMETER:&n; *&n; * RETURN:&t;lsn - offset to the next log record to write (end-of-log);&n; *&t;&t;-1  - error;&n; *&n; * note: todo: log error handler&n; */
DECL|function|lmLog
r_int
id|lmLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
(brace
r_int
id|lsn
suffix:semicolon
r_int
id|diffp
comma
id|difft
suffix:semicolon
id|metapage_t
op_star
id|mp
op_assign
l_int|NULL
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p&bslash;n&quot;
comma
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* log by (out-of-transaction) JFS ? */
r_if
c_cond
(paren
id|tblk
op_eq
l_int|NULL
)paren
r_goto
id|writeRecord
suffix:semicolon
multiline_comment|/* log from page ? */
r_if
c_cond
(paren
id|tlck
op_eq
l_int|NULL
op_logical_or
id|tlck-&gt;type
op_amp
id|tlckBTROOT
op_logical_or
(paren
id|mp
op_assign
id|tlck-&gt;mp
)paren
op_eq
l_int|NULL
)paren
r_goto
id|writeRecord
suffix:semicolon
multiline_comment|/*&n;&t; *      initialize/update page/transaction recovery lsn&n;&t; */
id|lsn
op_assign
id|log-&gt;lsn
suffix:semicolon
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize page lsn if first log write of the page&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;lsn
op_eq
l_int|0
)paren
(brace
id|mp-&gt;log
op_assign
id|log
suffix:semicolon
id|mp-&gt;lsn
op_assign
id|lsn
suffix:semicolon
id|log-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* insert page at tail of logsynclist */
id|list_add_tail
c_func
(paren
op_amp
id|mp-&gt;synclist
comma
op_amp
id|log-&gt;synclist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      initialize/update lsn of tblock of the page&n;&t; *&n;&t; * transaction inherits oldest lsn of pages associated&n;&t; * with allocation/deallocation of resources (their&n;&t; * log records are used to reconstruct allocation map&n;&t; * at recovery time: inode for inode allocation map,&n;&t; * B+-tree index of extent descriptors for block&n;&t; * allocation map);&n;&t; * allocation map pages inherit transaction lsn at&n;&t; * commit time to allow forwarding log syncpt past log&n;&t; * records associated with allocation/deallocation of&n;&t; * resources only after persistent map of these map pages&n;&t; * have been updated and propagated to home.&n;&t; */
multiline_comment|/*&n;&t; * initialize transaction lsn:&n;&t; */
r_if
c_cond
(paren
id|tblk-&gt;lsn
op_eq
l_int|0
)paren
(brace
multiline_comment|/* inherit lsn of its first page logged */
id|tblk-&gt;lsn
op_assign
id|mp-&gt;lsn
suffix:semicolon
id|log-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* insert tblock after the page on logsynclist */
id|list_add
c_func
(paren
op_amp
id|tblk-&gt;synclist
comma
op_amp
id|mp-&gt;synclist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * update transaction lsn:&n;&t; */
r_else
(brace
multiline_comment|/* inherit oldest/smallest lsn of page */
id|logdiff
c_func
(paren
id|diffp
comma
id|mp-&gt;lsn
comma
id|log
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|difft
comma
id|tblk-&gt;lsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diffp
OL
id|difft
)paren
(brace
multiline_comment|/* update tblock lsn with page lsn */
id|tblk-&gt;lsn
op_assign
id|mp-&gt;lsn
suffix:semicolon
multiline_comment|/* move tblock after page on logsynclist */
id|list_del
c_func
(paren
op_amp
id|tblk-&gt;synclist
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|tblk-&gt;synclist
comma
op_amp
id|mp-&gt;synclist
)paren
suffix:semicolon
)brace
)brace
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      write the log record&n;&t; */
id|writeRecord
suffix:colon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * forward log syncpt if log reached next syncpt trigger&n;&t; */
id|logdiff
c_func
(paren
id|diffp
comma
id|lsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diffp
op_ge
id|log-&gt;nextsync
)paren
id|lsn
op_assign
id|lmLogSync
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* update end-of-log lsn */
id|log-&gt;lsn
op_assign
id|lsn
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* return end-of-log address */
r_return
id|lsn
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmWriteRecord()&n; *&n; * FUNCTION:&t;move the log record to current log page&n; *&n; * PARAMETER:&t;cd&t;- commit descriptor&n; *&n; * RETURN:&t;end-of-log address&n; *&t;&t;&t;&n; * serialization: LOG_LOCK() held on entry/exit&n; */
r_static
r_int
DECL|function|lmWriteRecord
id|lmWriteRecord
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
(brace
r_int
id|lsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end-of-log address */
id|lbuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* dst log page buffer */
id|logpage_t
op_star
id|lp
suffix:semicolon
multiline_comment|/* dst log page */
id|caddr_t
id|dst
suffix:semicolon
multiline_comment|/* destination address in log page */
r_int
id|dstoffset
suffix:semicolon
multiline_comment|/* end-of-log offset in log page */
r_int
id|freespace
suffix:semicolon
multiline_comment|/* free space in log page */
id|caddr_t
id|p
suffix:semicolon
multiline_comment|/* src meta-data page */
id|caddr_t
id|src
suffix:semicolon
r_int
id|srclen
suffix:semicolon
r_int
id|nbytes
suffix:semicolon
multiline_comment|/* number of bytes to move */
r_int
id|i
suffix:semicolon
r_int
id|len
suffix:semicolon
id|linelock_t
op_star
id|linelock
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|lvd_t
op_star
id|lvd
suffix:semicolon
r_int
id|l2linesize
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* retrieve destination log page to write */
id|bp
op_assign
(paren
id|lbuf_t
op_star
)paren
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|log-&gt;eor
suffix:semicolon
multiline_comment|/* any log data to write ? */
r_if
c_cond
(paren
id|tlck
op_eq
l_int|NULL
)paren
r_goto
id|moveLrd
suffix:semicolon
multiline_comment|/*&n;&t; *      move log record data&n;&t; */
multiline_comment|/* retrieve source meta-data page to log */
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckPAGELOCK
)paren
(brace
id|p
op_assign
(paren
id|caddr_t
)paren
(paren
id|tlck-&gt;mp-&gt;data
)paren
suffix:semicolon
id|linelock
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
multiline_comment|/* retrieve source in-memory inode to log */
r_else
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckINODELOCK
)paren
(brace
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckDTREE
)paren
id|p
op_assign
(paren
id|caddr_t
)paren
op_amp
id|JFS_IP
c_func
(paren
id|tlck-&gt;ip
)paren
op_member_access_from_pointer
id|i_dtroot
suffix:semicolon
r_else
id|p
op_assign
(paren
id|caddr_t
)paren
op_amp
id|JFS_IP
c_func
(paren
id|tlck-&gt;ip
)paren
op_member_access_from_pointer
id|i_xtroot
suffix:semicolon
id|linelock
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
macro_line|#ifdef&t;_JFS_WIP
r_else
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckINLINELOCK
)paren
(brace
id|inlinelock
op_assign
(paren
id|inlinelock_t
op_star
)paren
op_amp
id|tlck
suffix:semicolon
id|p
op_assign
(paren
id|caddr_t
)paren
op_amp
id|inlinelock-&gt;pxd
suffix:semicolon
id|linelock
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_WIP */
r_else
(brace
id|jERROR
c_func
(paren
l_int|2
comma
(paren
l_string|&quot;lmWriteRecord: UFO tlck:0x%p&bslash;n&quot;
comma
id|tlck
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Probably should trap */
)brace
id|l2linesize
op_assign
id|linelock-&gt;l2linesize
suffix:semicolon
id|moveData
suffix:colon
id|ASSERT
c_func
(paren
id|linelock-&gt;index
op_le
id|linelock-&gt;maxcnt
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|linelock-&gt;lv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linelock-&gt;index
suffix:semicolon
id|i
op_increment
comma
id|lv
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lv-&gt;length
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* is page full ? */
r_if
c_cond
(paren
id|dstoffset
op_ge
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
(brace
multiline_comment|/* page become full: move on to next page */
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|LOGPHDRSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * move log vector data&n;&t;&t; */
id|src
op_assign
(paren
id|u8
op_star
)paren
id|p
op_plus
(paren
id|lv-&gt;offset
op_lshift
id|l2linesize
)paren
suffix:semicolon
id|srclen
op_assign
id|lv-&gt;length
op_lshift
id|l2linesize
suffix:semicolon
id|len
op_add_assign
id|srclen
suffix:semicolon
r_while
c_loop
(paren
id|srclen
OG
l_int|0
)paren
(brace
id|freespace
op_assign
(paren
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
op_minus
id|dstoffset
suffix:semicolon
id|nbytes
op_assign
id|min
c_func
(paren
id|freespace
comma
id|srclen
)paren
suffix:semicolon
id|dst
op_assign
(paren
id|caddr_t
)paren
id|lp
op_plus
id|dstoffset
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|nbytes
)paren
suffix:semicolon
id|dstoffset
op_add_assign
id|nbytes
suffix:semicolon
multiline_comment|/* is page not full ? */
r_if
c_cond
(paren
id|dstoffset
OL
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
r_break
suffix:semicolon
multiline_comment|/* page become full: move on to next page */
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
id|bp
op_assign
(paren
id|lbuf_t
op_star
)paren
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|LOGPHDRSIZE
suffix:semicolon
id|srclen
op_sub_assign
id|nbytes
suffix:semicolon
id|src
op_add_assign
id|nbytes
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * move log vector descriptor&n;&t;&t; */
id|len
op_add_assign
l_int|4
suffix:semicolon
id|lvd
op_assign
(paren
id|lvd_t
op_star
)paren
(paren
(paren
id|caddr_t
)paren
id|lp
op_plus
id|dstoffset
)paren
suffix:semicolon
id|lvd-&gt;offset
op_assign
id|cpu_to_le16
c_func
(paren
id|lv-&gt;offset
)paren
suffix:semicolon
id|lvd-&gt;length
op_assign
id|cpu_to_le16
c_func
(paren
id|lv-&gt;length
)paren
suffix:semicolon
id|dstoffset
op_add_assign
l_int|4
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmWriteRecord: lv offset:%d length:%d&bslash;n&quot;
comma
id|lv-&gt;offset
comma
id|lv-&gt;length
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_assign
id|linelock-&gt;next
)paren
)paren
(brace
id|linelock
op_assign
(paren
id|linelock_t
op_star
)paren
id|lid_to_tlock
c_func
(paren
id|i
)paren
suffix:semicolon
r_goto
id|moveData
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      move log record descriptor&n;&t; */
id|moveLrd
suffix:colon
id|lrd-&gt;length
op_assign
id|cpu_to_le16
c_func
(paren
id|len
)paren
suffix:semicolon
id|src
op_assign
(paren
id|caddr_t
)paren
id|lrd
suffix:semicolon
id|srclen
op_assign
id|LOGRDSIZE
suffix:semicolon
r_while
c_loop
(paren
id|srclen
OG
l_int|0
)paren
(brace
id|freespace
op_assign
(paren
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
op_minus
id|dstoffset
suffix:semicolon
id|nbytes
op_assign
id|min
c_func
(paren
id|freespace
comma
id|srclen
)paren
suffix:semicolon
id|dst
op_assign
(paren
id|caddr_t
)paren
id|lp
op_plus
id|dstoffset
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|nbytes
)paren
suffix:semicolon
id|dstoffset
op_add_assign
id|nbytes
suffix:semicolon
id|srclen
op_sub_assign
id|nbytes
suffix:semicolon
multiline_comment|/* are there more to move than freespace of page ? */
r_if
c_cond
(paren
id|srclen
)paren
r_goto
id|pageFull
suffix:semicolon
multiline_comment|/*&n;&t;&t; * end of log record descriptor&n;&t;&t; */
multiline_comment|/* update last log record eor */
id|log-&gt;eor
op_assign
id|dstoffset
suffix:semicolon
id|bp-&gt;l_eor
op_assign
id|dstoffset
suffix:semicolon
id|lsn
op_assign
(paren
id|log-&gt;page
op_lshift
id|L2LOGPSIZE
)paren
op_plus
id|dstoffset
suffix:semicolon
r_if
c_cond
(paren
id|lrd-&gt;type
op_amp
id|cpu_to_le16
c_func
(paren
id|LOG_COMMIT
)paren
)paren
(brace
id|tblk-&gt;clsn
op_assign
id|lsn
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;wr: tclsn:0x%x, beor:0x%x&bslash;n&quot;
comma
id|tblk-&gt;clsn
comma
id|bp-&gt;l_eor
)paren
)paren
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.commit
)paren
suffix:semicolon
multiline_comment|/* # of commit */
multiline_comment|/*&n;&t;&t;&t; * enqueue tblock for group commit:&n;&t;&t;&t; *&n;&t;&t;&t; * enqueue tblock of non-trivial/synchronous COMMIT&n;&t;&t;&t; * at tail of group commit queue&n;&t;&t;&t; * (trivial/asynchronous COMMITs are ignored by&n;&t;&t;&t; * group commit.)&n;&t;&t;&t; */
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* init tblock gc state */
id|tblk-&gt;flag
op_assign
id|tblkGC_QUEUE
suffix:semicolon
id|tblk-&gt;bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|tblk-&gt;pn
op_assign
id|log-&gt;page
suffix:semicolon
id|tblk-&gt;eor
op_assign
id|log-&gt;eor
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|tblk-&gt;gcwait
)paren
suffix:semicolon
multiline_comment|/* enqueue transaction to commit queue */
id|tblk-&gt;cqnext
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;cqueue.head
)paren
(brace
id|log-&gt;cqueue.tail-&gt;cqnext
op_assign
id|tblk
suffix:semicolon
id|log-&gt;cqueue.tail
op_assign
id|tblk
suffix:semicolon
)brace
r_else
id|log-&gt;cqueue.head
op_assign
id|log-&gt;cqueue.tail
op_assign
id|tblk
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x&bslash;n&quot;
comma
id|le16_to_cpu
c_func
(paren
id|lrd-&gt;type
)paren
comma
id|log-&gt;bp
comma
id|log-&gt;page
comma
id|dstoffset
)paren
)paren
suffix:semicolon
multiline_comment|/* page not full ? */
r_if
c_cond
(paren
id|dstoffset
OL
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
r_return
id|lsn
suffix:semicolon
id|pageFull
suffix:colon
multiline_comment|/* page become full: move on to next page */
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
id|bp
op_assign
(paren
id|lbuf_t
op_star
)paren
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|LOGPHDRSIZE
suffix:semicolon
id|src
op_add_assign
id|nbytes
suffix:semicolon
)brace
r_return
id|lsn
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmNextPage()&n; *&n; * FUNCTION:&t;write current page and allocate next page.&n; *&n; * PARAMETER:&t;log&n; *&n; * RETURN:&t;0&n; *&t;&t;&t;&n; * serialization: LOG_LOCK() held on entry/exit&n; */
DECL|function|lmNextPage
r_static
r_int
id|lmNextPage
c_func
(paren
id|log_t
op_star
id|log
)paren
(brace
id|logpage_t
op_star
id|lp
suffix:semicolon
r_int
id|lspn
suffix:semicolon
multiline_comment|/* log sequence page number */
r_int
id|pn
suffix:semicolon
multiline_comment|/* current page number */
id|lbuf_t
op_star
id|bp
suffix:semicolon
id|lbuf_t
op_star
id|nextbp
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmNextPage&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* get current log page number and log sequence page number */
id|pn
op_assign
id|log-&gt;page
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|lspn
op_assign
id|le32_to_cpu
c_func
(paren
id|lp-&gt;h.page
)paren
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      write or queue the full page at the tail of write queue&n;&t; */
multiline_comment|/* get the tail tblk on commit queue */
id|tblk
op_assign
id|log-&gt;cqueue.tail
suffix:semicolon
multiline_comment|/* every tblk who has COMMIT record on the current page,&n;&t; * and has not been committed, must be on commit queue&n;&t; * since tblk is queued at commit queueu at the time&n;&t; * of writing its COMMIT record on the page before&n;&t; * page becomes full (even though the tblk thread&n;&t; * who wrote COMMIT record may have been suspended&n;&t; * currently);&n;&t; */
multiline_comment|/* is page bound with outstanding tail tblk ? */
r_if
c_cond
(paren
id|tblk
op_logical_and
id|tblk-&gt;pn
op_eq
id|pn
)paren
(brace
multiline_comment|/* mark tblk for end-of-page */
id|tblk-&gt;flag
op_or_assign
id|tblkGC_EOP
suffix:semicolon
multiline_comment|/* if page is not already on write queue,&n;&t;&t; * just enqueue (no lbmWRITE to prevent redrive)&n;&t;&t; * buffer to wqueue to ensure correct serial order&n;&t;&t; * of the pages since log pages will be added&n;&t;&t; * continuously (tblk bound with the page hasn&squot;t&n;&t;&t; * got around to init write of the page, either&n;&t;&t; * preempted or the page got filled by its COMMIT&n;&t;&t; * record);&n;&t;&t; * pages with COMMIT are paged out explicitly by&n;&t;&t; * tblk in lmGroupCommit();&n;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_wqnext
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* bp-&gt;l_ceor = bp-&gt;l_eor; */
multiline_comment|/* lp-&gt;h.eor = lp-&gt;t.eor = bp-&gt;l_ceor; */
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* page is not bound with outstanding tblk:&n;&t; * init write or mark it to be redriven (lbmWRITE)&n;&t; */
r_else
(brace
multiline_comment|/* finalize the page */
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_ceor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmFREE
comma
l_int|0
)paren
suffix:semicolon
)brace
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      allocate/initialize next page&n;&t; */
multiline_comment|/* if log wraps, the first data page of log is 2&n;&t; * (0 never used, 1 is superblock).&n;&t; */
id|log-&gt;page
op_assign
(paren
id|pn
op_eq
id|log-&gt;size
op_minus
l_int|1
)paren
ques
c_cond
l_int|2
suffix:colon
id|pn
op_plus
l_int|1
suffix:semicolon
id|log-&gt;eor
op_assign
id|LOGPHDRSIZE
suffix:semicolon
multiline_comment|/* ? valid page empty/full at logRedo() */
multiline_comment|/* allocate/initialize next log page buffer */
id|nextbp
op_assign
id|lbmAllocate
c_func
(paren
id|log
comma
id|log-&gt;page
)paren
suffix:semicolon
id|nextbp-&gt;l_eor
op_assign
id|log-&gt;eor
suffix:semicolon
id|log-&gt;bp
op_assign
id|nextbp
suffix:semicolon
multiline_comment|/* initialize next log page */
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|nextbp-&gt;l_ldata
suffix:semicolon
id|lp-&gt;h.page
op_assign
id|lp-&gt;t.page
op_assign
id|cpu_to_le32
c_func
(paren
id|lspn
op_plus
l_int|1
)paren
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|LOGPHDRSIZE
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmNextPage done&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmGroupCommit()&n; *&n; * FUNCTION:&t;group commit&n; *&t;initiate pageout of the pages with COMMIT in the order of&n; *&t;page number - redrive pageout of the page at the head of&n; *&t;pageout queue until full page has been written.&n; *&n; * RETURN:&t;&n; *&n; * NOTE:&n; *&t;LOGGC_LOCK serializes log group commit queue, and&n; *&t;transaction blocks on the commit queue.&n; *&t;N.B. LOG_LOCK is NOT held during lmGroupCommit().&n; */
DECL|function|lmGroupCommit
r_int
id|lmGroupCommit
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* group committed already ? */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMITTED
)paren
(brace
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_ERROR
)paren
id|rc
op_assign
id|EIO
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmGroup Commit: tblk = 0x%p, gcrtc = %d&bslash;n&quot;
comma
id|tblk
comma
id|log-&gt;gcrtc
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * group commit pageout in progress&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|log-&gt;cflag
op_amp
id|logGC_PAGEOUT
)paren
)paren
op_logical_and
id|log-&gt;cqueue.head
)paren
(brace
multiline_comment|/*&n;&t;&t; * only transaction in the commit queue:&n;&t;&t; *&n;&t;&t; * start one-transaction group commit as&n;&t;&t; * its group leader.&n;&t;&t; */
id|log-&gt;cflag
op_or_assign
id|logGC_PAGEOUT
suffix:semicolon
id|lmGCwrite
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* lmGCwrite gives up LOGGC_LOCK, check again */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMITTED
)paren
(brace
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_ERROR
)paren
id|rc
op_assign
id|EIO
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* upcount transaction waiting for completion&n;&t; */
id|log-&gt;gcrtc
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_LAZY
)paren
(brace
id|tblk-&gt;flag
op_or_assign
id|tblkGC_LAZY
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tblk-&gt;flag
op_or_assign
id|tblkGC_READY
suffix:semicolon
id|__SLEEP_COND
c_func
(paren
id|tblk-&gt;gcwait
comma
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMITTED
)paren
comma
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
comma
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
)paren
suffix:semicolon
multiline_comment|/* removed from commit queue */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_ERROR
)paren
id|rc
op_assign
id|EIO
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmGCwrite()&n; *&n; * FUNCTION:&t;group commit write&n; *&t;initiate write of log page, building a group of all transactions&n; *&t;with commit records on that page.&n; *&n; * RETURN:&t;None&n; *&n; * NOTE:&n; *&t;LOGGC_LOCK must be held by caller.&n; *&t;N.B. LOG_LOCK is NOT held during lmGroupCommit().&n; */
DECL|function|lmGCwrite
r_void
id|lmGCwrite
c_func
(paren
id|log_t
op_star
id|log
comma
r_int
id|cant_write
)paren
(brace
id|lbuf_t
op_star
id|bp
suffix:semicolon
id|logpage_t
op_star
id|lp
suffix:semicolon
r_int
id|gcpn
suffix:semicolon
multiline_comment|/* group commit page number */
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|tblock_t
op_star
id|xtblk
suffix:semicolon
multiline_comment|/*&n;&t; * build the commit group of a log page&n;&t; *&n;&t; * scan commit queue and make a commit group of all&n;&t; * transactions with COMMIT records on the same log page.&n;&t; */
multiline_comment|/* get the head tblk on the commit queue */
id|tblk
op_assign
id|xtblk
op_assign
id|log-&gt;cqueue.head
suffix:semicolon
id|gcpn
op_assign
id|tblk-&gt;pn
suffix:semicolon
r_while
c_loop
(paren
id|tblk
op_logical_and
id|tblk-&gt;pn
op_eq
id|gcpn
)paren
(brace
id|xtblk
op_assign
id|tblk
suffix:semicolon
multiline_comment|/* state transition: (QUEUE, READY) -&gt; COMMIT */
id|tblk-&gt;flag
op_or_assign
id|tblkGC_COMMIT
suffix:semicolon
id|tblk
op_assign
id|tblk-&gt;cqnext
suffix:semicolon
)brace
id|tblk
op_assign
id|xtblk
suffix:semicolon
multiline_comment|/* last tblk of the page */
multiline_comment|/*&n;&t; * pageout to commit transactions on the log page.&n;&t; */
id|bp
op_assign
(paren
id|lbuf_t
op_star
)paren
id|tblk-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
multiline_comment|/* is page already full ? */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_EOP
)paren
(brace
multiline_comment|/* mark page to free at end of group commit of the page */
id|tblk-&gt;flag
op_and_assign
op_complement
id|tblkGC_EOP
suffix:semicolon
id|tblk-&gt;flag
op_or_assign
id|tblkGC_FREE
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_ceor
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;gc: tclsn:0x%x, bceor:0x%x&bslash;n&quot;
comma
id|tblk-&gt;clsn
comma
id|bp-&gt;l_ceor
)paren
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmGC
comma
id|cant_write
)paren
suffix:semicolon
)brace
multiline_comment|/* page is not yet full */
r_else
(brace
id|bp-&gt;l_ceor
op_assign
id|tblk-&gt;eor
suffix:semicolon
multiline_comment|/* ? bp-&gt;l_ceor = bp-&gt;l_eor; */
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_ceor
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;gc: tclsn:0x%x, bceor:0x%x&bslash;n&quot;
comma
id|tblk-&gt;clsn
comma
id|bp-&gt;l_ceor
)paren
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmGC
comma
id|cant_write
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NAME:&t;lmPostGC()&n; *&n; * FUNCTION:&t;group commit post-processing&n; *&t;Processes transactions after their commit records have been written&n; *&t;to disk, redriving log I/O if necessary.&n; *&n; * RETURN:&t;None&n; *&n; * NOTE:&n; *&t;This routine is called a interrupt time by lbmIODone&n; */
DECL|function|lmPostGC
r_void
id|lmPostGC
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|log_t
op_star
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
id|logpage_t
op_star
id|lp
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
singleline_comment|//LOGGC_LOCK(log);
id|spin_lock_irqsave
c_func
(paren
op_amp
id|log-&gt;gclock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * current pageout of group commit completed.&n;&t; *&n;&t; * remove/wakeup transactions from commit queue who were&n;&t; * group committed with the current log page&n;&t; */
r_while
c_loop
(paren
(paren
id|tblk
op_assign
id|log-&gt;cqueue.head
)paren
op_logical_and
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMIT
)paren
)paren
(brace
multiline_comment|/* if transaction was marked GC_COMMIT then&n;&t;&t; * it has been shipped in the current pageout&n;&t;&t; * and made it to disk - it is committed.&n;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmERROR
)paren
id|tblk-&gt;flag
op_or_assign
id|tblkGC_ERROR
suffix:semicolon
multiline_comment|/* remove it from the commit queue */
id|log-&gt;cqueue.head
op_assign
id|tblk-&gt;cqnext
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;cqueue.head
op_eq
l_int|NULL
)paren
id|log-&gt;cqueue.tail
op_assign
l_int|NULL
suffix:semicolon
id|tblk-&gt;flag
op_and_assign
op_complement
id|tblkGC_QUEUE
suffix:semicolon
id|tblk-&gt;cqnext
op_assign
l_int|0
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lmPostGC: tblk = 0x%p, flag = 0x%x&bslash;n&quot;
comma
id|tblk
comma
id|tblk-&gt;flag
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_FORCE
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Hand tblk over to lazy commit thread&n;&t;&t;&t; */
id|txLazyUnlock
c_func
(paren
id|tblk
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* state transition: COMMIT -&gt; COMMITTED */
id|tblk-&gt;flag
op_or_assign
id|tblkGC_COMMITTED
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_READY
)paren
(brace
id|log-&gt;gcrtc
op_decrement
suffix:semicolon
id|LOGGC_WAKEUP
c_func
(paren
id|tblk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* was page full before pageout ?&n;&t;&t; * (and this is the last tblk bound with the page)&n;&t;&t; */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_FREE
)paren
id|lbmFree
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* did page become full after pageout ?&n;&t;&t; * (and this is the last tblk bound with the page)&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_EOP
)paren
(brace
multiline_comment|/* finalize the page */
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_eor
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lmPostGC: calling lbmWrite&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmFREE
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* are there any transactions who have entered lnGroupCommit()&n;&t; * (whose COMMITs are after that of the last log page written.&n;&t; * They are waiting for new group commit (above at (SLEEP 1)):&n;&t; * select the latest ready transaction as new group leader and&n;&t; * wake her up to lead her group.&n;&t; */
r_if
c_cond
(paren
(paren
id|log-&gt;gcrtc
OG
l_int|0
)paren
op_logical_and
id|log-&gt;cqueue.head
)paren
multiline_comment|/*&n;&t;&t; * Call lmGCwrite with new group leader&n;&t;&t; */
id|lmGCwrite
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no transaction are ready yet (transactions are only just&n;&t; * queued (GC_QUEUE) and not entered for group commit yet).&n;&t; * let the first transaction entering group commit&n;&t; * will elect hetself as new group leader.&n;&t; */
r_else
id|log-&gt;cflag
op_and_assign
op_complement
id|logGC_PAGEOUT
suffix:semicolon
singleline_comment|//LOGGC_UNLOCK(log);
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log-&gt;gclock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogSync()&n; *&n; * FUNCTION:&t;write log SYNCPT record for specified log&n; *&t;if new sync address is available&n; *&t;(normally the case if sync() is executed by back-ground&n; *&t;process).&n; *&t;if not, explicitly run jfs_blogsync() to initiate&n; *&t;getting of new sync address.&n; *&t;calculate new value of i_nextsync which determines when&n; *&t;this code is called again.&n; *&n; *&t;this is called only from lmLog().&n; *&n; * PARAMETER:&t;ip&t;- pointer to logs inode.&n; *&n; * RETURN:&t;0&n; *&t;&t;&t;&n; * serialization: LOG_LOCK() held on entry/exit&n; */
DECL|function|lmLogSync
r_int
id|lmLogSync
c_func
(paren
id|log_t
op_star
id|log
comma
r_int
id|nosyncwait
)paren
(brace
r_int
id|logsize
suffix:semicolon
r_int
id|written
suffix:semicolon
multiline_comment|/* written since last syncpt */
r_int
id|free
suffix:semicolon
multiline_comment|/* free space left available */
r_int
id|delta
suffix:semicolon
multiline_comment|/* additional delta to write normally */
r_int
id|more
suffix:semicolon
multiline_comment|/* additional write granted */
id|lrd_t
id|lrd
suffix:semicolon
r_int
id|lsn
suffix:semicolon
r_struct
id|logsyncblk
op_star
id|lp
suffix:semicolon
multiline_comment|/*&n;&t; *      forward syncpt&n;&t; */
multiline_comment|/* if last sync is same as last syncpt,&n;&t; * invoke sync point forward processing to update sync.&n;&t; */
r_if
c_cond
(paren
id|log-&gt;sync
op_eq
id|log-&gt;syncpt
)paren
(brace
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* ToDo: push dirty metapages out to disk */
singleline_comment|//              bmLogSync(log);
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
id|log-&gt;sync
op_assign
id|log-&gt;lsn
suffix:semicolon
r_else
(brace
id|lp
op_assign
id|list_entry
c_func
(paren
id|log-&gt;synclist.next
comma
r_struct
id|logsyncblk
comma
id|synclist
)paren
suffix:semicolon
id|log-&gt;sync
op_assign
id|lp-&gt;lsn
suffix:semicolon
)brace
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
multiline_comment|/* if sync is different from last syncpt,&n;&t; * write a SYNCPT record with syncpt = sync.&n;&t; * reset syncpt = sync&n;&t; */
r_if
c_cond
(paren
id|log-&gt;sync
op_ne
id|log-&gt;syncpt
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|log-&gt;sb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to make sure all of the &quot;written&quot; metapages&n;&t;&t; * actually make it to disk&n;&t;&t; */
id|fsync_inode_data_buffers
c_func
(paren
id|sbi-&gt;ipbmap
)paren
suffix:semicolon
id|fsync_inode_data_buffers
c_func
(paren
id|sbi-&gt;ipimap
)paren
suffix:semicolon
id|fsync_inode_data_buffers
c_func
(paren
id|sbi-&gt;direct_inode
)paren
suffix:semicolon
id|lrd.logtid
op_assign
l_int|0
suffix:semicolon
id|lrd.backchain
op_assign
l_int|0
suffix:semicolon
id|lrd.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd.length
op_assign
l_int|0
suffix:semicolon
id|lrd.log.syncpt.sync
op_assign
id|cpu_to_le32
c_func
(paren
id|log-&gt;sync
)paren
suffix:semicolon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
l_int|NULL
comma
op_amp
id|lrd
comma
l_int|NULL
)paren
suffix:semicolon
id|log-&gt;syncpt
op_assign
id|log-&gt;sync
suffix:semicolon
)brace
r_else
id|lsn
op_assign
id|log-&gt;lsn
suffix:semicolon
multiline_comment|/*&n;&t; *      setup next syncpt trigger (SWAG)&n;&t; */
id|logsize
op_assign
id|log-&gt;logsize
suffix:semicolon
id|logdiff
c_func
(paren
id|written
comma
id|lsn
comma
id|log
)paren
suffix:semicolon
id|free
op_assign
id|logsize
op_minus
id|written
suffix:semicolon
id|delta
op_assign
id|LOGSYNC_DELTA
c_func
(paren
id|logsize
)paren
suffix:semicolon
id|more
op_assign
id|min
c_func
(paren
id|free
op_div
l_int|2
comma
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|more
OL
l_int|2
op_star
id|LOGPSIZE
)paren
(brace
id|jEVENT
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;&bslash;n ... Log Wrap ... Log Wrap ... Log Wrap ...&bslash;n&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      log wrapping&n;&t;&t; *&n;&t;&t; * option 1 - panic ? No.!&n;&t;&t; * option 2 - shutdown file systems&n;&t;&t; *            associated with log ?&n;&t;&t; * option 3 - extend log ?&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * option 4 - second chance&n;&t;&t; *&n;&t;&t; * mark log wrapped, and continue.&n;&t;&t; * when all active transactions are completed,&n;&t;&t; * mark log vaild for recovery.&n;&t;&t; * if crashed during invalid state, log state&n;&t;&t; * implies invald log, forcing fsck().&n;&t;&t; */
multiline_comment|/* mark log state log wrap in log superblock */
multiline_comment|/* log-&gt;state = LOGWRAP; */
multiline_comment|/* reset sync point computation */
id|log-&gt;syncpt
op_assign
id|log-&gt;sync
op_assign
id|lsn
suffix:semicolon
id|log-&gt;nextsync
op_assign
id|delta
suffix:semicolon
)brace
r_else
multiline_comment|/* next syncpt trigger = written + more */
id|log-&gt;nextsync
op_assign
id|written
op_plus
id|more
suffix:semicolon
multiline_comment|/* return if lmLogSync() from outside of transaction, e.g., sync() */
r_if
c_cond
(paren
id|nosyncwait
)paren
r_return
id|lsn
suffix:semicolon
multiline_comment|/* if number of bytes written from last sync point is more&n;&t; * than 1/4 of the log size, stop new transactions from&n;&t; * starting until all current transactions are completed&n;&t; * by setting syncbarrier flag.&n;&t; */
r_if
c_cond
(paren
id|written
OG
id|LOGSYNC_BARRIER
c_func
(paren
id|logsize
)paren
op_logical_and
id|logsize
OG
l_int|32
op_star
id|LOGPSIZE
)paren
(brace
id|log-&gt;syncbarrier
op_assign
l_int|1
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;log barrier on: lsn=0x%x syncpt=0x%x&bslash;n&quot;
comma
id|lsn
comma
id|log-&gt;syncpt
)paren
)paren
suffix:semicolon
)brace
r_return
id|lsn
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogOpen()&n; *&n; * FUNCTION:    open the log on first open;&n; *&t;insert filesystem in the active list of the log.&n; *&n; * PARAMETER:&t;ipmnt&t;- file system mount inode&n; *&t;&t;iplog &t;- log inode (out)&n; *&n; * RETURN:&n; *&n; * serialization:&n; */
DECL|function|lmLogOpen
r_int
id|lmLogOpen
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|log_t
op_star
op_star
id|logptr
)paren
(brace
r_int
id|rc
suffix:semicolon
id|kdev_t
id|logdev
suffix:semicolon
multiline_comment|/* dev_t of log device */
id|log_t
op_star
id|log
suffix:semicolon
id|logdev
op_assign
id|sb-&gt;s_dev
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/*&n;&t; * open the inode representing the log device (aka log inode)&n;&t; */
r_if
c_cond
(paren
id|logdev
op_ne
id|fsdev
)paren
r_goto
id|externalLog
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
multiline_comment|/*&n;&t; *      in-line log in host file system&n;&t; *&n;&t; * file system to log have 1-to-1 relationship;&n;&t; */
singleline_comment|//    inlineLog:
op_star
id|logptr
op_assign
id|log
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|log_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log
op_eq
l_int|0
)paren
r_return
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|log
comma
l_int|0
comma
r_sizeof
(paren
id|log_t
)paren
)paren
suffix:semicolon
id|log-&gt;sb
op_assign
id|sb
suffix:semicolon
multiline_comment|/* This should be a list */
id|log-&gt;flag
op_assign
id|JFS_INLINELOG
suffix:semicolon
id|log-&gt;dev
op_assign
id|logdev
suffix:semicolon
id|log-&gt;base
op_assign
id|addressPXD
c_func
(paren
op_amp
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|logpxd
)paren
suffix:semicolon
id|log-&gt;size
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|logpxd
)paren
op_rshift
(paren
id|L2LOGPSIZE
op_minus
id|sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|log-&gt;l2bsize
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|ASSERT
c_func
(paren
id|L2LOGPSIZE
op_ge
id|sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize log.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lmLogInit
c_func
(paren
id|log
)paren
)paren
)paren
r_goto
id|errout10
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *      external log as separate logical volume&n;&t; *&n;&t; * file systems to log may have n-to-1 relationship;&n;&t; */
id|externalLog
suffix:colon
multiline_comment|/*&n;&t; * open log inode&n;&t; *&n;&t; * log inode is reserved inode of (dev_t = log device,&n;&t; * fileset number = 0, i_number = 0), which acquire&n;&t; * one i_count for each open by file system.&n;&t; *&n;&t; * hand craft dummy vfs to force iget() the special case of&n;&t; * an in-memory inode allocation without on-disk inode&n;&t; */
id|memset
c_func
(paren
op_amp
id|dummyvfs
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|vfs
)paren
)paren
suffix:semicolon
id|dummyvfs.filesetvfs.vfs_data
op_assign
l_int|NULL
suffix:semicolon
id|dummyvfs.dummyvfs.dev
op_assign
id|logdev
suffix:semicolon
id|dummyvfs.dummyvfs.ipmnt
op_assign
l_int|NULL
suffix:semicolon
id|ICACHE_LOCK
c_func
(paren
)paren
suffix:semicolon
id|rc
op_assign
id|iget
c_func
(paren
(paren
r_struct
id|vfs
op_star
)paren
op_amp
id|dummyvfs
comma
l_int|0
comma
(paren
id|inode_t
op_star
op_star
)paren
op_amp
id|log
comma
l_int|0
)paren
suffix:semicolon
id|ICACHE_UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|log-&gt;flag
op_assign
l_int|0
suffix:semicolon
id|log-&gt;dev
op_assign
id|logdev
suffix:semicolon
id|log-&gt;base
op_assign
l_int|0
suffix:semicolon
id|log-&gt;size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * serialize open/close between multiple file systems&n;&t; * bound with the log;&n;&t; */
id|ip
op_assign
(paren
id|inode_t
op_star
)paren
id|log
suffix:semicolon
id|IWRITE_LOCK
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * subsequent open: add file system to log active file system list&n;&t; */
macro_line|#ifdef&t;_JFS_OS2
r_if
c_cond
(paren
id|log-&gt;strat2p
)paren
macro_line|#endif&t;&t;&t;&t;/* _JFS_OS2 */
(brace
r_if
c_cond
(paren
id|rc
op_assign
id|lmLogFileSystem
c_func
(paren
id|log
comma
id|fsdev
comma
l_int|1
)paren
)paren
r_goto
id|errout10
suffix:semicolon
id|IWRITE_UNLOCK
c_func
(paren
id|ip
)paren
suffix:semicolon
op_star
id|iplog
op_assign
id|ip
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogOpen: exit(0)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* decouple log inode from dummy vfs */
id|vPut
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * first open:&n;&t; */
macro_line|#ifdef&t;_JFS_OS2
multiline_comment|/*&n;&t; * establish access to the single/shared (already open) log device&n;&t; */
id|logdevfp
op_assign
(paren
r_void
op_star
)paren
id|logStrat2
suffix:semicolon
id|log-&gt;strat2p
op_assign
id|logStrat2
suffix:semicolon
id|log-&gt;strat3p
op_assign
id|logStrat3
suffix:semicolon
id|log-&gt;l2pbsize
op_assign
l_int|9
suffix:semicolon
multiline_comment|/* todo: when OS/2 have multiple external log */
macro_line|#endif&t;&t;&t;&t;/* _JFS_OS2 */
multiline_comment|/*&n;&t; * initialize log:&n;&t; */
r_if
c_cond
(paren
id|rc
op_assign
id|lmLogInit
c_func
(paren
id|log
)paren
)paren
r_goto
id|errout20
suffix:semicolon
multiline_comment|/*&n;&t; * add file system to log active file system list&n;&t; */
r_if
c_cond
(paren
id|rc
op_assign
id|lmLogFileSystem
c_func
(paren
id|log
comma
id|fsdev
comma
l_int|1
)paren
)paren
r_goto
id|errout30
suffix:semicolon
multiline_comment|/*&n;&t; *      insert log device into log device list&n;&t; */
id|out
suffix:colon
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogOpen: exit(0)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      unwind on error&n;&t; */
macro_line|#ifdef _STILL_TO_PORT
id|errout30
suffix:colon
multiline_comment|/* unwind lbmLogInit() */
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
id|errout20
suffix:colon
multiline_comment|/* close external log device */
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
id|errout10
suffix:colon
multiline_comment|/* free log inode */
id|kfree
c_func
(paren
id|log
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogOpen: exit(%d)&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogInit()&n; *&n; * FUNCTION:&t;log initialization at first log open.&n; *&n; *&t;logredo() (or logformat()) should have been run previously.&n; *&t;initialize the log inode from log superblock.&n; *&t;set the log state in the superblock to LOGMOUNT and&n; *&t;write SYNCPT log record.&n; *&t;&t;&n; * PARAMETER:&t;log&t;- log structure&n; *&n; * RETURN:&t;0&t;- if ok&n; *&t;&t;EINVAL&t;- bad log magic number or superblock dirty&n; *&t;&t;error returned from logwait()&n; *&t;&t;&t;&n; * serialization: single first open thread&n; */
DECL|function|lmLogInit
r_static
r_int
id|lmLogInit
c_func
(paren
id|log_t
op_star
id|log
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|lrd_t
id|lrd
suffix:semicolon
id|logsuper_t
op_star
id|logsuper
suffix:semicolon
id|lbuf_t
op_star
id|bpsuper
suffix:semicolon
id|lbuf_t
op_star
id|bp
suffix:semicolon
id|logpage_t
op_star
id|lp
suffix:semicolon
r_int
id|lsn
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogInit: log:0x%p&bslash;n&quot;
comma
id|log
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * log inode is overlaid on generic inode where&n;&t; * dinode have been zeroed out by iRead();&n;&t; */
multiline_comment|/*&n;&t; * initialize log i/o&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmLogInit
c_func
(paren
id|log
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * validate log superblock&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
l_int|1
comma
op_amp
id|bpsuper
)paren
)paren
)paren
r_goto
id|errout10
suffix:semicolon
id|logsuper
op_assign
(paren
id|logsuper_t
op_star
)paren
id|bpsuper-&gt;l_ldata
suffix:semicolon
r_if
c_cond
(paren
id|logsuper-&gt;magic
op_ne
id|cpu_to_le32
c_func
(paren
id|LOGMAGIC
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;*** Log Format Error ! ***&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|EINVAL
suffix:semicolon
r_goto
id|errout20
suffix:semicolon
)brace
multiline_comment|/* logredo() should have been run successfully. */
r_if
c_cond
(paren
id|logsuper-&gt;state
op_ne
id|cpu_to_le32
c_func
(paren
id|LOGREDONE
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;*** Log Is Dirty ! ***&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|EINVAL
suffix:semicolon
r_goto
id|errout20
suffix:semicolon
)brace
multiline_comment|/* initialize log inode from log superblock */
r_if
c_cond
(paren
id|log-&gt;flag
op_amp
id|JFS_INLINELOG
)paren
(brace
r_if
c_cond
(paren
id|log-&gt;size
op_ne
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;size
)paren
)paren
(brace
id|rc
op_assign
id|EINVAL
suffix:semicolon
r_goto
id|errout20
suffix:semicolon
)brace
id|jFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lmLogInit: inline log:0x%p base:0x%Lx size:0x%x&bslash;n&quot;
comma
id|log
comma
(paren
r_int
r_int
r_int
)paren
id|log-&gt;base
comma
id|log-&gt;size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|log-&gt;size
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;size
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lmLogInit: external log:0x%p base:0x%Lx size:0x%x&bslash;n&quot;
comma
id|log
comma
(paren
r_int
r_int
r_int
)paren
id|log-&gt;base
comma
id|log-&gt;size
)paren
)paren
suffix:semicolon
)brace
id|log-&gt;flag
op_or_assign
id|JFS_GROUPCOMMIT
suffix:semicolon
multiline_comment|/*&n;&t;log-&gt;flag |= JFS_LAZYCOMMIT;&n;*/
id|log-&gt;page
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;end
)paren
op_div
id|LOGPSIZE
suffix:semicolon
id|log-&gt;eor
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;end
)paren
op_minus
(paren
id|LOGPSIZE
op_star
id|log-&gt;page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize for log append write mode&n;&t; */
multiline_comment|/* establish current/end-of-log page/buffer */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
id|log-&gt;page
comma
op_amp
id|bp
)paren
)paren
)paren
r_goto
id|errout20
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogInit: lsn:0x%x page:%d eor:%d:%d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;end
)paren
comma
id|log-&gt;page
comma
id|log-&gt;eor
comma
id|le16_to_cpu
c_func
(paren
id|lp-&gt;h.eor
)paren
)paren
)paren
suffix:semicolon
singleline_comment|//      ASSERT(log-&gt;eor == lp-&gt;h.eor);
id|log-&gt;bp
op_assign
id|bp
suffix:semicolon
id|bp-&gt;l_pn
op_assign
id|log-&gt;page
suffix:semicolon
id|bp-&gt;l_eor
op_assign
id|log-&gt;eor
suffix:semicolon
multiline_comment|/* initialize the group commit serialization lock */
id|LOGGC_LOCK_INIT
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* if current page is full, move on to next page */
r_if
c_cond
(paren
id|log-&gt;eor
op_ge
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* allocate/initialize the log write serialization lock */
id|LOG_LOCK_INIT
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize log syncpoint&n;&t; */
multiline_comment|/*&n;&t; * write the first SYNCPT record with syncpoint = 0&n;&t; * (i.e., log redo up to HERE !);&n;&t; * remove current page from lbm write queue at end of pageout&n;&t; * (to write log superblock update), but do not release to freelist;&n;&t; */
id|lrd.logtid
op_assign
l_int|0
suffix:semicolon
id|lrd.backchain
op_assign
l_int|0
suffix:semicolon
id|lrd.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd.length
op_assign
l_int|0
suffix:semicolon
id|lrd.log.syncpt.sync
op_assign
l_int|0
suffix:semicolon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
l_int|NULL
comma
op_amp
id|lrd
comma
l_int|NULL
)paren
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_eor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmSYNC
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bp
comma
l_int|0
)paren
)paren
)paren
r_goto
id|errout30
suffix:semicolon
multiline_comment|/* initialize logsync parameters */
id|log-&gt;logsize
op_assign
(paren
id|log-&gt;size
op_minus
l_int|2
)paren
op_lshift
id|L2LOGPSIZE
suffix:semicolon
id|log-&gt;lsn
op_assign
id|lsn
suffix:semicolon
id|log-&gt;syncpt
op_assign
id|lsn
suffix:semicolon
id|log-&gt;sync
op_assign
id|log-&gt;syncpt
suffix:semicolon
id|log-&gt;nextsync
op_assign
id|LOGSYNC_DELTA
c_func
(paren
id|log-&gt;logsize
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|log-&gt;syncwait
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x&bslash;n&quot;
comma
id|log-&gt;lsn
comma
id|log-&gt;syncpt
comma
id|log-&gt;sync
)paren
)paren
suffix:semicolon
id|LOGSYNC_LOCK_INIT
c_func
(paren
id|log
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
suffix:semicolon
id|log-&gt;cqueue.head
op_assign
id|log-&gt;cqueue.tail
op_assign
l_int|0
suffix:semicolon
id|log-&gt;count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * initialize for lazy/group commit&n;&t; */
id|log-&gt;clsn
op_assign
id|lsn
suffix:semicolon
multiline_comment|/*&n;&t; * update/write superblock&n;&t; */
id|logsuper-&gt;state
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGMOUNT
)paren
suffix:semicolon
id|log-&gt;serial
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;serial
)paren
op_plus
l_int|1
suffix:semicolon
id|logsuper-&gt;serial
op_assign
id|cpu_to_le32
c_func
(paren
id|log-&gt;serial
)paren
suffix:semicolon
id|lbmDirectWrite
c_func
(paren
id|log
comma
id|bpsuper
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bpsuper
comma
id|lbmFREE
)paren
)paren
)paren
r_goto
id|errout30
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogInit: exit(%d)&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      unwind on error&n;&t; */
id|errout30
suffix:colon
multiline_comment|/* release log page */
id|lbmFree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|errout20
suffix:colon
multiline_comment|/* release log superblock */
id|lbmFree
c_func
(paren
id|bpsuper
)paren
suffix:semicolon
id|errout10
suffix:colon
multiline_comment|/* unwind lbmLogInit() */
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogInit: exit(%d)&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogClose()&n; *&n; * FUNCTION:&t;remove file system &lt;ipmnt&gt; from active list of log &lt;iplog&gt;&n; *&t;&t;and close it on last close.&n; *&n; * PARAMETER:&t;sb&t;- superblock&n; *&t;&t;log&t;- log inode&n; *&n; * RETURN:&t;errors from subroutines&n; *&n; * serialization:&n; */
DECL|function|lmLogClose
r_int
id|lmLogClose
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|log_t
op_star
id|log
)paren
(brace
r_int
id|rc
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogClose: log:0x%p&bslash;n&quot;
comma
id|log
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      in-line log in host file system&n;&t; */
singleline_comment|//      inlineLog:
macro_line|#ifdef _STILL_TO_PORT
r_if
c_cond
(paren
id|log-&gt;flag
op_amp
id|JFS_INLINELOG
)paren
(brace
id|rc
op_assign
id|lmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
r_goto
id|out1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      external log as separate logical volume&n;&t; */
id|externalLog
suffix:colon
multiline_comment|/* serialize open/close between multiple file systems&n;&t; * associated with the log&n;&t; */
id|IWRITE_LOCK
c_func
(paren
id|iplog
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * remove file system from log active file system list&n;&t; */
id|rc
op_assign
id|lmLogFileSystem
c_func
(paren
id|log
comma
id|fsdev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iplog-&gt;i_count
OG
l_int|1
)paren
r_goto
id|out2
suffix:semicolon
multiline_comment|/*&n;&t; *      last close: shut down log&n;&t; */
id|rc
op_assign
(paren
(paren
id|rc1
op_assign
id|lmLogShutdown
c_func
(paren
id|log
)paren
)paren
op_logical_and
id|rc
op_eq
l_int|0
)paren
ques
c_cond
id|rc1
suffix:colon
id|rc
suffix:semicolon
id|out1
suffix:colon
macro_line|#else&t;&t;&t;&t;/* _STILL_TO_PORT */
id|rc
op_assign
id|lmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
singleline_comment|//      out2:
id|jFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lmLogClose: exit(%d)&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogShutdown()&n; *&n; * FUNCTION:&t;log shutdown at last LogClose().&n; *&n; *&t;&t;write log syncpt record.&n; *&t;&t;update super block to set redone flag to 0.&n; *&n; * PARAMETER:&t;log&t;- log inode&n; *&n; * RETURN:&t;0&t;- success&n; *&t;&t;&t;&n; * serialization: single last close thread&n; */
DECL|function|lmLogShutdown
r_static
r_int
id|lmLogShutdown
c_func
(paren
id|log_t
op_star
id|log
)paren
(brace
r_int
id|rc
suffix:semicolon
id|lrd_t
id|lrd
suffix:semicolon
r_int
id|lsn
suffix:semicolon
id|logsuper_t
op_star
id|logsuper
suffix:semicolon
id|lbuf_t
op_star
id|bpsuper
suffix:semicolon
id|lbuf_t
op_star
id|bp
suffix:semicolon
id|logpage_t
op_star
id|lp
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogShutdown: log:0x%p&bslash;n&quot;
comma
id|log
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;cqueue.head
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If there was very recent activity, we may need to wait&n;&t;&t; * for the lazycommit thread to catch up&n;&t;&t; */
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|800
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Too much? */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|log-&gt;cqueue.head
op_eq
l_int|NULL
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
m_assert
(paren
id|log-&gt;cqueue.head
op_eq
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to make sure all of the &quot;written&quot; metapages&n;&t; * actually make it to disk&n;&t; */
id|fsync_no_super
c_func
(paren
id|log-&gt;sb-&gt;s_bdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * write the last SYNCPT record with syncpoint = 0&n;&t; * (i.e., log redo up to HERE !)&n;&t; */
id|lrd.logtid
op_assign
l_int|0
suffix:semicolon
id|lrd.backchain
op_assign
l_int|0
suffix:semicolon
id|lrd.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd.length
op_assign
l_int|0
suffix:semicolon
id|lrd.log.syncpt.sync
op_assign
l_int|0
suffix:semicolon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
l_int|NULL
comma
op_amp
id|lrd
comma
l_int|NULL
)paren
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_eor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|log-&gt;bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
comma
l_int|0
)paren
suffix:semicolon
id|lbmIOWait
c_func
(paren
id|log-&gt;bp
comma
id|lbmFREE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * synchronous update log superblock&n;&t; * mark log state as shutdown cleanly&n;&t; * (i.e., Log does not need to be replayed).&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
l_int|1
comma
op_amp
id|bpsuper
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|logsuper
op_assign
(paren
id|logsuper_t
op_star
)paren
id|bpsuper-&gt;l_ldata
suffix:semicolon
id|logsuper-&gt;state
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGREDONE
)paren
suffix:semicolon
id|logsuper-&gt;end
op_assign
id|cpu_to_le32
c_func
(paren
id|lsn
)paren
suffix:semicolon
id|lbmDirectWrite
c_func
(paren
id|log
comma
id|bpsuper
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
)paren
suffix:semicolon
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bpsuper
comma
id|lbmFREE
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogShutdown: lsn:0x%x page:%d eor:%d&bslash;n&quot;
comma
id|lsn
comma
id|log-&gt;page
comma
id|log-&gt;eor
)paren
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * shutdown per log i/o&n;&t; */
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lmLogShutdown: exit(%d)&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/*&n; * NAME:&t;lmLogFileSystem()&n; *&n; * FUNCTION:&t;insert (&lt;activate&gt; = true)/remove (&lt;activate&gt; = false)&n; *&t;file system into/from log active file system list.&n; *&n; * PARAMETE:&t;log&t;- pointer to logs inode.&n; *&t;&t;fsdev&t;- dev_t of filesystem.&n; *&t;&t;serial  - pointer to returned log serial number&n; *&t;&t;activate - insert/remove device from active list.&n; *&n; * RETURN:&t;0&t;- success&n; *&t;&t;errors returned by vms_iowait().&n; *&t;&t;&t;&n; * serialization: IWRITE_LOCK(log inode) held on entry/exit&n; */
DECL|function|lmLogFileSystem
r_static
r_int
id|lmLogFileSystem
c_func
(paren
id|log_t
op_star
id|log
comma
id|dev_t
id|fsdev
comma
r_int
id|activate
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|bit
comma
id|word
suffix:semicolon
id|logsuper_t
op_star
id|logsuper
suffix:semicolon
id|lbuf_t
op_star
id|bpsuper
suffix:semicolon
multiline_comment|/*&n;&t; * insert/remove file system device to log active file system list.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
l_int|1
comma
op_amp
id|bpsuper
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|logsuper
op_assign
(paren
id|logsuper_t
op_star
)paren
id|bpsuper-&gt;l_ldata
suffix:semicolon
id|bit
op_assign
id|minor
c_func
(paren
id|fsdev
)paren
suffix:semicolon
id|word
op_assign
id|bit
op_div
l_int|32
suffix:semicolon
id|bit
op_sub_assign
l_int|32
op_star
id|word
suffix:semicolon
r_if
c_cond
(paren
id|activate
)paren
id|logsuper-&gt;active
(braket
id|word
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
(paren
id|LEFTMOSTONE
op_rshift
id|bit
)paren
)paren
suffix:semicolon
r_else
id|logsuper-&gt;active
(braket
id|word
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
(paren
op_complement
(paren
id|LEFTMOSTONE
op_rshift
id|bit
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * synchronous write log superblock:&n;&t; *&n;&t; * write sidestream bypassing write queue:&n;&t; * at file system mount, log super block is updated for&n;&t; * activation of the file system before any log record&n;&t; * (MOUNT record) of the file system, and at file system&n;&t; * unmount, all meta data for the file system has been&n;&t; * flushed before log super block is updated for deactivation&n;&t; * of the file system.&n;&t; */
id|lbmDirectWrite
c_func
(paren
id|log
comma
id|bpsuper
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
)paren
suffix:semicolon
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bpsuper
comma
id|lbmFREE
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
multiline_comment|/*&n; *&t;lmLogQuiesce()&n; */
DECL|function|lmLogQuiesce
r_int
id|lmLogQuiesce
c_func
(paren
id|log_t
op_star
id|log
)paren
(brace
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|lmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lmLogResume()&n; */
DECL|function|lmLogResume
r_int
id|lmLogResume
c_func
(paren
id|log_t
op_star
id|log
comma
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|log-&gt;base
op_assign
id|addressPXD
c_func
(paren
op_amp
id|sbi-&gt;logpxd
)paren
suffix:semicolon
id|log-&gt;size
op_assign
(paren
id|lengthPXD
c_func
(paren
op_amp
id|sbi-&gt;logpxd
)paren
op_lshift
id|sb-&gt;s_blocksize_bits
)paren
op_rshift
id|L2LOGPSIZE
suffix:semicolon
id|rc
op_assign
id|lmLogInit
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;&t;log buffer manager (lbm)&n; *&t;&t;------------------------&n; *&n; * special purpose buffer manager supporting log i/o requirements.&n; *&n; * per log write queue:&n; * log pageout occurs in serial order by fifo write queue and&n; * restricting to a single i/o in pregress at any one time.&n; * a circular singly-linked list&n; * (log-&gt;wrqueue points to the tail, and buffers are linked via&n; * bp-&gt;wrqueue field), and&n; * maintains log page in pageout ot waiting for pageout in serial pageout.&n; */
multiline_comment|/*&n; *&t;lbmLogInit()&n; *&n; * initialize per log I/O setup at lmLogInit()&n; */
DECL|function|lbmLogInit
r_static
r_int
id|lbmLogInit
c_func
(paren
id|log_t
op_star
id|log
)paren
(brace
multiline_comment|/* log inode */
r_int
id|i
suffix:semicolon
id|lbuf_t
op_star
id|lbuf
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmLogInit: log:0x%p&bslash;n&quot;
comma
id|log
)paren
)paren
suffix:semicolon
multiline_comment|/* initialize current buffer cursor */
id|log-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* initialize log device write queue */
id|log-&gt;wqueue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Each log has its own buffer pages allocated to it.  These are&n;&t; * not managed by the page cache.  This ensures that a transaction&n;&t; * writing to the log does not block trying to allocate a page from&n;&t; * the page cache (for the log).  This would be bad, since page&n;&t; * allocation waits on the kswapd thread that may be committing inodes&n;&t; * which would cause log activity.  Was that clear?  I&squot;m trying to&n;&t; * avoid deadlock here.&n;&t; */
id|init_waitqueue_head
c_func
(paren
op_amp
id|log-&gt;free_wait
)paren
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LOGPAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lbuf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|lbuf_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbuf
op_eq
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|lbuf-&gt;l_ldata
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbuf-&gt;l_ldata
op_eq
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|lbuf
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|lbuf-&gt;l_log
op_assign
id|log
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|lbuf-&gt;l_ioevent
)paren
suffix:semicolon
id|lbuf-&gt;l_freelist
op_assign
id|log-&gt;lbuf_free
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
id|lbuf
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error
suffix:colon
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmLogShutdown()&n; *&n; * finalize per log I/O setup at lmLogShutdown()&n; */
DECL|function|lbmLogShutdown
r_static
r_void
id|lbmLogShutdown
c_func
(paren
id|log_t
op_star
id|log
)paren
(brace
id|lbuf_t
op_star
id|lbuf
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmLogShutdown: log:0x%p&bslash;n&quot;
comma
id|log
)paren
)paren
suffix:semicolon
id|lbuf
op_assign
id|log-&gt;lbuf_free
suffix:semicolon
r_while
c_loop
(paren
id|lbuf
)paren
(brace
id|lbuf_t
op_star
id|next
op_assign
id|lbuf-&gt;l_freelist
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|lbuf-&gt;l_ldata
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lbuf
)paren
suffix:semicolon
id|lbuf
op_assign
id|next
suffix:semicolon
)brace
id|log-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmAllocate()&n; *&n; * allocate an empty log buffer&n; */
DECL|function|lbmAllocate
r_static
id|lbuf_t
op_star
id|lbmAllocate
c_func
(paren
id|log_t
op_star
id|log
comma
r_int
id|pn
)paren
(brace
id|lbuf_t
op_star
id|bp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * recycle from log buffer freelist if any&n;&t; */
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|LCACHE_SLEEP_COND
c_func
(paren
id|log-&gt;free_wait
comma
(paren
id|bp
op_assign
id|log-&gt;lbuf_free
)paren
comma
id|flags
)paren
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
id|bp-&gt;l_freelist
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|bp-&gt;l_flag
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;l_freelist
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;l_pn
op_assign
id|pn
suffix:semicolon
id|bp-&gt;l_blkno
op_assign
id|log-&gt;base
op_plus
(paren
id|pn
op_lshift
(paren
id|L2LOGPSIZE
op_minus
id|log-&gt;l2bsize
)paren
)paren
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
l_int|0
suffix:semicolon
r_return
id|bp
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmFree()&n; *&n; * release a log buffer to freelist&n; */
DECL|function|lbmFree
r_static
r_void
id|lbmFree
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|lbmfree
r_static
r_void
id|lbmfree
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
(brace
id|log_t
op_star
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
m_assert
(paren
id|bp-&gt;l_wqnext
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * return the buffer to head of freelist&n;&t; */
id|bp-&gt;l_freelist
op_assign
id|log-&gt;lbuf_free
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
id|bp
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|log-&gt;free_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef _THIS_IS_NOT_USED
multiline_comment|/*&n; *&t;lbmRelease()&n; *&n; * remove the log buffer from log device write queue;&n; */
DECL|function|lbmRelease
r_static
r_void
id|lbmRelease
c_func
(paren
id|log_t
op_star
id|log
comma
id|uint
id|flag
)paren
(brace
id|lbuf_t
op_star
id|bp
comma
op_star
id|tail
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|tail
op_assign
id|log-&gt;wqueue
suffix:semicolon
multiline_comment|/* single element queue */
r_if
c_cond
(paren
id|bp
op_eq
id|tail
)paren
(brace
id|log-&gt;wqueue
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* multi element queue */
r_else
(brace
id|tail-&gt;l_wqnext
op_assign
id|bp-&gt;l_wqnext
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|lbmFREE
)paren
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _THIS_IS_NOT_USED */
multiline_comment|/*&n; * NAME:&t;lbmRedrive&n; *&n; * FUNCTION:&t;add a log buffer to the the log redrive list&n; *&n; * PARAMETER:&n; *     bp&t;- log buffer&n; *&n; * NOTES:&n; *&t;Takes log_redrive_lock.&n; */
DECL|function|lbmRedrive
r_static
r_inline
r_void
id|lbmRedrive
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|log_redrive_lock
comma
id|flags
)paren
suffix:semicolon
id|bp-&gt;l_redrive_next
op_assign
id|log_redrive_list
suffix:semicolon
id|log_redrive_list
op_assign
id|bp
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log_redrive_lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|jfsIOtask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmRead()&n; */
DECL|function|lbmRead
r_static
r_int
id|lbmRead
c_func
(paren
id|log_t
op_star
id|log
comma
r_int
id|pn
comma
id|lbuf_t
op_star
op_star
id|bpp
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|lbuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a log buffer&n;&t; */
op_star
id|bpp
op_assign
id|bp
op_assign
id|lbmAllocate
c_func
(paren
id|log
comma
id|pn
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmRead: bp:0x%p pn:0x%x&bslash;n&quot;
comma
id|bp
comma
id|pn
)paren
)paren
suffix:semicolon
id|bp-&gt;l_flag
op_or_assign
id|lbmREAD
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOFS
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|bp-&gt;l_blkno
op_lshift
(paren
id|log-&gt;l2bsize
op_minus
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_dev
op_assign
id|log-&gt;dev
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
op_assign
id|virt_to_page
c_func
(paren
id|bp-&gt;l_ldata
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_len
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
l_int|1
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|lbmIODone
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|bp
suffix:semicolon
id|submit_bio
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|bp-&gt;l_ioevent
comma
(paren
id|bp-&gt;l_flag
op_ne
id|lbmREAD
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmWrite()&n; *&n; * buffer at head of pageout queue stays after completion of&n; * partial-page pageout and redriven by explicit initiation of&n; * pageout by caller until full-page pageout is completed and&n; * released.&n; *&n; * device driver i/o done redrives pageout of new buffer at&n; * head of pageout queue when current buffer at head of pageout&n; * queue is released at the completion of its full-page pageout.&n; *&n; * LOGGC_LOCK() serializes lbmWrite() by lmNextPage() and lmGroupCommit().&n; * LCACHE_LOCK() serializes xflag between lbmWrite() and lbmIODone()&n; */
DECL|function|lbmWrite
r_static
r_void
id|lbmWrite
c_func
(paren
id|log_t
op_star
id|log
comma
id|lbuf_t
op_star
id|bp
comma
r_int
id|flag
comma
r_int
id|cant_block
)paren
(brace
id|lbuf_t
op_star
id|tail
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmWrite: bp:0x%p flag:0x%x pn:0x%x&bslash;n&quot;
comma
id|bp
comma
id|flag
comma
id|bp-&gt;l_pn
)paren
)paren
suffix:semicolon
multiline_comment|/* map the logical block address to physical block address */
id|bp-&gt;l_blkno
op_assign
id|log-&gt;base
op_plus
(paren
id|bp-&gt;l_pn
op_lshift
(paren
id|L2LOGPSIZE
op_minus
id|log-&gt;l2bsize
)paren
)paren
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* disable+lock */
multiline_comment|/*&n;&t; * initialize buffer for device driver&n;&t; */
id|bp-&gt;l_flag
op_assign
id|flag
suffix:semicolon
multiline_comment|/*&n;&t; *      insert bp at tail of write queue associated with log&n;&t; *&n;&t; * (request is either for bp already/currently at head of queue&n;&t; * or new bp to be inserted at tail)&n;&t; */
id|tail
op_assign
id|log-&gt;wqueue
suffix:semicolon
multiline_comment|/* is buffer not already on write queue ? */
r_if
c_cond
(paren
id|bp-&gt;l_wqnext
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* insert at tail of wqueue */
r_if
c_cond
(paren
id|tail
op_eq
l_int|NULL
)paren
(brace
id|log-&gt;wqueue
op_assign
id|bp
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
id|bp
suffix:semicolon
)brace
r_else
(brace
id|log-&gt;wqueue
op_assign
id|bp
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
id|tail-&gt;l_wqnext
suffix:semicolon
id|tail-&gt;l_wqnext
op_assign
id|bp
suffix:semicolon
)brace
id|tail
op_assign
id|bp
suffix:semicolon
)brace
multiline_comment|/* is buffer at head of wqueue and for write ? */
r_if
c_cond
(paren
(paren
id|bp
op_ne
id|tail-&gt;l_wqnext
)paren
op_logical_or
op_logical_neg
(paren
id|flag
op_amp
id|lbmWRITE
)paren
)paren
(brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
r_return
suffix:semicolon
)brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
r_if
c_cond
(paren
id|cant_block
)paren
id|lbmRedrive
c_func
(paren
id|bp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|lbmSYNC
)paren
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
r_else
(brace
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;lbmDirectWrite()&n; *&n; * initiate pageout bypassing write queue for sidestream&n; * (e.g., log superblock) write;&n; */
DECL|function|lbmDirectWrite
r_static
r_void
id|lbmDirectWrite
c_func
(paren
id|log_t
op_star
id|log
comma
id|lbuf_t
op_star
id|bp
comma
r_int
id|flag
)paren
(brace
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x&bslash;n&quot;
comma
id|bp
comma
id|flag
comma
id|bp-&gt;l_pn
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize buffer for device driver&n;&t; */
id|bp-&gt;l_flag
op_assign
id|flag
op_or
id|lbmDIRECT
suffix:semicolon
multiline_comment|/* map the logical block address to physical block address */
id|bp-&gt;l_blkno
op_assign
id|log-&gt;base
op_plus
(paren
id|bp-&gt;l_pn
op_lshift
(paren
id|L2LOGPSIZE
op_minus
id|log-&gt;l2bsize
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      initiate pageout of the page&n;&t; */
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lbmStartIO()&n; *&n; * FUNCTION:&t;Interface to DD strategy routine&n; *&n; * RETURN:      none&n; *&n; * serialization: LCACHE_LOCK() is NOT held during log i/o;&n; */
DECL|function|lbmStartIO
r_void
id|lbmStartIO
c_func
(paren
id|lbuf_t
op_star
id|bp
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
id|log_t
op_star
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmStartIO&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOFS
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|bp-&gt;l_blkno
op_lshift
(paren
id|log-&gt;l2bsize
op_minus
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_dev
op_assign
id|log-&gt;dev
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
op_assign
id|virt_to_page
c_func
(paren
id|bp-&gt;l_ldata
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_len
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
l_int|1
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|lbmIODone
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|bp
suffix:semicolon
id|submit_bio
c_func
(paren
id|WRITE
comma
id|bio
)paren
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.submitted
)paren
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmStartIO done&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmIOWait()&n; */
DECL|function|lbmIOWait
r_static
r_int
id|lbmIOWait
c_func
(paren
id|lbuf_t
op_star
id|bp
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmIOWait1: bp:0x%p flag:0x%x:0x%x&bslash;n&quot;
comma
id|bp
comma
id|bp-&gt;l_flag
comma
id|flag
)paren
)paren
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* disable+lock */
id|LCACHE_SLEEP_COND
c_func
(paren
id|bp-&gt;l_ioevent
comma
(paren
id|bp-&gt;l_flag
op_amp
id|lbmDONE
)paren
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
(paren
id|bp-&gt;l_flag
op_amp
id|lbmERROR
)paren
ques
c_cond
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|lbmFREE
)paren
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmIOWait2: bp:0x%p flag:0x%x:0x%x&bslash;n&quot;
comma
id|bp
comma
id|bp-&gt;l_flag
comma
id|flag
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmIODone()&n; *&n; * executed at INTIODONE level&n; */
DECL|function|lbmIODone
r_static
r_void
id|lbmIODone
c_func
(paren
r_struct
id|bio
op_star
id|bio
)paren
(brace
id|lbuf_t
op_star
id|bp
op_assign
id|bio-&gt;bi_private
suffix:semicolon
id|lbuf_t
op_star
id|nextbp
comma
op_star
id|tail
suffix:semicolon
id|log_t
op_star
id|log
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * get back jfs buffer bound to the i/o buffer&n;&t; */
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lbmIODone: bp:0x%p flag:0x%x&bslash;n&quot;
comma
id|bp
comma
id|bp-&gt;l_flag
)paren
)paren
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* disable+lock */
id|bp-&gt;l_flag
op_or_assign
id|lbmDONE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
)paren
(brace
id|bp-&gt;l_flag
op_or_assign
id|lbmERROR
suffix:semicolon
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;lbmIODone: I/O error in JFS log&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      pagein completion&n;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmREAD
)paren
(brace
id|bp-&gt;l_flag
op_and_assign
op_complement
id|lbmREAD
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
multiline_comment|/* wakeup I/O initiator */
id|LCACHE_WAKEUP
c_func
(paren
op_amp
id|bp-&gt;l_ioevent
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      pageout completion&n;&t; *&n;&t; * the bp at the head of write queue has completed pageout.&n;&t; *&n;&t; * if single-commit/full-page pageout, remove the current buffer&n;&t; * from head of pageout queue, and redrive pageout with&n;&t; * the new buffer at head of pageout queue;&n;&t; * otherwise, the partial-page pageout buffer stays at&n;&t; * the head of pageout queue to be redriven for pageout&n;&t; * by lmGroupCommit() until full-page pageout is completed.&n;&t; */
id|bp-&gt;l_flag
op_and_assign
op_complement
id|lbmWRITE
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.pagedone
)paren
suffix:semicolon
multiline_comment|/* update committed lsn */
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
id|log-&gt;clsn
op_assign
(paren
id|bp-&gt;l_pn
op_lshift
id|L2LOGPSIZE
)paren
op_plus
id|bp-&gt;l_ceor
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmDIRECT
)paren
(brace
id|LCACHE_WAKEUP
c_func
(paren
op_amp
id|bp-&gt;l_ioevent
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tail
op_assign
id|log-&gt;wqueue
suffix:semicolon
multiline_comment|/* single element queue */
r_if
c_cond
(paren
id|bp
op_eq
id|tail
)paren
(brace
multiline_comment|/* remove head buffer of full-page pageout&n;&t;&t; * from log device write queue&n;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmRELEASE
)paren
(brace
id|log-&gt;wqueue
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* multi element queue */
r_else
(brace
multiline_comment|/* remove head buffer of full-page pageout&n;&t;&t; * from log device write queue&n;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmRELEASE
)paren
(brace
id|nextbp
op_assign
id|tail-&gt;l_wqnext
op_assign
id|bp-&gt;l_wqnext
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * redrive pageout of next page at head of write queue:&n;&t;&t;&t; * redrive next page without any bound tblk&n;&t;&t;&t; * (i.e., page w/o any COMMIT records), or&n;&t;&t;&t; * first page of new group commit which has been&n;&t;&t;&t; * queued after current page (subsequent pageout&n;&t;&t;&t; * is performed synchronously, except page without&n;&t;&t;&t; * any COMMITs) by lmGroupCommit() as indicated&n;&t;&t;&t; * by lbmWRITE flag;&n;&t;&t;&t; */
r_if
c_cond
(paren
id|nextbp-&gt;l_flag
op_amp
id|lbmWRITE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We can&squot;t do the I/O at interrupt time.&n;&t;&t;&t;&t; * The jfsIO thread can do it&n;&t;&t;&t;&t; */
id|lbmRedrive
c_func
(paren
id|nextbp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *      synchronous pageout:&n;&t; *&n;&t; * buffer has not necessarily been removed from write queue&n;&t; * (e.g., synchronous write of partial-page with COMMIT):&n;&t; * leave buffer for i/o initiator to dispose&n;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmSYNC
)paren
(brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
multiline_comment|/* wakeup I/O initiator */
id|LCACHE_WAKEUP
c_func
(paren
op_amp
id|bp-&gt;l_ioevent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      Group Commit pageout:&n;&t; */
r_else
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmGC
)paren
(brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lmPostGC
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      asynchronous pageout:&n;&t; *&n;&t; * buffer must have been removed from write queue:&n;&t; * insert buffer at head of freelist where it can be recycled&n;&t; */
r_else
(brace
m_assert
(paren
id|bp-&gt;l_flag
op_amp
id|lbmRELEASE
)paren
suffix:semicolon
m_assert
(paren
id|bp-&gt;l_flag
op_amp
id|lbmFREE
)paren
suffix:semicolon
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
)brace
r_return
suffix:semicolon
)brace
DECL|function|jfsIOWait
r_int
id|jfsIOWait
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|lbuf_t
op_star
id|bp
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfsIOWait is here!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;jfsIO&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|jfsIOtask
op_assign
id|current
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGHUP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGCONT
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|jfsIOwait
)paren
suffix:semicolon
r_do
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bp
op_assign
id|log_redrive_list
)paren
)paren
(brace
id|log_redrive_list
op_assign
id|bp-&gt;l_redrive_next
suffix:semicolon
id|bp-&gt;l_redrive_next
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|jfs_thread_stopped
c_func
(paren
)paren
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfsIOWait being killed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|jfsIOwait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/*&n; *&t;lbmDirectIODone()&n; *&n; * iodone() for lbmDirectWrite() to bypass write queue;&n; * executed at INTIODONE level;&n; */
DECL|function|lbmDirectIODone
r_static
r_void
id|lbmDirectIODone
c_func
(paren
id|iobuf_t
op_star
id|iobp
)paren
(brace
id|lbuf_t
op_star
id|bp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * get back jfs buffer bound to the io buffer&n;&t; */
id|bp
op_assign
(paren
id|lbuf_t
op_star
)paren
id|iobp-&gt;b_jfsbp
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lbmDirectIODone: bp:0x%p flag:0x%x&bslash;n&quot;
comma
id|bp
comma
id|bp-&gt;l_flag
)paren
)paren
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* disable+lock */
id|bp-&gt;l_flag
op_or_assign
id|lbmDONE
suffix:semicolon
r_if
c_cond
(paren
id|iobp-&gt;b_flags
op_amp
id|B_ERROR
)paren
(brace
id|bp-&gt;l_flag
op_or_assign
id|lbmERROR
suffix:semicolon
macro_line|#ifdef _JFS_OS2
id|SysLogError
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; *      pageout completion&n;&t; */
id|bp-&gt;l_flag
op_and_assign
op_complement
id|lbmWRITE
suffix:semicolon
multiline_comment|/*&n;&t; *      synchronous pageout:&n;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmSYNC
)paren
(brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
multiline_comment|/* wakeup I/O initiator */
id|LCACHE_WAKEUP
c_func
(paren
op_amp
id|bp-&gt;l_ioevent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      asynchronous pageout:&n;&t; */
r_else
(brace
m_assert
(paren
id|bp-&gt;l_flag
op_amp
id|lbmRELEASE
)paren
suffix:semicolon
m_assert
(paren
id|bp-&gt;l_flag
op_amp
id|lbmFREE
)paren
suffix:semicolon
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/*&n; * NAME:&t;lmLogFormat()/jfs_logform()&n; *&n; * FUNCTION:&t;format file system log (ref. jfs_logform()).&n; *&n; * PARAMETERS:&n; *&t;log&t;- log inode (with common mount inode base);&n; *&t;logAddress - start address of log space in FS block;&n; *&t;logSize&t;- length of log space in FS block;&n; *&n; * RETURN:&t;0 -&t;success&n; *&t;&t;-1 -&t;i/o error&n; */
DECL|function|lmLogFormat
r_int
id|lmLogFormat
c_func
(paren
id|inode_t
op_star
id|ipmnt
comma
id|s64
id|logAddress
comma
r_int
id|logSize
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|cbuf_t
op_star
id|bp
suffix:semicolon
id|logsuper_t
op_star
id|logsuper
suffix:semicolon
id|logpage_t
op_star
id|lp
suffix:semicolon
r_int
id|lspn
suffix:semicolon
multiline_comment|/* log sequence page number */
r_struct
id|lrd
op_star
id|lrd_ptr
suffix:semicolon
r_int
id|npbperpage
comma
id|npages
suffix:semicolon
id|jFYI
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;lmLogFormat: logAddress:%Ld logSize:%d&bslash;n&quot;
comma
id|logAddress
comma
id|logSize
)paren
)paren
suffix:semicolon
multiline_comment|/* allocate a JFS buffer */
id|bp
op_assign
id|rawAllocate
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* map the logical block address to physical block address */
id|bp-&gt;cm_blkno
op_assign
id|logAddress
op_lshift
id|ipmnt-&gt;i_l2bfactor
suffix:semicolon
id|npbperpage
op_assign
id|LOGPSIZE
op_rshift
id|ipmnt-&gt;i_l2pbsize
suffix:semicolon
id|npages
op_assign
id|logSize
op_div
(paren
id|LOGPSIZE
op_rshift
id|ipmnt-&gt;i_l2bsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      log space:&n;&t; *&n;&t; * page 0 - reserved;&n;&t; * page 1 - log superblock;&n;&t; * page 2 - log data page: A SYNC log record is written&n;&t; *          into this page at logform time;&n;&t; * pages 3-N - log data page: set to empty log data pages;&n;&t; */
multiline_comment|/*&n;&t; *      init log superblock: log page 1&n;&t; */
id|logsuper
op_assign
(paren
id|logsuper_t
op_star
)paren
id|bp-&gt;cm_cdata
suffix:semicolon
id|logsuper-&gt;magic
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGMAGIC
)paren
suffix:semicolon
id|logsuper-&gt;version
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGVERSION
)paren
suffix:semicolon
id|logsuper-&gt;state
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGREDONE
)paren
suffix:semicolon
id|logsuper-&gt;flag
op_assign
id|cpu_to_le32
c_func
(paren
id|ipmnt-&gt;i_mntflag
)paren
suffix:semicolon
multiline_comment|/* ? */
id|logsuper-&gt;size
op_assign
id|cpu_to_le32
c_func
(paren
id|npages
)paren
suffix:semicolon
id|logsuper-&gt;bsize
op_assign
id|cpu_to_le32
c_func
(paren
id|ipmnt-&gt;i_bsize
)paren
suffix:semicolon
id|logsuper-&gt;l2bsize
op_assign
id|cpu_to_le32
c_func
(paren
id|ipmnt-&gt;i_l2bsize
)paren
suffix:semicolon
id|logsuper-&gt;end
op_assign
id|cpu_to_le32
c_func
(paren
l_int|2
op_star
id|LOGPSIZE
op_plus
id|LOGPHDRSIZE
op_plus
id|LOGRDSIZE
)paren
suffix:semicolon
id|bp-&gt;cm_blkno
op_add_assign
id|npbperpage
suffix:semicolon
id|rawWrite
c_func
(paren
id|ipmnt
comma
id|bp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      init pages 2 to npages-1 as log data pages:&n;&t; *&n;&t; * log page sequence number (lpsn) initialization:&n;&t; *&n;&t; * pn:   0     1     2     3                 n-1&n;&t; *       +-----+-----+=====+=====+===.....===+=====+&n;&t; * lspn:             N-1   0     1           N-2&n;&t; *                   &lt;--- N page circular file ----&gt;&n;&t; *&n;&t; * the N (= npages-2) data pages of the log is maintained as&n;&t; * a circular file for the log records;&n;&t; * lpsn grows by 1 monotonically as each log page is written&n;&t; * to the circular file of the log;&n;&t; * Since the AIX DUMMY log record is dropped for this XJFS,&n;&t; * and setLogpage() will not reset the page number even if&n;&t; * the eor is equal to LOGPHDRSIZE. In order for binary search&n;&t; * still work in find log end process, we have to simulate the&n;&t; * log wrap situation at the log format time.&n;&t; * The 1st log page written will have the highest lpsn. Then&n;&t; * the succeeding log pages will have ascending order of&n;&t; * the lspn starting from 0, ... (N-2)&n;&t; */
id|lp
op_assign
(paren
id|logpage_t
op_star
)paren
id|bp-&gt;cm_cdata
suffix:semicolon
multiline_comment|/*&n;&t; * initialize 1st log page to be written: lpsn = N - 1,&n;&t; * write a SYNCPT log record is written to this page&n;&t; */
id|lp-&gt;h.page
op_assign
id|lp-&gt;t.page
op_assign
id|cpu_to_le32
c_func
(paren
id|npages
op_minus
l_int|3
)paren
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|LOGPHDRSIZE
op_plus
id|LOGRDSIZE
)paren
suffix:semicolon
id|lrd_ptr
op_assign
(paren
r_struct
id|lrd
op_star
)paren
op_amp
id|lp-&gt;data
suffix:semicolon
id|lrd_ptr-&gt;logtid
op_assign
l_int|0
suffix:semicolon
id|lrd_ptr-&gt;backchain
op_assign
l_int|0
suffix:semicolon
id|lrd_ptr-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd_ptr-&gt;length
op_assign
l_int|0
suffix:semicolon
id|lrd_ptr-&gt;log.syncpt.sync
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;cm_blkno
op_add_assign
id|npbperpage
suffix:semicolon
id|rawWrite
c_func
(paren
id|ipmnt
comma
id|bp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      initialize succeeding log pages: lpsn = 0, 1, ..., (N-2)&n;&t; */
r_for
c_loop
(paren
id|lspn
op_assign
l_int|0
suffix:semicolon
id|lspn
OL
id|npages
op_minus
l_int|3
suffix:semicolon
id|lspn
op_increment
)paren
(brace
id|lp-&gt;h.page
op_assign
id|lp-&gt;t.page
op_assign
id|cpu_to_le32
c_func
(paren
id|lspn
)paren
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|LOGPHDRSIZE
)paren
suffix:semicolon
id|bp-&gt;cm_blkno
op_add_assign
id|npbperpage
suffix:semicolon
id|rawWrite
c_func
(paren
id|ipmnt
comma
id|bp
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      finalize log&n;&t; */
multiline_comment|/* release the buffer */
id|rawRelease
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
macro_line|#ifdef CONFIG_JFS_STATISTICS
DECL|function|jfs_lmstats_read
r_int
id|jfs_lmstats_read
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;JFS Logmgr stats&bslash;n&quot;
l_string|&quot;================&bslash;n&quot;
l_string|&quot;commits = %d&bslash;n&quot;
l_string|&quot;writes submitted = %d&bslash;n&quot;
l_string|&quot;writes completed = %d&bslash;n&quot;
comma
id|lmStat.commit
comma
id|lmStat.submitted
comma
id|lmStat.pagedone
)paren
suffix:semicolon
id|begin
op_assign
id|offset
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|begin
suffix:semicolon
id|len
op_sub_assign
id|begin
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_else
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_JFS_STATISTICS */
eof
