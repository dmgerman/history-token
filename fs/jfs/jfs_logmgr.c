multiline_comment|/*&n; *   Copyright (C) International Business Machines Corp., 2000-2004&n; *   Portions Copyright (C) Christoph Hellwig, 2001-2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
multiline_comment|/*&n; *&t;jfs_logmgr.c: log manager&n; *&n; * for related information, see transaction manager (jfs_txnmgr.c), and&n; * recovery manager (jfs_logredo.c).&n; *&n; * note: for detail, RTFS.&n; *&n; *&t;log buffer manager:&n; * special purpose buffer manager supporting log i/o requirements.&n; * per log serial pageout of logpage&n; * queuing i/o requests and redrive i/o at iodone&n; * maintain current logpage buffer&n; * no caching since append only&n; * appropriate jfs buffer cache buffers as needed&n; *&n; *&t;group commit:&n; * transactions which wrote COMMIT records in the same in-memory&n; * log page during the pageout of previous/current log page(s) are&n; * committed together by the pageout of the page.&n; *&n; *&t;TBD lazy commit:&n; * transactions are committed asynchronously when the log page&n; * containing it COMMIT is paged out when it becomes full;&n; *&n; *&t;serialization:&n; * . a per log lock serialize log write.&n; * . a per log lock serialize group commit.&n; * . a per log lock serialize log open/close;&n; *&n; *&t;TBD log integrity:&n; * careful-write (ping-pong) of last logpage to recover from crash&n; * in overwrite.&n; * detection of split (out-of-order) write of physical sectors&n; * of last logpage via timestamp at end of each sector&n; * with its mirror data array at trailer).&n; *&n; *&t;alternatives:&n; * lsn - 64-bit monotonically increasing integer vs&n; * 32-bit lspn and page eor.&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;&t;&t;/* for sync_blockdev() */
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_filsys.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_txnmgr.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/*&n; * lbuf&squot;s ready to be redriven.  Protected by log_redrive_lock (jfsIO thread)&n; */
DECL|variable|log_redrive_list
r_static
r_struct
id|lbuf
op_star
id|log_redrive_list
suffix:semicolon
DECL|variable|log_redrive_lock
r_static
id|spinlock_t
id|log_redrive_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|jfs_IO_thread_wait
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|jfs_IO_thread_wait
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;log read/write serialization (per log)&n; */
DECL|macro|LOG_LOCK_INIT
mdefine_line|#define LOG_LOCK_INIT(log)&t;init_MUTEX(&amp;(log)-&gt;loglock)
DECL|macro|LOG_LOCK
mdefine_line|#define LOG_LOCK(log)&t;&t;down(&amp;((log)-&gt;loglock))
DECL|macro|LOG_UNLOCK
mdefine_line|#define LOG_UNLOCK(log)&t;&t;up(&amp;((log)-&gt;loglock))
multiline_comment|/*&n; *&t;log group commit serialization (per log)&n; */
DECL|macro|LOGGC_LOCK_INIT
mdefine_line|#define LOGGC_LOCK_INIT(log)&t;spin_lock_init(&amp;(log)-&gt;gclock)
DECL|macro|LOGGC_LOCK
mdefine_line|#define LOGGC_LOCK(log)&t;&t;spin_lock_irq(&amp;(log)-&gt;gclock)
DECL|macro|LOGGC_UNLOCK
mdefine_line|#define LOGGC_UNLOCK(log)&t;spin_unlock_irq(&amp;(log)-&gt;gclock)
DECL|macro|LOGGC_WAKEUP
mdefine_line|#define LOGGC_WAKEUP(tblk)&t;wake_up_all(&amp;(tblk)-&gt;gcwait)
multiline_comment|/*&n; *&t;log sync serialization (per log)&n; */
DECL|macro|LOGSYNC_DELTA
mdefine_line|#define&t;LOGSYNC_DELTA(logsize)&t;&t;min((logsize)/8, 128*LOGPSIZE)
DECL|macro|LOGSYNC_BARRIER
mdefine_line|#define&t;LOGSYNC_BARRIER(logsize)&t;((logsize)/4)
multiline_comment|/*&n;#define&t;LOGSYNC_DELTA(logsize)&t;&t;min((logsize)/4, 256*LOGPSIZE)&n;#define&t;LOGSYNC_BARRIER(logsize)&t;((logsize)/2)&n;*/
multiline_comment|/*&n; *&t;log buffer cache synchronization&n; */
DECL|variable|jfsLCacheLock
r_static
id|spinlock_t
id|jfsLCacheLock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|LCACHE_LOCK
mdefine_line|#define&t;LCACHE_LOCK(flags)&t;spin_lock_irqsave(&amp;jfsLCacheLock, flags)
DECL|macro|LCACHE_UNLOCK
mdefine_line|#define&t;LCACHE_UNLOCK(flags)&t;spin_unlock_irqrestore(&amp;jfsLCacheLock, flags)
multiline_comment|/*&n; * See __SLEEP_COND in jfs_locks.h&n; */
DECL|macro|LCACHE_SLEEP_COND
mdefine_line|#define LCACHE_SLEEP_COND(wq, cond, flags)&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (cond)&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&bslash;&n;&t;__SLEEP_COND(wq, cond, LCACHE_LOCK(flags), LCACHE_UNLOCK(flags)); &bslash;&n;} while (0)
DECL|macro|LCACHE_WAKEUP
mdefine_line|#define&t;LCACHE_WAKEUP(event)&t;wake_up(event)
multiline_comment|/*&n; *&t;lbuf buffer cache (lCache) control&n; */
multiline_comment|/* log buffer manager pageout control (cumulative, inclusive) */
DECL|macro|lbmREAD
mdefine_line|#define&t;lbmREAD&t;&t;0x0001
DECL|macro|lbmWRITE
mdefine_line|#define&t;lbmWRITE&t;0x0002&t;/* enqueue at tail of write queue;&n;&t;&t;&t;&t; * init pageout if at head of queue;&n;&t;&t;&t;&t; */
DECL|macro|lbmRELEASE
mdefine_line|#define&t;lbmRELEASE&t;0x0004&t;/* remove from write queue&n;&t;&t;&t;&t; * at completion of pageout;&n;&t;&t;&t;&t; * do not free/recycle it yet:&n;&t;&t;&t;&t; * caller will free it;&n;&t;&t;&t;&t; */
DECL|macro|lbmSYNC
mdefine_line|#define&t;lbmSYNC&t;&t;0x0008&t;/* do not return to freelist&n;&t;&t;&t;&t; * when removed from write queue;&n;&t;&t;&t;&t; */
DECL|macro|lbmFREE
mdefine_line|#define lbmFREE&t;&t;0x0010&t;/* return to freelist&n;&t;&t;&t;&t; * at completion of pageout;&n;&t;&t;&t;&t; * the buffer may be recycled;&n;&t;&t;&t;&t; */
DECL|macro|lbmDONE
mdefine_line|#define&t;lbmDONE&t;&t;0x0020
DECL|macro|lbmERROR
mdefine_line|#define&t;lbmERROR&t;0x0040
DECL|macro|lbmGC
mdefine_line|#define lbmGC&t;&t;0x0080&t;/* lbmIODone to perform post-GC processing&n;&t;&t;&t;&t; * of log page&n;&t;&t;&t;&t; */
DECL|macro|lbmDIRECT
mdefine_line|#define lbmDIRECT&t;0x0100
multiline_comment|/*&n; * Global list of active external journals&n; */
DECL|variable|jfs_external_logs
id|LIST_HEAD
c_func
(paren
id|jfs_external_logs
)paren
suffix:semicolon
DECL|variable|dummy_log
r_struct
id|jfs_log
op_star
id|dummy_log
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|jfs_log_sem
id|DECLARE_MUTEX
c_func
(paren
id|jfs_log_sem
)paren
suffix:semicolon
multiline_comment|/*&n; * external references&n; */
r_extern
r_void
id|txLazyUnlock
c_func
(paren
r_struct
id|tblock
op_star
id|tblk
)paren
suffix:semicolon
r_extern
r_int
id|jfs_stop_threads
suffix:semicolon
r_extern
r_struct
id|completion
id|jfsIOwait
suffix:semicolon
multiline_comment|/*&n; * forward references&n; */
r_static
r_int
id|lmWriteRecord
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|tblock
op_star
id|tblk
comma
r_struct
id|lrd
op_star
id|lrd
comma
r_struct
id|tlock
op_star
id|tlck
)paren
suffix:semicolon
r_static
r_int
id|lmNextPage
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
suffix:semicolon
r_static
r_int
id|lmLogFileSystem
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|jfs_sb_info
op_star
id|sbi
comma
r_int
id|activate
)paren
suffix:semicolon
r_static
r_int
id|open_inline_log
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
suffix:semicolon
r_static
r_int
id|open_dummy_log
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
suffix:semicolon
r_static
r_int
id|lbmLogInit
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
suffix:semicolon
r_static
r_void
id|lbmLogShutdown
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
suffix:semicolon
r_static
r_struct
id|lbuf
op_star
id|lbmAllocate
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|lbmFree
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
suffix:semicolon
r_static
r_void
id|lbmfree
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|lbmRead
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|pn
comma
r_struct
id|lbuf
op_star
op_star
id|bpp
)paren
suffix:semicolon
r_static
r_void
id|lbmWrite
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|lbuf
op_star
id|bp
comma
r_int
id|flag
comma
r_int
id|cant_block
)paren
suffix:semicolon
r_static
r_void
id|lbmDirectWrite
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|lbuf
op_star
id|bp
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_int
id|lbmIOWait
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
comma
r_int
id|flag
)paren
suffix:semicolon
DECL|variable|lbmIODone
r_static
id|bio_end_io_t
id|lbmIODone
suffix:semicolon
r_static
r_void
id|lbmStartIO
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
suffix:semicolon
r_static
r_void
id|lmGCwrite
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|cant_block
)paren
suffix:semicolon
r_static
r_int
id|lmLogSync
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|nosyncwait
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;statistics&n; */
macro_line|#ifdef CONFIG_JFS_STATISTICS
DECL|struct|lmStat
r_struct
id|lmStat
(brace
DECL|member|commit
id|uint
id|commit
suffix:semicolon
multiline_comment|/* # of commit */
DECL|member|pagedone
id|uint
id|pagedone
suffix:semicolon
multiline_comment|/* # of page written */
DECL|member|submitted
id|uint
id|submitted
suffix:semicolon
multiline_comment|/* # of pages submitted */
DECL|member|full_page
id|uint
id|full_page
suffix:semicolon
multiline_comment|/* # of full pages submitted */
DECL|member|partial_page
id|uint
id|partial_page
suffix:semicolon
multiline_comment|/* # of partial pages submitted */
DECL|variable|lmStat
)brace
id|lmStat
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * NAME:&t;lmLog()&n; *&n; * FUNCTION:&t;write a log record;&n; *&n; * PARAMETER:&n; *&n; * RETURN:&t;lsn - offset to the next log record to write (end-of-log);&n; *&t;&t;-1  - error;&n; *&n; * note: todo: log error handler&n; */
DECL|function|lmLog
r_int
id|lmLog
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|tblock
op_star
id|tblk
comma
r_struct
id|lrd
op_star
id|lrd
comma
r_struct
id|tlock
op_star
id|tlck
)paren
(brace
r_int
id|lsn
suffix:semicolon
r_int
id|diffp
comma
id|difft
suffix:semicolon
r_struct
id|metapage
op_star
id|mp
op_assign
l_int|NULL
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLog: log:0x%p tblk:0x%p, lrd:0x%p tlck:0x%p&quot;
comma
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
suffix:semicolon
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* log by (out-of-transaction) JFS ? */
r_if
c_cond
(paren
id|tblk
op_eq
l_int|NULL
)paren
r_goto
id|writeRecord
suffix:semicolon
multiline_comment|/* log from page ? */
r_if
c_cond
(paren
id|tlck
op_eq
l_int|NULL
op_logical_or
id|tlck-&gt;type
op_amp
id|tlckBTROOT
op_logical_or
(paren
id|mp
op_assign
id|tlck-&gt;mp
)paren
op_eq
l_int|NULL
)paren
r_goto
id|writeRecord
suffix:semicolon
multiline_comment|/*&n;&t; *      initialize/update page/transaction recovery lsn&n;&t; */
id|lsn
op_assign
id|log-&gt;lsn
suffix:semicolon
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize page lsn if first log write of the page&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;lsn
op_eq
l_int|0
)paren
(brace
id|mp-&gt;log
op_assign
id|log
suffix:semicolon
id|mp-&gt;lsn
op_assign
id|lsn
suffix:semicolon
id|log-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* insert page at tail of logsynclist */
id|list_add_tail
c_func
(paren
op_amp
id|mp-&gt;synclist
comma
op_amp
id|log-&gt;synclist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      initialize/update lsn of tblock of the page&n;&t; *&n;&t; * transaction inherits oldest lsn of pages associated&n;&t; * with allocation/deallocation of resources (their&n;&t; * log records are used to reconstruct allocation map&n;&t; * at recovery time: inode for inode allocation map,&n;&t; * B+-tree index of extent descriptors for block&n;&t; * allocation map);&n;&t; * allocation map pages inherit transaction lsn at&n;&t; * commit time to allow forwarding log syncpt past log&n;&t; * records associated with allocation/deallocation of&n;&t; * resources only after persistent map of these map pages&n;&t; * have been updated and propagated to home.&n;&t; */
multiline_comment|/*&n;&t; * initialize transaction lsn:&n;&t; */
r_if
c_cond
(paren
id|tblk-&gt;lsn
op_eq
l_int|0
)paren
(brace
multiline_comment|/* inherit lsn of its first page logged */
id|tblk-&gt;lsn
op_assign
id|mp-&gt;lsn
suffix:semicolon
id|log-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* insert tblock after the page on logsynclist */
id|list_add
c_func
(paren
op_amp
id|tblk-&gt;synclist
comma
op_amp
id|mp-&gt;synclist
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * update transaction lsn:&n;&t; */
r_else
(brace
multiline_comment|/* inherit oldest/smallest lsn of page */
id|logdiff
c_func
(paren
id|diffp
comma
id|mp-&gt;lsn
comma
id|log
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|difft
comma
id|tblk-&gt;lsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diffp
OL
id|difft
)paren
(brace
multiline_comment|/* update tblock lsn with page lsn */
id|tblk-&gt;lsn
op_assign
id|mp-&gt;lsn
suffix:semicolon
multiline_comment|/* move tblock after page on logsynclist */
id|list_move
c_func
(paren
op_amp
id|tblk-&gt;synclist
comma
op_amp
id|mp-&gt;synclist
)paren
suffix:semicolon
)brace
)brace
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      write the log record&n;&t; */
id|writeRecord
suffix:colon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * forward log syncpt if log reached next syncpt trigger&n;&t; */
id|logdiff
c_func
(paren
id|diffp
comma
id|lsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diffp
op_ge
id|log-&gt;nextsync
)paren
id|lsn
op_assign
id|lmLogSync
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* update end-of-log lsn */
id|log-&gt;lsn
op_assign
id|lsn
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* return end-of-log address */
r_return
id|lsn
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmWriteRecord()&n; *&n; * FUNCTION:&t;move the log record to current log page&n; *&n; * PARAMETER:&t;cd&t;- commit descriptor&n; *&n; * RETURN:&t;end-of-log address&n; *&t;&t;&t;&n; * serialization: LOG_LOCK() held on entry/exit&n; */
r_static
r_int
DECL|function|lmWriteRecord
id|lmWriteRecord
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|tblock
op_star
id|tblk
comma
r_struct
id|lrd
op_star
id|lrd
comma
r_struct
id|tlock
op_star
id|tlck
)paren
(brace
r_int
id|lsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end-of-log address */
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
multiline_comment|/* dst log page buffer */
r_struct
id|logpage
op_star
id|lp
suffix:semicolon
multiline_comment|/* dst log page */
id|caddr_t
id|dst
suffix:semicolon
multiline_comment|/* destination address in log page */
r_int
id|dstoffset
suffix:semicolon
multiline_comment|/* end-of-log offset in log page */
r_int
id|freespace
suffix:semicolon
multiline_comment|/* free space in log page */
id|caddr_t
id|p
suffix:semicolon
multiline_comment|/* src meta-data page */
id|caddr_t
id|src
suffix:semicolon
r_int
id|srclen
suffix:semicolon
r_int
id|nbytes
suffix:semicolon
multiline_comment|/* number of bytes to move */
r_int
id|i
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|linelock
op_star
id|linelock
suffix:semicolon
r_struct
id|lv
op_star
id|lv
suffix:semicolon
r_struct
id|lvd
op_star
id|lvd
suffix:semicolon
r_int
id|l2linesize
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* retrieve destination log page to write */
id|bp
op_assign
(paren
r_struct
id|lbuf
op_star
)paren
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|log-&gt;eor
suffix:semicolon
multiline_comment|/* any log data to write ? */
r_if
c_cond
(paren
id|tlck
op_eq
l_int|NULL
)paren
r_goto
id|moveLrd
suffix:semicolon
multiline_comment|/*&n;&t; *      move log record data&n;&t; */
multiline_comment|/* retrieve source meta-data page to log */
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckPAGELOCK
)paren
(brace
id|p
op_assign
(paren
id|caddr_t
)paren
(paren
id|tlck-&gt;mp-&gt;data
)paren
suffix:semicolon
id|linelock
op_assign
(paren
r_struct
id|linelock
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
multiline_comment|/* retrieve source in-memory inode to log */
r_else
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckINODELOCK
)paren
(brace
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckDTREE
)paren
id|p
op_assign
(paren
id|caddr_t
)paren
op_amp
id|JFS_IP
c_func
(paren
id|tlck-&gt;ip
)paren
op_member_access_from_pointer
id|i_dtroot
suffix:semicolon
r_else
id|p
op_assign
(paren
id|caddr_t
)paren
op_amp
id|JFS_IP
c_func
(paren
id|tlck-&gt;ip
)paren
op_member_access_from_pointer
id|i_xtroot
suffix:semicolon
id|linelock
op_assign
(paren
r_struct
id|linelock
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
)brace
macro_line|#ifdef&t;_JFS_WIP
r_else
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckINLINELOCK
)paren
(brace
id|inlinelock
op_assign
(paren
r_struct
id|inlinelock
op_star
)paren
op_amp
id|tlck
suffix:semicolon
id|p
op_assign
(paren
id|caddr_t
)paren
op_amp
id|inlinelock-&gt;pxd
suffix:semicolon
id|linelock
op_assign
(paren
r_struct
id|linelock
op_star
)paren
op_amp
id|tlck
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_WIP */
r_else
(brace
id|jfs_err
c_func
(paren
l_string|&quot;lmWriteRecord: UFO tlck:0x%p&quot;
comma
id|tlck
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Probably should trap */
)brace
id|l2linesize
op_assign
id|linelock-&gt;l2linesize
suffix:semicolon
id|moveData
suffix:colon
id|ASSERT
c_func
(paren
id|linelock-&gt;index
op_le
id|linelock-&gt;maxcnt
)paren
suffix:semicolon
id|lv
op_assign
id|linelock-&gt;lv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linelock-&gt;index
suffix:semicolon
id|i
op_increment
comma
id|lv
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lv-&gt;length
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* is page full ? */
r_if
c_cond
(paren
id|dstoffset
op_ge
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
(brace
multiline_comment|/* page become full: move on to next page */
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|LOGPHDRSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * move log vector data&n;&t;&t; */
id|src
op_assign
(paren
id|u8
op_star
)paren
id|p
op_plus
(paren
id|lv-&gt;offset
op_lshift
id|l2linesize
)paren
suffix:semicolon
id|srclen
op_assign
id|lv-&gt;length
op_lshift
id|l2linesize
suffix:semicolon
id|len
op_add_assign
id|srclen
suffix:semicolon
r_while
c_loop
(paren
id|srclen
OG
l_int|0
)paren
(brace
id|freespace
op_assign
(paren
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
op_minus
id|dstoffset
suffix:semicolon
id|nbytes
op_assign
id|min
c_func
(paren
id|freespace
comma
id|srclen
)paren
suffix:semicolon
id|dst
op_assign
(paren
id|caddr_t
)paren
id|lp
op_plus
id|dstoffset
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|nbytes
)paren
suffix:semicolon
id|dstoffset
op_add_assign
id|nbytes
suffix:semicolon
multiline_comment|/* is page not full ? */
r_if
c_cond
(paren
id|dstoffset
OL
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
r_break
suffix:semicolon
multiline_comment|/* page become full: move on to next page */
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
id|bp
op_assign
(paren
r_struct
id|lbuf
op_star
)paren
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|LOGPHDRSIZE
suffix:semicolon
id|srclen
op_sub_assign
id|nbytes
suffix:semicolon
id|src
op_add_assign
id|nbytes
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * move log vector descriptor&n;&t;&t; */
id|len
op_add_assign
l_int|4
suffix:semicolon
id|lvd
op_assign
(paren
r_struct
id|lvd
op_star
)paren
(paren
(paren
id|caddr_t
)paren
id|lp
op_plus
id|dstoffset
)paren
suffix:semicolon
id|lvd-&gt;offset
op_assign
id|cpu_to_le16
c_func
(paren
id|lv-&gt;offset
)paren
suffix:semicolon
id|lvd-&gt;length
op_assign
id|cpu_to_le16
c_func
(paren
id|lv-&gt;length
)paren
suffix:semicolon
id|dstoffset
op_add_assign
l_int|4
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmWriteRecord: lv offset:%d length:%d&quot;
comma
id|lv-&gt;offset
comma
id|lv-&gt;length
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_assign
id|linelock-&gt;next
)paren
)paren
(brace
id|linelock
op_assign
(paren
r_struct
id|linelock
op_star
)paren
id|lid_to_tlock
c_func
(paren
id|i
)paren
suffix:semicolon
r_goto
id|moveData
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      move log record descriptor&n;&t; */
id|moveLrd
suffix:colon
id|lrd-&gt;length
op_assign
id|cpu_to_le16
c_func
(paren
id|len
)paren
suffix:semicolon
id|src
op_assign
(paren
id|caddr_t
)paren
id|lrd
suffix:semicolon
id|srclen
op_assign
id|LOGRDSIZE
suffix:semicolon
r_while
c_loop
(paren
id|srclen
OG
l_int|0
)paren
(brace
id|freespace
op_assign
(paren
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
op_minus
id|dstoffset
suffix:semicolon
id|nbytes
op_assign
id|min
c_func
(paren
id|freespace
comma
id|srclen
)paren
suffix:semicolon
id|dst
op_assign
(paren
id|caddr_t
)paren
id|lp
op_plus
id|dstoffset
suffix:semicolon
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|nbytes
)paren
suffix:semicolon
id|dstoffset
op_add_assign
id|nbytes
suffix:semicolon
id|srclen
op_sub_assign
id|nbytes
suffix:semicolon
multiline_comment|/* are there more to move than freespace of page ? */
r_if
c_cond
(paren
id|srclen
)paren
r_goto
id|pageFull
suffix:semicolon
multiline_comment|/*&n;&t;&t; * end of log record descriptor&n;&t;&t; */
multiline_comment|/* update last log record eor */
id|log-&gt;eor
op_assign
id|dstoffset
suffix:semicolon
id|bp-&gt;l_eor
op_assign
id|dstoffset
suffix:semicolon
id|lsn
op_assign
(paren
id|log-&gt;page
op_lshift
id|L2LOGPSIZE
)paren
op_plus
id|dstoffset
suffix:semicolon
r_if
c_cond
(paren
id|lrd-&gt;type
op_amp
id|cpu_to_le16
c_func
(paren
id|LOG_COMMIT
)paren
)paren
(brace
id|tblk-&gt;clsn
op_assign
id|lsn
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;wr: tclsn:0x%x, beor:0x%x&quot;
comma
id|tblk-&gt;clsn
comma
id|bp-&gt;l_eor
)paren
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.commit
)paren
suffix:semicolon
multiline_comment|/* # of commit */
multiline_comment|/*&n;&t;&t;&t; * enqueue tblock for group commit:&n;&t;&t;&t; *&n;&t;&t;&t; * enqueue tblock of non-trivial/synchronous COMMIT&n;&t;&t;&t; * at tail of group commit queue&n;&t;&t;&t; * (trivial/asynchronous COMMITs are ignored by&n;&t;&t;&t; * group commit.)&n;&t;&t;&t; */
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* init tblock gc state */
id|tblk-&gt;flag
op_assign
id|tblkGC_QUEUE
suffix:semicolon
id|tblk-&gt;bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|tblk-&gt;pn
op_assign
id|log-&gt;page
suffix:semicolon
id|tblk-&gt;eor
op_assign
id|log-&gt;eor
suffix:semicolon
multiline_comment|/* enqueue transaction to commit queue */
id|tblk-&gt;cqnext
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;cqueue.head
)paren
(brace
id|log-&gt;cqueue.tail-&gt;cqnext
op_assign
id|tblk
suffix:semicolon
id|log-&gt;cqueue.tail
op_assign
id|tblk
suffix:semicolon
)brace
r_else
id|log-&gt;cqueue.head
op_assign
id|log-&gt;cqueue.tail
op_assign
id|tblk
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
id|jfs_info
c_func
(paren
l_string|&quot;lmWriteRecord: lrd:0x%04x bp:0x%p pn:%d eor:0x%x&quot;
comma
id|le16_to_cpu
c_func
(paren
id|lrd-&gt;type
)paren
comma
id|log-&gt;bp
comma
id|log-&gt;page
comma
id|dstoffset
)paren
suffix:semicolon
multiline_comment|/* page not full ? */
r_if
c_cond
(paren
id|dstoffset
OL
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
r_return
id|lsn
suffix:semicolon
id|pageFull
suffix:colon
multiline_comment|/* page become full: move on to next page */
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
id|bp
op_assign
(paren
r_struct
id|lbuf
op_star
)paren
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|dstoffset
op_assign
id|LOGPHDRSIZE
suffix:semicolon
id|src
op_add_assign
id|nbytes
suffix:semicolon
)brace
r_return
id|lsn
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmNextPage()&n; *&n; * FUNCTION:&t;write current page and allocate next page.&n; *&n; * PARAMETER:&t;log&n; *&n; * RETURN:&t;0&n; *&t;&t;&t;&n; * serialization: LOG_LOCK() held on entry/exit&n; */
DECL|function|lmNextPage
r_static
r_int
id|lmNextPage
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
(brace
r_struct
id|logpage
op_star
id|lp
suffix:semicolon
r_int
id|lspn
suffix:semicolon
multiline_comment|/* log sequence page number */
r_int
id|pn
suffix:semicolon
multiline_comment|/* current page number */
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
r_struct
id|lbuf
op_star
id|nextbp
suffix:semicolon
r_struct
id|tblock
op_star
id|tblk
suffix:semicolon
multiline_comment|/* get current log page number and log sequence page number */
id|pn
op_assign
id|log-&gt;page
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|lspn
op_assign
id|le32_to_cpu
c_func
(paren
id|lp-&gt;h.page
)paren
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      write or queue the full page at the tail of write queue&n;&t; */
multiline_comment|/* get the tail tblk on commit queue */
id|tblk
op_assign
id|log-&gt;cqueue.tail
suffix:semicolon
multiline_comment|/* every tblk who has COMMIT record on the current page,&n;&t; * and has not been committed, must be on commit queue&n;&t; * since tblk is queued at commit queueu at the time&n;&t; * of writing its COMMIT record on the page before&n;&t; * page becomes full (even though the tblk thread&n;&t; * who wrote COMMIT record may have been suspended&n;&t; * currently);&n;&t; */
multiline_comment|/* is page bound with outstanding tail tblk ? */
r_if
c_cond
(paren
id|tblk
op_logical_and
id|tblk-&gt;pn
op_eq
id|pn
)paren
(brace
multiline_comment|/* mark tblk for end-of-page */
id|tblk-&gt;flag
op_or_assign
id|tblkGC_EOP
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;cflag
op_amp
id|logGC_PAGEOUT
)paren
(brace
multiline_comment|/* if page is not already on write queue,&n;&t;&t;&t; * just enqueue (no lbmWRITE to prevent redrive)&n;&t;&t;&t; * buffer to wqueue to ensure correct serial order&n;&t;&t;&t; * of the pages since log pages will be added&n;&t;&t;&t; * continuously&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_wqnext
op_eq
l_int|NULL
)paren
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * No current GC leader, initiate group commit&n;&t;&t;&t; */
id|log-&gt;cflag
op_or_assign
id|logGC_PAGEOUT
suffix:semicolon
id|lmGCwrite
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* page is not bound with outstanding tblk:&n;&t; * init write or mark it to be redriven (lbmWRITE)&n;&t; */
r_else
(brace
multiline_comment|/* finalize the page */
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_ceor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmFREE
comma
l_int|0
)paren
suffix:semicolon
)brace
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      allocate/initialize next page&n;&t; */
multiline_comment|/* if log wraps, the first data page of log is 2&n;&t; * (0 never used, 1 is superblock).&n;&t; */
id|log-&gt;page
op_assign
(paren
id|pn
op_eq
id|log-&gt;size
op_minus
l_int|1
)paren
ques
c_cond
l_int|2
suffix:colon
id|pn
op_plus
l_int|1
suffix:semicolon
id|log-&gt;eor
op_assign
id|LOGPHDRSIZE
suffix:semicolon
multiline_comment|/* ? valid page empty/full at logRedo() */
multiline_comment|/* allocate/initialize next log page buffer */
id|nextbp
op_assign
id|lbmAllocate
c_func
(paren
id|log
comma
id|log-&gt;page
)paren
suffix:semicolon
id|nextbp-&gt;l_eor
op_assign
id|log-&gt;eor
suffix:semicolon
id|log-&gt;bp
op_assign
id|nextbp
suffix:semicolon
multiline_comment|/* initialize next log page */
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|nextbp-&gt;l_ldata
suffix:semicolon
id|lp-&gt;h.page
op_assign
id|lp-&gt;t.page
op_assign
id|cpu_to_le32
c_func
(paren
id|lspn
op_plus
l_int|1
)paren
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|LOGPHDRSIZE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmGroupCommit()&n; *&n; * FUNCTION:&t;group commit&n; *&t;initiate pageout of the pages with COMMIT in the order of&n; *&t;page number - redrive pageout of the page at the head of&n; *&t;pageout queue until full page has been written.&n; *&n; * RETURN:&t;&n; *&n; * NOTE:&n; *&t;LOGGC_LOCK serializes log group commit queue, and&n; *&t;transaction blocks on the commit queue.&n; *&t;N.B. LOG_LOCK is NOT held during lmGroupCommit().&n; */
DECL|function|lmGroupCommit
r_int
id|lmGroupCommit
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|tblock
op_star
id|tblk
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* group committed already ? */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMITTED
)paren
(brace
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_ERROR
)paren
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|jfs_info
c_func
(paren
l_string|&quot;lmGroup Commit: tblk = 0x%p, gcrtc = %d&quot;
comma
id|tblk
comma
id|log-&gt;gcrtc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_LAZY
)paren
id|tblk-&gt;flag
op_or_assign
id|tblkGC_LAZY
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|log-&gt;cflag
op_amp
id|logGC_PAGEOUT
)paren
)paren
op_logical_and
id|log-&gt;cqueue.head
op_logical_and
(paren
op_logical_neg
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_LAZY
)paren
op_logical_or
id|test_bit
c_func
(paren
id|log_FLUSH
comma
op_amp
id|log-&gt;flag
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * No pageout in progress&n;&t;&t; *&n;&t;&t; * start group commit as its group leader.&n;&t;&t; */
id|log-&gt;cflag
op_or_assign
id|logGC_PAGEOUT
suffix:semicolon
id|lmGCwrite
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_LAZY
)paren
(brace
multiline_comment|/*&n;&t;&t; * Lazy transactions can leave now&n;&t;&t; */
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lmGCwrite gives up LOGGC_LOCK, check again */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMITTED
)paren
(brace
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_ERROR
)paren
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* upcount transaction waiting for completion&n;&t; */
id|log-&gt;gcrtc
op_increment
suffix:semicolon
id|tblk-&gt;flag
op_or_assign
id|tblkGC_READY
suffix:semicolon
id|__SLEEP_COND
c_func
(paren
id|tblk-&gt;gcwait
comma
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMITTED
)paren
comma
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
comma
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
)paren
suffix:semicolon
multiline_comment|/* removed from commit queue */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_ERROR
)paren
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmGCwrite()&n; *&n; * FUNCTION:&t;group commit write&n; *&t;initiate write of log page, building a group of all transactions&n; *&t;with commit records on that page.&n; *&n; * RETURN:&t;None&n; *&n; * NOTE:&n; *&t;LOGGC_LOCK must be held by caller.&n; *&t;N.B. LOG_LOCK is NOT held during lmGroupCommit().&n; */
DECL|function|lmGCwrite
r_static
r_void
id|lmGCwrite
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|cant_write
)paren
(brace
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
r_struct
id|logpage
op_star
id|lp
suffix:semicolon
r_int
id|gcpn
suffix:semicolon
multiline_comment|/* group commit page number */
r_struct
id|tblock
op_star
id|tblk
suffix:semicolon
r_struct
id|tblock
op_star
id|xtblk
suffix:semicolon
multiline_comment|/*&n;&t; * build the commit group of a log page&n;&t; *&n;&t; * scan commit queue and make a commit group of all&n;&t; * transactions with COMMIT records on the same log page.&n;&t; */
multiline_comment|/* get the head tblk on the commit queue */
id|tblk
op_assign
id|xtblk
op_assign
id|log-&gt;cqueue.head
suffix:semicolon
id|gcpn
op_assign
id|tblk-&gt;pn
suffix:semicolon
r_while
c_loop
(paren
id|tblk
op_logical_and
id|tblk-&gt;pn
op_eq
id|gcpn
)paren
(brace
id|xtblk
op_assign
id|tblk
suffix:semicolon
multiline_comment|/* state transition: (QUEUE, READY) -&gt; COMMIT */
id|tblk-&gt;flag
op_or_assign
id|tblkGC_COMMIT
suffix:semicolon
id|tblk
op_assign
id|tblk-&gt;cqnext
suffix:semicolon
)brace
id|tblk
op_assign
id|xtblk
suffix:semicolon
multiline_comment|/* last tblk of the page */
multiline_comment|/*&n;&t; * pageout to commit transactions on the log page.&n;&t; */
id|bp
op_assign
(paren
r_struct
id|lbuf
op_star
)paren
id|tblk-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
multiline_comment|/* is page already full ? */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_EOP
)paren
(brace
multiline_comment|/* mark page to free at end of group commit of the page */
id|tblk-&gt;flag
op_and_assign
op_complement
id|tblkGC_EOP
suffix:semicolon
id|tblk-&gt;flag
op_or_assign
id|tblkGC_FREE
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_ceor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmGC
comma
id|cant_write
)paren
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.full_page
)paren
suffix:semicolon
)brace
multiline_comment|/* page is not yet full */
r_else
(brace
id|bp-&gt;l_ceor
op_assign
id|tblk-&gt;eor
suffix:semicolon
multiline_comment|/* ? bp-&gt;l_ceor = bp-&gt;l_eor; */
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_ceor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmGC
comma
id|cant_write
)paren
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.partial_page
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NAME:&t;lmPostGC()&n; *&n; * FUNCTION:&t;group commit post-processing&n; *&t;Processes transactions after their commit records have been written&n; *&t;to disk, redriving log I/O if necessary.&n; *&n; * RETURN:&t;None&n; *&n; * NOTE:&n; *&t;This routine is called a interrupt time by lbmIODone&n; */
DECL|function|lmPostGC
r_static
r_void
id|lmPostGC
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|jfs_log
op_star
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
r_struct
id|logpage
op_star
id|lp
suffix:semicolon
r_struct
id|tblock
op_star
id|tblk
suffix:semicolon
singleline_comment|//LOGGC_LOCK(log);
id|spin_lock_irqsave
c_func
(paren
op_amp
id|log-&gt;gclock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * current pageout of group commit completed.&n;&t; *&n;&t; * remove/wakeup transactions from commit queue who were&n;&t; * group committed with the current log page&n;&t; */
r_while
c_loop
(paren
(paren
id|tblk
op_assign
id|log-&gt;cqueue.head
)paren
op_logical_and
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_COMMIT
)paren
)paren
(brace
multiline_comment|/* if transaction was marked GC_COMMIT then&n;&t;&t; * it has been shipped in the current pageout&n;&t;&t; * and made it to disk - it is committed.&n;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmERROR
)paren
id|tblk-&gt;flag
op_or_assign
id|tblkGC_ERROR
suffix:semicolon
multiline_comment|/* remove it from the commit queue */
id|log-&gt;cqueue.head
op_assign
id|tblk-&gt;cqnext
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;cqueue.head
op_eq
l_int|NULL
)paren
id|log-&gt;cqueue.tail
op_assign
l_int|NULL
suffix:semicolon
id|tblk-&gt;flag
op_and_assign
op_complement
id|tblkGC_QUEUE
suffix:semicolon
id|tblk-&gt;cqnext
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tblk
op_eq
id|log-&gt;flush_tblk
)paren
(brace
multiline_comment|/* we can stop flushing the log now */
id|clear_bit
c_func
(paren
id|log_FLUSH
comma
op_amp
id|log-&gt;flag
)paren
suffix:semicolon
id|log-&gt;flush_tblk
op_assign
l_int|NULL
suffix:semicolon
)brace
id|jfs_info
c_func
(paren
l_string|&quot;lmPostGC: tblk = 0x%p, flag = 0x%x&quot;
comma
id|tblk
comma
id|tblk-&gt;flag
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_FORCE
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Hand tblk over to lazy commit thread&n;&t;&t;&t; */
id|txLazyUnlock
c_func
(paren
id|tblk
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* state transition: COMMIT -&gt; COMMITTED */
id|tblk-&gt;flag
op_or_assign
id|tblkGC_COMMITTED
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_READY
)paren
id|log-&gt;gcrtc
op_decrement
suffix:semicolon
id|LOGGC_WAKEUP
c_func
(paren
id|tblk
)paren
suffix:semicolon
)brace
multiline_comment|/* was page full before pageout ?&n;&t;&t; * (and this is the last tblk bound with the page)&n;&t;&t; */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_FREE
)paren
id|lbmFree
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* did page become full after pageout ?&n;&t;&t; * (and this is the last tblk bound with the page)&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_EOP
)paren
(brace
multiline_comment|/* finalize the page */
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_eor
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmPostGC: calling lbmWrite&quot;
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmFREE
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* are there any transactions who have entered lnGroupCommit()&n;&t; * (whose COMMITs are after that of the last log page written.&n;&t; * They are waiting for new group commit (above at (SLEEP 1))&n;&t; * or lazy transactions are on a full (queued) log page,&n;&t; * select the latest ready transaction as new group leader and&n;&t; * wake her up to lead her group.&n;&t; */
r_if
c_cond
(paren
(paren
id|tblk
op_assign
id|log-&gt;cqueue.head
)paren
op_logical_and
(paren
(paren
id|log-&gt;gcrtc
OG
l_int|0
)paren
op_logical_or
(paren
id|tblk-&gt;bp-&gt;l_wqnext
op_ne
l_int|NULL
)paren
op_logical_or
id|test_bit
c_func
(paren
id|log_FLUSH
comma
op_amp
id|log-&gt;flag
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t; * Call lmGCwrite with new group leader&n;&t;&t; */
id|lmGCwrite
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* no transaction are ready yet (transactions are only just&n;&t; * queued (GC_QUEUE) and not entered for group commit yet).&n;&t; * the first transaction entering group commit&n;&t; * will elect herself as new group leader.&n;&t; */
r_else
id|log-&gt;cflag
op_and_assign
op_complement
id|logGC_PAGEOUT
suffix:semicolon
singleline_comment|//LOGGC_UNLOCK(log);
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log-&gt;gclock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogSync()&n; *&n; * FUNCTION:&t;write log SYNCPT record for specified log&n; *&t;if new sync address is available&n; *&t;(normally the case if sync() is executed by back-ground&n; *&t;process).&n; *&t;if not, explicitly run jfs_blogsync() to initiate&n; *&t;getting of new sync address.&n; *&t;calculate new value of i_nextsync which determines when&n; *&t;this code is called again.&n; *&n; *&t;this is called only from lmLog().&n; *&n; * PARAMETER:&t;ip&t;- pointer to logs inode.&n; *&n; * RETURN:&t;0&n; *&t;&t;&t;&n; * serialization: LOG_LOCK() held on entry/exit&n; */
DECL|function|lmLogSync
r_static
r_int
id|lmLogSync
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|nosyncwait
)paren
(brace
r_int
id|logsize
suffix:semicolon
r_int
id|written
suffix:semicolon
multiline_comment|/* written since last syncpt */
r_int
id|free
suffix:semicolon
multiline_comment|/* free space left available */
r_int
id|delta
suffix:semicolon
multiline_comment|/* additional delta to write normally */
r_int
id|more
suffix:semicolon
multiline_comment|/* additional write granted */
r_struct
id|lrd
id|lrd
suffix:semicolon
r_int
id|lsn
suffix:semicolon
r_struct
id|logsyncblk
op_star
id|lp
suffix:semicolon
multiline_comment|/*&n;&t; *      forward syncpt&n;&t; */
multiline_comment|/* if last sync is same as last syncpt,&n;&t; * invoke sync point forward processing to update sync.&n;&t; */
r_if
c_cond
(paren
id|log-&gt;sync
op_eq
id|log-&gt;syncpt
)paren
(brace
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* ToDo: push dirty metapages out to disk */
singleline_comment|//              bmLogSync(log);
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
id|log-&gt;sync
op_assign
id|log-&gt;lsn
suffix:semicolon
r_else
(brace
id|lp
op_assign
id|list_entry
c_func
(paren
id|log-&gt;synclist.next
comma
r_struct
id|logsyncblk
comma
id|synclist
)paren
suffix:semicolon
id|log-&gt;sync
op_assign
id|lp-&gt;lsn
suffix:semicolon
)brace
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
multiline_comment|/* if sync is different from last syncpt,&n;&t; * write a SYNCPT record with syncpt = sync.&n;&t; * reset syncpt = sync&n;&t; */
r_if
c_cond
(paren
id|log-&gt;sync
op_ne
id|log-&gt;syncpt
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to make sure all of the &quot;written&quot; metapages&n;&t;&t; * actually make it to disk&n;&t;&t; */
id|list_for_each_entry
c_func
(paren
id|sbi
comma
op_amp
id|log-&gt;sb_list
comma
id|log_list
)paren
(brace
id|filemap_fdatawrite
c_func
(paren
id|sbi-&gt;ipbmap-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawrite
c_func
(paren
id|sbi-&gt;ipimap-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawrite
c_func
(paren
id|sbi-&gt;sb-&gt;s_bdev-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
)brace
id|list_for_each_entry
c_func
(paren
id|sbi
comma
op_amp
id|log-&gt;sb_list
comma
id|log_list
)paren
(brace
id|filemap_fdatawait
c_func
(paren
id|sbi-&gt;ipbmap-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|sbi-&gt;ipimap-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|sbi-&gt;sb-&gt;s_bdev-&gt;bd_inode-&gt;i_mapping
)paren
suffix:semicolon
)brace
id|lrd.logtid
op_assign
l_int|0
suffix:semicolon
id|lrd.backchain
op_assign
l_int|0
suffix:semicolon
id|lrd.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd.length
op_assign
l_int|0
suffix:semicolon
id|lrd.log.syncpt.sync
op_assign
id|cpu_to_le32
c_func
(paren
id|log-&gt;sync
)paren
suffix:semicolon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
l_int|NULL
comma
op_amp
id|lrd
comma
l_int|NULL
)paren
suffix:semicolon
id|log-&gt;syncpt
op_assign
id|log-&gt;sync
suffix:semicolon
)brace
r_else
id|lsn
op_assign
id|log-&gt;lsn
suffix:semicolon
multiline_comment|/*&n;&t; *      setup next syncpt trigger (SWAG)&n;&t; */
id|logsize
op_assign
id|log-&gt;logsize
suffix:semicolon
id|logdiff
c_func
(paren
id|written
comma
id|lsn
comma
id|log
)paren
suffix:semicolon
id|free
op_assign
id|logsize
op_minus
id|written
suffix:semicolon
id|delta
op_assign
id|LOGSYNC_DELTA
c_func
(paren
id|logsize
)paren
suffix:semicolon
id|more
op_assign
id|min
c_func
(paren
id|free
op_div
l_int|2
comma
id|delta
)paren
suffix:semicolon
r_if
c_cond
(paren
id|more
OL
l_int|2
op_star
id|LOGPSIZE
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;&bslash;n ... Log Wrap ... Log Wrap ... Log Wrap ...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      log wrapping&n;&t;&t; *&n;&t;&t; * option 1 - panic ? No.!&n;&t;&t; * option 2 - shutdown file systems&n;&t;&t; *            associated with log ?&n;&t;&t; * option 3 - extend log ?&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * option 4 - second chance&n;&t;&t; *&n;&t;&t; * mark log wrapped, and continue.&n;&t;&t; * when all active transactions are completed,&n;&t;&t; * mark log vaild for recovery.&n;&t;&t; * if crashed during invalid state, log state&n;&t;&t; * implies invald log, forcing fsck().&n;&t;&t; */
multiline_comment|/* mark log state log wrap in log superblock */
multiline_comment|/* log-&gt;state = LOGWRAP; */
multiline_comment|/* reset sync point computation */
id|log-&gt;syncpt
op_assign
id|log-&gt;sync
op_assign
id|lsn
suffix:semicolon
id|log-&gt;nextsync
op_assign
id|delta
suffix:semicolon
)brace
r_else
multiline_comment|/* next syncpt trigger = written + more */
id|log-&gt;nextsync
op_assign
id|written
op_plus
id|more
suffix:semicolon
multiline_comment|/* return if lmLogSync() from outside of transaction, e.g., sync() */
r_if
c_cond
(paren
id|nosyncwait
)paren
r_return
id|lsn
suffix:semicolon
multiline_comment|/* if number of bytes written from last sync point is more&n;&t; * than 1/4 of the log size, stop new transactions from&n;&t; * starting until all current transactions are completed&n;&t; * by setting syncbarrier flag.&n;&t; */
r_if
c_cond
(paren
id|written
OG
id|LOGSYNC_BARRIER
c_func
(paren
id|logsize
)paren
op_logical_and
id|logsize
OG
l_int|32
op_star
id|LOGPSIZE
)paren
(brace
id|set_bit
c_func
(paren
id|log_SYNCBARRIER
comma
op_amp
id|log-&gt;flag
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;log barrier on: lsn=0x%x syncpt=0x%x&quot;
comma
id|lsn
comma
id|log-&gt;syncpt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We may have to initiate group commit&n;&t;&t; */
id|jfs_flush_journal
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|lsn
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogOpen()&n; *&n; * FUNCTION:    open the log on first open;&n; *&t;insert filesystem in the active list of the log.&n; *&n; * PARAMETER:&t;ipmnt&t;- file system mount inode&n; *&t;&t;iplog &t;- log inode (out)&n; *&n; * RETURN:&n; *&n; * serialization:&n; */
DECL|function|lmLogOpen
r_int
id|lmLogOpen
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_struct
id|jfs_log
op_star
id|log
suffix:semicolon
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;flag
op_amp
id|JFS_NOINTEGRITY
)paren
r_return
id|open_dummy_log
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbi-&gt;mntflag
op_amp
id|JFS_INLINELOG
)paren
r_return
id|open_inline_log
c_func
(paren
id|sb
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
id|list_for_each_entry
c_func
(paren
id|log
comma
op_amp
id|jfs_external_logs
comma
id|journal_list
)paren
(brace
r_if
c_cond
(paren
id|log-&gt;bdev-&gt;bd_dev
op_eq
id|sbi-&gt;logdev
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|log-&gt;uuid
comma
id|sbi-&gt;loguuid
comma
r_sizeof
(paren
id|log-&gt;uuid
)paren
)paren
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;wrong uuid on JFS journal&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * add file system to log active file system list&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lmLogFileSystem
c_func
(paren
id|log
comma
id|sbi
comma
l_int|1
)paren
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_goto
id|journal_found
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|log
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jfs_log
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|log
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jfs_log
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|log-&gt;sb_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      external log as separate logical volume&n;&t; *&n;&t; * file systems to log may have n-to-1 relationship;&n;&t; */
id|bdev
op_assign
id|open_by_devnum
c_func
(paren
id|sbi-&gt;logdev
comma
id|FMODE_READ
op_or
id|FMODE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|bdev
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|PTR_ERR
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_goto
id|free
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|bd_claim
c_func
(paren
id|bdev
comma
id|log
)paren
)paren
)paren
(brace
r_goto
id|close
suffix:semicolon
)brace
id|log-&gt;bdev
op_assign
id|bdev
suffix:semicolon
id|memcpy
c_func
(paren
id|log-&gt;uuid
comma
id|sbi-&gt;loguuid
comma
r_sizeof
(paren
id|log-&gt;uuid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize log:&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lmLogInit
c_func
(paren
id|log
)paren
)paren
)paren
r_goto
id|unclaim
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|log-&gt;journal_list
comma
op_amp
id|jfs_external_logs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * add file system to log active file system list&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lmLogFileSystem
c_func
(paren
id|log
comma
id|sbi
comma
l_int|1
)paren
)paren
)paren
r_goto
id|shutdown
suffix:semicolon
id|journal_found
suffix:colon
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|sbi-&gt;log_list
comma
op_amp
id|log-&gt;sb_list
)paren
suffix:semicolon
id|sbi-&gt;log
op_assign
id|log
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      unwind on error&n;&t; */
id|shutdown
suffix:colon
multiline_comment|/* unwind lbmLogInit() */
id|list_del
c_func
(paren
op_amp
id|log-&gt;journal_list
)paren
suffix:semicolon
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
id|unclaim
suffix:colon
id|bd_release
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|close
suffix:colon
multiline_comment|/* close external log device */
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|free
suffix:colon
multiline_comment|/* free log descriptor */
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|log
)paren
suffix:semicolon
id|jfs_warn
c_func
(paren
l_string|&quot;lmLogOpen: exit(%d)&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|open_inline_log
r_static
r_int
id|open_inline_log
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|jfs_log
op_star
id|log
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|log
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jfs_log
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|log
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jfs_log
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|log-&gt;sb_list
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|log_INLINELOG
comma
op_amp
id|log-&gt;flag
)paren
suffix:semicolon
id|log-&gt;bdev
op_assign
id|sb-&gt;s_bdev
suffix:semicolon
id|log-&gt;base
op_assign
id|addressPXD
c_func
(paren
op_amp
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|logpxd
)paren
suffix:semicolon
id|log-&gt;size
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|logpxd
)paren
op_rshift
(paren
id|L2LOGPSIZE
op_minus
id|sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|log-&gt;l2bsize
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|ASSERT
c_func
(paren
id|L2LOGPSIZE
op_ge
id|sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize log.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lmLogInit
c_func
(paren
id|log
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|log
)paren
suffix:semicolon
id|jfs_warn
c_func
(paren
l_string|&quot;lmLogOpen: exit(%d)&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|log_list
comma
op_amp
id|log-&gt;sb_list
)paren
suffix:semicolon
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|log
op_assign
id|log
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|open_dummy_log
r_static
r_int
id|open_dummy_log
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_int
id|rc
suffix:semicolon
id|down
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dummy_log
)paren
(brace
id|dummy_log
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jfs_log
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dummy_log
)paren
(brace
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dummy_log
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jfs_log
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dummy_log-&gt;sb_list
)paren
suffix:semicolon
id|dummy_log-&gt;no_integrity
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Make up some stuff */
id|dummy_log-&gt;base
op_assign
l_int|0
suffix:semicolon
id|dummy_log-&gt;size
op_assign
l_int|1024
suffix:semicolon
id|rc
op_assign
id|lmLogInit
c_func
(paren
id|dummy_log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|kfree
c_func
(paren
id|dummy_log
)paren
suffix:semicolon
id|dummy_log
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
id|LOG_LOCK
c_func
(paren
id|dummy_log
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|log_list
comma
op_amp
id|dummy_log-&gt;sb_list
)paren
suffix:semicolon
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|log
op_assign
id|dummy_log
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|dummy_log
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogInit()&n; *&n; * FUNCTION:&t;log initialization at first log open.&n; *&n; *&t;logredo() (or logformat()) should have been run previously.&n; *&t;initialize the log from log superblock.&n; *&t;set the log state in the superblock to LOGMOUNT and&n; *&t;write SYNCPT log record.&n; *&t;&t;&n; * PARAMETER:&t;log&t;- log structure&n; *&n; * RETURN:&t;0&t;- if ok&n; *&t;&t;-EINVAL&t;- bad log magic number or superblock dirty&n; *&t;&t;error returned from logwait()&n; *&t;&t;&t;&n; * serialization: single first open thread&n; */
DECL|function|lmLogInit
r_int
id|lmLogInit
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|lrd
id|lrd
suffix:semicolon
r_struct
id|logsuper
op_star
id|logsuper
suffix:semicolon
r_struct
id|lbuf
op_star
id|bpsuper
suffix:semicolon
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
r_struct
id|logpage
op_star
id|lp
suffix:semicolon
r_int
id|lsn
op_assign
l_int|0
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogInit: log:0x%p&quot;
comma
id|log
)paren
suffix:semicolon
multiline_comment|/* initialize the group commit serialization lock */
id|LOGGC_LOCK_INIT
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* allocate/initialize the log write serialization lock */
id|LOG_LOCK_INIT
c_func
(paren
id|log
)paren
suffix:semicolon
id|LOGSYNC_LOCK_INIT
c_func
(paren
id|log
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|log-&gt;syncwait
)paren
suffix:semicolon
id|log-&gt;cqueue.head
op_assign
id|log-&gt;cqueue.tail
op_assign
l_int|NULL
suffix:semicolon
id|log-&gt;flush_tblk
op_assign
l_int|NULL
suffix:semicolon
id|log-&gt;count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * initialize log i/o&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmLogInit
c_func
(paren
id|log
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|log_INLINELOG
comma
op_amp
id|log-&gt;flag
)paren
)paren
id|log-&gt;l2bsize
op_assign
id|L2LOGPSIZE
suffix:semicolon
multiline_comment|/* check for disabled journaling to disk */
r_if
c_cond
(paren
id|log-&gt;no_integrity
)paren
(brace
multiline_comment|/*&n;&t;&t; * Journal pages will still be filled.  When the time comes&n;&t;&t; * to actually do the I/O, the write is not done, and the&n;&t;&t; * endio routine is called directly.&n;&t;&t; */
id|bp
op_assign
id|lbmAllocate
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
id|log-&gt;bp
op_assign
id|bp
suffix:semicolon
id|bp-&gt;l_pn
op_assign
id|bp-&gt;l_eor
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * validate log superblock&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
l_int|1
comma
op_amp
id|bpsuper
)paren
)paren
)paren
r_goto
id|errout10
suffix:semicolon
id|logsuper
op_assign
(paren
r_struct
id|logsuper
op_star
)paren
id|bpsuper-&gt;l_ldata
suffix:semicolon
r_if
c_cond
(paren
id|logsuper-&gt;magic
op_ne
id|cpu_to_le32
c_func
(paren
id|LOGMAGIC
)paren
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;*** Log Format Error ! ***&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|errout20
suffix:semicolon
)brace
multiline_comment|/* logredo() should have been run successfully. */
r_if
c_cond
(paren
id|logsuper-&gt;state
op_ne
id|cpu_to_le32
c_func
(paren
id|LOGREDONE
)paren
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;*** Log Is Dirty ! ***&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|errout20
suffix:semicolon
)brace
multiline_comment|/* initialize log from log superblock */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|log_INLINELOG
comma
op_amp
id|log-&gt;flag
)paren
)paren
(brace
r_if
c_cond
(paren
id|log-&gt;size
op_ne
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;size
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|errout20
suffix:semicolon
)brace
id|jfs_info
c_func
(paren
l_string|&quot;lmLogInit: inline log:0x%p base:0x%Lx &quot;
l_string|&quot;size:0x%x&quot;
comma
id|log
comma
(paren
r_int
r_int
r_int
)paren
id|log-&gt;base
comma
id|log-&gt;size
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|logsuper-&gt;uuid
comma
id|log-&gt;uuid
comma
l_int|16
)paren
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;wrong uuid on JFS log device&quot;
)paren
suffix:semicolon
r_goto
id|errout20
suffix:semicolon
)brace
id|log-&gt;size
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;size
)paren
suffix:semicolon
id|log-&gt;l2bsize
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;l2bsize
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogInit: external log:0x%p base:0x%Lx &quot;
l_string|&quot;size:0x%x&quot;
comma
id|log
comma
(paren
r_int
r_int
r_int
)paren
id|log-&gt;base
comma
id|log-&gt;size
)paren
suffix:semicolon
)brace
id|log-&gt;page
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;end
)paren
op_div
id|LOGPSIZE
suffix:semicolon
id|log-&gt;eor
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;end
)paren
op_minus
(paren
id|LOGPSIZE
op_star
id|log-&gt;page
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initialize for log append write mode&n;&t;&t; */
multiline_comment|/* establish current/end-of-log page/buffer */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
id|log-&gt;page
comma
op_amp
id|bp
)paren
)paren
)paren
r_goto
id|errout20
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogInit: lsn:0x%x page:%d eor:%d:%d&quot;
comma
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;end
)paren
comma
id|log-&gt;page
comma
id|log-&gt;eor
comma
id|le16_to_cpu
c_func
(paren
id|lp-&gt;h.eor
)paren
)paren
suffix:semicolon
multiline_comment|/* if current page is full, move on to next page */
r_if
c_cond
(paren
id|log-&gt;eor
op_ge
id|LOGPSIZE
op_minus
id|LOGPTLRSIZE
)paren
id|lmNextPage
c_func
(paren
id|log
)paren
suffix:semicolon
id|log-&gt;bp
op_assign
id|bp
suffix:semicolon
id|bp-&gt;l_pn
op_assign
id|log-&gt;page
suffix:semicolon
id|bp-&gt;l_eor
op_assign
id|log-&gt;eor
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initialize log syncpoint&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * write the first SYNCPT record with syncpoint = 0&n;&t;&t; * (i.e., log redo up to HERE !);&n;&t;&t; * remove current page from lbm write queue at end of pageout&n;&t;&t; * (to write log superblock update), but do not release to&n;&t;&t; * freelist;&n;&t;&t; */
id|lrd.logtid
op_assign
l_int|0
suffix:semicolon
id|lrd.backchain
op_assign
l_int|0
suffix:semicolon
id|lrd.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd.length
op_assign
l_int|0
suffix:semicolon
id|lrd.log.syncpt.sync
op_assign
l_int|0
suffix:semicolon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
l_int|NULL
comma
op_amp
id|lrd
comma
l_int|NULL
)paren
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
id|bp-&gt;l_eor
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_eor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|bp
comma
id|lbmWRITE
op_or
id|lbmSYNC
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bp
comma
l_int|0
)paren
)paren
)paren
r_goto
id|errout30
suffix:semicolon
multiline_comment|/*&n;&t;&t; * update/write superblock&n;&t;&t; */
id|logsuper-&gt;state
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGMOUNT
)paren
suffix:semicolon
id|log-&gt;serial
op_assign
id|le32_to_cpu
c_func
(paren
id|logsuper-&gt;serial
)paren
op_plus
l_int|1
suffix:semicolon
id|logsuper-&gt;serial
op_assign
id|cpu_to_le32
c_func
(paren
id|log-&gt;serial
)paren
suffix:semicolon
id|lbmDirectWrite
c_func
(paren
id|log
comma
id|bpsuper
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bpsuper
comma
id|lbmFREE
)paren
)paren
)paren
r_goto
id|errout30
suffix:semicolon
)brace
multiline_comment|/* initialize logsync parameters */
id|log-&gt;logsize
op_assign
(paren
id|log-&gt;size
op_minus
l_int|2
)paren
op_lshift
id|L2LOGPSIZE
suffix:semicolon
id|log-&gt;lsn
op_assign
id|lsn
suffix:semicolon
id|log-&gt;syncpt
op_assign
id|lsn
suffix:semicolon
id|log-&gt;sync
op_assign
id|log-&gt;syncpt
suffix:semicolon
id|log-&gt;nextsync
op_assign
id|LOGSYNC_DELTA
c_func
(paren
id|log-&gt;logsize
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogInit: lsn:0x%x syncpt:0x%x sync:0x%x&quot;
comma
id|log-&gt;lsn
comma
id|log-&gt;syncpt
comma
id|log-&gt;sync
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize for lazy/group commit&n;&t; */
id|log-&gt;clsn
op_assign
id|lsn
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      unwind on error&n;&t; */
id|errout30
suffix:colon
multiline_comment|/* release log page */
id|lbmFree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|errout20
suffix:colon
multiline_comment|/* release log superblock */
id|lbmFree
c_func
(paren
id|bpsuper
)paren
suffix:semicolon
id|errout10
suffix:colon
multiline_comment|/* unwind lbmLogInit() */
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
id|jfs_warn
c_func
(paren
l_string|&quot;lmLogInit: exit(%d)&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogClose()&n; *&n; * FUNCTION:&t;remove file system &lt;ipmnt&gt; from active list of log &lt;iplog&gt;&n; *&t;&t;and close it on last close.&n; *&n; * PARAMETER:&t;sb&t;- superblock&n; *&n; * RETURN:&t;errors from subroutines&n; *&n; * serialization:&n; */
DECL|function|lmLogClose
r_int
id|lmLogClose
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|jfs_log
op_star
id|log
op_assign
id|sbi-&gt;log
suffix:semicolon
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogClose: log:0x%p&quot;
comma
id|log
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|sbi-&gt;log_list
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|sbi-&gt;log
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * We need to make sure all of the &quot;written&quot; metapages&n;&t; * actually make it to disk&n;&t; */
id|sync_blockdev
c_func
(paren
id|sb-&gt;s_bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|log_INLINELOG
comma
op_amp
id|log-&gt;flag
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *      in-line log in host file system&n;&t;&t; */
id|rc
op_assign
id|lmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|log-&gt;no_integrity
)paren
id|lmLogFileSystem
c_func
(paren
id|log
comma
id|sbi
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|log-&gt;sb_list
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * TODO: ensure that the dummy_log is in a state to allow&n;&t; * lbmLogShutdown to deallocate all the buffers and call&n;&t; * kfree against dummy_log.  For now, leave dummy_log &amp; its&n;&t; * buffers in memory, and resuse if another no-integrity mount&n;&t; * is requested.&n;&t; */
r_if
c_cond
(paren
id|log-&gt;no_integrity
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; *      external log as separate logical volume&n;&t; */
id|list_del
c_func
(paren
op_amp
id|log-&gt;journal_list
)paren
suffix:semicolon
id|bdev
op_assign
id|log-&gt;bdev
suffix:semicolon
id|rc
op_assign
id|lmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
id|bd_release
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|jfs_log_sem
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogClose: exit(%d)&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;jfs_flush_journal()&n; *&n; * FUNCTION:&t;initiate write of any outstanding transactions to the journal&n; *&t;&t;and optionally wait until they are all written to disk&n; *&n; *&t;&t;wait == 0  flush until latest txn is committed, don&squot;t wait&n; *&t;&t;wait == 1  flush until latest txn is committed, wait&n; *&t;&t;wait &gt; 1   flush until all txn&squot;s are complete, wait&n; */
DECL|function|jfs_flush_journal
r_void
id|jfs_flush_journal
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|wait
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|tblock
op_star
id|target
suffix:semicolon
multiline_comment|/* jfs_write_inode may call us during read-only mount */
r_if
c_cond
(paren
op_logical_neg
id|log
)paren
r_return
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;jfs_flush_journal: log:0x%p wait=%d&quot;
comma
id|log
comma
id|wait
)paren
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|target
op_assign
id|log-&gt;cqueue.head
suffix:semicolon
r_if
c_cond
(paren
id|target
)paren
(brace
multiline_comment|/*&n;&t;&t; * This ensures that we will keep writing to the journal as long&n;&t;&t; * as there are unwritten commit records&n;&t;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|log_FLUSH
comma
op_amp
id|log-&gt;flag
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We&squot;re already flushing.&n;&t;&t;&t; * if flush_tblk is NULL, we are flushing everything,&n;&t;&t;&t; * so leave it that way.  Otherwise, update it to the&n;&t;&t;&t; * latest transaction&n;&t;&t;&t; */
r_if
c_cond
(paren
id|log-&gt;flush_tblk
)paren
id|log-&gt;flush_tblk
op_assign
id|target
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Only flush until latest transaction is committed */
id|log-&gt;flush_tblk
op_assign
id|target
suffix:semicolon
id|set_bit
c_func
(paren
id|log_FLUSH
comma
op_amp
id|log-&gt;flag
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Initiate I/O on outstanding transactions&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|log-&gt;cflag
op_amp
id|logGC_PAGEOUT
)paren
)paren
(brace
id|log-&gt;cflag
op_or_assign
id|logGC_PAGEOUT
suffix:semicolon
id|lmGCwrite
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
(paren
id|wait
OG
l_int|1
)paren
op_logical_or
id|test_bit
c_func
(paren
id|log_SYNCBARRIER
comma
op_amp
id|log-&gt;flag
)paren
)paren
(brace
multiline_comment|/* Flush until all activity complete */
id|set_bit
c_func
(paren
id|log_FLUSH
comma
op_amp
id|log-&gt;flag
)paren
suffix:semicolon
id|log-&gt;flush_tblk
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait
op_logical_and
id|target
op_logical_and
op_logical_neg
(paren
id|target-&gt;flag
op_amp
id|tblkGC_COMMITTED
)paren
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|__wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|target-&gt;gcwait
comma
op_amp
id|__wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|target-&gt;gcwait
comma
op_amp
id|__wait
)paren
suffix:semicolon
)brace
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
OL
l_int|2
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If there was recent activity, we may need to wait&n;&t; * for the lazycommit thread to catch up&n;&t; */
r_if
c_cond
(paren
id|log-&gt;cqueue.head
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|800
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Too much? */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|log-&gt;cqueue.head
op_eq
l_int|NULL
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
m_assert
(paren
id|log-&gt;cqueue.head
op_eq
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|list_empty
c_func
(paren
op_amp
id|log-&gt;synclist
)paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|log_FLUSH
comma
op_amp
id|log-&gt;flag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogShutdown()&n; *&n; * FUNCTION:&t;log shutdown at last LogClose().&n; *&n; *&t;&t;write log syncpt record.&n; *&t;&t;update super block to set redone flag to 0.&n; *&n; * PARAMETER:&t;log&t;- log inode&n; *&n; * RETURN:&t;0&t;- success&n; *&t;&t;&t;&n; * serialization: single last close thread&n; */
DECL|function|lmLogShutdown
r_int
id|lmLogShutdown
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|lrd
id|lrd
suffix:semicolon
r_int
id|lsn
suffix:semicolon
r_struct
id|logsuper
op_star
id|logsuper
suffix:semicolon
r_struct
id|lbuf
op_star
id|bpsuper
suffix:semicolon
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
r_struct
id|logpage
op_star
id|lp
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogShutdown: log:0x%p&quot;
comma
id|log
)paren
suffix:semicolon
id|jfs_flush_journal
c_func
(paren
id|log
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * write the last SYNCPT record with syncpoint = 0&n;&t; * (i.e., log redo up to HERE !)&n;&t; */
id|lrd.logtid
op_assign
l_int|0
suffix:semicolon
id|lrd.backchain
op_assign
l_int|0
suffix:semicolon
id|lrd.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd.length
op_assign
l_int|0
suffix:semicolon
id|lrd.log.syncpt.sync
op_assign
l_int|0
suffix:semicolon
id|lsn
op_assign
id|lmWriteRecord
c_func
(paren
id|log
comma
l_int|NULL
comma
op_amp
id|lrd
comma
l_int|NULL
)paren
suffix:semicolon
id|bp
op_assign
id|log-&gt;bp
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|bp-&gt;l_eor
)paren
suffix:semicolon
id|lbmWrite
c_func
(paren
id|log
comma
id|log-&gt;bp
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
comma
l_int|0
)paren
suffix:semicolon
id|lbmIOWait
c_func
(paren
id|log-&gt;bp
comma
id|lbmFREE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * synchronous update log superblock&n;&t; * mark log state as shutdown cleanly&n;&t; * (i.e., Log does not need to be replayed).&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
l_int|1
comma
op_amp
id|bpsuper
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|logsuper
op_assign
(paren
r_struct
id|logsuper
op_star
)paren
id|bpsuper-&gt;l_ldata
suffix:semicolon
id|logsuper-&gt;state
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGREDONE
)paren
suffix:semicolon
id|logsuper-&gt;end
op_assign
id|cpu_to_le32
c_func
(paren
id|lsn
)paren
suffix:semicolon
id|lbmDirectWrite
c_func
(paren
id|log
comma
id|bpsuper
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
)paren
suffix:semicolon
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bpsuper
comma
id|lbmFREE
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogShutdown: lsn:0x%x page:%d eor:%d&quot;
comma
id|lsn
comma
id|log-&gt;page
comma
id|log-&gt;eor
)paren
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * shutdown per log i/o&n;&t; */
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;lmLogShutdown: exit(%d)&quot;
comma
id|rc
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogFileSystem()&n; *&n; * FUNCTION:&t;insert (&lt;activate&gt; = true)/remove (&lt;activate&gt; = false)&n; *&t;file system into/from log active file system list.&n; *&n; * PARAMETE:&t;log&t;- pointer to logs inode.&n; *&t;&t;fsdev&t;- kdev_t of filesystem.&n; *&t;&t;serial  - pointer to returned log serial number&n; *&t;&t;activate - insert/remove device from active list.&n; *&n; * RETURN:&t;0&t;- success&n; *&t;&t;errors returned by vms_iowait().&n; */
DECL|function|lmLogFileSystem
r_static
r_int
id|lmLogFileSystem
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|jfs_sb_info
op_star
id|sbi
comma
r_int
id|activate
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|logsuper
op_star
id|logsuper
suffix:semicolon
r_struct
id|lbuf
op_star
id|bpsuper
suffix:semicolon
r_char
op_star
id|uuid
op_assign
id|sbi-&gt;uuid
suffix:semicolon
multiline_comment|/*&n;&t; * insert/remove file system device to log active file system list.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmRead
c_func
(paren
id|log
comma
l_int|1
comma
op_amp
id|bpsuper
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|logsuper
op_assign
(paren
r_struct
id|logsuper
op_star
)paren
id|bpsuper-&gt;l_ldata
suffix:semicolon
r_if
c_cond
(paren
id|activate
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ACTIVE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|logsuper-&gt;active
(braket
id|i
)braket
dot
id|uuid
comma
id|NULL_UUID
comma
l_int|16
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|logsuper-&gt;active
(braket
id|i
)braket
dot
id|uuid
comma
id|uuid
comma
l_int|16
)paren
suffix:semicolon
id|sbi-&gt;aggregate
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_ACTIVE
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;Too many file systems sharing journal!&quot;
)paren
suffix:semicolon
id|lbmFree
c_func
(paren
id|bpsuper
)paren
suffix:semicolon
r_return
op_minus
id|EMFILE
suffix:semicolon
multiline_comment|/* Is there a better rc? */
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ACTIVE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|logsuper-&gt;active
(braket
id|i
)braket
dot
id|uuid
comma
id|uuid
comma
l_int|16
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|logsuper-&gt;active
(braket
id|i
)braket
dot
id|uuid
comma
id|NULL_UUID
comma
l_int|16
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_ACTIVE
)paren
(brace
id|jfs_warn
c_func
(paren
l_string|&quot;Somebody stomped on the journal!&quot;
)paren
suffix:semicolon
id|lbmFree
c_func
(paren
id|bpsuper
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * synchronous write log superblock:&n;&t; *&n;&t; * write sidestream bypassing write queue:&n;&t; * at file system mount, log super block is updated for&n;&t; * activation of the file system before any log record&n;&t; * (MOUNT record) of the file system, and at file system&n;&t; * unmount, all meta data for the file system has been&n;&t; * flushed before log super block is updated for deactivation&n;&t; * of the file system.&n;&t; */
id|lbmDirectWrite
c_func
(paren
id|log
comma
id|bpsuper
comma
id|lbmWRITE
op_or
id|lbmRELEASE
op_or
id|lbmSYNC
)paren
suffix:semicolon
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bpsuper
comma
id|lbmFREE
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;&t;log buffer manager (lbm)&n; *&t;&t;------------------------&n; *&n; * special purpose buffer manager supporting log i/o requirements.&n; *&n; * per log write queue:&n; * log pageout occurs in serial order by fifo write queue and&n; * restricting to a single i/o in pregress at any one time.&n; * a circular singly-linked list&n; * (log-&gt;wrqueue points to the tail, and buffers are linked via&n; * bp-&gt;wrqueue field), and&n; * maintains log page in pageout ot waiting for pageout in serial pageout.&n; */
multiline_comment|/*&n; *&t;lbmLogInit()&n; *&n; * initialize per log I/O setup at lmLogInit()&n; */
DECL|function|lbmLogInit
r_static
r_int
id|lbmLogInit
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
(brace
multiline_comment|/* log inode */
r_int
id|i
suffix:semicolon
r_struct
id|lbuf
op_star
id|lbuf
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lbmLogInit: log:0x%p&quot;
comma
id|log
)paren
suffix:semicolon
multiline_comment|/* initialize current buffer cursor */
id|log-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* initialize log device write queue */
id|log-&gt;wqueue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Each log has its own buffer pages allocated to it.  These are&n;&t; * not managed by the page cache.  This ensures that a transaction&n;&t; * writing to the log does not block trying to allocate a page from&n;&t; * the page cache (for the log).  This would be bad, since page&n;&t; * allocation waits on the kswapd thread that may be committing inodes&n;&t; * which would cause log activity.  Was that clear?  I&squot;m trying to&n;&t; * avoid deadlock here.&n;&t; */
id|init_waitqueue_head
c_func
(paren
op_amp
id|log-&gt;free_wait
)paren
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LOGPAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lbuf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|lbuf
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbuf
op_eq
l_int|0
)paren
r_goto
id|error
suffix:semicolon
id|lbuf-&gt;l_ldata
op_assign
(paren
r_char
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbuf-&gt;l_ldata
op_eq
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|lbuf
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|lbuf-&gt;l_log
op_assign
id|log
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|lbuf-&gt;l_ioevent
)paren
suffix:semicolon
id|lbuf-&gt;l_freelist
op_assign
id|log-&gt;lbuf_free
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
id|lbuf
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error
suffix:colon
id|lbmLogShutdown
c_func
(paren
id|log
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmLogShutdown()&n; *&n; * finalize per log I/O setup at lmLogShutdown()&n; */
DECL|function|lbmLogShutdown
r_static
r_void
id|lbmLogShutdown
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
)paren
(brace
r_struct
id|lbuf
op_star
id|lbuf
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lbmLogShutdown: log:0x%p&quot;
comma
id|log
)paren
suffix:semicolon
id|lbuf
op_assign
id|log-&gt;lbuf_free
suffix:semicolon
r_while
c_loop
(paren
id|lbuf
)paren
(brace
r_struct
id|lbuf
op_star
id|next
op_assign
id|lbuf-&gt;l_freelist
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|lbuf-&gt;l_ldata
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lbuf
)paren
suffix:semicolon
id|lbuf
op_assign
id|next
suffix:semicolon
)brace
id|log-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmAllocate()&n; *&n; * allocate an empty log buffer&n; */
DECL|function|lbmAllocate
r_static
r_struct
id|lbuf
op_star
id|lbmAllocate
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|pn
)paren
(brace
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * recycle from log buffer freelist if any&n;&t; */
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|LCACHE_SLEEP_COND
c_func
(paren
id|log-&gt;free_wait
comma
(paren
id|bp
op_assign
id|log-&gt;lbuf_free
)paren
comma
id|flags
)paren
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
id|bp-&gt;l_freelist
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|bp-&gt;l_flag
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;l_freelist
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;l_pn
op_assign
id|pn
suffix:semicolon
id|bp-&gt;l_blkno
op_assign
id|log-&gt;base
op_plus
(paren
id|pn
op_lshift
(paren
id|L2LOGPSIZE
op_minus
id|log-&gt;l2bsize
)paren
)paren
suffix:semicolon
id|bp-&gt;l_ceor
op_assign
l_int|0
suffix:semicolon
r_return
id|bp
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmFree()&n; *&n; * release a log buffer to freelist&n; */
DECL|function|lbmFree
r_static
r_void
id|lbmFree
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|lbmfree
r_static
r_void
id|lbmfree
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
(brace
r_struct
id|jfs_log
op_star
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
m_assert
(paren
id|bp-&gt;l_wqnext
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * return the buffer to head of freelist&n;&t; */
id|bp-&gt;l_freelist
op_assign
id|log-&gt;lbuf_free
suffix:semicolon
id|log-&gt;lbuf_free
op_assign
id|bp
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|log-&gt;free_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lbmRedrive&n; *&n; * FUNCTION:&t;add a log buffer to the the log redrive list&n; *&n; * PARAMETER:&n; *     bp&t;- log buffer&n; *&n; * NOTES:&n; *&t;Takes log_redrive_lock.&n; */
DECL|function|lbmRedrive
r_static
r_inline
r_void
id|lbmRedrive
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|log_redrive_lock
comma
id|flags
)paren
suffix:semicolon
id|bp-&gt;l_redrive_next
op_assign
id|log_redrive_list
suffix:semicolon
id|log_redrive_list
op_assign
id|bp
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|log_redrive_lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|jfs_IO_thread_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmRead()&n; */
DECL|function|lbmRead
r_static
r_int
id|lbmRead
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_int
id|pn
comma
r_struct
id|lbuf
op_star
op_star
id|bpp
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a log buffer&n;&t; */
op_star
id|bpp
op_assign
id|bp
op_assign
id|lbmAllocate
c_func
(paren
id|log
comma
id|pn
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lbmRead: bp:0x%p pn:0x%x&quot;
comma
id|bp
comma
id|pn
)paren
suffix:semicolon
id|bp-&gt;l_flag
op_or_assign
id|lbmREAD
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOFS
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|bp-&gt;l_blkno
op_lshift
(paren
id|log-&gt;l2bsize
op_minus
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|log-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
op_assign
id|virt_to_page
c_func
(paren
id|bp-&gt;l_ldata
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_len
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
l_int|1
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|lbmIODone
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|bp
suffix:semicolon
id|submit_bio
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|bp-&gt;l_ioevent
comma
(paren
id|bp-&gt;l_flag
op_ne
id|lbmREAD
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmWrite()&n; *&n; * buffer at head of pageout queue stays after completion of&n; * partial-page pageout and redriven by explicit initiation of&n; * pageout by caller until full-page pageout is completed and&n; * released.&n; *&n; * device driver i/o done redrives pageout of new buffer at&n; * head of pageout queue when current buffer at head of pageout&n; * queue is released at the completion of its full-page pageout.&n; *&n; * LOGGC_LOCK() serializes lbmWrite() by lmNextPage() and lmGroupCommit().&n; * LCACHE_LOCK() serializes xflag between lbmWrite() and lbmIODone()&n; */
DECL|function|lbmWrite
r_static
r_void
id|lbmWrite
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|lbuf
op_star
id|bp
comma
r_int
id|flag
comma
r_int
id|cant_block
)paren
(brace
r_struct
id|lbuf
op_star
id|tail
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lbmWrite: bp:0x%p flag:0x%x pn:0x%x&quot;
comma
id|bp
comma
id|flag
comma
id|bp-&gt;l_pn
)paren
suffix:semicolon
multiline_comment|/* map the logical block address to physical block address */
id|bp-&gt;l_blkno
op_assign
id|log-&gt;base
op_plus
(paren
id|bp-&gt;l_pn
op_lshift
(paren
id|L2LOGPSIZE
op_minus
id|log-&gt;l2bsize
)paren
)paren
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* disable+lock */
multiline_comment|/*&n;&t; * initialize buffer for device driver&n;&t; */
id|bp-&gt;l_flag
op_assign
id|flag
suffix:semicolon
multiline_comment|/*&n;&t; *      insert bp at tail of write queue associated with log&n;&t; *&n;&t; * (request is either for bp already/currently at head of queue&n;&t; * or new bp to be inserted at tail)&n;&t; */
id|tail
op_assign
id|log-&gt;wqueue
suffix:semicolon
multiline_comment|/* is buffer not already on write queue ? */
r_if
c_cond
(paren
id|bp-&gt;l_wqnext
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* insert at tail of wqueue */
r_if
c_cond
(paren
id|tail
op_eq
l_int|NULL
)paren
(brace
id|log-&gt;wqueue
op_assign
id|bp
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
id|bp
suffix:semicolon
)brace
r_else
(brace
id|log-&gt;wqueue
op_assign
id|bp
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
id|tail-&gt;l_wqnext
suffix:semicolon
id|tail-&gt;l_wqnext
op_assign
id|bp
suffix:semicolon
)brace
id|tail
op_assign
id|bp
suffix:semicolon
)brace
multiline_comment|/* is buffer at head of wqueue and for write ? */
r_if
c_cond
(paren
(paren
id|bp
op_ne
id|tail-&gt;l_wqnext
)paren
op_logical_or
op_logical_neg
(paren
id|flag
op_amp
id|lbmWRITE
)paren
)paren
(brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
r_return
suffix:semicolon
)brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
r_if
c_cond
(paren
id|cant_block
)paren
id|lbmRedrive
c_func
(paren
id|bp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|lbmSYNC
)paren
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
r_else
(brace
id|LOGGC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LOGGC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;lbmDirectWrite()&n; *&n; * initiate pageout bypassing write queue for sidestream&n; * (e.g., log superblock) write;&n; */
DECL|function|lbmDirectWrite
r_static
r_void
id|lbmDirectWrite
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
r_struct
id|lbuf
op_star
id|bp
comma
r_int
id|flag
)paren
(brace
id|jfs_info
c_func
(paren
l_string|&quot;lbmDirectWrite: bp:0x%p flag:0x%x pn:0x%x&quot;
comma
id|bp
comma
id|flag
comma
id|bp-&gt;l_pn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize buffer for device driver&n;&t; */
id|bp-&gt;l_flag
op_assign
id|flag
op_or
id|lbmDIRECT
suffix:semicolon
multiline_comment|/* map the logical block address to physical block address */
id|bp-&gt;l_blkno
op_assign
id|log-&gt;base
op_plus
(paren
id|bp-&gt;l_pn
op_lshift
(paren
id|L2LOGPSIZE
op_minus
id|log-&gt;l2bsize
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      initiate pageout of the page&n;&t; */
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lbmStartIO()&n; *&n; * FUNCTION:&t;Interface to DD strategy routine&n; *&n; * RETURN:      none&n; *&n; * serialization: LCACHE_LOCK() is NOT held during log i/o;&n; */
DECL|function|lbmStartIO
r_static
r_void
id|lbmStartIO
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
)paren
(brace
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_struct
id|jfs_log
op_star
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lbmStartIO&bslash;n&quot;
)paren
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOFS
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|bp-&gt;l_blkno
op_lshift
(paren
id|log-&gt;l2bsize
op_minus
l_int|9
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|log-&gt;bdev
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_page
op_assign
id|virt_to_page
c_func
(paren
id|bp-&gt;l_ldata
)paren
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_len
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_io_vec
(braket
l_int|0
)braket
dot
id|bv_offset
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_vcnt
op_assign
l_int|1
suffix:semicolon
id|bio-&gt;bi_idx
op_assign
l_int|0
suffix:semicolon
id|bio-&gt;bi_size
op_assign
id|LOGPSIZE
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|lbmIODone
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|bp
suffix:semicolon
multiline_comment|/* check if journaling to disk has been disabled */
r_if
c_cond
(paren
op_logical_neg
id|log-&gt;no_integrity
)paren
(brace
id|submit_bio
c_func
(paren
id|WRITE
comma
id|bio
)paren
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.submitted
)paren
suffix:semicolon
id|blk_run_queues
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|bio-&gt;bi_size
op_assign
l_int|0
suffix:semicolon
id|lbmIODone
c_func
(paren
id|bio
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 2nd argument appears to not be used =&gt; 0&n;&t;&t;&t;&t;       *  3rd argument appears to not be used =&gt; 0&n;&t;&t;&t;&t;       */
)brace
)brace
multiline_comment|/*&n; *&t;lbmIOWait()&n; */
DECL|function|lbmIOWait
r_static
r_int
id|lbmIOWait
c_func
(paren
r_struct
id|lbuf
op_star
id|bp
comma
r_int
id|flag
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lbmIOWait1: bp:0x%p flag:0x%x:0x%x&quot;
comma
id|bp
comma
id|bp-&gt;l_flag
comma
id|flag
)paren
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* disable+lock */
id|LCACHE_SLEEP_COND
c_func
(paren
id|bp-&gt;l_ioevent
comma
(paren
id|bp-&gt;l_flag
op_amp
id|lbmDONE
)paren
comma
id|flags
)paren
suffix:semicolon
id|rc
op_assign
(paren
id|bp-&gt;l_flag
op_amp
id|lbmERROR
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|lbmFREE
)paren
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
id|jfs_info
c_func
(paren
l_string|&quot;lbmIOWait2: bp:0x%p flag:0x%x:0x%x&quot;
comma
id|bp
comma
id|bp-&gt;l_flag
comma
id|flag
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;lbmIODone()&n; *&n; * executed at INTIODONE level&n; */
DECL|function|lbmIODone
r_static
r_int
id|lbmIODone
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
r_struct
id|lbuf
op_star
id|bp
op_assign
id|bio-&gt;bi_private
suffix:semicolon
r_struct
id|lbuf
op_star
id|nextbp
comma
op_star
id|tail
suffix:semicolon
r_struct
id|jfs_log
op_star
id|log
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * get back jfs buffer bound to the i/o buffer&n;&t; */
id|jfs_info
c_func
(paren
l_string|&quot;lbmIODone: bp:0x%p flag:0x%x&quot;
comma
id|bp
comma
id|bp-&gt;l_flag
)paren
suffix:semicolon
id|LCACHE_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* disable+lock */
id|bp-&gt;l_flag
op_or_assign
id|lbmDONE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
)paren
(brace
id|bp-&gt;l_flag
op_or_assign
id|lbmERROR
suffix:semicolon
id|jfs_err
c_func
(paren
l_string|&quot;lbmIODone: I/O error in JFS log&quot;
)paren
suffix:semicolon
)brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      pagein completion&n;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmREAD
)paren
(brace
id|bp-&gt;l_flag
op_and_assign
op_complement
id|lbmREAD
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
multiline_comment|/* wakeup I/O initiator */
id|LCACHE_WAKEUP
c_func
(paren
op_amp
id|bp-&gt;l_ioevent
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      pageout completion&n;&t; *&n;&t; * the bp at the head of write queue has completed pageout.&n;&t; *&n;&t; * if single-commit/full-page pageout, remove the current buffer&n;&t; * from head of pageout queue, and redrive pageout with&n;&t; * the new buffer at head of pageout queue;&n;&t; * otherwise, the partial-page pageout buffer stays at&n;&t; * the head of pageout queue to be redriven for pageout&n;&t; * by lmGroupCommit() until full-page pageout is completed.&n;&t; */
id|bp-&gt;l_flag
op_and_assign
op_complement
id|lbmWRITE
suffix:semicolon
id|INCREMENT
c_func
(paren
id|lmStat.pagedone
)paren
suffix:semicolon
multiline_comment|/* update committed lsn */
id|log
op_assign
id|bp-&gt;l_log
suffix:semicolon
id|log-&gt;clsn
op_assign
(paren
id|bp-&gt;l_pn
op_lshift
id|L2LOGPSIZE
)paren
op_plus
id|bp-&gt;l_ceor
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmDIRECT
)paren
(brace
id|LCACHE_WAKEUP
c_func
(paren
op_amp
id|bp-&gt;l_ioevent
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tail
op_assign
id|log-&gt;wqueue
suffix:semicolon
multiline_comment|/* single element queue */
r_if
c_cond
(paren
id|bp
op_eq
id|tail
)paren
(brace
multiline_comment|/* remove head buffer of full-page pageout&n;&t;&t; * from log device write queue&n;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmRELEASE
)paren
(brace
id|log-&gt;wqueue
op_assign
l_int|NULL
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* multi element queue */
r_else
(brace
multiline_comment|/* remove head buffer of full-page pageout&n;&t;&t; * from log device write queue&n;&t;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmRELEASE
)paren
(brace
id|nextbp
op_assign
id|tail-&gt;l_wqnext
op_assign
id|bp-&gt;l_wqnext
suffix:semicolon
id|bp-&gt;l_wqnext
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * redrive pageout of next page at head of write queue:&n;&t;&t;&t; * redrive next page without any bound tblk&n;&t;&t;&t; * (i.e., page w/o any COMMIT records), or&n;&t;&t;&t; * first page of new group commit which has been&n;&t;&t;&t; * queued after current page (subsequent pageout&n;&t;&t;&t; * is performed synchronously, except page without&n;&t;&t;&t; * any COMMITs) by lmGroupCommit() as indicated&n;&t;&t;&t; * by lbmWRITE flag;&n;&t;&t;&t; */
r_if
c_cond
(paren
id|nextbp-&gt;l_flag
op_amp
id|lbmWRITE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We can&squot;t do the I/O at interrupt time.&n;&t;&t;&t;&t; * The jfsIO thread can do it&n;&t;&t;&t;&t; */
id|lbmRedrive
c_func
(paren
id|nextbp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *      synchronous pageout:&n;&t; *&n;&t; * buffer has not necessarily been removed from write queue&n;&t; * (e.g., synchronous write of partial-page with COMMIT):&n;&t; * leave buffer for i/o initiator to dispose&n;&t; */
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmSYNC
)paren
(brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
multiline_comment|/* wakeup I/O initiator */
id|LCACHE_WAKEUP
c_func
(paren
op_amp
id|bp-&gt;l_ioevent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      Group Commit pageout:&n;&t; */
r_else
r_if
c_cond
(paren
id|bp-&gt;l_flag
op_amp
id|lbmGC
)paren
(brace
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lmPostGC
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      asynchronous pageout:&n;&t; *&n;&t; * buffer must have been removed from write queue:&n;&t; * insert buffer at head of freelist where it can be recycled&n;&t; */
r_else
(brace
m_assert
(paren
id|bp-&gt;l_flag
op_amp
id|lbmRELEASE
)paren
suffix:semicolon
m_assert
(paren
id|bp-&gt;l_flag
op_amp
id|lbmFREE
)paren
suffix:semicolon
id|lbmfree
c_func
(paren
id|bp
)paren
suffix:semicolon
id|LCACHE_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* unlock+enable */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jfsIOWait
r_int
id|jfsIOWait
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
id|daemonize
c_func
(paren
l_string|&quot;jfsIO&quot;
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|jfsIOwait
)paren
suffix:semicolon
r_do
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wq
comma
id|current
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bp
op_assign
id|log_redrive_list
)paren
)paren
(brace
id|log_redrive_list
op_assign
id|bp-&gt;l_redrive_next
suffix:semicolon
id|bp-&gt;l_redrive_next
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
id|refrigerator
c_func
(paren
id|PF_IOTHREAD
)paren
suffix:semicolon
)brace
r_else
(brace
id|add_wait_queue
c_func
(paren
op_amp
id|jfs_IO_thread_wait
comma
op_amp
id|wq
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|log_redrive_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|jfs_IO_thread_wait
comma
op_amp
id|wq
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|jfs_stop_threads
)paren
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;jfsIOWait being killed!&quot;
)paren
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|jfsIOwait
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;lmLogFormat()/jfs_logform()&n; *&n; * FUNCTION:&t;format file system log&n; *&n; * PARAMETERS:&n; *      log&t;- volume log&n; *&t;logAddress - start address of log space in FS block&n; *&t;logSize&t;- length of log space in FS block;&n; *&n; * RETURN:&t;0&t;- success&n; *&t;&t;-EIO&t;- i/o error&n; *&n; * XXX: We&squot;re synchronously writing one page at a time.  This needs to&n; *&t;be improved by writing multiple pages at once.&n; */
DECL|function|lmLogFormat
r_int
id|lmLogFormat
c_func
(paren
r_struct
id|jfs_log
op_star
id|log
comma
id|s64
id|logAddress
comma
r_int
id|logSize
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_struct
id|jfs_sb_info
op_star
id|sbi
suffix:semicolon
r_struct
id|logsuper
op_star
id|logsuper
suffix:semicolon
r_struct
id|logpage
op_star
id|lp
suffix:semicolon
r_int
id|lspn
suffix:semicolon
multiline_comment|/* log sequence page number */
r_struct
id|lrd
op_star
id|lrd_ptr
suffix:semicolon
r_int
id|npages
op_assign
l_int|0
suffix:semicolon
r_struct
id|lbuf
op_star
id|bp
suffix:semicolon
id|jfs_info
c_func
(paren
l_string|&quot;lmLogFormat: logAddress:%Ld logSize:%d&quot;
comma
(paren
r_int
r_int
)paren
id|logAddress
comma
id|logSize
)paren
suffix:semicolon
id|sbi
op_assign
id|list_entry
c_func
(paren
id|log-&gt;sb_list.next
comma
r_struct
id|jfs_sb_info
comma
id|log_list
)paren
suffix:semicolon
multiline_comment|/* allocate a log buffer */
id|bp
op_assign
id|lbmAllocate
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
id|npages
op_assign
id|logSize
op_rshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
multiline_comment|/*&n;&t; *      log space:&n;&t; *&n;&t; * page 0 - reserved;&n;&t; * page 1 - log superblock;&n;&t; * page 2 - log data page: A SYNC log record is written&n;&t; *          into this page at logform time;&n;&t; * pages 3-N - log data page: set to empty log data pages;&n;&t; */
multiline_comment|/*&n;&t; *      init log superblock: log page 1&n;&t; */
id|logsuper
op_assign
(paren
r_struct
id|logsuper
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
id|logsuper-&gt;magic
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGMAGIC
)paren
suffix:semicolon
id|logsuper-&gt;version
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGVERSION
)paren
suffix:semicolon
id|logsuper-&gt;state
op_assign
id|cpu_to_le32
c_func
(paren
id|LOGREDONE
)paren
suffix:semicolon
id|logsuper-&gt;flag
op_assign
id|cpu_to_le32
c_func
(paren
id|sbi-&gt;mntflag
)paren
suffix:semicolon
multiline_comment|/* ? */
id|logsuper-&gt;size
op_assign
id|cpu_to_le32
c_func
(paren
id|npages
)paren
suffix:semicolon
id|logsuper-&gt;bsize
op_assign
id|cpu_to_le32
c_func
(paren
id|sbi-&gt;bsize
)paren
suffix:semicolon
id|logsuper-&gt;l2bsize
op_assign
id|cpu_to_le32
c_func
(paren
id|sbi-&gt;l2bsize
)paren
suffix:semicolon
id|logsuper-&gt;end
op_assign
id|cpu_to_le32
c_func
(paren
l_int|2
op_star
id|LOGPSIZE
op_plus
id|LOGPHDRSIZE
op_plus
id|LOGRDSIZE
)paren
suffix:semicolon
id|bp-&gt;l_flag
op_assign
id|lbmWRITE
op_or
id|lbmSYNC
op_or
id|lbmDIRECT
suffix:semicolon
id|bp-&gt;l_blkno
op_assign
id|logAddress
op_plus
id|sbi-&gt;nbperpage
suffix:semicolon
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bp
comma
l_int|0
)paren
)paren
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t; *      init pages 2 to npages-1 as log data pages:&n;&t; *&n;&t; * log page sequence number (lpsn) initialization:&n;&t; *&n;&t; * pn:   0     1     2     3                 n-1&n;&t; *       +-----+-----+=====+=====+===.....===+=====+&n;&t; * lspn:             N-1   0     1           N-2&n;&t; *                   &lt;--- N page circular file ----&gt;&n;&t; *&n;&t; * the N (= npages-2) data pages of the log is maintained as&n;&t; * a circular file for the log records;&n;&t; * lpsn grows by 1 monotonically as each log page is written&n;&t; * to the circular file of the log;&n;&t; * and setLogpage() will not reset the page number even if&n;&t; * the eor is equal to LOGPHDRSIZE. In order for binary search&n;&t; * still work in find log end process, we have to simulate the&n;&t; * log wrap situation at the log format time.&n;&t; * The 1st log page written will have the highest lpsn. Then&n;&t; * the succeeding log pages will have ascending order of&n;&t; * the lspn starting from 0, ... (N-2)&n;&t; */
id|lp
op_assign
(paren
r_struct
id|logpage
op_star
)paren
id|bp-&gt;l_ldata
suffix:semicolon
multiline_comment|/*&n;&t; * initialize 1st log page to be written: lpsn = N - 1,&n;&t; * write a SYNCPT log record is written to this page&n;&t; */
id|lp-&gt;h.page
op_assign
id|lp-&gt;t.page
op_assign
id|cpu_to_le32
c_func
(paren
id|npages
op_minus
l_int|3
)paren
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|LOGPHDRSIZE
op_plus
id|LOGRDSIZE
)paren
suffix:semicolon
id|lrd_ptr
op_assign
(paren
r_struct
id|lrd
op_star
)paren
op_amp
id|lp-&gt;data
suffix:semicolon
id|lrd_ptr-&gt;logtid
op_assign
l_int|0
suffix:semicolon
id|lrd_ptr-&gt;backchain
op_assign
l_int|0
suffix:semicolon
id|lrd_ptr-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_SYNCPT
)paren
suffix:semicolon
id|lrd_ptr-&gt;length
op_assign
l_int|0
suffix:semicolon
id|lrd_ptr-&gt;log.syncpt.sync
op_assign
l_int|0
suffix:semicolon
id|bp-&gt;l_blkno
op_add_assign
id|sbi-&gt;nbperpage
suffix:semicolon
id|bp-&gt;l_flag
op_assign
id|lbmWRITE
op_or
id|lbmSYNC
op_or
id|lbmDIRECT
suffix:semicolon
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bp
comma
l_int|0
)paren
)paren
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t; *      initialize succeeding log pages: lpsn = 0, 1, ..., (N-2)&n;&t; */
r_for
c_loop
(paren
id|lspn
op_assign
l_int|0
suffix:semicolon
id|lspn
OL
id|npages
op_minus
l_int|3
suffix:semicolon
id|lspn
op_increment
)paren
(brace
id|lp-&gt;h.page
op_assign
id|lp-&gt;t.page
op_assign
id|cpu_to_le32
c_func
(paren
id|lspn
)paren
suffix:semicolon
id|lp-&gt;h.eor
op_assign
id|lp-&gt;t.eor
op_assign
id|cpu_to_le16
c_func
(paren
id|LOGPHDRSIZE
)paren
suffix:semicolon
id|bp-&gt;l_blkno
op_add_assign
id|sbi-&gt;nbperpage
suffix:semicolon
id|bp-&gt;l_flag
op_assign
id|lbmWRITE
op_or
id|lbmSYNC
op_or
id|lbmDIRECT
suffix:semicolon
id|lbmStartIO
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|lbmIOWait
c_func
(paren
id|bp
comma
l_int|0
)paren
)paren
)paren
r_goto
m_exit
suffix:semicolon
)brace
id|rc
op_assign
l_int|0
suffix:semicolon
m_exit
suffix:colon
multiline_comment|/*&n;&t; *      finalize log&n;&t; */
multiline_comment|/* release the buffer */
id|lbmFree
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_JFS_STATISTICS
DECL|function|jfs_lmstats_read
r_int
id|jfs_lmstats_read
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;JFS Logmgr stats&bslash;n&quot;
l_string|&quot;================&bslash;n&quot;
l_string|&quot;commits = %d&bslash;n&quot;
l_string|&quot;writes submitted = %d&bslash;n&quot;
l_string|&quot;writes completed = %d&bslash;n&quot;
l_string|&quot;full pages submitted = %d&bslash;n&quot;
l_string|&quot;partial pages submitted = %d&bslash;n&quot;
comma
id|lmStat.commit
comma
id|lmStat.submitted
comma
id|lmStat.pagedone
comma
id|lmStat.full_page
comma
id|lmStat.partial_page
)paren
suffix:semicolon
id|begin
op_assign
id|offset
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|begin
suffix:semicolon
id|len
op_sub_assign
id|begin
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_else
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_JFS_STATISTICS */
eof
