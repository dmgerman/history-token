multiline_comment|/*&n; *&n; *   Copyright (c) International Business Machines  Corp., 2000&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
multiline_comment|/*&n; *      jfs_txnmgr.c: transaction manager&n; *&n; * notes:&n; * transaction starts with txBegin() and ends with txCommit()&n; * or txAbort().&n; *&n; * tlock is acquired at the time of update;&n; * (obviate scan at commit time for xtree and dtree)&n; * tlock and mp points to each other;&n; * (no hashlist for mp -&gt; tlock).&n; *&n; * special cases:&n; * tlock on in-memory inode:&n; * in-place tlock in the in-memory inode itself;&n; * converted to page lock by iWrite() at commit time.&n; *&n; * tlock during write()/mmap() under anonymous transaction (tid = 0):&n; * transferred (?) to transaction at commit time.&n; *&n; * use the page itself to update allocation maps&n; * (obviate intermediate replication of allocation/deallocation data)&n; * hold on to mp+lock thru update of maps&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/completion.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_filsys.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_dinode.h&quot;
macro_line|#include &quot;jfs_imap.h&quot;
macro_line|#include &quot;jfs_dmap.h&quot;
macro_line|#include &quot;jfs_superblock.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/*&n; *      transaction management structures&n; */
r_static
r_struct
(brace
multiline_comment|/* tblock */
DECL|member|freetid
r_int
id|freetid
suffix:semicolon
multiline_comment|/* 4: index of a free tid structure */
DECL|member|freewait
id|wait_queue_head_t
id|freewait
suffix:semicolon
multiline_comment|/* 4: eventlist of free tblock */
multiline_comment|/* tlock */
DECL|member|freelock
r_int
id|freelock
suffix:semicolon
multiline_comment|/* 4: index first free lock word */
DECL|member|freelockwait
id|wait_queue_head_t
id|freelockwait
suffix:semicolon
multiline_comment|/* 4: eventlist of free tlock */
DECL|member|lowlockwait
id|wait_queue_head_t
id|lowlockwait
suffix:semicolon
multiline_comment|/* 4: eventlist of ample tlocks */
DECL|member|tlocksInUse
r_int
id|tlocksInUse
suffix:semicolon
multiline_comment|/* 4: Number of tlocks in use */
DECL|member|LazyLock
id|spinlock_t
id|LazyLock
suffix:semicolon
multiline_comment|/* 4: synchronize sync_queue &amp; unlock_queue */
multiline_comment|/*&t;tblock_t *sync_queue;&t; * 4: Transactions waiting for data sync */
DECL|member|unlock_queue
id|tblock_t
op_star
id|unlock_queue
suffix:semicolon
multiline_comment|/* 4: Transactions waiting to be released */
DECL|member|unlock_tail
id|tblock_t
op_star
id|unlock_tail
suffix:semicolon
multiline_comment|/* 4: Tail of unlock_queue */
DECL|member|anon_list
r_struct
id|list_head
id|anon_list
suffix:semicolon
multiline_comment|/* inodes having anonymous txns */
DECL|member|anon_list2
r_struct
id|list_head
id|anon_list2
suffix:semicolon
multiline_comment|/* inodes having anonymous txns&n;&t;&t;&t;&t;&t;   that couldn&squot;t be sync&squot;ed */
DECL|variable|TxAnchor
)brace
id|TxAnchor
suffix:semicolon
DECL|variable|nTxBlock
r_static
r_int
id|nTxBlock
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* number of transaction blocks */
DECL|variable|TxBlock
r_struct
id|tblock
op_star
id|TxBlock
suffix:semicolon
multiline_comment|/* transaction block table */
DECL|variable|nTxLock
r_static
r_int
id|nTxLock
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/* number of transaction locks */
DECL|variable|TxLockLWM
r_static
r_int
id|TxLockLWM
op_assign
l_int|4096
op_star
dot
l_int|4
suffix:semicolon
multiline_comment|/* Low water mark for number of txLocks used */
DECL|variable|TxLockHWM
r_static
r_int
id|TxLockHWM
op_assign
l_int|4096
op_star
dot
l_int|8
suffix:semicolon
multiline_comment|/* High water mark for number of txLocks used */
DECL|variable|TxLock
r_struct
id|tlock
op_star
id|TxLock
suffix:semicolon
multiline_comment|/* transaction lock table */
DECL|variable|TlocksLow
r_static
r_int
id|TlocksLow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Indicates low number of available tlocks */
multiline_comment|/*&n; *      transaction management lock&n; */
DECL|variable|jfsTxnLock
r_static
id|spinlock_t
id|jfsTxnLock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|macro|TXN_LOCK
mdefine_line|#define TXN_LOCK()              spin_lock(&amp;jfsTxnLock)
DECL|macro|TXN_UNLOCK
mdefine_line|#define TXN_UNLOCK()            spin_unlock(&amp;jfsTxnLock)
DECL|macro|LAZY_LOCK_INIT
mdefine_line|#define LAZY_LOCK_INIT()&t;spin_lock_init(&amp;TxAnchor.LazyLock);
DECL|macro|LAZY_LOCK
mdefine_line|#define LAZY_LOCK(flags)&t;spin_lock_irqsave(&amp;TxAnchor.LazyLock, flags)
DECL|macro|LAZY_UNLOCK
mdefine_line|#define LAZY_UNLOCK(flags) spin_unlock_irqrestore(&amp;TxAnchor.LazyLock, flags)
multiline_comment|/*&n; * Retry logic exist outside these macros to protect from spurrious wakeups.&n; */
DECL|function|TXN_SLEEP_DROP_LOCK
r_static
r_inline
r_void
id|TXN_SLEEP_DROP_LOCK
c_func
(paren
id|wait_queue_head_t
op_star
id|event
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|event
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|event
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
DECL|macro|TXN_SLEEP
mdefine_line|#define TXN_SLEEP(event)&bslash;&n;{&bslash;&n;&t;TXN_SLEEP_DROP_LOCK(event);&bslash;&n;&t;TXN_LOCK();&bslash;&n;}
DECL|macro|TXN_WAKEUP
mdefine_line|#define TXN_WAKEUP(event) wake_up_all(event)
multiline_comment|/*&n; *      statistics&n; */
r_struct
(brace
DECL|member|maxtid
id|tid_t
id|maxtid
suffix:semicolon
multiline_comment|/* 4: biggest tid ever used */
DECL|member|maxlid
id|lid_t
id|maxlid
suffix:semicolon
multiline_comment|/* 4: biggest lid ever used */
DECL|member|ntid
r_int
id|ntid
suffix:semicolon
multiline_comment|/* 4: # of transactions performed */
DECL|member|nlid
r_int
id|nlid
suffix:semicolon
multiline_comment|/* 4: # of tlocks acquired */
DECL|member|waitlock
r_int
id|waitlock
suffix:semicolon
multiline_comment|/* 4: # of tlock wait */
DECL|variable|stattx
)brace
id|stattx
suffix:semicolon
multiline_comment|/*&n; * external references&n; */
r_extern
r_int
id|lmGroupCommit
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
)paren
suffix:semicolon
r_extern
r_void
id|lmSync
c_func
(paren
id|log_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|readSuper
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|metapage_t
op_star
op_star
id|bpp
)paren
suffix:semicolon
r_extern
r_int
id|jfs_commit_inode
c_func
(paren
r_struct
id|inode
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|jfs_thread_stopped
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|jfsCommitTask
suffix:semicolon
r_extern
r_struct
id|completion
id|jfsIOwait
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|jfsSyncTask
suffix:semicolon
multiline_comment|/*&n; * forward references&n; */
r_int
id|diLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
comma
id|commit_t
op_star
id|cd
)paren
suffix:semicolon
r_int
id|dataLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
suffix:semicolon
r_void
id|dtLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
suffix:semicolon
r_void
id|inlineLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
suffix:semicolon
r_void
id|mapLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
suffix:semicolon
r_void
id|txAbortCommit
c_func
(paren
id|commit_t
op_star
id|cd
comma
r_int
id|exval
)paren
suffix:semicolon
r_static
r_void
id|txAllocPMap
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|maplock_t
op_star
id|maplock
comma
id|tblock_t
op_star
id|tblk
)paren
suffix:semicolon
r_void
id|txForce
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
suffix:semicolon
r_static
r_int
id|txLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|commit_t
op_star
id|cd
)paren
suffix:semicolon
r_int
id|txMoreLock
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|txUpdateMap
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
suffix:semicolon
r_static
r_void
id|txRelease
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
suffix:semicolon
r_void
id|xtLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
suffix:semicolon
r_static
r_void
id|LogSyncRelease
c_func
(paren
id|metapage_t
op_star
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n; *              transaction block/lock management&n; *              ---------------------------------&n; */
multiline_comment|/*&n; * Get a transaction lock from the free list.  If the number in use is&n; * greater than the high water mark, wake up the sync daemon.  This should&n; * free some anonymous transaction locks.  (TXN_LOCK must be held.)&n; */
DECL|function|txLockAlloc
r_static
id|lid_t
id|txLockAlloc
c_func
(paren
r_void
)paren
(brace
id|lid_t
id|lid
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|lid
op_assign
id|TxAnchor.freelock
)paren
)paren
id|TXN_SLEEP
c_func
(paren
op_amp
id|TxAnchor.freelockwait
)paren
suffix:semicolon
id|TxAnchor.freelock
op_assign
id|TxLock
(braket
id|lid
)braket
dot
id|next
suffix:semicolon
id|HIGHWATERMARK
c_func
(paren
id|stattx.maxlid
comma
id|lid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_increment
id|TxAnchor.tlocksInUse
OG
id|TxLockHWM
)paren
op_logical_and
(paren
id|TlocksLow
op_eq
l_int|0
)paren
)paren
(brace
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;txLockAlloc TlocksLow&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|TlocksLow
op_assign
l_int|1
suffix:semicolon
id|wake_up_process
c_func
(paren
id|jfsSyncTask
)paren
suffix:semicolon
)brace
r_return
id|lid
suffix:semicolon
)brace
DECL|function|txLockFree
r_static
r_void
id|txLockFree
c_func
(paren
id|lid_t
id|lid
)paren
(brace
id|TxLock
(braket
id|lid
)braket
dot
id|next
op_assign
id|TxAnchor.freelock
suffix:semicolon
id|TxAnchor.freelock
op_assign
id|lid
suffix:semicolon
id|TxAnchor.tlocksInUse
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|TlocksLow
op_logical_and
(paren
id|TxAnchor.tlocksInUse
OL
id|TxLockLWM
)paren
)paren
(brace
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;txLockFree TlocksLow no more&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|TlocksLow
op_assign
l_int|0
suffix:semicolon
id|TXN_WAKEUP
c_func
(paren
op_amp
id|TxAnchor.lowlockwait
)paren
suffix:semicolon
)brace
id|TXN_WAKEUP
c_func
(paren
op_amp
id|TxAnchor.freelockwait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        txInit()&n; *&n; * FUNCTION:    initialize transaction management structures&n; *&n; * RETURN:&n; *&n; * serialization: single thread at jfs_init()&n; */
DECL|function|txInit
r_int
id|txInit
c_func
(paren
r_void
)paren
(brace
r_int
id|k
comma
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * initialize transaction block (tblock) table&n;&t; *&n;&t; * transaction id (tid) = tblock index&n;&t; * tid = 0 is reserved.&n;&t; */
id|size
op_assign
r_sizeof
(paren
id|tblock_t
)paren
op_star
id|nTxBlock
suffix:semicolon
id|TxBlock
op_assign
(paren
id|tblock_t
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxBlock
op_eq
l_int|NULL
)paren
r_return
id|ENOMEM
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|1
suffix:semicolon
id|k
OL
id|nTxBlock
op_minus
l_int|1
suffix:semicolon
id|k
op_increment
)paren
(brace
id|TxBlock
(braket
id|k
)braket
dot
id|next
op_assign
id|k
op_plus
l_int|1
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|TxBlock
(braket
id|k
)braket
dot
id|gcwait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|TxBlock
(braket
id|k
)braket
dot
id|waitor
)paren
suffix:semicolon
)brace
id|TxBlock
(braket
id|k
)braket
dot
id|next
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|TxBlock
(braket
id|k
)braket
dot
id|gcwait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|TxBlock
(braket
id|k
)braket
dot
id|waitor
)paren
suffix:semicolon
id|TxAnchor.freetid
op_assign
l_int|1
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|TxAnchor.freewait
)paren
suffix:semicolon
id|stattx.maxtid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* statistics */
multiline_comment|/*&n;&t; * initialize transaction lock (tlock) table&n;&t; *&n;&t; * transaction lock id = tlock index&n;&t; * tlock id = 0 is reserved.&n;&t; */
id|size
op_assign
r_sizeof
(paren
id|tlock_t
)paren
op_star
id|nTxLock
suffix:semicolon
id|TxLock
op_assign
(paren
id|tlock_t
op_star
)paren
id|vmalloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxLock
op_eq
l_int|NULL
)paren
(brace
id|vfree
c_func
(paren
id|TxBlock
)paren
suffix:semicolon
r_return
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* initialize tlock table */
r_for
c_loop
(paren
id|k
op_assign
l_int|1
suffix:semicolon
id|k
OL
id|nTxLock
op_minus
l_int|1
suffix:semicolon
id|k
op_increment
)paren
id|TxLock
(braket
id|k
)braket
dot
id|next
op_assign
id|k
op_plus
l_int|1
suffix:semicolon
id|TxLock
(braket
id|k
)braket
dot
id|next
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|TxAnchor.freelockwait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|TxAnchor.lowlockwait
)paren
suffix:semicolon
id|TxAnchor.freelock
op_assign
l_int|1
suffix:semicolon
id|TxAnchor.tlocksInUse
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|TxAnchor.anon_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|TxAnchor.anon_list2
)paren
suffix:semicolon
id|stattx.maxlid
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* statistics */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        txExit()&n; *&n; * FUNCTION:    clean up when module is unloaded&n; */
DECL|function|txExit
r_void
id|txExit
c_func
(paren
r_void
)paren
(brace
id|vfree
c_func
(paren
id|TxLock
)paren
suffix:semicolon
id|TxLock
op_assign
l_int|0
suffix:semicolon
id|vfree
c_func
(paren
id|TxBlock
)paren
suffix:semicolon
id|TxBlock
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        txBegin()&n; *&n; * FUNCTION:    start a transaction.&n; *&n; * PARAMETER:   sb&t;- superblock&n; *              flag&t;- force for nested tx;&n; *&n; * RETURN:&t;tid&t;- transaction id&n; *&n; * note: flag force allows to start tx for nested tx&n; * to prevent deadlock on logsync barrier;&n; */
DECL|function|txBegin
id|tid_t
id|txBegin
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|flag
)paren
(brace
id|tid_t
id|t
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|log_t
op_star
id|log
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txBegin: flag = 0x%x&bslash;n&quot;
comma
id|flag
)paren
)paren
suffix:semicolon
id|log
op_assign
(paren
id|log_t
op_star
)paren
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
id|retry
suffix:colon
r_if
c_cond
(paren
id|flag
op_ne
id|COMMIT_FORCE
)paren
(brace
multiline_comment|/*&n;&t;&t; * synchronize with logsync barrier&n;&t;&t; */
r_if
c_cond
(paren
id|log-&gt;syncbarrier
)paren
(brace
id|TXN_SLEEP
c_func
(paren
op_amp
id|log-&gt;syncwait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flag
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t begin transaction if we&squot;re getting starved for tlocks&n;&t;&t; * unless COMMIT_FORCE (imap changes) or COMMIT_INODE (which&n;&t;&t; * may ultimately free tlocks)&n;&t;&t; */
r_if
c_cond
(paren
id|TlocksLow
)paren
(brace
id|TXN_SLEEP
c_func
(paren
op_amp
id|TxAnchor.lowlockwait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * allocate transaction id/block&n;&t; */
r_if
c_cond
(paren
(paren
id|t
op_assign
id|TxAnchor.freetid
)paren
op_eq
l_int|0
)paren
(brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txBegin: waiting for free tid&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|TXN_SLEEP
c_func
(paren
op_amp
id|TxAnchor.freewait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tblk-&gt;next
op_eq
l_int|0
)paren
op_logical_and
(paren
id|current
op_ne
id|jfsCommitTask
)paren
)paren
(brace
multiline_comment|/* Save one tblk for jfsCommit thread */
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txBegin: waiting for free tid&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|TXN_SLEEP
c_func
(paren
op_amp
id|TxAnchor.freewait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|TxAnchor.freetid
op_assign
id|tblk-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t; * initialize transaction&n;&t; */
multiline_comment|/*&n;&t; * We can&squot;t zero the whole thing or we screw up another thread being&n;&t; * awakened after sleeping on tblk-&gt;waitor&n;&t; *&n;&t; * memset(tblk, 0, sizeof(tblock_t));&n;&t; */
id|tblk-&gt;next
op_assign
id|tblk-&gt;last
op_assign
id|tblk-&gt;xflag
op_assign
id|tblk-&gt;flag
op_assign
id|tblk-&gt;lsn
op_assign
l_int|0
suffix:semicolon
id|tblk-&gt;sb
op_assign
id|sb
suffix:semicolon
op_increment
id|log-&gt;logtid
suffix:semicolon
id|tblk-&gt;logtid
op_assign
id|log-&gt;logtid
suffix:semicolon
op_increment
id|log-&gt;active
suffix:semicolon
id|HIGHWATERMARK
c_func
(paren
id|stattx.maxtid
comma
id|t
)paren
suffix:semicolon
multiline_comment|/* statistics */
id|INCREMENT
c_func
(paren
id|stattx.ntid
)paren
suffix:semicolon
multiline_comment|/* statistics */
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txBegin: returning tid = %d&bslash;n&quot;
comma
id|t
)paren
)paren
suffix:semicolon
r_return
id|t
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        txBeginAnon()&n; *&n; * FUNCTION:    start an anonymous transaction.&n; *&t;&t;Blocks if logsync or available tlocks are low to prevent&n; *&t;&t;anonymous tlocks from depleting supply.&n; *&n; * PARAMETER:   sb&t;- superblock&n; *&n; * RETURN:&t;none&n; */
DECL|function|txBeginAnon
r_void
id|txBeginAnon
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|log_t
op_star
id|log
suffix:semicolon
id|log
op_assign
(paren
id|log_t
op_star
)paren
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
id|retry
suffix:colon
multiline_comment|/*&n;&t; * synchronize with logsync barrier&n;&t; */
r_if
c_cond
(paren
id|log-&gt;syncbarrier
)paren
(brace
id|TXN_SLEEP
c_func
(paren
op_amp
id|log-&gt;syncwait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Don&squot;t begin transaction if we&squot;re getting starved for tlocks&n;&t; */
r_if
c_cond
(paren
id|TlocksLow
)paren
(brace
id|TXN_SLEEP
c_func
(paren
op_amp
id|TxAnchor.lowlockwait
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      txEnd()&n; *&n; * function: free specified transaction block.&n; *&n; *      logsync barrier processing:&n; *&n; * serialization:&n; */
DECL|function|txEnd
r_void
id|txEnd
c_func
(paren
id|tid_t
id|tid
)paren
(brace
id|tblock_t
op_star
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
id|log_t
op_star
id|log
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txEnd: tid = %d&bslash;n&quot;
comma
id|tid
)paren
)paren
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * wakeup transactions waiting on the page locked&n;&t; * by the current transaction&n;&t; */
id|TXN_WAKEUP
c_func
(paren
op_amp
id|tblk-&gt;waitor
)paren
suffix:semicolon
id|log
op_assign
(paren
id|log_t
op_star
)paren
id|JFS_SBI
c_func
(paren
id|tblk-&gt;sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
multiline_comment|/*&n;&t; * Lazy commit thread can&squot;t free this guy until we mark it UNLOCKED,&n;&t; * otherwise, we would be left with a transaction that may have been&n;&t; * reused.&n;&t; *&n;&t; * Lazy commit thread will turn off tblkGC_LAZY before calling this&n;&t; * routine.&n;&t; */
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_LAZY
)paren
(brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txEnd called w/lazy tid: %d, tblk = 0x%p&bslash;n&quot;
comma
id|tid
comma
id|tblk
)paren
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|log-&gt;gclock
)paren
suffix:semicolon
singleline_comment|// LOGGC_LOCK
id|tblk-&gt;flag
op_or_assign
id|tblkGC_UNLOCKED
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|log-&gt;gclock
)paren
suffix:semicolon
singleline_comment|// LOGGC_UNLOCK
r_return
suffix:semicolon
)brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txEnd: tid: %d, tblk = 0x%p&bslash;n&quot;
comma
id|tid
comma
id|tblk
)paren
)paren
suffix:semicolon
m_assert
(paren
id|tblk-&gt;next
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * insert tblock back on freelist&n;&t; */
id|tblk-&gt;next
op_assign
id|TxAnchor.freetid
suffix:semicolon
id|TxAnchor.freetid
op_assign
id|tid
suffix:semicolon
multiline_comment|/*&n;&t; * mark the tblock not active&n;&t; */
op_decrement
id|log-&gt;active
suffix:semicolon
multiline_comment|/*&n;&t; * synchronize with logsync barrier&n;&t; */
r_if
c_cond
(paren
id|log-&gt;syncbarrier
op_logical_and
id|log-&gt;active
op_eq
l_int|0
)paren
(brace
multiline_comment|/* forward log syncpt */
multiline_comment|/* lmSync(log); */
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;     log barrier off: 0x%x&bslash;n&quot;
comma
id|log-&gt;lsn
)paren
)paren
suffix:semicolon
multiline_comment|/* enable new transactions start */
id|log-&gt;syncbarrier
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wakeup all waitors for logsync barrier */
id|TXN_WAKEUP
c_func
(paren
op_amp
id|log-&gt;syncwait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * wakeup all waitors for a free tblock&n;&t; */
id|TXN_WAKEUP
c_func
(paren
op_amp
id|TxAnchor.freewait
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txEnd: exitting&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      txLock()&n; *&n; * function: acquire a transaction lock on the specified &lt;mp&gt;&n; *&n; * parameter:&n; *&n; * return:      transaction lock id&n; *&n; * serialization:&n; */
DECL|function|txLock
id|tlock_t
op_star
id|txLock
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|metapage_t
op_star
id|mp
comma
r_int
id|type
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
r_int
id|dir_xtree
op_assign
l_int|0
suffix:semicolon
id|lid_t
id|lid
suffix:semicolon
id|tid_t
id|xtid
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
id|linelock_t
op_star
id|linelock
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
op_logical_and
(paren
id|type
op_amp
id|tlckXTREE
)paren
op_logical_and
op_logical_neg
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Directory inode is special.  It can have both an xtree tlock&n;&t;&t; * and a dtree tlock associated with it.&n;&t;&t; */
id|dir_xtree
op_assign
l_int|1
suffix:semicolon
id|lid
op_assign
id|jfs_ip-&gt;xtlid
suffix:semicolon
)brace
r_else
id|lid
op_assign
id|mp-&gt;lid
suffix:semicolon
multiline_comment|/* is page not locked by a transaction ? */
r_if
c_cond
(paren
id|lid
op_eq
l_int|0
)paren
r_goto
id|allocateLock
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txLock: tid:%d ip:0x%p mp:0x%p lid:%d&bslash;n&quot;
comma
id|tid
comma
id|ip
comma
id|mp
comma
id|lid
)paren
)paren
suffix:semicolon
multiline_comment|/* is page locked by the requester transaction ? */
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xtid
op_assign
id|tlck-&gt;tid
)paren
op_eq
id|tid
)paren
r_goto
id|grantLock
suffix:semicolon
multiline_comment|/*&n;&t; * is page locked by anonymous transaction/lock ?&n;&t; *&n;&t; * (page update without transaction (i.e., file write) is&n;&t; * locked under anonymous transaction tid = 0:&n;&t; * anonymous tlocks maintained on anonymous tlock list of&n;&t; * the inode of the page and available to all anonymous&n;&t; * transactions until txCommit() time at which point&n;&t; * they are transferred to the transaction tlock list of&n;&t; * the commiting transaction of the inode)&n;&t; */
r_if
c_cond
(paren
id|xtid
op_eq
l_int|0
)paren
(brace
id|tlck-&gt;tid
op_assign
id|tid
suffix:semicolon
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The order of the tlocks in the transaction is important&n;&t;&t; * (during truncate, child xtree pages must be freed before&n;&t;&t; * parent&squot;s tlocks change the working map).&n;&t;&t; * Take tlock off anonymous list and add to tail of&n;&t;&t; * transaction list&n;&t;&t; *&n;&t;&t; * Note:  We really need to get rid of the tid &amp; lid and&n;&t;&t; * use list_head&squot;s.  This code is getting UGLY!&n;&t;&t; */
r_if
c_cond
(paren
id|jfs_ip-&gt;atlhead
op_eq
id|lid
)paren
(brace
r_if
c_cond
(paren
id|jfs_ip-&gt;atltail
op_eq
id|lid
)paren
(brace
multiline_comment|/* only anonymous txn.&n;&t;&t;&t;&t; * Remove from anon_list&n;&t;&t;&t;&t; */
id|list_del_init
c_func
(paren
op_amp
id|jfs_ip-&gt;anon_inode_list
)paren
suffix:semicolon
)brace
id|jfs_ip-&gt;atlhead
op_assign
id|tlck-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|lid_t
id|last
suffix:semicolon
r_for
c_loop
(paren
id|last
op_assign
id|jfs_ip-&gt;atlhead
suffix:semicolon
id|lid_to_tlock
c_func
(paren
id|last
)paren
op_member_access_from_pointer
id|next
op_ne
id|lid
suffix:semicolon
id|last
op_assign
id|lid_to_tlock
c_func
(paren
id|last
)paren
op_member_access_from_pointer
id|next
)paren
(brace
m_assert
(paren
id|last
)paren
suffix:semicolon
)brace
id|lid_to_tlock
c_func
(paren
id|last
)paren
op_member_access_from_pointer
id|next
op_assign
id|tlck-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|jfs_ip-&gt;atltail
op_eq
id|lid
)paren
id|jfs_ip-&gt;atltail
op_assign
id|last
suffix:semicolon
)brace
multiline_comment|/* insert the tlock at tail of transaction tlock list */
r_if
c_cond
(paren
id|tblk-&gt;next
)paren
id|lid_to_tlock
c_func
(paren
id|tblk-&gt;last
)paren
op_member_access_from_pointer
id|next
op_assign
id|lid
suffix:semicolon
r_else
id|tblk-&gt;next
op_assign
id|lid
suffix:semicolon
id|tlck-&gt;next
op_assign
l_int|0
suffix:semicolon
id|tblk-&gt;last
op_assign
id|lid
suffix:semicolon
r_goto
id|grantLock
suffix:semicolon
)brace
r_goto
id|waitLock
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a tlock&n;&t; */
id|allocateLock
suffix:colon
id|lid
op_assign
id|txLockAlloc
c_func
(paren
)paren
suffix:semicolon
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize tlock&n;&t; */
id|tlck-&gt;tid
op_assign
id|tid
suffix:semicolon
multiline_comment|/* mark tlock for meta-data page */
r_if
c_cond
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
(brace
id|tlck-&gt;flag
op_assign
id|tlckPAGELOCK
suffix:semicolon
multiline_comment|/* mark the page dirty and nohomeok */
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;locking mp = 0x%p, nohomeok = %d tid = %d tlck = 0x%p&bslash;n&quot;
comma
id|mp
comma
id|atomic_read
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
comma
id|tid
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* if anonymous transaction, and buffer is on the group&n;&t;&t; * commit synclist, mark inode to show this.  This will&n;&t;&t; * prevent the buffer from being marked nohomeok for too&n;&t;&t; * long a time.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|tid
op_eq
l_int|0
)paren
op_logical_and
id|mp-&gt;lsn
)paren
id|set_cflag
c_func
(paren
id|COMMIT_Synclist
comma
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/* mark tlock for in-memory inode */
r_else
id|tlck-&gt;flag
op_assign
id|tlckINODELOCK
suffix:semicolon
id|tlck-&gt;type
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bind the tlock and the page */
id|tlck-&gt;ip
op_assign
id|ip
suffix:semicolon
id|tlck-&gt;mp
op_assign
id|mp
suffix:semicolon
r_if
c_cond
(paren
id|dir_xtree
)paren
id|jfs_ip-&gt;xtlid
op_assign
id|lid
suffix:semicolon
r_else
id|mp-&gt;lid
op_assign
id|lid
suffix:semicolon
multiline_comment|/*&n;&t; * enqueue transaction lock to transaction/inode&n;&t; */
multiline_comment|/* insert the tlock at tail of transaction tlock list */
r_if
c_cond
(paren
id|tid
)paren
(brace
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;next
)paren
id|lid_to_tlock
c_func
(paren
id|tblk-&gt;last
)paren
op_member_access_from_pointer
id|next
op_assign
id|lid
suffix:semicolon
r_else
id|tblk-&gt;next
op_assign
id|lid
suffix:semicolon
id|tlck-&gt;next
op_assign
l_int|0
suffix:semicolon
id|tblk-&gt;last
op_assign
id|lid
suffix:semicolon
)brace
multiline_comment|/* anonymous transaction:&n;&t; * insert the tlock at head of inode anonymous tlock list&n;&t; */
r_else
(brace
id|tlck-&gt;next
op_assign
id|jfs_ip-&gt;atlhead
suffix:semicolon
id|jfs_ip-&gt;atlhead
op_assign
id|lid
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;next
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This inode&squot;s first anonymous transaction */
id|jfs_ip-&gt;atltail
op_assign
id|lid
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jfs_ip-&gt;anon_inode_list
comma
op_amp
id|TxAnchor.anon_list
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* initialize type dependent area for linelock */
id|linelock
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|linelock-&gt;next
op_assign
l_int|0
suffix:semicolon
id|linelock-&gt;flag
op_assign
id|tlckLINELOCK
suffix:semicolon
id|linelock-&gt;maxcnt
op_assign
id|TLOCKSHORT
suffix:semicolon
id|linelock-&gt;index
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
op_amp
id|tlckTYPE
)paren
(brace
r_case
id|tlckDTREE
suffix:colon
id|linelock-&gt;l2linesize
op_assign
id|L2DTSLOTSIZE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlckXTREE
suffix:colon
id|linelock-&gt;l2linesize
op_assign
id|L2XTSLOTSIZE
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
id|linelock
suffix:semicolon
id|xtlck-&gt;header.offset
op_assign
l_int|0
suffix:semicolon
id|xtlck-&gt;header.length
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|type
op_amp
id|tlckNEW
)paren
(brace
id|xtlck-&gt;lwm.offset
op_assign
id|XTENTRYSTART
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
id|p
op_assign
(paren
id|xtpage_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
r_else
id|p
op_assign
op_amp
id|jfs_ip-&gt;i_xtroot
suffix:semicolon
id|xtlck-&gt;lwm.offset
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
)brace
id|xtlck-&gt;lwm.length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ! */
id|xtlck-&gt;index
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlckINODE
suffix:colon
id|linelock-&gt;l2linesize
op_assign
id|L2INODESLOTSIZE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlckDATA
suffix:colon
id|linelock-&gt;l2linesize
op_assign
id|L2DATASLOTSIZE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;UFO tlock:0x%p&bslash;n&quot;
comma
id|tlck
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * update tlock vector&n;&t; */
id|grantLock
suffix:colon
id|tlck-&gt;type
op_or_assign
id|type
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_return
id|tlck
suffix:semicolon
multiline_comment|/*&n;&t; * page is being locked by another transaction:&n;&t; */
id|waitLock
suffix:colon
multiline_comment|/* Only locks on ipimap or ipaimap should reach here */
multiline_comment|/* assert(jfs_ip-&gt;fileset == AGGREGATE_I); */
r_if
c_cond
(paren
id|jfs_ip-&gt;fileset
op_ne
id|AGGREGATE_I
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txLock: trying to lock locked page!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|dump_mem
c_func
(paren
l_string|&quot;ip&quot;
comma
id|ip
comma
r_sizeof
(paren
r_struct
id|inode
)paren
)paren
suffix:semicolon
id|dump_mem
c_func
(paren
l_string|&quot;mp&quot;
comma
id|mp
comma
r_sizeof
(paren
id|metapage_t
)paren
)paren
suffix:semicolon
id|dump_mem
c_func
(paren
l_string|&quot;Locker&squot;s tblk&quot;
comma
id|tid_to_tblock
c_func
(paren
id|tid
)paren
comma
r_sizeof
(paren
id|tblock_t
)paren
)paren
suffix:semicolon
id|dump_mem
c_func
(paren
l_string|&quot;Tlock&quot;
comma
id|tlck
comma
r_sizeof
(paren
id|tlock_t
)paren
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|INCREMENT
c_func
(paren
id|stattx.waitlock
)paren
suffix:semicolon
multiline_comment|/* statistics */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;txLock: in waitLock, tid = %d, xtid = %d, lid = %d&bslash;n&quot;
comma
id|tid
comma
id|xtid
comma
id|lid
)paren
)paren
suffix:semicolon
id|TXN_SLEEP_DROP_LOCK
c_func
(paren
op_amp
id|tid_to_tblock
c_func
(paren
id|xtid
)paren
op_member_access_from_pointer
id|waitor
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;txLock: awakened     tid = %d, lid = %d&bslash;n&quot;
comma
id|tid
comma
id|lid
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        txRelease()&n; *&n; * FUNCTION:    Release buffers associated with transaction locks, but don&squot;t&n; *&t;&t;mark homeok yet.  The allows other transactions to modify&n; *&t;&t;buffers, but won&squot;t let them go to disk until commit record&n; *&t;&t;actually gets written.&n; *&n; * PARAMETER:&n; *              tblk    -&n; *&n; * RETURN:      Errors from subroutines.&n; */
DECL|function|txRelease
r_static
r_void
id|txRelease
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
(brace
id|metapage_t
op_star
id|mp
suffix:semicolon
id|lid_t
id|lid
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lid
op_assign
id|tblk-&gt;next
suffix:semicolon
id|lid
suffix:semicolon
id|lid
op_assign
id|tlck-&gt;next
)paren
(brace
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|tlck-&gt;mp
)paren
op_ne
l_int|NULL
op_logical_and
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
op_eq
l_int|0
)paren
(brace
m_assert
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
suffix:semicolon
id|mp-&gt;lid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * wakeup transactions waiting on a page locked&n;&t; * by the current transaction&n;&t; */
id|TXN_WAKEUP
c_func
(paren
op_amp
id|tblk-&gt;waitor
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        txUnlock()&n; *&n; * FUNCTION:    Initiates pageout of pages modified by tid in journalled&n; *              objects and frees their lockwords.&n; *&n; * PARAMETER:&n; *              flag    -&n; *&n; * RETURN:      Errors from subroutines.&n; */
DECL|function|txUnlock
r_static
r_void
id|txUnlock
c_func
(paren
id|tblock_t
op_star
id|tblk
comma
r_int
id|flag
)paren
(brace
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|linelock_t
op_star
id|linelock
suffix:semicolon
id|lid_t
id|lid
comma
id|next
comma
id|llid
comma
id|k
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|log_t
op_star
id|log
suffix:semicolon
r_int
id|force
suffix:semicolon
r_int
id|difft
comma
id|diffp
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txUnlock: tblk = 0x%p&bslash;n&quot;
comma
id|tblk
)paren
)paren
suffix:semicolon
id|log
op_assign
(paren
id|log_t
op_star
)paren
id|JFS_SBI
c_func
(paren
id|tblk-&gt;sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
id|force
op_assign
id|flag
op_amp
id|COMMIT_FLUSH
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;syncbarrier
)paren
id|force
op_or_assign
id|COMMIT_FORCE
suffix:semicolon
multiline_comment|/*&n;&t; * mark page under tlock homeok (its log has been written):&n;&t; * if caller has specified FORCE (e.g., iRecycle()), or&n;&t; * if syncwait for the log is set (i.e., the log sync point&n;&t; * has fallen behind), or&n;&t; * if syncpt is set for the page, or&n;&t; * if the page is new, initiate pageout;&n;&t; * otherwise, leave the page in memory.&n;&t; */
r_for
c_loop
(paren
id|lid
op_assign
id|tblk-&gt;next
suffix:semicolon
id|lid
suffix:semicolon
id|lid
op_assign
id|next
)paren
(brace
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
id|next
op_assign
id|tlck-&gt;next
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;unlocking lid = %d, tlck = 0x%p&bslash;n&quot;
comma
id|lid
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* unbind page from tlock */
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|tlck-&gt;mp
)paren
op_ne
l_int|NULL
op_logical_and
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
op_eq
l_int|0
)paren
(brace
m_assert
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
suffix:semicolon
multiline_comment|/* hold buffer&n;&t;&t;&t; *&n;&t;&t;&t; * It&squot;s possible that someone else has the metapage.&n;&t;&t;&t; * The only things were changing are nohomeok, which&n;&t;&t;&t; * is handled atomically, and clsn which is protected&n;&t;&t;&t; * by the LOGSYNC_LOCK.&n;&t;&t;&t; */
id|hold_metapage
c_func
(paren
id|mp
comma
l_int|1
)paren
suffix:semicolon
m_assert
(paren
id|atomic_read
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
OG
l_int|0
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
suffix:semicolon
multiline_comment|/* inherit younger/larger clsn */
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;clsn
)paren
(brace
id|logdiff
c_func
(paren
id|difft
comma
id|tblk-&gt;clsn
comma
id|log
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|diffp
comma
id|mp-&gt;clsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|difft
OG
id|diffp
)paren
id|mp-&gt;clsn
op_assign
id|tblk-&gt;clsn
suffix:semicolon
)brace
r_else
id|mp-&gt;clsn
op_assign
id|tblk-&gt;clsn
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
m_assert
(paren
op_logical_neg
(paren
id|tlck-&gt;flag
op_amp
id|tlckFREEPAGE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckWRITEPAGE
)paren
(brace
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* release page which has been forced */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* insert tlock, and linelock(s) of the tlock if any,&n;&t;&t; * at head of freelist&n;&t;&t; */
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
id|llid
op_assign
(paren
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_while
c_loop
(paren
id|llid
)paren
(brace
id|linelock
op_assign
(paren
id|linelock_t
op_star
)paren
id|lid_to_tlock
c_func
(paren
id|llid
)paren
suffix:semicolon
id|k
op_assign
id|linelock-&gt;next
suffix:semicolon
id|txLockFree
c_func
(paren
id|llid
)paren
suffix:semicolon
id|llid
op_assign
id|k
suffix:semicolon
)brace
id|txLockFree
c_func
(paren
id|lid
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
id|tblk-&gt;next
op_assign
id|tblk-&gt;last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * remove tblock from logsynclist&n;&t; * (allocation map pages inherited lsn of tblk and&n;&t; * has been inserted in logsync list at txUpdateMap())&n;&t; */
r_if
c_cond
(paren
id|tblk-&gt;lsn
)paren
(brace
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|log-&gt;count
op_decrement
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|tblk-&gt;synclist
)paren
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      txMaplock()&n; *&n; * function: allocate a transaction lock for freed page/entry;&n; *      for freed page, maplock is used as xtlock/dtlock type;&n; */
DECL|function|txMaplock
id|tlock_t
op_star
id|txMaplock
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
r_int
id|type
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|lid_t
id|lid
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|maplock_t
op_star
id|maplock
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allocate a tlock&n;&t; */
id|lid
op_assign
id|txLockAlloc
c_func
(paren
)paren
suffix:semicolon
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize tlock&n;&t; */
id|tlck-&gt;tid
op_assign
id|tid
suffix:semicolon
multiline_comment|/* bind the tlock and the object */
id|tlck-&gt;flag
op_assign
id|tlckINODELOCK
suffix:semicolon
id|tlck-&gt;ip
op_assign
id|ip
suffix:semicolon
id|tlck-&gt;mp
op_assign
l_int|NULL
suffix:semicolon
id|tlck-&gt;type
op_assign
id|type
suffix:semicolon
multiline_comment|/*&n;&t; * enqueue transaction lock to transaction/inode&n;&t; */
multiline_comment|/* insert the tlock at tail of transaction tlock list */
r_if
c_cond
(paren
id|tid
)paren
(brace
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;next
)paren
id|lid_to_tlock
c_func
(paren
id|tblk-&gt;last
)paren
op_member_access_from_pointer
id|next
op_assign
id|lid
suffix:semicolon
r_else
id|tblk-&gt;next
op_assign
id|lid
suffix:semicolon
id|tlck-&gt;next
op_assign
l_int|0
suffix:semicolon
id|tblk-&gt;last
op_assign
id|lid
suffix:semicolon
)brace
multiline_comment|/* anonymous transaction:&n;&t; * insert the tlock at head of inode anonymous tlock list&n;&t; */
r_else
(brace
id|tlck-&gt;next
op_assign
id|jfs_ip-&gt;atlhead
suffix:semicolon
id|jfs_ip-&gt;atlhead
op_assign
id|lid
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;next
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This inode&squot;s first anonymous transaction */
id|jfs_ip-&gt;atltail
op_assign
id|lid
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jfs_ip-&gt;anon_inode_list
comma
op_amp
id|TxAnchor.anon_list
)paren
suffix:semicolon
)brace
)brace
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initialize type dependent area for maplock */
id|maplock
op_assign
(paren
id|maplock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|maplock-&gt;next
op_assign
l_int|0
suffix:semicolon
id|maplock-&gt;maxcnt
op_assign
l_int|0
suffix:semicolon
id|maplock-&gt;index
op_assign
l_int|0
suffix:semicolon
r_return
id|tlck
suffix:semicolon
)brace
multiline_comment|/*&n; *      txLinelock()&n; *&n; * function: allocate a transaction lock for log vector list&n; */
DECL|function|txLinelock
id|linelock_t
op_star
id|txLinelock
c_func
(paren
id|linelock_t
op_star
id|tlock
)paren
(brace
id|lid_t
id|lid
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|linelock_t
op_star
id|linelock
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* allocate a TxLock structure */
id|lid
op_assign
id|txLockAlloc
c_func
(paren
)paren
suffix:semicolon
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initialize linelock */
id|linelock
op_assign
(paren
id|linelock_t
op_star
)paren
id|tlck
suffix:semicolon
id|linelock-&gt;next
op_assign
l_int|0
suffix:semicolon
id|linelock-&gt;flag
op_assign
id|tlckLINELOCK
suffix:semicolon
id|linelock-&gt;maxcnt
op_assign
id|TLOCKLONG
suffix:semicolon
id|linelock-&gt;index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* append linelock after tlock */
id|linelock-&gt;next
op_assign
id|tlock-&gt;next
suffix:semicolon
id|tlock-&gt;next
op_assign
id|lid
suffix:semicolon
r_return
id|linelock
suffix:semicolon
)brace
multiline_comment|/*&n; *              transaction commit management&n; *              -----------------------------&n; */
multiline_comment|/*&n; * NAME:        txCommit()&n; *&n; * FUNCTION:    commit the changes to the objects specified in&n; *              clist.  For journalled segments only the&n; *              changes of the caller are committed, ie by tid.&n; *              for non-journalled segments the data are flushed to&n; *              disk and then the change to the disk inode and indirect&n; *              blocks committed (so blocks newly allocated to the&n; *              segment will be made a part of the segment atomically).&n; *&n; *              all of the segments specified in clist must be in&n; *              one file system. no more than 6 segments are needed&n; *              to handle all unix svcs.&n; *&n; *              if the i_nlink field (i.e. disk inode link count)&n; *              is zero, and the type of inode is a regular file or&n; *              directory, or symbolic link , the inode is truncated&n; *              to zero length. the truncation is committed but the&n; *              VM resources are unaffected until it is closed (see&n; *              iput and iclose).&n; *&n; * PARAMETER:&n; *&n; * RETURN:&n; *&n; * serialization:&n; *              on entry the inode lock on each segment is assumed&n; *              to be held.&n; *&n; * i/o error:&n; */
DECL|function|txCommit
r_int
id|txCommit
c_func
(paren
id|tid_t
id|tid
comma
multiline_comment|/* transaction identifier */
r_int
id|nip
comma
multiline_comment|/* number of inodes to commit */
r_struct
id|inode
op_star
op_star
id|iplist
comma
multiline_comment|/* list of inode to commit */
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
comma
id|rc1
op_assign
l_int|0
suffix:semicolon
id|commit_t
id|cd
suffix:semicolon
id|log_t
op_star
id|log
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|lrd_t
op_star
id|lrd
suffix:semicolon
r_int
id|lsn
suffix:semicolon
r_struct
id|inode
op_star
id|ip
suffix:semicolon
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
suffix:semicolon
r_int
id|k
comma
id|n
suffix:semicolon
id|ino_t
id|top
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txCommit, tid = %d, flag = %d&bslash;n&quot;
comma
id|tid
comma
id|flag
)paren
)paren
suffix:semicolon
multiline_comment|/* is read-only file system ? */
r_if
c_cond
(paren
id|isReadOnly
c_func
(paren
id|iplist
(braket
l_int|0
)braket
)paren
)paren
(brace
id|rc
op_assign
id|EROFS
suffix:semicolon
r_goto
id|TheEnd
suffix:semicolon
)brace
id|sb
op_assign
id|cd.sb
op_assign
id|iplist
(braket
l_int|0
)braket
op_member_access_from_pointer
id|i_sb
suffix:semicolon
id|cd.tid
op_assign
id|tid
suffix:semicolon
r_if
c_cond
(paren
id|tid
op_eq
l_int|0
)paren
id|tid
op_assign
id|txBegin
c_func
(paren
id|sb
comma
l_int|0
)paren
suffix:semicolon
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize commit structure&n;&t; */
id|log
op_assign
(paren
id|log_t
op_star
)paren
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
id|cd.log
op_assign
id|log
suffix:semicolon
multiline_comment|/* initialize log record descriptor in commit */
id|lrd
op_assign
op_amp
id|cd.lrd
suffix:semicolon
id|lrd-&gt;logtid
op_assign
id|cpu_to_le32
c_func
(paren
id|tblk-&gt;logtid
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
l_int|0
suffix:semicolon
id|tblk-&gt;xflag
op_or_assign
id|flag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
(paren
id|COMMIT_FORCE
op_or
id|COMMIT_SYNC
)paren
)paren
op_eq
l_int|0
)paren
id|tblk-&gt;xflag
op_or_assign
id|COMMIT_LAZY
suffix:semicolon
multiline_comment|/*&n;&t; *      prepare non-journaled objects for commit&n;&t; *&n;&t; * flush data pages of non-journaled file&n;&t; * to prevent the file getting non-initialized disk blocks&n;&t; * in case of crash.&n;&t; * (new blocks - )&n;&t; */
id|cd.iplist
op_assign
id|iplist
suffix:semicolon
id|cd.nip
op_assign
id|nip
suffix:semicolon
multiline_comment|/*&n;&t; *      acquire transaction lock on (on-disk) inodes&n;&t; *&n;&t; * update on-disk inode from in-memory inode&n;&t; * acquiring transaction locks for AFTER records&n;&t; * on the on-disk inode of file object&n;&t; *&n;&t; * sort the inodes array by inode number in descending order&n;&t; * to prevent deadlock when acquiring transaction lock&n;&t; * of on-disk inodes on multiple on-disk inode pages by&n;&t; * multiple concurrent transactions&n;&t; */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cd.nip
suffix:semicolon
id|k
op_increment
)paren
(brace
id|top
op_assign
(paren
id|cd.iplist
(braket
id|k
)braket
)paren
op_member_access_from_pointer
id|i_ino
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|k
op_plus
l_int|1
suffix:semicolon
id|n
OL
id|cd.nip
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ip
op_assign
id|cd.iplist
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_ino
OG
id|top
)paren
(brace
id|top
op_assign
id|ip-&gt;i_ino
suffix:semicolon
id|cd.iplist
(braket
id|n
)braket
op_assign
id|cd.iplist
(braket
id|k
)braket
suffix:semicolon
id|cd.iplist
(braket
id|k
)braket
op_assign
id|ip
suffix:semicolon
)brace
)brace
id|ip
op_assign
id|cd.iplist
(braket
id|k
)braket
suffix:semicolon
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * BUGBUG - Should we call filemap_fdatasync here instead&n;&t;&t; * of fsync_inode_data?&n;&t;&t; * If we do, we have a deadlock condition since we may end&n;&t;&t; * up recursively calling jfs_get_block with the IWRITELOCK&n;&t;&t; * held.  We may be able to do away with IWRITELOCK while&n;&t;&t; * committing transactions and use i_sem instead.&n;&t;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
op_logical_and
(paren
id|tblk-&gt;flag
op_amp
id|COMMIT_DELETE
)paren
op_eq
l_int|0
)paren
id|fsync_inode_data_buffers
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark inode as not dirty.  It will still be on the dirty&n;&t;&t; * inode list, but we&squot;ll know not to commit it again unless&n;&t;&t; * it gets marked dirty again&n;&t;&t; */
id|clear_cflag
c_func
(paren
id|COMMIT_Dirty
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/* inherit anonymous tlock(s) of inode */
r_if
c_cond
(paren
id|jfs_ip-&gt;atlhead
)paren
(brace
id|lid_to_tlock
c_func
(paren
id|jfs_ip-&gt;atltail
)paren
op_member_access_from_pointer
id|next
op_assign
id|tblk-&gt;next
suffix:semicolon
id|tblk-&gt;next
op_assign
id|jfs_ip-&gt;atlhead
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tblk-&gt;last
)paren
id|tblk-&gt;last
op_assign
id|jfs_ip-&gt;atltail
suffix:semicolon
id|jfs_ip-&gt;atlhead
op_assign
id|jfs_ip-&gt;atltail
op_assign
l_int|0
suffix:semicolon
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|jfs_ip-&gt;anon_inode_list
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * acquire transaction lock on on-disk inode page&n;&t;&t; * (become first tlock of the tblk&squot;s tlock list)&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|rc
op_assign
id|diWrite
c_func
(paren
id|tid
comma
id|ip
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      write log records from transaction locks&n;&t; *&n;&t; * txUpdateMap() resets XAD_NEW in XAD.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|txLog
c_func
(paren
id|log
comma
id|tblk
comma
op_amp
id|cd
)paren
)paren
)paren
r_goto
id|TheEnd
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that inode isn&squot;t reused before&n;&t; * lazy commit thread finishes processing&n;&t; */
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
(paren
id|COMMIT_CREATE
op_or
id|COMMIT_DELETE
)paren
)paren
id|atomic_inc
c_func
(paren
op_amp
id|tblk-&gt;ip-&gt;i_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_DELETE
)paren
(brace
id|ip
op_assign
id|tblk-&gt;ip
suffix:semicolon
m_assert
(paren
(paren
id|ip-&gt;i_nlink
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
)paren
suffix:semicolon
id|set_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      write COMMIT log record&n;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_COMMIT
)paren
suffix:semicolon
id|lrd-&gt;length
op_assign
l_int|0
suffix:semicolon
id|lsn
op_assign
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
suffix:semicolon
id|lmGroupCommit
c_func
(paren
id|log
comma
id|tblk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      - transaction is now committed -&n;&t; */
multiline_comment|/*&n;&t; * force pages in careful update&n;&t; * (imap addressing structure update)&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|COMMIT_FORCE
)paren
id|txForce
c_func
(paren
id|tblk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      update allocation map.&n;&t; *&n;&t; * update inode allocation map and inode:&n;&t; * free pager lock on memory object of inode if any.&n;&t; * update  block allocation map.&n;&t; *&n;&t; * txUpdateMap() resets XAD_NEW in XAD.&n;&t; */
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_FORCE
)paren
id|txUpdateMap
c_func
(paren
id|tblk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      free transaction locks and pageout/free pages&n;&t; */
id|txRelease
c_func
(paren
id|tblk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_LAZY
)paren
op_eq
l_int|0
)paren
id|txUnlock
c_func
(paren
id|tblk
comma
id|flag
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      reset in-memory object state&n;&t; */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|cd.nip
suffix:semicolon
id|k
op_increment
)paren
(brace
id|ip
op_assign
id|cd.iplist
(braket
id|k
)braket
suffix:semicolon
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * reset in-memory inode state&n;&t;&t; */
id|jfs_ip-&gt;bxflag
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;blid
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|rc
op_ne
l_int|0
)paren
id|txAbortCommit
c_func
(paren
op_amp
id|cd
comma
id|rc
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|rc1
suffix:semicolon
id|TheEnd
suffix:colon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txCommit: tid = %d, returning %d&bslash;n&quot;
comma
id|tid
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        txLog()&n; *&n; * FUNCTION:    Writes AFTER log records for all lines modified&n; *              by tid for segments specified by inodes in comdata.&n; *              Code assumes only WRITELOCKS are recorded in lockwords.&n; *&n; * PARAMETERS:&n; *&n; * RETURN :&n; */
DECL|function|txLog
r_static
r_int
id|txLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|commit_t
op_star
id|cd
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|ip
suffix:semicolon
id|lid_t
id|lid
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|lrd_t
op_star
id|lrd
op_assign
op_amp
id|cd-&gt;lrd
suffix:semicolon
multiline_comment|/*&n;&t; * write log record(s) for each tlock of transaction,&n;&t; */
r_for
c_loop
(paren
id|lid
op_assign
id|tblk-&gt;next
suffix:semicolon
id|lid
suffix:semicolon
id|lid
op_assign
id|tlck-&gt;next
)paren
(brace
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
id|tlck-&gt;flag
op_or_assign
id|tlckLOG
suffix:semicolon
multiline_comment|/* initialize lrd common */
id|ip
op_assign
id|tlck-&gt;ip
suffix:semicolon
id|lrd-&gt;aggregate
op_assign
id|cpu_to_le32
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|ip-&gt;i_dev
)paren
)paren
suffix:semicolon
id|lrd-&gt;log.redopage.fileset
op_assign
id|cpu_to_le32
c_func
(paren
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|fileset
)paren
suffix:semicolon
id|lrd-&gt;log.redopage.inode
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;mp
)paren
id|hold_metapage
c_func
(paren
id|tlck-&gt;mp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* write log record of page from the tlock */
r_switch
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckTYPE
)paren
(brace
r_case
id|tlckXTREE
suffix:colon
id|xtLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlckDTREE
suffix:colon
id|dtLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlckINODE
suffix:colon
id|diLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
comma
id|cd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlckMAP
suffix:colon
id|mapLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tlckDATA
suffix:colon
id|dataLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;UFO tlock:0x%p&bslash;n&quot;
comma
id|tlck
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tlck-&gt;mp
)paren
id|release_metapage
c_func
(paren
id|tlck-&gt;mp
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      diLog()&n; *&n; * function:    log inode tlock and format maplock to update bmap;&n; */
DECL|function|diLog
r_int
id|diLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
comma
id|commit_t
op_star
id|cd
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|mp
op_assign
id|tlck-&gt;mp
suffix:semicolon
multiline_comment|/* initialize as REDOPAGE record format */
id|lrd-&gt;log.redopage.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_INODE
)paren
suffix:semicolon
id|lrd-&gt;log.redopage.l2linesize
op_assign
id|cpu_to_le16
c_func
(paren
id|L2INODESLOTSIZE
)paren
suffix:semicolon
id|pxd
op_assign
op_amp
id|lrd-&gt;log.redopage.pxd
suffix:semicolon
multiline_comment|/*&n;&t; *      inode after image&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckENTRY
)paren
(brace
multiline_comment|/* log after-image for logredo(): */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_REDOPAGE
)paren
suffix:semicolon
singleline_comment|//              *pxd = mp-&gt;cm_pxd;
id|PXDaddress
c_func
(paren
id|pxd
comma
id|mp-&gt;index
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|mp-&gt;logical_size
op_rshift
id|tblk-&gt;sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* mark page as homeward bound */
id|tlck-&gt;flag
op_or_assign
id|tlckWRITEPAGE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckFREE
)paren
(brace
multiline_comment|/*&n;&t;&t; *      free inode extent&n;&t;&t; *&n;&t;&t; * (pages of the freed inode extent have been invalidated and&n;&t;&t; * a maplock for free of the extent has been formatted at&n;&t;&t; * txLock() time);&n;&t;&t; *&n;&t;&t; * the tlock had been acquired on the inode allocation map page&n;&t;&t; * (iag) that specifies the freed extent, even though the map&n;&t;&t; * page is not itself logged, to prevent pageout of the map&n;&t;&t; * page before the log;&n;&t;&t; */
m_assert
(paren
id|tlck-&gt;type
op_amp
id|tlckFREE
)paren
suffix:semicolon
multiline_comment|/* log LOG_NOREDOINOEXT of the freed inode extent for&n;&t;&t; * logredo() to start NoRedoPage filters, and to update&n;&t;&t; * imap and bmap for free of the extent;&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_NOREDOINOEXT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For the LOG_NOREDOINOEXT record, we need&n;&t;&t; * to pass the IAG number and inode extent&n;&t;&t; * index (within that IAG) from which the&n;&t;&t; * the extent being released.  These have been&n;&t;&t; * passed to us in the iplist[1] and iplist[2].&n;&t;&t; */
id|lrd-&gt;log.noredoinoext.iagnum
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|u32
)paren
(paren
r_int
)paren
id|cd-&gt;iplist
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|lrd-&gt;log.noredoinoext.inoext_idx
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|u32
)paren
(paren
r_int
)paren
id|cd-&gt;iplist
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
op_star
id|pxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
multiline_comment|/* update bmap */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
multiline_comment|/* mark page as homeward bound */
id|tlck-&gt;flag
op_or_assign
id|tlckWRITEPAGE
suffix:semicolon
)brace
r_else
(brace
id|jERROR
c_func
(paren
l_int|2
comma
(paren
l_string|&quot;diLog: UFO type tlck:0x%p&bslash;n&quot;
comma
id|tlck
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef  _JFS_WIP
multiline_comment|/*&n;&t; *      alloc/free external EA extent&n;&t; *&n;&t; * a maplock for txUpdateMap() to update bPWMAP for alloc/free&n;&t; * of the extent has been formatted at txLock() time;&n;&t; */
r_else
(brace
m_assert
(paren
id|tlck-&gt;type
op_amp
id|tlckEA
)paren
suffix:semicolon
multiline_comment|/* log LOG_UPDATEMAP for logredo() to update bmap for&n;&t;&t; * alloc of new (and free of old) external EA extent;&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_UPDATEMAP
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|nlock
op_assign
id|pxdlock-&gt;index
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nlock
suffix:semicolon
id|i
op_increment
comma
id|pxdlock
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pxdlock-&gt;flag
op_amp
id|mlckALLOCPXD
)paren
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_ALLOCPXD
)paren
suffix:semicolon
r_else
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_FREEPXD
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.nxd
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.pxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* update bmap */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_WIP */
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *      dataLog()&n; *&n; * function:    log data tlock&n; */
DECL|function|dataLog
r_int
id|dataLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
(brace
id|metapage_t
op_star
id|mp
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
r_int
id|xflag
suffix:semicolon
id|s32
id|xlen
suffix:semicolon
id|mp
op_assign
id|tlck-&gt;mp
suffix:semicolon
multiline_comment|/* initialize as REDOPAGE record format */
id|lrd-&gt;log.redopage.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_DATA
)paren
suffix:semicolon
id|lrd-&gt;log.redopage.l2linesize
op_assign
id|cpu_to_le16
c_func
(paren
id|L2DATASLOTSIZE
)paren
suffix:semicolon
id|pxd
op_assign
op_amp
id|lrd-&gt;log.redopage.pxd
suffix:semicolon
multiline_comment|/* log after-image for logredo(): */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_REDOPAGE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|JFS_IP
c_func
(paren
id|tlck-&gt;ip
)paren
op_member_access_from_pointer
id|next_index
OL
id|MAX_INLINE_DIRTABLE_ENTRY
)paren
(brace
multiline_comment|/*&n;&t;&t; * The table has been truncated, we&squot;ve must have deleted&n;&t;&t; * the last entry, so don&squot;t bother logging this&n;&t;&t; */
id|mp-&gt;lid
op_assign
l_int|0
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
suffix:semicolon
id|discard_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|tlck-&gt;mp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rc
op_assign
id|xtLookup
c_func
(paren
id|tlck-&gt;ip
comma
id|mp-&gt;index
comma
l_int|1
comma
op_amp
id|xflag
comma
op_amp
id|xaddr
comma
op_amp
id|xlen
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_logical_or
(paren
id|xlen
op_eq
l_int|0
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;dataLog: can&squot;t find physical address&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|PXDaddress
c_func
(paren
id|pxd
comma
id|xaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|mp-&gt;logical_size
op_rshift
id|tblk-&gt;sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* mark page as homeward bound */
id|tlck-&gt;flag
op_or_assign
id|tlckWRITEPAGE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *      dtLog()&n; *&n; * function:    log dtree tlock and format maplock to update bmap;&n; */
DECL|function|dtLog
r_void
id|dtLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
(brace
r_struct
id|inode
op_star
id|ip
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|ip
op_assign
id|tlck-&gt;ip
suffix:semicolon
id|mp
op_assign
id|tlck-&gt;mp
suffix:semicolon
multiline_comment|/* initialize as REDOPAGE/NOREDOPAGE record format */
id|lrd-&gt;log.redopage.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_DTREE
)paren
suffix:semicolon
id|lrd-&gt;log.redopage.l2linesize
op_assign
id|cpu_to_le16
c_func
(paren
id|L2DTSLOTSIZE
)paren
suffix:semicolon
id|pxd
op_assign
op_amp
id|lrd-&gt;log.redopage.pxd
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
id|lrd-&gt;log.redopage.type
op_or_assign
id|cpu_to_le16
c_func
(paren
id|LOG_BTROOT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      page extension via relocation: entry insertion;&n;&t; *      page extension in-place: entry insertion;&n;&t; *      new right page from page split, reinitialized in-line&n;&t; *      root from root page split: entry insertion;&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
(paren
id|tlckNEW
op_or
id|tlckEXTEND
)paren
)paren
(brace
multiline_comment|/* log after-image of the new page for logredo():&n;&t;&t; * mark log (LOG_NEW) for logredo() to initialize&n;&t;&t; * freelist and update bmap for alloc of the new page;&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_REDOPAGE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckEXTEND
)paren
id|lrd-&gt;log.redopage.type
op_or_assign
id|cpu_to_le16
c_func
(paren
id|LOG_EXTEND
)paren
suffix:semicolon
r_else
id|lrd-&gt;log.redopage.type
op_or_assign
id|cpu_to_le16
c_func
(paren
id|LOG_NEW
)paren
suffix:semicolon
singleline_comment|//              *pxd = mp-&gt;cm_pxd;
id|PXDaddress
c_func
(paren
id|pxd
comma
id|mp-&gt;index
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|mp-&gt;logical_size
op_rshift
id|tblk-&gt;sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* format a maplock for txUpdateMap() to update bPMAP for&n;&t;&t; * alloc of the new page;&n;&t;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
r_return
suffix:semicolon
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckALLOCPXD
suffix:semicolon
id|pxdlock-&gt;pxd
op_assign
op_star
id|pxd
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* mark page as homeward bound */
id|tlck-&gt;flag
op_or_assign
id|tlckWRITEPAGE
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      entry insertion/deletion,&n;&t; *      sibling page link update (old right page before split);&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
(paren
id|tlckENTRY
op_or
id|tlckRELINK
)paren
)paren
(brace
multiline_comment|/* log after-image for logredo(): */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_REDOPAGE
)paren
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|mp-&gt;index
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|mp-&gt;logical_size
op_rshift
id|tblk-&gt;sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* mark page as homeward bound */
id|tlck-&gt;flag
op_or_assign
id|tlckWRITEPAGE
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      page deletion: page has been invalidated&n;&t; *      page relocation: source extent&n;&t; *&n;&t; *      a maplock for free of the page has been formatted&n;&t; *      at txLock() time);&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
(paren
id|tlckFREE
op_or
id|tlckRELOCATE
)paren
)paren
(brace
multiline_comment|/* log LOG_NOREDOPAGE of the deleted page for logredo()&n;&t;&t; * to start NoRedoPage filter and to update bmap for free&n;&t;&t; * of the deletd page&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_NOREDOPAGE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
op_star
id|pxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
multiline_comment|/* a maplock for txUpdateMap() for free of the page&n;&t;&t; * has been formatted at txLock() time;&n;&t;&t; */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *      xtLog()&n; *&n; * function:    log xtree tlock and format maplock to update bmap;&n; */
DECL|function|xtLog
r_void
id|xtLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
(brace
r_struct
id|inode
op_star
id|ip
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|xtpage_t
op_star
id|p
suffix:semicolon
id|xtlock_t
op_star
id|xtlck
suffix:semicolon
id|maplock_t
op_star
id|maplock
suffix:semicolon
id|xdlistlock_t
op_star
id|xadlock
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
r_int
id|next
comma
id|lwm
comma
id|hwm
suffix:semicolon
id|ip
op_assign
id|tlck-&gt;ip
suffix:semicolon
id|mp
op_assign
id|tlck-&gt;mp
suffix:semicolon
multiline_comment|/* initialize as REDOPAGE/NOREDOPAGE record format */
id|lrd-&gt;log.redopage.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_XTREE
)paren
suffix:semicolon
id|lrd-&gt;log.redopage.l2linesize
op_assign
id|cpu_to_le16
c_func
(paren
id|L2XTSLOTSIZE
)paren
suffix:semicolon
id|pxd
op_assign
op_amp
id|lrd-&gt;log.redopage.pxd
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
(brace
id|lrd-&gt;log.redopage.type
op_or_assign
id|cpu_to_le16
c_func
(paren
id|LOG_BTROOT
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|i_xtroot
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
id|lrd-&gt;log.redopage.type
op_or_assign
id|cpu_to_le16
c_func
(paren
id|LOG_DIR_XTREE
)paren
suffix:semicolon
)brace
r_else
id|p
op_assign
(paren
id|xtpage_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|next
op_assign
id|le16_to_cpu
c_func
(paren
id|p-&gt;header.nextindex
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|maplock
op_assign
(paren
id|maplock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|xadlock
op_assign
(paren
id|xdlistlock_t
op_star
)paren
id|maplock
suffix:semicolon
multiline_comment|/*&n;&t; *      entry insertion/extension;&n;&t; *      sibling page link update (old right page before split);&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
(paren
id|tlckNEW
op_or
id|tlckGROW
op_or
id|tlckRELINK
)paren
)paren
(brace
multiline_comment|/* log after-image for logredo():&n;&t;&t; * logredo() will update bmap for alloc of new/extended&n;&t;&t; * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from&n;&t;&t; * after-image of XADlist;&n;&t;&t; * logredo() resets (XAD_NEW|XAD_EXTEND) flag when&n;&t;&t; * applying the after-image to the meta-data page.&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_REDOPAGE
)paren
suffix:semicolon
singleline_comment|//              *pxd = mp-&gt;cm_pxd;
id|PXDaddress
c_func
(paren
id|pxd
comma
id|mp-&gt;index
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|mp-&gt;logical_size
op_rshift
id|tblk-&gt;sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* format a maplock for txUpdateMap() to update bPMAP&n;&t;&t; * for alloc of new/extended extents of XAD[lwm:next)&n;&t;&t; * from the page itself;&n;&t;&t; * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.&n;&t;&t; */
id|lwm
op_assign
id|xtlck-&gt;lwm.offset
suffix:semicolon
r_if
c_cond
(paren
id|lwm
op_eq
l_int|0
)paren
id|lwm
op_assign
id|XTPAGEMAXSLOT
suffix:semicolon
r_if
c_cond
(paren
id|lwm
op_eq
id|next
)paren
r_goto
id|out
suffix:semicolon
m_assert
(paren
id|lwm
OL
id|next
)paren
suffix:semicolon
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
id|xadlock-&gt;flag
op_assign
id|mlckALLOCXADLIST
suffix:semicolon
id|xadlock-&gt;count
op_assign
id|next
op_minus
id|lwm
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xadlock-&gt;count
op_le
l_int|2
)paren
op_logical_and
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_LAZY
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Lazy commit may allow xtree to be modified before&n;&t;&t;&t; * txUpdateMap runs.  Copy xad into linelock to&n;&t;&t;&t; * preserve correct data.&n;&t;&t;&t; */
id|xadlock-&gt;xdlist
op_assign
op_amp
id|xtlck-&gt;pxdlock
suffix:semicolon
id|memcpy
c_func
(paren
id|xadlock-&gt;xdlist
comma
op_amp
id|p-&gt;xad
(braket
id|lwm
)braket
comma
r_sizeof
(paren
id|xad_t
)paren
op_star
id|xadlock-&gt;count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|xadlock-&gt;count
suffix:semicolon
id|i
op_increment
)paren
id|p-&gt;xad
(braket
id|lwm
op_plus
id|i
)braket
dot
id|flag
op_and_assign
op_complement
(paren
id|XAD_NEW
op_or
id|XAD_EXTENDED
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * xdlist will point to into inode&squot;s xtree, ensure&n;&t;&t;&t; * that transaction is not committed lazily.&n;&t;&t;&t; */
id|xadlock-&gt;xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|lwm
)braket
suffix:semicolon
id|tblk-&gt;xflag
op_and_assign
op_complement
id|COMMIT_LAZY
suffix:semicolon
)brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLog: alloc ip:0x%p mp:0x%p tlck:0x%p lwm:%d count:%d&bslash;n&quot;
comma
id|tlck-&gt;ip
comma
id|mp
comma
id|tlck
comma
id|lwm
comma
id|xadlock-&gt;count
)paren
)paren
suffix:semicolon
id|maplock-&gt;index
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* mark page as homeward bound */
id|tlck-&gt;flag
op_or_assign
id|tlckWRITEPAGE
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      page deletion: file deletion/truncation (ref. xtTruncate())&n;&t; *&n;&t; * (page will be invalidated after log is written and bmap&n;&t; * is updated from the page);&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckFREE
)paren
(brace
multiline_comment|/* LOG_NOREDOPAGE log for NoRedoPage filter:&n;&t;&t; * if page free from file delete, NoRedoFile filter from&n;&t;&t; * inode image of zero link count will subsume NoRedoPage&n;&t;&t; * filters for each page;&n;&t;&t; * if page free from file truncattion, write NoRedoPage&n;&t;&t; * filter;&n;&t;&t; *&n;&t;&t; * upadte of block allocation map for the page itself:&n;&t;&t; * if page free from deletion and truncation, LOG_UPDATEMAP&n;&t;&t; * log for the page itself is generated from processing&n;&t;&t; * its parent page xad entries;&n;&t;&t; */
multiline_comment|/* if page free from file truncation, log LOG_NOREDOPAGE&n;&t;&t; * of the deleted page for logredo() to start NoRedoPage&n;&t;&t; * filter for the page;&n;&t;&t; */
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_TRUNCATE
)paren
(brace
multiline_comment|/* write NOREDOPAGE for the page */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_NOREDOPAGE
)paren
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|mp-&gt;index
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|mp-&gt;logical_size
op_rshift
id|tblk-&gt;sb
op_member_access_from_pointer
id|s_blocksize_bits
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
(brace
multiline_comment|/* Empty xtree must be logged */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_REDOPAGE
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* init LOG_UPDATEMAP of the freed extents&n;&t;&t; * XAD[XTENTRYSTART:hwm) from the deleted page itself&n;&t;&t; * for logredo() to update bmap;&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_UPDATEMAP
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_FREEXADLIST
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|hwm
op_assign
id|xtlck-&gt;hwm.offset
suffix:semicolon
id|lrd-&gt;log.updatemap.nxd
op_assign
id|cpu_to_le16
c_func
(paren
id|hwm
op_minus
id|XTENTRYSTART
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* reformat linelock for lmLog() */
id|xtlck-&gt;header.offset
op_assign
id|XTENTRYSTART
suffix:semicolon
id|xtlck-&gt;header.length
op_assign
id|hwm
op_minus
id|XTENTRYSTART
op_plus
l_int|1
suffix:semicolon
id|xtlck-&gt;index
op_assign
l_int|1
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
multiline_comment|/* format a maplock for txUpdateMap() to update bmap&n;&t;&t; * to free extents of XAD[XTENTRYSTART:hwm) from the&n;&t;&t; * deleted page itself;&n;&t;&t; */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
id|xadlock-&gt;flag
op_assign
id|mlckFREEXADLIST
suffix:semicolon
id|xadlock-&gt;count
op_assign
id|hwm
op_minus
id|XTENTRYSTART
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xadlock-&gt;count
op_le
l_int|2
)paren
op_logical_and
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_LAZY
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Lazy commit may allow xtree to be modified before&n;&t;&t;&t; * txUpdateMap runs.  Copy xad into linelock to&n;&t;&t;&t; * preserve correct data.&n;&t;&t;&t; */
id|xadlock-&gt;xdlist
op_assign
op_amp
id|xtlck-&gt;pxdlock
suffix:semicolon
id|memcpy
c_func
(paren
id|xadlock-&gt;xdlist
comma
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
comma
r_sizeof
(paren
id|xad_t
)paren
op_star
id|xadlock-&gt;count
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * xdlist will point to into inode&squot;s xtree, ensure&n;&t;&t;&t; * that transaction is not committed lazily unless&n;&t;&t;&t; * we&squot;re deleting the inode (unlink).  In that case&n;&t;&t;&t; * we have special logic for the inode to be&n;&t;&t;&t; * unlocked by the lazy commit thread.&n;&t;&t;&t; */
id|xadlock-&gt;xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_LAZY
)paren
op_logical_and
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_DELETE
)paren
op_logical_and
(paren
id|tblk-&gt;ip
op_eq
id|ip
)paren
)paren
id|set_cflag
c_func
(paren
id|COMMIT_Holdlock
comma
id|ip
)paren
suffix:semicolon
r_else
id|tblk-&gt;xflag
op_and_assign
op_complement
id|COMMIT_LAZY
suffix:semicolon
)brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLog: free ip:0x%p mp:0x%p count:%d lwm:2&bslash;n&quot;
comma
id|tlck-&gt;ip
comma
id|mp
comma
id|xadlock-&gt;count
)paren
)paren
suffix:semicolon
id|maplock-&gt;index
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* mark page as invalid */
r_if
c_cond
(paren
(paren
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_PWMAP
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
)paren
id|tlck-&gt;flag
op_or_assign
id|tlckFREEPAGE
suffix:semicolon
multiline_comment|/*&n;&t;&t;   else (tblk-&gt;xflag &amp; COMMIT_PMAP)&n;&t;&t;   ? release the page;&n;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      page/entry truncation: file truncation (ref. xtTruncate())&n;&t; *&n;&t; *     |----------+------+------+---------------|&n;&t; *                |      |      |&n;&t; *                |      |     hwm - hwm before truncation&n;&t; *                |     next - truncation point&n;&t; *               lwm - lwm before truncation&n;&t; * header ?&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckTRUNCATE
)paren
(brace
id|pxd_t
id|tpxd
suffix:semicolon
multiline_comment|/* truncated extent of xad */
multiline_comment|/*&n;&t;&t; * For truncation the entire linelock may be used, so it would&n;&t;&t; * be difficult to store xad list in linelock itself.&n;&t;&t; * Therefore, we&squot;ll just force transaction to be committed&n;&t;&t; * synchronously, so that xtree pages won&squot;t be changed before&n;&t;&t; * txUpdateMap runs.&n;&t;&t; */
id|tblk-&gt;xflag
op_and_assign
op_complement
id|COMMIT_LAZY
suffix:semicolon
id|lwm
op_assign
id|xtlck-&gt;lwm.offset
suffix:semicolon
r_if
c_cond
(paren
id|lwm
op_eq
l_int|0
)paren
id|lwm
op_assign
id|XTPAGEMAXSLOT
suffix:semicolon
id|hwm
op_assign
id|xtlck-&gt;hwm.offset
suffix:semicolon
multiline_comment|/*&n;&t;&t; *      write log records&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * allocate entries XAD[lwm:next]:&n;&t;&t; */
r_if
c_cond
(paren
id|lwm
OL
id|next
)paren
(brace
multiline_comment|/* log after-image for logredo():&n;&t;&t;&t; * logredo() will update bmap for alloc of new/extended&n;&t;&t;&t; * extents (XAD_NEW|XAD_EXTEND) of XAD[lwm:next) from&n;&t;&t;&t; * after-image of XADlist;&n;&t;&t;&t; * logredo() resets (XAD_NEW|XAD_EXTEND) flag when&n;&t;&t;&t; * applying the after-image to the meta-data page.&n;&t;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_REDOPAGE
)paren
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|mp-&gt;index
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|mp-&gt;logical_size
op_rshift
id|tblk-&gt;sb
op_member_access_from_pointer
id|s_blocksize_bits
)paren
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * truncate entry XAD[hwm == next - 1]:&n;&t;&t; */
r_if
c_cond
(paren
id|hwm
op_eq
id|next
op_minus
l_int|1
)paren
(brace
multiline_comment|/* init LOG_UPDATEMAP for logredo() to update bmap for&n;&t;&t;&t; * free of truncated delta extent of the truncated&n;&t;&t;&t; * entry XAD[next - 1]:&n;&t;&t;&t; * (xtlck-&gt;pxdlock = truncated delta extent);&n;&t;&t;&t; */
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|xtlck-&gt;pxdlock
suffix:semicolon
multiline_comment|/* assert(pxdlock-&gt;type &amp; tlckTRUNCATE); */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_UPDATEMAP
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_FREEPXD
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.nxd
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.pxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
id|tpxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
multiline_comment|/* save to format maplock */
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * free entries XAD[next:hwm]:&n;&t;&t; */
r_if
c_cond
(paren
id|hwm
op_ge
id|next
)paren
(brace
multiline_comment|/* init LOG_UPDATEMAP of the freed extents&n;&t;&t;&t; * XAD[next:hwm] from the deleted page itself&n;&t;&t;&t; * for logredo() to update bmap;&n;&t;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_UPDATEMAP
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_FREEXADLIST
)paren
suffix:semicolon
id|xtlck
op_assign
(paren
id|xtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|hwm
op_assign
id|xtlck-&gt;hwm.offset
suffix:semicolon
id|lrd-&gt;log.updatemap.nxd
op_assign
id|cpu_to_le16
c_func
(paren
id|hwm
op_minus
id|next
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* reformat linelock for lmLog() */
id|xtlck-&gt;header.offset
op_assign
id|next
suffix:semicolon
id|xtlck-&gt;header.length
op_assign
id|hwm
op_minus
id|next
op_plus
l_int|1
suffix:semicolon
id|xtlck-&gt;index
op_assign
l_int|1
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
id|tlck
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *      format maplock(s) for txUpdateMap() to update bmap&n;&t;&t; */
id|maplock-&gt;index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * allocate entries XAD[lwm:next):&n;&t;&t; */
r_if
c_cond
(paren
id|lwm
OL
id|next
)paren
(brace
multiline_comment|/* format a maplock for txUpdateMap() to update bPMAP&n;&t;&t;&t; * for alloc of new/extended extents of XAD[lwm:next)&n;&t;&t;&t; * from the page itself;&n;&t;&t;&t; * txUpdateMap() resets (XAD_NEW|XAD_EXTEND) flag.&n;&t;&t;&t; */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
id|xadlock-&gt;flag
op_assign
id|mlckALLOCXADLIST
suffix:semicolon
id|xadlock-&gt;count
op_assign
id|next
op_minus
id|lwm
suffix:semicolon
id|xadlock-&gt;xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|lwm
)braket
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLog: alloc ip:0x%p mp:0x%p count:%d lwm:%d next:%d&bslash;n&quot;
comma
id|tlck-&gt;ip
comma
id|mp
comma
id|xadlock-&gt;count
comma
id|lwm
comma
id|next
)paren
)paren
suffix:semicolon
id|maplock-&gt;index
op_increment
suffix:semicolon
id|xadlock
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * truncate entry XAD[hwm == next - 1]:&n;&t;&t; */
r_if
c_cond
(paren
id|hwm
op_eq
id|next
op_minus
l_int|1
)paren
(brace
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
multiline_comment|/* format a maplock for txUpdateMap() to update bmap&n;&t;&t;&t; * to free truncated delta extent of the truncated&n;&t;&t;&t; * entry XAD[next - 1];&n;&t;&t;&t; * (xtlck-&gt;pxdlock = truncated delta extent);&n;&t;&t;&t; */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
id|xadlock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|pxdlock-&gt;count
op_assign
l_int|1
suffix:semicolon
id|pxdlock-&gt;pxd
op_assign
id|tpxd
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLog: truncate ip:0x%p mp:0x%p count:%d hwm:%d&bslash;n&quot;
comma
id|ip
comma
id|mp
comma
id|pxdlock-&gt;count
comma
id|hwm
)paren
)paren
suffix:semicolon
id|maplock-&gt;index
op_increment
suffix:semicolon
id|xadlock
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * free entries XAD[next:hwm]:&n;&t;&t; */
r_if
c_cond
(paren
id|hwm
op_ge
id|next
)paren
(brace
multiline_comment|/* format a maplock for txUpdateMap() to update bmap&n;&t;&t;&t; * to free extents of XAD[next:hwm] from thedeleted&n;&t;&t;&t; * page itself;&n;&t;&t;&t; */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
id|xadlock-&gt;flag
op_assign
id|mlckFREEXADLIST
suffix:semicolon
id|xadlock-&gt;count
op_assign
id|hwm
op_minus
id|next
op_plus
l_int|1
suffix:semicolon
id|xadlock-&gt;xdlist
op_assign
op_amp
id|p-&gt;xad
(braket
id|next
)braket
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;xtLog: free ip:0x%p mp:0x%p count:%d next:%d hwm:%d&bslash;n&quot;
comma
id|tlck-&gt;ip
comma
id|mp
comma
id|xadlock-&gt;count
comma
id|next
comma
id|hwm
)paren
)paren
suffix:semicolon
id|maplock-&gt;index
op_increment
suffix:semicolon
)brace
multiline_comment|/* mark page as homeward bound */
id|tlck-&gt;flag
op_or_assign
id|tlckWRITEPAGE
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *      mapLog()&n; *&n; * function:    log from maplock of freed data extents;&n; */
DECL|function|mapLog
r_void
id|mapLog
c_func
(paren
id|log_t
op_star
id|log
comma
id|tblock_t
op_star
id|tblk
comma
id|lrd_t
op_star
id|lrd
comma
id|tlock_t
op_star
id|tlck
)paren
(brace
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
r_int
id|i
comma
id|nlock
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
multiline_comment|/*&n;&t; *      page relocation: free the source page extent&n;&t; *&n;&t; * a maplock for txUpdateMap() for free of the page&n;&t; * has been formatted at txLock() time saving the src&n;&t; * relocated page address;&n;&t; */
r_if
c_cond
(paren
id|tlck-&gt;type
op_amp
id|tlckRELOCATE
)paren
(brace
multiline_comment|/* log LOG_NOREDOPAGE of the old relocated page&n;&t;&t; * for logredo() to start NoRedoPage filter;&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_NOREDOPAGE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxd
op_assign
op_amp
id|lrd-&gt;log.redopage.pxd
suffix:semicolon
op_star
id|pxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
multiline_comment|/* (N.B. currently, logredo() does NOT update bmap&n;&t;&t; * for free of the page itself for (LOG_XTREE|LOG_NOREDOPAGE);&n;&t;&t; * if page free from relocation, LOG_UPDATEMAP log is&n;&t;&t; * specifically generated now for logredo()&n;&t;&t; * to update bmap for free of src relocated page;&n;&t;&t; * (new flag LOG_RELOCATE may be introduced which will&n;&t;&t; * inform logredo() to start NORedoPage filter and also&n;&t;&t; * update block allocation map at the same time, thus&n;&t;&t; * avoiding an extra log write);&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_UPDATEMAP
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_FREEPXD
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.nxd
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.pxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
multiline_comment|/* a maplock for txUpdateMap() for free of the page&n;&t;&t; * has been formatted at txLock() time;&n;&t;&t; */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&n;&t; * Otherwise it&squot;s not a relocate request&n;&t; *&n;&t; */
r_else
(brace
multiline_comment|/* log LOG_UPDATEMAP for logredo() to update bmap for&n;&t;&t; * free of truncated/relocated delta extent of the data;&n;&t;&t; * e.g.: external EA extent, relocated/truncated extent&n;&t;&t; * from xtTailgate();&n;&t;&t; */
id|lrd-&gt;type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_UPDATEMAP
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|nlock
op_assign
id|pxdlock-&gt;index
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nlock
suffix:semicolon
id|i
op_increment
comma
id|pxdlock
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pxdlock-&gt;flag
op_amp
id|mlckALLOCPXD
)paren
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_ALLOCPXD
)paren
suffix:semicolon
r_else
id|lrd-&gt;log.updatemap.type
op_assign
id|cpu_to_le16
c_func
(paren
id|LOG_FREEPXD
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.nxd
op_assign
id|cpu_to_le16
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|lrd-&gt;log.updatemap.pxd
op_assign
id|pxdlock-&gt;pxd
suffix:semicolon
id|lrd-&gt;backchain
op_assign
id|cpu_to_le32
c_func
(paren
id|lmLog
c_func
(paren
id|log
comma
id|tblk
comma
id|lrd
comma
l_int|NULL
)paren
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;mapLog: xaddr:0x%lx xlen:0x%x&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|addressPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
comma
id|lengthPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* update bmap */
id|tlck-&gt;flag
op_or_assign
id|tlckUPDATEMAP
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      txEA()&n; *&n; * function:    acquire maplock for EA/ACL extents or&n; *              set COMMIT_INLINE flag;&n; */
DECL|function|txEA
r_void
id|txEA
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dxd_t
op_star
id|oldea
comma
id|dxd_t
op_star
id|newea
)paren
(brace
id|tlock_t
op_star
id|tlck
op_assign
l_int|NULL
suffix:semicolon
id|pxdlock_t
op_star
id|maplock
op_assign
l_int|NULL
comma
op_star
id|pxdlock
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * format maplock for alloc of new EA extent&n;&t; */
r_if
c_cond
(paren
id|newea
)paren
(brace
multiline_comment|/* Since the newea could be a completely zeroed entry we need to&n;&t;&t; * check for the two flags which indicate we should actually&n;&t;&t; * commit new EA data&n;&t;&t; */
r_if
c_cond
(paren
id|newea-&gt;flag
op_amp
id|DXD_EXTENT
)paren
(brace
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckMAP
)paren
suffix:semicolon
id|maplock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckALLOCPXD
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|addressDXD
c_func
(paren
id|newea
)paren
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|lengthDXD
c_func
(paren
id|newea
)paren
)paren
suffix:semicolon
id|pxdlock
op_increment
suffix:semicolon
id|maplock-&gt;index
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|newea-&gt;flag
op_amp
id|DXD_INLINE
)paren
(brace
id|tlck
op_assign
l_int|NULL
suffix:semicolon
id|set_cflag
c_func
(paren
id|COMMIT_Inlineea
comma
id|ip
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * format maplock for free of old EA extent&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_cflag
c_func
(paren
id|COMMIT_Nolink
comma
id|ip
)paren
op_logical_and
id|oldea-&gt;flag
op_amp
id|DXD_EXTENT
)paren
(brace
r_if
c_cond
(paren
id|tlck
op_eq
l_int|NULL
)paren
(brace
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckMAP
)paren
suffix:semicolon
id|maplock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|maplock-&gt;index
op_assign
l_int|0
suffix:semicolon
)brace
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|addressDXD
c_func
(paren
id|oldea
)paren
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|lengthDXD
c_func
(paren
id|oldea
)paren
)paren
suffix:semicolon
id|maplock-&gt;index
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      txForce()&n; *&n; * function: synchronously write pages locked by transaction&n; *              after txLog() but before txUpdateMap();&n; */
DECL|function|txForce
r_void
id|txForce
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
(brace
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|lid_t
id|lid
comma
id|next
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/*&n;&t; * reverse the order of transaction tlocks in&n;&t; * careful update order of address index pages&n;&t; * (right to left, bottom up)&n;&t; */
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|tblk-&gt;next
)paren
suffix:semicolon
id|lid
op_assign
id|tlck-&gt;next
suffix:semicolon
id|tlck-&gt;next
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|lid
)paren
(brace
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
id|next
op_assign
id|tlck-&gt;next
suffix:semicolon
id|tlck-&gt;next
op_assign
id|tblk-&gt;next
suffix:semicolon
id|tblk-&gt;next
op_assign
id|lid
suffix:semicolon
id|lid
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * synchronously write the page, and&n;&t; * hold the page for txUpdateMap();&n;&t; */
r_for
c_loop
(paren
id|lid
op_assign
id|tblk-&gt;next
suffix:semicolon
id|lid
suffix:semicolon
id|lid
op_assign
id|next
)paren
(brace
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
id|next
op_assign
id|tlck-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|tlck-&gt;mp
)paren
op_ne
l_int|NULL
op_logical_and
(paren
id|tlck-&gt;type
op_amp
id|tlckBTROOT
)paren
op_eq
l_int|0
)paren
(brace
m_assert
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckWRITEPAGE
)paren
(brace
id|tlck-&gt;flag
op_and_assign
op_complement
id|tlckWRITEPAGE
suffix:semicolon
multiline_comment|/* do not release page to freelist */
m_assert
(paren
id|atomic_read
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
)paren
suffix:semicolon
id|hold_metapage
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; *      txUpdateMap()&n; *&n; * function:    update persistent allocation map (and working map&n; *              if appropriate);&n; *&n; * parameter:&n; */
DECL|function|txUpdateMap
r_static
r_void
id|txUpdateMap
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
(brace
r_struct
id|inode
op_star
id|ip
suffix:semicolon
r_struct
id|inode
op_star
id|ipimap
suffix:semicolon
id|lid_t
id|lid
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|maplock_t
op_star
id|maplock
suffix:semicolon
id|pxdlock_t
id|pxdlock
suffix:semicolon
r_int
id|maptype
suffix:semicolon
r_int
id|k
comma
id|nlock
suffix:semicolon
id|metapage_t
op_star
id|mp
op_assign
l_int|0
suffix:semicolon
id|ipimap
op_assign
id|JFS_SBI
c_func
(paren
id|tblk-&gt;sb
)paren
op_member_access_from_pointer
id|ipimap
suffix:semicolon
id|maptype
op_assign
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_PMAP
)paren
ques
c_cond
id|COMMIT_PMAP
suffix:colon
id|COMMIT_PWMAP
suffix:semicolon
multiline_comment|/*&n;&t; *      update block allocation map&n;&t; *&n;&t; * update allocation state in pmap (and wmap) and&n;&t; * update lsn of the pmap page;&n;&t; */
multiline_comment|/*&n;&t; * scan each tlock/page of transaction for block allocation/free:&n;&t; *&n;&t; * for each tlock/page of transaction, update map.&n;&t; *  ? are there tlock for pmap and pwmap at the same time ?&n;&t; */
r_for
c_loop
(paren
id|lid
op_assign
id|tblk-&gt;next
suffix:semicolon
id|lid
suffix:semicolon
id|lid
op_assign
id|tlck-&gt;next
)paren
(brace
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tlck-&gt;flag
op_amp
id|tlckUPDATEMAP
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckFREEPAGE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Another thread may attempt to reuse freed space&n;&t;&t;&t; * immediately, so we want to get rid of the metapage&n;&t;&t;&t; * before anyone else has a chance to get it.&n;&t;&t;&t; * Lock metapage, update maps, then invalidate&n;&t;&t;&t; * the metapage.&n;&t;&t;&t; */
id|mp
op_assign
id|tlck-&gt;mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
suffix:semicolon
id|hold_metapage
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * extent list:&n;&t;&t; * . in-line PXD list:&n;&t;&t; * . out-of-line XAD list:&n;&t;&t; */
id|maplock
op_assign
(paren
id|maplock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|nlock
op_assign
id|maplock-&gt;index
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|nlock
suffix:semicolon
id|k
op_increment
comma
id|maplock
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * allocate blocks in persistent map:&n;&t;&t;&t; *&n;&t;&t;&t; * blocks have been allocated from wmap at alloc time;&n;&t;&t;&t; */
r_if
c_cond
(paren
id|maplock-&gt;flag
op_amp
id|mlckALLOC
)paren
(brace
id|txAllocPMap
c_func
(paren
id|ipimap
comma
id|maplock
comma
id|tblk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * free blocks in persistent and working map:&n;&t;&t;&t; * blocks will be freed in pmap and then in wmap;&n;&t;&t;&t; *&n;&t;&t;&t; * ? tblock specifies the PMAP/PWMAP based upon&n;&t;&t;&t; * transaction&n;&t;&t;&t; *&n;&t;&t;&t; * free blocks in persistent map:&n;&t;&t;&t; * blocks will be freed from wmap at last reference&n;&t;&t;&t; * release of the object for regular files;&n;&t;&t;&t; *&n;&t;&t;&t; * Alway free blocks from both persistent &amp; working&n;&t;&t;&t; * maps for directories&n;&t;&t;&t; */
r_else
(brace
multiline_comment|/* (maplock-&gt;flag &amp; mlckFREE) */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|tlck-&gt;ip-&gt;i_mode
)paren
)paren
id|txFreeMap
c_func
(paren
id|ipimap
comma
id|maplock
comma
id|tblk
comma
id|COMMIT_PWMAP
)paren
suffix:semicolon
r_else
id|txFreeMap
c_func
(paren
id|ipimap
comma
id|maplock
comma
id|tblk
comma
id|maptype
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckFREEPAGE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_LAZY
)paren
)paren
(brace
multiline_comment|/* This is equivalent to txRelease */
id|ASSERT
c_func
(paren
id|mp-&gt;lid
op_eq
id|lid
)paren
suffix:semicolon
id|tlck-&gt;mp-&gt;lid
op_assign
l_int|0
suffix:semicolon
)brace
m_assert
(paren
id|atomic_read
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
op_eq
l_int|1
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
suffix:semicolon
id|discard_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|tlck-&gt;mp
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *      update inode allocation map&n;&t; *&n;&t; * update allocation state in pmap and&n;&t; * update lsn of the pmap page;&n;&t; * update in-memory inode flag/state&n;&t; *&n;&t; * unlock mapper/write lock&n;&t; */
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_CREATE
)paren
(brace
id|ip
op_assign
id|tblk-&gt;ip
suffix:semicolon
id|ASSERT
c_func
(paren
id|test_cflag
c_func
(paren
id|COMMIT_New
comma
id|ip
)paren
)paren
suffix:semicolon
id|clear_cflag
c_func
(paren
id|COMMIT_New
comma
id|ip
)paren
suffix:semicolon
id|diUpdatePMap
c_func
(paren
id|ipimap
comma
id|ip-&gt;i_ino
comma
id|FALSE
comma
id|tblk
)paren
suffix:semicolon
id|ipimap-&gt;i_state
op_or_assign
id|I_DIRTY
suffix:semicolon
multiline_comment|/* update persistent block allocation map&n;&t;&t; * for the allocation of inode extent;&n;&t;&t; */
id|pxdlock.flag
op_assign
id|mlckALLOCPXD
suffix:semicolon
id|pxdlock.pxd
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ixpxd
suffix:semicolon
id|pxdlock.index
op_assign
l_int|1
suffix:semicolon
id|txAllocPMap
c_func
(paren
id|ip
comma
(paren
id|maplock_t
op_star
)paren
op_amp
id|pxdlock
comma
id|tblk
)paren
suffix:semicolon
id|iput
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tblk-&gt;xflag
op_amp
id|COMMIT_DELETE
)paren
(brace
id|ip
op_assign
id|tblk-&gt;ip
suffix:semicolon
id|diUpdatePMap
c_func
(paren
id|ipimap
comma
id|ip-&gt;i_ino
comma
id|TRUE
comma
id|tblk
)paren
suffix:semicolon
id|ipimap-&gt;i_state
op_or_assign
id|I_DIRTY
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_cflag
c_func
(paren
id|COMMIT_Holdlock
comma
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_LAZY
)paren
id|IWRITE_UNLOCK
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
id|iput
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      txAllocPMap()&n; *&n; * function: allocate from persistent map;&n; *&n; * parameter:&n; *      ipbmap  -&n; *      malock -&n; *              xad list:&n; *              pxd:&n; *&n; *      maptype -&n; *              allocate from persistent map;&n; *              free from persistent map;&n; *              (e.g., tmp file - free from working map at releae&n; *               of last reference);&n; *              free from persistent and working map;&n; *&n; *      lsn     - log sequence number;&n; */
DECL|function|txAllocPMap
r_static
r_void
id|txAllocPMap
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|maplock_t
op_star
id|maplock
comma
id|tblock_t
op_star
id|tblk
)paren
(brace
r_struct
id|inode
op_star
id|ipbmap
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipbmap
suffix:semicolon
id|xdlistlock_t
op_star
id|xadlistlock
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
r_int
id|xlen
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|xdlistlock_t
op_star
id|pxdlistlock
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * allocate from persistent map;&n;&t; */
r_if
c_cond
(paren
id|maplock-&gt;flag
op_amp
id|mlckALLOCXADLIST
)paren
(brace
id|xadlistlock
op_assign
(paren
id|xdlistlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|xad
op_assign
id|xadlistlock-&gt;xdlist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|xadlistlock-&gt;count
suffix:semicolon
id|n
op_increment
comma
id|xad
op_increment
)paren
(brace
r_if
c_cond
(paren
id|xad-&gt;flag
op_amp
(paren
id|XAD_NEW
op_or
id|XAD_EXTENDED
)paren
)paren
(brace
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|dbUpdatePMap
c_func
(paren
id|ipbmap
comma
id|FALSE
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
comma
id|tblk
)paren
suffix:semicolon
id|xad-&gt;flag
op_and_assign
op_complement
(paren
id|XAD_NEW
op_or
id|XAD_EXTENDED
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;allocPMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|maplock-&gt;flag
op_amp
id|mlckALLOCPXD
)paren
(brace
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
suffix:semicolon
id|dbUpdatePMap
c_func
(paren
id|ipbmap
comma
id|FALSE
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
comma
id|tblk
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;allocPMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (maplock-&gt;flag &amp; mlckALLOCPXDLIST) */
id|pxdlistlock
op_assign
(paren
id|xdlistlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|pxd
op_assign
id|pxdlistlock-&gt;xdlist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|pxdlistlock-&gt;count
suffix:semicolon
id|n
op_increment
comma
id|pxd
op_increment
)paren
(brace
id|xaddr
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|dbUpdatePMap
c_func
(paren
id|ipbmap
comma
id|FALSE
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
comma
id|tblk
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;allocPMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *      txFreeMap()&n; *&n; * function:    free from persistent and/or working map;&n; *&n; * todo: optimization&n; */
DECL|function|txFreeMap
r_void
id|txFreeMap
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|maplock_t
op_star
id|maplock
comma
id|tblock_t
op_star
id|tblk
comma
r_int
id|maptype
)paren
(brace
r_struct
id|inode
op_star
id|ipbmap
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipbmap
suffix:semicolon
id|xdlistlock_t
op_star
id|xadlistlock
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
r_int
id|xlen
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|xdlistlock_t
op_star
id|pxdlistlock
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
r_int
id|n
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txFreeMap: tblk:0x%p maplock:0x%p maptype:0x%x&bslash;n&quot;
comma
id|tblk
comma
id|maplock
comma
id|maptype
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free from persistent map;&n;&t; */
r_if
c_cond
(paren
id|maptype
op_eq
id|COMMIT_PMAP
op_logical_or
id|maptype
op_eq
id|COMMIT_PWMAP
)paren
(brace
r_if
c_cond
(paren
id|maplock-&gt;flag
op_amp
id|mlckFREEXADLIST
)paren
(brace
id|xadlistlock
op_assign
(paren
id|xdlistlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|xad
op_assign
id|xadlistlock-&gt;xdlist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|xadlistlock-&gt;count
suffix:semicolon
id|n
op_increment
comma
id|xad
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|xad-&gt;flag
op_amp
id|XAD_NEW
)paren
)paren
(brace
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|dbUpdatePMap
c_func
(paren
id|ipbmap
comma
id|TRUE
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
comma
id|tblk
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freePMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|maplock-&gt;flag
op_amp
id|mlckFREEPXD
)paren
(brace
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
suffix:semicolon
id|dbUpdatePMap
c_func
(paren
id|ipbmap
comma
id|TRUE
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
comma
id|tblk
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freePMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (maplock-&gt;flag &amp; mlckALLOCPXDLIST) */
id|pxdlistlock
op_assign
(paren
id|xdlistlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|pxd
op_assign
id|pxdlistlock-&gt;xdlist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|pxdlistlock-&gt;count
suffix:semicolon
id|n
op_increment
comma
id|pxd
op_increment
)paren
(brace
id|xaddr
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|dbUpdatePMap
c_func
(paren
id|ipbmap
comma
id|TRUE
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
comma
id|tblk
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freePMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * free from working map;&n;&t; */
r_if
c_cond
(paren
id|maptype
op_eq
id|COMMIT_PWMAP
op_logical_or
id|maptype
op_eq
id|COMMIT_WMAP
)paren
(brace
r_if
c_cond
(paren
id|maplock-&gt;flag
op_amp
id|mlckFREEXADLIST
)paren
(brace
id|xadlistlock
op_assign
(paren
id|xdlistlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|xad
op_assign
id|xadlistlock-&gt;xdlist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|xadlistlock-&gt;count
suffix:semicolon
id|n
op_increment
comma
id|xad
op_increment
)paren
(brace
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xad
)paren
suffix:semicolon
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
id|xad-&gt;flag
op_assign
l_int|0
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freeWMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|maplock-&gt;flag
op_amp
id|mlckFREEPXD
)paren
(brace
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
)paren
suffix:semicolon
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freeWMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (maplock-&gt;flag &amp; mlckFREEPXDLIST) */
id|pxdlistlock
op_assign
(paren
id|xdlistlock_t
op_star
)paren
id|maplock
suffix:semicolon
id|pxd
op_assign
id|pxdlistlock-&gt;xdlist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|pxdlistlock-&gt;count
suffix:semicolon
id|n
op_increment
comma
id|pxd
op_increment
)paren
(brace
id|xaddr
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;freeWMap: xaddr:0x%lx xlen:%d&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|xaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; *      txFreelock()&n; *&n; * function:    remove tlock from inode anonymous locklist&n; */
DECL|function|txFreelock
r_void
id|txFreelock
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|tlock_t
op_star
id|xtlck
comma
op_star
id|tlck
suffix:semicolon
id|lid_t
id|xlid
op_assign
l_int|0
comma
id|lid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jfs_ip-&gt;atlhead
)paren
r_return
suffix:semicolon
id|xtlck
op_assign
(paren
id|tlock_t
op_star
)paren
op_amp
id|jfs_ip-&gt;atlhead
suffix:semicolon
r_while
c_loop
(paren
(paren
id|lid
op_assign
id|xtlck-&gt;next
)paren
)paren
(brace
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tlck-&gt;flag
op_amp
id|tlckFREELOCK
)paren
(brace
id|xtlck-&gt;next
op_assign
id|tlck-&gt;next
suffix:semicolon
id|txLockFree
c_func
(paren
id|lid
)paren
suffix:semicolon
)brace
r_else
(brace
id|xtlck
op_assign
id|tlck
suffix:semicolon
id|xlid
op_assign
id|lid
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|jfs_ip-&gt;atlhead
)paren
id|jfs_ip-&gt;atltail
op_assign
id|xlid
suffix:semicolon
r_else
(brace
id|jfs_ip-&gt;atltail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If inode was on anon_list, remove it&n;&t;&t; */
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|jfs_ip-&gt;anon_inode_list
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *      txAbort()&n; *&n; * function: abort tx before commit;&n; *&n; * frees line-locks and segment locks for all&n; * segments in comdata structure.&n; * Optionally sets state of file-system to FM_DIRTY in super-block.&n; * log age of page-frames in memory for which caller has&n; * are reset to 0 (to avoid logwarap).&n; */
DECL|function|txAbort
r_void
id|txAbort
c_func
(paren
id|tid_t
id|tid
comma
r_int
id|dirty
)paren
(brace
id|lid_t
id|lid
comma
id|next
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|tblock_t
op_star
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txAbort: tid:%d dirty:0x%x&bslash;n&quot;
comma
id|tid
comma
id|dirty
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free tlocks of the transaction&n;&t; */
r_for
c_loop
(paren
id|lid
op_assign
id|tblk-&gt;next
suffix:semicolon
id|lid
suffix:semicolon
id|lid
op_assign
id|next
)paren
(brace
id|next
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|mp
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
op_member_access_from_pointer
id|mp
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|mp-&gt;lid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * reset lsn of page to avoid logwarap:&n;&t;&t;&t; *&n;&t;&t;&t; * (page may have been previously committed by another&n;&t;&t;&t; * transaction(s) but has not been paged, i.e.,&n;&t;&t;&t; * it may be on logsync list even though it has not&n;&t;&t;&t; * been logged for the current tx.)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
op_logical_and
id|mp-&gt;lsn
)paren
id|LogSyncRelease
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* insert tlock at head of freelist */
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
id|txLockFree
c_func
(paren
id|lid
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* caller will free the transaction block */
id|tblk-&gt;next
op_assign
id|tblk-&gt;last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * mark filesystem dirty&n;&t; */
r_if
c_cond
(paren
id|dirty
)paren
id|updateSuper
c_func
(paren
id|tblk-&gt;sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *      txAbortCommit()&n; *&n; * function: abort commit.&n; *&n; * frees tlocks of transaction; line-locks and segment locks for all&n; * segments in comdata structure. frees malloc storage&n; * sets state of file-system to FM_MDIRTY in super-block.&n; * log age of page-frames in memory for which caller has&n; * are reset to 0 (to avoid logwarap).&n; */
DECL|function|txAbortCommit
r_void
id|txAbortCommit
c_func
(paren
id|commit_t
op_star
id|cd
comma
r_int
id|exval
)paren
(brace
id|tblock_t
op_star
id|tblk
suffix:semicolon
id|tid_t
id|tid
suffix:semicolon
id|lid_t
id|lid
comma
id|next
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
m_assert
(paren
id|exval
op_eq
id|EIO
op_logical_or
id|exval
op_eq
id|ENOMEM
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txAbortCommit: cd:0x%p&bslash;n&quot;
comma
id|cd
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free tlocks of the transaction&n;&t; */
id|tid
op_assign
id|cd-&gt;tid
suffix:semicolon
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lid
op_assign
id|tblk-&gt;next
suffix:semicolon
id|lid
suffix:semicolon
id|lid
op_assign
id|next
)paren
(brace
id|next
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|mp
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
op_member_access_from_pointer
id|mp
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|mp-&gt;lid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * reset lsn of page to avoid logwarap;&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;xflag
op_amp
id|COMMIT_PAGE
)paren
id|LogSyncRelease
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* insert tlock at head of freelist */
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
id|txLockFree
c_func
(paren
id|lid
)paren
suffix:semicolon
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
)brace
id|tblk-&gt;next
op_assign
id|tblk-&gt;last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* free the transaction block */
id|txEnd
c_func
(paren
id|tid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * mark filesystem dirty&n;&t; */
id|updateSuper
c_func
(paren
id|cd-&gt;sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      txLazyCommit(void)&n; *&n; *&t;All transactions except those changing ipimap (COMMIT_FORCE) are&n; *&t;processed by this routine.  This insures that the inode and block&n; *&t;allocation maps are updated in order.  For synchronous transactions,&n; *&t;let the user thread finish processing after txUpdateMap() is called.&n; */
DECL|function|txLazyCommit
r_void
id|txLazyCommit
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
(brace
id|log_t
op_star
id|log
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_READY
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_UNLOCKED
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* We must have gotten ahead of the user thread&n;&t;&t; */
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_lazycommit: tblk 0x%p not unlocked&bslash;n&quot;
comma
id|tblk
)paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txLazyCommit: processing tblk 0x%p&bslash;n&quot;
comma
id|tblk
)paren
)paren
suffix:semicolon
id|txUpdateMap
c_func
(paren
id|tblk
)paren
suffix:semicolon
id|log
op_assign
(paren
id|log_t
op_star
)paren
id|JFS_SBI
c_func
(paren
id|tblk-&gt;sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|log-&gt;gclock
)paren
suffix:semicolon
singleline_comment|// LOGGC_LOCK
id|tblk-&gt;flag
op_or_assign
id|tblkGC_COMMITTED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_READY
)paren
op_logical_or
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_LAZY
)paren
)paren
id|log-&gt;gcrtc
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_READY
)paren
id|wake_up
c_func
(paren
op_amp
id|tblk-&gt;gcwait
)paren
suffix:semicolon
singleline_comment|// LOGGC_WAKEUP
id|spin_unlock_irq
c_func
(paren
op_amp
id|log-&gt;gclock
)paren
suffix:semicolon
singleline_comment|// LOGGC_UNLOCK
r_if
c_cond
(paren
id|tblk-&gt;flag
op_amp
id|tblkGC_LAZY
)paren
(brace
id|txUnlock
c_func
(paren
id|tblk
comma
l_int|0
)paren
suffix:semicolon
id|tblk-&gt;flag
op_and_assign
op_complement
id|tblkGC_LAZY
suffix:semicolon
id|txEnd
c_func
(paren
id|tblk
op_minus
id|TxBlock
)paren
suffix:semicolon
multiline_comment|/* Convert back to tid */
)brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;txLazyCommit: done: tblk = 0x%p&bslash;n&quot;
comma
id|tblk
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      jfs_lazycommit(void)&n; *&n; *&t;To be run as a kernel daemon.  If lbmIODone is called in an interrupt&n; *&t;context, or where blocking is not wanted, this routine will process&n; *&t;committed transactions from the unlock queue.&n; */
DECL|function|jfs_lazycommit
r_int
id|jfs_lazycommit
c_func
(paren
r_void
)paren
(brace
r_int
id|WorkDone
suffix:semicolon
id|tblock_t
op_star
id|tblk
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;jfsCommit&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|jfsCommitTask
op_assign
id|current
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGHUP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGCONT
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|LAZY_LOCK_INIT
c_func
(paren
)paren
suffix:semicolon
id|TxAnchor.unlock_queue
op_assign
id|TxAnchor.unlock_tail
op_assign
l_int|0
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|jfsIOwait
)paren
suffix:semicolon
r_do
(brace
id|LAZY_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|restart
suffix:colon
id|WorkDone
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tblk
op_assign
id|TxAnchor.unlock_queue
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We can&squot;t get ahead of user thread.  Spinning is&n;&t;&t;&t; * simpler than blocking/waking.  We shouldn&squot;t spin&n;&t;&t;&t; * very long, since user thread shouldn&squot;t be blocking&n;&t;&t;&t; * between lmGroupCommit &amp; txEnd.&n;&t;&t;&t; */
id|WorkDone
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Remove first transaction from queue&n;&t;&t;&t; */
id|TxAnchor.unlock_queue
op_assign
id|tblk-&gt;cqnext
suffix:semicolon
id|tblk-&gt;cqnext
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|TxAnchor.unlock_tail
op_eq
id|tblk
)paren
id|TxAnchor.unlock_tail
op_assign
l_int|0
suffix:semicolon
id|LAZY_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|txLazyCommit
c_func
(paren
id|tblk
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We can be running indefinately if other processors&n;&t;&t;&t; * are adding transactions to this list&n;&t;&t;&t; */
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|LAZY_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|WorkDone
)paren
r_goto
id|restart
suffix:semicolon
id|LAZY_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|jfs_thread_stopped
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxAnchor.unlock_queue
)paren
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_lazycommit being killed with pending transactions!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_else
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_lazycommit being killed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|jfsIOwait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|txLazyUnlock
r_void
id|txLazyUnlock
c_func
(paren
id|tblock_t
op_star
id|tblk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|LAZY_LOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxAnchor.unlock_tail
)paren
id|TxAnchor.unlock_tail-&gt;cqnext
op_assign
id|tblk
suffix:semicolon
r_else
id|TxAnchor.unlock_queue
op_assign
id|tblk
suffix:semicolon
id|TxAnchor.unlock_tail
op_assign
id|tblk
suffix:semicolon
id|tblk-&gt;cqnext
op_assign
l_int|0
suffix:semicolon
id|LAZY_UNLOCK
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|jfsCommitTask
)paren
suffix:semicolon
)brace
DECL|function|LogSyncRelease
r_static
r_void
id|LogSyncRelease
c_func
(paren
id|metapage_t
op_star
id|mp
)paren
(brace
id|log_t
op_star
id|log
op_assign
id|mp-&gt;log
suffix:semicolon
m_assert
(paren
id|atomic_read
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
)paren
suffix:semicolon
m_assert
(paren
id|log
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|mp-&gt;nohomeok
)paren
)paren
r_return
suffix:semicolon
id|hold_metapage
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|mp-&gt;log
op_assign
l_int|NULL
suffix:semicolon
id|mp-&gt;lsn
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;clsn
op_assign
l_int|0
suffix:semicolon
id|log-&gt;count
op_decrement
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|mp-&gt;synclist
)paren
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *      jfs_sync(void)&n; *&n; *&t;To be run as a kernel daemon.  This is awakened when tlocks run low.&n; *&t;We write any inodes that have anonymous tlocks so they will become&n; *&t;available.&n; */
DECL|function|jfs_sync
r_int
id|jfs_sync
c_func
(paren
r_void
)paren
(brace
r_struct
id|inode
op_star
id|ip
suffix:semicolon
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;jfsSync&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|jfsSyncTask
op_assign
id|current
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGHUP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGCONT
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|jfsIOwait
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * write each inode on the anonymous inode list&n;&t;&t; */
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|TlocksLow
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|TxAnchor.anon_list
)paren
)paren
(brace
id|jfs_ip
op_assign
id|list_entry
c_func
(paren
id|TxAnchor.anon_list.next
comma
r_struct
id|jfs_inode_info
comma
id|anon_inode_list
)paren
suffix:semicolon
id|ip
op_assign
op_amp
id|jfs_ip-&gt;vfs_inode
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We must release the TXN_LOCK since our&n;&t;&t;&t; * IWRITE_TRYLOCK implementation may still block&n;&t;&t;&t; */
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IWRITE_TRYLOCK
c_func
(paren
id|ip
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * inode will be removed from anonymous list&n;&t;&t;&t;&t; * when it is committed&n;&t;&t;&t;&t; */
id|jfs_commit_inode
c_func
(paren
id|ip
comma
l_int|0
)paren
suffix:semicolon
id|IWRITE_UNLOCK
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Just to be safe.  I don&squot;t know how&n;&t;&t;&t;&t; * long we can run without blocking&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|need_resched
c_func
(paren
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We can&squot;t get the write lock.  It may&n;&t;&t;&t;&t; * be held by a thread waiting for tlock&squot;s&n;&t;&t;&t;&t; * so let&squot;s not block here.  Save it to&n;&t;&t;&t;&t; * put back on the anon_list.&n;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t; * We released TXN_LOCK, let&squot;s make sure&n;&t;&t;&t;&t; * this inode is still there&n;&t;&t;&t;&t; */
id|TXN_LOCK
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TxAnchor.anon_list.next
op_ne
op_amp
id|jfs_ip-&gt;anon_inode_list
)paren
r_continue
suffix:semicolon
multiline_comment|/* Take off anon_list */
id|list_del
c_func
(paren
op_amp
id|jfs_ip-&gt;anon_inode_list
)paren
suffix:semicolon
multiline_comment|/* Put on anon_list2 */
id|list_add
c_func
(paren
op_amp
id|jfs_ip-&gt;anon_inode_list
comma
op_amp
id|TxAnchor.anon_list2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Add anon_list2 back to anon_list */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|TxAnchor.anon_list2
)paren
)paren
(brace
id|list_splice
c_func
(paren
op_amp
id|TxAnchor.anon_list2
comma
op_amp
id|TxAnchor.anon_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|TxAnchor.anon_list2
)paren
suffix:semicolon
)brace
id|TXN_UNLOCK
c_func
(paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|jfs_thread_stopped
c_func
(paren
)paren
)paren
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_sync being killed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|complete
c_func
(paren
op_amp
id|jfsIOwait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if CONFIG_PROC_FS
DECL|function|jfs_txanchor_read
r_int
id|jfs_txanchor_read
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
suffix:semicolon
r_char
op_star
id|freewait
suffix:semicolon
r_char
op_star
id|freelockwait
suffix:semicolon
r_char
op_star
id|lowlockwait
suffix:semicolon
id|freewait
op_assign
id|waitqueue_active
c_func
(paren
op_amp
id|TxAnchor.freewait
)paren
ques
c_cond
l_string|&quot;active&quot;
suffix:colon
l_string|&quot;empty&quot;
suffix:semicolon
id|freelockwait
op_assign
id|waitqueue_active
c_func
(paren
op_amp
id|TxAnchor.freelockwait
)paren
ques
c_cond
l_string|&quot;active&quot;
suffix:colon
l_string|&quot;empty&quot;
suffix:semicolon
id|lowlockwait
op_assign
id|waitqueue_active
c_func
(paren
op_amp
id|TxAnchor.lowlockwait
)paren
ques
c_cond
l_string|&quot;active&quot;
suffix:colon
l_string|&quot;empty&quot;
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;JFS TxAnchor&bslash;n&quot;
l_string|&quot;============&bslash;n&quot;
l_string|&quot;freetid = %d&bslash;n&quot;
l_string|&quot;freewait = %s&bslash;n&quot;
l_string|&quot;freelock = %d&bslash;n&quot;
l_string|&quot;freelockwait = %s&bslash;n&quot;
l_string|&quot;lowlockwait = %s&bslash;n&quot;
l_string|&quot;tlocksInUse = %d&bslash;n&quot;
l_string|&quot;unlock_queue = 0x%p&bslash;n&quot;
l_string|&quot;unlock_tail = 0x%p&bslash;n&quot;
comma
id|TxAnchor.freetid
comma
id|freewait
comma
id|TxAnchor.freelock
comma
id|freelockwait
comma
id|lowlockwait
comma
id|TxAnchor.tlocksInUse
comma
id|TxAnchor.unlock_queue
comma
id|TxAnchor.unlock_tail
)paren
suffix:semicolon
id|begin
op_assign
id|offset
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|begin
suffix:semicolon
id|len
op_sub_assign
id|begin
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_else
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif
eof
