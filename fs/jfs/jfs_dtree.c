multiline_comment|/*&n; *   Copyright (c) International Business Machines Corp., 2000-2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
multiline_comment|/*&n; *&t;jfs_dtree.c: directory B+-tree manager&n; *&n; * B+-tree with variable length key directory:&n; *&n; * each directory page is structured as an array of 32-byte&n; * directory entry slots initialized as a freelist&n; * to avoid search/compaction of free space at insertion.&n; * when an entry is inserted, a number of slots are allocated&n; * from the freelist as required to store variable length data&n; * of the entry; when the entry is deleted, slots of the entry&n; * are returned to freelist.&n; *&n; * leaf entry stores full name as key and file serial number&n; * (aka inode number) as data.&n; * internal/router entry stores sufffix compressed name&n; * as key and simple extent descriptor as data.&n; *&n; * each directory page maintains a sorted entry index table&n; * which stores the start slot index of sorted entries&n; * to allow binary search on the table.&n; *&n; * directory starts as a root/leaf page in on-disk inode&n; * inline data area.&n; * when it becomes full, it starts a leaf of a external extent&n; * of length of 1 block. each time the first leaf becomes full,&n; * it is extended rather than split (its size is doubled),&n; * until its length becoms 4 KBytes, from then the extent is split&n; * with new 4 Kbyte extent when it becomes full&n; * to reduce external fragmentation of small directories.&n; *&n; * blah, blah, blah, for linear scan of directory in pieces by&n; * readdir().&n; *&n; *&n; *&t;case-insensitive directory file system&n; *&n; * names are stored in case-sensitive way in leaf entry.&n; * but stored, searched and compared in case-insensitive (uppercase) order&n; * (i.e., both search key and entry key are folded for search/compare):&n; * (note that case-sensitive order is BROKEN in storage, e.g.,&n; *  sensitive: Ad, aB, aC, aD -&gt; insensitive: aB, aC, aD, Ad&n; *&n; *  entries which folds to the same key makes up a equivalent class&n; *  whose members are stored as contiguous cluster (may cross page boundary)&n; *  but whose order is arbitrary and acts as duplicate, e.g.,&n; *  abc, Abc, aBc, abC)&n; *&n; * once match is found at leaf, requires scan forward/backward&n; * either for, in case-insensitive search, duplicate&n; * or for, in case-sensitive search, for exact match&n; *&n; * router entry must be created/stored in case-insensitive way&n; * in internal entry:&n; * (right most key of left page and left most key of right page&n; * are folded, and its suffix compression is propagated as router&n; * key in parent)&n; * (e.g., if split occurs &lt;abc&gt; and &lt;aBd&gt;, &lt;ABD&gt; trather than &lt;aB&gt;&n; * should be made the router key for the split)&n; *&n; * case-insensitive search:&n; *&n; * &t;fold search key;&n; *&n; *&t;case-insensitive search of B-tree:&n; *&t;for internal entry, router key is already folded;&n; *&t;for leaf entry, fold the entry key before comparison.&n; *&n; *&t;if (leaf entry case-insensitive match found)&n; *&t;&t;if (next entry satisfies case-insensitive match)&n; *&t;&t;&t;return EDUPLICATE;&n; *&t;&t;if (prev entry satisfies case-insensitive match)&n; *&t;&t;&t;return EDUPLICATE;&n; *&t;&t;return match;&n; *&t;else&n; *&t;&t;return no match;&n; *&n; * &t;serialization:&n; * target directory inode lock is being held on entry/exit&n; * of all main directory service routines.&n; *&n; *&t;log based recovery:&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_superblock.h&quot;
macro_line|#include &quot;jfs_filsys.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_dmap.h&quot;
macro_line|#include &quot;jfs_unicode.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/* dtree split parameter */
r_typedef
r_struct
(brace
DECL|member|mp
id|metapage_t
op_star
id|mp
suffix:semicolon
DECL|member|index
id|s16
id|index
suffix:semicolon
DECL|member|nslot
id|s16
id|nslot
suffix:semicolon
DECL|member|key
id|component_t
op_star
id|key
suffix:semicolon
DECL|member|data
id|ddata_t
op_star
id|data
suffix:semicolon
DECL|member|pxdlist
id|pxdlist_t
op_star
id|pxdlist
suffix:semicolon
DECL|typedef|dtsplit_t
)brace
id|dtsplit_t
suffix:semicolon
DECL|macro|DT_PAGE
mdefine_line|#define DT_PAGE(IP, MP) BT_PAGE(IP, MP, dtpage_t, i_dtroot)
multiline_comment|/* get page buffer for specified block address */
DECL|macro|DT_GETPAGE
mdefine_line|#define DT_GETPAGE(IP, BN, MP, SIZE, P, RC)&bslash;&n;{&bslash;&n;&t;BT_GETPAGE(IP, BN, MP, dtpage_t, SIZE, P, RC, i_dtroot)&bslash;&n;&t;if (!(RC))&bslash;&n;&t;{&bslash;&n;&t;&t;if (((P)-&gt;header.nextindex &gt; (((BN)==0)?DTROOTMAXSLOT:(P)-&gt;header.maxslot)) ||&bslash;&n;&t;&t;    ((BN) &amp;&amp; ((P)-&gt;header.maxslot &gt; DTPAGEMAXSLOT)))&bslash;&n;&t;&t;{&bslash;&n;&t;&t;&t;jERROR(1,(&quot;DT_GETPAGE: dtree page corrupt&bslash;n&quot;));&bslash;&n;&t;&t;&t;BT_PUTPAGE(MP);&bslash;&n;&t;&t;&t;updateSuper((IP)-&gt;i_sb, FM_DIRTY);&bslash;&n;&t;&t;&t;MP = NULL;&bslash;&n;&t;&t;&t;RC = EIO;&bslash;&n;&t;&t;}&bslash;&n;&t;}&bslash;&n;}
multiline_comment|/* for consistency */
DECL|macro|DT_PUTPAGE
mdefine_line|#define DT_PUTPAGE(MP) BT_PUTPAGE(MP)
DECL|macro|DT_GETSEARCH
mdefine_line|#define DT_GETSEARCH(IP, LEAF, BN, MP, P, INDEX) &bslash;&n;&t;BT_GETSEARCH(IP, LEAF, BN, MP, dtpage_t, P, INDEX, i_dtroot)
multiline_comment|/*&n; * forward references&n; */
r_static
r_int
id|dtSplitUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|dtSplitPage
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
comma
id|dtpage_t
op_star
op_star
id|rpp
comma
id|pxd_t
op_star
id|rxdp
)paren
suffix:semicolon
r_static
r_int
id|dtExtendPage
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|dtSplitRoot
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
)paren
suffix:semicolon
r_static
r_int
id|dtDeleteUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|metapage_t
op_star
id|fmp
comma
id|dtpage_t
op_star
id|fp
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|dtSearchNode
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|lmxaddr
comma
id|pxd_t
op_star
id|kpxd
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|dtRelink
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtpage_t
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|dtReadFirst
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|dtReadNext
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|loff_t
op_star
id|offset
comma
id|btstack_t
op_star
id|btstack
)paren
suffix:semicolon
r_static
r_int
id|dtCompare
c_func
(paren
id|component_t
op_star
id|key
comma
id|dtpage_t
op_star
id|p
comma
r_int
id|si
)paren
suffix:semicolon
r_static
r_int
id|ciCompare
c_func
(paren
id|component_t
op_star
id|key
comma
id|dtpage_t
op_star
id|p
comma
r_int
id|si
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_void
id|dtGetKey
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|i
comma
id|component_t
op_star
id|key
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_void
id|ciGetLeafPrefixKey
c_func
(paren
id|dtpage_t
op_star
id|lp
comma
r_int
id|li
comma
id|dtpage_t
op_star
id|rp
comma
r_int
id|ri
comma
id|component_t
op_star
id|key
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_void
id|dtInsertEntry
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|index
comma
id|component_t
op_star
id|key
comma
id|ddata_t
op_star
id|data
comma
id|dtlock_t
op_star
op_star
id|dtlock
)paren
suffix:semicolon
r_static
r_void
id|dtMoveEntry
c_func
(paren
id|dtpage_t
op_star
id|sp
comma
r_int
id|si
comma
id|dtpage_t
op_star
id|dp
comma
id|dtlock_t
op_star
op_star
id|sdtlock
comma
id|dtlock_t
op_star
op_star
id|ddtlock
comma
r_int
id|do_index
)paren
suffix:semicolon
r_static
r_void
id|dtDeleteEntry
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|fi
comma
id|dtlock_t
op_star
op_star
id|dtlock
)paren
suffix:semicolon
r_static
r_void
id|dtTruncateEntry
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|ti
comma
id|dtlock_t
op_star
op_star
id|dtlock
)paren
suffix:semicolon
r_static
r_void
id|dtLinelockFreelist
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|m
comma
id|dtlock_t
op_star
op_star
id|dtlock
)paren
suffix:semicolon
DECL|macro|ciToUpper
mdefine_line|#define ciToUpper(c)&t;UniStrupr((c)-&gt;name)
multiline_comment|/*&n; *&t;find_index()&n; *&n; *&t;Returns dtree page containing directory table entry for specified&n; *&t;index and pointer to its entry.&n; *&n; *&t;mp must be released by caller.&n; */
DECL|function|find_index
r_static
id|dir_table_slot_t
op_star
id|find_index
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|u32
id|index
comma
id|metapage_t
op_star
op_star
id|mp
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|s64
id|blkno
suffix:semicolon
id|s64
id|offset
suffix:semicolon
r_int
id|page_offset
suffix:semicolon
id|dir_table_slot_t
op_star
id|slot
suffix:semicolon
r_static
r_int
id|maxWarnings
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|maxWarnings
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;find_entry called with index = %d&bslash;n&quot;
comma
id|index
)paren
)paren
suffix:semicolon
id|maxWarnings
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index
op_ge
id|jfs_ip-&gt;next_index
)paren
(brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;find_entry called with index &gt;= next_index&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jfs_ip-&gt;next_index
op_le
(paren
id|MAX_INLINE_DIRTABLE_ENTRY
op_plus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Inline directory table&n;&t;&t; */
op_star
id|mp
op_assign
l_int|0
suffix:semicolon
id|slot
op_assign
op_amp
id|jfs_ip-&gt;i_dirtable
(braket
id|index
op_minus
l_int|2
)braket
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
(paren
id|index
op_minus
l_int|2
)paren
op_star
r_sizeof
(paren
id|dir_table_slot_t
)paren
suffix:semicolon
id|page_offset
op_assign
id|offset
op_amp
(paren
id|PSIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|blkno
op_assign
(paren
(paren
id|offset
op_plus
l_int|1
)paren
op_rshift
id|L2PSIZE
)paren
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2nbperpage
suffix:semicolon
r_if
c_cond
(paren
op_star
id|mp
op_logical_and
(paren
(paren
op_star
id|mp
)paren
op_member_access_from_pointer
id|index
op_ne
id|blkno
)paren
)paren
(brace
id|release_metapage
c_func
(paren
op_star
id|mp
)paren
suffix:semicolon
op_star
id|mp
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|mp
op_eq
l_int|0
)paren
op_star
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ip
comma
id|blkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|mp
op_eq
l_int|0
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;free_index: error reading directory table&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|slot
op_assign
(paren
id|dir_table_slot_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
(paren
op_star
id|mp
)paren
op_member_access_from_pointer
id|data
op_plus
id|page_offset
)paren
suffix:semicolon
)brace
r_return
id|slot
suffix:semicolon
)brace
DECL|function|lock_index
r_static
r_inline
r_void
id|lock_index
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|metapage_t
op_star
id|mp
comma
id|u32
id|index
)paren
(brace
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|linelock_t
op_star
id|llck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDATA
)paren
suffix:semicolon
id|llck
op_assign
(paren
id|linelock_t
op_star
)paren
id|tlck-&gt;lock
suffix:semicolon
r_if
c_cond
(paren
id|llck-&gt;index
op_ge
id|llck-&gt;maxcnt
)paren
id|llck
op_assign
id|txLinelock
c_func
(paren
id|llck
)paren
suffix:semicolon
id|lv
op_assign
op_amp
id|llck-&gt;lv
(braket
id|llck-&gt;index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *      Linelock slot size is twice the size of directory table&n;&t; *      slot size.  512 entries per page.&n;&t; */
id|lv-&gt;offset
op_assign
(paren
(paren
id|index
op_minus
l_int|2
)paren
op_amp
l_int|511
)paren
op_rshift
l_int|1
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|llck-&gt;index
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;add_index()&n; *&n; *&t;Adds an entry to the directory index table.  This is used to provide&n; *&t;each directory entry with a persistent index in which to resume&n; *&t;directory traversals&n; */
DECL|function|add_index
r_static
id|u32
id|add_index
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|bn
comma
r_int
id|slot
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|u64
id|blkno
suffix:semicolon
id|dir_table_slot_t
op_star
id|dirtab_slot
suffix:semicolon
id|u32
id|index
suffix:semicolon
id|linelock_t
op_star
id|llck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|s64
id|offset
suffix:semicolon
id|uint
id|page_offset
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
id|ASSERT
c_func
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jfs_ip-&gt;next_index
OL
l_int|2
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;next_index = %d.  Please fix this!&bslash;n&quot;
comma
id|jfs_ip-&gt;next_index
)paren
)paren
suffix:semicolon
id|jfs_ip-&gt;next_index
op_assign
l_int|2
suffix:semicolon
)brace
id|index
op_assign
id|jfs_ip-&gt;next_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|index
op_le
id|MAX_INLINE_DIRTABLE_ENTRY
)paren
(brace
multiline_comment|/*&n;&t;&t; * i_size reflects size of index table, or 8 bytes per entry.&n;&t;&t; */
id|ip-&gt;i_size
op_assign
(paren
id|loff_t
)paren
(paren
id|index
op_minus
l_int|1
)paren
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t; * dir table fits inline within inode&n;&t;&t; */
id|dirtab_slot
op_assign
op_amp
id|jfs_ip-&gt;i_dirtable
(braket
id|index
op_minus
l_int|2
)braket
suffix:semicolon
id|dirtab_slot-&gt;flag
op_assign
id|DIR_INDEX_VALID
suffix:semicolon
id|dirtab_slot-&gt;slot
op_assign
id|slot
suffix:semicolon
id|DTSaddress
c_func
(paren
id|dirtab_slot
comma
id|bn
)paren
suffix:semicolon
id|set_cflag
c_func
(paren
id|COMMIT_Dirtable
comma
id|ip
)paren
suffix:semicolon
r_return
id|index
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index
op_eq
(paren
id|MAX_INLINE_DIRTABLE_ENTRY
op_plus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s time to move the inline table to an external&n;&t;&t; * page and begin to build the xtree&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * Save the table, we&squot;re going to overwrite it with the&n;&t;&t; * xtree root&n;&t;&t; */
id|dir_table_slot_t
id|temp_table
(braket
l_int|12
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|temp_table
comma
op_amp
id|jfs_ip-&gt;i_dirtable
comma
r_sizeof
(paren
id|temp_table
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize empty x-tree&n;&t;&t; */
id|xtInitRoot
c_func
(paren
id|tid
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate the first block &amp; add it to the xtree&n;&t;&t; */
id|xaddr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtInsert
c_func
(paren
id|tid
comma
id|ip
comma
l_int|0
comma
l_int|0
comma
id|sbi-&gt;nbperpage
comma
op_amp
id|xaddr
comma
l_int|0
)paren
)paren
)paren
(brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;add_index: xtInsert failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ip-&gt;i_size
op_assign
id|PSIZE
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|sb
comma
id|sbi-&gt;nbperpage
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|get_metapage
c_func
(paren
id|ip
comma
l_int|0
comma
id|ip-&gt;i_blksize
comma
l_int|0
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;add_index: get_metapage failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|xtTruncate
c_func
(paren
id|tid
comma
id|ip
comma
l_int|0
comma
id|COMMIT_PWMAP
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDATA
)paren
suffix:semicolon
id|llck
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|ASSERT
c_func
(paren
id|llck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
op_amp
id|llck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* tlckDATA slot size is 16 bytes */
id|llck-&gt;index
op_increment
suffix:semicolon
id|memcpy
c_func
(paren
id|mp-&gt;data
comma
id|temp_table
comma
r_sizeof
(paren
id|temp_table
)paren
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Logging is now directed by xtree tlocks&n;&t;&t; */
id|clear_cflag
c_func
(paren
id|COMMIT_Dirtable
comma
id|ip
)paren
suffix:semicolon
)brace
id|offset
op_assign
(paren
id|index
op_minus
l_int|2
)paren
op_star
r_sizeof
(paren
id|dir_table_slot_t
)paren
suffix:semicolon
id|page_offset
op_assign
id|offset
op_amp
(paren
id|PSIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|blkno
op_assign
(paren
(paren
id|offset
op_plus
l_int|1
)paren
op_rshift
id|L2PSIZE
)paren
op_lshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
r_if
c_cond
(paren
id|page_offset
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * This will be the beginning of a new page&n;&t;&t; */
id|xaddr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtInsert
c_func
(paren
id|tid
comma
id|ip
comma
l_int|0
comma
id|blkno
comma
id|sbi-&gt;nbperpage
comma
op_amp
id|xaddr
comma
l_int|0
)paren
)paren
)paren
(brace
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;add_index: xtInsert failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jfs_ip-&gt;next_index
op_decrement
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ip-&gt;i_size
op_add_assign
id|PSIZE
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|sb
comma
id|sbi-&gt;nbperpage
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|get_metapage
c_func
(paren
id|ip
comma
id|blkno
comma
id|PSIZE
comma
l_int|0
)paren
)paren
)paren
id|memset
c_func
(paren
id|mp-&gt;data
comma
l_int|0
comma
id|PSIZE
)paren
suffix:semicolon
multiline_comment|/* Just looks better */
r_else
id|xtTruncate
c_func
(paren
id|tid
comma
id|ip
comma
id|offset
comma
id|COMMIT_PWMAP
)paren
suffix:semicolon
)brace
r_else
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ip
comma
id|blkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|0
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;add_index: get/read_metapage failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|lock_index
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|index
)paren
suffix:semicolon
id|dirtab_slot
op_assign
(paren
id|dir_table_slot_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|mp-&gt;data
op_plus
id|page_offset
)paren
suffix:semicolon
id|dirtab_slot-&gt;flag
op_assign
id|DIR_INDEX_VALID
suffix:semicolon
id|dirtab_slot-&gt;slot
op_assign
id|slot
suffix:semicolon
id|DTSaddress
c_func
(paren
id|dirtab_slot
comma
id|bn
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|index
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;free_index()&n; *&n; *&t;Marks an entry to the directory index table as free.&n; */
DECL|function|free_index
r_static
r_void
id|free_index
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|u32
id|index
comma
id|u32
id|next
)paren
(brace
id|dir_table_slot_t
op_star
id|dirtab_slot
suffix:semicolon
id|metapage_t
op_star
id|mp
op_assign
l_int|0
suffix:semicolon
id|dirtab_slot
op_assign
id|find_index
c_func
(paren
id|ip
comma
id|index
comma
op_amp
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dirtab_slot
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|dirtab_slot-&gt;flag
op_assign
id|DIR_INDEX_FREE
suffix:semicolon
id|dirtab_slot-&gt;slot
op_assign
id|dirtab_slot-&gt;addr1
op_assign
l_int|0
suffix:semicolon
id|dirtab_slot-&gt;addr2
op_assign
id|cpu_to_le32
c_func
(paren
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
(brace
id|lock_index
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|index
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
id|set_cflag
c_func
(paren
id|COMMIT_Dirtable
comma
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;modify_index()&n; *&n; *&t;Changes an entry in the directory index table&n; */
DECL|function|modify_index
r_static
r_void
id|modify_index
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|u32
id|index
comma
id|s64
id|bn
comma
r_int
id|slot
comma
id|metapage_t
op_star
op_star
id|mp
)paren
(brace
id|dir_table_slot_t
op_star
id|dirtab_slot
suffix:semicolon
id|dirtab_slot
op_assign
id|find_index
c_func
(paren
id|ip
comma
id|index
comma
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dirtab_slot
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|DTSaddress
c_func
(paren
id|dirtab_slot
comma
id|bn
)paren
suffix:semicolon
id|dirtab_slot-&gt;slot
op_assign
id|slot
suffix:semicolon
r_if
c_cond
(paren
op_star
id|mp
)paren
(brace
id|lock_index
c_func
(paren
id|tid
comma
id|ip
comma
op_star
id|mp
comma
id|index
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
op_star
id|mp
)paren
suffix:semicolon
)brace
r_else
id|set_cflag
c_func
(paren
id|COMMIT_Dirtable
comma
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;get_index()&n; *&n; *&t;reads a directory table slot&n; */
DECL|function|get_index
r_static
r_int
id|get_index
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|u32
id|index
comma
id|dir_table_slot_t
op_star
id|dirtab_slot
)paren
(brace
id|metapage_t
op_star
id|mp
op_assign
l_int|0
suffix:semicolon
id|dir_table_slot_t
op_star
id|slot
suffix:semicolon
id|slot
op_assign
id|find_index
c_func
(paren
id|ip
comma
id|index
comma
op_amp
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|dirtab_slot
comma
id|slot
comma
r_sizeof
(paren
id|dir_table_slot_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
)paren
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtSearch()&n; *&n; * function:&n; *&t;Search for the entry with specified key&n; *&n; * parameter:&n; *&n; * return: 0 - search result on stack, leaf page pinned;&n; *&t;   errno - I/O error&n; */
DECL|function|dtSearch
r_int
id|dtSearch
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|component_t
op_star
id|key
comma
id|ino_t
op_star
id|data
comma
id|btstack_t
op_star
id|btstack
comma
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|cmp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* init for empty page */
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
r_int
id|base
comma
id|index
comma
id|lim
suffix:semicolon
id|btframe_t
op_star
id|btsp
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
r_int
id|psize
op_assign
l_int|288
suffix:semicolon
multiline_comment|/* initial in-line directory */
id|ino_t
id|inumber
suffix:semicolon
id|component_t
id|ciKey
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
id|ciKey.name
op_assign
(paren
m_wchar_t
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|JFS_NAME_MAX
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
m_wchar_t
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ciKey.name
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|ENOMEM
suffix:semicolon
r_goto
id|dtSearch_Exit2
suffix:semicolon
)brace
multiline_comment|/* uppercase search key for c-i directory */
id|UniStrcpy
c_func
(paren
id|ciKey.name
comma
id|key-&gt;name
)paren
suffix:semicolon
id|ciKey.namlen
op_assign
id|key-&gt;namlen
suffix:semicolon
multiline_comment|/* only uppercase if case-insensitive support is on */
r_if
c_cond
(paren
(paren
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|mntflag
op_amp
id|JFS_OS2
)paren
op_eq
id|JFS_OS2
)paren
(brace
id|ciToUpper
c_func
(paren
op_amp
id|ciKey
)paren
suffix:semicolon
)brace
id|BT_CLR
c_func
(paren
id|btstack
)paren
suffix:semicolon
multiline_comment|/* reset stack */
multiline_comment|/* init level count for max pages to split */
id|btstack-&gt;nsplit
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *      search down tree from root:&n;&t; *&n;&t; * between two consecutive entries of &lt;Ki, Pi&gt; and &lt;Kj, Pj&gt; of&n;&t; * internal page, child page Pi contains entry with k, Ki &lt;= K &lt; Kj.&n;&t; *&n;&t; * if entry with search key K is not found&n;&t; * internal page search find the entry with largest key Ki&n;&t; * less than K which point to the child page to search;&n;&t; * leaf page search find the entry with smallest key Kj&n;&t; * greater than K so that the returned index is the position of&n;&t; * the entry to be shifted right for insertion of new entry.&n;&t; * for empty tree, search key is greater than any key of the tree.&n;&t; *&n;&t; * by convention, root bn = 0.&n;&t; */
r_for
c_loop
(paren
id|bn
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* get/pin the page to search */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|psize
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_goto
id|dtSearch_Exit1
suffix:semicolon
multiline_comment|/* get sorted entry table of the page */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * binary search with search key K on the current page.&n;&t;&t; */
r_for
c_loop
(paren
id|base
op_assign
l_int|0
comma
id|lim
op_assign
id|p-&gt;header.nextindex
suffix:semicolon
id|lim
suffix:semicolon
id|lim
op_rshift_assign
l_int|1
)paren
(brace
id|index
op_assign
id|base
op_plus
(paren
id|lim
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
multiline_comment|/* uppercase leaf name to compare */
id|cmp
op_assign
id|ciCompare
c_func
(paren
op_amp
id|ciKey
comma
id|p
comma
id|stbl
(braket
id|index
)braket
comma
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|mntflag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* router key is in uppercase */
id|cmp
op_assign
id|dtCompare
c_func
(paren
op_amp
id|ciKey
comma
id|p
comma
id|stbl
(braket
id|index
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmp
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *      search hit&n;&t;&t;&t;&t; */
multiline_comment|/* search hit - leaf page:&n;&t;&t;&t;&t; * return the entry found&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
id|inumber
op_assign
id|le32_to_cpu
c_func
(paren
(paren
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|index
)braket
)braket
)paren
op_member_access_from_pointer
id|inumber
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * search for JFS_LOOKUP&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_eq
id|JFS_LOOKUP
)paren
(brace
op_star
id|data
op_assign
id|inumber
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * search for JFS_CREATE&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_eq
id|JFS_CREATE
)paren
(brace
op_star
id|data
op_assign
id|inumber
suffix:semicolon
id|rc
op_assign
id|EEXIST
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * search for JFS_REMOVE or JFS_RENAME&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|flag
op_eq
id|JFS_REMOVE
op_logical_or
id|flag
op_eq
id|JFS_RENAME
)paren
op_logical_and
op_star
id|data
op_ne
id|inumber
)paren
(brace
id|rc
op_assign
id|ESTALE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * JFS_REMOVE|JFS_FINDDIR|JFS_RENAME&n;&t;&t;&t;&t;&t; */
multiline_comment|/* save search result */
op_star
id|data
op_assign
id|inumber
suffix:semicolon
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|index
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_goto
id|dtSearch_Exit1
suffix:semicolon
)brace
multiline_comment|/* search hit - internal page:&n;&t;&t;&t;&t; * descend/search its child page&n;&t;&t;&t;&t; */
r_goto
id|getChild
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmp
OG
l_int|0
)paren
(brace
id|base
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
op_decrement
id|lim
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; *      search miss&n;&t;&t; *&n;&t;&t; * base is the smallest index with key (Kj) greater than&n;&t;&t; * search key (K) and may be zero or (maxindex + 1) index.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * search miss - leaf page&n;&t;&t; *&n;&t;&t; * return location of entry (base) where new entry with&n;&t;&t; * search key K is to be inserted.&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * search for JFS_LOOKUP, JFS_REMOVE, or JFS_RENAME&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_eq
id|JFS_LOOKUP
op_logical_or
id|flag
op_eq
id|JFS_REMOVE
op_logical_or
id|flag
op_eq
id|JFS_RENAME
)paren
(brace
id|rc
op_assign
id|ENOENT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * search for JFS_CREATE|JFS_FINDDIR:&n;&t;&t;&t; *&n;&t;&t;&t; * save search result&n;&t;&t;&t; */
op_star
id|data
op_assign
l_int|0
suffix:semicolon
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|base
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_goto
id|dtSearch_Exit1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * search miss - internal page&n;&t;&t; *&n;&t;&t; * if base is non-zero, decrement base by one to get the parent&n;&t;&t; * entry of the child page to search.&n;&t;&t; */
id|index
op_assign
id|base
ques
c_cond
id|base
op_minus
l_int|1
suffix:colon
id|base
suffix:semicolon
multiline_comment|/*&n;&t;&t; * go down to child page&n;&t;&t; */
id|getChild
suffix:colon
multiline_comment|/* update max. number of pages to split */
r_if
c_cond
(paren
id|btstack-&gt;nsplit
op_ge
l_int|8
)paren
(brace
multiline_comment|/* Something&squot;s corrupted, mark filesytem dirty so&n;&t;&t;&t; * chkdsk will fix it.&n;&t;&t;&t; */
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;stack overrun in dtSearch!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
id|rc
op_assign
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|btstack-&gt;nsplit
op_increment
suffix:semicolon
multiline_comment|/* push (bn, index) of the parent page/entry */
id|BT_PUSH
c_func
(paren
id|btstack
comma
id|bn
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* get the child page block number */
id|pxd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|index
)braket
)braket
suffix:semicolon
id|bn
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|psize
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
multiline_comment|/* unpin the parent page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|dtSearch_Exit1
suffix:colon
id|kfree
c_func
(paren
id|ciKey.name
)paren
suffix:semicolon
id|dtSearch_Exit2
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtInsert()&n; *&n; * function: insert an entry to directory tree&n; *&n; * parameter:&n; *&n; * return: 0 - success;&n; *&t;   errno - failure;&n; */
DECL|function|dtInsert
r_int
id|dtInsert
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|component_t
op_star
id|name
comma
id|ino_t
op_star
id|fsn
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* meta-page buffer */
id|dtpage_t
op_star
id|p
suffix:semicolon
multiline_comment|/* base B+-tree index page */
id|s64
id|bn
suffix:semicolon
r_int
id|index
suffix:semicolon
id|dtsplit_t
id|split
suffix:semicolon
multiline_comment|/* split information */
id|ddata_t
id|data
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
r_int
id|n
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
multiline_comment|/*&n;&t; *      retrieve search result&n;&t; *&n;&t; * dtSearch() returns (leaf page pinned, index at which to insert).&n;&t; * n.b. dtSearch() may return index of (maxindex + 1) of&n;&t; * the full page.&n;&t; */
id|DT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack-&gt;top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      insert entry for new key&n;&t; */
r_if
c_cond
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|next_index
op_eq
id|DIREND
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|EMLINK
suffix:semicolon
)brace
id|n
op_assign
id|NDTLEAF
c_func
(paren
id|name-&gt;namlen
)paren
suffix:semicolon
id|data.leaf.tid
op_assign
id|tid
suffix:semicolon
id|data.leaf.ip
op_assign
id|ip
suffix:semicolon
)brace
r_else
(brace
id|n
op_assign
id|NDTLEAF_LEGACY
c_func
(paren
id|name-&gt;namlen
)paren
suffix:semicolon
id|data.leaf.ip
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* signifies legacy directory format */
)brace
id|data.leaf.ino
op_assign
id|cpu_to_le32
c_func
(paren
op_star
id|fsn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      leaf page does not have enough room for new entry:&n;&t; *&n;&t; *      extend/split the leaf page;&n;&t; *&n;&t; * dtSplitUp() will insert the entry and unpin the leaf page.&n;&t; */
r_if
c_cond
(paren
id|n
OG
id|p-&gt;header.freecnt
)paren
(brace
id|split.mp
op_assign
id|mp
suffix:semicolon
id|split.index
op_assign
id|index
suffix:semicolon
id|split.nslot
op_assign
id|n
suffix:semicolon
id|split.key
op_assign
id|name
suffix:semicolon
id|split.data
op_assign
op_amp
id|data
suffix:semicolon
id|rc
op_assign
id|dtSplitUp
c_func
(paren
id|tid
comma
id|ip
comma
op_amp
id|split
comma
id|btstack
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      leaf page does have enough room for new entry:&n;&t; *&n;&t; *      insert the new data entry into the leaf page;&n;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the leaf page&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* linelock header */
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|dtInsertEntry
c_func
(paren
id|p
comma
id|index
comma
id|name
comma
op_amp
id|data
comma
op_amp
id|dtlck
)paren
suffix:semicolon
multiline_comment|/* linelock stbl of non-root leaf page */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
)paren
(brace
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|n
op_assign
id|index
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|lv-&gt;offset
op_assign
id|p-&gt;header.stblindex
op_plus
id|n
suffix:semicolon
id|lv-&gt;length
op_assign
(paren
(paren
id|p-&gt;header.nextindex
op_minus
l_int|1
)paren
op_rshift
id|L2DTSLOTSIZE
)paren
op_minus
id|n
op_plus
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
)brace
multiline_comment|/* unpin the leaf page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtSplitUp()&n; *&n; * function: propagate insertion bottom up;&n; *&n; * parameter:&n; *&n; * return: 0 - success;&n; *&t;   errno - failure;&n; * &t;leaf page unpinned;&n; */
DECL|function|dtSplitUp
r_static
r_int
id|dtSplitUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|smp
suffix:semicolon
id|dtpage_t
op_star
id|sp
suffix:semicolon
multiline_comment|/* split page */
id|metapage_t
op_star
id|rmp
suffix:semicolon
id|dtpage_t
op_star
id|rp
suffix:semicolon
multiline_comment|/* new right page split from sp */
id|pxd_t
id|rpxd
suffix:semicolon
multiline_comment|/* new right page extent descriptor */
id|metapage_t
op_star
id|lmp
suffix:semicolon
id|dtpage_t
op_star
id|lp
suffix:semicolon
multiline_comment|/* left child page */
r_int
id|skip
suffix:semicolon
multiline_comment|/* index of entry of insertion */
id|btframe_t
op_star
id|parent
suffix:semicolon
multiline_comment|/* parent page entry on traverse stack */
id|s64
id|xaddr
comma
id|nxaddr
suffix:semicolon
r_int
id|xlen
comma
id|xsize
suffix:semicolon
id|pxdlist_t
id|pxdlist
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|component_t
id|key
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|ddata_t
op_star
id|data
op_assign
id|split-&gt;data
suffix:semicolon
r_int
id|n
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
multiline_comment|/* get split page */
id|smp
op_assign
id|split-&gt;mp
suffix:semicolon
id|sp
op_assign
id|DT_PAGE
c_func
(paren
id|ip
comma
id|smp
)paren
suffix:semicolon
id|key.name
op_assign
(paren
m_wchar_t
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|JFS_NAME_MAX
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
m_wchar_t
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key.name
op_eq
l_int|0
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
id|rc
op_assign
id|ENOMEM
suffix:semicolon
r_goto
id|dtSplitUp_Exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      split leaf page&n;&t; *&n;&t; * The split routines insert the new entry, and&n;&t; * acquire txLock as appropriate.&n;&t; */
multiline_comment|/*&n;&t; *      split root leaf page:&n;&t; */
r_if
c_cond
(paren
id|sp-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
multiline_comment|/*&n;&t;&t; * allocate a single extent child page&n;&t;&t; */
id|xlen
op_assign
l_int|1
suffix:semicolon
id|n
op_assign
id|sbi-&gt;bsize
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|n
op_sub_assign
(paren
id|n
op_plus
l_int|31
)paren
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
multiline_comment|/* stbl size */
id|n
op_sub_assign
id|DTROOTMAXSLOT
op_minus
id|sp-&gt;header.freecnt
suffix:semicolon
multiline_comment|/* header + entries */
r_if
c_cond
(paren
id|n
op_le
id|split-&gt;nslot
)paren
id|xlen
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ip
comma
l_int|0
comma
(paren
id|s64
)paren
id|xlen
comma
op_amp
id|xaddr
)paren
)paren
)paren
r_goto
id|freeKeyName
suffix:semicolon
id|pxdlist.maxnpxd
op_assign
l_int|1
suffix:semicolon
id|pxdlist.npxd
op_assign
l_int|0
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist.pxd
(braket
l_int|0
)braket
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|xaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|xlen
)paren
suffix:semicolon
id|split-&gt;pxdlist
op_assign
op_amp
id|pxdlist
suffix:semicolon
id|rc
op_assign
id|dtSplitRoot
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
r_goto
id|freeKeyName
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      extend first leaf page&n;&t; *&n;&t; * extend the 1st extent if less than buffer page size&n;&t; * (dtExtendPage() reurns leaf page unpinned)&n;&t; */
id|pxd
op_assign
op_amp
id|sp-&gt;header.self
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|xsize
op_assign
id|xlen
op_lshift
id|sbi-&gt;l2bsize
suffix:semicolon
r_if
c_cond
(paren
id|xsize
OL
id|PSIZE
)paren
(brace
id|xaddr
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|n
op_assign
id|xsize
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|n
op_sub_assign
(paren
id|n
op_plus
l_int|31
)paren
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
multiline_comment|/* stbl size */
r_if
c_cond
(paren
(paren
id|n
op_plus
id|sp-&gt;header.freecnt
)paren
op_le
id|split-&gt;nslot
)paren
id|n
op_assign
id|xlen
op_plus
(paren
id|xlen
op_lshift
l_int|1
)paren
suffix:semicolon
r_else
id|n
op_assign
id|xlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbReAlloc
c_func
(paren
id|sbi-&gt;ipbmap
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
comma
(paren
id|s64
)paren
id|n
comma
op_amp
id|nxaddr
)paren
)paren
)paren
r_goto
id|extendOut
suffix:semicolon
id|pxdlist.maxnpxd
op_assign
l_int|1
suffix:semicolon
id|pxdlist.npxd
op_assign
l_int|0
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist.pxd
(braket
l_int|0
)braket
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|nxaddr
)paren
id|PXDlength
c_func
(paren
id|pxd
comma
id|xlen
op_plus
id|n
)paren
suffix:semicolon
id|split-&gt;pxdlist
op_assign
op_amp
id|pxdlist
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtExtendPage
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
id|btstack
)paren
)paren
)paren
(brace
id|nxaddr
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xaddr
op_ne
id|nxaddr
)paren
(brace
multiline_comment|/* free relocated extent */
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|dbFree
c_func
(paren
id|ip
comma
id|nxaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* free extended delta */
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
op_minus
id|n
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
op_plus
id|xlen
suffix:semicolon
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|n
)paren
suffix:semicolon
)brace
)brace
id|extendOut
suffix:colon
id|DT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
r_goto
id|freeKeyName
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      split leaf page &lt;sp&gt; into &lt;sp&gt; and a new right page &lt;rp&gt;.&n;&t; *&n;&t; * return &lt;rp&gt; pinned and its extent descriptor &lt;rpxd&gt;&n;&t; */
multiline_comment|/*&n;&t; * allocate new directory page extent and&n;&t; * new index page(s) to cover page split(s)&n;&t; *&n;&t; * allocation hint: ?&n;&t; */
id|n
op_assign
id|btstack-&gt;nsplit
suffix:semicolon
id|pxdlist.maxnpxd
op_assign
id|pxdlist.npxd
op_assign
l_int|0
suffix:semicolon
id|xlen
op_assign
id|sbi-&gt;nbperpage
suffix:semicolon
r_for
c_loop
(paren
id|pxd
op_assign
id|pxdlist.pxd
suffix:semicolon
id|n
OG
l_int|0
suffix:semicolon
id|n
op_decrement
comma
id|pxd
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ip
comma
l_int|0
comma
(paren
id|s64
)paren
id|xlen
comma
op_amp
id|xaddr
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|PXDaddress
c_func
(paren
id|pxd
comma
id|xaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
id|pxd
comma
id|xlen
)paren
suffix:semicolon
id|pxdlist.maxnpxd
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|DT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
multiline_comment|/* undo allocation */
r_goto
id|splitOut
suffix:semicolon
)brace
id|split-&gt;pxdlist
op_assign
op_amp
id|pxdlist
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtSplitPage
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
comma
op_amp
id|rp
comma
op_amp
id|rpxd
)paren
)paren
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
multiline_comment|/* undo allocation */
r_goto
id|splitOut
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * propagate up the router entry for the leaf page just split&n;&t; *&n;&t; * insert a router entry for the new page into the parent page,&n;&t; * propagate the insert/split up the tree by walking back the stack&n;&t; * of (bn of parent page, index of child page entry in parent page)&n;&t; * that were traversed during the search for the page that split.&n;&t; *&n;&t; * the propagation of insert/split up the tree stops if the root&n;&t; * splits or the page inserted into doesn&squot;t have to split to hold&n;&t; * the new entry.&n;&t; *&n;&t; * the parent entry for the split page remains the same, and&n;&t; * a new entry is inserted at its right with the first key and&n;&t; * block number of the new right page.&n;&t; *&n;&t; * There are a maximum of 4 pages pinned at any time:&n;&t; * two children, left parent and right parent (when the parent splits).&n;&t; * keep the child pages pinned while working on the parent.&n;&t; * make sure that all pins are released at exit.&n;&t; */
r_while
c_loop
(paren
(paren
id|parent
op_assign
id|BT_POP
c_func
(paren
id|btstack
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* parent page specified by stack frame &lt;parent&gt; */
multiline_comment|/* keep current child pages (&lt;lp&gt;, &lt;rp&gt;) pinned */
id|lmp
op_assign
id|smp
suffix:semicolon
id|lp
op_assign
id|sp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * insert router entry in parent for new right child page &lt;rp&gt;&n;&t;&t; */
multiline_comment|/* get the parent page &lt;sp&gt; */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|parent-&gt;bn
comma
id|smp
comma
id|PSIZE
comma
id|sp
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|lmp
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
r_goto
id|splitOut
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The new key entry goes ONE AFTER the index of parent entry,&n;&t;&t; * because the split was to the right.&n;&t;&t; */
id|skip
op_assign
id|parent-&gt;index
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * compute the key for the router entry&n;&t;&t; *&n;&t;&t; * key suffix compression:&n;&t;&t; * for internal pages that have leaf pages as children,&n;&t;&t; * retain only what&squot;s needed to distinguish between&n;&t;&t; * the new entry and the entry on the page to its left.&n;&t;&t; * If the keys compare equal, retain the entire key.&n;&t;&t; *&n;&t;&t; * note that compression is performed only at computing&n;&t;&t; * router key at the lowest internal level.&n;&t;&t; * further compression of the key between pairs of higher&n;&t;&t; * level internal pages loses too much information and&n;&t;&t; * the search may fail.&n;&t;&t; * (e.g., two adjacent leaf pages of {a, ..., x} {xx, ...,}&n;&t;&t; * results in two adjacent parent entries (a)(xx).&n;&t;&t; * if split occurs between these two entries, and&n;&t;&t; * if compression is applied, the router key of parent entry&n;&t;&t; * of right page (x) will divert search for x into right&n;&t;&t; * subtree and miss x in the left subtree.)&n;&t;&t; *&n;&t;&t; * the entire key must be retained for the next-to-leftmost&n;&t;&t; * internal key at any level of the tree, or search may fail&n;&t;&t; * (e.g., ?)&n;&t;&t; */
r_switch
c_cond
(paren
id|rp-&gt;header.flag
op_amp
id|BT_TYPE
)paren
(brace
r_case
id|BT_LEAF
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * compute the length of prefix for suffix compression&n;&t;&t;&t; * between last entry of left page and first entry&n;&t;&t;&t; * of right page&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|sp-&gt;header.flag
op_amp
id|BT_ROOT
op_logical_and
id|skip
OG
l_int|1
)paren
op_logical_or
id|sp-&gt;header.prev
op_ne
l_int|0
op_logical_or
id|skip
OG
l_int|1
)paren
(brace
multiline_comment|/* compute uppercase router prefix key */
id|ciGetLeafPrefixKey
c_func
(paren
id|lp
comma
id|lp-&gt;header.nextindex
op_minus
l_int|1
comma
id|rp
comma
l_int|0
comma
op_amp
id|key
comma
id|sbi-&gt;mntflag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* next to leftmost entry of&n;&t;&t;&t;&t;   lowest internal level */
multiline_comment|/* compute uppercase router key */
id|dtGetKey
c_func
(paren
id|rp
comma
l_int|0
comma
op_amp
id|key
comma
id|sbi-&gt;mntflag
)paren
suffix:semicolon
id|key.name
(braket
id|key.namlen
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sbi-&gt;mntflag
op_amp
id|JFS_OS2
)paren
op_eq
id|JFS_OS2
)paren
id|ciToUpper
c_func
(paren
op_amp
id|key
)paren
suffix:semicolon
)brace
id|n
op_assign
id|NDTINTERNAL
c_func
(paren
id|key.namlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BT_INTERNAL
suffix:colon
id|dtGetKey
c_func
(paren
id|rp
comma
l_int|0
comma
op_amp
id|key
comma
id|sbi-&gt;mntflag
)paren
suffix:semicolon
id|n
op_assign
id|NDTINTERNAL
c_func
(paren
id|key.namlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|jERROR
c_func
(paren
l_int|2
comma
(paren
l_string|&quot;dtSplitUp(): UFO!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* unpin left child page */
id|DT_PUTPAGE
c_func
(paren
id|lmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * compute the data for the router entry&n;&t;&t; */
id|data-&gt;xd
op_assign
id|rpxd
suffix:semicolon
multiline_comment|/* child page xd */
multiline_comment|/*&n;&t;&t; * parent page is full - split the parent page&n;&t;&t; */
r_if
c_cond
(paren
id|n
OG
id|sp-&gt;header.freecnt
)paren
(brace
multiline_comment|/* init for parent page split */
id|split-&gt;mp
op_assign
id|smp
suffix:semicolon
id|split-&gt;index
op_assign
id|skip
suffix:semicolon
multiline_comment|/* index at insert */
id|split-&gt;nslot
op_assign
id|n
suffix:semicolon
id|split-&gt;key
op_assign
op_amp
id|key
suffix:semicolon
multiline_comment|/* split-&gt;data = data; */
multiline_comment|/* unpin right child page */
id|DT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
multiline_comment|/* The split routines insert the new entry,&n;&t;&t;&t; * acquire txLock as appropriate.&n;&t;&t;&t; * return &lt;rp&gt; pinned and its block number &lt;rbn&gt;.&n;&t;&t;&t; */
id|rc
op_assign
(paren
id|sp-&gt;header.flag
op_amp
id|BT_ROOT
)paren
ques
c_cond
id|dtSplitRoot
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
)paren
suffix:colon
id|dtSplitPage
c_func
(paren
id|tid
comma
id|ip
comma
id|split
comma
op_amp
id|rmp
comma
op_amp
id|rp
comma
op_amp
id|rpxd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
r_goto
id|splitOut
suffix:semicolon
)brace
multiline_comment|/* smp and rmp are pinned */
)brace
multiline_comment|/*&n;&t;&t; * parent page is not full - insert router entry in parent page&n;&t;&t; */
r_else
(brace
id|BT_MARK_DIRTY
c_func
(paren
id|smp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * acquire a transaction lock on the parent page&n;&t;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|smp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* linelock header */
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* linelock stbl of non-root parent page */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sp-&gt;header.flag
op_amp
id|BT_ROOT
)paren
)paren
(brace
id|lv
op_increment
suffix:semicolon
id|n
op_assign
id|skip
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|lv-&gt;offset
op_assign
id|sp-&gt;header.stblindex
op_plus
id|n
suffix:semicolon
id|lv-&gt;length
op_assign
(paren
(paren
id|sp-&gt;header.nextindex
op_minus
l_int|1
)paren
op_rshift
id|L2DTSLOTSIZE
)paren
op_minus
id|n
op_plus
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
)brace
id|dtInsertEntry
c_func
(paren
id|sp
comma
id|skip
comma
op_amp
id|key
comma
id|data
comma
op_amp
id|dtlck
)paren
suffix:semicolon
multiline_comment|/* exit propagate up */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* unpin current split and its right page */
id|DT_PUTPAGE
c_func
(paren
id|smp
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free remaining extents allocated for split&n;&t; */
id|splitOut
suffix:colon
id|n
op_assign
id|pxdlist.npxd
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist.pxd
(braket
id|n
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n
OL
id|pxdlist.maxnpxd
suffix:semicolon
id|n
op_increment
comma
id|pxd
op_increment
)paren
id|dbFree
c_func
(paren
id|ip
comma
id|addressPXD
c_func
(paren
id|pxd
)paren
comma
(paren
id|s64
)paren
id|lengthPXD
c_func
(paren
id|pxd
)paren
)paren
suffix:semicolon
id|freeKeyName
suffix:colon
id|kfree
c_func
(paren
id|key.name
)paren
suffix:semicolon
id|dtSplitUp_Exit
suffix:colon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtSplitPage()&n; *&n; * function: Split a non-root page of a btree.&n; *&n; * parameter:&n; *&n; * return: 0 - success;&n; *&t;   errno - failure;&n; *&t;return split and new page pinned;&n; */
DECL|function|dtSplitPage
r_static
r_int
id|dtSplitPage
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
comma
id|dtpage_t
op_star
op_star
id|rpp
comma
id|pxd_t
op_star
id|rpxdp
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|smp
suffix:semicolon
id|dtpage_t
op_star
id|sp
suffix:semicolon
id|metapage_t
op_star
id|rmp
suffix:semicolon
id|dtpage_t
op_star
id|rp
suffix:semicolon
multiline_comment|/* new right page allocated */
id|s64
id|rbn
suffix:semicolon
multiline_comment|/* new right page block number */
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
id|s64
id|nextbn
suffix:semicolon
id|pxdlist_t
op_star
id|pxdlist
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
r_int
id|skip
comma
id|nextindex
comma
id|half
comma
id|left
comma
id|nxt
comma
id|off
comma
id|si
suffix:semicolon
id|ldtentry_t
op_star
id|ldtentry
suffix:semicolon
id|idtentry_t
op_star
id|idtentry
suffix:semicolon
id|u8
op_star
id|stbl
suffix:semicolon
id|dtslot_t
op_star
id|f
suffix:semicolon
r_int
id|fsi
comma
id|stblsize
suffix:semicolon
r_int
id|n
suffix:semicolon
id|dtlock_t
op_star
id|sdtlck
comma
op_star
id|rdtlck
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|lv_t
op_star
id|slv
comma
op_star
id|rlv
comma
op_star
id|lv
suffix:semicolon
multiline_comment|/* get split page */
id|smp
op_assign
id|split-&gt;mp
suffix:semicolon
id|sp
op_assign
id|DT_PAGE
c_func
(paren
id|ip
comma
id|smp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allocate the new right page for the split&n;&t; */
id|pxdlist
op_assign
id|split-&gt;pxdlist
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist-&gt;pxd
(braket
id|pxdlist-&gt;npxd
)braket
suffix:semicolon
id|pxdlist-&gt;npxd
op_increment
suffix:semicolon
id|rbn
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|rmp
op_assign
id|get_metapage
c_func
(paren
id|ip
comma
id|rbn
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmp
op_eq
l_int|NULL
)paren
r_return
id|EIO
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtSplitPage: ip:0x%p smp:0x%p rmp:0x%p&bslash;n&quot;
comma
id|ip
comma
id|smp
comma
id|rmp
)paren
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|rmp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the new right page&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|rmp
comma
id|tlckDTREE
op_or
id|tlckNEW
)paren
suffix:semicolon
id|rdtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|rp
op_assign
(paren
id|dtpage_t
op_star
)paren
id|rmp-&gt;data
suffix:semicolon
op_star
id|rpp
op_assign
id|rp
suffix:semicolon
id|rp-&gt;header.self
op_assign
op_star
id|pxd
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|smp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the split page&n;&t; *&n;&t; * action:&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|smp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|sdtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header of split page */
id|ASSERT
c_func
(paren
id|sdtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|slv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|sdtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|slv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|slv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|sdtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * initialize/update sibling pointers between sp and rp&n;&t; */
id|nextbn
op_assign
id|le64_to_cpu
c_func
(paren
id|sp-&gt;header.next
)paren
suffix:semicolon
id|rp-&gt;header.next
op_assign
id|cpu_to_le64
c_func
(paren
id|nextbn
)paren
suffix:semicolon
id|rp-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|addressPXD
c_func
(paren
op_amp
id|sp-&gt;header.self
)paren
)paren
suffix:semicolon
id|sp-&gt;header.next
op_assign
id|cpu_to_le64
c_func
(paren
id|rbn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize new right page&n;&t; */
id|rp-&gt;header.flag
op_assign
id|sp-&gt;header.flag
suffix:semicolon
multiline_comment|/* compute sorted entry table at start of extent data area */
id|rp-&gt;header.nextindex
op_assign
l_int|0
suffix:semicolon
id|rp-&gt;header.stblindex
op_assign
l_int|1
suffix:semicolon
id|n
op_assign
id|PSIZE
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|rp-&gt;header.maxslot
op_assign
id|n
suffix:semicolon
id|stblsize
op_assign
(paren
id|n
op_plus
l_int|31
)paren
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
multiline_comment|/* in unit of slot */
multiline_comment|/* init freelist */
id|fsi
op_assign
id|rp-&gt;header.stblindex
op_plus
id|stblsize
suffix:semicolon
id|rp-&gt;header.freelist
op_assign
id|fsi
suffix:semicolon
id|rp-&gt;header.freecnt
op_assign
id|rp-&gt;header.maxslot
op_minus
id|fsi
suffix:semicolon
multiline_comment|/*&n;&t; *      sequential append at tail: append without split&n;&t; *&n;&t; * If splitting the last page on a level because of appending&n;&t; * a entry to it (skip is maxentry), it&squot;s likely that the access is&n;&t; * sequential. Adding an empty page on the side of the level is less&n;&t; * work and can push the fill factor much higher than normal.&n;&t; * If we&squot;re wrong it&squot;s no big deal, we&squot;ll just do the split the right&n;&t; * way next time.&n;&t; * (It may look like it&squot;s equally easy to do a similar hack for&n;&t; * reverse sorted data, that is, split the tree left,&n;&t; * but it&squot;s not. Be my guest.)&n;&t; */
r_if
c_cond
(paren
id|nextbn
op_eq
l_int|0
op_logical_and
id|split-&gt;index
op_eq
id|sp-&gt;header.nextindex
)paren
(brace
multiline_comment|/* linelock header + stbl (first slot) of new page */
id|rlv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|rdtlck-&gt;lv
(braket
id|rdtlck-&gt;index
)braket
suffix:semicolon
id|rlv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|rlv-&gt;length
op_assign
l_int|2
suffix:semicolon
id|rdtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initialize freelist of new right page&n;&t;&t; */
id|f
op_assign
op_amp
id|rp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
r_for
c_loop
(paren
id|fsi
op_increment
suffix:semicolon
id|fsi
OL
id|rp-&gt;header.maxslot
suffix:semicolon
id|f
op_increment
comma
id|fsi
op_increment
)paren
id|f-&gt;next
op_assign
id|fsi
suffix:semicolon
id|f-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* insert entry at the first entry of the new right page */
id|dtInsertEntry
c_func
(paren
id|rp
comma
l_int|0
comma
id|split-&gt;key
comma
id|split-&gt;data
comma
op_amp
id|rdtlck
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      non-sequential insert (at possibly middle page)&n;&t; */
multiline_comment|/*&n;&t; * update prev pointer of previous right sibling page;&n;&t; */
r_if
c_cond
(paren
id|nextbn
op_ne
l_int|0
)paren
(brace
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|nextbn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the next page&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtSplitPage: tlck = 0x%p, ip = 0x%p, mp=0x%p&bslash;n&quot;
comma
id|tlck
comma
id|ip
comma
id|mp
)paren
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header of previous right sibling page */
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|p-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|rbn
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * split the data between the split and right pages.&n;&t; */
id|skip
op_assign
id|split-&gt;index
suffix:semicolon
id|half
op_assign
(paren
id|PSIZE
op_rshift
id|L2DTSLOTSIZE
)paren
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* swag */
id|left
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      compute fill factor for split pages&n;&t; *&n;&t; * &lt;nxt&gt; traces the next entry to move to rp&n;&t; * &lt;off&gt; traces the next entry to stay in sp&n;&t; */
id|stbl
op_assign
(paren
id|u8
op_star
)paren
op_amp
id|sp-&gt;slot
(braket
id|sp-&gt;header.stblindex
)braket
suffix:semicolon
id|nextindex
op_assign
id|sp-&gt;header.nextindex
suffix:semicolon
r_for
c_loop
(paren
id|nxt
op_assign
id|off
op_assign
l_int|0
suffix:semicolon
id|nxt
OL
id|nextindex
suffix:semicolon
op_increment
id|off
)paren
(brace
r_if
c_cond
(paren
id|off
op_eq
id|skip
)paren
multiline_comment|/* check for fill factor with new entry size */
id|n
op_assign
id|split-&gt;nslot
suffix:semicolon
r_else
(brace
id|si
op_assign
id|stbl
(braket
id|nxt
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|sp-&gt;header.flag
op_amp
id|BT_TYPE
)paren
(brace
r_case
id|BT_LEAF
suffix:colon
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|sp-&gt;slot
(braket
id|si
)braket
suffix:semicolon
r_if
c_cond
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
id|n
op_assign
id|NDTLEAF
c_func
(paren
id|ldtentry-&gt;namlen
)paren
suffix:semicolon
r_else
id|n
op_assign
id|NDTLEAF_LEGACY
c_func
(paren
id|ldtentry
op_member_access_from_pointer
id|namlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BT_INTERNAL
suffix:colon
id|idtentry
op_assign
(paren
id|idtentry_t
op_star
)paren
op_amp
id|sp-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|n
op_assign
id|NDTINTERNAL
c_func
(paren
id|idtentry-&gt;namlen
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
op_increment
id|nxt
suffix:semicolon
multiline_comment|/* advance to next entry to move in sp */
)brace
id|left
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|left
op_ge
id|half
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* &lt;nxt&gt; poins to the 1st entry to move */
multiline_comment|/*&n;&t; *      move entries to right page&n;&t; *&n;&t; * dtMoveEntry() initializes rp and reserves entry for insertion&n;&t; *&n;&t; * split page moved out entries are linelocked;&n;&t; * new/right page moved in entries are linelocked;&n;&t; */
multiline_comment|/* linelock header + stbl of new right page */
id|rlv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|rdtlck-&gt;lv
(braket
id|rdtlck-&gt;index
)braket
suffix:semicolon
id|rlv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|rlv-&gt;length
op_assign
l_int|5
suffix:semicolon
id|rdtlck-&gt;index
op_increment
suffix:semicolon
id|dtMoveEntry
c_func
(paren
id|sp
comma
id|nxt
comma
id|rp
comma
op_amp
id|sdtlck
comma
op_amp
id|rdtlck
comma
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|sp-&gt;header.nextindex
op_assign
id|nxt
suffix:semicolon
multiline_comment|/*&n;&t; * finalize freelist of new right page&n;&t; */
id|fsi
op_assign
id|rp-&gt;header.freelist
suffix:semicolon
id|f
op_assign
op_amp
id|rp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
r_for
c_loop
(paren
id|fsi
op_increment
suffix:semicolon
id|fsi
OL
id|rp-&gt;header.maxslot
suffix:semicolon
id|f
op_increment
comma
id|fsi
op_increment
)paren
id|f-&gt;next
op_assign
id|fsi
suffix:semicolon
id|f-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Update directory index table for entries now in right page&n;&t; */
r_if
c_cond
(paren
(paren
id|rp-&gt;header.flag
op_amp
id|BT_LEAF
)paren
op_logical_and
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
(brace
id|mp
op_assign
l_int|0
suffix:semicolon
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|rp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|rp-&gt;header.nextindex
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|rp-&gt;slot
(braket
id|stbl
(braket
id|n
)braket
)braket
suffix:semicolon
id|modify_index
c_func
(paren
id|tid
comma
id|ip
comma
id|le32_to_cpu
c_func
(paren
id|ldtentry-&gt;index
)paren
comma
id|rbn
comma
id|n
comma
op_amp
id|mp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp
)paren
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the skipped index was on the left page,&n;&t; */
r_if
c_cond
(paren
id|skip
op_le
id|off
)paren
(brace
multiline_comment|/* insert the new entry in the split page */
id|dtInsertEntry
c_func
(paren
id|sp
comma
id|skip
comma
id|split-&gt;key
comma
id|split-&gt;data
comma
op_amp
id|sdtlck
)paren
suffix:semicolon
multiline_comment|/* linelock stbl of split page */
r_if
c_cond
(paren
id|sdtlck-&gt;index
op_ge
id|sdtlck-&gt;maxcnt
)paren
id|sdtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|sdtlck
)paren
suffix:semicolon
id|slv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|sdtlck-&gt;lv
(braket
id|sdtlck-&gt;index
)braket
suffix:semicolon
id|n
op_assign
id|skip
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|slv-&gt;offset
op_assign
id|sp-&gt;header.stblindex
op_plus
id|n
suffix:semicolon
id|slv-&gt;length
op_assign
(paren
(paren
id|sp-&gt;header.nextindex
op_minus
l_int|1
)paren
op_rshift
id|L2DTSLOTSIZE
)paren
op_minus
id|n
op_plus
l_int|1
suffix:semicolon
id|sdtlck-&gt;index
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the skipped index was on the right page,&n;&t; */
r_else
(brace
multiline_comment|/* adjust the skip index to reflect the new position */
id|skip
op_sub_assign
id|nxt
suffix:semicolon
multiline_comment|/* insert the new entry in the right page */
id|dtInsertEntry
c_func
(paren
id|rp
comma
id|skip
comma
id|split-&gt;key
comma
id|split-&gt;data
comma
op_amp
id|rdtlck
)paren
suffix:semicolon
)brace
id|out
suffix:colon
op_star
id|rmpp
op_assign
id|rmp
suffix:semicolon
op_star
id|rpxdp
op_assign
op_star
id|pxd
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|sb
comma
id|lengthPXD
c_func
(paren
id|pxd
)paren
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtSplitPage: ip:0x%p sp:0x%p rp:0x%p&bslash;n&quot;
comma
id|ip
comma
id|sp
comma
id|rp
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtExtendPage()&n; *&n; * function: extend 1st/only directory leaf page&n; *&n; * parameter:&n; *&n; * return: 0 - success;&n; *&t;   errno - failure;&n; *&t;return extended page pinned;&n; */
DECL|function|dtExtendPage
r_static
r_int
id|dtExtendPage
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|metapage_t
op_star
id|smp
comma
op_star
id|pmp
comma
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|sp
comma
op_star
id|pp
suffix:semicolon
id|pxdlist_t
op_star
id|pxdlist
suffix:semicolon
id|pxd_t
op_star
id|pxd
comma
op_star
id|tpxd
suffix:semicolon
r_int
id|xlen
comma
id|xsize
suffix:semicolon
r_int
id|newstblindex
comma
id|newstblsize
suffix:semicolon
r_int
id|oldstblindex
comma
id|oldstblsize
suffix:semicolon
r_int
id|fsi
comma
id|last
suffix:semicolon
id|dtslot_t
op_star
id|f
suffix:semicolon
id|btframe_t
op_star
id|parent
suffix:semicolon
r_int
id|n
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|s64
id|xaddr
comma
id|txaddr
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|uint
id|type
suffix:semicolon
id|ldtentry_t
op_star
id|ldtentry
suffix:semicolon
id|u8
op_star
id|stbl
suffix:semicolon
multiline_comment|/* get page to extend */
id|smp
op_assign
id|split-&gt;mp
suffix:semicolon
id|sp
op_assign
id|DT_PAGE
c_func
(paren
id|ip
comma
id|smp
)paren
suffix:semicolon
multiline_comment|/* get parent/root page */
id|parent
op_assign
id|BT_POP
c_func
(paren
id|btstack
)paren
suffix:semicolon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|parent-&gt;bn
comma
id|pmp
comma
id|PSIZE
comma
id|pp
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      extend the extent&n;&t; */
id|pxdlist
op_assign
id|split-&gt;pxdlist
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist-&gt;pxd
(braket
id|pxdlist-&gt;npxd
)braket
suffix:semicolon
id|pxdlist-&gt;npxd
op_increment
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|tpxd
op_assign
op_amp
id|sp-&gt;header.self
suffix:semicolon
id|txaddr
op_assign
id|addressPXD
c_func
(paren
id|tpxd
)paren
suffix:semicolon
multiline_comment|/* in-place extension */
r_if
c_cond
(paren
id|xaddr
op_eq
id|txaddr
)paren
(brace
id|type
op_assign
id|tlckEXTEND
suffix:semicolon
)brace
multiline_comment|/* relocation */
r_else
(brace
id|type
op_assign
id|tlckNEW
suffix:semicolon
multiline_comment|/* save moved extent descriptor for later free */
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckDTREE
op_or
id|tlckRELOCATE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|pxdlock-&gt;pxd
op_assign
id|sp-&gt;header.self
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update directory index table to reflect new page address&n;&t;&t; */
r_if
c_cond
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
(brace
id|mp
op_assign
l_int|0
suffix:semicolon
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|sp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|sp-&gt;header.nextindex
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|sp-&gt;slot
(braket
id|stbl
(braket
id|n
)braket
)braket
suffix:semicolon
id|modify_index
c_func
(paren
id|tid
comma
id|ip
comma
id|le32_to_cpu
c_func
(paren
id|ldtentry-&gt;index
)paren
comma
id|xaddr
comma
id|n
comma
op_amp
id|mp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp
)paren
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *      extend the page&n;&t; */
id|sp-&gt;header.self
op_assign
op_star
id|pxd
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtExtendPage: ip:0x%p smp:0x%p sp:0x%p&bslash;n&quot;
comma
id|ip
comma
id|smp
comma
id|sp
)paren
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|smp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the extended/leaf page&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|smp
comma
id|tlckDTREE
op_or
id|type
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* update buffer extent descriptor of extended page */
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|xsize
op_assign
id|xlen
op_lshift
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
id|bmSetXD
c_func
(paren
id|smp
comma
id|xaddr
comma
id|xsize
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
multiline_comment|/*&n;&t; * copy old stbl to new stbl at start of extended area&n;&t; */
id|oldstblindex
op_assign
id|sp-&gt;header.stblindex
suffix:semicolon
id|oldstblsize
op_assign
(paren
id|sp-&gt;header.maxslot
op_plus
l_int|31
)paren
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|newstblindex
op_assign
id|sp-&gt;header.maxslot
suffix:semicolon
id|n
op_assign
id|xsize
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|newstblsize
op_assign
(paren
id|n
op_plus
l_int|31
)paren
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sp-&gt;slot
(braket
id|newstblindex
)braket
comma
op_amp
id|sp-&gt;slot
(braket
id|oldstblindex
)braket
comma
id|sp-&gt;header.nextindex
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * in-line extension: linelock old area of extended page&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|tlckEXTEND
)paren
(brace
multiline_comment|/* linelock header */
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|lv
op_increment
suffix:semicolon
multiline_comment|/* linelock new stbl of extended page */
id|lv-&gt;offset
op_assign
id|newstblindex
suffix:semicolon
id|lv-&gt;length
op_assign
id|newstblsize
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * relocation: linelock whole relocated area&n;&t; */
r_else
(brace
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
id|sp-&gt;header.maxslot
op_plus
id|newstblsize
suffix:semicolon
)brace
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|sp-&gt;header.maxslot
op_assign
id|n
suffix:semicolon
id|sp-&gt;header.stblindex
op_assign
id|newstblindex
suffix:semicolon
multiline_comment|/* sp-&gt;header.nextindex remains the same */
multiline_comment|/*&n;&t; * add old stbl region at head of freelist&n;&t; */
id|fsi
op_assign
id|oldstblindex
suffix:semicolon
id|f
op_assign
op_amp
id|sp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
id|last
op_assign
id|sp-&gt;header.freelist
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|oldstblsize
suffix:semicolon
id|n
op_increment
comma
id|fsi
op_increment
comma
id|f
op_increment
)paren
(brace
id|f-&gt;next
op_assign
id|last
suffix:semicolon
id|last
op_assign
id|fsi
suffix:semicolon
)brace
id|sp-&gt;header.freelist
op_assign
id|last
suffix:semicolon
id|sp-&gt;header.freecnt
op_add_assign
id|oldstblsize
suffix:semicolon
multiline_comment|/*&n;&t; * append free region of newly extended area at tail of freelist&n;&t; */
multiline_comment|/* init free region of newly extended area */
id|fsi
op_assign
id|n
op_assign
id|newstblindex
op_plus
id|newstblsize
suffix:semicolon
id|f
op_assign
op_amp
id|sp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
r_for
c_loop
(paren
id|fsi
op_increment
suffix:semicolon
id|fsi
OL
id|sp-&gt;header.maxslot
suffix:semicolon
id|f
op_increment
comma
id|fsi
op_increment
)paren
id|f-&gt;next
op_assign
id|fsi
suffix:semicolon
id|f-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* append new free region at tail of old freelist */
id|fsi
op_assign
id|sp-&gt;header.freelist
suffix:semicolon
r_if
c_cond
(paren
id|fsi
op_eq
op_minus
l_int|1
)paren
id|sp-&gt;header.freelist
op_assign
id|n
suffix:semicolon
r_else
(brace
r_do
(brace
id|f
op_assign
op_amp
id|sp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
id|fsi
op_assign
id|f-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fsi
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|f-&gt;next
op_assign
id|n
suffix:semicolon
)brace
id|sp-&gt;header.freecnt
op_add_assign
id|sp-&gt;header.maxslot
op_minus
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * insert the new entry&n;&t; */
id|dtInsertEntry
c_func
(paren
id|sp
comma
id|split-&gt;index
comma
id|split-&gt;key
comma
id|split-&gt;data
comma
op_amp
id|dtlck
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|pmp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * linelock any freeslots residing in old extent&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|tlckEXTEND
)paren
(brace
id|n
op_assign
id|sp-&gt;header.maxslot
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;header.freelist
OL
id|n
)paren
id|dtLinelockFreelist
c_func
(paren
id|sp
comma
id|n
comma
op_amp
id|dtlck
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      update parent entry on the parent/root page&n;&t; */
multiline_comment|/*&n;&t; * acquire a transaction lock on the parent/root page&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|pmp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
multiline_comment|/* linelock parent entry - 1st slot */
id|lv-&gt;offset
op_assign
l_int|1
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* update the parent pxd for page extension */
id|tpxd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|pp-&gt;slot
(braket
l_int|1
)braket
suffix:semicolon
op_star
id|tpxd
op_assign
op_star
id|pxd
suffix:semicolon
multiline_comment|/* Since the directory might have an EA and/or ACL associated with it&n;&t; * we need to make sure we take that into account when setting the&n;&t; * i_nblocks&n;&t; */
id|ip-&gt;i_blocks
op_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|xlen
op_plus
(paren
(paren
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ea.flag
op_amp
id|DXD_EXTENT
)paren
ques
c_cond
id|lengthDXD
c_func
(paren
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ea
)paren
suffix:colon
l_int|0
)paren
op_plus
(paren
(paren
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|acl.flag
op_amp
id|DXD_EXTENT
)paren
ques
c_cond
id|lengthDXD
c_func
(paren
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|acl
)paren
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtExtendPage: ip:0x%p smp:0x%p sp:0x%p&bslash;n&quot;
comma
id|ip
comma
id|smp
comma
id|sp
)paren
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtSplitRoot()&n; *&n; * function:&n; *&t;split the full root page into&n; *&t;original/root/split page and new right page&n; *&t;i.e., root remains fixed in tree anchor (inode) and&n; *&t;the root is copied to a single new right child page&n; *&t;since root page &lt;&lt; non-root page, and&n; *&t;the split root page contains a single entry for the&n; *&t;new right child page.&n; *&n; * parameter:&n; *&n; * return: 0 - success;&n; *&t;   errno - failure;&n; *&t;return new page pinned;&n; */
DECL|function|dtSplitRoot
r_static
r_int
id|dtSplitRoot
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtsplit_t
op_star
id|split
comma
id|metapage_t
op_star
op_star
id|rmpp
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
id|metapage_t
op_star
id|smp
suffix:semicolon
id|dtroot_t
op_star
id|sp
suffix:semicolon
id|metapage_t
op_star
id|rmp
suffix:semicolon
id|dtpage_t
op_star
id|rp
suffix:semicolon
id|s64
id|rbn
suffix:semicolon
r_int
id|xlen
suffix:semicolon
r_int
id|xsize
suffix:semicolon
id|dtslot_t
op_star
id|f
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
r_int
id|fsi
comma
id|stblsize
comma
id|n
suffix:semicolon
id|idtentry_t
op_star
id|s
suffix:semicolon
id|pxd_t
op_star
id|ppxd
suffix:semicolon
id|pxdlist_t
op_star
id|pxdlist
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
multiline_comment|/* get split root page */
id|smp
op_assign
id|split-&gt;mp
suffix:semicolon
id|sp
op_assign
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|i_dtroot
suffix:semicolon
multiline_comment|/*&n;&t; *      allocate/initialize a single (right) child page&n;&t; *&n;&t; * N.B. at first split, a one (or two) block to fit new entry&n;&t; * is allocated; at subsequent split, a full page is allocated;&n;&t; */
id|pxdlist
op_assign
id|split-&gt;pxdlist
suffix:semicolon
id|pxd
op_assign
op_amp
id|pxdlist-&gt;pxd
(braket
id|pxdlist-&gt;npxd
)braket
suffix:semicolon
id|pxdlist-&gt;npxd
op_increment
suffix:semicolon
id|rbn
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|xsize
op_assign
id|xlen
op_lshift
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
id|rmp
op_assign
id|get_metapage
c_func
(paren
id|ip
comma
id|rbn
comma
id|xsize
comma
l_int|1
)paren
suffix:semicolon
id|rp
op_assign
id|rmp-&gt;data
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|rmp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the new right page&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|rmp
comma
id|tlckDTREE
op_or
id|tlckNEW
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|rp-&gt;header.flag
op_assign
(paren
id|sp-&gt;header.flag
op_amp
id|BT_LEAF
)paren
ques
c_cond
id|BT_LEAF
suffix:colon
id|BT_INTERNAL
suffix:semicolon
id|rp-&gt;header.self
op_assign
op_star
id|pxd
suffix:semicolon
multiline_comment|/* initialize sibling pointers */
id|rp-&gt;header.next
op_assign
l_int|0
suffix:semicolon
id|rp-&gt;header.prev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *      move in-line root page into new right page extent&n;&t; */
multiline_comment|/* linelock header + copied entries + new stbl (1st slot) in new page */
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* 1 + 8 + 1 */
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|n
op_assign
id|xsize
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|rp-&gt;header.maxslot
op_assign
id|n
suffix:semicolon
id|stblsize
op_assign
(paren
id|n
op_plus
l_int|31
)paren
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
multiline_comment|/* copy old stbl to new stbl at start of extended area */
id|rp-&gt;header.stblindex
op_assign
id|DTROOTMAXSLOT
suffix:semicolon
id|stbl
op_assign
(paren
id|s8
op_star
)paren
op_amp
id|rp-&gt;slot
(braket
id|DTROOTMAXSLOT
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|stbl
comma
id|sp-&gt;header.stbl
comma
id|sp-&gt;header.nextindex
)paren
suffix:semicolon
id|rp-&gt;header.nextindex
op_assign
id|sp-&gt;header.nextindex
suffix:semicolon
multiline_comment|/* copy old data area to start of new data area */
id|memcpy
c_func
(paren
op_amp
id|rp-&gt;slot
(braket
l_int|1
)braket
comma
op_amp
id|sp-&gt;slot
(braket
l_int|1
)braket
comma
id|IDATASIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * append free region of newly extended area at tail of freelist&n;&t; */
multiline_comment|/* init free region of newly extended area */
id|fsi
op_assign
id|n
op_assign
id|DTROOTMAXSLOT
op_plus
id|stblsize
suffix:semicolon
id|f
op_assign
op_amp
id|rp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
r_for
c_loop
(paren
id|fsi
op_increment
suffix:semicolon
id|fsi
OL
id|rp-&gt;header.maxslot
suffix:semicolon
id|f
op_increment
comma
id|fsi
op_increment
)paren
id|f-&gt;next
op_assign
id|fsi
suffix:semicolon
id|f-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* append new free region at tail of old freelist */
id|fsi
op_assign
id|sp-&gt;header.freelist
suffix:semicolon
r_if
c_cond
(paren
id|fsi
op_eq
op_minus
l_int|1
)paren
id|rp-&gt;header.freelist
op_assign
id|n
suffix:semicolon
r_else
(brace
id|rp-&gt;header.freelist
op_assign
id|fsi
suffix:semicolon
r_do
(brace
id|f
op_assign
op_amp
id|rp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
id|fsi
op_assign
id|f-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fsi
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|f-&gt;next
op_assign
id|n
suffix:semicolon
)brace
id|rp-&gt;header.freecnt
op_assign
id|sp-&gt;header.freecnt
op_plus
id|rp-&gt;header.maxslot
op_minus
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * Update directory index table for entries now in right page&n;&t; */
r_if
c_cond
(paren
(paren
id|rp-&gt;header.flag
op_amp
id|BT_LEAF
)paren
op_logical_and
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
(brace
id|metapage_t
op_star
id|mp
op_assign
l_int|0
suffix:semicolon
id|ldtentry_t
op_star
id|ldtentry
suffix:semicolon
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|rp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|rp-&gt;header.nextindex
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|rp-&gt;slot
(braket
id|stbl
(braket
id|n
)braket
)braket
suffix:semicolon
id|modify_index
c_func
(paren
id|tid
comma
id|ip
comma
id|le32_to_cpu
c_func
(paren
id|ldtentry-&gt;index
)paren
comma
id|rbn
comma
id|n
comma
op_amp
id|mp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp
)paren
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * insert the new entry into the new right/child page&n;&t; * (skip index in the new right page will not change)&n;&t; */
id|dtInsertEntry
c_func
(paren
id|rp
comma
id|split-&gt;index
comma
id|split-&gt;key
comma
id|split-&gt;data
comma
op_amp
id|dtlck
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      reset parent/root page&n;&t; *&n;&t; * set the 1st entry offset to 0, which force the left-most key&n;&t; * at any level of the tree to be less than any search key.&n;&t; *&n;&t; * The btree comparison code guarantees that the left-most key on any&n;&t; * level of the tree is never used, so it doesn&squot;t need to be filled in.&n;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|smp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the root page (in-memory inode)&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|smp
comma
id|tlckDTREE
op_or
id|tlckNEW
op_or
id|tlckBTROOT
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock root */
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
id|DTROOTMAXSLOT
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* update page header of root */
r_if
c_cond
(paren
id|sp-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
id|sp-&gt;header.flag
op_and_assign
op_complement
id|BT_LEAF
suffix:semicolon
id|sp-&gt;header.flag
op_or_assign
id|BT_INTERNAL
suffix:semicolon
)brace
multiline_comment|/* init the first entry */
id|s
op_assign
(paren
id|idtentry_t
op_star
)paren
op_amp
id|sp-&gt;slot
(braket
id|DTENTRYSTART
)braket
suffix:semicolon
id|ppxd
op_assign
(paren
id|pxd_t
op_star
)paren
id|s
suffix:semicolon
op_star
id|ppxd
op_assign
op_star
id|pxd
suffix:semicolon
id|s-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
id|s-&gt;namlen
op_assign
l_int|0
suffix:semicolon
id|stbl
op_assign
id|sp-&gt;header.stbl
suffix:semicolon
id|stbl
(braket
l_int|0
)braket
op_assign
id|DTENTRYSTART
suffix:semicolon
id|sp-&gt;header.nextindex
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* init freelist */
id|fsi
op_assign
id|DTENTRYSTART
op_plus
l_int|1
suffix:semicolon
id|f
op_assign
op_amp
id|sp-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
multiline_comment|/* init free region of remaining area */
r_for
c_loop
(paren
id|fsi
op_increment
suffix:semicolon
id|fsi
OL
id|DTROOTMAXSLOT
suffix:semicolon
id|f
op_increment
comma
id|fsi
op_increment
)paren
id|f-&gt;next
op_assign
id|fsi
suffix:semicolon
id|f-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
id|sp-&gt;header.freelist
op_assign
id|DTENTRYSTART
op_plus
l_int|1
suffix:semicolon
id|sp-&gt;header.freecnt
op_assign
id|DTROOTMAXSLOT
op_minus
(paren
id|DTENTRYSTART
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|rmpp
op_assign
id|rmp
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|lengthPXD
c_func
(paren
id|pxd
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtDelete()&n; *&n; * function: delete the entry(s) referenced by a key.&n; *&n; * parameter:&n; *&n; * return:&n; */
DECL|function|dtDelete
r_int
id|dtDelete
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|component_t
op_star
id|key
comma
id|ino_t
op_star
id|ino
comma
r_int
id|flag
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
comma
op_star
id|imp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ldtentry_t
op_star
id|ldtentry
suffix:semicolon
id|u8
op_star
id|stbl
suffix:semicolon
id|u32
id|table_index
comma
id|next_index
suffix:semicolon
id|metapage_t
op_star
id|nmp
suffix:semicolon
id|dtpage_t
op_star
id|np
suffix:semicolon
multiline_comment|/*&n;&t; *      search for the entry to delete:&n;&t; *&n;&t; * dtSearch() returns (leaf page pinned, index at which to delete).&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtSearch
c_func
(paren
id|ip
comma
id|key
comma
id|ino
comma
op_amp
id|btstack
comma
id|flag
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* retrieve search result */
id|DT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to find put the index of the next entry into the&n;&t; * directory index table in order to resume a readdir from this&n;&t; * entry.&n;&t; */
r_if
c_cond
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
(brace
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|index
)braket
)braket
suffix:semicolon
id|table_index
op_assign
id|le32_to_cpu
c_func
(paren
id|ldtentry-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
(paren
id|p-&gt;header.nextindex
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Last entry in this leaf page&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
op_logical_or
(paren
id|p-&gt;header.next
op_eq
l_int|0
)paren
)paren
id|next_index
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
multiline_comment|/* Read next leaf page */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
comma
id|nmp
comma
id|PSIZE
comma
id|np
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|next_index
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|np
)paren
suffix:semicolon
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|np
op_member_access_from_pointer
id|slot
(braket
id|stbl
(braket
l_int|0
)braket
)braket
suffix:semicolon
id|next_index
op_assign
id|le32_to_cpu
c_func
(paren
id|ldtentry-&gt;index
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|nmp
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|index
op_plus
l_int|1
)braket
)braket
suffix:semicolon
id|next_index
op_assign
id|le32_to_cpu
c_func
(paren
id|ldtentry-&gt;index
)paren
suffix:semicolon
)brace
id|free_index
c_func
(paren
id|tid
comma
id|ip
comma
id|table_index
comma
id|next_index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the leaf page becomes empty, delete the page&n;&t; */
r_if
c_cond
(paren
id|p-&gt;header.nextindex
op_eq
l_int|1
)paren
(brace
multiline_comment|/* delete empty page */
id|rc
op_assign
id|dtDeleteUp
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|p
comma
op_amp
id|btstack
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the leaf page has other entries remaining:&n;&t; *&n;&t; * delete the entry from the leaf page.&n;&t; */
r_else
(brace
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the leaf page&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do not assume that dtlck-&gt;index will be zero.  During a&n;&t;&t; * rename within a directory, this transaction may have&n;&t;&t; * modified this page already when adding the new entry.&n;&t;&t; */
multiline_comment|/* linelock header */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* linelock stbl of non-root leaf page */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
)paren
(brace
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|i
op_assign
id|index
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|lv-&gt;offset
op_assign
id|p-&gt;header.stblindex
op_plus
id|i
suffix:semicolon
id|lv-&gt;length
op_assign
(paren
(paren
id|p-&gt;header.nextindex
op_minus
l_int|1
)paren
op_rshift
id|L2DTSLOTSIZE
)paren
op_minus
id|i
op_plus
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
)brace
multiline_comment|/* free the leaf entry */
id|dtDeleteEntry
c_func
(paren
id|p
comma
id|index
comma
op_amp
id|dtlck
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update directory index table for entries moved in stbl&n;&t;&t; */
r_if
c_cond
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
op_logical_and
id|index
OL
id|p-&gt;header.nextindex
)paren
(brace
id|imp
op_assign
l_int|0
suffix:semicolon
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|index
suffix:semicolon
id|i
OL
id|p-&gt;header.nextindex
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ldtentry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|i
)braket
)braket
suffix:semicolon
id|modify_index
c_func
(paren
id|tid
comma
id|ip
comma
id|le32_to_cpu
c_func
(paren
id|ldtentry-&gt;index
)paren
comma
id|bn
comma
id|i
comma
op_amp
id|imp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|imp
)paren
id|release_metapage
c_func
(paren
id|imp
)paren
suffix:semicolon
)brace
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtDeleteUp()&n; *&n; * function:&n; *&t;free empty pages as propagating deletion up the tree&n; *&n; * parameter:&n; *&n; * return:&n; */
DECL|function|dtDeleteUp
r_static
r_int
id|dtDeleteUp
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|metapage_t
op_star
id|fmp
comma
id|dtpage_t
op_star
id|fp
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
comma
id|nextindex
suffix:semicolon
r_int
id|xlen
suffix:semicolon
id|btframe_t
op_star
id|parent
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *      keep the root leaf page which has become empty&n;&t; */
r_if
c_cond
(paren
id|BT_IS_ROOT
c_func
(paren
id|fmp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * reset the root&n;&t;&t; *&n;&t;&t; * dtInitRoot() acquires txlock on the root&n;&t;&t; */
id|dtInitRoot
c_func
(paren
id|tid
comma
id|ip
comma
id|PARENT
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|fmp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      free the non-root leaf page&n;&t; */
multiline_comment|/*&n;&t; * acquire a transaction lock on the page&n;&t; *&n;&t; * write FREEXTENT|NOREDOPAGE log record&n;&t; * N.B. linelock is overlaid as freed extent descriptor, and&n;&t; * the buffer page is freed;&n;&t; */
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckDTREE
op_or
id|tlckFREE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|pxdlock-&gt;pxd
op_assign
id|fp-&gt;header.self
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* update sibling pointers */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtRelink
c_func
(paren
id|tid
comma
id|ip
comma
id|fp
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|fp-&gt;header.self
)paren
suffix:semicolon
id|ip-&gt;i_blocks
op_sub_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|xlen
)paren
suffix:semicolon
multiline_comment|/* free/invalidate its buffer page */
id|discard_metapage
c_func
(paren
id|fmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      propagate page deletion up the directory tree&n;&t; *&n;&t; * If the delete from the parent page makes it empty,&n;&t; * continue all the way up the tree.&n;&t; * stop if the root page is reached (which is never deleted) or&n;&t; * if the entry deletion does not empty the page.&n;&t; */
r_while
c_loop
(paren
(paren
id|parent
op_assign
id|BT_POP
c_func
(paren
id|btstack
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* pin the parent page &lt;sp&gt; */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|parent-&gt;bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * free the extent of the child page deleted&n;&t;&t; */
id|index
op_assign
id|parent-&gt;index
suffix:semicolon
multiline_comment|/*&n;&t;&t; * delete the entry for the child page from parent&n;&t;&t; */
id|nextindex
op_assign
id|p-&gt;header.nextindex
suffix:semicolon
multiline_comment|/*&n;&t;&t; * the parent has the single entry being deleted:&n;&t;&t; *&n;&t;&t; * free the parent page which has become empty.&n;&t;&t; */
r_if
c_cond
(paren
id|nextindex
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * keep the root internal page which has become empty&n;&t;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * reset the root&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * dtInitRoot() acquires txlock on the root&n;&t;&t;&t;&t; */
id|dtInitRoot
c_func
(paren
id|tid
comma
id|ip
comma
id|PARENT
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * free the parent page&n;&t;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * acquire a transaction lock on the page&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * write FREEXTENT|NOREDOPAGE log record&n;&t;&t;&t;&t; */
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckDTREE
op_or
id|tlckFREE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|pxdlock-&gt;pxd
op_assign
id|p-&gt;header.self
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* update sibling pointers */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtRelink
c_func
(paren
id|tid
comma
id|ip
comma
id|p
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|p-&gt;header.self
)paren
suffix:semicolon
id|ip-&gt;i_blocks
op_sub_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|xlen
)paren
suffix:semicolon
multiline_comment|/* free/invalidate its buffer page */
id|discard_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* propagate up */
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * the parent has other entries remaining:&n;&t;&t; *&n;&t;&t; * delete the router entry from the parent page.&n;&t;&t; */
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the page&n;&t;&t; *&n;&t;&t; * action: router entry deletion&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* linelock stbl of non-root leaf page */
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
)paren
(brace
r_if
c_cond
(paren
id|dtlck-&gt;index
OL
id|dtlck-&gt;maxcnt
)paren
id|lv
op_increment
suffix:semicolon
r_else
(brace
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|i
op_assign
id|index
op_rshift
id|L2DTSLOTSIZE
suffix:semicolon
id|lv-&gt;offset
op_assign
id|p-&gt;header.stblindex
op_plus
id|i
suffix:semicolon
id|lv-&gt;length
op_assign
(paren
(paren
id|p-&gt;header.nextindex
op_minus
l_int|1
)paren
op_rshift
id|L2DTSLOTSIZE
)paren
op_minus
id|i
op_plus
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
)brace
multiline_comment|/* free the router entry */
id|dtDeleteEntry
c_func
(paren
id|p
comma
id|index
comma
op_amp
id|dtlck
)paren
suffix:semicolon
multiline_comment|/* reset key of new leftmost entry of level (for consistency) */
r_if
c_cond
(paren
id|index
op_eq
l_int|0
op_logical_and
(paren
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
op_logical_or
id|p-&gt;header.prev
op_eq
l_int|0
)paren
)paren
id|dtTruncateEntry
c_func
(paren
id|p
comma
l_int|0
comma
op_amp
id|dtlck
)paren
suffix:semicolon
multiline_comment|/* unpin the parent page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* exit propagation up */
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        dtRelocate()&n; *&n; * FUNCTION:    relocate dtpage (internal or leaf) of directory;&n; *              This function is mainly used by defragfs utility.&n; */
DECL|function|dtRelocate
r_int
id|dtRelocate
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|lmxaddr
comma
id|pxd_t
op_star
id|opxd
comma
id|s64
id|nxaddr
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
comma
op_star
id|pmp
comma
op_star
id|lmp
comma
op_star
id|rmp
suffix:semicolon
id|dtpage_t
op_star
id|p
comma
op_star
id|pp
comma
op_star
id|rp
op_assign
l_int|0
comma
op_star
id|lp
op_assign
l_int|0
suffix:semicolon
id|s64
id|bn
suffix:semicolon
r_int
id|index
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|s64
id|oxaddr
comma
id|nextbn
comma
id|prevbn
suffix:semicolon
r_int
id|xlen
comma
id|xsize
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|oxaddr
op_assign
id|addressPXD
c_func
(paren
id|opxd
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
id|opxd
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtRelocate: lmxaddr:%Ld xaddr:%Ld:%Ld xlen:%d&bslash;n&quot;
comma
id|lmxaddr
comma
id|oxaddr
comma
id|nxaddr
comma
id|xlen
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      1. get the internal parent dtpage covering&n;&t; *      router entry for the tartget page to be relocated;&n;&t; */
id|rc
op_assign
id|dtSearchNode
c_func
(paren
id|ip
comma
id|lmxaddr
comma
id|opxd
comma
op_amp
id|btstack
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* retrieve search result */
id|DT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|pmp
comma
id|pp
comma
id|index
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtRelocate: parent router entry validated.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      2. relocate the target dtpage&n;&t; */
multiline_comment|/* read in the target page from src extent */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|oxaddr
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* release the pinned parent page */
id|DT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * read in sibling pages if any to update sibling pointers;&n;&t; */
id|rmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.next
)paren
(brace
id|nextbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|nextbn
comma
id|rmp
comma
id|PSIZE
comma
id|rp
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
id|lmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.prev
)paren
(brace
id|prevbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.prev
)paren
suffix:semicolon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|prevbn
comma
id|lmp
comma
id|PSIZE
comma
id|lp
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rmp
)paren
id|DT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* at this point, all xtpages to be updated are in memory */
multiline_comment|/*&n;&t; * update sibling pointers of sibling dtpages if any;&n;&t; */
r_if
c_cond
(paren
id|lmp
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|lmp
comma
id|tlckDTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header */
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|lp-&gt;header.next
op_assign
id|cpu_to_le64
c_func
(paren
id|nxaddr
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|lmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rmp
)paren
(brace
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|rmp
comma
id|tlckDTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header */
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|rp-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|nxaddr
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|rmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * update the target dtpage to be relocated&n;&t; *&n;&t; * write LOG_REDOPAGE of LOG_NEW type for dst page&n;&t; * for the whole target page (logredo() will apply&n;&t; * after image and update bmap for allocation of the&n;&t; * dst extent), and update bmap for allocation of&n;&t; * the dst extent;&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckNEW
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header */
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* update the self address in the dtpage header */
id|pxd
op_assign
op_amp
id|p-&gt;header.self
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|nxaddr
)paren
suffix:semicolon
multiline_comment|/* the dst page is the same as the src page, i.e.,&n;&t; * linelock for afterimage of the whole page;&n;&t; */
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
id|p-&gt;header.maxslot
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* update the buffer extent descriptor of the dtpage */
id|xsize
op_assign
id|xlen
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
id|bmSetXD
c_func
(paren
id|mp
comma
id|nxaddr
comma
id|xsize
)paren
suffix:semicolon
macro_line|#endif /* _STILL_TO_PORT */
multiline_comment|/* unpin the relocated page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtRelocate: target dtpage relocated.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* the moved extent is dtpage, then a LOG_NOREDOPAGE log rec&n;&t; * needs to be written (in logredo(), the LOG_NOREDOPAGE log rec&n;&t; * will also force a bmap update ).&n;&t; */
multiline_comment|/*&n;&t; *      3. acquire maplock for the source extent to be freed;&n;&t; */
multiline_comment|/* for dtpage relocation, write a LOG_NOREDOPAGE record&n;&t; * for the source dtpage (logredo() will init NoRedoPage&n;&t; * filter and will also update bmap for free of the source&n;&t; * dtpage), and upadte bmap for free of the source dtpage;&n;&t; */
id|tlck
op_assign
id|txMaplock
c_func
(paren
id|tid
comma
id|ip
comma
id|tlckDTREE
op_or
id|tlckFREE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|oxaddr
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|pxdlock-&gt;pxd
comma
id|xlen
)paren
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *      4. update the parent router entry for relocation;&n;&t; *&n;&t; * acquire tlck for the parent entry covering the target dtpage;&n;&t; * write LOG_REDOPAGE to apply after image only;&n;&t; */
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtRelocate: update parent router entry.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|pmp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
multiline_comment|/* update the PXD with the new address */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|pp
)paren
suffix:semicolon
id|pxd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|pp-&gt;slot
(braket
id|stbl
(braket
id|index
)braket
)braket
suffix:semicolon
id|PXDaddress
c_func
(paren
id|pxd
comma
id|nxaddr
)paren
suffix:semicolon
id|lv-&gt;offset
op_assign
id|stbl
(braket
id|index
)braket
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* unpin the parent dtpage */
id|DT_PUTPAGE
c_func
(paren
id|pmp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;dtSearchNode()&n; *&n; * FUNCTION:&t;Search for an dtpage containing a specified address&n; *              This function is mainly used by defragfs utility.&n; *&n; * NOTE:&t;Search result on stack, the found page is pinned at exit.&n; *&t;&t;The result page must be an internal dtpage.&n; *&t;&t;lmxaddr give the address of the left most page of the&n; *&t;&t;dtree level, in which the required dtpage resides.&n; */
DECL|function|dtSearchNode
r_static
r_int
id|dtSearchNode
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|lmxaddr
comma
id|pxd_t
op_star
id|kpxd
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
r_int
id|psize
op_assign
l_int|288
suffix:semicolon
multiline_comment|/* initial in-line directory */
id|s8
op_star
id|stbl
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pxd_t
op_star
id|pxd
suffix:semicolon
id|btframe_t
op_star
id|btsp
suffix:semicolon
id|BT_CLR
c_func
(paren
id|btstack
)paren
suffix:semicolon
multiline_comment|/* reset stack */
multiline_comment|/*&n;&t; *      descend tree to the level with specified leftmost page&n;&t; *&n;&t; *  by convention, root bn = 0.&n;&t; */
r_for
c_loop
(paren
id|bn
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* get/pin the page to search */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|psize
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* does the xaddr of leftmost page of the levevl&n;&t;&t; * matches levevl search key ?&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
r_if
c_cond
(paren
id|lmxaddr
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|addressPXD
c_func
(paren
op_amp
id|p-&gt;header.self
)paren
op_eq
id|lmxaddr
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * descend down to leftmost child page&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
r_return
id|ESTALE
suffix:semicolon
multiline_comment|/* get the leftmost entry */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|pxd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
l_int|0
)braket
)braket
suffix:semicolon
multiline_comment|/* get the child page block address */
id|bn
op_assign
id|addressPXD
c_func
(paren
id|pxd
)paren
suffix:semicolon
id|psize
op_assign
id|lengthPXD
c_func
(paren
id|pxd
)paren
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
multiline_comment|/* unpin the parent page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      search each page at the current levevl&n;&t; */
id|loop
suffix:colon
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;header.nextindex
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pxd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|i
)braket
)braket
suffix:semicolon
multiline_comment|/* found the specified router entry */
r_if
c_cond
(paren
id|addressPXD
c_func
(paren
id|pxd
)paren
op_eq
id|addressPXD
c_func
(paren
id|kpxd
)paren
op_logical_and
id|lengthPXD
c_func
(paren
id|pxd
)paren
op_eq
id|lengthPXD
c_func
(paren
id|kpxd
)paren
)paren
(brace
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|i
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* get the right sibling page if any */
r_if
c_cond
(paren
id|p-&gt;header.next
)paren
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
r_else
(brace
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|ESTALE
suffix:semicolon
)brace
multiline_comment|/* unpin current page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* get the right sibling page */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_goto
id|loop
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtRelink()&n; *&n; * function:&n; *&t;link around a freed page.&n; *&n; * parameter:&n; *&t;fp:&t;page to be freed&n; *&n; * return:&n; */
DECL|function|dtRelink
r_static
r_int
id|dtRelink
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|dtpage_t
op_star
id|p
)paren
(brace
r_int
id|rc
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|s64
id|nextbn
comma
id|prevbn
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|nextbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
id|prevbn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.prev
)paren
suffix:semicolon
multiline_comment|/* update prev pointer of the next page */
r_if
c_cond
(paren
id|nextbn
op_ne
l_int|0
)paren
(brace
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|nextbn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the next page&n;&t;&t; *&n;&t;&t; * action: update prev pointer;&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtRelink nextbn: tlck = 0x%p, ip = 0x%p, mp=0x%p&bslash;n&quot;
comma
id|tlck
comma
id|ip
comma
id|mp
)paren
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|p-&gt;header.prev
op_assign
id|cpu_to_le64
c_func
(paren
id|prevbn
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/* update next pointer of the previous page */
r_if
c_cond
(paren
id|prevbn
op_ne
l_int|0
)paren
(brace
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|prevbn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * acquire a transaction lock on the prev page&n;&t;&t; *&n;&t;&t; * action: update next pointer;&n;&t;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckRELINK
)paren
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;dtRelink prevbn: tlck = 0x%p, ip = 0x%p, mp=0x%p&bslash;n&quot;
comma
id|tlck
comma
id|ip
comma
id|mp
)paren
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock header */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|p-&gt;header.next
op_assign
id|cpu_to_le64
c_func
(paren
id|nextbn
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtInitRoot()&n; *&n; * initialize directory root (inline in inode)&n; */
DECL|function|dtInitRoot
r_void
id|dtInitRoot
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|u32
id|idotdot
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|dtroot_t
op_star
id|p
suffix:semicolon
r_int
id|fsi
suffix:semicolon
id|dtslot_t
op_star
id|f
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|u16
id|xflag_save
suffix:semicolon
multiline_comment|/*&n;&t; * If this was previously an non-empty directory, we need to remove&n;&t; * the old directory table.&n;&t; */
r_if
c_cond
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
id|jfs_ip-&gt;next_index
OG
(paren
id|MAX_INLINE_DIRTABLE_ENTRY
op_plus
l_int|1
)paren
)paren
(brace
id|tblock_t
op_star
id|tblk
op_assign
id|tid_to_tblock
c_func
(paren
id|tid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We&squot;re playing games with the tid&squot;s xflag.  If&n;&t;&t;&t; * we&squot;re removing a regular file, the file&squot;s xtree&n;&t;&t;&t; * is committed with COMMIT_PMAP, but we always&n;&t;&t;&t; * commit the directories xtree with COMMIT_PWMAP.&n;&t;&t;&t; */
id|xflag_save
op_assign
id|tblk-&gt;xflag
suffix:semicolon
id|tblk-&gt;xflag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * xtTruncate isn&squot;t guaranteed to fully truncate&n;&t;&t;&t; * the xtree.  The caller needs to check i_size&n;&t;&t;&t; * after committing the transaction to see if&n;&t;&t;&t; * additional truncation is needed.  The&n;&t;&t;&t; * COMMIT_Stale flag tells caller that we&n;&t;&t;&t; * initiated the truncation.&n;&t;&t;&t; */
id|xtTruncate
c_func
(paren
id|tid
comma
id|ip
comma
l_int|0
comma
id|COMMIT_PWMAP
)paren
suffix:semicolon
id|set_cflag
c_func
(paren
id|COMMIT_Stale
comma
id|ip
)paren
suffix:semicolon
id|tblk-&gt;xflag
op_assign
id|xflag_save
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Tells jfs_metapage code that the metadata pages&n;&t;&t;&t; * for the index table are no longer useful, and&n;&t;&t;&t; * remove them from page cache.&n;&t;&t;&t; */
id|invalidate_inode_metapages
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
r_else
id|ip-&gt;i_size
op_assign
l_int|1
suffix:semicolon
id|jfs_ip-&gt;next_index
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|ip-&gt;i_size
op_assign
id|IDATASIZE
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the root&n;&t; *&n;&t; * action: directory initialization;&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
(paren
id|metapage_t
op_star
)paren
op_amp
id|jfs_ip-&gt;bxflag
comma
id|tlckDTREE
op_or
id|tlckENTRY
op_or
id|tlckBTROOT
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* linelock root */
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
l_int|0
suffix:semicolon
id|lv-&gt;length
op_assign
id|DTROOTMAXSLOT
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
id|p
op_assign
op_amp
id|jfs_ip-&gt;i_dtroot
suffix:semicolon
id|p-&gt;header.flag
op_assign
id|DXD_INDEX
op_or
id|BT_ROOT
op_or
id|BT_LEAF
suffix:semicolon
id|p-&gt;header.nextindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* init freelist */
id|fsi
op_assign
l_int|1
suffix:semicolon
id|f
op_assign
op_amp
id|p-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
multiline_comment|/* init data area of root */
r_for
c_loop
(paren
id|fsi
op_increment
suffix:semicolon
id|fsi
OL
id|DTROOTMAXSLOT
suffix:semicolon
id|f
op_increment
comma
id|fsi
op_increment
)paren
id|f-&gt;next
op_assign
id|fsi
suffix:semicolon
id|f-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
id|p-&gt;header.freelist
op_assign
l_int|1
suffix:semicolon
id|p-&gt;header.freecnt
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* init &squot;..&squot; entry */
id|p-&gt;header.idotdot
op_assign
id|cpu_to_le32
c_func
(paren
id|idotdot
)paren
suffix:semicolon
macro_line|#if 0
id|ip-&gt;i_blocks
op_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
(paren
(paren
id|jfs_ip-&gt;ea.flag
op_amp
id|DXD_EXTENT
)paren
ques
c_cond
id|lengthDXD
c_func
(paren
op_amp
id|jfs_ip-&gt;ea
)paren
suffix:colon
l_int|0
)paren
op_plus
(paren
(paren
id|jfs_ip-&gt;acl.flag
op_amp
id|DXD_EXTENT
)paren
ques
c_cond
id|lengthDXD
c_func
(paren
op_amp
id|jfs_ip-&gt;acl
)paren
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;jfs_readdir()&n; *&n; * function: read directory entries sequentially&n; *&t;from the specified entry offset&n; *&n; * parameter:&n; *&n; * return: offset = (pn, index) of start entry&n; *&t;of next jfs_readdir()/dtRead()&n; */
DECL|function|jfs_readdir
r_int
id|jfs_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|inode
op_star
id|ip
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|nls_table
op_star
id|codepage
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nls_tab
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|dtoffset
(brace
id|s16
id|pn
suffix:semicolon
id|s16
id|index
suffix:semicolon
id|s32
id|unused
suffix:semicolon
)brace
op_star
id|dtoffset
op_assign
(paren
r_struct
id|dtoffset
op_star
)paren
op_amp
id|filp-&gt;f_pos
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
r_int
id|i
comma
id|next
suffix:semicolon
id|ldtentry_t
op_star
id|d
suffix:semicolon
id|dtslot_t
op_star
id|t
suffix:semicolon
r_int
id|d_namleft
comma
id|d_namlen
comma
id|len
comma
id|outlen
suffix:semicolon
r_char
op_star
id|d_name
comma
op_star
id|name_ptr
suffix:semicolon
r_int
id|dtlhdrdatalen
suffix:semicolon
id|u32
id|dir_index
suffix:semicolon
r_int
id|do_index
op_assign
l_int|0
suffix:semicolon
id|uint
id|loop_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
id|DIREND
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DO_INDEX
c_func
(paren
id|ip
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * persistent index is stored in directory entries.&n;&t;&t; * Special cases:        0 = .&n;&t;&t; *                       1 = ..&n;&t;&t; *                      -1 = End of directory&n;&t;&t; */
id|do_index
op_assign
l_int|1
suffix:semicolon
id|dtlhdrdatalen
op_assign
id|DTLHDRDATALEN
suffix:semicolon
id|dir_index
op_assign
(paren
id|u32
)paren
id|filp-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|dir_index
OG
l_int|1
)paren
(brace
id|dir_table_slot_t
id|dirtab_slot
suffix:semicolon
r_if
c_cond
(paren
id|dtEmpty
c_func
(paren
id|ip
)paren
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|repeat
suffix:colon
id|rc
op_assign
id|get_index
c_func
(paren
id|ip
comma
id|dir_index
comma
op_amp
id|dirtab_slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dirtab_slot.flag
op_eq
id|DIR_INDEX_FREE
)paren
(brace
r_if
c_cond
(paren
id|loop_count
op_increment
OG
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|next_index
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_readdir detected &quot;
l_string|&quot;infinite loop!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dir_index
op_assign
id|le32_to_cpu
c_func
(paren
id|dirtab_slot.addr2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir_index
op_eq
op_minus
l_int|1
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
id|bn
op_assign
id|addressDTS
c_func
(paren
op_amp
id|dirtab_slot
)paren
suffix:semicolon
id|index
op_assign
id|dirtab_slot.slot
suffix:semicolon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_INTERNAL
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_readdir: bad index table&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|dir_index
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * self &quot;.&quot;&n;&t;&t;&t;&t; */
id|filp-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
l_int|0
comma
id|ip-&gt;i_ino
comma
id|DT_DIR
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * parent &quot;..&quot;&n;&t;&t;&t; */
id|filp-&gt;f_pos
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|filldir
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
l_int|1
comma
id|PARENT
c_func
(paren
id|ip
)paren
comma
id|DT_DIR
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Find first entry of left-most leaf&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dtEmpty
c_func
(paren
id|ip
)paren
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtReadFirst
c_func
(paren
id|ip
comma
op_amp
id|btstack
)paren
)paren
)paren
r_return
op_minus
id|rc
suffix:semicolon
id|DT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Legacy filesystem - OS/2 &amp; Linux JFS &lt; 0.3.6&n;&t;&t; *&n;&t;&t; * pn = index = 0:      First entry &quot;.&quot;&n;&t;&t; * pn = 0; index = 1:   Second entry &quot;..&quot;&n;&t;&t; * pn &gt; 0:              Real entries, pn=1 -&gt; leftmost page&n;&t;&t; * pn = index = -1:     No more entries&n;&t;&t; */
id|dtlhdrdatalen
op_assign
id|DTLHDRDATALEN_LEGACY
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
l_int|0
)paren
(brace
multiline_comment|/* build &quot;.&quot; entry */
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|filp-&gt;f_pos
comma
id|ip-&gt;i_ino
comma
id|DT_DIR
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|dtoffset-&gt;index
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dtoffset-&gt;pn
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dtoffset-&gt;index
op_eq
l_int|1
)paren
(brace
multiline_comment|/* build &quot;..&quot; entry */
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|filp-&gt;f_pos
comma
id|PARENT
c_func
(paren
id|ip
)paren
comma
id|DT_DIR
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_readdir called with invalid offset!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|dtoffset-&gt;pn
op_assign
l_int|1
suffix:semicolon
id|dtoffset-&gt;index
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dtEmpty
c_func
(paren
id|ip
)paren
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtReadNext
c_func
(paren
id|ip
comma
op_amp
id|filp-&gt;f_pos
comma
op_amp
id|btstack
)paren
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_readdir: unexpected rc = %d from dtReadNext&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get start leaf page and index */
id|DT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* offset beyond directory eof ? */
r_if
c_cond
(paren
id|bn
OL
l_int|0
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|d_name
op_assign
id|kmalloc
c_func
(paren
(paren
id|JFS_NAME_MAX
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
m_wchar_t
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_name
op_eq
l_int|NULL
)paren
(brace
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;jfs_readdir: kmalloc failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|index
suffix:semicolon
id|i
OL
id|p-&gt;header.nextindex
suffix:semicolon
id|i
op_increment
)paren
(brace
id|d
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|i
)braket
)braket
suffix:semicolon
id|d_namleft
op_assign
id|d-&gt;namlen
suffix:semicolon
id|name_ptr
op_assign
id|d_name
suffix:semicolon
r_if
c_cond
(paren
id|do_index
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|le32_to_cpu
c_func
(paren
id|d-&gt;index
)paren
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|d_namleft
comma
id|DTLHDRDATALEN
)paren
suffix:semicolon
)brace
r_else
id|len
op_assign
id|min
c_func
(paren
id|d_namleft
comma
id|DTLHDRDATALEN_LEGACY
)paren
suffix:semicolon
multiline_comment|/* copy the name of head/only segment */
id|outlen
op_assign
id|jfs_strfromUCS_le
c_func
(paren
id|name_ptr
comma
id|d-&gt;name
comma
id|len
comma
id|codepage
)paren
suffix:semicolon
id|d_namlen
op_assign
id|outlen
suffix:semicolon
multiline_comment|/* copy name in the additional segment(s) */
id|next
op_assign
id|d-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ge
l_int|0
)paren
(brace
id|t
op_assign
(paren
id|dtslot_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|next
)braket
suffix:semicolon
id|name_ptr
op_add_assign
id|outlen
suffix:semicolon
id|d_namleft
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* Sanity Check */
r_if
c_cond
(paren
id|d_namleft
op_eq
l_int|0
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;JFS:Dtree error: &quot;
l_string|&quot;ino = %ld, bn=%Ld, index = %d&bslash;n&quot;
comma
id|ip-&gt;i_ino
comma
id|bn
comma
id|i
)paren
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
r_goto
id|skip_one
suffix:semicolon
)brace
id|len
op_assign
id|min
c_func
(paren
id|d_namleft
comma
id|DTSLOTDATALEN
)paren
suffix:semicolon
id|outlen
op_assign
id|jfs_strfromUCS_le
c_func
(paren
id|name_ptr
comma
id|t-&gt;name
comma
id|len
comma
id|codepage
)paren
suffix:semicolon
id|d_namlen
op_add_assign
id|outlen
suffix:semicolon
id|next
op_assign
id|t-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|d_name
comma
id|d_namlen
comma
id|filp-&gt;f_pos
comma
id|le32_to_cpu
c_func
(paren
id|d-&gt;inumber
)paren
comma
id|DT_UNKNOWN
)paren
)paren
r_goto
id|out
suffix:semicolon
id|skip_one
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|do_index
)paren
id|dtoffset-&gt;index
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * get next leaf page&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bn
op_eq
l_int|0
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|DIREND
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* unpin previous leaf page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* get next leaf page */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|kfree
c_func
(paren
id|d_name
)paren
suffix:semicolon
r_return
op_minus
id|rc
suffix:semicolon
)brace
multiline_comment|/* update offset (pn:index) for new page */
id|index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|do_index
)paren
(brace
id|dtoffset-&gt;pn
op_increment
suffix:semicolon
id|dtoffset-&gt;index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|kfree
c_func
(paren
id|d_name
)paren
suffix:semicolon
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtReadFirst()&n; *&n; * function: get the leftmost page of the directory&n; */
DECL|function|dtReadFirst
r_static
r_int
id|dtReadFirst
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s64
id|bn
suffix:semicolon
r_int
id|psize
op_assign
l_int|288
suffix:semicolon
multiline_comment|/* initial in-line directory */
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
id|btframe_t
op_star
id|btsp
suffix:semicolon
id|pxd_t
op_star
id|xd
suffix:semicolon
id|BT_CLR
c_func
(paren
id|btstack
)paren
suffix:semicolon
multiline_comment|/* reset stack */
multiline_comment|/*&n;&t; *      descend leftmost path of the tree&n;&t; *&n;&t; * by convention, root bn = 0.&n;&t; */
r_for
c_loop
(paren
id|bn
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
)paren
(brace
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|psize
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t;&t; * leftmost leaf page&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
multiline_comment|/* return leftmost entry */
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
l_int|0
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * descend down to leftmost child page&n;&t;&t; */
multiline_comment|/* push (bn, index) of the parent page/entry */
id|BT_PUSH
c_func
(paren
id|btstack
comma
id|bn
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* get the leftmost entry */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|xd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
l_int|0
)braket
)braket
suffix:semicolon
multiline_comment|/* get the child page block address */
id|bn
op_assign
id|addressPXD
c_func
(paren
id|xd
)paren
suffix:semicolon
id|psize
op_assign
id|lengthPXD
c_func
(paren
id|xd
)paren
op_lshift
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2bsize
suffix:semicolon
multiline_comment|/* unpin the parent page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;dtReadNext()&n; *&n; * function: get the page of the specified offset (pn:index)&n; *&n; * return: if (offset &gt; eof), bn = -1;&n; *&n; * note: if index &gt; nextindex of the target leaf page,&n; * start with 1st entry of next leaf page;&n; */
DECL|function|dtReadNext
r_static
r_int
id|dtReadNext
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|loff_t
op_star
id|offset
comma
id|btstack_t
op_star
id|btstack
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_struct
id|dtoffset
(brace
id|s16
id|pn
suffix:semicolon
id|s16
id|index
suffix:semicolon
id|s32
id|unused
suffix:semicolon
)brace
op_star
id|dtoffset
op_assign
(paren
r_struct
id|dtoffset
op_star
)paren
id|offset
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|pn
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
id|btframe_t
op_star
id|btsp
comma
op_star
id|parent
suffix:semicolon
id|pxd_t
op_star
id|xd
suffix:semicolon
multiline_comment|/*&n;&t; * get leftmost leaf page pinned&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtReadFirst
c_func
(paren
id|ip
comma
id|btstack
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* get leaf page */
id|DT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack-&gt;top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* get the start offset (pn:index) */
id|pn
op_assign
id|dtoffset-&gt;pn
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Now pn = 0 represents leftmost leaf */
id|index
op_assign
id|dtoffset-&gt;index
suffix:semicolon
multiline_comment|/* start at leftmost page ? */
r_if
c_cond
(paren
id|pn
op_eq
l_int|0
)paren
(brace
multiline_comment|/* offset beyond eof ? */
r_if
c_cond
(paren
id|index
OL
id|p-&gt;header.nextindex
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
id|bn
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* start with 1st entry of next leaf page */
id|dtoffset-&gt;pn
op_increment
suffix:semicolon
id|dtoffset-&gt;index
op_assign
id|index
op_assign
l_int|0
suffix:semicolon
r_goto
id|a
suffix:semicolon
)brace
multiline_comment|/* start at non-leftmost page: scan parent pages for large pn */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
(brace
id|bn
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* start after next leaf page ? */
r_if
c_cond
(paren
id|pn
OG
l_int|1
)paren
r_goto
id|b
suffix:semicolon
multiline_comment|/* get leaf page pn = 1 */
id|a
suffix:colon
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
multiline_comment|/* unpin leaf page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* offset beyond eof ? */
r_if
c_cond
(paren
id|bn
op_eq
l_int|0
)paren
(brace
id|bn
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_goto
id|c
suffix:semicolon
multiline_comment|/*&n;&t; * scan last internal page level to get target leaf page&n;&t; */
id|b
suffix:colon
multiline_comment|/* unpin leftmost leaf page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* get left most parent page */
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|parent
op_assign
id|btsp
op_minus
l_int|1
suffix:semicolon
id|bn
op_assign
id|parent-&gt;bn
suffix:semicolon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* scan parent pages at last internal page level */
r_while
c_loop
(paren
id|pn
op_ge
id|p-&gt;header.nextindex
)paren
(brace
id|pn
op_sub_assign
id|p-&gt;header.nextindex
suffix:semicolon
multiline_comment|/* get next parent page address */
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
multiline_comment|/* unpin current parent page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* offset beyond eof ? */
r_if
c_cond
(paren
id|bn
op_eq
l_int|0
)paren
(brace
id|bn
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* get next parent page */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* update parent page stack frame */
id|parent-&gt;bn
op_assign
id|bn
suffix:semicolon
)brace
multiline_comment|/* get leaf page address */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|xd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|pn
)braket
)braket
suffix:semicolon
id|bn
op_assign
id|addressPXD
c_func
(paren
id|xd
)paren
suffix:semicolon
multiline_comment|/* unpin parent page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * get target leaf page&n;&t; */
id|c
suffix:colon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * leaf page has been completed:&n;&t; * start with 1st entry of next leaf page&n;&t; */
r_if
c_cond
(paren
id|index
op_ge
id|p-&gt;header.nextindex
)paren
(brace
id|bn
op_assign
id|le64_to_cpu
c_func
(paren
id|p-&gt;header.next
)paren
suffix:semicolon
multiline_comment|/* unpin leaf page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* offset beyond eof ? */
r_if
c_cond
(paren
id|bn
op_eq
l_int|0
)paren
(brace
id|bn
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* get next leaf page */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* start with 1st entry of next leaf page */
id|dtoffset-&gt;pn
op_increment
suffix:semicolon
id|dtoffset-&gt;index
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/* return target leaf page pinned */
id|btsp
op_assign
id|btstack-&gt;top
suffix:semicolon
id|btsp-&gt;bn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|dtoffset-&gt;index
suffix:semicolon
id|btsp-&gt;mp
op_assign
id|mp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtCompare()&n; *&n; * function: compare search key with an internal entry&n; *&n; * return:&n; *&t;&lt; 0 if k is &lt; record&n; *&t;= 0 if k is = record&n; *&t;&gt; 0 if k is &gt; record&n; */
DECL|function|dtCompare
r_static
r_int
id|dtCompare
c_func
(paren
id|component_t
op_star
id|key
comma
multiline_comment|/* search key */
id|dtpage_t
op_star
id|p
comma
multiline_comment|/* directory page */
r_int
id|si
)paren
(brace
multiline_comment|/* entry slot index */
m_wchar_t
op_star
id|kname
comma
op_star
id|name
suffix:semicolon
r_int
id|klen
comma
id|namlen
comma
id|len
comma
id|rc
suffix:semicolon
id|idtentry_t
op_star
id|ih
suffix:semicolon
id|dtslot_t
op_star
id|t
suffix:semicolon
multiline_comment|/*&n;&t; * force the left-most key on internal pages, at any level of&n;&t; * the tree, to be less than any search key.&n;&t; * this obviates having to update the leftmost key on an internal&n;&t; * page when the user inserts a new key in the tree smaller than&n;&t; * anything that has been stored.&n;&t; *&n;&t; * (? if/when dtSearch() narrows down to 1st entry (index = 0),&n;&t; * at any internal page at any level of the tree,&n;&t; * it descends to child of the entry anyway -&n;&t; * ? make the entry as min size dummy entry)&n;&t; *&n;&t; * if (e-&gt;index == 0 &amp;&amp; h-&gt;prevpg == P_INVALID &amp;&amp; !(h-&gt;flags &amp; BT_LEAF))&n;&t; * return (1);&n;&t; */
id|kname
op_assign
id|key-&gt;name
suffix:semicolon
id|klen
op_assign
id|key-&gt;namlen
suffix:semicolon
id|ih
op_assign
(paren
id|idtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|si
op_assign
id|ih-&gt;next
suffix:semicolon
id|name
op_assign
id|ih-&gt;name
suffix:semicolon
id|namlen
op_assign
id|ih-&gt;namlen
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTIHDRDATALEN
)paren
suffix:semicolon
multiline_comment|/* compare with head/only segment */
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|UniStrncmp_le
c_func
(paren
id|kname
comma
id|name
comma
id|len
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|klen
op_sub_assign
id|len
suffix:semicolon
id|namlen
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* compare with additional segment(s) */
id|kname
op_add_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
id|klen
OG
l_int|0
op_logical_and
id|namlen
OG
l_int|0
)paren
(brace
multiline_comment|/* compare with next name segment */
id|t
op_assign
(paren
id|dtslot_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTSLOTDATALEN
)paren
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|len
)paren
suffix:semicolon
id|name
op_assign
id|t-&gt;name
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|UniStrncmp_le
c_func
(paren
id|kname
comma
id|name
comma
id|len
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
id|klen
op_sub_assign
id|len
suffix:semicolon
id|namlen
op_sub_assign
id|len
suffix:semicolon
id|kname
op_add_assign
id|len
suffix:semicolon
id|si
op_assign
id|t-&gt;next
suffix:semicolon
)brace
r_return
(paren
id|klen
op_minus
id|namlen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;ciCompare()&n; *&n; * function: compare search key with an (leaf/internal) entry&n; *&n; * return:&n; *&t;&lt; 0 if k is &lt; record&n; *&t;= 0 if k is = record&n; *&t;&gt; 0 if k is &gt; record&n; */
DECL|function|ciCompare
r_static
r_int
id|ciCompare
c_func
(paren
id|component_t
op_star
id|key
comma
multiline_comment|/* search key */
id|dtpage_t
op_star
id|p
comma
multiline_comment|/* directory page */
r_int
id|si
comma
multiline_comment|/* entry slot index */
r_int
id|flag
)paren
(brace
m_wchar_t
op_star
id|kname
comma
op_star
id|name
comma
id|x
suffix:semicolon
r_int
id|klen
comma
id|namlen
comma
id|len
comma
id|rc
suffix:semicolon
id|ldtentry_t
op_star
id|lh
suffix:semicolon
id|idtentry_t
op_star
id|ih
suffix:semicolon
id|dtslot_t
op_star
id|t
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * force the left-most key on internal pages, at any level of&n;&t; * the tree, to be less than any search key.&n;&t; * this obviates having to update the leftmost key on an internal&n;&t; * page when the user inserts a new key in the tree smaller than&n;&t; * anything that has been stored.&n;&t; *&n;&t; * (? if/when dtSearch() narrows down to 1st entry (index = 0),&n;&t; * at any internal page at any level of the tree,&n;&t; * it descends to child of the entry anyway -&n;&t; * ? make the entry as min size dummy entry)&n;&t; *&n;&t; * if (e-&gt;index == 0 &amp;&amp; h-&gt;prevpg == P_INVALID &amp;&amp; !(h-&gt;flags &amp; BT_LEAF))&n;&t; * return (1);&n;&t; */
id|kname
op_assign
id|key-&gt;name
suffix:semicolon
id|klen
op_assign
id|key-&gt;namlen
suffix:semicolon
multiline_comment|/*&n;&t; * leaf page entry&n;&t; */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
id|lh
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|si
op_assign
id|lh-&gt;next
suffix:semicolon
id|name
op_assign
id|lh-&gt;name
suffix:semicolon
id|namlen
op_assign
id|lh-&gt;namlen
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|JFS_DIR_INDEX
)paren
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTLHDRDATALEN
)paren
suffix:semicolon
r_else
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTLHDRDATALEN_LEGACY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * internal page entry&n;&t; */
r_else
(brace
id|ih
op_assign
(paren
id|idtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|si
op_assign
id|ih-&gt;next
suffix:semicolon
id|name
op_assign
id|ih-&gt;name
suffix:semicolon
id|namlen
op_assign
id|ih-&gt;namlen
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTIHDRDATALEN
)paren
suffix:semicolon
)brace
multiline_comment|/* compare with head/only segment */
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
comma
id|kname
op_increment
comma
id|name
op_increment
)paren
(brace
multiline_comment|/* only uppercase if case-insensitive support is on */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|JFS_OS2
)paren
op_eq
id|JFS_OS2
)paren
id|x
op_assign
id|UniToupper
c_func
(paren
id|le16_to_cpu
c_func
(paren
op_star
id|name
)paren
)paren
suffix:semicolon
r_else
id|x
op_assign
id|le16_to_cpu
c_func
(paren
op_star
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
op_star
id|kname
op_minus
id|x
)paren
)paren
r_return
id|rc
suffix:semicolon
)brace
id|klen
op_sub_assign
id|len
suffix:semicolon
id|namlen
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* compare with additional segment(s) */
r_while
c_loop
(paren
id|klen
OG
l_int|0
op_logical_and
id|namlen
OG
l_int|0
)paren
(brace
multiline_comment|/* compare with next name segment */
id|t
op_assign
(paren
id|dtslot_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTSLOTDATALEN
)paren
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|len
)paren
suffix:semicolon
id|name
op_assign
id|t-&gt;name
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
comma
id|kname
op_increment
comma
id|name
op_increment
)paren
(brace
multiline_comment|/* only uppercase if case-insensitive support is on */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|JFS_OS2
)paren
op_eq
id|JFS_OS2
)paren
id|x
op_assign
id|UniToupper
c_func
(paren
id|le16_to_cpu
c_func
(paren
op_star
id|name
)paren
)paren
suffix:semicolon
r_else
id|x
op_assign
id|le16_to_cpu
c_func
(paren
op_star
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
op_star
id|kname
op_minus
id|x
)paren
)paren
r_return
id|rc
suffix:semicolon
)brace
id|klen
op_sub_assign
id|len
suffix:semicolon
id|namlen
op_sub_assign
id|len
suffix:semicolon
id|si
op_assign
id|t-&gt;next
suffix:semicolon
)brace
r_return
(paren
id|klen
op_minus
id|namlen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;ciGetLeafPrefixKey()&n; *&n; * function: compute prefix of suffix compression&n; *&t;     from two adjacent leaf entries&n; *&t;     across page boundary&n; *&n; * return:&n; *&t;Number of prefix bytes needed to distinguish b from a.&n; */
DECL|function|ciGetLeafPrefixKey
r_static
r_void
id|ciGetLeafPrefixKey
c_func
(paren
id|dtpage_t
op_star
id|lp
comma
r_int
id|li
comma
id|dtpage_t
op_star
id|rp
comma
r_int
id|ri
comma
id|component_t
op_star
id|key
comma
r_int
id|flag
)paren
(brace
r_int
id|klen
comma
id|namlen
suffix:semicolon
m_wchar_t
op_star
id|pl
comma
op_star
id|pr
comma
op_star
id|kname
suffix:semicolon
m_wchar_t
id|lname
(braket
id|JFS_NAME_MAX
op_plus
l_int|1
)braket
suffix:semicolon
id|component_t
id|lkey
op_assign
(brace
l_int|0
comma
id|lname
)brace
suffix:semicolon
m_wchar_t
id|rname
(braket
id|JFS_NAME_MAX
op_plus
l_int|1
)braket
suffix:semicolon
id|component_t
id|rkey
op_assign
(brace
l_int|0
comma
id|rname
)brace
suffix:semicolon
multiline_comment|/* get left and right key */
id|dtGetKey
c_func
(paren
id|lp
comma
id|li
comma
op_amp
id|lkey
comma
id|flag
)paren
suffix:semicolon
id|lkey.name
(braket
id|lkey.namlen
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|JFS_OS2
)paren
op_eq
id|JFS_OS2
)paren
id|ciToUpper
c_func
(paren
op_amp
id|lkey
)paren
suffix:semicolon
id|dtGetKey
c_func
(paren
id|rp
comma
id|ri
comma
op_amp
id|rkey
comma
id|flag
)paren
suffix:semicolon
id|rkey.name
(braket
id|rkey.namlen
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|JFS_OS2
)paren
op_eq
id|JFS_OS2
)paren
id|ciToUpper
c_func
(paren
op_amp
id|rkey
)paren
suffix:semicolon
multiline_comment|/* compute prefix */
id|klen
op_assign
l_int|0
suffix:semicolon
id|kname
op_assign
id|key-&gt;name
suffix:semicolon
id|namlen
op_assign
id|min
c_func
(paren
id|lkey.namlen
comma
id|rkey.namlen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|pl
op_assign
id|lkey.name
comma
id|pr
op_assign
id|rkey.name
suffix:semicolon
id|namlen
suffix:semicolon
id|pl
op_increment
comma
id|pr
op_increment
comma
id|namlen
op_decrement
comma
id|klen
op_increment
comma
id|kname
op_increment
)paren
(brace
op_star
id|kname
op_assign
op_star
id|pr
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pl
op_ne
op_star
id|pr
)paren
(brace
id|key-&gt;namlen
op_assign
id|klen
op_plus
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* l-&gt;namlen &lt;= r-&gt;namlen since l &lt;= r */
r_if
c_cond
(paren
id|lkey.namlen
OL
id|rkey.namlen
)paren
(brace
op_star
id|kname
op_assign
op_star
id|pr
suffix:semicolon
id|key-&gt;namlen
op_assign
id|klen
op_plus
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/* l-&gt;namelen == r-&gt;namelen */
id|key-&gt;namlen
op_assign
id|klen
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtGetKey()&n; *&n; * function: get key of the entry&n; */
DECL|function|dtGetKey
r_static
r_void
id|dtGetKey
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|i
comma
multiline_comment|/* entry index */
id|component_t
op_star
id|key
comma
r_int
id|flag
)paren
(brace
r_int
id|si
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
id|ldtentry_t
op_star
id|lh
suffix:semicolon
id|idtentry_t
op_star
id|ih
suffix:semicolon
id|dtslot_t
op_star
id|t
suffix:semicolon
r_int
id|namlen
comma
id|len
suffix:semicolon
m_wchar_t
op_star
id|name
comma
op_star
id|kname
suffix:semicolon
multiline_comment|/* get entry */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|si
op_assign
id|stbl
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
id|lh
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|si
op_assign
id|lh-&gt;next
suffix:semicolon
id|namlen
op_assign
id|lh-&gt;namlen
suffix:semicolon
id|name
op_assign
id|lh-&gt;name
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|JFS_DIR_INDEX
)paren
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTLHDRDATALEN
)paren
suffix:semicolon
r_else
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTLHDRDATALEN_LEGACY
)paren
suffix:semicolon
)brace
r_else
(brace
id|ih
op_assign
(paren
id|idtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|si
op_assign
id|ih-&gt;next
suffix:semicolon
id|namlen
op_assign
id|ih-&gt;namlen
suffix:semicolon
id|name
op_assign
id|ih-&gt;name
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTIHDRDATALEN
)paren
suffix:semicolon
)brace
id|key-&gt;namlen
op_assign
id|namlen
suffix:semicolon
id|kname
op_assign
id|key-&gt;name
suffix:semicolon
multiline_comment|/*&n;&t; * move head/only segment&n;&t; */
id|UniStrncpy_le
c_func
(paren
id|kname
comma
id|name
comma
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * move additional segment(s)&n;&t; */
r_while
c_loop
(paren
id|si
op_ge
l_int|0
)paren
(brace
multiline_comment|/* get next segment */
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|kname
op_add_assign
id|len
suffix:semicolon
id|namlen
op_sub_assign
id|len
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|namlen
comma
id|DTSLOTDATALEN
)paren
suffix:semicolon
id|UniStrncpy_le
c_func
(paren
id|kname
comma
id|t-&gt;name
comma
id|len
)paren
suffix:semicolon
id|si
op_assign
id|t-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;dtInsertEntry()&n; *&n; * function: allocate free slot(s) and&n; *&t;     write a leaf/internal entry&n; *&n; * return: entry slot index&n; */
DECL|function|dtInsertEntry
r_static
r_void
id|dtInsertEntry
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|index
comma
id|component_t
op_star
id|key
comma
id|ddata_t
op_star
id|data
comma
id|dtlock_t
op_star
op_star
id|dtlock
)paren
(brace
id|dtslot_t
op_star
id|h
comma
op_star
id|t
suffix:semicolon
id|ldtentry_t
op_star
id|lh
op_assign
l_int|0
suffix:semicolon
id|idtentry_t
op_star
id|ih
op_assign
l_int|0
suffix:semicolon
r_int
id|hsi
comma
id|fsi
comma
id|klen
comma
id|len
comma
id|nextindex
suffix:semicolon
m_wchar_t
op_star
id|kname
comma
op_star
id|name
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
id|pxd_t
op_star
id|xd
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
op_assign
op_star
id|dtlock
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
r_int
id|xsi
comma
id|n
suffix:semicolon
id|s64
id|bn
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|mp
op_assign
l_int|0
suffix:semicolon
id|klen
op_assign
id|key-&gt;namlen
suffix:semicolon
id|kname
op_assign
id|key-&gt;name
suffix:semicolon
multiline_comment|/* allocate a free slot */
id|hsi
op_assign
id|fsi
op_assign
id|p-&gt;header.freelist
suffix:semicolon
id|h
op_assign
op_amp
id|p-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
id|p-&gt;header.freelist
op_assign
id|h-&gt;next
suffix:semicolon
op_decrement
id|p-&gt;header.freecnt
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
id|hsi
suffix:semicolon
multiline_comment|/* write head/only segment */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
id|lh
op_assign
(paren
id|ldtentry_t
op_star
)paren
id|h
suffix:semicolon
id|lh-&gt;next
op_assign
id|h-&gt;next
suffix:semicolon
id|lh-&gt;inumber
op_assign
id|data-&gt;leaf.ino
suffix:semicolon
multiline_comment|/* little-endian */
id|lh-&gt;namlen
op_assign
id|klen
suffix:semicolon
id|name
op_assign
id|lh-&gt;name
suffix:semicolon
r_if
c_cond
(paren
id|data-&gt;leaf.ip
)paren
(brace
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|DTLHDRDATALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;header.flag
op_amp
id|BT_ROOT
)paren
)paren
id|bn
op_assign
id|addressPXD
c_func
(paren
op_amp
id|p-&gt;header.self
)paren
suffix:semicolon
id|lh-&gt;index
op_assign
id|cpu_to_le32
c_func
(paren
id|add_index
c_func
(paren
id|data-&gt;leaf.tid
comma
id|data-&gt;leaf.ip
comma
id|bn
comma
id|index
)paren
)paren
suffix:semicolon
)brace
r_else
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|DTLHDRDATALEN_LEGACY
)paren
suffix:semicolon
)brace
r_else
(brace
id|ih
op_assign
(paren
id|idtentry_t
op_star
)paren
id|h
suffix:semicolon
id|ih-&gt;next
op_assign
id|h-&gt;next
suffix:semicolon
id|xd
op_assign
(paren
id|pxd_t
op_star
)paren
id|ih
suffix:semicolon
op_star
id|xd
op_assign
id|data-&gt;xd
suffix:semicolon
id|ih-&gt;namlen
op_assign
id|klen
suffix:semicolon
id|name
op_assign
id|ih-&gt;name
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|DTIHDRDATALEN
)paren
suffix:semicolon
)brace
id|UniStrncpy_le
c_func
(paren
id|name
comma
id|kname
comma
id|len
)paren
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|xsi
op_assign
id|hsi
suffix:semicolon
multiline_comment|/* write additional segment(s) */
id|t
op_assign
id|h
suffix:semicolon
id|klen
op_sub_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
id|klen
)paren
(brace
multiline_comment|/* get free slot */
id|fsi
op_assign
id|p-&gt;header.freelist
suffix:semicolon
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
id|p-&gt;header.freelist
op_assign
id|t-&gt;next
suffix:semicolon
op_decrement
id|p-&gt;header.freecnt
suffix:semicolon
multiline_comment|/* is next slot contiguous ? */
r_if
c_cond
(paren
id|fsi
op_ne
id|xsi
op_plus
l_int|1
)paren
(brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
OL
id|dtlck-&gt;maxcnt
)paren
id|lv
op_increment
suffix:semicolon
r_else
(brace
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|lv-&gt;offset
op_assign
id|fsi
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
)brace
id|kname
op_add_assign
id|len
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|klen
comma
id|DTSLOTDATALEN
)paren
suffix:semicolon
id|UniStrncpy_le
c_func
(paren
id|t-&gt;name
comma
id|kname
comma
id|len
)paren
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|xsi
op_assign
id|fsi
suffix:semicolon
id|klen
op_sub_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
op_star
id|dtlock
op_assign
id|dtlck
suffix:semicolon
multiline_comment|/* terminate last/only segment */
r_if
c_cond
(paren
id|h
op_eq
id|t
)paren
(brace
multiline_comment|/* single segment entry */
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
id|lh-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|ih-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/* multi-segment entry */
id|t-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* if insert into middle, shift right succeeding entries in stbl */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|nextindex
op_assign
id|p-&gt;header.nextindex
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|nextindex
)paren
(brace
id|memmove
c_func
(paren
id|stbl
op_plus
id|index
op_plus
l_int|1
comma
id|stbl
op_plus
id|index
comma
id|nextindex
op_minus
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
op_logical_and
id|data-&gt;leaf.ip
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Need to update slot number for entries that moved&n;&t;&t;&t; * in the stbl&n;&t;&t;&t; */
id|mp
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|index
op_plus
l_int|1
suffix:semicolon
id|n
op_le
id|nextindex
suffix:semicolon
id|n
op_increment
)paren
(brace
id|lh
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
(paren
id|p-&gt;slot
(braket
id|stbl
(braket
id|n
)braket
)braket
)paren
suffix:semicolon
id|modify_index
c_func
(paren
id|data-&gt;leaf.tid
comma
id|data-&gt;leaf.ip
comma
id|le32_to_cpu
c_func
(paren
id|lh-&gt;index
)paren
comma
id|bn
comma
id|n
comma
op_amp
id|mp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp
)paren
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
)brace
id|stbl
(braket
id|index
)braket
op_assign
id|hsi
suffix:semicolon
multiline_comment|/* advance next available entry index of stbl */
op_increment
id|p-&gt;header.nextindex
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtMoveEntry()&n; *&n; * function: move entries from split/left page to new/right page&n; *&n; *&t;nextindex of dst page and freelist/freecnt of both pages&n; *&t;are updated.&n; */
DECL|function|dtMoveEntry
r_static
r_void
id|dtMoveEntry
c_func
(paren
id|dtpage_t
op_star
id|sp
comma
r_int
id|si
comma
id|dtpage_t
op_star
id|dp
comma
id|dtlock_t
op_star
op_star
id|sdtlock
comma
id|dtlock_t
op_star
op_star
id|ddtlock
comma
r_int
id|do_index
)paren
(brace
r_int
id|ssi
comma
id|next
suffix:semicolon
multiline_comment|/* src slot index */
r_int
id|di
suffix:semicolon
multiline_comment|/* dst entry index */
r_int
id|dsi
suffix:semicolon
multiline_comment|/* dst slot index */
id|s8
op_star
id|sstbl
comma
op_star
id|dstbl
suffix:semicolon
multiline_comment|/* sorted entry table */
r_int
id|snamlen
comma
id|len
suffix:semicolon
id|ldtentry_t
op_star
id|slh
comma
op_star
id|dlh
op_assign
l_int|0
suffix:semicolon
id|idtentry_t
op_star
id|sih
comma
op_star
id|dih
op_assign
l_int|0
suffix:semicolon
id|dtslot_t
op_star
id|h
comma
op_star
id|s
comma
op_star
id|d
suffix:semicolon
id|dtlock_t
op_star
id|sdtlck
op_assign
op_star
id|sdtlock
comma
op_star
id|ddtlck
op_assign
op_star
id|ddtlock
suffix:semicolon
id|lv_t
op_star
id|slv
comma
op_star
id|dlv
suffix:semicolon
r_int
id|xssi
comma
id|ns
comma
id|nd
suffix:semicolon
r_int
id|sfsi
suffix:semicolon
id|sstbl
op_assign
(paren
id|s8
op_star
)paren
op_amp
id|sp-&gt;slot
(braket
id|sp-&gt;header.stblindex
)braket
suffix:semicolon
id|dstbl
op_assign
(paren
id|s8
op_star
)paren
op_amp
id|dp-&gt;slot
(braket
id|dp-&gt;header.stblindex
)braket
suffix:semicolon
id|dsi
op_assign
id|dp-&gt;header.freelist
suffix:semicolon
multiline_comment|/* first (whole page) free slot */
id|sfsi
op_assign
id|sp-&gt;header.freelist
suffix:semicolon
multiline_comment|/* linelock destination entry slot */
id|dlv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|ddtlck-&gt;lv
(braket
id|ddtlck-&gt;index
)braket
suffix:semicolon
id|dlv-&gt;offset
op_assign
id|dsi
suffix:semicolon
multiline_comment|/* linelock source entry slot */
id|slv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|sdtlck-&gt;lv
(braket
id|sdtlck-&gt;index
)braket
suffix:semicolon
id|slv-&gt;offset
op_assign
id|sstbl
(braket
id|si
)braket
suffix:semicolon
id|xssi
op_assign
id|slv-&gt;offset
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * move entries&n;&t; */
id|ns
op_assign
id|nd
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|di
op_assign
l_int|0
suffix:semicolon
id|si
OL
id|sp-&gt;header.nextindex
suffix:semicolon
id|si
op_increment
comma
id|di
op_increment
)paren
(brace
id|ssi
op_assign
id|sstbl
(braket
id|si
)braket
suffix:semicolon
id|dstbl
(braket
id|di
)braket
op_assign
id|dsi
suffix:semicolon
multiline_comment|/* is next slot contiguous ? */
r_if
c_cond
(paren
id|ssi
op_ne
id|xssi
op_plus
l_int|1
)paren
(brace
multiline_comment|/* close current linelock */
id|slv-&gt;length
op_assign
id|ns
suffix:semicolon
id|sdtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|sdtlck-&gt;index
OL
id|sdtlck-&gt;maxcnt
)paren
id|slv
op_increment
suffix:semicolon
r_else
(brace
id|sdtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|sdtlck
)paren
suffix:semicolon
id|slv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|sdtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|slv-&gt;offset
op_assign
id|ssi
suffix:semicolon
id|ns
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * move head/only segment of an entry&n;&t;&t; */
multiline_comment|/* get dst slot */
id|h
op_assign
id|d
op_assign
op_amp
id|dp-&gt;slot
(braket
id|dsi
)braket
suffix:semicolon
multiline_comment|/* get src slot and move */
id|s
op_assign
op_amp
id|sp-&gt;slot
(braket
id|ssi
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
multiline_comment|/* get source entry */
id|slh
op_assign
(paren
id|ldtentry_t
op_star
)paren
id|s
suffix:semicolon
id|dlh
op_assign
(paren
id|ldtentry_t
op_star
)paren
id|h
suffix:semicolon
id|snamlen
op_assign
id|slh-&gt;namlen
suffix:semicolon
r_if
c_cond
(paren
id|do_index
)paren
(brace
id|len
op_assign
id|min
c_func
(paren
id|snamlen
comma
id|DTLHDRDATALEN
)paren
suffix:semicolon
id|dlh-&gt;index
op_assign
id|slh-&gt;index
suffix:semicolon
multiline_comment|/* little-endian */
)brace
r_else
id|len
op_assign
id|min
c_func
(paren
id|snamlen
comma
id|DTLHDRDATALEN_LEGACY
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dlh
comma
id|slh
comma
l_int|6
op_plus
id|len
op_star
l_int|2
)paren
suffix:semicolon
id|next
op_assign
id|slh-&gt;next
suffix:semicolon
multiline_comment|/* update dst head/only segment next field */
id|dsi
op_increment
suffix:semicolon
id|dlh-&gt;next
op_assign
id|dsi
suffix:semicolon
)brace
r_else
(brace
id|sih
op_assign
(paren
id|idtentry_t
op_star
)paren
id|s
suffix:semicolon
id|snamlen
op_assign
id|sih-&gt;namlen
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|snamlen
comma
id|DTIHDRDATALEN
)paren
suffix:semicolon
id|dih
op_assign
(paren
id|idtentry_t
op_star
)paren
id|h
suffix:semicolon
id|memcpy
c_func
(paren
id|dih
comma
id|sih
comma
l_int|10
op_plus
id|len
op_star
l_int|2
)paren
suffix:semicolon
id|next
op_assign
id|sih-&gt;next
suffix:semicolon
id|dsi
op_increment
suffix:semicolon
id|dih-&gt;next
op_assign
id|dsi
suffix:semicolon
)brace
multiline_comment|/* free src head/only segment */
id|s-&gt;next
op_assign
id|sfsi
suffix:semicolon
id|s-&gt;cnt
op_assign
l_int|1
suffix:semicolon
id|sfsi
op_assign
id|ssi
suffix:semicolon
id|ns
op_increment
suffix:semicolon
id|nd
op_increment
suffix:semicolon
id|xssi
op_assign
id|ssi
suffix:semicolon
multiline_comment|/*&n;&t;&t; * move additional segment(s) of the entry&n;&t;&t; */
id|snamlen
op_sub_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ssi
op_assign
id|next
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* is next slot contiguous ? */
r_if
c_cond
(paren
id|ssi
op_ne
id|xssi
op_plus
l_int|1
)paren
(brace
multiline_comment|/* close current linelock */
id|slv-&gt;length
op_assign
id|ns
suffix:semicolon
id|sdtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|sdtlck-&gt;index
OL
id|sdtlck-&gt;maxcnt
)paren
id|slv
op_increment
suffix:semicolon
r_else
(brace
id|sdtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|sdtlck
)paren
suffix:semicolon
id|slv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|sdtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|slv-&gt;offset
op_assign
id|ssi
suffix:semicolon
id|ns
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get next source segment */
id|s
op_assign
op_amp
id|sp-&gt;slot
(braket
id|ssi
)braket
suffix:semicolon
multiline_comment|/* get next destination free slot */
id|d
op_increment
suffix:semicolon
id|len
op_assign
id|min
c_func
(paren
id|snamlen
comma
id|DTSLOTDATALEN
)paren
suffix:semicolon
id|UniStrncpy
c_func
(paren
id|d-&gt;name
comma
id|s-&gt;name
comma
id|len
)paren
suffix:semicolon
id|ns
op_increment
suffix:semicolon
id|nd
op_increment
suffix:semicolon
id|xssi
op_assign
id|ssi
suffix:semicolon
id|dsi
op_increment
suffix:semicolon
id|d-&gt;next
op_assign
id|dsi
suffix:semicolon
multiline_comment|/* free source segment */
id|next
op_assign
id|s-&gt;next
suffix:semicolon
id|s-&gt;next
op_assign
id|sfsi
suffix:semicolon
id|s-&gt;cnt
op_assign
l_int|1
suffix:semicolon
id|sfsi
op_assign
id|ssi
suffix:semicolon
id|snamlen
op_sub_assign
id|len
suffix:semicolon
)brace
multiline_comment|/* end while */
multiline_comment|/* terminate dst last/only segment */
r_if
c_cond
(paren
id|h
op_eq
id|d
)paren
(brace
multiline_comment|/* single segment entry */
r_if
c_cond
(paren
id|dp-&gt;header.flag
op_amp
id|BT_LEAF
)paren
id|dlh-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|dih-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/* multi-segment entry */
id|d-&gt;next
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end for */
multiline_comment|/* close current linelock */
id|slv-&gt;length
op_assign
id|ns
suffix:semicolon
id|sdtlck-&gt;index
op_increment
suffix:semicolon
op_star
id|sdtlock
op_assign
id|sdtlck
suffix:semicolon
id|dlv-&gt;length
op_assign
id|nd
suffix:semicolon
id|ddtlck-&gt;index
op_increment
suffix:semicolon
op_star
id|ddtlock
op_assign
id|ddtlck
suffix:semicolon
multiline_comment|/* update source header */
id|sp-&gt;header.freelist
op_assign
id|sfsi
suffix:semicolon
id|sp-&gt;header.freecnt
op_add_assign
id|nd
suffix:semicolon
multiline_comment|/* update destination header */
id|dp-&gt;header.nextindex
op_assign
id|di
suffix:semicolon
id|dp-&gt;header.freelist
op_assign
id|dsi
suffix:semicolon
id|dp-&gt;header.freecnt
op_sub_assign
id|nd
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtDeleteEntry()&n; *&n; * function: free a (leaf/internal) entry&n; *&n; * log freelist header, stbl, and each segment slot of entry&n; * (even though last/only segment next field is modified,&n; * physical image logging requires all segment slots of&n; * the entry logged to avoid applying previous updates&n; * to the same slots)&n; */
DECL|function|dtDeleteEntry
r_static
r_void
id|dtDeleteEntry
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|fi
comma
id|dtlock_t
op_star
op_star
id|dtlock
)paren
(brace
r_int
id|fsi
suffix:semicolon
multiline_comment|/* free entry slot index */
id|s8
op_star
id|stbl
suffix:semicolon
id|dtslot_t
op_star
id|t
suffix:semicolon
r_int
id|si
comma
id|freecnt
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
op_assign
op_star
id|dtlock
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
r_int
id|xsi
comma
id|n
suffix:semicolon
multiline_comment|/* get free entry slot index */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|fsi
op_assign
id|stbl
(braket
id|fi
)braket
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
id|fsi
suffix:semicolon
multiline_comment|/* get the head/only segment */
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
id|si
op_assign
(paren
(paren
id|ldtentry_t
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_else
id|si
op_assign
(paren
(paren
id|idtentry_t
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
id|t-&gt;next
op_assign
id|si
suffix:semicolon
id|t-&gt;cnt
op_assign
l_int|1
suffix:semicolon
id|n
op_assign
id|freecnt
op_assign
l_int|1
suffix:semicolon
id|xsi
op_assign
id|fsi
suffix:semicolon
multiline_comment|/* find the last/only segment */
r_while
c_loop
(paren
id|si
op_ge
l_int|0
)paren
(brace
multiline_comment|/* is next slot contiguous ? */
r_if
c_cond
(paren
id|si
op_ne
id|xsi
op_plus
l_int|1
)paren
(brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
OL
id|dtlck-&gt;maxcnt
)paren
id|lv
op_increment
suffix:semicolon
r_else
(brace
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|lv-&gt;offset
op_assign
id|si
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
)brace
id|n
op_increment
suffix:semicolon
id|xsi
op_assign
id|si
suffix:semicolon
id|freecnt
op_increment
suffix:semicolon
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|t-&gt;cnt
op_assign
l_int|1
suffix:semicolon
id|si
op_assign
id|t-&gt;next
suffix:semicolon
)brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
op_star
id|dtlock
op_assign
id|dtlck
suffix:semicolon
multiline_comment|/* update freelist */
id|t-&gt;next
op_assign
id|p-&gt;header.freelist
suffix:semicolon
id|p-&gt;header.freelist
op_assign
id|fsi
suffix:semicolon
id|p-&gt;header.freecnt
op_add_assign
id|freecnt
suffix:semicolon
multiline_comment|/* if delete from middle,&n;&t; * shift left the succedding entries in the stbl&n;&t; */
id|si
op_assign
id|p-&gt;header.nextindex
suffix:semicolon
r_if
c_cond
(paren
id|fi
OL
id|si
op_minus
l_int|1
)paren
id|memmove
c_func
(paren
op_amp
id|stbl
(braket
id|fi
)braket
comma
op_amp
id|stbl
(braket
id|fi
op_plus
l_int|1
)braket
comma
id|si
op_minus
id|fi
op_minus
l_int|1
)paren
suffix:semicolon
id|p-&gt;header.nextindex
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtTruncateEntry()&n; *&n; * function: truncate a (leaf/internal) entry&n; *&n; * log freelist header, stbl, and each segment slot of entry&n; * (even though last/only segment next field is modified,&n; * physical image logging requires all segment slots of&n; * the entry logged to avoid applying previous updates&n; * to the same slots)&n; */
DECL|function|dtTruncateEntry
r_static
r_void
id|dtTruncateEntry
c_func
(paren
id|dtpage_t
op_star
id|p
comma
r_int
id|ti
comma
id|dtlock_t
op_star
op_star
id|dtlock
)paren
(brace
r_int
id|tsi
suffix:semicolon
multiline_comment|/* truncate entry slot index */
id|s8
op_star
id|stbl
suffix:semicolon
id|dtslot_t
op_star
id|t
suffix:semicolon
r_int
id|si
comma
id|freecnt
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
op_assign
op_star
id|dtlock
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
r_int
id|fsi
comma
id|xsi
comma
id|n
suffix:semicolon
multiline_comment|/* get free entry slot index */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|tsi
op_assign
id|stbl
(braket
id|ti
)braket
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
id|tsi
suffix:semicolon
multiline_comment|/* get the head/only segment */
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|tsi
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|p-&gt;header.flag
op_amp
id|BT_INTERNAL
)paren
suffix:semicolon
(paren
(paren
id|idtentry_t
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|namlen
op_assign
l_int|0
suffix:semicolon
id|si
op_assign
(paren
(paren
id|idtentry_t
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
(paren
(paren
id|idtentry_t
op_star
)paren
id|t
)paren
op_member_access_from_pointer
id|next
op_assign
op_minus
l_int|1
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|freecnt
op_assign
l_int|0
suffix:semicolon
id|fsi
op_assign
id|si
suffix:semicolon
id|xsi
op_assign
id|tsi
suffix:semicolon
multiline_comment|/* find the last/only segment */
r_while
c_loop
(paren
id|si
op_ge
l_int|0
)paren
(brace
multiline_comment|/* is next slot contiguous ? */
r_if
c_cond
(paren
id|si
op_ne
id|xsi
op_plus
l_int|1
)paren
(brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
OL
id|dtlck-&gt;maxcnt
)paren
id|lv
op_increment
suffix:semicolon
r_else
(brace
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|lv-&gt;offset
op_assign
id|si
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
)brace
id|n
op_increment
suffix:semicolon
id|xsi
op_assign
id|si
suffix:semicolon
id|freecnt
op_increment
suffix:semicolon
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|t-&gt;cnt
op_assign
l_int|1
suffix:semicolon
id|si
op_assign
id|t-&gt;next
suffix:semicolon
)brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
op_star
id|dtlock
op_assign
id|dtlck
suffix:semicolon
multiline_comment|/* update freelist */
r_if
c_cond
(paren
id|freecnt
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|t-&gt;next
op_assign
id|p-&gt;header.freelist
suffix:semicolon
id|p-&gt;header.freelist
op_assign
id|fsi
suffix:semicolon
id|p-&gt;header.freecnt
op_add_assign
id|freecnt
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtLinelockFreelist()&n; */
DECL|function|dtLinelockFreelist
r_static
r_void
id|dtLinelockFreelist
c_func
(paren
id|dtpage_t
op_star
id|p
comma
multiline_comment|/* directory page */
r_int
id|m
comma
multiline_comment|/* max slot index */
id|dtlock_t
op_star
op_star
id|dtlock
)paren
(brace
r_int
id|fsi
suffix:semicolon
multiline_comment|/* free entry slot index */
id|dtslot_t
op_star
id|t
suffix:semicolon
r_int
id|si
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
op_assign
op_star
id|dtlock
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
r_int
id|xsi
comma
id|n
suffix:semicolon
multiline_comment|/* get free entry slot index */
id|fsi
op_assign
id|p-&gt;header.freelist
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
op_ge
id|dtlck-&gt;maxcnt
)paren
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
id|dtlck-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
id|fsi
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|xsi
op_assign
id|fsi
suffix:semicolon
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|fsi
)braket
suffix:semicolon
id|si
op_assign
id|t-&gt;next
suffix:semicolon
multiline_comment|/* find the last/only segment */
r_while
c_loop
(paren
id|si
OL
id|m
op_logical_and
id|si
op_ge
l_int|0
)paren
(brace
multiline_comment|/* is next slot contiguous ? */
r_if
c_cond
(paren
id|si
op_ne
id|xsi
op_plus
l_int|1
)paren
(brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* open new linelock */
r_if
c_cond
(paren
id|dtlck-&gt;index
OL
id|dtlck-&gt;maxcnt
)paren
id|lv
op_increment
suffix:semicolon
r_else
(brace
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
id|txLinelock
c_func
(paren
id|dtlck
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|lv-&gt;offset
op_assign
id|si
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
)brace
id|n
op_increment
suffix:semicolon
id|xsi
op_assign
id|si
suffix:semicolon
id|t
op_assign
op_amp
id|p-&gt;slot
(braket
id|si
)braket
suffix:semicolon
id|si
op_assign
id|t-&gt;next
suffix:semicolon
)brace
multiline_comment|/* close current linelock */
id|lv-&gt;length
op_assign
id|n
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
op_star
id|dtlock
op_assign
id|dtlck
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME: dtModify&n; *&n; * FUNCTION: Modify the inode number part of a directory entry&n; *&n; * PARAMETERS:&n; *&t;tid&t;- Transaction id&n; *&t;ip&t;- Inode of parent directory&n; *&t;key&t;- Name of entry to be modified&n; *&t;orig_ino&t;- Original inode number expected in entry&n; *&t;new_ino&t;- New inode number to put into entry&n; *&t;flag&t;- JFS_RENAME&n; *&n; * RETURNS:&n; *&t;ESTALE&t;- If entry found does not match orig_ino passed in&n; *&t;ENOENT&t;- If no entry can be found to match key&n; *&t;0&t;- If successfully modified entry&n; */
DECL|function|dtModify
r_int
id|dtModify
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
comma
id|component_t
op_star
id|key
comma
id|ino_t
op_star
id|orig_ino
comma
id|ino_t
id|new_ino
comma
r_int
id|flag
)paren
(brace
r_int
id|rc
suffix:semicolon
id|s64
id|bn
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
r_int
id|index
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|dtlock_t
op_star
id|dtlck
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
id|s8
op_star
id|stbl
suffix:semicolon
r_int
id|entry_si
suffix:semicolon
multiline_comment|/* entry slot index */
id|ldtentry_t
op_star
id|entry
suffix:semicolon
multiline_comment|/*&n;&t; *      search for the entry to modify:&n;&t; *&n;&t; * dtSearch() returns (leaf page pinned, index at which to modify).&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dtSearch
c_func
(paren
id|ip
comma
id|key
comma
id|orig_ino
comma
op_amp
id|btstack
comma
id|flag
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* retrieve search result */
id|DT_GETSEARCH
c_func
(paren
id|ip
comma
id|btstack.top
comma
id|bn
comma
id|mp
comma
id|p
comma
id|index
)paren
suffix:semicolon
id|BT_MARK_DIRTY
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * acquire a transaction lock on the leaf page of named entry&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ip
comma
id|mp
comma
id|tlckDTREE
op_or
id|tlckENTRY
)paren
suffix:semicolon
id|dtlck
op_assign
(paren
id|dtlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/* get slot index of the entry */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|entry_si
op_assign
id|stbl
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* linelock entry */
id|ASSERT
c_func
(paren
id|dtlck-&gt;index
op_eq
l_int|0
)paren
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dtlck-&gt;lv
(braket
l_int|0
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
id|entry_si
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dtlck-&gt;index
op_increment
suffix:semicolon
multiline_comment|/* get the head/only segment */
id|entry
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|entry_si
)braket
suffix:semicolon
multiline_comment|/* substitute the inode number of the entry */
id|entry-&gt;inumber
op_assign
id|cpu_to_le32
c_func
(paren
id|new_ino
)paren
suffix:semicolon
multiline_comment|/* unpin the leaf page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef _JFS_DEBUG_DTREE
multiline_comment|/*&n; *&t;dtDisplayTree()&n; *&n; * function: traverse forward&n; */
DECL|function|dtDisplayTree
r_int
id|dtDisplayTree
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|rc
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|dtpage_t
op_star
id|p
suffix:semicolon
id|s64
id|bn
comma
id|pbn
suffix:semicolon
r_int
id|index
comma
id|lastindex
comma
id|v
comma
id|h
suffix:semicolon
id|pxd_t
op_star
id|xd
suffix:semicolon
id|btstack_t
id|btstack
suffix:semicolon
id|btframe_t
op_star
id|btsp
suffix:semicolon
id|btframe_t
op_star
id|parent
suffix:semicolon
id|u8
op_star
id|stbl
suffix:semicolon
r_int
id|psize
op_assign
l_int|256
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;display B+-tree.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* clear stack */
id|btsp
op_assign
id|btstack.stack
suffix:semicolon
multiline_comment|/*&n;&t; * start with root&n;&t; *&n;&t; * root resides in the inode&n;&t; */
id|bn
op_assign
l_int|0
suffix:semicolon
id|v
op_assign
id|h
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each page:&n;&t; */
id|newPage
suffix:colon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|psize
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* process entries forward from first index */
id|index
op_assign
l_int|0
suffix:semicolon
id|lastindex
op_assign
id|p-&gt;header.nextindex
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_INTERNAL
)paren
(brace
multiline_comment|/*&n;&t;&t; * first access of each internal page&n;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;internal page &quot;
)paren
suffix:semicolon
id|dtDisplayPage
c_func
(paren
id|ip
comma
id|bn
comma
id|p
)paren
suffix:semicolon
r_goto
id|getChild
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* (p-&gt;header.flag &amp; BT_LEAF) */
multiline_comment|/*&n;&t;&t; * first access of each leaf page&n;&t;&t; */
id|printf
c_func
(paren
l_string|&quot;leaf page &quot;
)paren
suffix:semicolon
id|dtDisplayPage
c_func
(paren
id|ip
comma
id|bn
comma
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * process leaf page entries&n;&t;&t; *&n;&t;&t; for ( ; index &lt;= lastindex; index++)&n;&t;&t; {&n;&t;&t; }&n;&t;&t; */
multiline_comment|/* unpin the leaf page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * go back up to the parent page&n;&t; */
id|getParent
suffix:colon
multiline_comment|/* pop/restore parent entry for the current child page */
r_if
c_cond
(paren
(paren
id|parent
op_assign
(paren
id|btsp
op_eq
id|btstack.stack
ques
c_cond
l_int|NULL
suffix:colon
op_decrement
id|btsp
)paren
)paren
op_eq
l_int|NULL
)paren
multiline_comment|/* current page must have been root */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * parent page scan completed&n;&t; */
r_if
c_cond
(paren
(paren
id|index
op_assign
id|parent-&gt;index
)paren
op_eq
(paren
id|lastindex
op_assign
id|parent-&gt;lastindex
)paren
)paren
(brace
multiline_comment|/* go back up to the parent page */
r_goto
id|getParent
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * parent page has entries remaining&n;&t; */
multiline_comment|/* get back the parent page */
id|bn
op_assign
id|parent-&gt;bn
suffix:semicolon
multiline_comment|/* v = parent-&gt;level; */
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* get next parent entry */
id|index
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * internal page: go down to child page of current entry&n;&t; */
id|getChild
suffix:colon
multiline_comment|/* push/save current parent entry for the child page */
id|btsp-&gt;bn
op_assign
id|pbn
op_assign
id|bn
suffix:semicolon
id|btsp-&gt;index
op_assign
id|index
suffix:semicolon
id|btsp-&gt;lastindex
op_assign
id|lastindex
suffix:semicolon
multiline_comment|/* btsp-&gt;level = v; */
multiline_comment|/* btsp-&gt;node = h; */
op_increment
id|btsp
suffix:semicolon
multiline_comment|/* get current entry for the child page */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
id|xd
op_assign
(paren
id|pxd_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|index
)braket
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * first access of each internal entry:&n;&t; */
multiline_comment|/* get child page */
id|bn
op_assign
id|addressPXD
c_func
(paren
id|xd
)paren
suffix:semicolon
id|psize
op_assign
id|lengthPXD
c_func
(paren
id|xd
)paren
op_lshift
id|ip-&gt;i_ipmnt-&gt;i_l2bsize
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;traverse down 0x%Lx[%d]-&gt;0x%Lx&bslash;n&quot;
comma
id|pbn
comma
id|index
comma
id|bn
)paren
suffix:semicolon
id|v
op_increment
suffix:semicolon
id|h
op_assign
id|index
suffix:semicolon
multiline_comment|/* release parent page */
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* process the child page */
r_goto
id|newPage
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;dtDisplayPage()&n; *&n; * function: display page&n; */
DECL|function|dtDisplayPage
r_int
id|dtDisplayPage
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|bn
comma
id|dtpage_t
op_star
id|p
)paren
(brace
r_int
id|rc
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|ldtentry_t
op_star
id|lh
suffix:semicolon
id|idtentry_t
op_star
id|ih
suffix:semicolon
id|pxd_t
op_star
id|xd
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|u8
op_star
id|stbl
suffix:semicolon
m_wchar_t
id|name
(braket
id|JFS_NAME_MAX
op_plus
l_int|1
)braket
suffix:semicolon
id|component_t
id|key
op_assign
(brace
l_int|0
comma
id|name
)brace
suffix:semicolon
r_int
id|freepage
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
id|freepage
op_assign
l_int|1
suffix:semicolon
id|DT_GETPAGE
c_func
(paren
id|ip
comma
id|bn
comma
id|mp
comma
id|PSIZE
comma
id|p
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* display page control */
id|printk
c_func
(paren
l_string|&quot;bn:0x%Lx flag:0x%08x nextindex:%d&bslash;n&quot;
comma
id|bn
comma
id|p-&gt;header.flag
comma
id|p-&gt;header.nextindex
)paren
suffix:semicolon
multiline_comment|/* display entries */
id|stbl
op_assign
id|DT_GETSTBL
c_func
(paren
id|p
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|p-&gt;header.nextindex
suffix:semicolon
id|i
op_increment
comma
id|j
op_increment
)paren
(brace
id|dtGetKey
c_func
(paren
id|p
comma
id|i
comma
op_amp
id|key
comma
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|mntflag
)paren
suffix:semicolon
id|key.name
(braket
id|key.namlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;header.flag
op_amp
id|BT_LEAF
)paren
(brace
id|lh
op_assign
(paren
id|ldtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|i
)braket
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t[%d] %s:%d&quot;
comma
id|i
comma
id|key.name
comma
id|le32_to_cpu
c_func
(paren
id|lh-&gt;inumber
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ih
op_assign
(paren
id|idtentry_t
op_star
)paren
op_amp
id|p-&gt;slot
(braket
id|stbl
(braket
id|i
)braket
)braket
suffix:semicolon
id|xd
op_assign
(paren
id|pxd_t
op_star
)paren
id|ih
suffix:semicolon
id|bn
op_assign
id|addressPXD
c_func
(paren
id|xd
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t[%d] %s:0x%Lx&quot;
comma
id|i
comma
id|key.name
comma
id|bn
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_eq
l_int|4
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|freepage
)paren
id|DT_PUTPAGE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_DEBUG_DTREE */
eof
