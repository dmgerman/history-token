multiline_comment|/*&n; *   Copyright (c) International Business Machines Corp., 2000-2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_dmap.h&quot;
macro_line|#include &quot;jfs_extent.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/*&n; * forward references&n; */
r_static
r_int
id|extBalloc
c_func
(paren
r_struct
id|inode
op_star
comma
id|s64
comma
id|s64
op_star
comma
id|s64
op_star
)paren
suffix:semicolon
r_static
r_int
id|extBrealloc
c_func
(paren
r_struct
id|inode
op_star
comma
id|s64
comma
id|s64
comma
id|s64
op_star
comma
id|s64
op_star
)paren
suffix:semicolon
r_int
id|extRecord
c_func
(paren
r_struct
id|inode
op_star
comma
id|xad_t
op_star
)paren
suffix:semicolon
r_static
id|s64
id|extRoundDown
c_func
(paren
id|s64
id|nb
)paren
suffix:semicolon
multiline_comment|/*&n; * external references&n; */
r_extern
r_int
id|dbExtend
c_func
(paren
r_struct
id|inode
op_star
comma
id|s64
comma
id|s64
comma
id|s64
)paren
suffix:semicolon
r_extern
r_int
id|jfs_commit_inode
c_func
(paren
r_struct
id|inode
op_star
comma
r_int
)paren
suffix:semicolon
DECL|macro|DPD
mdefine_line|#define DPD(a)          (printk(&quot;(a): %d&bslash;n&quot;,(a)))
DECL|macro|DPC
mdefine_line|#define DPC(a)          (printk(&quot;(a): %c&bslash;n&quot;,(a)))
DECL|macro|DPL1
mdefine_line|#define DPL1(a)&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((a) &gt;&gt; 32)&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;(a): %x%08x  &quot;,(a));&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;(a): %x  &quot;,(a) &lt;&lt; 32);&t;&bslash;&n;}
DECL|macro|DPL
mdefine_line|#define DPL(a)&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((a) &gt;&gt; 32)&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;(a): %x%08x&bslash;n&quot;,(a));&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;(a): %x&bslash;n&quot;,(a) &lt;&lt; 32);&t;&bslash;&n;}
DECL|macro|DPD1
mdefine_line|#define DPD1(a)         (printk(&quot;(a): %d  &quot;,(a)))
DECL|macro|DPX
mdefine_line|#define DPX(a)          (printk(&quot;(a): %08x&bslash;n&quot;,(a)))
DECL|macro|DPX1
mdefine_line|#define DPX1(a)         (printk(&quot;(a): %08x  &quot;,(a)))
DECL|macro|DPS
mdefine_line|#define DPS(a)          (printk(&quot;%s&bslash;n&quot;,(a)))
DECL|macro|DPE
mdefine_line|#define DPE(a)          (printk(&quot;&bslash;nENTERING: %s&bslash;n&quot;,(a)))
DECL|macro|DPE1
mdefine_line|#define DPE1(a)          (printk(&quot;&bslash;nENTERING: %s&quot;,(a)))
DECL|macro|DPS1
mdefine_line|#define DPS1(a)         (printk(&quot;  %s  &quot;,(a)))
multiline_comment|/*&n; * NAME:&t;extAlloc()&n; *&n; * FUNCTION:    allocate an extent for a specified page range within a&n; *&t;&t;file.&n; *&n; * PARAMETERS:&n; *&t;ip&t;- the inode of the file.&n; *&t;xlen&t;- requested extent length.&n; *&t;pno&t;- the starting page number with the file.&n; *&t;xp&t;- pointer to an xad.  on entry, xad describes an&n; *&t;&t;  extent that is used as an allocation hint if the&n; *&t;&t;  xaddr of the xad is non-zero.  on successful exit,&n; *&t;&t;  the xad describes the newly allocated extent.&n; *&t;abnr&t;- boolean_t indicating whether the newly allocated extent&n; *&t;&t;  should be marked as allocated but not recorded.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO&t;- i/o error.&n; *      ENOSPC&t;- insufficient disk resources.&n; */
r_int
DECL|function|extAlloc
id|extAlloc
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|xlen
comma
id|s64
id|pno
comma
id|xad_t
op_star
id|xp
comma
id|boolean_t
id|abnr
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
id|s64
id|nxlen
comma
id|nxaddr
comma
id|xoff
comma
id|hint
comma
id|xaddr
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
comma
id|nbperpage
suffix:semicolon
r_int
id|xflag
suffix:semicolon
multiline_comment|/* This blocks if we are low on resources */
id|txBeginAnon
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* validate extent length */
r_if
c_cond
(paren
id|xlen
OG
id|MAXXLEN
)paren
id|xlen
op_assign
id|MAXXLEN
suffix:semicolon
multiline_comment|/* get the number of blocks per page */
id|nbperpage
op_assign
id|sbi-&gt;nbperpage
suffix:semicolon
multiline_comment|/* get the page&squot;s starting extent offset */
id|xoff
op_assign
id|pno
op_lshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
multiline_comment|/* check if an allocation hint was provided */
r_if
c_cond
(paren
(paren
id|hint
op_assign
id|addressXAD
c_func
(paren
id|xp
)paren
)paren
)paren
(brace
multiline_comment|/* get the size of the extent described by the hint */
id|nxlen
op_assign
id|lengthXAD
c_func
(paren
id|xp
)paren
suffix:semicolon
multiline_comment|/* check if the hint is for the portion of the file&n;&t;&t; * immediately previous to the current allocation&n;&t;&t; * request and if hint extent has the same abnr&n;&t;&t; * value as the current request.  if so, we can&n;&t;&t; * extend the hint extent to include the current&n;&t;&t; * extent if we can allocate the blocks immediately&n;&t;&t; * following the hint extent.&n;&t;&t; */
r_if
c_cond
(paren
id|offsetXAD
c_func
(paren
id|xp
)paren
op_plus
id|nxlen
op_eq
id|xoff
op_logical_and
id|abnr
op_eq
(paren
(paren
id|xp-&gt;flag
op_amp
id|XAD_NOTRECORDED
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
)paren
id|xaddr
op_assign
id|hint
op_plus
id|nxlen
suffix:semicolon
multiline_comment|/* adjust the hint to the last block of the extent */
id|hint
op_add_assign
(paren
id|nxlen
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* allocate the disk blocks for the extent.  initially, extBalloc()&n;&t; * will try to allocate disk blocks for the requested size (xlen). &n;&t; * if this fails (xlen contigious free blocks not avaliable), it&squot;ll&n;&t; * try to allocate a smaller number of blocks (producing a smaller&n;&t; * extent), with this smaller number of blocks consisting of the&n;&t; * requested number of blocks rounded down to the next smaller&n;&t; * power of 2 number (i.e. 16 -&gt; 8).  it&squot;ll continue to round down&n;&t; * and retry the allocation until the number of blocks to allocate&n;&t; * is smaller than the number of blocks per page.&n;&t; */
id|nxlen
op_assign
id|xlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|extBalloc
c_func
(paren
id|ip
comma
id|hint
ques
c_cond
id|hint
suffix:colon
id|INOHINT
c_func
(paren
id|ip
)paren
comma
op_amp
id|nxlen
comma
op_amp
id|nxaddr
)paren
)paren
)paren
(brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* determine the value of the extent flag */
id|xflag
op_assign
(paren
id|abnr
op_eq
id|TRUE
)paren
ques
c_cond
id|XAD_NOTRECORDED
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* if we can extend the hint extent to cover the current request, &n;&t; * extend it.  otherwise, insert a new extent to&n;&t; * cover the current request.&n;&t; */
r_if
c_cond
(paren
id|xaddr
op_logical_and
id|xaddr
op_eq
id|nxaddr
)paren
id|rc
op_assign
id|xtExtend
c_func
(paren
l_int|0
comma
id|ip
comma
id|xoff
comma
(paren
r_int
)paren
id|nxlen
comma
l_int|0
)paren
suffix:semicolon
r_else
id|rc
op_assign
id|xtInsert
c_func
(paren
l_int|0
comma
id|ip
comma
id|xflag
comma
id|xoff
comma
(paren
r_int
)paren
id|nxlen
comma
op_amp
id|nxaddr
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* if the extend or insert failed, &n;&t; * free the newly allocated blocks and return the error.&n;&t; */
r_if
c_cond
(paren
id|rc
)paren
(brace
id|dbFree
c_func
(paren
id|ip
comma
id|nxaddr
comma
id|nxlen
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* update the number of blocks allocated to the file */
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|nxlen
)paren
suffix:semicolon
multiline_comment|/* set the results of the extent allocation */
id|XADaddress
c_func
(paren
id|xp
comma
id|nxaddr
)paren
suffix:semicolon
id|XADlength
c_func
(paren
id|xp
comma
id|nxlen
)paren
suffix:semicolon
id|XADoffset
c_func
(paren
id|xp
comma
id|xoff
)paren
suffix:semicolon
id|xp-&gt;flag
op_assign
id|xflag
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * COMMIT_SyncList flags an anonymous tlock on page that is on&n;&t; * sync list.&n;&t; * We need to commit the inode to get the page written disk.&n;&t; */
r_if
c_cond
(paren
id|test_and_clear_cflag
c_func
(paren
id|COMMIT_Synclist
comma
id|ip
)paren
)paren
id|jfs_commit_inode
c_func
(paren
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        extRealloc()&n; *&n; * FUNCTION:    extend the allocation of a file extent containing a&n; *&t;&t;partial back last page.&n; *&n; * PARAMETERS:&n; *&t;ip&t;- the inode of the file.&n; *&t;cp&t;- cbuf for the partial backed last page.&n; *&t;xlen&t;- request size of the resulting extent.&n; *&t;xp&t;- pointer to an xad. on successful exit, the xad&n; *&t;&t;  describes the newly allocated extent.&n; *&t;abnr&t;- boolean_t indicating whether the newly allocated extent&n; *&t;&t;  should be marked as allocated but not recorded.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO&t;- i/o error.&n; *      ENOSPC&t;- insufficient disk resources.&n; */
DECL|function|extRealloc
r_int
id|extRealloc
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|nxlen
comma
id|xad_t
op_star
id|xp
comma
id|boolean_t
id|abnr
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
id|s64
id|xaddr
comma
id|xlen
comma
id|nxaddr
comma
id|delta
comma
id|xoff
suffix:semicolon
id|s64
id|ntail
comma
id|nextend
comma
id|ninsert
suffix:semicolon
r_int
id|rc
comma
id|nbperpage
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|nbperpage
suffix:semicolon
r_int
id|xflag
suffix:semicolon
multiline_comment|/* This blocks if we are low on resources */
id|txBeginAnon
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* validate extent length */
r_if
c_cond
(paren
id|nxlen
OG
id|MAXXLEN
)paren
id|nxlen
op_assign
id|MAXXLEN
suffix:semicolon
multiline_comment|/* get the extend (partial) page&squot;s disk block address and&n;&t; * number of blocks.&n;&t; */
id|xaddr
op_assign
id|addressXAD
c_func
(paren
id|xp
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthXAD
c_func
(paren
id|xp
)paren
suffix:semicolon
id|xoff
op_assign
id|offsetXAD
c_func
(paren
id|xp
)paren
suffix:semicolon
multiline_comment|/* if the extend page is abnr and if the request is for&n;&t; * the extent to be allocated and recorded, &n;&t; * make the page allocated and recorded.&n;&t; */
r_if
c_cond
(paren
(paren
id|xp-&gt;flag
op_amp
id|XAD_NOTRECORDED
)paren
op_logical_and
op_logical_neg
id|abnr
)paren
(brace
id|xp-&gt;flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtUpdate
c_func
(paren
l_int|0
comma
id|ip
comma
id|xp
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* try to allocated the request number of blocks for the&n;&t; * extent.  dbRealloc() first tries to satisfy the request&n;&t; * by extending the allocation in place. otherwise, it will&n;&t; * try to allocate a new set of blocks large enough for the&n;&t; * request.  in satisfying a request, dbReAlloc() may allocate&n;&t; * less than what was request but will always allocate enough&n;&t; * space as to satisfy the extend page.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|extBrealloc
c_func
(paren
id|ip
comma
id|xaddr
comma
id|xlen
comma
op_amp
id|nxlen
comma
op_amp
id|nxaddr
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
id|delta
op_assign
id|nxlen
op_minus
id|xlen
suffix:semicolon
multiline_comment|/* check if the extend page is not abnr but the request is abnr&n;&t; * and the allocated disk space is for more than one page.  if this&n;&t; * is the case, there is a miss match of abnr between the extend page&n;&t; * and the one or more pages following the extend page.  as a result,&n;&t; * two extents will have to be manipulated. the first will be that&n;&t; * of the extent of the extend page and will be manipulated thru&n;&t; * an xtExtend() or an xtTailgate(), depending upon whether the&n;&t; * disk allocation occurred as an inplace extension.  the second&n;&t; * extent will be manipulated (created) through an xtInsert() and&n;&t; * will be for the pages following the extend page.&n;&t; */
r_if
c_cond
(paren
id|abnr
op_logical_and
(paren
op_logical_neg
(paren
id|xp-&gt;flag
op_amp
id|XAD_NOTRECORDED
)paren
)paren
op_logical_and
(paren
id|nxlen
OG
id|nbperpage
)paren
)paren
(brace
id|ntail
op_assign
id|nbperpage
suffix:semicolon
id|nextend
op_assign
id|ntail
op_minus
id|xlen
suffix:semicolon
id|ninsert
op_assign
id|nxlen
op_minus
id|nbperpage
suffix:semicolon
id|xflag
op_assign
id|XAD_NOTRECORDED
suffix:semicolon
)brace
r_else
(brace
id|ntail
op_assign
id|nxlen
suffix:semicolon
id|nextend
op_assign
id|delta
suffix:semicolon
id|ninsert
op_assign
l_int|0
suffix:semicolon
id|xflag
op_assign
id|xp-&gt;flag
suffix:semicolon
)brace
multiline_comment|/* if we were able to extend the disk allocation in place,&n;&t; * extend the extent.  otherwise, move the extent to a&n;&t; * new disk location.&n;&t; */
r_if
c_cond
(paren
id|xaddr
op_eq
id|nxaddr
)paren
(brace
multiline_comment|/* extend the extent */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtExtend
c_func
(paren
l_int|0
comma
id|ip
comma
id|xoff
op_plus
id|xlen
comma
(paren
r_int
)paren
id|nextend
comma
l_int|0
)paren
)paren
)paren
(brace
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
op_plus
id|xlen
comma
id|delta
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * move the extent to a new location:&n;&t;&t; *&n;&t;&t; * xtTailgate() accounts for relocated tail extent;&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtTailgate
c_func
(paren
l_int|0
comma
id|ip
comma
id|xoff
comma
(paren
r_int
)paren
id|ntail
comma
id|nxaddr
comma
l_int|0
)paren
)paren
)paren
(brace
id|dbFree
c_func
(paren
id|ip
comma
id|nxaddr
comma
id|nxlen
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* check if we need to also insert a new extent */
r_if
c_cond
(paren
id|ninsert
)paren
(brace
multiline_comment|/* perform the insert.  if it fails, free the blocks&n;&t;&t; * to be inserted and make it appear that we only did&n;&t;&t; * the xtExtend() or xtTailgate() above.&n;&t;&t; */
id|xaddr
op_assign
id|nxaddr
op_plus
id|ntail
suffix:semicolon
r_if
c_cond
(paren
id|xtInsert
(paren
l_int|0
comma
id|ip
comma
id|xflag
comma
id|xoff
op_plus
id|ntail
comma
(paren
r_int
)paren
id|ninsert
comma
op_amp
id|xaddr
comma
l_int|0
)paren
)paren
(brace
id|dbFree
c_func
(paren
id|ip
comma
id|xaddr
comma
(paren
id|s64
)paren
id|ninsert
)paren
suffix:semicolon
id|delta
op_assign
id|nextend
suffix:semicolon
id|nxlen
op_assign
id|ntail
suffix:semicolon
id|xflag
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* update the inode with the number of blocks allocated */
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|sb
comma
id|delta
)paren
suffix:semicolon
multiline_comment|/* set the return results */
id|XADaddress
c_func
(paren
id|xp
comma
id|nxaddr
)paren
suffix:semicolon
id|XADlength
c_func
(paren
id|xp
comma
id|nxlen
)paren
suffix:semicolon
id|XADoffset
c_func
(paren
id|xp
comma
id|xoff
)paren
suffix:semicolon
id|xp-&gt;flag
op_assign
id|xflag
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        extHint()&n; *&n; * FUNCTION:    produce an extent allocation hint for a file offset.&n; *&n; * PARAMETERS:&n; *&t;ip&t;- the inode of the file.&n; *&t;offset  - file offset for which the hint is needed.&n; *&t;xp&t;- pointer to the xad that is to be filled in with&n; *&t;&t;  the hint.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO&t;- i/o error.&n; */
DECL|function|extHint
r_int
id|extHint
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|offset
comma
id|xad_t
op_star
id|xp
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
id|xadlist_t
id|xadl
suffix:semicolon
id|lxdlist_t
id|lxdl
suffix:semicolon
id|lxd_t
id|lxd
suffix:semicolon
id|s64
id|prev
suffix:semicolon
r_int
id|rc
comma
id|nbperpage
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|nbperpage
suffix:semicolon
multiline_comment|/* init the hint as &quot;no hint provided&quot; */
id|XADaddress
c_func
(paren
id|xp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* determine the starting extent offset of the page previous&n;&t; * to the page containing the offset.&n;&t; */
id|prev
op_assign
(paren
(paren
id|offset
op_amp
op_complement
id|POFFSET
)paren
op_rshift
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|l2bsize
)paren
op_minus
id|nbperpage
suffix:semicolon
multiline_comment|/* if the offsets in the first page of the file,&n;&t; * no hint provided.&n;&t; */
r_if
c_cond
(paren
id|prev
OL
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* prepare to lookup the previous page&squot;s extent info */
id|lxdl.maxnlxd
op_assign
l_int|1
suffix:semicolon
id|lxdl.nlxd
op_assign
l_int|1
suffix:semicolon
id|lxdl.lxd
op_assign
op_amp
id|lxd
suffix:semicolon
id|LXDoffset
c_func
(paren
op_amp
id|lxd
comma
id|prev
)paren
id|LXDlength
c_func
(paren
op_amp
id|lxd
comma
id|nbperpage
)paren
suffix:semicolon
id|xadl.maxnxad
op_assign
l_int|1
suffix:semicolon
id|xadl.nxad
op_assign
l_int|0
suffix:semicolon
id|xadl.xad
op_assign
id|xp
suffix:semicolon
multiline_comment|/* perform the lookup */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtLookupList
c_func
(paren
id|ip
comma
op_amp
id|lxdl
comma
op_amp
id|xadl
comma
l_int|0
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
multiline_comment|/* check if not extent exists for the previous page.  &n;&t; * this is possible for sparse files.&n;&t; */
r_if
c_cond
(paren
id|xadl.nxad
op_eq
l_int|0
)paren
(brace
singleline_comment|//              assert(ISSPARSE(ip));
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* only preserve the abnr flag within the xad flags&n;&t; * of the returned hint.&n;&t; */
id|xp-&gt;flag
op_and_assign
id|XAD_NOTRECORDED
suffix:semicolon
m_assert
(paren
id|xadl.nxad
op_eq
l_int|1
)paren
suffix:semicolon
m_assert
(paren
id|lengthXAD
c_func
(paren
id|xp
)paren
op_eq
id|nbperpage
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        extRecord()&n; *&n; * FUNCTION:    change a page with a file from not recorded to recorded.&n; *&n; * PARAMETERS:&n; *&t;ip&t;- inode of the file.&n; *&t;cp&t;- cbuf of the file page.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO&t;- i/o error.&n; *      ENOSPC&t;- insufficient disk resources.&n; */
DECL|function|extRecord
r_int
id|extRecord
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|xad_t
op_star
id|xp
)paren
(brace
r_int
id|rc
suffix:semicolon
id|txBeginAnon
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
multiline_comment|/* update the extent */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtUpdate
c_func
(paren
l_int|0
comma
id|ip
comma
id|xp
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/* no longer abnr */
id|cp-&gt;cm_abnr
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* mark the cbuf as modified */
id|cp-&gt;cm_modified
op_assign
id|TRUE
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        extFill()&n; *&n; * FUNCTION:    allocate disk space for a file page that represents&n; *&t;&t;a file hole.&n; *&n; * PARAMETERS:&n; *&t;ip&t;- the inode of the file.&n; *&t;cp&t;- cbuf of the file page represent the hole.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO&t;- i/o error.&n; *      ENOSPC&t;- insufficient disk resources.&n; */
DECL|function|extFill
r_int
id|extFill
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|xad_t
op_star
id|xp
)paren
(brace
r_int
id|rc
comma
id|nbperpage
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
suffix:semicolon
id|s64
id|blkno
op_assign
id|offsetXAD
c_func
(paren
id|xp
)paren
op_rshift
id|ip-&gt;i_blksize
suffix:semicolon
singleline_comment|//      assert(ISSPARSE(ip));
multiline_comment|/* initialize the extent allocation hint */
id|XADaddress
c_func
(paren
id|xp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* allocate an extent to fill the hole */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|extAlloc
c_func
(paren
id|ip
comma
id|nbperpage
comma
id|blkno
comma
id|xp
comma
id|FALSE
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
m_assert
(paren
id|lengthPXD
c_func
(paren
id|xp
)paren
op_eq
id|nbperpage
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;extBalloc()&n; *&n; * FUNCTION:    allocate disk blocks to form an extent.&n; *&n; *&t;&t;initially, we will try to allocate disk blocks for the&n; *&t;&t;requested size (nblocks).  if this fails (nblocks &n; *&t;&t;contigious free blocks not avaliable), we&squot;ll try to allocate&n; *&t;&t;a smaller number of blocks (producing a smaller extent), with&n; *&t;&t;this smaller number of blocks consisting of the requested&n; *&t;&t;number of blocks rounded down to the next smaller power of 2&n; *&t;&t;number (i.e. 16 -&gt; 8).  we&squot;ll continue to round down and&n; *&t;&t;retry the allocation until the number of blocks to allocate&n; *&t;&t;is smaller than the number of blocks per page.&n; *&t;&t;&n; * PARAMETERS:&n; *&t;ip&t; - the inode of the file.&n; *&t;hint&t; - disk block number to be used as an allocation hint.&n; *&t;*nblocks - pointer to an s64 value.  on entry, this value specifies&n; *&t;&t;   the desired number of block to be allocated. on successful&n; *&t;&t;   exit, this value is set to the number of blocks actually&n; *&t;&t;   allocated.&n; *&t;blkno&t; - pointer to a block address that is filled in on successful&n; *&t;&t;   return with the starting block number of the newly &n; *&t;&t;   allocated block range.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO&t;- i/o error.&n; *      ENOSPC&t;- insufficient disk resources.&n; */
r_static
r_int
DECL|function|extBalloc
id|extBalloc
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|hint
comma
id|s64
op_star
id|nblocks
comma
id|s64
op_star
id|blkno
)paren
(brace
id|s64
id|nb
comma
id|nblks
comma
id|daddr
comma
id|max
suffix:semicolon
r_int
id|rc
comma
id|nbperpage
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|nbperpage
suffix:semicolon
id|bmap_t
op_star
id|mp
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
multiline_comment|/* get the number of blocks to initially attempt to allocate.&n;&t; * we&squot;ll first try the number of blocks requested unless this&n;&t; * number is greater than the maximum number of contigious free&n;&t; * blocks in the map. in that case, we&squot;ll start off with the &n;&t; * maximum free.&n;&t; */
id|max
op_assign
(paren
id|s64
)paren
l_int|1
op_lshift
id|mp-&gt;db_maxfreebud
suffix:semicolon
r_if
c_cond
(paren
op_star
id|nblocks
op_ge
id|max
op_logical_and
op_star
id|nblocks
OG
id|nbperpage
)paren
id|nb
op_assign
id|nblks
op_assign
(paren
id|max
OG
id|nbperpage
)paren
ques
c_cond
id|max
suffix:colon
id|nbperpage
suffix:semicolon
r_else
id|nb
op_assign
id|nblks
op_assign
op_star
id|nblocks
suffix:semicolon
multiline_comment|/* try to allocate blocks */
r_while
c_loop
(paren
(paren
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ip
comma
id|hint
comma
id|nb
comma
op_amp
id|daddr
)paren
)paren
)paren
(brace
multiline_comment|/* if something other than an out of space error,&n;&t;&t; * stop and return this error.&n;&t;&t; */
r_if
c_cond
(paren
id|rc
op_ne
id|ENOSPC
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
multiline_comment|/* decrease the allocation request size */
id|nb
op_assign
id|min
c_func
(paren
id|nblks
comma
id|extRoundDown
c_func
(paren
id|nb
)paren
)paren
suffix:semicolon
multiline_comment|/* give up if we cannot cover a page */
r_if
c_cond
(paren
id|nb
OL
id|nbperpage
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
op_star
id|nblocks
op_assign
id|nb
suffix:semicolon
op_star
id|blkno
op_assign
id|daddr
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;extBrealloc()&n; *&n; * FUNCTION:    attempt to extend an extent&squot;s allocation.&n; *&n; *&t;&t;initially, we will try to extend the extent&squot;s allocation&n; *&t;&t;in place.  if this fails, we&squot;ll try to move the extent&n; *&t;&t;to a new set of blocks. if moving the extent, we initially&n; *&t;&t;will try to allocate disk blocks for the requested size&n; *&t;&t;(nnew).  if this fails &t;(nnew contigious free blocks not&n; *&t;&t;avaliable), we&squot;ll try  to allocate a smaller number of&n; *&t;&t;blocks (producing a smaller extent), with this smaller&n; *&t;&t;number of blocks consisting of the requested number of&n; *&t;&t;blocks rounded down to the next smaller power of 2&n; *&t;&t;number (i.e. 16 -&gt; 8).  we&squot;ll continue to round down and&n; *&t;&t;retry the allocation until the number of blocks to allocate&n; *&t;&t;is smaller than the number of blocks per page.&n; *&t;&t;&n; * PARAMETERS:&n; *&t;ip&t; - the inode of the file.&n; *&t;blkno    - starting block number of the extents current allocation.&n; *&t;nblks    - number of blocks within the extents current allocation.&n; *&t;newnblks - pointer to a s64 value.  on entry, this value is the&n; *&t;&t;   the new desired extent size (number of blocks).  on&n; *&t;&t;   successful exit, this value is set to the extent&squot;s actual&n; *&t;&t;   new size (new number of blocks).&n; *&t;newblkno - the starting block number of the extents new allocation.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO&t;- i/o error.&n; *      ENOSPC&t;- insufficient disk resources.&n; */
r_static
r_int
DECL|function|extBrealloc
id|extBrealloc
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|s64
id|blkno
comma
id|s64
id|nblks
comma
id|s64
op_star
id|newnblks
comma
id|s64
op_star
id|newblkno
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* try to extend in place */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbExtend
c_func
(paren
id|ip
comma
id|blkno
comma
id|nblks
comma
op_star
id|newnblks
op_minus
id|nblks
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|newblkno
op_assign
id|blkno
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rc
op_ne
id|ENOSPC
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* in place extension not possible.  &n;&t; * try to move the extent to a new set of blocks.&n;&t; */
r_return
(paren
id|extBalloc
c_func
(paren
id|ip
comma
id|blkno
comma
id|newnblks
comma
id|newblkno
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        extRoundDown()&n; *&n; * FUNCTION:    round down a specified number of blocks to the next&n; *&t;&t;smallest power of 2 number.&n; *&n; * PARAMETERS:&n; *&t;nb&t;- the inode of the file.&n; *&n; * RETURN VALUES:&n; *      next smallest power of 2 number.&n; */
DECL|function|extRoundDown
r_static
id|s64
id|extRoundDown
c_func
(paren
id|s64
id|nb
)paren
(brace
r_int
id|i
suffix:semicolon
id|u64
id|m
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|m
op_assign
(paren
id|u64
)paren
l_int|1
op_lshift
l_int|63
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
comma
id|m
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|m
op_amp
id|nb
)paren
r_break
suffix:semicolon
)brace
id|i
op_assign
l_int|63
op_minus
id|i
suffix:semicolon
id|k
op_assign
(paren
id|u64
)paren
l_int|1
op_lshift
id|i
suffix:semicolon
id|k
op_assign
(paren
(paren
id|k
op_minus
l_int|1
)paren
op_amp
id|nb
)paren
ques
c_cond
id|k
suffix:colon
id|k
op_rshift
l_int|1
suffix:semicolon
r_return
(paren
id|k
)paren
suffix:semicolon
)brace
eof
