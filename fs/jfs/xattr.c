multiline_comment|/*&n; *   Copyright (c) International Business Machines  Corp., 2000-2002&n; *   Copyright (c) Christoph Hellwig, 2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/xattr.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_dmap.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
macro_line|#include &quot;jfs_dinode.h&quot;
macro_line|#include &quot;jfs_extent.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_xattr.h&quot;
macro_line|#include &quot;jfs_acl.h&quot;
multiline_comment|/*&n; *&t;jfs_xattr.c: extended attribute service&n; *&n; * Overall design --&n; *&n; * Format:&n; *&n; *   Extended attribute lists (jfs_ea_list) consist of an overall size (32 bit&n; *   value) and a variable (0 or more) number of extended attribute&n; *   entries.  Each extended attribute entry (jfs_ea) is a &lt;name,value&gt; double&n; *   where &lt;name&gt; is constructed from a null-terminated ascii string&n; *   (1 ... 255 bytes in the name) and &lt;value&gt; is arbitrary 8 bit data&n; *   (1 ... 65535 bytes).  The in-memory format is&n; *&n; *   0       1        2        4                4 + namelen + 1&n; *   +-------+--------+--------+----------------+-------------------+&n; *   | Flags | Name   | Value  | Name String &bslash;0 | Data . . . .      |&n; *   |       | Length | Length |                |                   |&n; *   +-------+--------+--------+----------------+-------------------+&n; *&n; *   A jfs_ea_list then is structured as&n; *&n; *   0            4                   4 + EA_SIZE(ea1)&n; *   +------------+-------------------+--------------------+-----&n; *   | Overall EA | First FEA Element | Second FEA Element | ..... &n; *   | List Size  |                   |                    |&n; *   +------------+-------------------+--------------------+-----&n; *&n; *   On-disk:&n; *&n; *     FEALISTs are stored on disk using blocks allocated by dbAlloc() and&n; *     written directly. An EA list may be in-lined in the inode if there is&n; *     sufficient room available.&n; */
DECL|struct|ea_buffer
r_struct
id|ea_buffer
(brace
DECL|member|flag
r_int
id|flag
suffix:semicolon
multiline_comment|/* Indicates what storage xattr points to */
DECL|member|max_size
r_int
id|max_size
suffix:semicolon
multiline_comment|/* largest xattr that fits in current buffer */
DECL|member|new_ea
id|dxd_t
id|new_ea
suffix:semicolon
multiline_comment|/* dxd to replace ea when modifying xattr */
DECL|member|mp
r_struct
id|metapage
op_star
id|mp
suffix:semicolon
multiline_comment|/* metapage containing ea list */
DECL|member|xattr
r_struct
id|jfs_ea_list
op_star
id|xattr
suffix:semicolon
multiline_comment|/* buffer containing ea list */
)brace
suffix:semicolon
multiline_comment|/*&n; * ea_buffer.flag values&n; */
DECL|macro|EA_INLINE
mdefine_line|#define EA_INLINE&t;0x0001
DECL|macro|EA_EXTENT
mdefine_line|#define EA_EXTENT&t;0x0002
DECL|macro|EA_NEW
mdefine_line|#define EA_NEW&t;&t;0x0004
DECL|macro|EA_MALLOC
mdefine_line|#define EA_MALLOC&t;0x0008
multiline_comment|/* Namespaces */
DECL|macro|XATTR_SYSTEM_PREFIX
mdefine_line|#define XATTR_SYSTEM_PREFIX &quot;system.&quot;
DECL|macro|XATTR_SYSTEM_PREFIX_LEN
mdefine_line|#define XATTR_SYSTEM_PREFIX_LEN (sizeof (XATTR_SYSTEM_PREFIX) - 1)
DECL|macro|XATTR_USER_PREFIX
mdefine_line|#define XATTR_USER_PREFIX &quot;user.&quot;
DECL|macro|XATTR_USER_PREFIX_LEN
mdefine_line|#define XATTR_USER_PREFIX_LEN (sizeof (XATTR_USER_PREFIX) - 1)
DECL|macro|XATTR_OS2_PREFIX
mdefine_line|#define XATTR_OS2_PREFIX &quot;os2.&quot;
DECL|macro|XATTR_OS2_PREFIX_LEN
mdefine_line|#define XATTR_OS2_PREFIX_LEN (sizeof (XATTR_OS2_PREFIX) - 1)
multiline_comment|/*&n; * These three routines are used to recognize on-disk extended attributes&n; * that are in a recognized namespace.  If the attribute is not recognized,&n; * &quot;os2.&quot; is prepended to the name&n; */
DECL|function|is_os2_xattr
r_static
r_inline
r_int
id|is_os2_xattr
c_func
(paren
r_struct
id|jfs_ea
op_star
id|ea
)paren
(brace
multiline_comment|/*&n;&t; * Check for &quot;system.&quot;&n;&t; */
r_if
c_cond
(paren
(paren
id|ea-&gt;namelen
op_ge
id|XATTR_SYSTEM_PREFIX_LEN
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|ea-&gt;name
comma
id|XATTR_SYSTEM_PREFIX
comma
id|XATTR_SYSTEM_PREFIX_LEN
)paren
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * Check for &quot;user.&quot;&n;&t; */
r_if
c_cond
(paren
(paren
id|ea-&gt;namelen
op_ge
id|XATTR_USER_PREFIX_LEN
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|ea-&gt;name
comma
id|XATTR_USER_PREFIX
comma
id|XATTR_USER_PREFIX_LEN
)paren
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * Add any other valid namespace prefixes here&n;&t; */
multiline_comment|/*&n;&t; * We assume it&squot;s OS/2&squot;s flat namespace&n;&t; */
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|name_size
r_static
r_inline
r_int
id|name_size
c_func
(paren
r_struct
id|jfs_ea
op_star
id|ea
)paren
(brace
r_if
c_cond
(paren
id|is_os2_xattr
c_func
(paren
id|ea
)paren
)paren
r_return
id|ea-&gt;namelen
op_plus
id|XATTR_OS2_PREFIX_LEN
suffix:semicolon
r_else
r_return
id|ea-&gt;namelen
suffix:semicolon
)brace
DECL|function|copy_name
r_static
r_inline
r_int
id|copy_name
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|jfs_ea
op_star
id|ea
)paren
(brace
r_int
id|len
op_assign
id|ea-&gt;namelen
suffix:semicolon
r_if
c_cond
(paren
id|is_os2_xattr
c_func
(paren
id|ea
)paren
)paren
(brace
id|memcpy
c_func
(paren
id|buffer
comma
id|XATTR_OS2_PREFIX
comma
id|XATTR_OS2_PREFIX_LEN
)paren
suffix:semicolon
id|buffer
op_add_assign
id|XATTR_OS2_PREFIX_LEN
suffix:semicolon
id|len
op_add_assign
id|XATTR_OS2_PREFIX_LEN
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buffer
comma
id|ea-&gt;name
comma
id|ea-&gt;namelen
)paren
suffix:semicolon
id|buffer
(braket
id|ea-&gt;namelen
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* Forward references */
r_static
r_void
id|ea_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ea_buffer
op_star
id|ea_buf
)paren
suffix:semicolon
multiline_comment|/*&n; * NAME: ea_write_inline&n; *                                                                    &n; * FUNCTION: Attempt to write an EA inline if area is available&n; *                                                                    &n; * PRE CONDITIONS:&n; *&t;Already verified that the specified EA is small enough to fit inline&n; *&n; * PARAMETERS:&n; *&t;ip&t;- Inode pointer&n; *&t;ealist&t;- EA list pointer&n; *&t;size&t;- size of ealist in bytes&n; *&t;ea&t;- dxd_t structure to be filled in with necessary EA information&n; *&t;&t;  if we successfully copy the EA inline&n; *&n; * NOTES:&n; *&t;Checks if the inode&squot;s inline area is available.  If so, copies EA inline&n; *&t;and sets &lt;ea&gt; fields appropriately.  Otherwise, returns failure, EA will&n; *&t;have to be put into an extent.&n; *&n; * RETURNS: 0 for successful copy to inline area; -1 if area not available&n; */
DECL|function|ea_write_inline
r_static
r_int
id|ea_write_inline
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|jfs_ea_list
op_star
id|ealist
comma
r_int
id|size
comma
id|dxd_t
op_star
id|ea
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|ji
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure we have an EA -- the NULL EA list is valid, but you&n;&t; * can&squot;t copy it!&n;&t; */
r_if
c_cond
(paren
id|ealist
op_logical_and
id|size
OG
r_sizeof
(paren
r_struct
id|jfs_ea_list
)paren
)paren
(brace
m_assert
(paren
id|size
op_le
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * See if the space is available or if it is already being&n;&t;&t; * used for an inline EA.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ji-&gt;mode2
op_amp
id|INLINEEA
)paren
op_logical_and
op_logical_neg
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_INLINE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|DXDsize
c_func
(paren
id|ea
comma
id|size
)paren
suffix:semicolon
id|DXDlength
c_func
(paren
id|ea
comma
l_int|0
)paren
suffix:semicolon
id|DXDaddress
c_func
(paren
id|ea
comma
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ji-&gt;i_inline_ea
comma
id|ealist
comma
id|size
)paren
suffix:semicolon
id|ea-&gt;flag
op_assign
id|DXD_INLINE
suffix:semicolon
id|ji-&gt;mode2
op_and_assign
op_complement
id|INLINEEA
suffix:semicolon
)brace
r_else
(brace
id|ea-&gt;flag
op_assign
l_int|0
suffix:semicolon
id|DXDsize
c_func
(paren
id|ea
comma
l_int|0
)paren
suffix:semicolon
id|DXDlength
c_func
(paren
id|ea
comma
l_int|0
)paren
suffix:semicolon
id|DXDaddress
c_func
(paren
id|ea
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Free up INLINE area */
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_INLINE
)paren
id|ji-&gt;mode2
op_or_assign
id|INLINEEA
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME: ea_write&n; *                                                                    &n; * FUNCTION: Write an EA for an inode&n; *                                                                    &n; * PRE CONDITIONS: EA has been verified &n; *&n; * PARAMETERS:&n; *&t;ip&t;- Inode pointer&n; *&t;ealist&t;- EA list pointer&n; *&t;size&t;- size of ealist in bytes&n; *&t;ea&t;- dxd_t structure to be filled in appropriately with where the&n; *&t;&t;  EA was copied&n; *&n; * NOTES: Will write EA inline if able to, otherwise allocates blocks for an&n; *&t;extent and synchronously writes it to those blocks.&n; *&n; * RETURNS: 0 for success; Anything else indicates failure&n; */
DECL|function|ea_write
r_static
r_int
id|ea_write
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|jfs_ea_list
op_star
id|ealist
comma
r_int
id|size
comma
id|dxd_t
op_star
id|ea
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
r_struct
id|jfs_inode_info
op_star
id|ji
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|nblocks
suffix:semicolon
id|s64
id|blkno
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
id|s32
id|nbytes
comma
id|nb
suffix:semicolon
id|s32
id|bytes_to_write
suffix:semicolon
r_struct
id|metapage
op_star
id|mp
suffix:semicolon
multiline_comment|/*&n;&t; * Quick check to see if this is an in-linable EA.  Short EAs&n;&t; * and empty EAs are all in-linable, provided the space exists.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ealist
op_logical_or
id|size
op_le
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ea_write_inline
c_func
(paren
id|ip
comma
id|ealist
comma
id|size
comma
id|ea
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* figure out how many blocks we need */
id|nblocks
op_assign
(paren
id|size
op_plus
(paren
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ip
comma
id|INOHINT
c_func
(paren
id|ip
)paren
comma
id|nblocks
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * Now have nblocks worth of storage to stuff into the FEALIST.&n;&t; * loop over the FEALIST copying data into the buffer one page at&n;&t; * a time.&n;&t; */
id|cp
op_assign
(paren
r_char
op_star
)paren
id|ealist
suffix:semicolon
id|nbytes
op_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_add_assign
id|sbi-&gt;nbperpage
)paren
(brace
multiline_comment|/*&n;&t;&t; * Determine how many bytes for this request, and round up to&n;&t;&t; * the nearest aggregate block size&n;&t;&t; */
id|nb
op_assign
id|min
c_func
(paren
id|PSIZE
comma
id|nbytes
)paren
suffix:semicolon
id|bytes_to_write
op_assign
(paren
(paren
(paren
(paren
id|nb
op_plus
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_rshift
id|sb-&gt;s_blocksize_bits
)paren
)paren
op_lshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp
op_assign
id|get_metapage
c_func
(paren
id|ip
comma
id|blkno
op_plus
id|i
comma
id|bytes_to_write
comma
l_int|1
)paren
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|failed
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|mp-&gt;data
comma
id|cp
comma
id|nb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We really need a way to propagate errors for&n;&t;&t; * forced writes like this one.  --hch&n;&t;&t; *&n;&t;&t; * (__write_metapage =&gt; release_metapage =&gt; flush_metapage)&n;&t;&t; */
macro_line|#ifdef _JFS_FIXME
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|flush_metapage
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * the write failed -- this means that the buffer&n;&t;&t;&t; * is still assigned and the blocks are not being&n;&t;&t;&t; * used.  this seems like the best error recovery&n;&t;&t;&t; * we can get ...&n;&t;&t;&t; */
r_goto
id|failed
suffix:semicolon
)brace
macro_line|#else
id|flush_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#endif
id|cp
op_add_assign
id|PSIZE
suffix:semicolon
id|nbytes
op_sub_assign
id|nb
suffix:semicolon
)brace
id|ea-&gt;flag
op_assign
id|DXD_EXTENT
suffix:semicolon
id|DXDsize
c_func
(paren
id|ea
comma
id|le32_to_cpu
c_func
(paren
id|ealist-&gt;size
)paren
)paren
suffix:semicolon
id|DXDlength
c_func
(paren
id|ea
comma
id|nblocks
)paren
suffix:semicolon
id|DXDaddress
c_func
(paren
id|ea
comma
id|blkno
)paren
suffix:semicolon
multiline_comment|/* Free up INLINE area */
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_INLINE
)paren
id|ji-&gt;mode2
op_or_assign
id|INLINEEA
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|failed
suffix:colon
id|dbFree
c_func
(paren
id|ip
comma
id|blkno
comma
id|nblocks
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME: ea_read_inline&n; *                                                                    &n; * FUNCTION: Read an inlined EA into user&squot;s buffer&n; *                                                                    &n; * PARAMETERS:&n; *&t;ip&t;- Inode pointer&n; *&t;ealist&t;- Pointer to buffer to fill in with EA&n; *&n; * RETURNS: 0&n; */
DECL|function|ea_read_inline
r_static
r_int
id|ea_read_inline
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|jfs_ea_list
op_star
id|ealist
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|ji
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
r_int
id|ea_size
op_assign
id|sizeDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_size
op_eq
l_int|0
)paren
(brace
id|ealist-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Sanity Check */
r_if
c_cond
(paren
(paren
id|sizeDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
OG
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
(paren
(paren
r_struct
id|jfs_ea_list
op_star
)paren
op_amp
id|ji-&gt;i_inline_ea
)paren
op_member_access_from_pointer
id|size
)paren
op_ne
id|ea_size
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|memcpy
c_func
(paren
id|ealist
comma
id|ji-&gt;i_inline_ea
comma
id|ea_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME: ea_read&n; *                                                                    &n; * FUNCTION: copy EA data into user&squot;s buffer&n; *                                                                    &n; * PARAMETERS:&n; *&t;ip&t;- Inode pointer&n; *&t;ealist&t;- Pointer to buffer to fill in with EA&n; *&n; * NOTES:  If EA is inline calls ea_read_inline() to copy EA.&n; *&n; * RETURNS: 0 for success; other indicates failure&n; */
DECL|function|ea_read
r_static
r_int
id|ea_read
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|jfs_ea_list
op_star
id|ealist
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|ip-&gt;i_sb
suffix:semicolon
r_struct
id|jfs_inode_info
op_star
id|ji
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|nblocks
suffix:semicolon
id|s64
id|blkno
suffix:semicolon
r_char
op_star
id|cp
op_assign
(paren
r_char
op_star
)paren
id|ealist
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nbytes
comma
id|nb
suffix:semicolon
id|s32
id|bytes_to_read
suffix:semicolon
r_struct
id|metapage
op_star
id|mp
suffix:semicolon
multiline_comment|/* quick check for in-line EA */
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_INLINE
)paren
r_return
id|ea_read_inline
c_func
(paren
id|ip
comma
id|ealist
)paren
suffix:semicolon
id|nbytes
op_assign
id|sizeDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
suffix:semicolon
m_assert
(paren
id|nbytes
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Figure out how many blocks were allocated when this EA list was&n;&t; * originally written to disk.&n;&t; */
id|nblocks
op_assign
id|lengthDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
op_lshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
id|blkno
op_assign
id|addressDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
op_lshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
multiline_comment|/*&n;&t; * I have found the disk blocks which were originally used to store&n;&t; * the FEALIST.  now i loop over each contiguous block copying the&n;&t; * data into the buffer.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_add_assign
id|sbi-&gt;nbperpage
)paren
(brace
multiline_comment|/*&n;&t;&t; * Determine how many bytes for this request, and round up to&n;&t;&t; * the nearest aggregate block size&n;&t;&t; */
id|nb
op_assign
id|min
c_func
(paren
id|PSIZE
comma
id|nbytes
)paren
suffix:semicolon
id|bytes_to_read
op_assign
(paren
(paren
(paren
(paren
id|nb
op_plus
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
)paren
op_rshift
id|sb-&gt;s_blocksize_bits
)paren
)paren
op_lshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ip
comma
id|blkno
op_plus
id|i
comma
id|bytes_to_read
comma
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|memcpy
c_func
(paren
id|cp
comma
id|mp-&gt;data
comma
id|nb
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|cp
op_add_assign
id|PSIZE
suffix:semicolon
id|nbytes
op_sub_assign
id|nb
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME: ea_get&n; *                                                                    &n; * FUNCTION: Returns buffer containing existing extended attributes.&n; *&t;     The size of the buffer will be the larger of the existing&n; *&t;     attributes size, or min_size.&n; *&n; *&t;     The buffer, which may be inlined in the inode or in the&n; * &t;     page cache must be release by calling ea_release or ea_put&n; *                                                                    &n; * PARAMETERS:&n; *&t;inode&t;- Inode pointer&n; *&t;ea_buf&t;- Structure to be populated with ealist and its metadata&n; *&t;min_size- minimum size of buffer to be returned&n; *&n; * RETURNS: 0 for success; Other indicates failure&n; */
DECL|function|ea_get
r_static
r_int
id|ea_get
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ea_buffer
op_star
id|ea_buf
comma
r_int
id|min_size
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|ji
op_assign
id|JFS_IP
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|ea_size
op_assign
id|sizeDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
suffix:semicolon
r_int
id|blocks_needed
comma
id|current_blocks
suffix:semicolon
id|s64
id|blkno
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* When fsck.jfs clears a bad ea, it doesn&squot;t clear the size */
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_eq
l_int|0
)paren
id|ea_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ea_size
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|min_size
op_eq
l_int|0
)paren
(brace
id|ea_buf-&gt;flag
op_assign
l_int|0
suffix:semicolon
id|ea_buf-&gt;max_size
op_assign
l_int|0
suffix:semicolon
id|ea_buf-&gt;xattr
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|min_size
op_le
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
)paren
op_logical_and
(paren
id|ji-&gt;mode2
op_amp
id|INLINEEA
)paren
)paren
(brace
id|ea_buf-&gt;flag
op_assign
id|EA_INLINE
op_or
id|EA_NEW
suffix:semicolon
id|ea_buf-&gt;max_size
op_assign
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
suffix:semicolon
id|ea_buf-&gt;xattr
op_assign
(paren
r_struct
id|jfs_ea_list
op_star
)paren
id|ji-&gt;i_inline_ea
suffix:semicolon
id|DXDlength
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
l_int|0
)paren
suffix:semicolon
id|DXDaddress
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
l_int|0
)paren
suffix:semicolon
id|ea_buf-&gt;new_ea.flag
op_assign
id|DXD_INLINE
suffix:semicolon
id|DXDsize
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
id|min_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|current_blocks
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_INLINE
)paren
(brace
r_if
c_cond
(paren
id|min_size
op_le
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
)paren
(brace
id|ea_buf-&gt;flag
op_assign
id|EA_INLINE
suffix:semicolon
id|ea_buf-&gt;max_size
op_assign
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
suffix:semicolon
id|ea_buf-&gt;xattr
op_assign
(paren
r_struct
id|jfs_ea_list
op_star
)paren
id|ji-&gt;i_inline_ea
suffix:semicolon
r_goto
id|size_check
suffix:semicolon
)brace
id|current_blocks
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
m_assert
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_EXTENT
)paren
suffix:semicolon
id|current_blocks
op_assign
(paren
id|ea_size
op_plus
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
)brace
id|size
op_assign
id|max
c_func
(paren
id|min_size
comma
id|ea_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PSIZE
)paren
(brace
multiline_comment|/*&n;&t;&t; * To keep the rest of the code simple.  Allocate a&n;&t;&t; * contiguous buffer to work with&n;&t;&t; */
id|ea_buf-&gt;xattr
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_buf-&gt;xattr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ea_buf-&gt;flag
op_or_assign
id|EA_MALLOC
suffix:semicolon
id|ea_buf-&gt;max_size
op_assign
(paren
id|size
op_plus
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|ea_read
c_func
(paren
id|inode
comma
id|ea_buf-&gt;xattr
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|ea_buf-&gt;xattr
)paren
suffix:semicolon
id|ea_buf-&gt;xattr
op_assign
l_int|NULL
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_goto
id|size_check
suffix:semicolon
)brace
id|blocks_needed
op_assign
(paren
id|min_size
op_plus
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
id|blocks_needed
OG
id|current_blocks
)paren
(brace
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|inode
comma
id|INOHINT
c_func
(paren
id|inode
)paren
comma
(paren
id|s64
)paren
id|blocks_needed
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|DXDlength
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
id|blocks_needed
)paren
suffix:semicolon
id|DXDaddress
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
id|blkno
)paren
suffix:semicolon
id|ea_buf-&gt;new_ea.flag
op_assign
id|DXD_EXTENT
suffix:semicolon
id|DXDsize
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
id|min_size
)paren
suffix:semicolon
id|ea_buf-&gt;flag
op_assign
id|EA_EXTENT
op_or
id|EA_NEW
suffix:semicolon
id|ea_buf-&gt;mp
op_assign
id|get_metapage
c_func
(paren
id|inode
comma
id|blkno
comma
id|blocks_needed
op_lshift
id|sb-&gt;s_blocksize_bits
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_buf-&gt;mp
op_eq
l_int|NULL
)paren
(brace
id|dbFree
c_func
(paren
id|inode
comma
id|blkno
comma
(paren
id|s64
)paren
id|blocks_needed
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ea_buf-&gt;xattr
op_assign
id|ea_buf-&gt;mp-&gt;data
suffix:semicolon
id|ea_buf-&gt;max_size
op_assign
(paren
id|min_size
op_plus
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|ea_read
c_func
(paren
id|inode
comma
id|ea_buf-&gt;xattr
)paren
)paren
)paren
(brace
id|discard_metapage
c_func
(paren
id|ea_buf-&gt;mp
)paren
suffix:semicolon
id|dbFree
c_func
(paren
id|inode
comma
id|blkno
comma
(paren
id|s64
)paren
id|blocks_needed
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_goto
id|size_check
suffix:semicolon
)brace
id|ea_buf-&gt;flag
op_assign
id|EA_EXTENT
suffix:semicolon
id|ea_buf-&gt;mp
op_assign
id|read_metapage
c_func
(paren
id|inode
comma
id|addressDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
comma
id|lengthDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_buf-&gt;mp
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|ea_buf-&gt;xattr
op_assign
id|ea_buf-&gt;mp-&gt;data
suffix:semicolon
id|ea_buf-&gt;max_size
op_assign
(paren
id|ea_size
op_plus
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|size_check
suffix:colon
r_if
c_cond
(paren
id|EALIST_SIZE
c_func
(paren
id|ea_buf-&gt;xattr
)paren
op_ne
id|ea_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ea_get: invalid extended attribute&bslash;n&quot;
)paren
suffix:semicolon
id|dump_mem
c_func
(paren
l_string|&quot;xattr&quot;
comma
id|ea_buf-&gt;xattr
comma
id|ea_size
)paren
suffix:semicolon
id|ea_release
c_func
(paren
id|inode
comma
id|ea_buf
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
id|ea_size
suffix:semicolon
)brace
DECL|function|ea_release
r_static
r_void
id|ea_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ea_buffer
op_star
id|ea_buf
)paren
(brace
r_if
c_cond
(paren
id|ea_buf-&gt;flag
op_amp
id|EA_MALLOC
)paren
id|kfree
c_func
(paren
id|ea_buf-&gt;xattr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ea_buf-&gt;flag
op_amp
id|EA_EXTENT
)paren
(brace
m_assert
(paren
id|ea_buf-&gt;mp
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|ea_buf-&gt;mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_buf-&gt;flag
op_amp
id|EA_NEW
)paren
id|dbFree
c_func
(paren
id|inode
comma
id|addressDXD
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
)paren
comma
id|lengthDXD
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|ea_put
r_static
r_int
id|ea_put
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|ea_buffer
op_star
id|ea_buf
comma
r_int
id|new_size
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|ji
op_assign
id|JFS_IP
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
r_int
id|old_blocks
comma
id|new_blocks
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|tid_t
id|tid
suffix:semicolon
r_if
c_cond
(paren
id|new_size
op_eq
l_int|0
)paren
(brace
id|ea_release
c_func
(paren
id|inode
comma
id|ea_buf
)paren
suffix:semicolon
id|ea_buf
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ea_buf-&gt;flag
op_amp
id|EA_INLINE
)paren
(brace
m_assert
(paren
id|new_size
op_le
r_sizeof
(paren
id|ji-&gt;i_inline_ea
)paren
)paren
suffix:semicolon
id|ji-&gt;mode2
op_and_assign
op_complement
id|INLINEEA
suffix:semicolon
id|ea_buf-&gt;new_ea.flag
op_assign
id|DXD_INLINE
suffix:semicolon
id|DXDsize
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
id|new_size
)paren
suffix:semicolon
id|DXDaddress
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
l_int|0
)paren
suffix:semicolon
id|DXDlength
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ea_buf-&gt;flag
op_amp
id|EA_MALLOC
)paren
(brace
id|rc
op_assign
id|ea_write
c_func
(paren
id|inode
comma
id|ea_buf-&gt;xattr
comma
id|new_size
comma
op_amp
id|ea_buf-&gt;new_ea
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ea_buf-&gt;xattr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ea_buf-&gt;flag
op_amp
id|EA_NEW
)paren
(brace
multiline_comment|/* We have already allocated a new dxd */
id|flush_metapage
c_func
(paren
id|ea_buf-&gt;mp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* -&gt;xattr must point to original ea&squot;s metapage */
id|rc
op_assign
id|ea_write
c_func
(paren
id|inode
comma
id|ea_buf-&gt;xattr
comma
id|new_size
comma
op_amp
id|ea_buf-&gt;new_ea
)paren
suffix:semicolon
id|discard_metapage
c_func
(paren
id|ea_buf-&gt;mp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|tid
op_assign
id|txBegin
c_func
(paren
id|inode-&gt;i_sb
comma
l_int|0
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|ji-&gt;commit_sem
)paren
suffix:semicolon
id|old_blocks
op_assign
id|new_blocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_EXTENT
)paren
(brace
id|invalidate_dxd_metapages
c_func
(paren
id|inode
comma
id|ji-&gt;ea
)paren
suffix:semicolon
id|old_blocks
op_assign
id|lengthDXD
c_func
(paren
op_amp
id|ji-&gt;ea
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ea_buf
)paren
(brace
id|txEA
c_func
(paren
id|tid
comma
id|inode
comma
op_amp
id|ji-&gt;ea
comma
op_amp
id|ea_buf-&gt;new_ea
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ea_buf-&gt;new_ea.flag
op_amp
id|DXD_EXTENT
)paren
(brace
id|new_blocks
op_assign
id|lengthDXD
c_func
(paren
op_amp
id|ea_buf-&gt;new_ea
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_INLINE
)paren
id|ji-&gt;mode2
op_or_assign
id|INLINEEA
suffix:semicolon
)brace
id|ji-&gt;ea
op_assign
id|ea_buf-&gt;new_ea
suffix:semicolon
)brace
r_else
(brace
id|txEA
c_func
(paren
id|tid
comma
id|inode
comma
op_amp
id|ji-&gt;ea
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ji-&gt;ea.flag
op_amp
id|DXD_INLINE
)paren
id|ji-&gt;mode2
op_or_assign
id|INLINEEA
suffix:semicolon
id|ji-&gt;ea.flag
op_assign
l_int|0
suffix:semicolon
id|ji-&gt;ea.size
op_assign
l_int|0
suffix:semicolon
)brace
id|inode-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|inode-&gt;i_sb
comma
id|new_blocks
op_minus
id|old_blocks
)paren
suffix:semicolon
id|rc
op_assign
id|txCommit
c_func
(paren
id|tid
comma
l_int|1
comma
op_amp
id|inode
comma
l_int|0
)paren
suffix:semicolon
id|txEnd
c_func
(paren
id|tid
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|ji-&gt;commit_sem
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * can_set_system_xattr&n; *&n; * This code is specific to the system.* namespace.  It contains policy&n; * which doesn&squot;t belong in the main xattr codepath.&n; */
DECL|function|can_set_system_xattr
r_static
r_int
id|can_set_system_xattr
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|value_len
)paren
(brace
macro_line|#ifdef CONFIG_JFS_POSIX_ACL
r_struct
id|posix_acl
op_star
id|acl
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;fsuid
op_ne
id|inode-&gt;i_uid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t; * XATTR_NAME_ACL_ACCESS is tied to i_mode&n;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
id|XATTR_NAME_ACL_ACCESS
)paren
op_eq
l_int|0
)paren
(brace
id|acl
op_assign
id|posix_acl_from_xattr
c_func
(paren
id|value
comma
id|value_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acl
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;posix_acl_from_xattr returned %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|acl
OG
l_int|0
)paren
(brace
id|mode_t
id|mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
id|rc
op_assign
id|posix_acl_equiv_mode
c_func
(paren
id|acl
comma
op_amp
id|mode
)paren
suffix:semicolon
id|posix_acl_release
c_func
(paren
id|acl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;posix_acl_equiv_mode returned %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|inode-&gt;i_mode
op_assign
id|mode
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|value
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We&squot;re changing the ACL.  Get rid of the cached one&n;&t;&t; */
id|acl
op_assign
id|JFS_IP
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl
suffix:semicolon
r_if
c_cond
(paren
id|acl
op_logical_and
(paren
id|acl
op_ne
id|JFS_ACL_NOT_CACHED
)paren
)paren
id|posix_acl_release
c_func
(paren
id|acl
)paren
suffix:semicolon
id|JFS_IP
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_acl
op_assign
id|JFS_ACL_NOT_CACHED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
id|XATTR_NAME_ACL_DEFAULT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re changing the default ACL.  Get rid of the cached one&n;&t;&t; */
id|acl
op_assign
id|JFS_IP
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_default_acl
suffix:semicolon
r_if
c_cond
(paren
id|acl
op_logical_and
(paren
id|acl
op_ne
id|JFS_ACL_NOT_CACHED
)paren
)paren
id|posix_acl_release
c_func
(paren
id|acl
)paren
suffix:semicolon
id|JFS_IP
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_default_acl
op_assign
id|JFS_ACL_NOT_CACHED
suffix:semicolon
)brace
r_else
multiline_comment|/* Invalid xattr name */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else&t;&t;&t;/* CONFIG_JFS_POSIX_ACL */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
macro_line|#endif&t;&t;&t;/* CONFIG_JFS_POSIX_ACL */
)brace
DECL|function|can_set_xattr
r_static
r_int
id|can_set_xattr
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|value_len
)paren
(brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
id|XATTR_SYSTEM_PREFIX
comma
id|XATTR_SYSTEM_PREFIX_LEN
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;system.*&quot;&n;&t;&t; */
r_return
id|can_set_system_xattr
c_func
(paren
id|inode
comma
id|name
comma
id|value
comma
id|value_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|strncmp
c_func
(paren
id|name
comma
id|XATTR_USER_PREFIX
comma
id|XATTR_USER_PREFIX_LEN
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|strncmp
c_func
(paren
id|name
comma
id|XATTR_OS2_PREFIX
comma
id|XATTR_OS2_PREFIX_LEN
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|inode-&gt;i_mode
op_amp
id|S_ISVTX
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#ifdef CONFIG_JFS_POSIX_ACL
r_return
id|jfs_permission_have_sem
c_func
(paren
id|inode
comma
id|MAY_WRITE
)paren
suffix:semicolon
macro_line|#else
r_return
id|permission
c_func
(paren
id|inode
comma
id|MAY_WRITE
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|__jfs_setxattr
r_int
id|__jfs_setxattr
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|value_len
comma
r_int
id|flags
)paren
(brace
r_struct
id|jfs_ea_list
op_star
id|ealist
suffix:semicolon
r_struct
id|jfs_ea
op_star
id|ea
comma
op_star
id|old_ea
op_assign
l_int|NULL
comma
op_star
id|next_ea
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ea_buffer
id|ea_buf
suffix:semicolon
r_int
id|old_ea_size
op_assign
l_int|0
suffix:semicolon
r_int
id|xattr_size
suffix:semicolon
r_int
id|new_size
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_char
op_star
id|os2name
op_assign
l_int|NULL
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|length
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|can_set_xattr
c_func
(paren
id|inode
comma
id|name
comma
id|value
comma
id|value_len
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
id|XATTR_OS2_PREFIX
comma
id|XATTR_OS2_PREFIX_LEN
)paren
op_eq
l_int|0
)paren
(brace
id|os2name
op_assign
id|kmalloc
c_func
(paren
id|namelen
op_minus
id|XATTR_OS2_PREFIX_LEN
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|os2name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|strcpy
c_func
(paren
id|os2name
comma
id|name
op_plus
id|XATTR_OS2_PREFIX_LEN
)paren
suffix:semicolon
id|name
op_assign
id|os2name
suffix:semicolon
id|namelen
op_sub_assign
id|XATTR_OS2_PREFIX_LEN
suffix:semicolon
)brace
id|xattr_size
op_assign
id|ea_get
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xattr_size
OL
l_int|0
)paren
(brace
id|rc
op_assign
id|xattr_size
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|again
suffix:colon
id|ealist
op_assign
(paren
r_struct
id|jfs_ea_list
op_star
)paren
id|ea_buf.xattr
suffix:semicolon
id|new_size
op_assign
r_sizeof
(paren
r_struct
id|jfs_ea_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xattr_size
)paren
(brace
r_for
c_loop
(paren
id|ea
op_assign
id|FIRST_EA
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
OL
id|END_EALIST
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
op_assign
id|NEXT_EA
c_func
(paren
id|ea
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|namelen
op_eq
id|ea-&gt;namelen
)paren
op_logical_and
(paren
id|memcmp
c_func
(paren
id|name
comma
id|ea-&gt;name
comma
id|namelen
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XATTR_CREATE
)paren
(brace
id|rc
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
id|old_ea
op_assign
id|ea
suffix:semicolon
id|old_ea_size
op_assign
id|EA_SIZE
c_func
(paren
id|ea
)paren
suffix:semicolon
id|next_ea
op_assign
id|NEXT_EA
c_func
(paren
id|ea
)paren
suffix:semicolon
)brace
r_else
id|new_size
op_add_assign
id|EA_SIZE
c_func
(paren
id|ea
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XATTR_REPLACE
)paren
(brace
id|rc
op_assign
op_minus
id|ENODATA
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
l_int|0
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|value
)paren
id|new_size
op_add_assign
r_sizeof
(paren
r_struct
id|jfs_ea
)paren
op_plus
id|namelen
op_plus
l_int|1
op_plus
id|value_len
suffix:semicolon
r_if
c_cond
(paren
id|new_size
OG
id|ea_buf.max_size
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need to allocate more space for merged ea list.&n;&t;&t; * We should only have loop to again: once.&n;&t;&t; */
id|ea_release
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
)paren
suffix:semicolon
id|xattr_size
op_assign
id|ea_get
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
comma
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xattr_size
OL
l_int|0
)paren
(brace
id|rc
op_assign
id|xattr_size
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/* Remove old ea of the same name */
r_if
c_cond
(paren
id|found
)paren
(brace
multiline_comment|/* number of bytes following target EA */
id|length
op_assign
(paren
r_char
op_star
)paren
id|END_EALIST
c_func
(paren
id|ealist
)paren
op_minus
(paren
r_char
op_star
)paren
id|next_ea
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
l_int|0
)paren
id|memmove
c_func
(paren
id|old_ea
comma
id|next_ea
comma
id|length
)paren
suffix:semicolon
id|xattr_size
op_sub_assign
id|old_ea_size
suffix:semicolon
)brace
multiline_comment|/* Add new entry to the end */
r_if
c_cond
(paren
id|value
)paren
(brace
r_if
c_cond
(paren
id|xattr_size
op_eq
l_int|0
)paren
multiline_comment|/* Completely new ea list */
id|xattr_size
op_assign
r_sizeof
(paren
r_struct
id|jfs_ea_list
)paren
suffix:semicolon
id|ea
op_assign
(paren
r_struct
id|jfs_ea
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|ealist
op_plus
id|xattr_size
)paren
suffix:semicolon
id|ea-&gt;flag
op_assign
l_int|0
suffix:semicolon
id|ea-&gt;namelen
op_assign
id|namelen
suffix:semicolon
id|ea-&gt;valuelen
op_assign
(paren
id|cpu_to_le16
c_func
(paren
id|value_len
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ea-&gt;name
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
id|ea-&gt;name
(braket
id|namelen
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|value_len
)paren
id|memcpy
c_func
(paren
op_amp
id|ea-&gt;name
(braket
id|namelen
op_plus
l_int|1
)braket
comma
id|value
comma
id|value_len
)paren
suffix:semicolon
id|xattr_size
op_add_assign
id|EA_SIZE
c_func
(paren
id|ea
)paren
suffix:semicolon
)brace
multiline_comment|/* DEBUG - If we did this right, these number match */
r_if
c_cond
(paren
id|xattr_size
op_ne
id|new_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jfs_xsetattr: xattr_size = %d, new_size = %d&bslash;n&quot;
comma
id|xattr_size
comma
id|new_size
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re left with an empty list, there&squot;s no ea&n;&t; */
r_if
c_cond
(paren
id|new_size
op_eq
r_sizeof
(paren
r_struct
id|jfs_ea_list
)paren
)paren
id|new_size
op_assign
l_int|0
suffix:semicolon
id|ealist-&gt;size
op_assign
id|cpu_to_le32
c_func
(paren
id|new_size
)paren
suffix:semicolon
id|rc
op_assign
id|ea_put
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
comma
id|new_size
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|release
suffix:colon
id|ea_release
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|os2name
)paren
id|kfree
c_func
(paren
id|os2name
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|jfs_setxattr
r_int
id|jfs_setxattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
comma
r_const
r_void
op_star
id|value
comma
r_int
id|value_len
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|value
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* empty EA, do not remove */
id|value
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|value_len
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|__jfs_setxattr
c_func
(paren
id|dentry-&gt;d_inode
comma
id|name
comma
id|value
comma
id|value_len
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|can_get_xattr
r_static
r_int
id|can_get_xattr
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
)paren
(brace
macro_line|#ifdef CONFIG_JFS_POSIX_ACL
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
id|XATTR_SYSTEM_PREFIX
comma
id|XATTR_SYSTEM_PREFIX_LEN
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|jfs_permission_have_sem
c_func
(paren
id|inode
comma
id|MAY_READ
)paren
suffix:semicolon
macro_line|#else
r_return
id|permission
c_func
(paren
id|inode
comma
id|MAY_READ
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|__jfs_getxattr
id|ssize_t
id|__jfs_getxattr
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|data
comma
r_int
id|buf_size
)paren
(brace
r_struct
id|jfs_ea_list
op_star
id|ealist
suffix:semicolon
r_struct
id|jfs_ea
op_star
id|ea
suffix:semicolon
r_struct
id|ea_buffer
id|ea_buf
suffix:semicolon
r_int
id|xattr_size
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
r_int
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_char
op_star
id|os2name
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|can_get_xattr
c_func
(paren
id|inode
comma
id|name
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|name
comma
id|XATTR_OS2_PREFIX
comma
id|XATTR_OS2_PREFIX_LEN
)paren
op_eq
l_int|0
)paren
(brace
id|os2name
op_assign
id|kmalloc
c_func
(paren
id|namelen
op_minus
id|XATTR_OS2_PREFIX_LEN
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|os2name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|strcpy
c_func
(paren
id|os2name
comma
id|name
op_plus
id|XATTR_OS2_PREFIX_LEN
)paren
suffix:semicolon
id|name
op_assign
id|os2name
suffix:semicolon
id|namelen
op_sub_assign
id|XATTR_OS2_PREFIX_LEN
suffix:semicolon
)brace
id|xattr_size
op_assign
id|ea_get
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xattr_size
OL
l_int|0
)paren
(brace
id|size
op_assign
id|xattr_size
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xattr_size
op_eq
l_int|0
)paren
r_goto
id|not_found
suffix:semicolon
id|ealist
op_assign
(paren
r_struct
id|jfs_ea_list
op_star
)paren
id|ea_buf.xattr
suffix:semicolon
multiline_comment|/* Find the named attribute */
r_for
c_loop
(paren
id|ea
op_assign
id|FIRST_EA
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
OL
id|END_EALIST
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
op_assign
id|NEXT_EA
c_func
(paren
id|ea
)paren
)paren
r_if
c_cond
(paren
(paren
id|namelen
op_eq
id|ea-&gt;namelen
)paren
op_logical_and
id|memcmp
c_func
(paren
id|name
comma
id|ea-&gt;name
comma
id|namelen
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Found it */
id|size
op_assign
id|le16_to_cpu
c_func
(paren
id|ea-&gt;valuelen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|release
suffix:semicolon
r_else
r_if
c_cond
(paren
id|size
OG
id|buf_size
)paren
(brace
id|size
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
id|value
op_assign
(paren
(paren
r_char
op_star
)paren
op_amp
id|ea-&gt;name
)paren
op_plus
id|ea-&gt;namelen
op_plus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|data
comma
id|value
comma
id|size
)paren
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
id|not_found
suffix:colon
id|size
op_assign
op_minus
id|ENODATA
suffix:semicolon
id|release
suffix:colon
id|ea_release
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|os2name
)paren
id|kfree
c_func
(paren
id|os2name
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
DECL|function|jfs_getxattr
id|ssize_t
id|jfs_getxattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|data
comma
r_int
id|buf_size
)paren
(brace
r_int
id|err
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|__jfs_getxattr
c_func
(paren
id|dentry-&gt;d_inode
comma
id|name
comma
id|data
comma
id|buf_size
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|__jfs_listxattr
r_static
id|ssize_t
id|__jfs_listxattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|data
comma
r_int
id|buf_size
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
id|ssize_t
id|size
op_assign
l_int|0
suffix:semicolon
r_int
id|xattr_size
suffix:semicolon
r_struct
id|jfs_ea_list
op_star
id|ealist
suffix:semicolon
r_struct
id|jfs_ea
op_star
id|ea
suffix:semicolon
r_struct
id|ea_buffer
id|ea_buf
suffix:semicolon
id|xattr_size
op_assign
id|ea_get
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xattr_size
OL
l_int|0
)paren
(brace
id|size
op_assign
id|xattr_size
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xattr_size
op_eq
l_int|0
)paren
r_goto
id|release
suffix:semicolon
id|ealist
op_assign
(paren
r_struct
id|jfs_ea_list
op_star
)paren
id|ea_buf.xattr
suffix:semicolon
multiline_comment|/* compute required size of list */
r_for
c_loop
(paren
id|ea
op_assign
id|FIRST_EA
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
OL
id|END_EALIST
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
op_assign
id|NEXT_EA
c_func
(paren
id|ea
)paren
)paren
id|size
op_add_assign
id|name_size
c_func
(paren
id|ea
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|release
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|buf_size
)paren
(brace
id|size
op_assign
op_minus
id|ERANGE
suffix:semicolon
r_goto
id|release
suffix:semicolon
)brace
multiline_comment|/* Copy attribute names to buffer */
id|buffer
op_assign
id|data
suffix:semicolon
r_for
c_loop
(paren
id|ea
op_assign
id|FIRST_EA
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
OL
id|END_EALIST
c_func
(paren
id|ealist
)paren
suffix:semicolon
id|ea
op_assign
id|NEXT_EA
c_func
(paren
id|ea
)paren
)paren
(brace
r_int
id|namelen
op_assign
id|copy_name
c_func
(paren
id|buffer
comma
id|ea
)paren
suffix:semicolon
id|buffer
op_add_assign
id|namelen
op_plus
l_int|1
suffix:semicolon
)brace
id|release
suffix:colon
id|ea_release
c_func
(paren
id|inode
comma
op_amp
id|ea_buf
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|size
suffix:semicolon
)brace
DECL|function|jfs_listxattr
id|ssize_t
id|jfs_listxattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|data
comma
r_int
id|buf_size
)paren
(brace
r_int
id|err
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|__jfs_listxattr
c_func
(paren
id|dentry
comma
id|data
comma
id|buf_size
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|jfs_removexattr
r_int
id|jfs_removexattr
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_return
id|__jfs_setxattr
c_func
(paren
id|dentry-&gt;d_inode
comma
id|name
comma
l_int|0
comma
l_int|0
comma
id|XATTR_REPLACE
)paren
suffix:semicolon
)brace
eof
