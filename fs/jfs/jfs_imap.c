multiline_comment|/*&n; *   Copyright (c) International Business Machines Corp., 2000-2002&n; *&n; *   This program is free software;  you can redistribute it and/or modify&n; *   it under the terms of the GNU General Public License as published by&n; *   the Free Software Foundation; either version 2 of the License, or &n; *   (at your option) any later version.&n; * &n; *   This program is distributed in the hope that it will be useful,&n; *   but WITHOUT ANY WARRANTY;  without even the implied warranty of&n; *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See&n; *   the GNU General Public License for more details.&n; *&n; *   You should have received a copy of the GNU General Public License&n; *   along with this program;  if not, write to the Free Software &n; *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA&n; */
multiline_comment|/*&n; *&t;jfs_imap.c: inode allocation map manager&n; *&n; * Serialization:&n; *   Each AG has a simple lock which is used to control the serialization of&n; *&t;the AG level lists.  This lock should be taken first whenever an AG&n; *&t;level list will be modified or accessed.&n; *&n; *   Each IAG is locked by obtaining the buffer for the IAG page.&n; *&n; *   There is also a inode lock for the inode map inode.  A read lock needs to&n; *&t;be taken whenever an IAG is read from the map or the global level&n; *&t;information is read.  A write lock needs to be taken whenever the global&n; *&t;level information is modified or an atomic operation needs to be used.&n; *&n; *&t;If more than one IAG is read at one time, the read lock may not&n; *&t;be given up until all of the IAG&squot;s are read.  Otherwise, a deadlock&n; *&t;may occur when trying to obtain the read lock while another thread&n; *&t;holding the read lock is waiting on the IAG already being held.&n; *&n; *   The control page of the inode map is read into memory by diMount().&n; *&t;Thereafter it should only be modified in memory and then it will be&n; *&t;written out when the filesystem is unmounted by diUnmount().&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &quot;jfs_incore.h&quot;
macro_line|#include &quot;jfs_filsys.h&quot;
macro_line|#include &quot;jfs_dinode.h&quot;
macro_line|#include &quot;jfs_dmap.h&quot;
macro_line|#include &quot;jfs_imap.h&quot;
macro_line|#include &quot;jfs_metapage.h&quot;
macro_line|#include &quot;jfs_superblock.h&quot;
macro_line|#include &quot;jfs_debug.h&quot;
multiline_comment|/*&n; * imap locks&n; */
multiline_comment|/* iag free list lock */
DECL|macro|IAGFREE_LOCK_INIT
mdefine_line|#define IAGFREE_LOCK_INIT(imap)&t;&t;init_MUTEX(&amp;imap-&gt;im_freelock)
DECL|macro|IAGFREE_LOCK
mdefine_line|#define IAGFREE_LOCK(imap)&t;&t;down(&amp;imap-&gt;im_freelock)
DECL|macro|IAGFREE_UNLOCK
mdefine_line|#define IAGFREE_UNLOCK(imap)&t;&t;up(&amp;imap-&gt;im_freelock)
multiline_comment|/* per ag iag list locks */
DECL|macro|AG_LOCK_INIT
mdefine_line|#define AG_LOCK_INIT(imap,index)&t;init_MUTEX(&amp;(imap-&gt;im_aglock[index]))
DECL|macro|AG_LOCK
mdefine_line|#define AG_LOCK(imap,agno)&t;&t;down(&amp;imap-&gt;im_aglock[agno])
DECL|macro|AG_UNLOCK
mdefine_line|#define AG_UNLOCK(imap,agno)&t;&t;up(&amp;imap-&gt;im_aglock[agno])
multiline_comment|/*&n; * external references&n; */
r_extern
r_struct
id|address_space_operations
id|jfs_aops
suffix:semicolon
multiline_comment|/*&n; * forward references&n; */
r_static
r_int
id|diAllocAG
c_func
(paren
id|imap_t
op_star
comma
r_int
comma
id|boolean_t
comma
r_struct
id|inode
op_star
)paren
suffix:semicolon
r_static
r_int
id|diAllocAny
c_func
(paren
id|imap_t
op_star
comma
r_int
comma
id|boolean_t
comma
r_struct
id|inode
op_star
)paren
suffix:semicolon
r_static
r_int
id|diAllocBit
c_func
(paren
id|imap_t
op_star
comma
id|iag_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|diAllocExt
c_func
(paren
id|imap_t
op_star
comma
r_int
comma
r_struct
id|inode
op_star
)paren
suffix:semicolon
r_static
r_int
id|diAllocIno
c_func
(paren
id|imap_t
op_star
comma
r_int
comma
r_struct
id|inode
op_star
)paren
suffix:semicolon
r_static
r_int
id|diFindFree
c_func
(paren
id|u32
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|diNewExt
c_func
(paren
id|imap_t
op_star
comma
id|iag_t
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|diNewIAG
c_func
(paren
id|imap_t
op_star
comma
r_int
op_star
comma
r_int
comma
id|metapage_t
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|duplicateIXtree
c_func
(paren
r_struct
id|super_block
op_star
comma
id|s64
comma
r_int
comma
id|s64
op_star
)paren
suffix:semicolon
r_static
r_int
id|diIAGRead
c_func
(paren
id|imap_t
op_star
id|imap
comma
r_int
comma
id|metapage_t
op_star
op_star
)paren
suffix:semicolon
r_static
r_int
id|copy_from_dinode
c_func
(paren
id|dinode_t
op_star
comma
r_struct
id|inode
op_star
)paren
suffix:semicolon
r_static
r_void
id|copy_to_dinode
c_func
(paren
id|dinode_t
op_star
comma
r_struct
id|inode
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;debug code for double-checking inode map&n; */
multiline_comment|/* #define&t;_JFS_DEBUG_IMAP&t;1 */
macro_line|#ifdef&t;_JFS_DEBUG_IMAP
DECL|macro|DBG_DIINIT
mdefine_line|#define DBG_DIINIT(imap)&t;DBGdiInit(imap)
DECL|macro|DBG_DIALLOC
mdefine_line|#define DBG_DIALLOC(imap, ino)&t;DBGdiAlloc(imap, ino)
DECL|macro|DBG_DIFREE
mdefine_line|#define DBG_DIFREE(imap, ino)&t;DBGdiFree(imap, ino)
r_static
r_void
op_star
id|DBGdiInit
c_func
(paren
id|imap_t
op_star
id|imap
)paren
suffix:semicolon
r_static
r_void
id|DBGdiAlloc
c_func
(paren
id|imap_t
op_star
id|imap
comma
id|ino_t
id|ino
)paren
suffix:semicolon
r_static
r_void
id|DBGdiFree
c_func
(paren
id|imap_t
op_star
id|imap
comma
id|ino_t
id|ino
)paren
suffix:semicolon
macro_line|#else
DECL|macro|DBG_DIINIT
mdefine_line|#define DBG_DIINIT(imap)
DECL|macro|DBG_DIALLOC
mdefine_line|#define DBG_DIALLOC(imap, ino)
DECL|macro|DBG_DIFREE
mdefine_line|#define DBG_DIFREE(imap, ino)
macro_line|#endif&t;&t;&t;&t;/* _JFS_DEBUG_IMAP */
multiline_comment|/*&n; * NAME:        diMount()&n; *&n; * FUNCTION:    initialize the incore inode map control structures for&n; *&t;&t;a fileset or aggregate init time.&n; *&n; *              the inode map&squot;s control structure (dinomap_t) is &n; *              brought in from disk and placed in virtual memory.&n; *&n; * PARAMETERS:&n; *      ipimap  - pointer to inode map inode for the aggregate or fileset.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      ENOMEM  - insufficient free virtual memory.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diMount
r_int
id|diMount
c_func
(paren
r_struct
id|inode
op_star
id|ipimap
)paren
(brace
id|imap_t
op_star
id|imap
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
r_int
id|index
suffix:semicolon
id|dinomap_t
op_star
id|dinom_le
suffix:semicolon
multiline_comment|/*&n;&t; * allocate/initialize the in-memory inode map control structure&n;&t; */
multiline_comment|/* allocate the in-memory inode map control structure. */
id|imap
op_assign
(paren
id|imap_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|imap_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap
op_eq
l_int|NULL
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diMount: kmalloc returned NULL!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
multiline_comment|/* read the on-disk inode map control structure. */
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipimap
comma
id|IMAPBLKNO
op_lshift
id|JFS_SBI
c_func
(paren
id|ipimap-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2nbperpage
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|imap
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* copy the on-disk version to the in-memory version. */
id|dinom_le
op_assign
(paren
id|dinomap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|imap-&gt;im_freeiag
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_freeiag
)paren
suffix:semicolon
id|imap-&gt;im_nextiag
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_nextiag
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|imap-&gt;im_numinos
comma
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_numinos
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|imap-&gt;im_numfree
comma
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_numfree
)paren
)paren
suffix:semicolon
id|imap-&gt;im_nbperiext
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_nbperiext
)paren
suffix:semicolon
id|imap-&gt;im_l2nbperiext
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_l2nbperiext
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAXAG
suffix:semicolon
id|index
op_increment
)paren
(brace
id|imap-&gt;im_agctl
(braket
id|index
)braket
dot
id|inofree
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|inofree
)paren
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|index
)braket
dot
id|extfree
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|extfree
)paren
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|index
)braket
dot
id|numinos
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|numinos
)paren
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|index
)braket
dot
id|numfree
op_assign
id|le32_to_cpu
c_func
(paren
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|numfree
)paren
suffix:semicolon
)brace
multiline_comment|/* release the buffer. */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * allocate/initialize inode allocation map locks&n;&t; */
multiline_comment|/* allocate and init iag free list lock */
id|IAGFREE_LOCK_INIT
c_func
(paren
id|imap
)paren
suffix:semicolon
multiline_comment|/* allocate and init ag list locks */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAXAG
suffix:semicolon
id|index
op_increment
)paren
(brace
id|AG_LOCK_INIT
c_func
(paren
id|imap
comma
id|index
)paren
suffix:semicolon
)brace
multiline_comment|/* bind the inode map inode and inode map control structure&n;&t; * to each other.&n;&t; */
id|imap-&gt;im_ipimap
op_assign
id|ipimap
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
op_assign
id|imap
suffix:semicolon
singleline_comment|//      DBG_DIINIT(imap);
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diUnmount()&n; *&n; * FUNCTION:    write to disk the incore inode map control structures for&n; *&t;&t;a fileset or aggregate at unmount time.&n; *&n; * PARAMETERS:&n; *      ipimap  - pointer to inode map inode for the aggregate or fileset.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      ENOMEM  - insufficient free virtual memory.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diUnmount
r_int
id|diUnmount
c_func
(paren
r_struct
id|inode
op_star
id|ipimap
comma
r_int
id|mounterror
)paren
(brace
id|imap_t
op_star
id|imap
op_assign
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
suffix:semicolon
multiline_comment|/*&n;&t; * update the on-disk inode map control structure&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mounterror
op_logical_or
id|isReadOnly
c_func
(paren
id|ipimap
)paren
)paren
)paren
id|diSync
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Invalidate the page cache buffers&n;&t; */
id|truncate_inode_pages
c_func
(paren
id|ipimap-&gt;i_mapping
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * free in-memory control structure&n;&t; */
id|kfree
c_func
(paren
id|imap
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;diSync()&n; */
DECL|function|diSync
r_int
id|diSync
c_func
(paren
r_struct
id|inode
op_star
id|ipimap
)paren
(brace
id|dinomap_t
op_star
id|dinom_le
suffix:semicolon
id|imap_t
op_star
id|imp
op_assign
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
r_int
id|index
suffix:semicolon
multiline_comment|/*&n;&t; * write imap global conrol page&n;&t; */
multiline_comment|/* read the on-disk inode map control structure */
id|mp
op_assign
id|get_metapage
c_func
(paren
id|ipimap
comma
id|IMAPBLKNO
op_lshift
id|JFS_SBI
c_func
(paren
id|ipimap-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2nbperpage
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diSync: get_metapage failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/* copy the in-memory version to the on-disk version */
singleline_comment|//memcpy(mp-&gt;data, &amp;imp-&gt;im_imap,sizeof(dinomap_t));
id|dinom_le
op_assign
(paren
id|dinomap_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|dinom_le-&gt;in_freeiag
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_freeiag
)paren
suffix:semicolon
id|dinom_le-&gt;in_nextiag
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_nextiag
)paren
suffix:semicolon
id|dinom_le-&gt;in_numinos
op_assign
id|cpu_to_le32
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|imp-&gt;im_numinos
)paren
)paren
suffix:semicolon
id|dinom_le-&gt;in_numfree
op_assign
id|cpu_to_le32
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|imp-&gt;im_numfree
)paren
)paren
suffix:semicolon
id|dinom_le-&gt;in_nbperiext
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_nbperiext
)paren
suffix:semicolon
id|dinom_le-&gt;in_l2nbperiext
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_l2nbperiext
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAXAG
suffix:semicolon
id|index
op_increment
)paren
(brace
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|inofree
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_agctl
(braket
id|index
)braket
dot
id|inofree
)paren
suffix:semicolon
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|extfree
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_agctl
(braket
id|index
)braket
dot
id|extfree
)paren
suffix:semicolon
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|numinos
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_agctl
(braket
id|index
)braket
dot
id|numinos
)paren
suffix:semicolon
id|dinom_le-&gt;in_agctl
(braket
id|index
)braket
dot
id|numfree
op_assign
id|cpu_to_le32
c_func
(paren
id|imp-&gt;im_agctl
(braket
id|index
)braket
dot
id|numfree
)paren
suffix:semicolon
)brace
multiline_comment|/* write out the control structure */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * write out dirty pages of imap&n;&t; */
id|filemap_fdatawait
c_func
(paren
id|ipimap-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawrite
c_func
(paren
id|ipimap-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|ipimap-&gt;i_mapping
)paren
suffix:semicolon
id|diWriteSpecial
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diRead()&n; *&n; * FUNCTION:    initialize an incore inode from disk.&n; *&n; *&t;&t;on entry, the specifed incore inode should itself&n; *&t;&t;specify the disk inode number corresponding to the&n; *&t;&t;incore inode (i.e. i_number should be initialized).&n; *&t;&t;&n; *&t;&t;this routine handles incore inode initialization for&n; *&t;&t;both &quot;special&quot; and &quot;regular&quot; inodes.  special inodes&n; *&t;&t;are those required early in the mount process and&n; *&t;        require special handling since much of the file system&n; *&t;&t;is not yet initialized.  these &quot;special&quot; inodes are&n; *&t;&t;identified by a NULL inode map inode pointer and are&n; *&t;&t;actually initialized by a call to diReadSpecial().&n; *&t;&t;&n; *&t;&t;for regular inodes, the iag describing the disk inode&n; *&t;&t;is read from disk to determine the inode extent address&n; *&t;&t;for the disk inode.  with the inode extent address in&n; *&t;&t;hand, the page of the extent that contains the disk&n; *&t;&t;inode is read and the disk inode is copied to the&n; *&t;&t;incore inode.&n; *&n; * PARAMETERS:&n; *      ip  -  pointer to incore inode to be initialized from disk.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO  &t;- i/o error.&n; *      ENOMEM&t;- insufficient memory&n; *      &n; */
DECL|function|diRead
r_int
id|diRead
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
r_int
id|iagno
comma
id|ino
comma
id|extno
comma
id|rc
suffix:semicolon
r_struct
id|inode
op_star
id|ipimap
suffix:semicolon
id|dinode_t
op_star
id|dp
suffix:semicolon
id|iag_t
op_star
id|iagp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|s64
id|blkno
comma
id|agstart
suffix:semicolon
id|imap_t
op_star
id|imap
suffix:semicolon
r_int
id|block_offset
suffix:semicolon
r_int
id|inodes_left
suffix:semicolon
id|uint
id|pageno
suffix:semicolon
r_int
id|rel_inode
suffix:semicolon
id|jFYI
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diRead: ino = %ld&bslash;n&quot;
comma
id|ip-&gt;i_ino
)paren
)paren
suffix:semicolon
id|ipimap
op_assign
id|sbi-&gt;ipimap
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ipimap
op_assign
id|ipimap
suffix:semicolon
multiline_comment|/* determine the iag number for this inode (number) */
id|iagno
op_assign
id|INOTOIAG
c_func
(paren
id|ip-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/* read the iag */
id|imap
op_assign
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
suffix:semicolon
id|IREAD_LOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|iagno
comma
op_amp
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diRead: diIAGRead returned %d&bslash;n&quot;
comma
id|rc
)paren
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* determine inode extent that holds the disk inode */
id|ino
op_assign
id|ip-&gt;i_ino
op_amp
(paren
id|INOSPERIAG
op_minus
l_int|1
)paren
suffix:semicolon
id|extno
op_assign
id|ino
op_rshift
id|L2INOSPEREXT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lengthPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
op_ne
id|imap-&gt;im_nbperiext
)paren
op_logical_or
(paren
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diRead: Bad inoext: 0x%lx, 0x%lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
comma
(paren
id|ulong
)paren
id|lengthPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
)paren
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
r_return
id|ESTALE
suffix:semicolon
)brace
multiline_comment|/* get disk block number of the page within the inode extent&n;&t; * that holds the disk inode.&n;&t; */
id|blkno
op_assign
id|INOPBLK
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
comma
id|ino
comma
id|sbi-&gt;l2nbperpage
)paren
suffix:semicolon
multiline_comment|/* get the ag for the iag */
id|agstart
op_assign
id|le64_to_cpu
c_func
(paren
id|iagp-&gt;agstart
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|rel_inode
op_assign
(paren
id|ino
op_amp
(paren
id|INOSPERPAGE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|pageno
op_assign
id|blkno
op_rshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
r_if
c_cond
(paren
(paren
id|block_offset
op_assign
(paren
(paren
id|u32
)paren
id|blkno
op_amp
(paren
id|sbi-&gt;nbperpage
op_minus
l_int|1
)paren
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * OS/2 didn&squot;t always align inode extents on page boundaries&n;&t;&t; */
id|inodes_left
op_assign
(paren
id|sbi-&gt;nbperpage
op_minus
id|block_offset
)paren
op_lshift
id|sbi-&gt;l2niperblk
suffix:semicolon
r_if
c_cond
(paren
id|rel_inode
OL
id|inodes_left
)paren
id|rel_inode
op_add_assign
id|block_offset
op_lshift
id|sbi-&gt;l2niperblk
suffix:semicolon
r_else
(brace
id|pageno
op_add_assign
l_int|1
suffix:semicolon
id|rel_inode
op_sub_assign
id|inodes_left
suffix:semicolon
)brace
)brace
multiline_comment|/* read the page of disk inode */
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipimap
comma
id|pageno
op_lshift
id|sbi-&gt;l2nbperpage
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|0
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diRead: read_metapage failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/* locate the the disk inode requested */
id|dp
op_assign
(paren
id|dinode_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|dp
op_add_assign
id|rel_inode
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_ino
op_ne
id|le32_to_cpu
c_func
(paren
id|dp-&gt;di_number
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diRead: i_ino != di_number&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
id|rc
op_assign
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|dp-&gt;di_nlink
)paren
op_eq
l_int|0
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diRead: di_nlink is zero. ino=%ld&bslash;n&quot;
comma
id|ip-&gt;i_ino
)paren
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
id|rc
op_assign
id|ESTALE
suffix:semicolon
)brace
r_else
multiline_comment|/* copy the disk inode to the in-memory inode */
id|rc
op_assign
id|copy_from_dinode
c_func
(paren
id|dp
comma
id|ip
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* set the ag for the inode */
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|agno
op_assign
id|BLKTOAG
c_func
(paren
id|agstart
comma
id|sbi
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diReadSpecial()&n; *&n; * FUNCTION:    initialize a &squot;special&squot; inode from disk.&n; *&n; *&t;&t;this routines handles aggregate level inodes.  The&n; *&t;&t;inode cache cannot differentiate between the&n; *&t;&t;aggregate inodes and the filesystem inodes, so we&n; *&t;&t;handle these here.  We don&squot;t actually use the aggregate&n; *&t;        inode map, since these inodes are at a fixed location&n; *&t;&t;and in some cases the aggregate inode map isn&squot;t initialized&n; *&t;&t;yet.&n; *&n; * PARAMETERS:&n; *      sb - filesystem superblock&n; *&t;inum - aggregate inode number&n; *&n; * RETURN VALUES:&n; *      new inode&t;- success&n; *      NULL&t;&t;- i/o error.&n; */
DECL|function|diReadSpecial
r_struct
id|inode
op_star
id|diReadSpecial
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|ino_t
id|inum
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
id|uint
id|address
suffix:semicolon
id|dinode_t
op_star
id|dp
suffix:semicolon
r_struct
id|inode
op_star
id|ip
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|ip
op_assign
id|new_inode
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diReadSpecial: new_inode returned NULL!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ip
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If ip-&gt;i_number &gt;= 32 (INOSPEREXT), then read from secondary&n;&t; * aggregate inode table.&n;&t; */
r_if
c_cond
(paren
id|inum
op_ge
id|INOSPEREXT
)paren
(brace
id|address
op_assign
id|addressPXD
c_func
(paren
op_amp
id|sbi-&gt;ait2
)paren
op_rshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
id|inum
op_sub_assign
id|INOSPEREXT
suffix:semicolon
id|ASSERT
c_func
(paren
id|inum
OL
id|INOSPEREXT
)paren
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ipimap
op_assign
id|sbi-&gt;ipaimap2
suffix:semicolon
)brace
r_else
(brace
id|address
op_assign
id|AITBL_OFF
op_rshift
id|L2PSIZE
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ipimap
op_assign
id|sbi-&gt;ipaimap
suffix:semicolon
)brace
id|ip-&gt;i_ino
op_assign
id|inum
suffix:semicolon
id|address
op_add_assign
id|inum
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* 8 inodes per 4K page */
multiline_comment|/* read the page of fixed disk inode (AIT) in raw mode */
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;Reading aggregate inode %d from block %d&bslash;n&quot;
comma
(paren
id|uint
)paren
id|inum
comma
id|address
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ip
comma
id|address
op_lshift
id|sbi-&gt;l2nbperpage
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|ip-&gt;i_sb
op_assign
l_int|NULL
suffix:semicolon
id|ip-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t want iput() deleting it */
id|iput
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* get the pointer to the disk inode of interest */
id|dp
op_assign
(paren
id|dinode_t
op_star
)paren
(paren
id|mp-&gt;data
)paren
suffix:semicolon
id|dp
op_add_assign
id|inum
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* 8 inodes per 4K page */
multiline_comment|/* copy on-disk inode to in-memory inode */
r_if
c_cond
(paren
(paren
id|copy_from_dinode
c_func
(paren
id|dp
comma
id|ip
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* handle bad return by returning NULL for ip */
id|ip-&gt;i_sb
op_assign
l_int|NULL
suffix:semicolon
id|ip-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t want iput() deleting it */
id|iput
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/* release the page */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|ip-&gt;i_mapping-&gt;a_ops
op_assign
op_amp
id|jfs_aops
suffix:semicolon
id|ip-&gt;i_mapping-&gt;gfp_mask
op_assign
id|GFP_NOFS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inum
op_eq
id|FILESYSTEM_I
)paren
op_logical_and
(paren
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ipimap
op_eq
id|sbi-&gt;ipaimap
)paren
)paren
(brace
id|sbi-&gt;gengen
op_assign
id|le32_to_cpu
c_func
(paren
id|dp-&gt;di_gengen
)paren
suffix:semicolon
id|sbi-&gt;inostamp
op_assign
id|le32_to_cpu
c_func
(paren
id|dp-&gt;di_inostamp
)paren
suffix:semicolon
)brace
multiline_comment|/* release the page */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diWriteSpecial()&n; *&n; * FUNCTION:    Write the special inode to disk&n; *&n; * PARAMETERS:&n; *      ip - special inode&n; *&n; * RETURN VALUES: none&n; */
DECL|function|diWriteSpecial
r_void
id|diWriteSpecial
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
id|uint
id|address
suffix:semicolon
id|dinode_t
op_star
id|dp
suffix:semicolon
id|ino_t
id|inum
op_assign
id|ip-&gt;i_ino
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
multiline_comment|/*&n;&t; * If ip-&gt;i_number &gt;= 32 (INOSPEREXT), then write to secondary&n;&t; * aggregate inode table.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ip-&gt;i_state
op_amp
id|I_DIRTY
)paren
)paren
r_return
suffix:semicolon
id|ip-&gt;i_state
op_and_assign
op_complement
id|I_DIRTY
suffix:semicolon
r_if
c_cond
(paren
id|inum
op_ge
id|INOSPEREXT
)paren
(brace
id|address
op_assign
id|addressPXD
c_func
(paren
op_amp
id|sbi-&gt;ait2
)paren
op_rshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
id|inum
op_sub_assign
id|INOSPEREXT
suffix:semicolon
id|ASSERT
c_func
(paren
id|inum
OL
id|INOSPEREXT
)paren
suffix:semicolon
)brace
r_else
(brace
id|address
op_assign
id|AITBL_OFF
op_rshift
id|L2PSIZE
suffix:semicolon
)brace
id|address
op_add_assign
id|inum
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* 8 inodes per 4K page */
multiline_comment|/* read the page of fixed disk inode (AIT) in raw mode */
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;Reading aggregate inode %d from block %d&bslash;n&quot;
comma
(paren
id|uint
)paren
id|inum
comma
id|address
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ip
comma
id|address
op_lshift
id|sbi-&gt;l2nbperpage
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|NULL
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diWriteSpecial: failed to read aggregate inode extent!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* get the pointer to the disk inode of interest */
id|dp
op_assign
(paren
id|dinode_t
op_star
)paren
(paren
id|mp-&gt;data
)paren
suffix:semicolon
id|dp
op_add_assign
id|inum
op_mod
l_int|8
suffix:semicolon
multiline_comment|/* 8 inodes per 4K page */
multiline_comment|/* copy on-disk inode to in-memory inode */
id|copy_to_dinode
c_func
(paren
id|dp
comma
id|ip
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dp-&gt;di_xtroot
comma
op_amp
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|i_xtroot
comma
l_int|288
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inum
op_eq
id|FILESYSTEM_I
)paren
id|dp-&gt;di_gengen
op_assign
id|cpu_to_le32
c_func
(paren
id|sbi-&gt;gengen
)paren
suffix:semicolon
multiline_comment|/* write the page */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diFreeSpecial()&n; *&n; * FUNCTION:    Free allocated space for special inode&n; */
DECL|function|diFreeSpecial
r_void
id|diFreeSpecial
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diFreeSpecial called with NULL ip!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|filemap_fdatawait
c_func
(paren
id|ip-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawrite
c_func
(paren
id|ip-&gt;i_mapping
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|ip-&gt;i_mapping
)paren
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
id|ip-&gt;i_mapping
comma
l_int|0
)paren
suffix:semicolon
id|iput
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diWrite()&n; *&n; * FUNCTION:    write the on-disk inode portion of the in-memory inode&n; *&t;&t;to its corresponding on-disk inode.&n; *&n; *&t;&t;on entry, the specifed incore inode should itself&n; *&t;&t;specify the disk inode number corresponding to the&n; *&t;&t;incore inode (i.e. i_number should be initialized).&n; *&n; *&t;&t;the inode contains the inode extent address for the disk&n; *&t;&t;inode.  with the inode extent address in hand, the&n; *&t;&t;page of the extent that contains the disk inode is&n; *&t;&t;read and the disk inode portion of the incore inode&n; *&t;&t;is copied to the disk inode.&n; *&t;&t;&n; * PARAMETERS:&n; *&t;tid -  transacation id&n; *      ip  -  pointer to incore inode to be written to the inode extent.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diWrite
r_int
id|diWrite
c_func
(paren
id|tid_t
id|tid
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|s32
id|ino
suffix:semicolon
id|dinode_t
op_star
id|dp
suffix:semicolon
id|s64
id|blkno
suffix:semicolon
r_int
id|block_offset
suffix:semicolon
r_int
id|inodes_left
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|uint
id|pageno
suffix:semicolon
r_int
id|rel_inode
suffix:semicolon
r_int
id|dioffset
suffix:semicolon
r_struct
id|inode
op_star
id|ipimap
suffix:semicolon
id|uint
id|type
suffix:semicolon
id|lid_t
id|lid
suffix:semicolon
id|tlock_t
op_star
id|ditlck
comma
op_star
id|tlck
suffix:semicolon
id|linelock_t
op_star
id|dilinelock
comma
op_star
id|ilinelock
suffix:semicolon
id|lv_t
op_star
id|lv
suffix:semicolon
r_int
id|n
suffix:semicolon
id|ipimap
op_assign
id|jfs_ip-&gt;ipimap
suffix:semicolon
id|ino
op_assign
id|ip-&gt;i_ino
op_amp
(paren
id|INOSPERIAG
op_minus
l_int|1
)paren
suffix:semicolon
m_assert
(paren
id|lengthPXD
c_func
(paren
op_amp
(paren
id|jfs_ip-&gt;ixpxd
)paren
)paren
op_eq
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap-&gt;im_nbperiext
)paren
suffix:semicolon
m_assert
(paren
id|addressPXD
c_func
(paren
op_amp
(paren
id|jfs_ip-&gt;ixpxd
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * read the page of disk inode containing the specified inode:&n;&t; */
multiline_comment|/* compute the block address of the page */
id|blkno
op_assign
id|INOPBLK
c_func
(paren
op_amp
(paren
id|jfs_ip-&gt;ixpxd
)paren
comma
id|ino
comma
id|sbi-&gt;l2nbperpage
)paren
suffix:semicolon
id|rel_inode
op_assign
(paren
id|ino
op_amp
(paren
id|INOSPERPAGE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|pageno
op_assign
id|blkno
op_rshift
id|sbi-&gt;l2nbperpage
suffix:semicolon
r_if
c_cond
(paren
(paren
id|block_offset
op_assign
(paren
(paren
id|u32
)paren
id|blkno
op_amp
(paren
id|sbi-&gt;nbperpage
op_minus
l_int|1
)paren
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * OS/2 didn&squot;t always align inode extents on page boundaries&n;&t;&t; */
id|inodes_left
op_assign
(paren
id|sbi-&gt;nbperpage
op_minus
id|block_offset
)paren
op_lshift
id|sbi-&gt;l2niperblk
suffix:semicolon
r_if
c_cond
(paren
id|rel_inode
OL
id|inodes_left
)paren
id|rel_inode
op_add_assign
id|block_offset
op_lshift
id|sbi-&gt;l2niperblk
suffix:semicolon
r_else
(brace
id|pageno
op_add_assign
l_int|1
suffix:semicolon
id|rel_inode
op_sub_assign
id|inodes_left
suffix:semicolon
)brace
)brace
multiline_comment|/* read the page of disk inode */
id|retry
suffix:colon
id|mp
op_assign
id|read_metapage
c_func
(paren
id|ipimap
comma
id|pageno
op_lshift
id|sbi-&gt;l2nbperpage
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp
op_eq
l_int|0
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/* get the pointer to the disk inode */
id|dp
op_assign
(paren
id|dinode_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
id|dp
op_add_assign
id|rel_inode
suffix:semicolon
id|dioffset
op_assign
(paren
id|ino
op_amp
(paren
id|INOSPERPAGE
op_minus
l_int|1
)paren
)paren
op_lshift
id|L2DISIZE
suffix:semicolon
multiline_comment|/*&n;&t; * acquire transaction lock on the on-disk inode;&n;&t; * N.B. tlock is acquired on ipimap not ip;&n;&t; */
r_if
c_cond
(paren
(paren
id|ditlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ipimap
comma
id|mp
comma
id|tlckINODE
op_or
id|tlckENTRY
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|retry
suffix:semicolon
id|dilinelock
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|ditlck-&gt;lock
suffix:semicolon
multiline_comment|/*&n;&t; * copy btree root from in-memory inode to on-disk inode&n;&t; *&n;&t; * (tlock is taken from inline B+-tree root in in-memory&n;&t; * inode when the B+-tree root is updated, which is pointed &n;&t; * by jfs_ip-&gt;blid as well as being on tx tlock list)&n;&t; *&n;&t; * further processing of btree root is based on the copy &n;&t; * in in-memory inode, where txLog() will log from, and, &n;&t; * for xtree root, txUpdateMap() will update map and reset&n;&t; * XAD_NEW bit;&n;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
op_logical_and
(paren
id|lid
op_assign
id|jfs_ip-&gt;xtlid
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This is the special xtree inside the directory for storing&n;&t;&t; * the directory table&n;&t;&t; */
id|xtpage_t
op_star
id|p
comma
op_star
id|xp
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
id|jfs_ip-&gt;xtlid
op_assign
l_int|0
suffix:semicolon
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
m_assert
(paren
id|tlck-&gt;type
op_amp
id|tlckXTREE
)paren
suffix:semicolon
id|tlck-&gt;type
op_or_assign
id|tlckBTROOT
suffix:semicolon
id|tlck-&gt;mp
op_assign
id|mp
suffix:semicolon
id|ilinelock
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/*&n;&t;&t; * copy xtree root from inode to dinode:&n;&t;&t; */
id|p
op_assign
op_amp
id|jfs_ip-&gt;i_xtroot
suffix:semicolon
id|xp
op_assign
(paren
id|xtpage_t
op_star
)paren
op_amp
id|dp-&gt;di_dirtable
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|ilinelock-&gt;lv
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|ilinelock-&gt;index
suffix:semicolon
id|n
op_increment
comma
id|lv
op_increment
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|xp-&gt;xad
(braket
id|lv-&gt;offset
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|lv-&gt;offset
)braket
comma
id|lv-&gt;length
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* reset on-disk (metadata page) xtree XAD_NEW bit */
id|xad
op_assign
op_amp
id|xp-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|XTENTRYSTART
suffix:semicolon
id|n
OL
id|le16_to_cpu
c_func
(paren
id|xp-&gt;header.nextindex
)paren
suffix:semicolon
id|n
op_increment
comma
id|xad
op_increment
)paren
r_if
c_cond
(paren
id|xad-&gt;flag
op_amp
(paren
id|XAD_NEW
op_or
id|XAD_EXTENDED
)paren
)paren
id|xad-&gt;flag
op_and_assign
op_complement
(paren
id|XAD_NEW
op_or
id|XAD_EXTENDED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lid
op_assign
id|jfs_ip-&gt;blid
)paren
op_eq
l_int|0
)paren
r_goto
id|inlineData
suffix:semicolon
id|jfs_ip-&gt;blid
op_assign
l_int|0
suffix:semicolon
id|tlck
op_assign
id|lid_to_tlock
c_func
(paren
id|lid
)paren
suffix:semicolon
id|type
op_assign
id|tlck-&gt;type
suffix:semicolon
id|tlck-&gt;type
op_or_assign
id|tlckBTROOT
suffix:semicolon
id|tlck-&gt;mp
op_assign
id|mp
suffix:semicolon
id|ilinelock
op_assign
(paren
id|linelock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
multiline_comment|/*&n;&t; *      regular file: 16 byte (XAD slot) granularity&n;&t; */
r_if
c_cond
(paren
id|type
op_amp
id|tlckXTREE
)paren
(brace
id|xtpage_t
op_star
id|p
comma
op_star
id|xp
suffix:semicolon
id|xad_t
op_star
id|xad
suffix:semicolon
multiline_comment|/*&n;&t;&t; * copy xtree root from inode to dinode:&n;&t;&t; */
id|p
op_assign
op_amp
id|jfs_ip-&gt;i_xtroot
suffix:semicolon
id|xp
op_assign
op_amp
id|dp-&gt;di_xtroot
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|ilinelock-&gt;lv
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|ilinelock-&gt;index
suffix:semicolon
id|n
op_increment
comma
id|lv
op_increment
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|xp-&gt;xad
(braket
id|lv-&gt;offset
)braket
comma
op_amp
id|p-&gt;xad
(braket
id|lv-&gt;offset
)braket
comma
id|lv-&gt;length
op_lshift
id|L2XTSLOTSIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* reset on-disk (metadata page) xtree XAD_NEW bit */
id|xad
op_assign
op_amp
id|xp-&gt;xad
(braket
id|XTENTRYSTART
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|XTENTRYSTART
suffix:semicolon
id|n
OL
id|le16_to_cpu
c_func
(paren
id|xp-&gt;header.nextindex
)paren
suffix:semicolon
id|n
op_increment
comma
id|xad
op_increment
)paren
r_if
c_cond
(paren
id|xad-&gt;flag
op_amp
(paren
id|XAD_NEW
op_or
id|XAD_EXTENDED
)paren
)paren
id|xad-&gt;flag
op_and_assign
op_complement
(paren
id|XAD_NEW
op_or
id|XAD_EXTENDED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      directory: 32 byte (directory entry slot) granularity&n;&t; */
r_else
r_if
c_cond
(paren
id|type
op_amp
id|tlckDTREE
)paren
(brace
id|dtpage_t
op_star
id|p
comma
op_star
id|xp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * copy dtree root from inode to dinode:&n;&t;&t; */
id|p
op_assign
(paren
id|dtpage_t
op_star
)paren
op_amp
id|jfs_ip-&gt;i_dtroot
suffix:semicolon
id|xp
op_assign
(paren
id|dtpage_t
op_star
)paren
op_amp
id|dp-&gt;di_dtroot
suffix:semicolon
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|ilinelock-&gt;lv
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|ilinelock-&gt;index
suffix:semicolon
id|n
op_increment
comma
id|lv
op_increment
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|xp-&gt;slot
(braket
id|lv-&gt;offset
)braket
comma
op_amp
id|p-&gt;slot
(braket
id|lv-&gt;offset
)braket
comma
id|lv-&gt;length
op_lshift
id|L2DTSLOTSIZE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diWrite: UFO tlock&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|inlineData
suffix:colon
multiline_comment|/*&n;&t; * copy inline symlink from in-memory inode to on-disk inode&n;&t; */
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|ip-&gt;i_mode
)paren
op_logical_and
id|ip-&gt;i_size
OL
id|IDATASIZE
)paren
(brace
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dilinelock-&gt;lv
(braket
id|dilinelock-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
(paren
id|dioffset
op_plus
l_int|2
op_star
l_int|128
)paren
op_rshift
id|L2INODESLOTSIZE
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dp-&gt;di_fastsymlink
comma
id|jfs_ip-&gt;i_inline
comma
id|IDATASIZE
)paren
suffix:semicolon
id|dilinelock-&gt;index
op_increment
suffix:semicolon
)brace
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/*&n;&t; * copy inline data from in-memory inode to on-disk inode:&n;&t; * 128 byte slot granularity&n;&t; */
r_if
c_cond
(paren
id|test_cflag
c_func
(paren
id|COMMIT_Inlineea
comma
id|ip
)paren
)paren
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dilinelock-&gt;lv
(braket
id|dilinelock-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
(paren
id|dioffset
op_plus
l_int|3
op_star
l_int|128
)paren
op_rshift
id|L2INODESLOTSIZE
suffix:semicolon
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dp-&gt;di_inlineea
comma
op_amp
id|ip-&gt;i_inlineea
comma
id|INODESLOTSIZE
)paren
suffix:semicolon
id|dilinelock-&gt;index
op_increment
suffix:semicolon
id|clear_cflag
c_func
(paren
id|COMMIT_Inlineea
comma
id|ip
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _STILL_TO_PORT */
multiline_comment|/*&n;&t; *      lock/copy inode base: 128 byte slot granularity&n;&t; */
singleline_comment|// baseDinode:
id|lv
op_assign
(paren
id|lv_t
op_star
)paren
op_amp
id|dilinelock-&gt;lv
(braket
id|dilinelock-&gt;index
)braket
suffix:semicolon
id|lv-&gt;offset
op_assign
id|dioffset
op_rshift
id|L2INODESLOTSIZE
suffix:semicolon
id|copy_to_dinode
c_func
(paren
id|dp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_cflag
c_func
(paren
id|COMMIT_Dirtable
comma
id|ip
)paren
)paren
(brace
id|lv-&gt;length
op_assign
l_int|2
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dp-&gt;di_dirtable
comma
op_amp
id|jfs_ip-&gt;i_dirtable
comma
l_int|96
)paren
suffix:semicolon
)brace
r_else
id|lv-&gt;length
op_assign
l_int|1
suffix:semicolon
id|dilinelock-&gt;index
op_increment
suffix:semicolon
macro_line|#ifdef _JFS_FASTDASD
multiline_comment|/*&n;&t; * We aren&squot;t logging changes to the DASD used in directory inodes,&n;&t; * but we need to write them to disk.  If we don&squot;t unmount cleanly,&n;&t; * mount will recalculate the DASD used.&n;&t; */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
op_logical_and
(paren
id|ip-&gt;i_ipmnt-&gt;i_mntflag
op_amp
id|JFS_DASD_ENABLED
)paren
)paren
id|bcopy
c_func
(paren
op_amp
id|ip-&gt;i_DASD
comma
op_amp
id|dp-&gt;di_DASD
comma
r_sizeof
(paren
id|dasd_t
)paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  _JFS_FASTDASD */
multiline_comment|/* release the buffer holding the updated on-disk inode. &n;&t; * the buffer will be later written by commit processing.&n;&t; */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diFree(ip)&n; *&n; * FUNCTION:    free a specified inode from the inode working map&n; *&t;&t;for a fileset or aggregate.&n; *&n; *&t;&t;if the inode to be freed represents the first (only)&n; *&t;&t;free inode within the iag, the iag will be placed on&n; *&t;&t;the ag free inode list.&n; *&t;&n; *&t;&t;freeing the inode will cause the inode extent to be&n; *&t;&t;freed if the inode is the only allocated inode within&n; *&t;&t;the extent.  in this case all the disk resource backing&n; *&t;&t;up the inode extent will be freed. in addition, the iag&n; *&t;&t;will be placed on the ag extent free list if the extent&n; *&t;&t;is the first free extent in the iag.  if freeing the&n; *&t;&t;extent also means that no free inodes will exist for&n; *&t;&t;the iag, the iag will also be removed from the ag free&n; *&t;&t;inode list.&n; *&n; *&t;&t;the iag describing the inode will be freed if the extent&n; *&t;&t;is to be freed and it is the only backed extent within&n; *&t;&t;the iag.  in this case, the iag will be removed from the&n; *&t;&t;ag free extent list and ag free inode list and placed on&n; *&t;&t;the inode map&squot;s free iag list.&n; *&n; *&t;&t;a careful update approach is used to provide consistency&n; *&t;&t;in the face of updates to multiple buffers.  under this&n; *&t;&t;approach, all required buffers are obtained before making&n; *&t;&t;any updates and are held until all updates are complete.&n; *&n; * PARAMETERS:&n; *      ip  &t;- inode to be freed.&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diFree
r_int
id|diFree
c_func
(paren
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|rc
suffix:semicolon
id|ino_t
id|inum
op_assign
id|ip-&gt;i_ino
suffix:semicolon
id|iag_t
op_star
id|iagp
comma
op_star
id|aiagp
comma
op_star
id|biagp
comma
op_star
id|ciagp
comma
op_star
id|diagp
suffix:semicolon
id|metapage_t
op_star
id|mp
comma
op_star
id|amp
comma
op_star
id|bmp
comma
op_star
id|cmp
comma
op_star
id|dmp
suffix:semicolon
r_int
id|iagno
comma
id|ino
comma
id|extno
comma
id|bitno
comma
id|sword
comma
id|agno
suffix:semicolon
r_int
id|back
comma
id|fwd
suffix:semicolon
id|u32
id|bitmap
comma
id|mask
suffix:semicolon
r_struct
id|inode
op_star
id|ipimap
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipimap
suffix:semicolon
id|imap_t
op_star
id|imap
op_assign
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
suffix:semicolon
id|s64
id|xaddr
suffix:semicolon
id|s64
id|xlen
suffix:semicolon
id|pxd_t
id|freepxd
suffix:semicolon
id|tid_t
id|tid
suffix:semicolon
r_struct
id|inode
op_star
id|iplist
(braket
l_int|3
)braket
suffix:semicolon
id|tlock_t
op_star
id|tlck
suffix:semicolon
id|pxdlock_t
op_star
id|pxdlock
suffix:semicolon
multiline_comment|/*&n;&t; * This is just to suppress compiler warnings.  The same logic that&n;&t; * references these variables is used to initialize them.&n;&t; */
id|aiagp
op_assign
id|biagp
op_assign
id|ciagp
op_assign
id|diagp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get the iag number containing the inode.&n;&t; */
id|iagno
op_assign
id|INOTOIAG
c_func
(paren
id|inum
)paren
suffix:semicolon
multiline_comment|/* make sure that the iag is contained within &n;&t; * the map.&n;&t; */
singleline_comment|//assert(iagno &lt; imap-&gt;im_nextiag);
r_if
c_cond
(paren
id|iagno
op_ge
id|imap-&gt;im_nextiag
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diFree: inum = %d, iagno = %d, nextiag = %d&bslash;n&quot;
comma
(paren
id|uint
)paren
id|inum
comma
id|iagno
comma
id|imap-&gt;im_nextiag
)paren
)paren
suffix:semicolon
id|dump_mem
c_func
(paren
l_string|&quot;imap&quot;
comma
id|imap
comma
l_int|32
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/* get the allocation group for this ino.&n;&t; */
id|agno
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|agno
suffix:semicolon
multiline_comment|/* Lock the AG specific inode map information&n;&t; */
id|AG_LOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
multiline_comment|/* Obtain read lock in imap inode.  Don&squot;t release it until we have&n;&t; * read all of the IAG&squot;s that we are going to.&n;&t; */
id|IREAD_LOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/* read the iag.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|iagno
comma
op_amp
id|mp
)paren
)paren
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* get the inode number and extent number of the inode within&n;&t; * the iag and the inode number within the extent.&n;&t; */
id|ino
op_assign
id|inum
op_amp
(paren
id|INOSPERIAG
op_minus
l_int|1
)paren
suffix:semicolon
id|extno
op_assign
id|ino
op_rshift
id|L2INOSPEREXT
suffix:semicolon
id|bitno
op_assign
id|ino
op_amp
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
suffix:semicolon
id|mask
op_assign
id|HIGHORDER
op_rshift
id|bitno
suffix:semicolon
m_assert
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
m_assert
(paren
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;pmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
m_assert
(paren
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/* compute the bitmap for the extent reflecting the freed inode.&n;&t; */
id|bitmap
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
op_amp
op_complement
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
OG
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numinos
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diFree: numfree &gt; numinos&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      inode extent still has some inodes or below low water mark:&n;&t; *      keep the inode extent;&n;&t; */
r_if
c_cond
(paren
id|bitmap
op_logical_or
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
OL
l_int|96
op_logical_or
(paren
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
OL
l_int|288
op_logical_and
(paren
(paren
(paren
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
op_star
l_int|100
)paren
op_div
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numinos
)paren
op_le
l_int|25
)paren
)paren
)paren
(brace
multiline_comment|/* if the iag currently has no free inodes (i.e.,&n;&t;&t; * the inode being freed is the first free inode of iag),&n;&t;&t; * insert the iag at head of the inode free list for the ag.&n;&t;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check if there are any iags on the ag inode&n;&t;&t;&t; * free list.  if so, read the first one so that&n;&t;&t;&t; * we can link the current iag onto the list at&n;&t;&t;&t; * the head.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|fwd
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* read the iag that currently is the head&n;&t;&t;&t;&t; * of the list.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|fwd
comma
op_amp
id|amp
)paren
)paren
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|aiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
multiline_comment|/* make current head point back to the iag.&n;&t;&t;&t;&t; */
id|aiagp-&gt;inofreeback
op_assign
id|cpu_to_le32
c_func
(paren
id|iagno
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|amp
)paren
suffix:semicolon
)brace
multiline_comment|/* iag points forward to current head and iag&n;&t;&t;&t; * becomes the new head of the list.&n;&t;&t;&t; */
id|iagp-&gt;inofreefwd
op_assign
id|cpu_to_le32
c_func
(paren
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
)paren
suffix:semicolon
id|iagp-&gt;inofreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
op_assign
id|iagno
suffix:semicolon
)brace
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/* update the free inode summary map for the extent if&n;&t;&t; * freeing the inode means the extent will now have free&n;&t;&t; * inodes (i.e., the inode being freed is the first free &n;&t;&t; * inode of extent),&n;&t;&t; */
r_if
c_cond
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
op_eq
id|ONES
)paren
(brace
id|sword
op_assign
id|extno
op_rshift
id|L2EXTSPERSUM
suffix:semicolon
id|bitno
op_assign
id|extno
op_amp
(paren
id|EXTSPERSUM
op_minus
l_int|1
)paren
suffix:semicolon
id|iagp-&gt;inosmap
(braket
id|sword
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
(paren
id|HIGHORDER
op_rshift
id|bitno
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* update the bitmap.&n;&t;&t; */
id|iagp-&gt;wmap
(braket
id|extno
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|bitmap
)paren
suffix:semicolon
id|DBG_DIFREE
c_func
(paren
id|imap
comma
id|inum
)paren
suffix:semicolon
multiline_comment|/* update the free inode counts at the iag, ag and&n;&t;&t; * map level.&n;&t;&t; */
id|iagp-&gt;nfreeinos
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeinos
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
op_add_assign
l_int|1
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|imap-&gt;im_numfree
)paren
suffix:semicolon
multiline_comment|/* release the AG inode map lock&n;&t;&t; */
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
multiline_comment|/* write the iag */
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *      inode extent has become free and above low water mark:&n;&t; *      free the inode extent;&n;&t; */
multiline_comment|/*&n;&t; *      prepare to update iag list(s) (careful update step 1)&n;&t; */
id|amp
op_assign
id|bmp
op_assign
id|cmp
op_assign
id|dmp
op_assign
l_int|NULL
suffix:semicolon
id|fwd
op_assign
id|back
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* check if the iag currently has no free extents.  if so,&n;&t; * it will be placed on the head of the ag extent free list.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check if the ag extent free list has any iags.&n;&t;&t; * if so, read the iag at the head of the list now.&n;&t;&t; * this (head) iag will be updated later to reflect&n;&t;&t; * the addition of the current iag at the head of&n;&t;&t; * the list.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|fwd
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|fwd
comma
op_amp
id|amp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
id|aiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* iag has free extents. check if the addition of a free&n;&t;&t; * extent will cause all extents to be free within this&n;&t;&t; * iag.  if so, the iag will be removed from the ag extent&n;&t;&t; * free list and placed on the inode map&squot;s free iag list.&n;&t;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
id|EXTSPERIAG
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* in preparation for removing the iag from the&n;&t;&t;&t; * ag extent free list, read the iags preceeding&n;&t;&t;&t; * and following the iag on the ag extent free&n;&t;&t;&t; * list.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|fwd
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extfreefwd
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|fwd
comma
op_amp
id|amp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
id|aiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|back
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extfreeback
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|back
comma
op_amp
id|bmp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
id|biagp
op_assign
(paren
id|iag_t
op_star
)paren
id|bmp-&gt;data
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* remove the iag from the ag inode free list if freeing&n;&t; * this extent cause the iag to have no free inodes.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_eq
id|cpu_to_le32
c_func
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
)paren
(brace
r_int
id|inofreeback
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreeback
)paren
suffix:semicolon
r_int
id|inofreefwd
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreefwd
)paren
suffix:semicolon
multiline_comment|/* in preparation for removing the iag from the&n;&t;&t; * ag inode free list, read the iags preceeding&n;&t;&t; * and following the iag on the ag inode free&n;&t;&t; * list.  before reading these iags, we must make&n;&t;&t; * sure that we already don&squot;t have them in hand&n;&t;&t; * from up above, since re-reading an iag (buffer)&n;&t;&t; * we are currently holding would cause a deadlock.&n;&t;&t; */
r_if
c_cond
(paren
id|inofreefwd
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|inofreefwd
op_eq
id|fwd
)paren
id|ciagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inofreefwd
op_eq
id|back
)paren
id|ciagp
op_assign
(paren
id|iag_t
op_star
)paren
id|bmp-&gt;data
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|inofreefwd
comma
op_amp
id|cmp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
m_assert
(paren
id|cmp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ciagp
op_assign
(paren
id|iag_t
op_star
)paren
id|cmp-&gt;data
suffix:semicolon
)brace
m_assert
(paren
id|ciagp
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inofreeback
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|inofreeback
op_eq
id|fwd
)paren
id|diagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
r_else
r_if
c_cond
(paren
id|inofreeback
op_eq
id|back
)paren
id|diagp
op_assign
(paren
id|iag_t
op_star
)paren
id|bmp-&gt;data
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|inofreeback
comma
op_amp
id|dmp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
m_assert
(paren
id|dmp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|diagp
op_assign
(paren
id|iag_t
op_star
)paren
id|dmp-&gt;data
suffix:semicolon
)brace
m_assert
(paren
id|diagp
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * invalidate any page of the inode extent freed from buffer cache;&n;&t; */
id|freepxd
op_assign
id|iagp-&gt;inoext
(braket
id|extno
)braket
suffix:semicolon
id|xaddr
op_assign
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
suffix:semicolon
id|xlen
op_assign
id|lengthPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
suffix:semicolon
id|invalidate_metapages
c_func
(paren
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|direct_inode
comma
id|xaddr
comma
id|xlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      update iag list(s) (careful update step 2)&n;&t; */
multiline_comment|/* add the iag to the ag extent free list if this is the&n;&t; * first free extent for the iag.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fwd
op_ge
l_int|0
)paren
id|aiagp-&gt;extfreeback
op_assign
id|cpu_to_le32
c_func
(paren
id|iagno
)paren
suffix:semicolon
id|iagp-&gt;extfreefwd
op_assign
id|cpu_to_le32
c_func
(paren
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
)paren
suffix:semicolon
id|iagp-&gt;extfreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
op_assign
id|iagno
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* remove the iag from the ag extent list if all extents&n;&t;&t; * are now free and place it on the inode map iag free list.&n;&t;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
id|EXTSPERIAG
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|fwd
op_ge
l_int|0
)paren
id|aiagp-&gt;extfreeback
op_assign
id|iagp-&gt;extfreeback
suffix:semicolon
r_if
c_cond
(paren
id|back
op_ge
l_int|0
)paren
id|biagp-&gt;extfreefwd
op_assign
id|iagp-&gt;extfreefwd
suffix:semicolon
r_else
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extfreefwd
)paren
suffix:semicolon
id|iagp-&gt;extfreefwd
op_assign
id|iagp-&gt;extfreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|IAGFREE_LOCK
c_func
(paren
id|imap
)paren
suffix:semicolon
id|iagp-&gt;iagfree
op_assign
id|cpu_to_le32
c_func
(paren
id|imap-&gt;im_freeiag
)paren
suffix:semicolon
id|imap-&gt;im_freeiag
op_assign
id|iagno
suffix:semicolon
id|IAGFREE_UNLOCK
c_func
(paren
id|imap
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* remove the iag from the ag inode free list if freeing&n;&t; * this extent causes the iag to have no free inodes.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_eq
id|cpu_to_le32
c_func
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreefwd
)paren
op_ge
l_int|0
)paren
id|ciagp-&gt;inofreeback
op_assign
id|iagp-&gt;inofreeback
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreeback
)paren
op_ge
l_int|0
)paren
id|diagp-&gt;inofreefwd
op_assign
id|iagp-&gt;inofreefwd
suffix:semicolon
r_else
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreefwd
)paren
suffix:semicolon
id|iagp-&gt;inofreefwd
op_assign
id|iagp-&gt;inofreeback
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* update the inode extent address and working map &n;&t; * to reflect the free extent.&n;&t; * the permanent map should have been updated already &n;&t; * for the inode being freed.&n;&t; */
m_assert
(paren
id|iagp-&gt;pmap
(braket
id|extno
)braket
op_eq
l_int|0
)paren
suffix:semicolon
id|iagp-&gt;wmap
(braket
id|extno
)braket
op_assign
l_int|0
suffix:semicolon
id|DBG_DIFREE
c_func
(paren
id|imap
comma
id|inum
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
comma
l_int|0
)paren
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* update the free extent and free inode summary maps&n;&t; * to reflect the freed extent.&n;&t; * the inode summary map is marked to indicate no inodes &n;&t; * available for the freed extent.&n;&t; */
id|sword
op_assign
id|extno
op_rshift
id|L2EXTSPERSUM
suffix:semicolon
id|bitno
op_assign
id|extno
op_amp
(paren
id|EXTSPERSUM
op_minus
l_int|1
)paren
suffix:semicolon
id|mask
op_assign
id|HIGHORDER
op_rshift
id|bitno
suffix:semicolon
id|iagp-&gt;inosmap
(braket
id|sword
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|mask
)paren
suffix:semicolon
id|iagp-&gt;extsmap
(braket
id|sword
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|mask
)paren
suffix:semicolon
multiline_comment|/* update the number of free inodes and number of free extents&n;&t; * for the iag.&n;&t; */
id|iagp-&gt;nfreeinos
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeinos
)paren
op_minus
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|iagp-&gt;nfreeexts
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeexts
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the number of free inodes and backed inodes&n;&t; * at the ag and inode map level.&n;&t; */
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
op_sub_assign
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numinos
op_sub_assign
id|INOSPEREXT
suffix:semicolon
id|atomic_sub
c_func
(paren
id|INOSPEREXT
op_minus
l_int|1
comma
op_amp
id|imap-&gt;im_numfree
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|INOSPEREXT
comma
op_amp
id|imap-&gt;im_numinos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amp
)paren
id|write_metapage
c_func
(paren
id|amp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmp
)paren
id|write_metapage
c_func
(paren
id|bmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
id|write_metapage
c_func
(paren
id|cmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmp
)paren
id|write_metapage
c_func
(paren
id|dmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * start transaction to update block allocation map&n;&t; * for the inode extent freed;&n;&t; *&n;&t; * N.B. AG_LOCK is released and iag will be released below, and &n;&t; * other thread may allocate inode from/reusing the ixad freed&n;&t; * BUT with new/different backing inode extent from the extent &n;&t; * to be freed by the transaction;  &n;&t; */
id|tid
op_assign
id|txBegin
c_func
(paren
id|ipimap-&gt;i_sb
comma
id|COMMIT_FORCE
)paren
suffix:semicolon
multiline_comment|/* acquire tlock of the iag page of the freed ixad &n;&t; * to force the page NOHOMEOK (even though no data is&n;&t; * logged from the iag page) until NOREDOPAGE|FREEXTENT log &n;&t; * for the free of the extent is committed;&n;&t; * write FREEXTENT|NOREDOPAGE log record&n;&t; * N.B. linelock is overlaid as freed extent descriptor;&n;&t; */
id|tlck
op_assign
id|txLock
c_func
(paren
id|tid
comma
id|ipimap
comma
id|mp
comma
id|tlckINODE
op_or
id|tlckFREE
)paren
suffix:semicolon
id|pxdlock
op_assign
(paren
id|pxdlock_t
op_star
)paren
op_amp
id|tlck-&gt;lock
suffix:semicolon
id|pxdlock-&gt;flag
op_assign
id|mlckFREEPXD
suffix:semicolon
id|pxdlock-&gt;pxd
op_assign
id|freepxd
suffix:semicolon
id|pxdlock-&gt;index
op_assign
l_int|1
suffix:semicolon
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|iplist
(braket
l_int|0
)braket
op_assign
id|ipimap
suffix:semicolon
multiline_comment|/*&n;&t; * logredo needs the IAG number and IAG extent index in order&n;&t; * to ensure that the IMap is consistent.  The least disruptive&n;&t; * way to pass these values through  to the transaction manager&n;&t; * is in the iplist array.  &n;&t; * &n;&t; * It&squot;s not pretty, but it works.&n;&t; */
id|iplist
(braket
l_int|1
)braket
op_assign
(paren
r_struct
id|inode
op_star
)paren
(paren
r_int
)paren
id|iagno
suffix:semicolon
id|iplist
(braket
l_int|2
)braket
op_assign
(paren
r_struct
id|inode
op_star
)paren
(paren
r_int
)paren
id|extno
suffix:semicolon
id|rc
op_assign
id|txCommit
c_func
(paren
id|tid
comma
l_int|1
comma
op_amp
id|iplist
(braket
l_int|0
)braket
comma
id|COMMIT_FORCE
)paren
suffix:semicolon
singleline_comment|// D233382
id|txEnd
c_func
(paren
id|tid
)paren
suffix:semicolon
multiline_comment|/* unlock the AG inode map information */
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error_out
suffix:colon
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amp
)paren
id|release_metapage
c_func
(paren
id|amp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmp
)paren
id|release_metapage
c_func
(paren
id|bmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
id|release_metapage
c_func
(paren
id|cmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmp
)paren
id|release_metapage
c_func
(paren
id|dmp
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * There are several places in the diAlloc* routines where we initialize&n; * the inode.&n; */
r_static
r_inline
r_void
DECL|function|diInitInode
id|diInitInode
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_int
id|iagno
comma
r_int
id|ino
comma
r_int
id|extno
comma
id|iag_t
op_star
id|iagp
)paren
(brace
r_struct
id|jfs_sb_info
op_star
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|ip-&gt;i_ino
op_assign
(paren
id|iagno
op_lshift
id|L2INOSPERIAG
)paren
op_plus
id|ino
suffix:semicolon
id|DBG_DIALLOC
c_func
(paren
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|jfs_ip-&gt;ixpxd
op_assign
id|iagp-&gt;inoext
(braket
id|extno
)braket
suffix:semicolon
id|jfs_ip-&gt;agno
op_assign
id|BLKTOAG
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|iagp-&gt;agstart
)paren
comma
id|sbi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diAlloc(pip,dir,ip)&n; *&n; * FUNCTION:    allocate a disk inode from the inode working map &n; *&t;&t;for a fileset or aggregate.&n; *&n; * PARAMETERS:&n; *      pip  &t;- pointer to incore inode for the parent inode.&n; *      dir  &t;- TRUE if the new disk inode is for a directory.&n; *      ip  &t;- pointer to a new inode&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diAlloc
r_int
id|diAlloc
c_func
(paren
r_struct
id|inode
op_star
id|pip
comma
id|boolean_t
id|dir
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|rc
comma
id|ino
comma
id|iagno
comma
id|addext
comma
id|extno
comma
id|bitno
comma
id|sword
suffix:semicolon
r_int
id|nwords
comma
id|rem
comma
id|i
comma
id|agno
suffix:semicolon
id|u32
id|mask
comma
id|inosmap
comma
id|extsmap
suffix:semicolon
r_struct
id|inode
op_star
id|ipimap
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|ino_t
id|inum
suffix:semicolon
id|iag_t
op_star
id|iagp
suffix:semicolon
id|imap_t
op_star
id|imap
suffix:semicolon
multiline_comment|/* get the pointers to the inode map inode and the&n;&t; * corresponding imap control structure.&n;&t; */
id|ipimap
op_assign
id|JFS_SBI
c_func
(paren
id|pip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipimap
suffix:semicolon
id|imap
op_assign
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|ipimap
op_assign
id|ipimap
suffix:semicolon
id|JFS_IP
c_func
(paren
id|ip
)paren
op_member_access_from_pointer
id|fileset
op_assign
id|FILESYSTEM_I
suffix:semicolon
multiline_comment|/* for a directory, the allocation policy is to start &n;&t; * at the ag level using the preferred ag.&n;&t; */
r_if
c_cond
(paren
id|dir
op_eq
id|TRUE
)paren
(brace
id|agno
op_assign
id|dbNextAG
c_func
(paren
id|JFS_SBI
c_func
(paren
id|pip-&gt;i_sb
)paren
op_member_access_from_pointer
id|ipbmap
)paren
suffix:semicolon
id|AG_LOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
r_goto
id|tryag
suffix:semicolon
)brace
multiline_comment|/* for files, the policy starts off by trying to allocate from&n;&t; * the same iag containing the parent disk inode:&n;&t; * try to allocate the new disk inode close to the parent disk&n;&t; * inode, using parent disk inode number + 1 as the allocation&n;&t; * hint.  (we use a left-to-right policy to attempt to avoid&n;&t; * moving backward on the disk.)  compute the hint within the&n;&t; * file system and the iag.&n;&t; */
id|inum
op_assign
id|pip-&gt;i_ino
op_plus
l_int|1
suffix:semicolon
id|ino
op_assign
id|inum
op_amp
(paren
id|INOSPERIAG
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* back off the the hint if it is outside of the iag */
r_if
c_cond
(paren
id|ino
op_eq
l_int|0
)paren
id|inum
op_assign
id|pip-&gt;i_ino
suffix:semicolon
multiline_comment|/* get the ag number of this iag */
id|agno
op_assign
id|JFS_IP
c_func
(paren
id|pip
)paren
op_member_access_from_pointer
id|agno
suffix:semicolon
multiline_comment|/* lock the AG inode map information */
id|AG_LOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
multiline_comment|/* Get read lock on imap inode */
id|IREAD_LOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/* get the iag number and read the iag */
id|iagno
op_assign
id|INOTOIAG
c_func
(paren
id|inum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|iagno
comma
op_amp
id|mp
)paren
)paren
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* determine if new inode extent is allowed to be added to the iag.&n;&t; * new inode extent can be added to the iag if the ag&n;&t; * has less than 32 free disk inodes and the iag has free extents.&n;&t; */
id|addext
op_assign
(paren
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
OL
l_int|32
op_logical_and
id|iagp-&gt;nfreeexts
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      try to allocate from the IAG&n;&t; */
multiline_comment|/* check if the inode may be allocated from the iag &n;&t; * (i.e. the inode has free inodes or new extent can be added).&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_logical_or
id|addext
)paren
(brace
multiline_comment|/* determine the extent number of the hint.&n;&t;&t; */
id|extno
op_assign
id|ino
op_rshift
id|L2INOSPEREXT
suffix:semicolon
multiline_comment|/* check if the extent containing the hint has backed&n;&t;&t; * inodes.  if so, try to allocate within this extent.&n;&t;&t; */
r_if
c_cond
(paren
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
)paren
(brace
id|bitno
op_assign
id|ino
op_amp
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bitno
op_assign
id|diFindFree
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
comma
id|bitno
)paren
)paren
OL
id|INOSPEREXT
)paren
(brace
id|ino
op_assign
(paren
id|extno
op_lshift
id|L2INOSPEREXT
)paren
op_plus
id|bitno
suffix:semicolon
multiline_comment|/* a free inode (bit) was found within this&n;&t;&t;&t;&t; * extent, so allocate it.&n;&t;&t;&t;&t; */
id|rc
op_assign
id|diAllocBit
c_func
(paren
id|imap
comma
id|iagp
comma
id|ino
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
m_assert
(paren
id|rc
op_eq
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the results of the allocation&n;&t;&t;&t;&t;&t; * and write the iag.&n;&t;&t;&t;&t;&t; */
id|diInitInode
c_func
(paren
id|ip
comma
id|iagno
comma
id|ino
comma
id|extno
comma
id|iagp
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* free the AG lock and return.&n;&t;&t;&t;&t; */
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|addext
)paren
id|extno
op_assign
(paren
id|extno
op_eq
id|EXTSPERIAG
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
id|extno
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * no free inodes within the extent containing the hint.&n;&t;&t; *&n;&t;&t; * try to allocate from the backed extents following&n;&t;&t; * hint or, if appropriate (i.e. addext is true), allocate&n;&t;&t; * an extent of free inodes at or following the extent&n;&t;&t; * containing the hint.&n;&t;&t; * &n;&t;&t; * the free inode and free extent summary maps are used&n;&t;&t; * here, so determine the starting summary map position&n;&t;&t; * and the number of words we&squot;ll have to examine.  again,&n;&t;&t; * the approach is to allocate following the hint, so we&n;&t;&t; * might have to initially ignore prior bits of the summary&n;&t;&t; * map that represent extents prior to the extent containing&n;&t;&t; * the hint and later revisit these bits.&n;&t;&t; */
id|bitno
op_assign
id|extno
op_amp
(paren
id|EXTSPERSUM
op_minus
l_int|1
)paren
suffix:semicolon
id|nwords
op_assign
(paren
id|bitno
op_eq
l_int|0
)paren
ques
c_cond
id|SMAPSZ
suffix:colon
id|SMAPSZ
op_plus
l_int|1
suffix:semicolon
id|sword
op_assign
id|extno
op_rshift
id|L2EXTSPERSUM
suffix:semicolon
multiline_comment|/* mask any prior bits for the starting words of the&n;&t;&t; * summary map.&n;&t;&t; */
id|mask
op_assign
id|ONES
op_lshift
(paren
id|EXTSPERSUM
op_minus
id|bitno
)paren
suffix:semicolon
id|inosmap
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inosmap
(braket
id|sword
)braket
)paren
op_or
id|mask
suffix:semicolon
id|extsmap
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extsmap
(braket
id|sword
)braket
)paren
op_or
id|mask
suffix:semicolon
multiline_comment|/* scan the free inode and free extent summary maps for&n;&t;&t; * free resources.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nwords
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* check if this word of the free inode summary&n;&t;&t;&t; * map describes an extent with free inodes.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_complement
id|inosmap
)paren
(brace
multiline_comment|/* an extent with free inodes has been&n;&t;&t;&t;&t; * found. determine the extent number&n;&t;&t;&t;&t; * and the inode number within the extent.&n;&t;&t;&t;&t; */
id|rem
op_assign
id|diFindFree
c_func
(paren
id|inosmap
comma
l_int|0
)paren
suffix:semicolon
id|extno
op_assign
(paren
id|sword
op_lshift
id|L2EXTSPERSUM
)paren
op_plus
id|rem
suffix:semicolon
id|rem
op_assign
id|diFindFree
c_func
(paren
id|le32_to_cpu
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|rem
OL
id|INOSPEREXT
)paren
suffix:semicolon
multiline_comment|/* determine the inode number within the&n;&t;&t;&t;&t; * iag and allocate the inode from the&n;&t;&t;&t;&t; * map.&n;&t;&t;&t;&t; */
id|ino
op_assign
(paren
id|extno
op_lshift
id|L2INOSPEREXT
)paren
op_plus
id|rem
suffix:semicolon
id|rc
op_assign
id|diAllocBit
c_func
(paren
id|imap
comma
id|iagp
comma
id|ino
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
m_assert
(paren
id|rc
op_eq
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the results of the allocation&n;&t;&t;&t;&t;&t; * and write the iag.&n;&t;&t;&t;&t;&t; */
id|diInitInode
c_func
(paren
id|ip
comma
id|iagno
comma
id|ino
comma
id|extno
comma
id|iagp
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* free the AG lock and return.&n;&t;&t;&t;&t; */
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* check if we may allocate an extent of free&n;&t;&t;&t; * inodes and whether this word of the free&n;&t;&t;&t; * extents summary map describes a free extent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|addext
op_logical_and
op_complement
id|extsmap
)paren
(brace
multiline_comment|/* a free extent has been found.  determine&n;&t;&t;&t;&t; * the extent number.&n;&t;&t;&t;&t; */
id|rem
op_assign
id|diFindFree
c_func
(paren
id|extsmap
comma
l_int|0
)paren
suffix:semicolon
id|extno
op_assign
(paren
id|sword
op_lshift
id|L2EXTSPERSUM
)paren
op_plus
id|rem
suffix:semicolon
multiline_comment|/* allocate an extent of free inodes.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diNewExt
c_func
(paren
id|imap
comma
id|iagp
comma
id|extno
)paren
)paren
)paren
(brace
multiline_comment|/* if there is no disk space for a&n;&t;&t;&t;&t;&t; * new extent, try to allocate the&n;&t;&t;&t;&t;&t; * disk inode from somewhere else.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
id|ENOSPC
)paren
r_break
suffix:semicolon
m_assert
(paren
id|rc
op_eq
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set the results of the allocation&n;&t;&t;&t;&t;&t; * and write the iag.&n;&t;&t;&t;&t;&t; */
id|diInitInode
c_func
(paren
id|ip
comma
id|iagno
comma
id|extno
op_lshift
id|L2INOSPEREXT
comma
id|extno
comma
id|iagp
)paren
suffix:semicolon
id|mark_metapage_dirty
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* free the imap inode &amp; the AG lock &amp; return.&n;&t;&t;&t;&t; */
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* move on to the next set of summary map words.&n;&t;&t;&t; */
id|sword
op_assign
(paren
id|sword
op_eq
id|SMAPSZ
op_minus
l_int|1
)paren
ques
c_cond
l_int|0
suffix:colon
id|sword
op_plus
l_int|1
suffix:semicolon
id|inosmap
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inosmap
(braket
id|sword
)braket
)paren
suffix:semicolon
id|extsmap
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extsmap
(braket
id|sword
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* unlock imap inode */
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/* nothing doing in this iag, so release it. */
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
id|tryag
suffix:colon
multiline_comment|/*&n;&t; * try to allocate anywhere within the same AG as the parent inode.&n;&t; */
id|rc
op_assign
id|diAllocAG
c_func
(paren
id|imap
comma
id|agno
comma
id|dir
comma
id|ip
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|agno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|ENOSPC
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * try to allocate in any AG.&n;&t; */
r_return
(paren
id|diAllocAny
c_func
(paren
id|imap
comma
id|agno
comma
id|dir
comma
id|ip
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diAllocAG(imap,agno,dir,ip)&n; *&n; * FUNCTION:    allocate a disk inode from the allocation group.&n; *&n; *&t;&t;this routine first determines if a new extent of free&n; *&t;&t;inodes should be added for the allocation group, with&n; *&t;&t;the current request satisfied from this extent. if this&n; *&t;&t;is the case, an attempt will be made to do just that.  if&n; *&t;&t;this attempt fails or it has been determined that a new &n; *&t;&t;extent should not be added, an attempt is made to satisfy&n; *&t;&t;the request by allocating an existing (backed) free inode&n; *&t;&t;from the allocation group.&n; *&n; * PRE CONDITION: Already have the AG lock for this AG.&n; *&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      agno  &t;- allocation group to allocate from.&n; *      dir  &t;- TRUE if the new disk inode is for a directory.&n; *      ip  &t;- pointer to the new inode to be filled in on successful return&n; *&t;&t;  with the disk inode number allocated, its extent address&n; *&t;&t;  and the start of the ag.&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; */
r_static
r_int
DECL|function|diAllocAG
id|diAllocAG
c_func
(paren
id|imap_t
op_star
id|imap
comma
r_int
id|agno
comma
id|boolean_t
id|dir
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|rc
comma
id|addext
comma
id|numfree
comma
id|numinos
suffix:semicolon
multiline_comment|/* get the number of free and the number of backed disk &n;&t; * inodes currently within the ag.&n;&t; */
id|numfree
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
suffix:semicolon
id|numinos
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numinos
suffix:semicolon
r_if
c_cond
(paren
id|numfree
OG
id|numinos
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diAllocAG: numfree &gt; numinos&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/* determine if we should allocate a new extent of free inodes&n;&t; * within the ag: for directory inodes, add a new extent&n;&t; * if there are a small number of free inodes or number of free&n;&t; * inodes is a small percentage of the number of backed inodes.&n;&t; */
r_if
c_cond
(paren
id|dir
op_eq
id|TRUE
)paren
id|addext
op_assign
(paren
id|numfree
OL
l_int|64
op_logical_or
(paren
id|numfree
OL
l_int|256
op_logical_and
(paren
(paren
id|numfree
op_star
l_int|100
)paren
op_div
id|numinos
)paren
op_le
l_int|20
)paren
)paren
suffix:semicolon
r_else
id|addext
op_assign
(paren
id|numfree
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * try to allocate a new extent of free inodes.&n;&t; */
r_if
c_cond
(paren
id|addext
)paren
(brace
multiline_comment|/* if free space is not avaliable for this new extent, try&n;&t;&t; * below to allocate a free and existing (already backed)&n;&t;&t; * inode from the ag.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diAllocExt
c_func
(paren
id|imap
comma
id|agno
comma
id|ip
)paren
)paren
op_ne
id|ENOSPC
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * try to allocate an existing free inode from the ag.&n;&t; */
r_return
(paren
id|diAllocIno
c_func
(paren
id|imap
comma
id|agno
comma
id|ip
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diAllocAny(imap,agno,dir,iap)&n; *&n; * FUNCTION:    allocate a disk inode from any other allocation group.&n; *&n; *&t;&t;this routine is called when an allocation attempt within&n; *&t;&t;the primary allocation group has failed. if attempts to&n; *&t;&t;allocate an inode from any allocation group other than the&n; *&t;&t;specified primary group.&n; *&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      agno  &t;- primary allocation group (to avoid).&n; *      dir  &t;- TRUE if the new disk inode is for a directory.&n; *      ip  &t;- pointer to a new inode to be filled in on successful return&n; *&t;&t;  with the disk inode number allocated, its extent address&n; *&t;&t;  and the start of the ag.&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; */
r_static
r_int
DECL|function|diAllocAny
id|diAllocAny
c_func
(paren
id|imap_t
op_star
id|imap
comma
r_int
id|agno
comma
id|boolean_t
id|dir
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|ag
comma
id|rc
suffix:semicolon
r_int
id|maxag
op_assign
id|JFS_SBI
c_func
(paren
id|imap-&gt;im_ipimap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap-&gt;db_maxag
suffix:semicolon
multiline_comment|/* try to allocate from the ags following agno up to &n;&t; * the maximum ag number.&n;&t; */
r_for
c_loop
(paren
id|ag
op_assign
id|agno
op_plus
l_int|1
suffix:semicolon
id|ag
op_le
id|maxag
suffix:semicolon
id|ag
op_increment
)paren
(brace
id|AG_LOCK
c_func
(paren
id|imap
comma
id|ag
)paren
suffix:semicolon
id|rc
op_assign
id|diAllocAG
c_func
(paren
id|imap
comma
id|ag
comma
id|dir
comma
id|ip
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|ag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|ENOSPC
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* try to allocate from the ags in front of agno.&n;&t; */
r_for
c_loop
(paren
id|ag
op_assign
l_int|0
suffix:semicolon
id|ag
OL
id|agno
suffix:semicolon
id|ag
op_increment
)paren
(brace
id|AG_LOCK
c_func
(paren
id|imap
comma
id|ag
)paren
suffix:semicolon
id|rc
op_assign
id|diAllocAG
c_func
(paren
id|imap
comma
id|ag
comma
id|dir
comma
id|ip
)paren
suffix:semicolon
id|AG_UNLOCK
c_func
(paren
id|imap
comma
id|ag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ne
id|ENOSPC
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* no free disk inodes.&n;&t; */
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diAllocIno(imap,agno,ip)&n; *&n; * FUNCTION:    allocate a disk inode from the allocation group&squot;s free&n; *&t;&t;inode list, returning an error if this free list is&n; *&t;&t;empty (i.e. no iags on the list).&n; *&n; *&t;&t;allocation occurs from the first iag on the list using&n; *&t;&t;the iag&squot;s free inode summary map to find the leftmost&n; *&t;&t;free inode in the iag. &n; *&t;&t;&n; * PRE CONDITION: Already have AG lock for this AG.&n; *&t;&t;&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      agno  &t;- allocation group.&n; *      ip  &t;- pointer to new inode to be filled in on successful return&n; *&t;&t;  with the disk inode number allocated, its extent address&n; *&t;&t;  and the start of the ag.&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diAllocIno
r_static
r_int
id|diAllocIno
c_func
(paren
id|imap_t
op_star
id|imap
comma
r_int
id|agno
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|iagno
comma
id|ino
comma
id|rc
comma
id|rem
comma
id|extno
comma
id|sword
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|iag_t
op_star
id|iagp
suffix:semicolon
multiline_comment|/* check if there are iags on the ag&squot;s free inode list.&n;&t; */
r_if
c_cond
(paren
(paren
id|iagno
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
)paren
OL
l_int|0
)paren
r_return
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/* obtain read lock on imap inode */
id|IREAD_LOCK
c_func
(paren
id|imap-&gt;im_ipimap
)paren
suffix:semicolon
multiline_comment|/* read the iag at the head of the list.&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|iagno
comma
op_amp
id|mp
)paren
)paren
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|imap-&gt;im_ipimap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* better be free inodes in this iag if it is on the&n;&t; * list.&n;&t; */
singleline_comment|//assert(iagp-&gt;nfreeinos);
r_if
c_cond
(paren
op_logical_neg
id|iagp-&gt;nfreeinos
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diAllocIno: nfreeinos = 0, but iag on freelist&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;  agno = %d, iagno = %d&bslash;n&quot;
comma
id|agno
comma
id|iagno
)paren
)paren
suffix:semicolon
id|dump_mem
c_func
(paren
l_string|&quot;iag&quot;
comma
id|iagp
comma
l_int|64
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ip-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/* scan the free inode summary map to find an extent&n;&t; * with free inodes.&n;&t; */
r_for
c_loop
(paren
id|sword
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|sword
op_increment
)paren
(brace
m_assert
(paren
id|sword
OL
id|SMAPSZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|iagp-&gt;inosmap
(braket
id|sword
)braket
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* found a extent with free inodes. determine&n;&t; * the extent number.&n;&t; */
id|rem
op_assign
id|diFindFree
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inosmap
(braket
id|sword
)braket
)paren
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|rem
OL
id|EXTSPERSUM
)paren
suffix:semicolon
id|extno
op_assign
(paren
id|sword
op_lshift
id|L2EXTSPERSUM
)paren
op_plus
id|rem
suffix:semicolon
multiline_comment|/* find the first free inode in the extent.&n;&t; */
id|rem
op_assign
id|diFindFree
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|rem
OL
id|INOSPEREXT
)paren
suffix:semicolon
multiline_comment|/* compute the inode number within the iag. &n;&t; */
id|ino
op_assign
(paren
id|extno
op_lshift
id|L2INOSPEREXT
)paren
op_plus
id|rem
suffix:semicolon
multiline_comment|/* allocate the inode.&n;&t; */
id|rc
op_assign
id|diAllocBit
c_func
(paren
id|imap
comma
id|iagp
comma
id|ino
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|imap-&gt;im_ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|release_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* set the results of the allocation and write the iag.&n;&t; */
id|diInitInode
c_func
(paren
id|ip
comma
id|iagno
comma
id|ino
comma
id|extno
comma
id|iagp
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diAllocExt(imap,agno,ip)&n; *&n; * FUNCTION:   &t;add a new extent of free inodes to an iag, allocating&n; *&t;       &t;an inode from this extent to satisfy the current allocation&n; *&t;       &t;request.&n; *&t;&t;&n; *&t;&t;this routine first tries to find an existing iag with free&n; *&t;&t;extents through the ag free extent list.  if list is not&n; *&t;&t;empty, the head of the list will be selected as the home&n; *&t;&t;of the new extent of free inodes.  otherwise (the list is&n; *&t;&t;empty), a new iag will be allocated for the ag to contain&n; *&t;&t;the extent.&n; *&t;&t;&n; *&t;&t;once an iag has been selected, the free extent summary map&n; *&t;&t;is used to locate a free extent within the iag and diNewExt()&n; *&t;&t;is called to initialize the extent, with initialization&n; *&t;&t;including the allocation of the first inode of the extent&n; *&t;&t;for the purpose of satisfying this request.&n; *&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      agno  &t;- allocation group number.&n; *      ip  &t;- pointer to new inode to be filled in on successful return&n; *&t;&t;  with the disk inode number allocated, its extent address&n; *&t;&t;  and the start of the ag.&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diAllocExt
r_static
r_int
id|diAllocExt
c_func
(paren
id|imap_t
op_star
id|imap
comma
r_int
id|agno
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_int
id|rem
comma
id|iagno
comma
id|sword
comma
id|extno
comma
id|rc
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|iag_t
op_star
id|iagp
suffix:semicolon
multiline_comment|/* check if the ag has any iags with free extents.  if not,&n;&t; * allocate a new iag for the ag.&n;&t; */
r_if
c_cond
(paren
(paren
id|iagno
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* If successful, diNewIAG will obtain the read lock on the&n;&t;&t; * imap inode.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diNewIAG
c_func
(paren
id|imap
comma
op_amp
id|iagno
comma
id|agno
comma
op_amp
id|mp
)paren
)paren
)paren
(brace
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* set the ag number if this a brand new iag&n;&t;&t; */
id|iagp-&gt;agstart
op_assign
id|cpu_to_le64
c_func
(paren
id|AGTOBLK
c_func
(paren
id|agno
comma
id|imap-&gt;im_ipimap
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* read the iag.&n;&t;&t; */
id|IREAD_LOCK
c_func
(paren
id|imap-&gt;im_ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|iagno
comma
op_amp
id|mp
)paren
)paren
)paren
(brace
m_assert
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
)brace
multiline_comment|/* using the free extent summary map, find a free extent.&n;&t; */
r_for
c_loop
(paren
id|sword
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|sword
op_increment
)paren
(brace
m_assert
(paren
id|sword
OL
id|SMAPSZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|iagp-&gt;extsmap
(braket
id|sword
)braket
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* determine the extent number of the free extent.&n;&t; */
id|rem
op_assign
id|diFindFree
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extsmap
(braket
id|sword
)braket
)paren
comma
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|rem
OL
id|EXTSPERSUM
)paren
suffix:semicolon
id|extno
op_assign
(paren
id|sword
op_lshift
id|L2EXTSPERSUM
)paren
op_plus
id|rem
suffix:semicolon
multiline_comment|/* initialize the new extent.&n;&t; */
id|rc
op_assign
id|diNewExt
c_func
(paren
id|imap
comma
id|iagp
comma
id|extno
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|imap-&gt;im_ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
multiline_comment|/* something bad happened.  if a new iag was allocated,&n;&t;&t; * place it back on the inode map&squot;s iag free list, and&n;&t;&t; * clear the ag number information.&n;&t;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
id|EXTSPERIAG
)paren
)paren
(brace
id|IAGFREE_LOCK
c_func
(paren
id|imap
)paren
suffix:semicolon
id|iagp-&gt;iagfree
op_assign
id|cpu_to_le32
c_func
(paren
id|imap-&gt;im_freeiag
)paren
suffix:semicolon
id|imap-&gt;im_freeiag
op_assign
id|iagno
suffix:semicolon
id|IAGFREE_UNLOCK
c_func
(paren
id|imap
)paren
suffix:semicolon
)brace
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/* set the results of the allocation and write the iag.&n;&t; */
id|diInitInode
c_func
(paren
id|ip
comma
id|iagno
comma
id|extno
op_lshift
id|L2INOSPEREXT
comma
id|extno
comma
id|iagp
)paren
suffix:semicolon
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diAllocBit(imap,iagp,ino)&n; *&n; * FUNCTION:   &t;allocate a backed inode from an iag.&n; *&n; *&t;&t;this routine performs the mechanics of allocating a&n; *&t;&t;specified inode from a backed extent.&n; *&n; *&t;&t;if the inode to be allocated represents the last free&n; *&t;&t;inode within the iag, the iag will be removed from the&n; *&t;&t;ag free inode list.&n; *&n; *&t;&t;a careful update approach is used to provide consistency&n; *&t;&t;in the face of updates to multiple buffers.  under this&n; *&t;&t;approach, all required buffers are obtained before making&n; *&t;&t;any updates and are held all are updates are complete.&n; *&t;&t;&n; * PRE CONDITION: Already have buffer lock on iagp.  Already have AG lock on&n; *&t;this AG.  Must have read lock on imap inode.&n; *&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      iagp  &t;- pointer to iag. &n; *      ino   &t;- inode number to be allocated within the iag.&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diAllocBit
r_static
r_int
id|diAllocBit
c_func
(paren
id|imap_t
op_star
id|imap
comma
id|iag_t
op_star
id|iagp
comma
r_int
id|ino
)paren
(brace
r_int
id|extno
comma
id|bitno
comma
id|agno
comma
id|sword
comma
id|rc
suffix:semicolon
id|metapage_t
op_star
id|amp
comma
op_star
id|bmp
suffix:semicolon
id|iag_t
op_star
id|aiagp
op_assign
l_int|0
comma
op_star
id|biagp
op_assign
l_int|0
suffix:semicolon
id|u32
id|mask
suffix:semicolon
multiline_comment|/* check if this is the last free inode within the iag.&n;&t; * if so, it will have to be removed from the ag free&n;&t; * inode list, so get the iags preceeding and following&n;&t; * it on the list.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_eq
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
id|amp
op_assign
id|bmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreefwd
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreefwd
)paren
comma
op_amp
id|amp
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
id|aiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreeback
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreeback
)paren
comma
op_amp
id|bmp
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|amp
)paren
id|release_metapage
c_func
(paren
id|amp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
id|biagp
op_assign
(paren
id|iag_t
op_star
)paren
id|bmp-&gt;data
suffix:semicolon
)brace
)brace
multiline_comment|/* get the ag number, extent number, inode number within&n;&t; * the extent.&n;&t; */
id|agno
op_assign
id|BLKTOAG
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|iagp-&gt;agstart
)paren
comma
id|JFS_SBI
c_func
(paren
id|imap-&gt;im_ipimap-&gt;i_sb
)paren
)paren
suffix:semicolon
id|extno
op_assign
id|ino
op_rshift
id|L2INOSPEREXT
suffix:semicolon
id|bitno
op_assign
id|ino
op_amp
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* compute the mask for setting the map.&n;&t; */
id|mask
op_assign
id|HIGHORDER
op_rshift
id|bitno
suffix:semicolon
multiline_comment|/* the inode should be free and backed.&n;&t; */
m_assert
(paren
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;pmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* mark the inode as allocated in the working map.&n;&t; */
id|iagp-&gt;wmap
(braket
id|extno
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|mask
)paren
suffix:semicolon
multiline_comment|/* check if all inodes within the extent are now&n;&t; * allocated.  if so, update the free inode summary&n;&t; * map to reflect this.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
op_eq
id|ONES
)paren
(brace
id|sword
op_assign
id|extno
op_rshift
id|L2EXTSPERSUM
suffix:semicolon
id|bitno
op_assign
id|extno
op_amp
(paren
id|EXTSPERSUM
op_minus
l_int|1
)paren
suffix:semicolon
id|iagp-&gt;inosmap
(braket
id|sword
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|HIGHORDER
op_rshift
id|bitno
)paren
suffix:semicolon
)brace
multiline_comment|/* if this was the last free inode in the iag, remove the&n;&t; * iag from the ag free inode list.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_eq
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|amp
)paren
(brace
id|aiagp-&gt;inofreeback
op_assign
id|iagp-&gt;inofreeback
suffix:semicolon
id|write_metapage
c_func
(paren
id|amp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bmp
)paren
(brace
id|biagp-&gt;inofreefwd
op_assign
id|iagp-&gt;inofreefwd
suffix:semicolon
id|write_metapage
c_func
(paren
id|bmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;inofreefwd
)paren
suffix:semicolon
)brace
id|iagp-&gt;inofreefwd
op_assign
id|iagp-&gt;inofreeback
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* update the free inode count at the iag, ag, inode&n;&t; * map levels.&n;&t; */
id|iagp-&gt;nfreeinos
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeinos
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
op_sub_assign
l_int|1
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|imap-&gt;im_numfree
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diNewExt(imap,iagp,extno)&n; *&n; * FUNCTION:    initialize a new extent of inodes for an iag, allocating&n; *&t;        the first inode of the extent for use for the current&n; *&t;        allocation request.&n; *&n; *&t;&t;disk resources are allocated for the new extent of inodes&n; *&t;&t;and the inodes themselves are initialized to reflect their&n; *&t;&t;existence within the extent (i.e. their inode numbers and&n; *&t;&t;inode extent addresses are set) and their initial state&n; *&t;&t;(mode and link count are set to zero).&n; *&n; *&t;&t;if the iag is new, it is not yet on an ag extent free list&n; *&t;&t;but will now be placed on this list.&n; *&n; *&t;&t;if the allocation of the new extent causes the iag to&n; *&t;&t;have no free extent, the iag will be removed from the&n; *&t;&t;ag extent free list.&n; *&n; *&t;&t;if the iag has no free backed inodes, it will be placed&n; *&t;&t;on the ag free inode list, since the addition of the new&n; *&t;&t;extent will now cause it to have free inodes.&n; *&n; *&t;&t;a careful update approach is used to provide consistency&n; *&t;&t;(i.e. list consistency) in the face of updates to multiple&n; *&t;&t;buffers.  under this approach, all required buffers are&n; *&t;&t;obtained before making any updates and are held until all&n; *&t;&t;updates are complete.&n; *&t;&t;&n; * PRE CONDITION: Already have buffer lock on iagp.  Already have AG lock on&n; *&t;this AG.  Must have read lock on imap inode.&n; *&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      iagp  &t;- pointer to iag. &n; *      extno  &t;- extent number.&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diNewExt
r_static
r_int
id|diNewExt
c_func
(paren
id|imap_t
op_star
id|imap
comma
id|iag_t
op_star
id|iagp
comma
r_int
id|extno
)paren
(brace
r_int
id|agno
comma
id|iagno
comma
id|fwd
comma
id|back
comma
id|freei
op_assign
l_int|0
comma
id|sword
comma
id|rc
suffix:semicolon
id|iag_t
op_star
id|aiagp
op_assign
l_int|0
comma
op_star
id|biagp
op_assign
l_int|0
comma
op_star
id|ciagp
op_assign
l_int|0
suffix:semicolon
id|metapage_t
op_star
id|amp
comma
op_star
id|bmp
comma
op_star
id|cmp
comma
op_star
id|dmp
suffix:semicolon
r_struct
id|inode
op_star
id|ipimap
suffix:semicolon
id|s64
id|blkno
comma
id|hint
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|u32
id|mask
suffix:semicolon
id|ino_t
id|ino
suffix:semicolon
id|dinode_t
op_star
id|dp
suffix:semicolon
r_struct
id|jfs_sb_info
op_star
id|sbi
suffix:semicolon
multiline_comment|/* better have free extents.&n;&t; */
m_assert
(paren
id|iagp-&gt;nfreeexts
)paren
suffix:semicolon
multiline_comment|/* get the inode map inode.&n;&t; */
id|ipimap
op_assign
id|imap-&gt;im_ipimap
suffix:semicolon
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|ipimap-&gt;i_sb
)paren
suffix:semicolon
id|amp
op_assign
id|bmp
op_assign
id|cmp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* get the ag and iag numbers for this iag.&n;&t; */
id|agno
op_assign
id|BLKTOAG
c_func
(paren
id|le64_to_cpu
c_func
(paren
id|iagp-&gt;agstart
)paren
comma
id|sbi
)paren
suffix:semicolon
id|iagno
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;iagnum
)paren
suffix:semicolon
multiline_comment|/* check if this is the last free extent within the&n;&t; * iag.  if so, the iag must be removed from the ag&n;&t; * free extent list, so get the iags preceeding and&n;&t; * following the iag on this list.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|fwd
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extfreefwd
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|fwd
comma
op_amp
id|amp
)paren
)paren
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
id|aiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|back
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extfreeback
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|back
comma
op_amp
id|bmp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
id|biagp
op_assign
(paren
id|iag_t
op_star
)paren
id|bmp-&gt;data
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* the iag has free extents.  if all extents are free&n;&t;&t; * (as is the case for a newly allocated iag), the iag&n;&t;&t; * must be added to the ag free extent list, so get&n;&t;&t; * the iag at the head of the list in preparation for&n;&t;&t; * adding this iag to this list.&n;&t;&t; */
id|fwd
op_assign
id|back
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
id|EXTSPERIAG
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|fwd
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|fwd
comma
op_amp
id|amp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
id|aiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|amp-&gt;data
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* check if the iag has no free inodes.  if so, the iag&n;&t; * will have to be added to the ag free inode list, so get&n;&t; * the iag at the head of the list in preparation for&n;&t; * adding this iag to this list.  in doing this, we must&n;&t; * check if we already have the iag at the head of&n;&t; * the list in hand.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_eq
l_int|0
)paren
(brace
id|freei
op_assign
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
suffix:semicolon
r_if
c_cond
(paren
id|freei
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|freei
op_eq
id|fwd
)paren
(brace
id|ciagp
op_assign
id|aiagp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|freei
op_eq
id|back
)paren
(brace
id|ciagp
op_assign
id|biagp
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|freei
comma
op_amp
id|cmp
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
id|ciagp
op_assign
(paren
id|iag_t
op_star
)paren
id|cmp-&gt;data
suffix:semicolon
)brace
m_assert
(paren
id|ciagp
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* allocate disk space for the inode extent.&n;&t; */
r_if
c_cond
(paren
(paren
id|extno
op_eq
l_int|0
)paren
op_logical_or
(paren
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
op_minus
l_int|1
)braket
)paren
op_eq
l_int|0
)paren
)paren
id|hint
op_assign
(paren
(paren
id|s64
)paren
id|agno
op_lshift
id|sbi-&gt;bmap-&gt;db_agl2size
)paren
op_minus
l_int|1
suffix:semicolon
r_else
id|hint
op_assign
id|addressPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
op_minus
l_int|1
)braket
)paren
op_plus
id|lengthPXD
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
op_minus
l_int|1
)braket
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ipimap
comma
id|hint
comma
(paren
id|s64
)paren
id|imap-&gt;im_nbperiext
comma
op_amp
id|blkno
)paren
)paren
)paren
r_goto
id|error_out
suffix:semicolon
multiline_comment|/* compute the inode number of the first inode within the&n;&t; * extent.&n;&t; */
id|ino
op_assign
(paren
id|iagno
op_lshift
id|L2INOSPERIAG
)paren
op_plus
(paren
id|extno
op_lshift
id|L2INOSPEREXT
)paren
suffix:semicolon
multiline_comment|/* initialize the inodes within the newly allocated extent a&n;&t; * page at a time.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|imap-&gt;im_nbperiext
suffix:semicolon
id|i
op_add_assign
id|sbi-&gt;nbperpage
)paren
(brace
multiline_comment|/* get a buffer for this page of disk inodes.&n;&t;&t; */
id|dmp
op_assign
id|get_metapage
c_func
(paren
id|ipimap
comma
id|blkno
op_plus
id|i
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dmp
op_eq
l_int|NULL
)paren
(brace
id|rc
op_assign
id|EIO
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
id|dp
op_assign
(paren
id|dinode_t
op_star
)paren
id|dmp-&gt;data
suffix:semicolon
multiline_comment|/* initialize the inode number, mode, link count and&n;&t;&t; * inode extent address.&n;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|INOSPERPAGE
suffix:semicolon
id|j
op_increment
comma
id|dp
op_increment
comma
id|ino
op_increment
)paren
(brace
id|dp-&gt;di_inostamp
op_assign
id|cpu_to_le32
c_func
(paren
id|sbi-&gt;inostamp
)paren
suffix:semicolon
id|dp-&gt;di_number
op_assign
id|cpu_to_le32
c_func
(paren
id|ino
)paren
suffix:semicolon
id|dp-&gt;di_fileset
op_assign
id|cpu_to_le32
c_func
(paren
id|FILESYSTEM_I
)paren
suffix:semicolon
id|dp-&gt;di_mode
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;di_nlink
op_assign
l_int|0
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
(paren
id|dp-&gt;di_ixpxd
)paren
comma
id|blkno
)paren
suffix:semicolon
id|PXDlength
c_func
(paren
op_amp
(paren
id|dp-&gt;di_ixpxd
)paren
comma
id|imap-&gt;im_nbperiext
)paren
suffix:semicolon
)brace
id|write_metapage
c_func
(paren
id|dmp
)paren
suffix:semicolon
)brace
multiline_comment|/* if this is the last free extent within the iag, remove the&n;&t; * iag from the ag free extent list.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|fwd
op_ge
l_int|0
)paren
id|aiagp-&gt;extfreeback
op_assign
id|iagp-&gt;extfreeback
suffix:semicolon
r_if
c_cond
(paren
id|back
op_ge
l_int|0
)paren
id|biagp-&gt;extfreefwd
op_assign
id|iagp-&gt;extfreefwd
suffix:semicolon
r_else
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;extfreefwd
)paren
suffix:semicolon
id|iagp-&gt;extfreefwd
op_assign
id|iagp-&gt;extfreeback
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if the iag has all free extents (newly allocated iag),&n;&t;&t; * add the iag to the ag free extent list.&n;&t;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
id|EXTSPERIAG
)paren
)paren
(brace
r_if
c_cond
(paren
id|fwd
op_ge
l_int|0
)paren
id|aiagp-&gt;extfreeback
op_assign
id|cpu_to_le32
c_func
(paren
id|iagno
)paren
suffix:semicolon
id|iagp-&gt;extfreefwd
op_assign
id|cpu_to_le32
c_func
(paren
id|fwd
)paren
suffix:semicolon
id|iagp-&gt;extfreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|extfree
op_assign
id|iagno
suffix:semicolon
)brace
)brace
multiline_comment|/* if the iag has no free inodes, add the iag to the&n;&t; * ag free inode list.&n;&t; */
r_if
c_cond
(paren
id|iagp-&gt;nfreeinos
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|freei
op_ge
l_int|0
)paren
id|ciagp-&gt;inofreeback
op_assign
id|cpu_to_le32
c_func
(paren
id|iagno
)paren
suffix:semicolon
id|iagp-&gt;inofreefwd
op_assign
id|cpu_to_le32
c_func
(paren
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
)paren
suffix:semicolon
id|iagp-&gt;inofreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|inofree
op_assign
id|iagno
suffix:semicolon
)brace
multiline_comment|/* initialize the extent descriptor of the extent. */
id|PXDlength
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
comma
id|imap-&gt;im_nbperiext
)paren
suffix:semicolon
id|PXDaddress
c_func
(paren
op_amp
id|iagp-&gt;inoext
(braket
id|extno
)braket
comma
id|blkno
)paren
suffix:semicolon
multiline_comment|/* initialize the working and persistent map of the extent.&n;&t; * the working map will be initialized such that&n;&t; * it indicates the first inode of the extent is allocated.&n;&t; */
id|iagp-&gt;wmap
(braket
id|extno
)braket
op_assign
id|cpu_to_le32
c_func
(paren
id|HIGHORDER
)paren
suffix:semicolon
id|iagp-&gt;pmap
(braket
id|extno
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* update the free inode and free extent summary maps&n;&t; * for the extent to indicate the extent has free inodes&n;&t; * and no longer represents a free extent.&n;&t; */
id|sword
op_assign
id|extno
op_rshift
id|L2EXTSPERSUM
suffix:semicolon
id|mask
op_assign
id|HIGHORDER
op_rshift
(paren
id|extno
op_amp
(paren
id|EXTSPERSUM
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|iagp-&gt;extsmap
(braket
id|sword
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|mask
)paren
suffix:semicolon
id|iagp-&gt;inosmap
(braket
id|sword
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|mask
)paren
suffix:semicolon
multiline_comment|/* update the free inode and free extent counts for the&n;&t; * iag.&n;&t; */
id|iagp-&gt;nfreeinos
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeinos
)paren
op_plus
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|iagp-&gt;nfreeexts
op_assign
id|cpu_to_le32
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeexts
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* update the free and backed inode counts for the ag.&n;&t; */
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numfree
op_add_assign
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
suffix:semicolon
id|imap-&gt;im_agctl
(braket
id|agno
)braket
dot
id|numinos
op_add_assign
id|INOSPEREXT
suffix:semicolon
multiline_comment|/* update the free and backed inode counts for the inode map.&n;&t; */
id|atomic_add
c_func
(paren
id|INOSPEREXT
op_minus
l_int|1
comma
op_amp
id|imap-&gt;im_numfree
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|INOSPEREXT
comma
op_amp
id|imap-&gt;im_numinos
)paren
suffix:semicolon
multiline_comment|/* write the iags.&n;&t; */
r_if
c_cond
(paren
id|amp
)paren
id|write_metapage
c_func
(paren
id|amp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmp
)paren
id|write_metapage
c_func
(paren
id|bmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
id|write_metapage
c_func
(paren
id|cmp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error_out
suffix:colon
multiline_comment|/* release the iags.&n;&t; */
r_if
c_cond
(paren
id|amp
)paren
id|release_metapage
c_func
(paren
id|amp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmp
)paren
id|release_metapage
c_func
(paren
id|bmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmp
)paren
id|release_metapage
c_func
(paren
id|cmp
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diNewIAG(imap,iagnop,agno)&n; *&n; * FUNCTION:   &t;allocate a new iag for an allocation group.&n; *&t;&t;&n; *&t;&t;first tries to allocate the iag from the inode map &n; *&t;&t;iagfree list:  &n; *&t;&t;if the list has free iags, the head of the list is removed &n; *&t;&t;and returned to satisfy the request.&n; *&t;&t;if the inode map&squot;s iag free list is empty, the inode map&n; *&t;&t;is extended to hold a new iag. this new iag is initialized&n; *&t;&t;and returned to satisfy the request.&n; *&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      iagnop &t;- pointer to an iag number set with the number of the&n; *&t;&t;  newly allocated iag upon successful return.&n; *      agno  &t;- allocation group number.&n; *&t;bpp&t;- Buffer pointer to be filled in with new IAG&squot;s buffer&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      ENOSPC &t;- insufficient disk resources.&n; *      EIO  &t;- i/o error.&n; *&n; * serialization: &n; *&t;AG lock held on entry/exit;&n; *&t;write lock on the map is held inside;&n; *&t;read lock on the map is held on successful completion;&n; *&n; * note: new iag transaction: &n; * . synchronously write iag;&n; * . write log of xtree and inode  of imap;&n; * . commit;&n; * . synchronous write of xtree (right to left, bottom to top);&n; * . at start of logredo(): init in-memory imap with one additional iag page;&n; * . at end of logredo(): re-read imap inode to determine&n; *   new imap size;&n; */
r_static
r_int
DECL|function|diNewIAG
id|diNewIAG
c_func
(paren
id|imap_t
op_star
id|imap
comma
r_int
op_star
id|iagnop
comma
r_int
id|agno
comma
id|metapage_t
op_star
op_star
id|mpp
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|iagno
comma
id|i
comma
id|xlen
suffix:semicolon
r_struct
id|inode
op_star
id|ipimap
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_struct
id|jfs_sb_info
op_star
id|sbi
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
id|iag_t
op_star
id|iagp
suffix:semicolon
id|s64
id|xaddr
op_assign
l_int|0
suffix:semicolon
id|s64
id|blkno
suffix:semicolon
id|tid_t
id|tid
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
id|xad_t
id|xad
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
r_struct
id|inode
op_star
id|iplist
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* pick up pointers to the inode map and mount inodes */
id|ipimap
op_assign
id|imap-&gt;im_ipimap
suffix:semicolon
id|sb
op_assign
id|ipimap-&gt;i_sb
suffix:semicolon
id|sbi
op_assign
id|JFS_SBI
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* acquire the free iag lock */
id|IAGFREE_LOCK
c_func
(paren
id|imap
)paren
suffix:semicolon
multiline_comment|/* if there are any iags on the inode map free iag list, &n;&t; * allocate the iag from the head of the list.&n;&t; */
r_if
c_cond
(paren
id|imap-&gt;im_freeiag
op_ge
l_int|0
)paren
(brace
multiline_comment|/* pick up the iag number at the head of the list */
id|iagno
op_assign
id|imap-&gt;im_freeiag
suffix:semicolon
multiline_comment|/* determine the logical block number of the iag */
id|blkno
op_assign
id|IAGTOLBLK
c_func
(paren
id|iagno
comma
id|sbi-&gt;l2nbperpage
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no free iags. the inode map will have to be extented&n;&t;&t; * to include a new iag.&n;&t;&t; */
multiline_comment|/* acquire inode map lock */
id|IWRITE_LOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
m_assert
(paren
id|ipimap-&gt;i_size
op_rshift
id|L2PSIZE
op_eq
id|imap-&gt;im_nextiag
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* get the next avaliable iag number */
id|iagno
op_assign
id|imap-&gt;im_nextiag
suffix:semicolon
multiline_comment|/* make sure that we have not exceeded the maximum inode&n;&t;&t; * number limit.&n;&t;&t; */
r_if
c_cond
(paren
id|iagno
OG
(paren
id|MAXIAGS
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* release the inode map lock */
id|IWRITE_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|rc
op_assign
id|ENOSPC
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * synchronously append new iag page.&n;&t;&t; */
multiline_comment|/* determine the logical address of iag page to append */
id|blkno
op_assign
id|IAGTOLBLK
c_func
(paren
id|iagno
comma
id|sbi-&gt;l2nbperpage
)paren
suffix:semicolon
multiline_comment|/* Allocate extent for new iag page */
id|xlen
op_assign
id|sbi-&gt;nbperpage
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|dbAlloc
c_func
(paren
id|ipimap
comma
l_int|0
comma
(paren
id|s64
)paren
id|xlen
comma
op_amp
id|xaddr
)paren
)paren
)paren
(brace
multiline_comment|/* release the inode map lock */
id|IWRITE_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* assign a buffer for the page */
id|mp
op_assign
id|get_metapage
c_func
(paren
id|ipimap
comma
id|xaddr
comma
id|PSIZE
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|//bp = bmAssign(ipimap, blkno, xaddr, PSIZE, bmREAD_PAGE);
r_if
c_cond
(paren
op_logical_neg
id|mp
)paren
(brace
multiline_comment|/* Free the blocks allocated for the iag since it was&n;&t;&t;&t; * not successfully added to the inode map&n;&t;&t;&t; */
id|dbFree
c_func
(paren
id|ipimap
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
multiline_comment|/* release the inode map lock */
id|IWRITE_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|rc
op_assign
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* init the iag */
id|memset
c_func
(paren
id|iagp
comma
l_int|0
comma
r_sizeof
(paren
id|iag_t
)paren
)paren
suffix:semicolon
id|iagp-&gt;iagnum
op_assign
id|cpu_to_le32
c_func
(paren
id|iagno
)paren
suffix:semicolon
id|iagp-&gt;inofreefwd
op_assign
id|iagp-&gt;inofreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|iagp-&gt;extfreefwd
op_assign
id|iagp-&gt;extfreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|iagp-&gt;iagfree
op_assign
op_minus
l_int|1
suffix:semicolon
id|iagp-&gt;nfreeinos
op_assign
l_int|0
suffix:semicolon
id|iagp-&gt;nfreeexts
op_assign
id|cpu_to_le32
c_func
(paren
id|EXTSPERIAG
)paren
suffix:semicolon
multiline_comment|/* initialize the free inode summary map (free extent&n;&t;&t; * summary map initialization handled by bzero).&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SMAPSZ
suffix:semicolon
id|i
op_increment
)paren
id|iagp-&gt;inosmap
(braket
id|i
)braket
op_assign
id|ONES
suffix:semicolon
id|flush_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#ifdef _STILL_TO_PORT
multiline_comment|/* synchronously write the iag page */
r_if
c_cond
(paren
id|bmWrite
c_func
(paren
id|bp
)paren
)paren
(brace
multiline_comment|/* Free the blocks allocated for the iag since it was&n;&t;&t;&t; * not successfully added to the inode map&n;&t;&t;&t; */
id|dbFree
c_func
(paren
id|ipimap
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
multiline_comment|/* release the inode map lock */
id|IWRITE_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|rc
op_assign
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Now the iag is on disk */
multiline_comment|/*&n;&t;&t; * start tyransaction of update of the inode map&n;&t;&t; * addressing structure pointing to the new iag page;&n;&t;&t; */
macro_line|#endif&t;&t;&t;&t;/*  _STILL_TO_PORT */
id|tid
op_assign
id|txBegin
c_func
(paren
id|sb
comma
id|COMMIT_FORCE
)paren
suffix:semicolon
multiline_comment|/* update the inode map addressing structure to point to it */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtInsert
c_func
(paren
id|tid
comma
id|ipimap
comma
l_int|0
comma
id|blkno
comma
id|xlen
comma
op_amp
id|xaddr
comma
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* Free the blocks allocated for the iag since it was&n;&t;&t;&t; * not successfully added to the inode map&n;&t;&t;&t; */
id|dbFree
c_func
(paren
id|ipimap
comma
id|xaddr
comma
(paren
id|s64
)paren
id|xlen
)paren
suffix:semicolon
multiline_comment|/* release the inode map lock */
id|IWRITE_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* update the inode map&squot;s inode to reflect the extension */
id|ipimap-&gt;i_size
op_add_assign
id|PSIZE
suffix:semicolon
id|ipimap-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|sb
comma
id|xlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * txCommit(COMMIT_FORCE) will synchronously write address &n;&t;&t; * index pages and inode after commit in careful update order &n;&t;&t; * of address index pages (right to left, bottom up);&n;&t;&t; */
id|iplist
(braket
l_int|0
)braket
op_assign
id|ipimap
suffix:semicolon
id|rc
op_assign
id|txCommit
c_func
(paren
id|tid
comma
l_int|1
comma
op_amp
id|iplist
(braket
l_int|0
)braket
comma
id|COMMIT_FORCE
)paren
suffix:semicolon
id|txEnd
c_func
(paren
id|tid
)paren
suffix:semicolon
id|duplicateIXtree
c_func
(paren
id|sb
comma
id|blkno
comma
id|xlen
comma
op_amp
id|xaddr
)paren
suffix:semicolon
multiline_comment|/* update the next avaliable iag number */
id|imap-&gt;im_nextiag
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* Add the iag to the iag free list so we don&squot;t lose the iag&n;&t;&t; * if a failure happens now.&n;&t;&t; */
id|imap-&gt;im_freeiag
op_assign
id|iagno
suffix:semicolon
multiline_comment|/* Until we have logredo working, we want the imap inode &amp;&n;&t;&t; * control page to be up to date.&n;&t;&t; */
id|diSync
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/* release the inode map lock */
id|IWRITE_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
)brace
multiline_comment|/* obtain read lock on map */
id|IREAD_LOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
multiline_comment|/* read the iag */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|iagno
comma
op_amp
id|mp
)paren
)paren
)paren
(brace
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|rc
op_assign
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* remove the iag from the iag free list */
id|imap-&gt;im_freeiag
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;iagfree
)paren
suffix:semicolon
id|iagp-&gt;iagfree
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* set the return iag number and buffer pointer */
op_star
id|iagnop
op_assign
id|iagno
suffix:semicolon
op_star
id|mpp
op_assign
id|mp
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* release the iag free lock */
id|IAGFREE_UNLOCK
c_func
(paren
id|imap
)paren
suffix:semicolon
r_return
(paren
id|rc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diIAGRead()&n; *&n; * FUNCTION:    get the buffer for the specified iag within a fileset&n; *&t;&t;or aggregate inode map.&n; *&t;&t;&n; * PARAMETERS:&n; *      imap  &t;- pointer to inode map control structure.&n; *      iagno  &t;- iag number.&n; *      bpp  &t;- point to buffer pointer to be filled in on successful&n; *&t;&t;  exit.&n; *&n; * SERIALIZATION:&n; *&t;must have read lock on imap inode&n; *&t;(When called by diExtendFS, the filesystem is quiesced, therefore&n; *&t; the read lock is unnecessary.)&n; *&n; * RETURN VALUES:&n; *      0       - success.&n; *      EIO  &t;- i/o error.&n; */
DECL|function|diIAGRead
r_static
r_int
id|diIAGRead
c_func
(paren
id|imap_t
op_star
id|imap
comma
r_int
id|iagno
comma
id|metapage_t
op_star
op_star
id|mpp
)paren
(brace
r_struct
id|inode
op_star
id|ipimap
op_assign
id|imap-&gt;im_ipimap
suffix:semicolon
id|s64
id|blkno
suffix:semicolon
multiline_comment|/* compute the logical block number of the iag. */
id|blkno
op_assign
id|IAGTOLBLK
c_func
(paren
id|iagno
comma
id|JFS_SBI
c_func
(paren
id|ipimap-&gt;i_sb
)paren
op_member_access_from_pointer
id|l2nbperpage
)paren
suffix:semicolon
multiline_comment|/* read the iag. */
op_star
id|mpp
op_assign
id|read_metapage
c_func
(paren
id|ipimap
comma
id|blkno
comma
id|PSIZE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|mpp
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        diFindFree()&n; *&n; * FUNCTION:    find the first free bit in a word starting at&n; *&t;&t;the specified bit position.&n; *&n; * PARAMETERS:&n; *      word  &t;- word to be examined.&n; *      start  &t;- starting bit position.&n; *&n; * RETURN VALUES:&n; *      bit position of first free bit in the word or 32 if&n; *&t;no free bits were found.&n; */
DECL|function|diFindFree
r_static
r_int
id|diFindFree
c_func
(paren
id|u32
id|word
comma
r_int
id|start
)paren
(brace
r_int
id|bitno
suffix:semicolon
m_assert
(paren
id|start
OL
l_int|32
)paren
suffix:semicolon
multiline_comment|/* scan the word for the first free bit. */
r_for
c_loop
(paren
id|word
op_lshift_assign
id|start
comma
id|bitno
op_assign
id|start
suffix:semicolon
id|bitno
OL
l_int|32
suffix:semicolon
id|bitno
op_increment
comma
id|word
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|word
op_amp
id|HIGHORDER
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|bitno
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:&t;diUpdatePMap()&n; *                                                                    &n; * FUNCTION: Update the persistent map in an IAG for the allocation or &n; *&t;freeing of the specified inode.&n; *                                                                    &n; * PRE CONDITIONS: Working map has already been updated for allocate.&n; *&n; * PARAMETERS:&n; *&t;ipimap&t;- Incore inode map inode&n; *&t;inum&t;- Number of inode to mark in permanent map&n; *&t;is_free&t;- If TRUE indicates inode should be marked freed, otherwise&n; *&t;&t;  indicates inode should be marked allocated.&n; *&n; * RETURNS: 0 for success&n; */
r_int
DECL|function|diUpdatePMap
id|diUpdatePMap
c_func
(paren
r_struct
id|inode
op_star
id|ipimap
comma
r_int
r_int
id|inum
comma
id|boolean_t
id|is_free
comma
id|tblock_t
op_star
id|tblk
)paren
(brace
r_int
id|rc
suffix:semicolon
id|iag_t
op_star
id|iagp
suffix:semicolon
id|metapage_t
op_star
id|mp
suffix:semicolon
r_int
id|iagno
comma
id|ino
comma
id|extno
comma
id|bitno
suffix:semicolon
id|imap_t
op_star
id|imap
suffix:semicolon
id|u32
id|mask
suffix:semicolon
id|log_t
op_star
id|log
suffix:semicolon
r_int
id|lsn
comma
id|difft
comma
id|diffp
suffix:semicolon
id|imap
op_assign
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
suffix:semicolon
multiline_comment|/* get the iag number containing the inode */
id|iagno
op_assign
id|INOTOIAG
c_func
(paren
id|inum
)paren
suffix:semicolon
multiline_comment|/* make sure that the iag is contained within the map */
m_assert
(paren
id|iagno
OL
id|imap-&gt;im_nextiag
)paren
suffix:semicolon
multiline_comment|/* read the iag */
id|IREAD_LOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|iagno
comma
op_amp
id|mp
)paren
suffix:semicolon
id|IREAD_UNLOCK
c_func
(paren
id|ipimap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
(paren
id|rc
)paren
suffix:semicolon
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|mp-&gt;data
suffix:semicolon
multiline_comment|/* get the inode number and extent number of the inode within&n;&t; * the iag and the inode number within the extent.&n;&t; */
id|ino
op_assign
id|inum
op_amp
(paren
id|INOSPERIAG
op_minus
l_int|1
)paren
suffix:semicolon
id|extno
op_assign
id|ino
op_rshift
id|L2INOSPEREXT
suffix:semicolon
id|bitno
op_assign
id|ino
op_amp
(paren
id|INOSPEREXT
op_minus
l_int|1
)paren
suffix:semicolon
id|mask
op_assign
id|HIGHORDER
op_rshift
id|bitno
suffix:semicolon
multiline_comment|/* &n;&t; * mark the inode free in persistent map:&n;&t; */
r_if
c_cond
(paren
id|is_free
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* The inode should have been allocated both in working&n;&t;&t; * map and in persistent map;&n;&t;&t; * the inode will be freed from working map at the release&n;&t;&t; * of last reference release;&n;&t;&t; */
singleline_comment|//              assert(le32_to_cpu(iagp-&gt;wmap[extno]) &amp; mask);
r_if
c_cond
(paren
op_logical_neg
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diUpdatePMap: inode %ld not marked as allocated in wmap!&bslash;n&quot;
comma
id|inum
)paren
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ipimap-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
)brace
singleline_comment|//              assert(le32_to_cpu(iagp-&gt;pmap[extno]) &amp; mask);
r_if
c_cond
(paren
op_logical_neg
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;pmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
)paren
(brace
id|jERROR
c_func
(paren
l_int|1
comma
(paren
l_string|&quot;diUpdatePMap: inode %ld not marked as allocated in pmap!&bslash;n&quot;
comma
id|inum
)paren
)paren
suffix:semicolon
id|updateSuper
c_func
(paren
id|ipimap-&gt;i_sb
comma
id|FM_DIRTY
)paren
suffix:semicolon
)brace
multiline_comment|/* update the bitmap for the extent of the freed inode */
id|iagp-&gt;pmap
(braket
id|extno
)braket
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * mark the inode allocated in persistent map:&n;&t; */
r_else
(brace
multiline_comment|/* The inode should be already allocated in the working map&n;&t;&t; * and should be free in persistent map;&n;&t;&t; */
m_assert
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;wmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
suffix:semicolon
m_assert
(paren
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;pmap
(braket
id|extno
)braket
)paren
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* update the bitmap for the extent of the allocated inode */
id|iagp-&gt;pmap
(braket
id|extno
)braket
op_or_assign
id|cpu_to_le32
c_func
(paren
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * update iag lsn&n;&t; */
id|lsn
op_assign
id|tblk-&gt;lsn
suffix:semicolon
id|log
op_assign
id|JFS_SBI
c_func
(paren
id|tblk-&gt;sb
)paren
op_member_access_from_pointer
id|log
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;lsn
op_ne
l_int|0
)paren
(brace
multiline_comment|/* inherit older/smaller lsn */
id|logdiff
c_func
(paren
id|difft
comma
id|lsn
comma
id|log
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|diffp
comma
id|mp-&gt;lsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|difft
OL
id|diffp
)paren
(brace
id|mp-&gt;lsn
op_assign
id|lsn
suffix:semicolon
multiline_comment|/* move mp after tblock in logsync list */
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|mp-&gt;synclist
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mp-&gt;synclist
comma
op_amp
id|tblk-&gt;synclist
)paren
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
multiline_comment|/* inherit younger/larger clsn */
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
m_assert
(paren
id|mp-&gt;clsn
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|difft
comma
id|tblk-&gt;clsn
comma
id|log
)paren
suffix:semicolon
id|logdiff
c_func
(paren
id|diffp
comma
id|mp-&gt;clsn
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|difft
OG
id|diffp
)paren
id|mp-&gt;clsn
op_assign
id|tblk-&gt;clsn
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;log
op_assign
id|log
suffix:semicolon
id|mp-&gt;lsn
op_assign
id|lsn
suffix:semicolon
multiline_comment|/* insert mp after tblock in logsync list */
id|LOGSYNC_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|log-&gt;count
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|mp-&gt;synclist
comma
op_amp
id|tblk-&gt;synclist
)paren
suffix:semicolon
id|mp-&gt;clsn
op_assign
id|tblk-&gt;clsn
suffix:semicolon
id|LOGSYNC_UNLOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
singleline_comment|//      bmLazyWrite(mp, log-&gt;flag &amp; JFS_COMMIT);
id|write_metapage
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;diExtendFS()&n; *&n; * function: update imap for extendfs();&n; * &n; * note: AG size has been increased s.t. each k old contiguous AGs are &n; * coalesced into a new AG;&n; */
DECL|function|diExtendFS
r_int
id|diExtendFS
c_func
(paren
r_struct
id|inode
op_star
id|ipimap
comma
r_struct
id|inode
op_star
id|ipbmap
)paren
(brace
r_int
id|rc
comma
id|rcx
op_assign
l_int|0
suffix:semicolon
id|imap_t
op_star
id|imap
op_assign
id|JFS_IP
c_func
(paren
id|ipimap
)paren
op_member_access_from_pointer
id|i_imap
suffix:semicolon
id|iag_t
op_star
id|iagp
op_assign
l_int|0
comma
op_star
id|hiagp
op_assign
l_int|0
suffix:semicolon
id|bmap_t
op_star
id|mp
op_assign
id|JFS_SBI
c_func
(paren
id|ipbmap-&gt;i_sb
)paren
op_member_access_from_pointer
id|bmap
suffix:semicolon
id|metapage_t
op_star
id|bp
comma
op_star
id|hbp
suffix:semicolon
r_int
id|i
comma
id|n
comma
id|head
suffix:semicolon
r_int
id|numinos
comma
id|xnuminos
op_assign
l_int|0
comma
id|xnumfree
op_assign
l_int|0
suffix:semicolon
id|s64
id|agstart
suffix:semicolon
id|jEVENT
c_func
(paren
l_int|0
comma
(paren
l_string|&quot;diExtendFS: nextiag:%d numinos:%d numfree:%d&bslash;n&quot;
comma
id|imap-&gt;im_nextiag
comma
id|atomic_read
c_func
(paren
op_amp
id|imap-&gt;im_numinos
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|imap-&gt;im_numfree
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      reconstruct imap &n;&t; *&n;&t; * coalesce contiguous k (newAGSize/oldAGSize) AGs;&n;&t; * i.e., (AGi, ..., AGj) where i = k*n and j = k*(n+1) - 1 to AGn;&n;&t; * note: new AG size = old AG size * (2**x).&n;&t; */
multiline_comment|/* init per AG control information im_agctl[] */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXAG
suffix:semicolon
id|i
op_increment
)paren
(brace
id|imap-&gt;im_agctl
(braket
id|i
)braket
dot
id|inofree
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* free inode list */
id|imap-&gt;im_agctl
(braket
id|i
)braket
dot
id|extfree
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* free extent list */
id|imap-&gt;im_agctl
(braket
id|i
)braket
dot
id|numinos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of backed inodes */
id|imap-&gt;im_agctl
(braket
id|i
)braket
dot
id|numfree
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of free backed inodes */
)brace
multiline_comment|/*&n;&t; *      process each iag_t page of the map.&n;&t; *&n;&t; * rebuild AG Free Inode List, AG Free Inode Extent List;&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|imap-&gt;im_nextiag
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|i
comma
op_amp
id|bp
)paren
)paren
)paren
(brace
id|rcx
op_assign
id|rc
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|iagp
op_assign
(paren
id|iag_t
op_star
)paren
id|bp-&gt;data
suffix:semicolon
m_assert
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;iagnum
)paren
op_eq
id|i
)paren
suffix:semicolon
multiline_comment|/* leave free iag in the free iag list */
r_if
c_cond
(paren
id|iagp-&gt;nfreeexts
op_eq
id|cpu_to_le32
c_func
(paren
id|EXTSPERIAG
)paren
)paren
(brace
id|release_metapage
c_func
(paren
id|bp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* agstart that computes to the same ag is treated as same; */
id|agstart
op_assign
id|le64_to_cpu
c_func
(paren
id|iagp-&gt;agstart
)paren
suffix:semicolon
multiline_comment|/* iagp-&gt;agstart = agstart &amp; ~(mp-&gt;db_agsize - 1); */
id|n
op_assign
id|agstart
op_rshift
id|mp-&gt;db_agl2size
suffix:semicolon
multiline_comment|/*&n;printf(&quot;diExtendFS: iag:%d agstart:%Ld agno:%d&bslash;n&quot;, i, agstart, n);&n;*/
multiline_comment|/* compute backed inodes */
id|numinos
op_assign
(paren
id|EXTSPERIAG
op_minus
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeexts
)paren
)paren
op_lshift
id|L2INOSPEREXT
suffix:semicolon
r_if
c_cond
(paren
id|numinos
OG
l_int|0
)paren
(brace
multiline_comment|/* merge AG backed inodes */
id|imap-&gt;im_agctl
(braket
id|n
)braket
dot
id|numinos
op_add_assign
id|numinos
suffix:semicolon
id|xnuminos
op_add_assign
id|numinos
suffix:semicolon
)brace
multiline_comment|/* if any backed free inodes, insert at AG free inode list */
r_if
c_cond
(paren
(paren
r_int
)paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeinos
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|head
op_assign
id|imap-&gt;im_agctl
(braket
id|n
)braket
dot
id|inofree
)paren
op_eq
op_minus
l_int|1
)paren
id|iagp-&gt;inofreefwd
op_assign
id|iagp-&gt;inofreeback
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|head
comma
op_amp
id|hbp
)paren
)paren
)paren
(brace
id|rcx
op_assign
id|rc
suffix:semicolon
r_goto
id|nextiag
suffix:semicolon
)brace
id|hiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|hbp-&gt;data
suffix:semicolon
id|hiagp-&gt;inofreeback
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;iagnum
)paren
suffix:semicolon
id|iagp-&gt;inofreefwd
op_assign
id|cpu_to_le32
c_func
(paren
id|head
)paren
suffix:semicolon
id|iagp-&gt;inofreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|write_metapage
c_func
(paren
id|hbp
)paren
suffix:semicolon
)brace
id|imap-&gt;im_agctl
(braket
id|n
)braket
dot
id|inofree
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;iagnum
)paren
suffix:semicolon
multiline_comment|/* merge AG backed free inodes */
id|imap-&gt;im_agctl
(braket
id|n
)braket
dot
id|numfree
op_add_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeinos
)paren
suffix:semicolon
id|xnumfree
op_add_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeinos
)paren
suffix:semicolon
)brace
multiline_comment|/* if any free extents, insert at AG free extent list */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;nfreeexts
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|head
op_assign
id|imap-&gt;im_agctl
(braket
id|n
)braket
dot
id|extfree
)paren
op_eq
op_minus
l_int|1
)paren
id|iagp-&gt;extfreefwd
op_assign
id|iagp-&gt;extfreeback
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|diIAGRead
c_func
(paren
id|imap
comma
id|head
comma
op_amp
id|hbp
)paren
)paren
)paren
(brace
id|rcx
op_assign
id|rc
suffix:semicolon
r_goto
id|nextiag
suffix:semicolon
)brace
id|hiagp
op_assign
(paren
id|iag_t
op_star
)paren
id|hbp-&gt;data
suffix:semicolon
id|hiagp-&gt;extfreeback
op_assign
id|iagp-&gt;iagnum
suffix:semicolon
id|iagp-&gt;extfreefwd
op_assign
id|cpu_to_le32
c_func
(paren
id|head
)paren
suffix:semicolon
id|iagp-&gt;extfreeback
op_assign
op_minus
l_int|1
suffix:semicolon
id|write_metapage
c_func
(paren
id|hbp
)paren
suffix:semicolon
)brace
id|imap-&gt;im_agctl
(braket
id|n
)braket
dot
id|extfree
op_assign
id|le32_to_cpu
c_func
(paren
id|iagp-&gt;iagnum
)paren
suffix:semicolon
)brace
id|nextiag
suffix:colon
id|write_metapage
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|xnuminos
op_eq
id|atomic_read
c_func
(paren
op_amp
id|imap-&gt;im_numinos
)paren
op_logical_and
id|xnumfree
op_eq
id|atomic_read
c_func
(paren
op_amp
id|imap-&gt;im_numfree
)paren
)paren
suffix:semicolon
r_return
id|rcx
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;duplicateIXtree()&n; *&n; * serialization: IWRITE_LOCK held on entry/exit&n; *&n; * note: shadow page with regular inode (rel.2);&n; */
r_static
r_void
DECL|function|duplicateIXtree
id|duplicateIXtree
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|s64
id|blkno
comma
r_int
id|xlen
comma
id|s64
op_star
id|xaddr
)paren
(brace
r_int
id|rc
suffix:semicolon
id|tid_t
id|tid
suffix:semicolon
r_struct
id|inode
op_star
id|ip
suffix:semicolon
id|metapage_t
op_star
id|mpsuper
suffix:semicolon
r_struct
id|jfs_superblock
op_star
id|j_sb
suffix:semicolon
multiline_comment|/* if AIT2 ipmap2 is bad, do not try to update it */
r_if
c_cond
(paren
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|mntflag
op_amp
id|JFS_BAD_SAIT
)paren
multiline_comment|/* s_flag */
r_return
suffix:semicolon
id|ip
op_assign
id|diReadSpecial
c_func
(paren
id|sb
comma
id|FILESYSTEM_I
op_plus
id|INOSPEREXT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|0
)paren
(brace
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|mntflag
op_or_assign
id|JFS_BAD_SAIT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|readSuper
c_func
(paren
id|sb
comma
op_amp
id|mpsuper
)paren
)paren
)paren
r_return
suffix:semicolon
id|j_sb
op_assign
(paren
r_struct
id|jfs_superblock
op_star
)paren
(paren
id|mpsuper-&gt;data
)paren
suffix:semicolon
id|j_sb-&gt;s_flag
op_or_assign
id|JFS_BAD_SAIT
suffix:semicolon
id|write_metapage
c_func
(paren
id|mpsuper
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* start transaction */
id|tid
op_assign
id|txBegin
c_func
(paren
id|sb
comma
id|COMMIT_FORCE
)paren
suffix:semicolon
multiline_comment|/* update the inode map addressing structure to point to it */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|xtInsert
c_func
(paren
id|tid
comma
id|ip
comma
l_int|0
comma
id|blkno
comma
id|xlen
comma
id|xaddr
comma
l_int|0
)paren
)paren
)paren
(brace
id|JFS_SBI
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|mntflag
op_or_assign
id|JFS_BAD_SAIT
suffix:semicolon
id|txAbort
c_func
(paren
id|tid
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* update the inode map&squot;s inode to reflect the extension */
id|ip-&gt;i_size
op_add_assign
id|PSIZE
suffix:semicolon
id|ip-&gt;i_blocks
op_add_assign
id|LBLK2PBLK
c_func
(paren
id|sb
comma
id|xlen
)paren
suffix:semicolon
id|rc
op_assign
id|txCommit
c_func
(paren
id|tid
comma
l_int|1
comma
op_amp
id|ip
comma
id|COMMIT_FORCE
)paren
suffix:semicolon
id|cleanup
suffix:colon
id|txEnd
c_func
(paren
id|tid
)paren
suffix:semicolon
id|diFreeSpecial
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        copy_from_dinode()&n; *&n; * FUNCTION:    Copies inode info from disk inode to in-memory inode&n; *&n; * RETURN VALUES:&n; *      0       - success&n; *      ENOMEM&t;- insufficient memory&n; */
DECL|function|copy_from_dinode
r_static
r_int
id|copy_from_dinode
c_func
(paren
id|dinode_t
op_star
id|dip
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|jfs_ip-&gt;fileset
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_fileset
)paren
suffix:semicolon
id|jfs_ip-&gt;mode2
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_mode
)paren
suffix:semicolon
id|ip-&gt;i_mode
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_mode
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|ip-&gt;i_nlink
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_nlink
)paren
suffix:semicolon
id|ip-&gt;i_uid
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_uid
)paren
suffix:semicolon
id|ip-&gt;i_gid
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_gid
)paren
suffix:semicolon
id|ip-&gt;i_size
op_assign
id|le64_to_cpu
c_func
(paren
id|dip-&gt;di_size
)paren
suffix:semicolon
id|ip-&gt;i_atime
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_atime.tv_sec
)paren
suffix:semicolon
id|ip-&gt;i_mtime
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_mtime.tv_sec
)paren
suffix:semicolon
id|ip-&gt;i_ctime
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_ctime.tv_sec
)paren
suffix:semicolon
id|ip-&gt;i_blksize
op_assign
id|ip-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
id|ip-&gt;i_blocks
op_assign
id|LBLK2PBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|le64_to_cpu
c_func
(paren
id|dip-&gt;di_nblocks
)paren
)paren
suffix:semicolon
id|ip-&gt;i_version
op_assign
op_increment
id|event
suffix:semicolon
id|ip-&gt;i_generation
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_gen
)paren
suffix:semicolon
id|jfs_ip-&gt;ixpxd
op_assign
id|dip-&gt;di_ixpxd
suffix:semicolon
multiline_comment|/* in-memory pxd&squot;s are little-endian */
id|jfs_ip-&gt;acl
op_assign
id|dip-&gt;di_acl
suffix:semicolon
multiline_comment|/* as are dxd&squot;s */
id|jfs_ip-&gt;ea
op_assign
id|dip-&gt;di_ea
suffix:semicolon
id|jfs_ip-&gt;next_index
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_next_index
)paren
suffix:semicolon
id|jfs_ip-&gt;otime
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_otime.tv_sec
)paren
suffix:semicolon
id|jfs_ip-&gt;acltype
op_assign
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_acltype
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We may only need to do this for &quot;special&quot; inodes (dmap, imap)&n;&t; */
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|ip-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
id|ip-&gt;i_rdev
op_assign
id|to_kdev_t
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|dip-&gt;di_rdev
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|jfs_ip-&gt;i_dirtable
comma
op_amp
id|dip-&gt;di_dirtable
comma
l_int|384
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|S_ISFIFO
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|jfs_ip-&gt;i_xtroot
comma
op_amp
id|dip-&gt;di_xtroot
comma
l_int|288
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero the in-memory-only stuff */
id|jfs_ip-&gt;cflag
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;btindex
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;btorder
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;bxflag
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;blid
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;atlhead
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;atltail
op_assign
l_int|0
suffix:semicolon
id|jfs_ip-&gt;xtlid
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * NAME:        copy_to_dinode()&n; *&n; * FUNCTION:    Copies inode info from in-memory inode to disk inode&n; */
DECL|function|copy_to_dinode
r_static
r_void
id|copy_to_dinode
c_func
(paren
id|dinode_t
op_star
id|dip
comma
r_struct
id|inode
op_star
id|ip
)paren
(brace
r_struct
id|jfs_inode_info
op_star
id|jfs_ip
op_assign
id|JFS_IP
c_func
(paren
id|ip
)paren
suffix:semicolon
id|dip-&gt;di_fileset
op_assign
id|cpu_to_le32
c_func
(paren
id|jfs_ip-&gt;fileset
)paren
suffix:semicolon
id|dip-&gt;di_inostamp
op_assign
id|cpu_to_le32
c_func
(paren
id|JFS_SBI
c_func
(paren
id|ip-&gt;i_sb
)paren
op_member_access_from_pointer
id|inostamp
)paren
suffix:semicolon
id|dip-&gt;di_number
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|dip-&gt;di_gen
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_generation
)paren
suffix:semicolon
id|dip-&gt;di_size
op_assign
id|cpu_to_le64
c_func
(paren
id|ip-&gt;i_size
)paren
suffix:semicolon
id|dip-&gt;di_nblocks
op_assign
id|cpu_to_le64
c_func
(paren
id|PBLK2LBLK
c_func
(paren
id|ip-&gt;i_sb
comma
id|ip-&gt;i_blocks
)paren
)paren
suffix:semicolon
id|dip-&gt;di_nlink
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_nlink
)paren
suffix:semicolon
id|dip-&gt;di_uid
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_uid
)paren
suffix:semicolon
id|dip-&gt;di_gid
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_gid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * mode2 is only needed for storing the higher order bits.&n;&t; * Trust i_mode for the lower order ones&n;&t; */
id|dip-&gt;di_mode
op_assign
id|cpu_to_le32
c_func
(paren
(paren
id|jfs_ip-&gt;mode2
op_amp
l_int|0xffff0000
)paren
op_or
id|ip-&gt;i_mode
)paren
suffix:semicolon
id|dip-&gt;di_atime.tv_sec
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_atime
)paren
suffix:semicolon
id|dip-&gt;di_atime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|dip-&gt;di_ctime.tv_sec
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_ctime
)paren
suffix:semicolon
id|dip-&gt;di_ctime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|dip-&gt;di_mtime.tv_sec
op_assign
id|cpu_to_le32
c_func
(paren
id|ip-&gt;i_mtime
)paren
suffix:semicolon
id|dip-&gt;di_mtime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|dip-&gt;di_ixpxd
op_assign
id|jfs_ip-&gt;ixpxd
suffix:semicolon
multiline_comment|/* in-memory pxd&squot;s are little-endian */
id|dip-&gt;di_acl
op_assign
id|jfs_ip-&gt;acl
suffix:semicolon
multiline_comment|/* as are dxd&squot;s */
id|dip-&gt;di_ea
op_assign
id|jfs_ip-&gt;ea
suffix:semicolon
id|dip-&gt;di_next_index
op_assign
id|cpu_to_le32
c_func
(paren
id|jfs_ip-&gt;next_index
)paren
suffix:semicolon
id|dip-&gt;di_otime.tv_sec
op_assign
id|cpu_to_le32
c_func
(paren
id|jfs_ip-&gt;otime
)paren
suffix:semicolon
id|dip-&gt;di_otime.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|dip-&gt;di_acltype
op_assign
id|cpu_to_le32
c_func
(paren
id|jfs_ip-&gt;acltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|ip-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|ip-&gt;i_mode
)paren
)paren
id|dip-&gt;di_rdev
op_assign
id|cpu_to_le32
c_func
(paren
id|kdev_t_to_nr
c_func
(paren
id|ip-&gt;i_rdev
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef&t;_JFS_DEBUG_IMAP
multiline_comment|/*&n; *&t;DBGdiInit()&n; */
DECL|function|DBGdiInit
r_static
r_void
op_star
id|DBGdiInit
c_func
(paren
id|imap_t
op_star
id|imap
)paren
(brace
id|u32
op_star
id|dimap
suffix:semicolon
r_int
id|size
suffix:semicolon
id|size
op_assign
l_int|64
op_star
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dimap
op_assign
(paren
id|u32
op_star
)paren
id|xmalloc
c_func
(paren
id|size
comma
id|L2PSIZE
comma
id|kernel_heap
)paren
)paren
op_eq
l_int|NULL
)paren
m_assert
(paren
l_int|0
)paren
suffix:semicolon
id|bzero
c_func
(paren
(paren
r_void
op_star
)paren
id|dimap
comma
id|size
)paren
suffix:semicolon
id|imap-&gt;im_DBGdimap
op_assign
id|dimap
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;DBGdiAlloc()&n; */
DECL|function|DBGdiAlloc
r_static
r_void
id|DBGdiAlloc
c_func
(paren
id|imap_t
op_star
id|imap
comma
id|ino_t
id|ino
)paren
(brace
id|u32
op_star
id|dimap
op_assign
id|imap-&gt;im_DBGdimap
suffix:semicolon
r_int
id|w
comma
id|b
suffix:semicolon
id|u32
id|m
suffix:semicolon
id|w
op_assign
id|ino
op_rshift
l_int|5
suffix:semicolon
id|b
op_assign
id|ino
op_amp
l_int|31
suffix:semicolon
id|m
op_assign
l_int|0x80000000
op_rshift
id|b
suffix:semicolon
m_assert
(paren
id|w
OL
l_int|64
op_star
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dimap
(braket
id|w
)braket
op_amp
id|m
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEBUG diAlloc: duplicate alloc ino:0x%x&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
)brace
id|dimap
(braket
id|w
)braket
op_or_assign
id|m
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;DBGdiFree()&n; */
DECL|function|DBGdiFree
r_static
r_void
id|DBGdiFree
c_func
(paren
id|imap_t
op_star
id|imap
comma
id|ino_t
id|ino
)paren
(brace
id|u32
op_star
id|dimap
op_assign
id|imap-&gt;im_DBGdimap
suffix:semicolon
r_int
id|w
comma
id|b
suffix:semicolon
id|u32
id|m
suffix:semicolon
id|w
op_assign
id|ino
op_rshift
l_int|5
suffix:semicolon
id|b
op_assign
id|ino
op_amp
l_int|31
suffix:semicolon
id|m
op_assign
l_int|0x80000000
op_rshift
id|b
suffix:semicolon
m_assert
(paren
id|w
OL
l_int|64
op_star
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dimap
(braket
id|w
)braket
op_amp
id|m
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEBUG diFree: duplicate free ino:0x%x&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
)brace
id|dimap
(braket
id|w
)braket
op_and_assign
op_complement
id|m
suffix:semicolon
)brace
DECL|function|dump_cp
r_static
r_void
id|dump_cp
c_func
(paren
id|imap_t
op_star
id|ipimap
comma
r_char
op_star
id|function
comma
r_int
id|line
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n* ********* *&bslash;nControl Page %s %d&bslash;n&quot;
comma
id|function
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;FreeIAG %d&bslash;tNextIAG %d&bslash;n&quot;
comma
id|ipimap-&gt;im_freeiag
comma
id|ipimap-&gt;im_nextiag
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NumInos %d&bslash;tNumFree %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ipimap-&gt;im_numinos
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|ipimap-&gt;im_numfree
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AG InoFree %d&bslash;tAG ExtFree %d&bslash;n&quot;
comma
id|ipimap-&gt;im_agctl
(braket
l_int|0
)braket
dot
id|inofree
comma
id|ipimap-&gt;im_agctl
(braket
l_int|0
)braket
dot
id|extfree
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AG NumInos %d&bslash;tAG NumFree %d&bslash;n&quot;
comma
id|ipimap-&gt;im_agctl
(braket
l_int|0
)braket
dot
id|numinos
comma
id|ipimap-&gt;im_agctl
(braket
l_int|0
)braket
dot
id|numfree
)paren
suffix:semicolon
)brace
DECL|function|dump_iag
r_static
r_void
id|dump_iag
c_func
(paren
id|iag_t
op_star
id|iag
comma
r_char
op_star
id|function
comma
r_int
id|line
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n* ********* *&bslash;nIAG %s %d&bslash;n&quot;
comma
id|function
comma
id|line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IagNum %d&bslash;tIAG Free %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;iagnum
)paren
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;iagfree
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;InoFreeFwd %d&bslash;tInoFreeBack %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;inofreefwd
)paren
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;inofreeback
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ExtFreeFwd %d&bslash;tExtFreeBack %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;extfreefwd
)paren
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;extfreeback
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NFreeInos %d&bslash;tNFreeExts %d&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;nfreeinos
)paren
comma
id|le32_to_cpu
c_func
(paren
id|iag-&gt;nfreeexts
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* _JFS_DEBUG_IMAP */
eof
