multiline_comment|/*&n; *  linux/fs/compat.c&n; *&n; *  Kernel compatibililty routines for e.g. 32 bit syscall support&n; *  on 64 bit kernels.&n; *&n; *  Copyright (C) 2002       Stephen Rothwell, IBM Corporation&n; *  Copyright (C) 1997-2000  Jakub Jelinek  (jakub@redhat.com)&n; *  Copyright (C) 1998       Eddie C. Dost  (ecd@skynet.be)&n; *  Copyright (C) 2001,2002  Andi Kleen, SuSE Labs &n; *  Copyright (C) 2003       Pavel Machek (pavel@suse.cz)&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License version 2 as&n; *  published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/compat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/vfs.h&gt;
macro_line|#include &lt;linux/ioctl32.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;&t;/* for SIOCDEVPRIVATE */
macro_line|#include &lt;linux/smb.h&gt;
macro_line|#include &lt;linux/smb_mount.h&gt;
macro_line|#include &lt;linux/ncp_mount.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/dirent.h&gt;
macro_line|#include &lt;linux/dnotify.h&gt;
macro_line|#include &lt;linux/highuid.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
macro_line|#include &lt;linux/nfsd/syscall.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;net/sock.h&gt;&t;&t;/* siocdevprivate_ioctl */
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
multiline_comment|/*&n; * Not all architectures have sys_utime, so implement this in terms&n; * of sys_utimes.&n; */
DECL|function|compat_sys_utime
id|asmlinkage
r_int
id|compat_sys_utime
c_func
(paren
r_char
id|__user
op_star
id|filename
comma
r_struct
id|compat_utimbuf
id|__user
op_star
id|t
)paren
(brace
r_struct
id|timeval
id|tv
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|tv
(braket
l_int|0
)braket
dot
id|tv_sec
comma
op_amp
id|t-&gt;actime
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|1
)braket
dot
id|tv_sec
comma
op_amp
id|t-&gt;modtime
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tv
(braket
l_int|0
)braket
dot
id|tv_usec
op_assign
l_int|0
suffix:semicolon
id|tv
(braket
l_int|1
)braket
dot
id|tv_usec
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|do_utimes
c_func
(paren
id|filename
comma
id|t
ques
c_cond
id|tv
suffix:colon
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|compat_sys_utimes
id|asmlinkage
r_int
id|compat_sys_utimes
c_func
(paren
r_char
id|__user
op_star
id|filename
comma
r_struct
id|compat_timeval
id|__user
op_star
id|t
)paren
(brace
r_struct
id|timeval
id|tv
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|tv
(braket
l_int|0
)braket
dot
id|tv_sec
comma
op_amp
id|t
(braket
l_int|0
)braket
dot
id|tv_sec
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|0
)braket
dot
id|tv_usec
comma
op_amp
id|t
(braket
l_int|0
)braket
dot
id|tv_usec
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|1
)braket
dot
id|tv_sec
comma
op_amp
id|t
(braket
l_int|1
)braket
dot
id|tv_sec
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|1
)braket
dot
id|tv_usec
comma
op_amp
id|t
(braket
l_int|1
)braket
dot
id|tv_usec
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|do_utimes
c_func
(paren
id|filename
comma
id|t
ques
c_cond
id|tv
suffix:colon
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|compat_sys_newstat
id|asmlinkage
r_int
id|compat_sys_newstat
c_func
(paren
r_char
id|__user
op_star
id|filename
comma
r_struct
id|compat_stat
id|__user
op_star
id|statbuf
)paren
(brace
r_struct
id|kstat
id|stat
suffix:semicolon
r_int
id|error
op_assign
id|vfs_stat
c_func
(paren
id|filename
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|cp_compat_stat
c_func
(paren
op_amp
id|stat
comma
id|statbuf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_sys_newlstat
id|asmlinkage
r_int
id|compat_sys_newlstat
c_func
(paren
r_char
id|__user
op_star
id|filename
comma
r_struct
id|compat_stat
id|__user
op_star
id|statbuf
)paren
(brace
r_struct
id|kstat
id|stat
suffix:semicolon
r_int
id|error
op_assign
id|vfs_lstat
c_func
(paren
id|filename
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|cp_compat_stat
c_func
(paren
op_amp
id|stat
comma
id|statbuf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_sys_newfstat
id|asmlinkage
r_int
id|compat_sys_newfstat
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|compat_stat
id|__user
op_star
id|statbuf
)paren
(brace
r_struct
id|kstat
id|stat
suffix:semicolon
r_int
id|error
op_assign
id|vfs_fstat
c_func
(paren
id|fd
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|cp_compat_stat
c_func
(paren
op_amp
id|stat
comma
id|statbuf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|put_compat_statfs
r_static
r_int
id|put_compat_statfs
c_func
(paren
r_struct
id|compat_statfs
id|__user
op_star
id|ubuf
comma
r_struct
id|kstatfs
op_star
id|kbuf
)paren
(brace
r_if
c_cond
(paren
r_sizeof
id|ubuf-&gt;f_blocks
op_eq
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|kbuf-&gt;f_blocks
op_or
id|kbuf-&gt;f_bfree
op_or
id|kbuf-&gt;f_bavail
)paren
op_amp
l_int|0xffffffff00000000ULL
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
multiline_comment|/* f_files and f_ffree may be -1; it&squot;s okay&n;&t;&t; * to stuff that into 32 bits */
r_if
c_cond
(paren
id|kbuf-&gt;f_files
op_ne
l_int|0xffffffffffffffffULL
op_logical_and
(paren
id|kbuf-&gt;f_files
op_amp
l_int|0xffffffff00000000ULL
)paren
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|kbuf-&gt;f_ffree
op_ne
l_int|0xffffffffffffffffULL
op_logical_and
(paren
id|kbuf-&gt;f_ffree
op_amp
l_int|0xffffffff00000000ULL
)paren
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ubuf
comma
r_sizeof
(paren
op_star
id|ubuf
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_type
comma
op_amp
id|ubuf-&gt;f_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bsize
comma
op_amp
id|ubuf-&gt;f_bsize
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_blocks
comma
op_amp
id|ubuf-&gt;f_blocks
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bfree
comma
op_amp
id|ubuf-&gt;f_bfree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bavail
comma
op_amp
id|ubuf-&gt;f_bavail
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_files
comma
op_amp
id|ubuf-&gt;f_files
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_ffree
comma
op_amp
id|ubuf-&gt;f_ffree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_namelen
comma
op_amp
id|ubuf-&gt;f_namelen
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|0
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|0
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|1
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|1
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_frsize
comma
op_amp
id|ubuf-&gt;f_frsize
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|0
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|1
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|2
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|3
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|4
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The following statfs calls are copies of code from fs/open.c and&n; * should be checked against those from time to time&n; */
DECL|function|compat_sys_statfs
id|asmlinkage
r_int
id|compat_sys_statfs
c_func
(paren
r_const
r_char
id|__user
op_star
id|path
comma
r_struct
id|compat_statfs
id|__user
op_star
id|buf
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|user_path_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|kstatfs
id|tmp
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|nd.dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_sys_fstatfs
id|asmlinkage
r_int
id|compat_sys_fstatfs
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|compat_statfs
id|__user
op_star
id|buf
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|kstatfs
id|tmp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|put_compat_statfs64
r_static
r_int
id|put_compat_statfs64
c_func
(paren
r_struct
id|compat_statfs64
id|__user
op_star
id|ubuf
comma
r_struct
id|kstatfs
op_star
id|kbuf
)paren
(brace
r_if
c_cond
(paren
r_sizeof
id|ubuf-&gt;f_blocks
op_eq
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|kbuf-&gt;f_blocks
op_or
id|kbuf-&gt;f_bfree
op_or
id|kbuf-&gt;f_bavail
)paren
op_amp
l_int|0xffffffff00000000ULL
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
multiline_comment|/* f_files and f_ffree may be -1; it&squot;s okay&n;&t;&t; * to stuff that into 32 bits */
r_if
c_cond
(paren
id|kbuf-&gt;f_files
op_ne
l_int|0xffffffffffffffffULL
op_logical_and
(paren
id|kbuf-&gt;f_files
op_amp
l_int|0xffffffff00000000ULL
)paren
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|kbuf-&gt;f_ffree
op_ne
l_int|0xffffffffffffffffULL
op_logical_and
(paren
id|kbuf-&gt;f_ffree
op_amp
l_int|0xffffffff00000000ULL
)paren
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ubuf
comma
r_sizeof
(paren
op_star
id|ubuf
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_type
comma
op_amp
id|ubuf-&gt;f_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bsize
comma
op_amp
id|ubuf-&gt;f_bsize
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_blocks
comma
op_amp
id|ubuf-&gt;f_blocks
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bfree
comma
op_amp
id|ubuf-&gt;f_bfree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bavail
comma
op_amp
id|ubuf-&gt;f_bavail
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_files
comma
op_amp
id|ubuf-&gt;f_files
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_ffree
comma
op_amp
id|ubuf-&gt;f_ffree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_namelen
comma
op_amp
id|ubuf-&gt;f_namelen
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|0
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|0
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|1
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|1
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_frsize
comma
op_amp
id|ubuf-&gt;f_frsize
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|compat_sys_statfs64
id|asmlinkage
r_int
id|compat_sys_statfs64
c_func
(paren
r_const
r_char
id|__user
op_star
id|path
comma
id|compat_size_t
id|sz
comma
r_struct
id|compat_statfs64
id|__user
op_star
id|buf
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
r_sizeof
(paren
op_star
id|buf
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
id|user_path_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|kstatfs
id|tmp
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|nd.dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs64
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_sys_fstatfs64
id|asmlinkage
r_int
id|compat_sys_fstatfs64
c_func
(paren
r_int
r_int
id|fd
comma
id|compat_size_t
id|sz
comma
r_struct
id|compat_statfs64
id|__user
op_star
id|buf
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|kstatfs
id|tmp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
r_sizeof
(paren
op_star
id|buf
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs64
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* ioctl32 stuff, used by sparc64, parisc, s390x, ppc64, x86_64, MIPS */
DECL|macro|IOCTL_HASHSIZE
mdefine_line|#define IOCTL_HASHSIZE 256
DECL|variable|ioctl32_hash_table
r_static
r_struct
id|ioctl_trans
op_star
id|ioctl32_hash_table
(braket
id|IOCTL_HASHSIZE
)braket
suffix:semicolon
r_static
id|DECLARE_RWSEM
c_func
(paren
id|ioctl32_sem
)paren
suffix:semicolon
r_extern
r_struct
id|ioctl_trans
id|ioctl_start
(braket
)braket
suffix:semicolon
r_extern
r_int
id|ioctl_table_size
suffix:semicolon
DECL|function|ioctl32_hash
r_static
r_inline
r_int
r_int
id|ioctl32_hash
c_func
(paren
r_int
r_int
id|cmd
)paren
(brace
r_return
(paren
(paren
(paren
id|cmd
op_rshift
l_int|6
)paren
op_xor
(paren
id|cmd
op_rshift
l_int|4
)paren
op_xor
id|cmd
)paren
)paren
op_mod
id|IOCTL_HASHSIZE
suffix:semicolon
)brace
DECL|function|ioctl32_insert_translation
r_static
r_void
id|ioctl32_insert_translation
c_func
(paren
r_struct
id|ioctl_trans
op_star
id|trans
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
r_struct
id|ioctl_trans
op_star
id|t
suffix:semicolon
id|hash
op_assign
id|ioctl32_hash
(paren
id|trans-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioctl32_hash_table
(braket
id|hash
)braket
)paren
id|ioctl32_hash_table
(braket
id|hash
)braket
op_assign
id|trans
suffix:semicolon
r_else
(brace
id|t
op_assign
id|ioctl32_hash_table
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
id|t-&gt;next
)paren
id|t
op_assign
id|t-&gt;next
suffix:semicolon
id|trans-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;next
op_assign
id|trans
suffix:semicolon
)brace
)brace
DECL|function|init_sys32_ioctl
r_static
r_int
id|__init
id|init_sys32_ioctl
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ioctl_table_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioctl_start
(braket
id|i
)braket
dot
id|next
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ioctl translation %d bad&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ioctl32_insert_translation
c_func
(paren
op_amp
id|ioctl_start
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_sys32_ioctl
id|__initcall
c_func
(paren
id|init_sys32_ioctl
)paren
suffix:semicolon
DECL|function|register_ioctl32_conversion
r_int
id|register_ioctl32_conversion
c_func
(paren
r_int
r_int
id|cmd
comma
id|ioctl_trans_handler_t
id|handler
)paren
(brace
r_struct
id|ioctl_trans
op_star
id|t
suffix:semicolon
r_struct
id|ioctl_trans
op_star
id|new_t
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|ioctl32_hash
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|new_t
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_t
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
id|ioctl32_hash_table
(braket
id|hash
)braket
suffix:semicolon
id|t
suffix:semicolon
id|t
op_assign
id|t-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trying to register duplicated ioctl32 &quot;
l_string|&quot;handler %x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|new_t
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|new_t-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|new_t-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|new_t-&gt;handler
op_assign
id|handler
suffix:semicolon
id|ioctl32_insert_translation
c_func
(paren
id|new_t
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|register_ioctl32_conversion
id|EXPORT_SYMBOL
c_func
(paren
id|register_ioctl32_conversion
)paren
suffix:semicolon
DECL|function|builtin_ioctl
r_static
r_inline
r_int
id|builtin_ioctl
c_func
(paren
r_struct
id|ioctl_trans
op_star
id|t
)paren
(brace
r_return
id|t
op_ge
id|ioctl_start
op_logical_and
id|t
OL
(paren
id|ioctl_start
op_plus
id|ioctl_table_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Problem: &n;   This function cannot unregister duplicate ioctls, because they are not&n;   unique.&n;   When they happen we need to extend the prototype to pass the handler too. */
DECL|function|unregister_ioctl32_conversion
r_int
id|unregister_ioctl32_conversion
c_func
(paren
r_int
r_int
id|cmd
)paren
(brace
r_int
r_int
id|hash
op_assign
id|ioctl32_hash
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_struct
id|ioctl_trans
op_star
id|t
comma
op_star
id|t1
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
id|t
op_assign
id|ioctl32_hash_table
(braket
id|hash
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;cmd
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|builtin_ioctl
c_func
(paren
id|t
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%p tried to unregister builtin ioctl %x&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioctl32_hash_table
(braket
id|hash
)braket
op_assign
id|t-&gt;next
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|t-&gt;next
)paren
(brace
id|t1
op_assign
id|t-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|t1-&gt;cmd
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|builtin_ioctl
c_func
(paren
id|t1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%p tried to unregister builtin &quot;
l_string|&quot;ioctl %x&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|cmd
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|t-&gt;next
op_assign
id|t1-&gt;next
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|t1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|t
op_assign
id|t1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trying to free unknown 32bit ioctl handler %x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|out
suffix:colon
id|up_write
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|unregister_ioctl32_conversion
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_ioctl32_conversion
)paren
suffix:semicolon
DECL|function|compat_sys_ioctl
id|asmlinkage
r_int
id|compat_sys_ioctl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_struct
id|ioctl_trans
op_star
id|t
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
(brace
r_goto
id|out2
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_op
op_logical_or
op_logical_neg
id|filp-&gt;f_op-&gt;ioctl
)paren
(brace
id|error
op_assign
id|sys_ioctl
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|down_read
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
id|t
op_assign
id|ioctl32_hash_table
(braket
id|ioctl32_hash
(paren
id|cmd
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
id|t
op_logical_and
id|t-&gt;cmd
op_ne
id|cmd
)paren
id|t
op_assign
id|t-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;handler
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|t
op_member_access_from_pointer
id|handler
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
comma
id|filp
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|up_read
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
id|error
op_assign
id|sys_ioctl
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|up_read
c_func
(paren
op_amp
id|ioctl32_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
(brace
id|error
op_assign
id|siocdevprivate_ioctl
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
op_le
l_int|50
)paren
(brace
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_char
op_star
id|fn
op_assign
l_string|&quot;?&quot;
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
id|path
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* find the name of the device. */
r_if
c_cond
(paren
id|path
)paren
(brace
id|fn
op_assign
id|d_path
c_func
(paren
id|filp-&gt;f_dentry
comma
id|filp-&gt;f_vfsmnt
comma
id|path
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|fn
)paren
)paren
id|fn
op_assign
l_string|&quot;?&quot;
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&squot;%c&squot;&quot;
comma
(paren
id|cmd
op_rshift
l_int|24
)paren
op_amp
l_int|0x3f
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isprint
c_func
(paren
id|buf
(braket
l_int|1
)braket
)paren
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%02x&quot;
comma
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ioctl32(%s:%d): Unknown cmd fd(%d) &quot;
l_string|&quot;cmd(%08x){%s} arg(%08x) on %s&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
r_int
)paren
id|fd
comma
(paren
r_int
r_int
)paren
id|cmd
comma
id|buf
comma
(paren
r_int
r_int
)paren
id|arg
comma
id|fn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|path
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out2
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|get_compat_flock
r_static
r_int
id|get_compat_flock
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock
id|__user
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|put_compat_flock
r_static
r_int
id|put_compat_flock
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock
id|__user
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef HAVE_ARCH_GET_COMPAT_FLOCK64
DECL|function|get_compat_flock64
r_static
r_int
id|get_compat_flock64
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock64
id|__user
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef HAVE_ARCH_PUT_COMPAT_FLOCK64
DECL|function|put_compat_flock64
r_static
r_int
id|put_compat_flock64
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock64
id|__user
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|compat_sys_fcntl64
id|asmlinkage
r_int
id|compat_sys_fcntl64
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|mm_segment_t
id|old_fs
suffix:semicolon
r_struct
id|flock
id|f
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|F_GETLK
suffix:colon
r_case
id|F_SETLK
suffix:colon
r_case
id|F_SETLKW
suffix:colon
id|ret
op_assign
id|get_compat_flock
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|sys_fcntl
c_func
(paren
id|fd
comma
id|cmd
comma
(paren
r_int
r_int
)paren
op_amp
id|f
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|F_GETLK
op_logical_and
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|f.l_start
op_ge
id|COMPAT_OFF_T_MAX
)paren
op_logical_or
(paren
(paren
id|f.l_start
op_plus
id|f.l_len
)paren
OG
id|COMPAT_OFF_T_MAX
)paren
)paren
id|ret
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|put_compat_flock
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|F_GETLK64
suffix:colon
r_case
id|F_SETLK64
suffix:colon
r_case
id|F_SETLKW64
suffix:colon
id|ret
op_assign
id|get_compat_flock64
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|sys_fcntl
c_func
(paren
id|fd
comma
(paren
id|cmd
op_eq
id|F_GETLK64
)paren
ques
c_cond
id|F_GETLK
suffix:colon
(paren
(paren
id|cmd
op_eq
id|F_SETLK64
)paren
ques
c_cond
id|F_SETLK
suffix:colon
id|F_SETLKW
)paren
comma
(paren
r_int
r_int
)paren
op_amp
id|f
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|F_GETLK64
op_logical_and
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|f.l_start
op_ge
id|COMPAT_LOFF_T_MAX
)paren
op_logical_or
(paren
(paren
id|f.l_start
op_plus
id|f.l_len
)paren
OG
id|COMPAT_LOFF_T_MAX
)paren
)paren
id|ret
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|put_compat_flock64
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
id|sys_fcntl
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|compat_sys_fcntl
id|asmlinkage
r_int
id|compat_sys_fcntl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|F_GETLK64
)paren
op_logical_or
(paren
id|cmd
op_eq
id|F_SETLK64
)paren
op_logical_or
(paren
id|cmd
op_eq
id|F_SETLKW64
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|compat_sys_fcntl64
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|compat_sys_io_setup
id|compat_sys_io_setup
c_func
(paren
r_int
id|nr_reqs
comma
id|u32
id|__user
op_star
id|ctx32p
)paren
(brace
r_int
id|ret
suffix:semicolon
id|aio_context_t
id|ctx64
suffix:semicolon
id|mm_segment_t
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|get_user
c_func
(paren
id|ctx64
comma
id|ctx32p
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
multiline_comment|/* The __user pointer cast is valid because of the set_fs() */
id|ret
op_assign
id|sys_io_setup
c_func
(paren
id|nr_reqs
comma
(paren
id|aio_context_t
id|__user
op_star
)paren
op_amp
id|ctx64
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/* truncating is ok because it&squot;s a user address */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|put_user
c_func
(paren
(paren
id|u32
)paren
id|ctx64
comma
id|ctx32p
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|compat_sys_io_getevents
id|compat_sys_io_getevents
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
r_int
id|min_nr
comma
r_int
r_int
id|nr
comma
r_struct
id|io_event
id|__user
op_star
id|events
comma
r_struct
id|compat_timespec
id|__user
op_star
id|timeout
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|timespec
id|t
suffix:semicolon
r_struct
id|timespec
id|__user
op_star
id|ut
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|events
comma
id|nr
op_star
r_sizeof
(paren
r_struct
id|io_event
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|get_compat_timespec
c_func
(paren
op_amp
id|t
comma
id|timeout
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ut
op_assign
id|compat_alloc_user_space
c_func
(paren
r_sizeof
(paren
op_star
id|ut
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ut
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
id|sys_io_getevents
c_func
(paren
id|ctx_id
comma
id|min_nr
comma
id|nr
comma
id|events
comma
id|ut
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|copy_iocb
id|copy_iocb
c_func
(paren
r_int
id|nr
comma
id|u32
id|__user
op_star
id|ptr32
comma
r_struct
id|iocb
id|__user
op_star
id|__user
op_star
id|ptr64
)paren
(brace
id|compat_uptr_t
id|uptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|uptr
comma
id|ptr32
op_plus
id|i
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|compat_ptr
c_func
(paren
id|uptr
)paren
comma
id|ptr64
op_plus
id|i
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|MAX_AIO_SUBMITS
mdefine_line|#define MAX_AIO_SUBMITS &t;(PAGE_SIZE/sizeof(struct iocb *))
id|asmlinkage
r_int
DECL|function|compat_sys_io_submit
id|compat_sys_io_submit
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
id|nr
comma
id|u32
id|__user
op_star
id|iocb
)paren
(brace
r_struct
id|iocb
id|__user
op_star
id|__user
op_star
id|iocb64
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|nr
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|MAX_AIO_SUBMITS
)paren
id|nr
op_assign
id|MAX_AIO_SUBMITS
suffix:semicolon
id|iocb64
op_assign
id|compat_alloc_user_space
c_func
(paren
id|nr
op_star
r_sizeof
(paren
op_star
id|iocb64
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|copy_iocb
c_func
(paren
id|nr
comma
id|iocb
comma
id|iocb64
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|sys_io_submit
c_func
(paren
id|ctx_id
comma
id|nr
comma
id|iocb64
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|struct|compat_ncp_mount_data
r_struct
id|compat_ncp_mount_data
(brace
DECL|member|version
id|compat_int_t
id|version
suffix:semicolon
DECL|member|ncp_fd
id|compat_uint_t
id|ncp_fd
suffix:semicolon
DECL|member|mounted_uid
id|compat_uid_t
id|mounted_uid
suffix:semicolon
DECL|member|wdog_pid
id|compat_pid_t
id|wdog_pid
suffix:semicolon
DECL|member|mounted_vol
r_int
r_char
id|mounted_vol
(braket
id|NCP_VOLNAME_LEN
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|time_out
id|compat_uint_t
id|time_out
suffix:semicolon
DECL|member|retry_count
id|compat_uint_t
id|retry_count
suffix:semicolon
DECL|member|flags
id|compat_uint_t
id|flags
suffix:semicolon
DECL|member|uid
id|compat_uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|compat_gid_t
id|gid
suffix:semicolon
DECL|member|file_mode
id|compat_mode_t
id|file_mode
suffix:semicolon
DECL|member|dir_mode
id|compat_mode_t
id|dir_mode
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_ncp_mount_data_v4
r_struct
id|compat_ncp_mount_data_v4
(brace
DECL|member|version
id|compat_int_t
id|version
suffix:semicolon
DECL|member|flags
id|compat_ulong_t
id|flags
suffix:semicolon
DECL|member|mounted_uid
id|compat_ulong_t
id|mounted_uid
suffix:semicolon
DECL|member|wdog_pid
id|compat_long_t
id|wdog_pid
suffix:semicolon
DECL|member|ncp_fd
id|compat_uint_t
id|ncp_fd
suffix:semicolon
DECL|member|time_out
id|compat_uint_t
id|time_out
suffix:semicolon
DECL|member|retry_count
id|compat_uint_t
id|retry_count
suffix:semicolon
DECL|member|uid
id|compat_ulong_t
id|uid
suffix:semicolon
DECL|member|gid
id|compat_ulong_t
id|gid
suffix:semicolon
DECL|member|file_mode
id|compat_ulong_t
id|file_mode
suffix:semicolon
DECL|member|dir_mode
id|compat_ulong_t
id|dir_mode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|do_ncp_super_data_conv
r_static
r_void
op_star
id|do_ncp_super_data_conv
c_func
(paren
r_void
op_star
id|raw_data
)paren
(brace
r_int
id|version
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|raw_data
suffix:semicolon
r_if
c_cond
(paren
id|version
op_eq
l_int|3
)paren
(brace
r_struct
id|compat_ncp_mount_data
op_star
id|c_n
op_assign
id|raw_data
suffix:semicolon
r_struct
id|ncp_mount_data
op_star
id|n
op_assign
id|raw_data
suffix:semicolon
id|n-&gt;dir_mode
op_assign
id|c_n-&gt;dir_mode
suffix:semicolon
id|n-&gt;file_mode
op_assign
id|c_n-&gt;file_mode
suffix:semicolon
id|n-&gt;gid
op_assign
id|c_n-&gt;gid
suffix:semicolon
id|n-&gt;uid
op_assign
id|c_n-&gt;uid
suffix:semicolon
id|memmove
(paren
id|n-&gt;mounted_vol
comma
id|c_n-&gt;mounted_vol
comma
(paren
r_sizeof
(paren
id|c_n-&gt;mounted_vol
)paren
op_plus
l_int|3
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
suffix:semicolon
id|n-&gt;wdog_pid
op_assign
id|c_n-&gt;wdog_pid
suffix:semicolon
id|n-&gt;mounted_uid
op_assign
id|c_n-&gt;mounted_uid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|version
op_eq
l_int|4
)paren
(brace
r_struct
id|compat_ncp_mount_data_v4
op_star
id|c_n
op_assign
id|raw_data
suffix:semicolon
r_struct
id|ncp_mount_data_v4
op_star
id|n
op_assign
id|raw_data
suffix:semicolon
id|n-&gt;dir_mode
op_assign
id|c_n-&gt;dir_mode
suffix:semicolon
id|n-&gt;file_mode
op_assign
id|c_n-&gt;file_mode
suffix:semicolon
id|n-&gt;gid
op_assign
id|c_n-&gt;gid
suffix:semicolon
id|n-&gt;uid
op_assign
id|c_n-&gt;uid
suffix:semicolon
id|n-&gt;retry_count
op_assign
id|c_n-&gt;retry_count
suffix:semicolon
id|n-&gt;time_out
op_assign
id|c_n-&gt;time_out
suffix:semicolon
id|n-&gt;ncp_fd
op_assign
id|c_n-&gt;ncp_fd
suffix:semicolon
id|n-&gt;wdog_pid
op_assign
id|c_n-&gt;wdog_pid
suffix:semicolon
id|n-&gt;mounted_uid
op_assign
id|c_n-&gt;mounted_uid
suffix:semicolon
id|n-&gt;flags
op_assign
id|c_n-&gt;flags
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|version
op_ne
l_int|5
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|raw_data
suffix:semicolon
)brace
DECL|struct|compat_smb_mount_data
r_struct
id|compat_smb_mount_data
(brace
DECL|member|version
id|compat_int_t
id|version
suffix:semicolon
DECL|member|mounted_uid
id|compat_uid_t
id|mounted_uid
suffix:semicolon
DECL|member|uid
id|compat_uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|compat_gid_t
id|gid
suffix:semicolon
DECL|member|file_mode
id|compat_mode_t
id|file_mode
suffix:semicolon
DECL|member|dir_mode
id|compat_mode_t
id|dir_mode
suffix:semicolon
)brace
suffix:semicolon
DECL|function|do_smb_super_data_conv
r_static
r_void
op_star
id|do_smb_super_data_conv
c_func
(paren
r_void
op_star
id|raw_data
)paren
(brace
r_struct
id|smb_mount_data
op_star
id|s
op_assign
id|raw_data
suffix:semicolon
r_struct
id|compat_smb_mount_data
op_star
id|c_s
op_assign
id|raw_data
suffix:semicolon
r_if
c_cond
(paren
id|c_s-&gt;version
op_ne
id|SMB_MOUNT_OLDVERSION
)paren
r_goto
id|out
suffix:semicolon
id|s-&gt;dir_mode
op_assign
id|c_s-&gt;dir_mode
suffix:semicolon
id|s-&gt;file_mode
op_assign
id|c_s-&gt;file_mode
suffix:semicolon
id|s-&gt;gid
op_assign
id|c_s-&gt;gid
suffix:semicolon
id|s-&gt;uid
op_assign
id|c_s-&gt;uid
suffix:semicolon
id|s-&gt;mounted_uid
op_assign
id|c_s-&gt;mounted_uid
suffix:semicolon
id|out
suffix:colon
r_return
id|raw_data
suffix:semicolon
)brace
r_extern
r_int
id|copy_mount_options
(paren
r_const
r_void
id|__user
op_star
comma
r_int
r_int
op_star
)paren
suffix:semicolon
DECL|macro|SMBFS_NAME
mdefine_line|#define SMBFS_NAME      &quot;smbfs&quot;
DECL|macro|NCPFS_NAME
mdefine_line|#define NCPFS_NAME      &quot;ncpfs&quot;
DECL|function|compat_sys_mount
id|asmlinkage
r_int
id|compat_sys_mount
c_func
(paren
r_char
id|__user
op_star
id|dev_name
comma
r_char
id|__user
op_star
id|dir_name
comma
r_char
id|__user
op_star
id|type
comma
r_int
r_int
id|flags
comma
r_void
id|__user
op_star
id|data
)paren
(brace
r_int
r_int
id|type_page
suffix:semicolon
r_int
r_int
id|data_page
suffix:semicolon
r_int
r_int
id|dev_page
suffix:semicolon
r_char
op_star
id|dir_page
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|copy_mount_options
(paren
id|type
comma
op_amp
id|type_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|dir_page
op_assign
id|getname
c_func
(paren
id|dir_name
)paren
suffix:semicolon
id|retval
op_assign
id|PTR_ERR
c_func
(paren
id|dir_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir_page
)paren
)paren
r_goto
id|out1
suffix:semicolon
id|retval
op_assign
id|copy_mount_options
(paren
id|dev_name
comma
op_amp
id|dev_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out2
suffix:semicolon
id|retval
op_assign
id|copy_mount_options
(paren
id|data
comma
op_amp
id|data_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out3
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|type_page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|type_page
comma
id|SMBFS_NAME
)paren
)paren
(brace
id|do_smb_super_data_conv
c_func
(paren
(paren
r_void
op_star
)paren
id|data_page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|type_page
comma
id|NCPFS_NAME
)paren
)paren
(brace
id|do_ncp_super_data_conv
c_func
(paren
(paren
r_void
op_star
)paren
id|data_page
)paren
suffix:semicolon
)brace
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|do_mount
c_func
(paren
(paren
r_char
op_star
)paren
id|dev_page
comma
id|dir_page
comma
(paren
r_char
op_star
)paren
id|type_page
comma
id|flags
comma
(paren
r_void
op_star
)paren
id|data_page
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|data_page
)paren
suffix:semicolon
id|out3
suffix:colon
id|free_page
c_func
(paren
id|dev_page
)paren
suffix:semicolon
id|out2
suffix:colon
id|putname
c_func
(paren
id|dir_page
)paren
suffix:semicolon
id|out1
suffix:colon
id|free_page
c_func
(paren
id|type_page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|NAME_OFFSET
mdefine_line|#define NAME_OFFSET(de) ((int) ((de)-&gt;d_name - (char __user *) (de)))
DECL|macro|COMPAT_ROUND_UP
mdefine_line|#define COMPAT_ROUND_UP(x) (((x)+sizeof(compat_long_t)-1) &amp; &bslash;&n;&t;&t;&t;&t;~(sizeof(compat_long_t)-1))
DECL|struct|compat_old_linux_dirent
r_struct
id|compat_old_linux_dirent
(brace
DECL|member|d_ino
id|compat_ulong_t
id|d_ino
suffix:semicolon
DECL|member|d_offset
id|compat_ulong_t
id|d_offset
suffix:semicolon
DECL|member|d_namlen
r_int
r_int
id|d_namlen
suffix:semicolon
DECL|member|d_name
r_char
id|d_name
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_readdir_callback
r_struct
id|compat_readdir_callback
(brace
DECL|member|dirent
r_struct
id|compat_old_linux_dirent
id|__user
op_star
id|dirent
suffix:semicolon
DECL|member|result
r_int
id|result
suffix:semicolon
)brace
suffix:semicolon
DECL|function|compat_fillonedir
r_static
r_int
id|compat_fillonedir
c_func
(paren
r_void
op_star
id|__buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namlen
comma
id|loff_t
id|offset
comma
id|ino_t
id|ino
comma
r_int
r_int
id|d_type
)paren
(brace
r_struct
id|compat_readdir_callback
op_star
id|buf
op_assign
id|__buf
suffix:semicolon
r_struct
id|compat_old_linux_dirent
id|__user
op_star
id|dirent
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;result
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf-&gt;result
op_increment
suffix:semicolon
id|dirent
op_assign
id|buf-&gt;dirent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|dirent
comma
(paren
r_int
r_int
)paren
(paren
id|dirent-&gt;d_name
op_plus
id|namlen
op_plus
l_int|1
)paren
op_minus
(paren
r_int
r_int
)paren
id|dirent
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|ino
comma
op_amp
id|dirent-&gt;d_ino
)paren
op_logical_or
id|__put_user
c_func
(paren
id|offset
comma
op_amp
id|dirent-&gt;d_offset
)paren
op_logical_or
id|__put_user
c_func
(paren
id|namlen
comma
op_amp
id|dirent-&gt;d_namlen
)paren
op_logical_or
id|__copy_to_user
c_func
(paren
id|dirent-&gt;d_name
comma
id|name
comma
id|namlen
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
id|dirent-&gt;d_name
op_plus
id|namlen
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|efault
suffix:colon
id|buf-&gt;result
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
DECL|function|compat_sys_old_readdir
id|asmlinkage
r_int
id|compat_sys_old_readdir
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|compat_old_linux_dirent
id|__user
op_star
id|dirent
comma
r_int
r_int
id|count
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|compat_readdir_callback
id|buf
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|buf.result
op_assign
l_int|0
suffix:semicolon
id|buf.dirent
op_assign
id|dirent
suffix:semicolon
id|error
op_assign
id|vfs_readdir
c_func
(paren
id|file
comma
id|compat_fillonedir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
id|error
op_assign
id|buf.result
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|struct|compat_linux_dirent
r_struct
id|compat_linux_dirent
(brace
DECL|member|d_ino
id|compat_ulong_t
id|d_ino
suffix:semicolon
DECL|member|d_off
id|compat_ulong_t
id|d_off
suffix:semicolon
DECL|member|d_reclen
r_int
r_int
id|d_reclen
suffix:semicolon
DECL|member|d_name
r_char
id|d_name
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_getdents_callback
r_struct
id|compat_getdents_callback
(brace
DECL|member|current_dir
r_struct
id|compat_linux_dirent
id|__user
op_star
id|current_dir
suffix:semicolon
DECL|member|previous
r_struct
id|compat_linux_dirent
id|__user
op_star
id|previous
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
)brace
suffix:semicolon
DECL|function|compat_filldir
r_static
r_int
id|compat_filldir
c_func
(paren
r_void
op_star
id|__buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namlen
comma
id|loff_t
id|offset
comma
id|ino_t
id|ino
comma
r_int
r_int
id|d_type
)paren
(brace
r_struct
id|compat_linux_dirent
id|__user
op_star
id|dirent
suffix:semicolon
r_struct
id|compat_getdents_callback
op_star
id|buf
op_assign
id|__buf
suffix:semicolon
r_int
id|reclen
op_assign
id|COMPAT_ROUND_UP
c_func
(paren
id|NAME_OFFSET
c_func
(paren
id|dirent
)paren
op_plus
id|namlen
op_plus
l_int|2
)paren
suffix:semicolon
id|buf-&gt;error
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* only used if we fail.. */
r_if
c_cond
(paren
id|reclen
OG
id|buf-&gt;count
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dirent
op_assign
id|buf-&gt;previous
suffix:semicolon
r_if
c_cond
(paren
id|dirent
)paren
(brace
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|offset
comma
op_amp
id|dirent-&gt;d_off
)paren
)paren
r_goto
id|efault
suffix:semicolon
)brace
id|dirent
op_assign
id|buf-&gt;current_dir
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|ino
comma
op_amp
id|dirent-&gt;d_ino
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|reclen
comma
op_amp
id|dirent-&gt;d_reclen
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dirent-&gt;d_name
comma
id|name
comma
id|namlen
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
l_int|0
comma
id|dirent-&gt;d_name
op_plus
id|namlen
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|d_type
comma
(paren
r_char
id|__user
op_star
)paren
id|dirent
op_plus
id|reclen
op_minus
l_int|1
)paren
)paren
r_goto
id|efault
suffix:semicolon
id|buf-&gt;previous
op_assign
id|dirent
suffix:semicolon
id|dirent
op_assign
(paren
r_void
id|__user
op_star
)paren
id|dirent
op_plus
id|reclen
suffix:semicolon
id|buf-&gt;current_dir
op_assign
id|dirent
suffix:semicolon
id|buf-&gt;count
op_sub_assign
id|reclen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|efault
suffix:colon
id|buf-&gt;error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
DECL|function|compat_sys_getdents
id|asmlinkage
r_int
id|compat_sys_getdents
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|compat_linux_dirent
id|__user
op_star
id|dirent
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|compat_linux_dirent
id|__user
op_star
id|lastdirent
suffix:semicolon
r_struct
id|compat_getdents_callback
id|buf
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|dirent
comma
id|count
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|buf.current_dir
op_assign
id|dirent
suffix:semicolon
id|buf.previous
op_assign
l_int|NULL
suffix:semicolon
id|buf.count
op_assign
id|count
suffix:semicolon
id|buf.error
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|vfs_readdir
c_func
(paren
id|file
comma
id|compat_filldir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out_putf
suffix:semicolon
id|error
op_assign
id|buf.error
suffix:semicolon
id|lastdirent
op_assign
id|buf.previous
suffix:semicolon
r_if
c_cond
(paren
id|lastdirent
)paren
(brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|file-&gt;f_pos
comma
op_amp
id|lastdirent-&gt;d_off
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|error
op_assign
id|count
op_minus
id|buf.count
suffix:semicolon
)brace
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifndef __ARCH_OMIT_COMPAT_SYS_GETDENTS64
DECL|macro|COMPAT_ROUND_UP64
mdefine_line|#define COMPAT_ROUND_UP64(x) (((x)+sizeof(u64)-1) &amp; ~(sizeof(u64)-1))
DECL|struct|compat_getdents_callback64
r_struct
id|compat_getdents_callback64
(brace
DECL|member|current_dir
r_struct
id|linux_dirent64
id|__user
op_star
id|current_dir
suffix:semicolon
DECL|member|previous
r_struct
id|linux_dirent64
id|__user
op_star
id|previous
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|error
r_int
id|error
suffix:semicolon
)brace
suffix:semicolon
DECL|function|compat_filldir64
r_static
r_int
id|compat_filldir64
c_func
(paren
r_void
op_star
id|__buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namlen
comma
id|loff_t
id|offset
comma
id|ino_t
id|ino
comma
r_int
r_int
id|d_type
)paren
(brace
r_struct
id|linux_dirent64
id|__user
op_star
id|dirent
suffix:semicolon
r_struct
id|compat_getdents_callback64
op_star
id|buf
op_assign
id|__buf
suffix:semicolon
r_int
id|jj
op_assign
id|NAME_OFFSET
c_func
(paren
id|dirent
)paren
suffix:semicolon
r_int
id|reclen
op_assign
id|COMPAT_ROUND_UP64
c_func
(paren
id|jj
op_plus
id|namlen
op_plus
l_int|1
)paren
suffix:semicolon
id|u64
id|off
suffix:semicolon
id|buf-&gt;error
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* only used if we fail.. */
r_if
c_cond
(paren
id|reclen
OG
id|buf-&gt;count
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dirent
op_assign
id|buf-&gt;previous
suffix:semicolon
r_if
c_cond
(paren
id|dirent
)paren
(brace
r_if
c_cond
(paren
id|__put_user_unaligned
c_func
(paren
id|offset
comma
op_amp
id|dirent-&gt;d_off
)paren
)paren
r_goto
id|efault
suffix:semicolon
)brace
id|dirent
op_assign
id|buf-&gt;current_dir
suffix:semicolon
r_if
c_cond
(paren
id|__put_user_unaligned
c_func
(paren
id|ino
comma
op_amp
id|dirent-&gt;d_ino
)paren
)paren
r_goto
id|efault
suffix:semicolon
id|off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|__put_user_unaligned
c_func
(paren
id|off
comma
op_amp
id|dirent-&gt;d_off
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|reclen
comma
op_amp
id|dirent-&gt;d_reclen
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
id|d_type
comma
op_amp
id|dirent-&gt;d_type
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dirent-&gt;d_name
comma
id|name
comma
id|namlen
)paren
)paren
r_goto
id|efault
suffix:semicolon
r_if
c_cond
(paren
id|__put_user
c_func
(paren
l_int|0
comma
id|dirent-&gt;d_name
op_plus
id|namlen
)paren
)paren
r_goto
id|efault
suffix:semicolon
id|buf-&gt;previous
op_assign
id|dirent
suffix:semicolon
id|dirent
op_assign
(paren
r_void
id|__user
op_star
)paren
id|dirent
op_plus
id|reclen
suffix:semicolon
id|buf-&gt;current_dir
op_assign
id|dirent
suffix:semicolon
id|buf-&gt;count
op_sub_assign
id|reclen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|efault
suffix:colon
id|buf-&gt;error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
DECL|function|compat_sys_getdents64
id|asmlinkage
r_int
id|compat_sys_getdents64
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|linux_dirent64
id|__user
op_star
id|dirent
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|linux_dirent64
id|__user
op_star
id|lastdirent
suffix:semicolon
r_struct
id|compat_getdents_callback64
id|buf
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|dirent
comma
id|count
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|buf.current_dir
op_assign
id|dirent
suffix:semicolon
id|buf.previous
op_assign
l_int|NULL
suffix:semicolon
id|buf.count
op_assign
id|count
suffix:semicolon
id|buf.error
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|vfs_readdir
c_func
(paren
id|file
comma
id|compat_filldir64
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out_putf
suffix:semicolon
id|error
op_assign
id|buf.error
suffix:semicolon
id|lastdirent
op_assign
id|buf.previous
suffix:semicolon
r_if
c_cond
(paren
id|lastdirent
)paren
(brace
id|typeof
c_func
(paren
id|lastdirent-&gt;d_off
)paren
id|d_off
op_assign
id|file-&gt;f_pos
suffix:semicolon
id|__put_user_unaligned
c_func
(paren
id|d_off
comma
op_amp
id|lastdirent-&gt;d_off
)paren
suffix:semicolon
id|error
op_assign
id|count
op_minus
id|buf.count
suffix:semicolon
)brace
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif /* ! __ARCH_OMIT_COMPAT_SYS_GETDENTS64 */
DECL|function|compat_do_readv_writev
r_static
id|ssize_t
id|compat_do_readv_writev
c_func
(paren
r_int
id|type
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|compat_iovec
id|__user
op_star
id|uvector
comma
r_int
r_int
id|nr_segs
comma
id|loff_t
op_star
id|pos
)paren
(brace
r_typedef
id|ssize_t
(paren
op_star
id|io_fn_t
)paren
(paren
r_struct
id|file
op_star
comma
r_char
id|__user
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
r_typedef
id|ssize_t
(paren
op_star
id|iov_fn_t
)paren
(paren
r_struct
id|file
op_star
comma
r_const
r_struct
id|iovec
op_star
comma
r_int
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
id|compat_ssize_t
id|tot_len
suffix:semicolon
r_struct
id|iovec
id|iovstack
(braket
id|UIO_FASTIOV
)braket
suffix:semicolon
r_struct
id|iovec
op_star
id|iov
op_assign
id|iovstack
comma
op_star
id|vector
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
id|seg
suffix:semicolon
id|io_fn_t
id|fn
suffix:semicolon
id|iov_fn_t
id|fnv
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
multiline_comment|/*&n;&t; * SuS says &quot;The readv() function *may* fail if the iovcnt argument&n;&t; * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has&n;&t; * traditionally returned zero for zero segments, so...&n;&t; */
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr_segs
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * First get the &quot;struct iovec&quot; from user memory and&n;&t; * verify all the pointers&n;&t; */
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nr_segs
OG
id|UIO_MAXIOV
)paren
op_logical_or
(paren
id|nr_segs
op_le
l_int|0
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|nr_segs
OG
id|UIO_FASTIOV
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|iov
op_assign
id|kmalloc
c_func
(paren
id|nr_segs
op_star
r_sizeof
(paren
r_struct
id|iovec
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iov
)paren
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|uvector
comma
id|nr_segs
op_star
r_sizeof
(paren
op_star
id|uvector
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Single unix specification:&n;&t; * We should -EINVAL if an element length is not &gt;= 0 and fitting an&n;&t; * ssize_t.  The total length is fitting an ssize_t&n;&t; *&n;&t; * Be careful here because iov_len is a size_t not an ssize_t&n;&t; */
id|tot_len
op_assign
l_int|0
suffix:semicolon
id|vector
op_assign
id|iov
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|nr_segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
id|compat_ssize_t
id|tmp
op_assign
id|tot_len
suffix:semicolon
id|compat_ssize_t
id|len
suffix:semicolon
id|compat_uptr_t
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|len
comma
op_amp
id|uvector-&gt;iov_len
)paren
op_logical_or
id|__get_user
c_func
(paren
id|buf
comma
op_amp
id|uvector-&gt;iov_base
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
multiline_comment|/* size_t not fitting an compat_ssize_t .. */
r_goto
id|out
suffix:semicolon
id|tot_len
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|tot_len
OL
id|tmp
)paren
multiline_comment|/* maths overflow on the compat_ssize_t */
r_goto
id|out
suffix:semicolon
id|vector-&gt;iov_base
op_assign
id|compat_ptr
c_func
(paren
id|buf
)paren
suffix:semicolon
id|vector-&gt;iov_len
op_assign
(paren
id|compat_size_t
)paren
id|len
suffix:semicolon
id|uvector
op_increment
suffix:semicolon
id|vector
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tot_len
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* VERIFY_WRITE actually means a read, as we write to user space */
id|ret
op_assign
id|locks_verify_area
c_func
(paren
(paren
id|type
op_eq
id|READ
ques
c_cond
id|FLOCK_VERIFY_READ
suffix:colon
id|FLOCK_VERIFY_WRITE
)paren
comma
id|inode
comma
id|file
comma
op_star
id|pos
comma
id|tot_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|fnv
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|READ
)paren
(brace
id|fn
op_assign
id|file-&gt;f_op-&gt;read
suffix:semicolon
id|fnv
op_assign
id|file-&gt;f_op-&gt;readv
suffix:semicolon
)brace
r_else
(brace
id|fn
op_assign
(paren
id|io_fn_t
)paren
id|file-&gt;f_op-&gt;write
suffix:semicolon
id|fnv
op_assign
id|file-&gt;f_op-&gt;writev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fnv
)paren
(brace
id|ret
op_assign
id|fnv
c_func
(paren
id|file
comma
id|iov
comma
id|nr_segs
comma
id|pos
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Do it by hand, with file-ops */
id|ret
op_assign
l_int|0
suffix:semicolon
id|vector
op_assign
id|iov
suffix:semicolon
r_while
c_loop
(paren
id|nr_segs
OG
l_int|0
)paren
(brace
r_void
id|__user
op_star
id|base
suffix:semicolon
r_int
id|len
suffix:semicolon
id|ssize_t
id|nr
suffix:semicolon
id|base
op_assign
id|vector-&gt;iov_base
suffix:semicolon
id|len
op_assign
id|vector-&gt;iov_len
suffix:semicolon
id|vector
op_increment
suffix:semicolon
id|nr_segs
op_decrement
suffix:semicolon
id|nr
op_assign
id|fn
c_func
(paren
id|file
comma
id|base
comma
id|len
comma
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|nr
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_add_assign
id|nr
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ne
id|len
)paren
r_break
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|iov
op_ne
id|iovstack
)paren
id|kfree
c_func
(paren
id|iov
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_plus
(paren
id|type
op_eq
id|READ
)paren
)paren
OG
l_int|0
)paren
id|dnotify_parent
c_func
(paren
id|file-&gt;f_dentry
comma
(paren
id|type
op_eq
id|READ
)paren
ques
c_cond
id|DN_ACCESS
suffix:colon
id|DN_MODIFY
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|asmlinkage
id|ssize_t
DECL|function|compat_sys_readv
id|compat_sys_readv
c_func
(paren
r_int
r_int
id|fd
comma
r_const
r_struct
id|compat_iovec
id|__user
op_star
id|vec
comma
r_int
r_int
id|vlen
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
id|ssize_t
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
(paren
op_logical_neg
id|file-&gt;f_op-&gt;readv
op_logical_and
op_logical_neg
id|file-&gt;f_op-&gt;read
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|compat_do_readv_writev
c_func
(paren
id|READ
comma
id|file
comma
id|vec
comma
id|vlen
comma
op_amp
id|file-&gt;f_pos
)paren
suffix:semicolon
id|out
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|asmlinkage
id|ssize_t
DECL|function|compat_sys_writev
id|compat_sys_writev
c_func
(paren
r_int
r_int
id|fd
comma
r_const
r_struct
id|compat_iovec
id|__user
op_star
id|vec
comma
r_int
r_int
id|vlen
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
id|ssize_t
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
(paren
op_logical_neg
id|file-&gt;f_op-&gt;writev
op_logical_and
op_logical_neg
id|file-&gt;f_op-&gt;write
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|compat_do_readv_writev
c_func
(paren
id|WRITE
comma
id|file
comma
id|vec
comma
id|vlen
comma
op_amp
id|file-&gt;f_pos
)paren
suffix:semicolon
id|out
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * compat_count() counts the number of arguments/envelopes. It is basically&n; * a copy of count() from fs/exec.c, except that it works with 32 bit argv&n; * and envp pointers.&n; */
DECL|function|compat_count
r_static
r_int
id|compat_count
c_func
(paren
id|compat_uptr_t
id|__user
op_star
id|argv
comma
r_int
id|max
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|argv
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|compat_uptr_t
id|p
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|p
comma
id|argv
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_break
suffix:semicolon
id|argv
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
OG
id|max
)paren
(brace
r_return
op_minus
id|E2BIG
suffix:semicolon
)brace
)brace
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * compat_copy_strings() is basically a copy of copy_strings() from fs/exec.c&n; * except that it works with 32 bit argv and envp pointers.&n; */
DECL|function|compat_copy_strings
r_static
r_int
id|compat_copy_strings
c_func
(paren
r_int
id|argc
comma
id|compat_uptr_t
id|__user
op_star
id|argv
comma
r_struct
id|linux_binprm
op_star
id|bprm
)paren
(brace
r_struct
id|page
op_star
id|kmapped_page
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|kaddr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
OG
l_int|0
)paren
(brace
id|compat_uptr_t
id|str
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|str
comma
id|argv
op_plus
id|argc
)paren
op_logical_or
op_logical_neg
(paren
id|len
op_assign
id|strnlen_user
c_func
(paren
id|compat_ptr
c_func
(paren
id|str
)paren
comma
id|bprm-&gt;p
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bprm-&gt;p
OL
id|len
)paren
(brace
id|ret
op_assign
op_minus
id|E2BIG
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|bprm-&gt;p
op_sub_assign
id|len
suffix:semicolon
multiline_comment|/* XXX: add architecture specific overflow check here. */
id|pos
op_assign
id|bprm-&gt;p
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|i
comma
r_new
comma
id|err
suffix:semicolon
r_int
id|offset
comma
id|bytes_to_copy
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|offset
op_assign
id|pos
op_mod
id|PAGE_SIZE
suffix:semicolon
id|i
op_assign
id|pos
op_div
id|PAGE_SIZE
suffix:semicolon
id|page
op_assign
id|bprm-&gt;page
(braket
id|i
)braket
suffix:semicolon
r_new
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_HIGHUSER
)paren
suffix:semicolon
id|bprm-&gt;page
(braket
id|i
)braket
op_assign
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_new
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
op_ne
id|kmapped_page
)paren
(brace
r_if
c_cond
(paren
id|kmapped_page
)paren
id|kunmap
c_func
(paren
id|kmapped_page
)paren
suffix:semicolon
id|kmapped_page
op_assign
id|page
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|kmapped_page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
r_new
op_logical_and
id|offset
)paren
id|memset
c_func
(paren
id|kaddr
comma
l_int|0
comma
id|offset
)paren
suffix:semicolon
id|bytes_to_copy
op_assign
id|PAGE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes_to_copy
OG
id|len
)paren
(brace
id|bytes_to_copy
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|offset
op_plus
id|len
comma
l_int|0
comma
id|PAGE_SIZE
op_minus
id|offset
op_minus
id|len
)paren
suffix:semicolon
)brace
id|err
op_assign
id|copy_from_user
c_func
(paren
id|kaddr
op_plus
id|offset
comma
id|compat_ptr
c_func
(paren
id|str
)paren
comma
id|bytes_to_copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|pos
op_add_assign
id|bytes_to_copy
suffix:semicolon
id|str
op_add_assign
id|bytes_to_copy
suffix:semicolon
id|len
op_sub_assign
id|bytes_to_copy
suffix:semicolon
)brace
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|kmapped_page
)paren
id|kunmap
c_func
(paren
id|kmapped_page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MMU
DECL|macro|free_arg_pages
mdefine_line|#define free_arg_pages(bprm) do { } while (0)
macro_line|#else
DECL|function|free_arg_pages
r_static
r_inline
r_void
id|free_arg_pages
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ARG_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bprm-&gt;page
(braket
id|i
)braket
)paren
id|__free_page
c_func
(paren
id|bprm-&gt;page
(braket
id|i
)braket
)paren
suffix:semicolon
id|bprm-&gt;page
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_MMU */
multiline_comment|/*&n; * compat_do_execve() is mostly a copy of do_execve(), with the exception&n; * that it processes 32 bit argv and envp pointers.&n; */
DECL|function|compat_do_execve
r_int
id|compat_do_execve
c_func
(paren
r_char
op_star
id|filename
comma
id|compat_uptr_t
id|__user
op_star
id|argv
comma
id|compat_uptr_t
id|__user
op_star
id|envp
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|linux_binprm
op_star
id|bprm
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|i
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|bprm
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|bprm
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bprm
)paren
r_goto
id|out_ret
suffix:semicolon
id|memset
c_func
(paren
id|bprm
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bprm
)paren
)paren
suffix:semicolon
id|file
op_assign
id|open_exec
c_func
(paren
id|filename
)paren
suffix:semicolon
id|retval
op_assign
id|PTR_ERR
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
r_goto
id|out_kfree
suffix:semicolon
id|sched_exec
c_func
(paren
)paren
suffix:semicolon
id|bprm-&gt;p
op_assign
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
op_minus
r_sizeof
(paren
r_void
op_star
)paren
suffix:semicolon
id|bprm-&gt;file
op_assign
id|file
suffix:semicolon
id|bprm-&gt;filename
op_assign
id|filename
suffix:semicolon
id|bprm-&gt;interp
op_assign
id|filename
suffix:semicolon
id|bprm-&gt;mm
op_assign
id|mm_alloc
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bprm-&gt;mm
)paren
r_goto
id|out_file
suffix:semicolon
id|retval
op_assign
id|init_new_context
c_func
(paren
id|current
comma
id|bprm-&gt;mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_mm
suffix:semicolon
id|bprm-&gt;argc
op_assign
id|compat_count
c_func
(paren
id|argv
comma
id|bprm-&gt;p
op_div
r_sizeof
(paren
id|compat_uptr_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|bprm-&gt;argc
)paren
OL
l_int|0
)paren
r_goto
id|out_mm
suffix:semicolon
id|bprm-&gt;envc
op_assign
id|compat_count
c_func
(paren
id|envp
comma
id|bprm-&gt;p
op_div
r_sizeof
(paren
id|compat_uptr_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|bprm-&gt;envc
)paren
OL
l_int|0
)paren
r_goto
id|out_mm
suffix:semicolon
id|retval
op_assign
id|security_bprm_alloc
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|prepare_binprm
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|copy_strings_kernel
c_func
(paren
l_int|1
comma
op_amp
id|bprm-&gt;filename
comma
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|bprm-&gt;exec
op_assign
id|bprm-&gt;p
suffix:semicolon
id|retval
op_assign
id|compat_copy_strings
c_func
(paren
id|bprm-&gt;envc
comma
id|envp
comma
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|compat_copy_strings
c_func
(paren
id|bprm-&gt;argc
comma
id|argv
comma
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|search_binary_handler
c_func
(paren
id|bprm
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
(brace
id|free_arg_pages
c_func
(paren
id|bprm
)paren
suffix:semicolon
multiline_comment|/* execve success */
id|security_bprm_free
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|out
suffix:colon
multiline_comment|/* Something went wrong, return the inode and free the argument pages*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ARG_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bprm-&gt;page
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bprm-&gt;security
)paren
id|security_bprm_free
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|out_mm
suffix:colon
r_if
c_cond
(paren
id|bprm-&gt;mm
)paren
id|mmdrop
c_func
(paren
id|bprm-&gt;mm
)paren
suffix:semicolon
id|out_file
suffix:colon
r_if
c_cond
(paren
id|bprm-&gt;file
)paren
(brace
id|allow_write_access
c_func
(paren
id|bprm-&gt;file
)paren
suffix:semicolon
id|fput
c_func
(paren
id|bprm-&gt;file
)paren
suffix:semicolon
)brace
id|out_kfree
suffix:colon
id|kfree
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|out_ret
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|__COMPAT_NFDBITS
mdefine_line|#define __COMPAT_NFDBITS       (8 * sizeof(compat_ulong_t))
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP(x,y) (((x)+(y)-1)/(y))
multiline_comment|/*&n; * Ooo, nasty.  We need here to frob 32-bit unsigned longs to&n; * 64-bit unsigned longs.&n; */
r_static
r_inline
DECL|function|compat_get_fd_set
r_int
id|compat_get_fd_set
c_func
(paren
r_int
r_int
id|nr
comma
id|compat_ulong_t
id|__user
op_star
id|ufdset
comma
r_int
r_int
op_star
id|fdset
)paren
(brace
id|nr
op_assign
id|ROUND_UP
c_func
(paren
id|nr
comma
id|__COMPAT_NFDBITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ufdset
)paren
(brace
r_int
r_int
id|odd
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ufdset
comma
id|nr
op_star
r_sizeof
(paren
id|compat_ulong_t
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|odd
op_assign
id|nr
op_amp
l_int|1UL
suffix:semicolon
id|nr
op_and_assign
op_complement
l_int|1UL
suffix:semicolon
r_while
c_loop
(paren
id|nr
)paren
(brace
r_int
r_int
id|h
comma
id|l
suffix:semicolon
id|__get_user
c_func
(paren
id|l
comma
id|ufdset
)paren
suffix:semicolon
id|__get_user
c_func
(paren
id|h
comma
id|ufdset
op_plus
l_int|1
)paren
suffix:semicolon
id|ufdset
op_add_assign
l_int|2
suffix:semicolon
op_star
id|fdset
op_increment
op_assign
id|h
op_lshift
l_int|32
op_or
id|l
suffix:semicolon
id|nr
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|odd
)paren
id|__get_user
c_func
(paren
op_star
id|fdset
comma
id|ufdset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Tricky, must clear full unsigned long in the&n;&t;&t; * kernel fdset at the end, this makes sure that&n;&t;&t; * actually happens.&n;&t;&t; */
id|memset
c_func
(paren
id|fdset
comma
l_int|0
comma
(paren
(paren
id|nr
op_plus
l_int|1
)paren
op_amp
op_complement
l_int|1
)paren
op_star
r_sizeof
(paren
id|compat_ulong_t
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
DECL|function|compat_set_fd_set
r_void
id|compat_set_fd_set
c_func
(paren
r_int
r_int
id|nr
comma
id|compat_ulong_t
id|__user
op_star
id|ufdset
comma
r_int
r_int
op_star
id|fdset
)paren
(brace
r_int
r_int
id|odd
suffix:semicolon
id|nr
op_assign
id|ROUND_UP
c_func
(paren
id|nr
comma
id|__COMPAT_NFDBITS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ufdset
)paren
r_return
suffix:semicolon
id|odd
op_assign
id|nr
op_amp
l_int|1UL
suffix:semicolon
id|nr
op_and_assign
op_complement
l_int|1UL
suffix:semicolon
r_while
c_loop
(paren
id|nr
)paren
(brace
r_int
r_int
id|h
comma
id|l
suffix:semicolon
id|l
op_assign
op_star
id|fdset
op_increment
suffix:semicolon
id|h
op_assign
id|l
op_rshift
l_int|32
suffix:semicolon
id|__put_user
c_func
(paren
id|l
comma
id|ufdset
)paren
suffix:semicolon
id|__put_user
c_func
(paren
id|h
comma
id|ufdset
op_plus
l_int|1
)paren
suffix:semicolon
id|ufdset
op_add_assign
l_int|2
suffix:semicolon
id|nr
op_sub_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|odd
)paren
id|__put_user
c_func
(paren
op_star
id|fdset
comma
id|ufdset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a virtual copy of sys_select from fs/select.c and probably&n; * should be compared to it from time to time&n; */
DECL|function|select_bits_alloc
r_static
r_void
op_star
id|select_bits_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_return
id|kmalloc
c_func
(paren
l_int|6
op_star
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|select_bits_free
r_static
r_void
id|select_bits_free
c_func
(paren
r_void
op_star
id|bits
comma
r_int
id|size
)paren
(brace
id|kfree
c_func
(paren
id|bits
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We can actually return ERESTARTSYS instead of EINTR, but I&squot;d&n; * like to be certain this leads to no problems. So I return&n; * EINTR just for safety.&n; *&n; * Update: ERESTARTSYS breaks at least the xview clock binary, so&n; * I&squot;m trying ERESTARTNOHAND which restart only when you want to.&n; */
DECL|macro|MAX_SELECT_SECONDS
mdefine_line|#define MAX_SELECT_SECONDS &bslash;&n;&t;((unsigned long) (MAX_SCHEDULE_TIMEOUT / HZ)-1)
id|asmlinkage
r_int
DECL|function|compat_sys_select
id|compat_sys_select
c_func
(paren
r_int
id|n
comma
id|compat_ulong_t
id|__user
op_star
id|inp
comma
id|compat_ulong_t
id|__user
op_star
id|outp
comma
id|compat_ulong_t
id|__user
op_star
id|exp
comma
r_struct
id|compat_timeval
id|__user
op_star
id|tvp
)paren
(brace
id|fd_set_bits
id|fds
suffix:semicolon
r_char
op_star
id|bits
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
id|ret
comma
id|size
comma
id|max_fdset
suffix:semicolon
id|timeout
op_assign
id|MAX_SCHEDULE_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|tvp
)paren
(brace
id|time_t
id|sec
comma
id|usec
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|tvp
comma
r_sizeof
(paren
op_star
id|tvp
)paren
)paren
)paren
op_logical_or
(paren
id|ret
op_assign
id|__get_user
c_func
(paren
id|sec
comma
op_amp
id|tvp-&gt;tv_sec
)paren
)paren
op_logical_or
(paren
id|ret
op_assign
id|__get_user
c_func
(paren
id|usec
comma
op_amp
id|tvp-&gt;tv_usec
)paren
)paren
)paren
r_goto
id|out_nofds
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sec
OL
l_int|0
op_logical_or
id|usec
OL
l_int|0
)paren
r_goto
id|out_nofds
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|sec
OL
id|MAX_SELECT_SECONDS
)paren
(brace
id|timeout
op_assign
id|ROUND_UP
c_func
(paren
id|usec
comma
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
id|timeout
op_add_assign
id|sec
op_star
(paren
r_int
r_int
)paren
id|HZ
suffix:semicolon
)brace
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
r_goto
id|out_nofds
suffix:semicolon
multiline_comment|/* max_fdset can increase, so grab it once to avoid race */
id|max_fdset
op_assign
id|current-&gt;files-&gt;max_fdset
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|max_fdset
)paren
id|n
op_assign
id|max_fdset
suffix:semicolon
multiline_comment|/*&n;&t; * We need 6 bitmaps (in/out/ex for both incoming and outgoing),&n;&t; * since we used fdset we need to allocate memory in units of&n;&t; * long-words.&n;&t; */
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|size
op_assign
id|FDS_BYTES
c_func
(paren
id|n
)paren
suffix:semicolon
id|bits
op_assign
id|select_bits_alloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
r_goto
id|out_nofds
suffix:semicolon
id|fds.in
op_assign
(paren
r_int
r_int
op_star
)paren
id|bits
suffix:semicolon
id|fds.out
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|bits
op_plus
id|size
)paren
suffix:semicolon
id|fds.ex
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|bits
op_plus
l_int|2
op_star
id|size
)paren
suffix:semicolon
id|fds.res_in
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|bits
op_plus
l_int|3
op_star
id|size
)paren
suffix:semicolon
id|fds.res_out
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|bits
op_plus
l_int|4
op_star
id|size
)paren
suffix:semicolon
id|fds.res_ex
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|bits
op_plus
l_int|5
op_star
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|compat_get_fd_set
c_func
(paren
id|n
comma
id|inp
comma
id|fds.in
)paren
)paren
op_logical_or
(paren
id|ret
op_assign
id|compat_get_fd_set
c_func
(paren
id|n
comma
id|outp
comma
id|fds.out
)paren
)paren
op_logical_or
(paren
id|ret
op_assign
id|compat_get_fd_set
c_func
(paren
id|n
comma
id|exp
comma
id|fds.ex
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|zero_fd_set
c_func
(paren
id|n
comma
id|fds.res_in
)paren
suffix:semicolon
id|zero_fd_set
c_func
(paren
id|n
comma
id|fds.res_out
)paren
suffix:semicolon
id|zero_fd_set
c_func
(paren
id|n
comma
id|fds.res_ex
)paren
suffix:semicolon
id|ret
op_assign
id|do_select
c_func
(paren
id|n
comma
op_amp
id|fds
comma
op_amp
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tvp
op_logical_and
op_logical_neg
(paren
id|current-&gt;personality
op_amp
id|STICKY_TIMEOUTS
)paren
)paren
(brace
id|time_t
id|sec
op_assign
l_int|0
comma
id|usec
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|sec
op_assign
id|timeout
op_div
id|HZ
suffix:semicolon
id|usec
op_assign
id|timeout
op_mod
id|HZ
suffix:semicolon
id|usec
op_mul_assign
(paren
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|sec
comma
op_amp
id|tvp-&gt;tv_sec
)paren
op_logical_or
id|put_user
c_func
(paren
id|usec
comma
op_amp
id|tvp-&gt;tv_usec
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|ret
op_assign
op_minus
id|ERESTARTNOHAND
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|compat_set_fd_set
c_func
(paren
id|n
comma
id|inp
comma
id|fds.res_in
)paren
suffix:semicolon
id|compat_set_fd_set
c_func
(paren
id|n
comma
id|outp
comma
id|fds.res_out
)paren
suffix:semicolon
id|compat_set_fd_set
c_func
(paren
id|n
comma
id|exp
comma
id|fds.res_ex
)paren
suffix:semicolon
id|out
suffix:colon
id|select_bits_free
c_func
(paren
id|bits
comma
id|size
)paren
suffix:semicolon
id|out_nofds
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_NFSD) || defined(CONFIG_NFSD_MODULE)
multiline_comment|/* Stuff for NFS server syscalls... */
DECL|struct|compat_nfsctl_svc
r_struct
id|compat_nfsctl_svc
(brace
DECL|member|svc32_port
id|u16
id|svc32_port
suffix:semicolon
DECL|member|svc32_nthreads
id|s32
id|svc32_nthreads
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_nfsctl_client
r_struct
id|compat_nfsctl_client
(brace
DECL|member|cl32_ident
id|s8
id|cl32_ident
(braket
id|NFSCLNT_IDMAX
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|cl32_naddr
id|s32
id|cl32_naddr
suffix:semicolon
DECL|member|cl32_addrlist
r_struct
id|in_addr
id|cl32_addrlist
(braket
id|NFSCLNT_ADDRMAX
)braket
suffix:semicolon
DECL|member|cl32_fhkeytype
id|s32
id|cl32_fhkeytype
suffix:semicolon
DECL|member|cl32_fhkeylen
id|s32
id|cl32_fhkeylen
suffix:semicolon
DECL|member|cl32_fhkey
id|u8
id|cl32_fhkey
(braket
id|NFSCLNT_KEYMAX
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_nfsctl_export
r_struct
id|compat_nfsctl_export
(brace
DECL|member|ex32_client
r_char
id|ex32_client
(braket
id|NFSCLNT_IDMAX
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|ex32_path
r_char
id|ex32_path
(braket
id|NFS_MAXPATHLEN
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|ex32_dev
id|compat_dev_t
id|ex32_dev
suffix:semicolon
DECL|member|ex32_ino
id|compat_ino_t
id|ex32_ino
suffix:semicolon
DECL|member|ex32_flags
id|compat_int_t
id|ex32_flags
suffix:semicolon
DECL|member|ex32_anon_uid
id|compat_uid_t
id|ex32_anon_uid
suffix:semicolon
DECL|member|ex32_anon_gid
id|compat_gid_t
id|ex32_anon_gid
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_nfsctl_fdparm
r_struct
id|compat_nfsctl_fdparm
(brace
DECL|member|gd32_addr
r_struct
id|sockaddr
id|gd32_addr
suffix:semicolon
DECL|member|gd32_path
id|s8
id|gd32_path
(braket
id|NFS_MAXPATHLEN
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|gd32_version
id|compat_int_t
id|gd32_version
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_nfsctl_fsparm
r_struct
id|compat_nfsctl_fsparm
(brace
DECL|member|gd32_addr
r_struct
id|sockaddr
id|gd32_addr
suffix:semicolon
DECL|member|gd32_path
id|s8
id|gd32_path
(braket
id|NFS_MAXPATHLEN
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|gd32_maxlen
id|compat_int_t
id|gd32_maxlen
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|compat_nfsctl_arg
r_struct
id|compat_nfsctl_arg
(brace
DECL|member|ca32_version
id|compat_int_t
id|ca32_version
suffix:semicolon
multiline_comment|/* safeguard */
r_union
(brace
DECL|member|u32_svc
r_struct
id|compat_nfsctl_svc
id|u32_svc
suffix:semicolon
DECL|member|u32_client
r_struct
id|compat_nfsctl_client
id|u32_client
suffix:semicolon
DECL|member|u32_export
r_struct
id|compat_nfsctl_export
id|u32_export
suffix:semicolon
DECL|member|u32_getfd
r_struct
id|compat_nfsctl_fdparm
id|u32_getfd
suffix:semicolon
DECL|member|u32_getfs
r_struct
id|compat_nfsctl_fsparm
id|u32_getfs
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
DECL|macro|ca32_svc
mdefine_line|#define ca32_svc&t;u.u32_svc
DECL|macro|ca32_client
mdefine_line|#define ca32_client&t;u.u32_client
DECL|macro|ca32_export
mdefine_line|#define ca32_export&t;u.u32_export
DECL|macro|ca32_getfd
mdefine_line|#define ca32_getfd&t;u.u32_getfd
DECL|macro|ca32_getfs
mdefine_line|#define ca32_getfs&t;u.u32_getfs
)brace
suffix:semicolon
DECL|union|compat_nfsctl_res
r_union
id|compat_nfsctl_res
(brace
DECL|member|cr32_getfh
id|__u8
id|cr32_getfh
(braket
id|NFS_FHSIZE
)braket
suffix:semicolon
DECL|member|cr32_getfs
r_struct
id|knfsd_fh
id|cr32_getfs
suffix:semicolon
)brace
suffix:semicolon
DECL|function|compat_nfs_svc_trans
r_static
r_int
id|compat_nfs_svc_trans
c_func
(paren
r_struct
id|nfsctl_arg
op_star
id|karg
comma
r_struct
id|compat_nfsctl_arg
id|__user
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
op_amp
id|arg-&gt;ca32_svc
comma
r_sizeof
(paren
id|arg-&gt;ca32_svc
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|get_user
c_func
(paren
id|karg-&gt;ca_version
comma
op_amp
id|arg-&gt;ca32_version
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_svc.svc_port
comma
op_amp
id|arg-&gt;ca32_svc.svc32_port
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_svc.svc_nthreads
comma
op_amp
id|arg-&gt;ca32_svc.svc32_nthreads
)paren
suffix:semicolon
r_return
(paren
id|err
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|compat_nfs_clnt_trans
r_static
r_int
id|compat_nfs_clnt_trans
c_func
(paren
r_struct
id|nfsctl_arg
op_star
id|karg
comma
r_struct
id|compat_nfsctl_arg
id|__user
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
op_amp
id|arg-&gt;ca32_client
comma
r_sizeof
(paren
id|arg-&gt;ca32_client
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|get_user
c_func
(paren
id|karg-&gt;ca_version
comma
op_amp
id|arg-&gt;ca32_version
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_client.cl_ident
(braket
l_int|0
)braket
comma
op_amp
id|arg-&gt;ca32_client.cl32_ident
(braket
l_int|0
)braket
comma
id|NFSCLNT_IDMAX
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_client.cl_naddr
comma
op_amp
id|arg-&gt;ca32_client.cl32_naddr
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_client.cl_addrlist
(braket
l_int|0
)braket
comma
op_amp
id|arg-&gt;ca32_client.cl32_addrlist
(braket
l_int|0
)braket
comma
(paren
r_sizeof
(paren
r_struct
id|in_addr
)paren
op_star
id|NFSCLNT_ADDRMAX
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_client.cl_fhkeytype
comma
op_amp
id|arg-&gt;ca32_client.cl32_fhkeytype
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_client.cl_fhkeylen
comma
op_amp
id|arg-&gt;ca32_client.cl32_fhkeylen
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_client.cl_fhkey
(braket
l_int|0
)braket
comma
op_amp
id|arg-&gt;ca32_client.cl32_fhkey
(braket
l_int|0
)braket
comma
id|NFSCLNT_KEYMAX
)paren
suffix:semicolon
r_return
(paren
id|err
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|compat_nfs_exp_trans
r_static
r_int
id|compat_nfs_exp_trans
c_func
(paren
r_struct
id|nfsctl_arg
op_star
id|karg
comma
r_struct
id|compat_nfsctl_arg
id|__user
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
op_amp
id|arg-&gt;ca32_export
comma
r_sizeof
(paren
id|arg-&gt;ca32_export
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|get_user
c_func
(paren
id|karg-&gt;ca_version
comma
op_amp
id|arg-&gt;ca32_version
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_export.ex_client
(braket
l_int|0
)braket
comma
op_amp
id|arg-&gt;ca32_export.ex32_client
(braket
l_int|0
)braket
comma
id|NFSCLNT_IDMAX
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_export.ex_path
(braket
l_int|0
)braket
comma
op_amp
id|arg-&gt;ca32_export.ex32_path
(braket
l_int|0
)braket
comma
id|NFS_MAXPATHLEN
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_export.ex_dev
comma
op_amp
id|arg-&gt;ca32_export.ex32_dev
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_export.ex_ino
comma
op_amp
id|arg-&gt;ca32_export.ex32_ino
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_export.ex_flags
comma
op_amp
id|arg-&gt;ca32_export.ex32_flags
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_export.ex_anon_uid
comma
op_amp
id|arg-&gt;ca32_export.ex32_anon_uid
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_export.ex_anon_gid
comma
op_amp
id|arg-&gt;ca32_export.ex32_anon_gid
)paren
suffix:semicolon
id|SET_UID
c_func
(paren
id|karg-&gt;ca_export.ex_anon_uid
comma
id|karg-&gt;ca_export.ex_anon_uid
)paren
suffix:semicolon
id|SET_GID
c_func
(paren
id|karg-&gt;ca_export.ex_anon_gid
comma
id|karg-&gt;ca_export.ex_anon_gid
)paren
suffix:semicolon
r_return
(paren
id|err
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|compat_nfs_getfd_trans
r_static
r_int
id|compat_nfs_getfd_trans
c_func
(paren
r_struct
id|nfsctl_arg
op_star
id|karg
comma
r_struct
id|compat_nfsctl_arg
id|__user
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
op_amp
id|arg-&gt;ca32_getfd
comma
r_sizeof
(paren
id|arg-&gt;ca32_getfd
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|get_user
c_func
(paren
id|karg-&gt;ca_version
comma
op_amp
id|arg-&gt;ca32_version
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_getfd.gd_addr
comma
op_amp
id|arg-&gt;ca32_getfd.gd32_addr
comma
(paren
r_sizeof
(paren
r_struct
id|sockaddr
)paren
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_getfd.gd_path
comma
op_amp
id|arg-&gt;ca32_getfd.gd32_path
comma
(paren
id|NFS_MAXPATHLEN
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_getfd.gd_version
comma
op_amp
id|arg-&gt;ca32_getfd.gd32_version
)paren
suffix:semicolon
r_return
(paren
id|err
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|compat_nfs_getfs_trans
r_static
r_int
id|compat_nfs_getfs_trans
c_func
(paren
r_struct
id|nfsctl_arg
op_star
id|karg
comma
r_struct
id|compat_nfsctl_arg
id|__user
op_star
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
op_amp
id|arg-&gt;ca32_getfs
comma
r_sizeof
(paren
id|arg-&gt;ca32_getfs
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|get_user
c_func
(paren
id|karg-&gt;ca_version
comma
op_amp
id|arg-&gt;ca32_version
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_getfs.gd_addr
comma
op_amp
id|arg-&gt;ca32_getfs.gd32_addr
comma
(paren
r_sizeof
(paren
r_struct
id|sockaddr
)paren
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__copy_from_user
c_func
(paren
op_amp
id|karg-&gt;ca_getfs.gd_path
comma
op_amp
id|arg-&gt;ca32_getfs.gd32_path
comma
(paren
id|NFS_MAXPATHLEN
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|err
op_or_assign
id|__get_user
c_func
(paren
id|karg-&gt;ca_getfs.gd_maxlen
comma
op_amp
id|arg-&gt;ca32_getfs.gd32_maxlen
)paren
suffix:semicolon
r_return
(paren
id|err
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This really doesn&squot;t need translations, we are only passing&n; * back a union which contains opaque nfs file handle data.&n; */
DECL|function|compat_nfs_getfh_res_trans
r_static
r_int
id|compat_nfs_getfh_res_trans
c_func
(paren
r_union
id|nfsctl_res
op_star
id|kres
comma
r_union
id|compat_nfsctl_res
id|__user
op_star
id|res
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|copy_to_user
c_func
(paren
id|res
comma
id|kres
comma
r_sizeof
(paren
op_star
id|res
)paren
)paren
suffix:semicolon
r_return
(paren
id|err
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|compat_sys_nfsservctl
id|asmlinkage
r_int
id|compat_sys_nfsservctl
c_func
(paren
r_int
id|cmd
comma
r_struct
id|compat_nfsctl_arg
id|__user
op_star
id|arg
comma
r_union
id|compat_nfsctl_res
id|__user
op_star
id|res
)paren
(brace
r_struct
id|nfsctl_arg
op_star
id|karg
suffix:semicolon
r_union
id|nfsctl_res
op_star
id|kres
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|karg
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|karg
)paren
comma
id|GFP_USER
)paren
suffix:semicolon
id|kres
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|kres
)paren
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|karg
op_logical_or
op_logical_neg
id|kres
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|NFSCTL_SVC
suffix:colon
id|err
op_assign
id|compat_nfs_svc_trans
c_func
(paren
id|karg
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NFSCTL_ADDCLIENT
suffix:colon
id|err
op_assign
id|compat_nfs_clnt_trans
c_func
(paren
id|karg
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NFSCTL_DELCLIENT
suffix:colon
id|err
op_assign
id|compat_nfs_clnt_trans
c_func
(paren
id|karg
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NFSCTL_EXPORT
suffix:colon
r_case
id|NFSCTL_UNEXPORT
suffix:colon
id|err
op_assign
id|compat_nfs_exp_trans
c_func
(paren
id|karg
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NFSCTL_GETFD
suffix:colon
id|err
op_assign
id|compat_nfs_getfd_trans
c_func
(paren
id|karg
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NFSCTL_GETFS
suffix:colon
id|err
op_assign
id|compat_nfs_getfs_trans
c_func
(paren
id|karg
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
multiline_comment|/* The __user pointer casts are valid because of the set_fs() */
id|err
op_assign
id|sys_nfsservctl
c_func
(paren
id|cmd
comma
(paren
r_void
id|__user
op_star
)paren
id|karg
comma
(paren
r_void
id|__user
op_star
)paren
id|kres
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|NFSCTL_GETFD
)paren
op_logical_or
(paren
id|cmd
op_eq
id|NFSCTL_GETFS
)paren
)paren
(brace
id|err
op_assign
id|compat_nfs_getfh_res_trans
c_func
(paren
id|kres
comma
id|res
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|kfree
c_func
(paren
id|karg
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|kres
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#else /* !NFSD */
DECL|function|compat_sys_nfsservctl
r_int
id|asmlinkage
id|compat_sys_nfsservctl
c_func
(paren
r_int
id|cmd
comma
r_void
op_star
id|notused
comma
r_void
op_star
id|notused2
)paren
(brace
r_return
id|sys_ni_syscall
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
