multiline_comment|/*&n; *  linux/fs/compat.c&n; *&n; *  Kernel compatibililty routines for e.g. 32 bit syscall support&n; *  on 64 bit kernels.&n; *&n; *  Copyright (C) 2002       Stephen Rothwell, IBM Corporation&n; *  Copyright (C) 1997-2000  Jakub Jelinek  (jakub@redhat.com)&n; *  Copyright (C) 1998       Eddie C. Dost  (ecd@skynet.be)&n; *  Copyright (C) 2001,2002  Andi Kleen, SuSE Labs &n; *  Copyright (C) 2003       Pavel Machek (pavel@suse.cz)&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License version 2 as&n; *  published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;linux/compat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/namei.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/vfs.h&gt;
macro_line|#include &lt;linux/ioctl32.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sockios.h&gt;&t;/* for SIOCDEVPRIVATE */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;net/sock.h&gt;&t;&t;/* siocdevprivate_ioctl */
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * Not all architectures have sys_utime, so implement this in terms&n; * of sys_utimes.&n; */
DECL|function|compat_sys_utime
id|asmlinkage
r_int
id|compat_sys_utime
c_func
(paren
r_char
op_star
id|filename
comma
r_struct
id|compat_utimbuf
op_star
id|t
)paren
(brace
r_struct
id|timeval
id|tv
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|tv
(braket
l_int|0
)braket
dot
id|tv_sec
comma
op_amp
id|t-&gt;actime
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|1
)braket
dot
id|tv_sec
comma
op_amp
id|t-&gt;modtime
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tv
(braket
l_int|0
)braket
dot
id|tv_usec
op_assign
l_int|0
suffix:semicolon
id|tv
(braket
l_int|1
)braket
dot
id|tv_usec
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|do_utimes
c_func
(paren
id|filename
comma
id|t
ques
c_cond
id|tv
suffix:colon
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|compat_sys_utimes
id|asmlinkage
r_int
id|compat_sys_utimes
c_func
(paren
r_char
op_star
id|filename
comma
r_struct
id|compat_timeval
op_star
id|t
)paren
(brace
r_struct
id|timeval
id|tv
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|tv
(braket
l_int|0
)braket
dot
id|tv_sec
comma
op_amp
id|t
(braket
l_int|0
)braket
dot
id|tv_sec
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|0
)braket
dot
id|tv_usec
comma
op_amp
id|t
(braket
l_int|0
)braket
dot
id|tv_usec
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|1
)braket
dot
id|tv_sec
comma
op_amp
id|t
(braket
l_int|1
)braket
dot
id|tv_sec
)paren
op_logical_or
id|get_user
c_func
(paren
id|tv
(braket
l_int|1
)braket
dot
id|tv_usec
comma
op_amp
id|t
(braket
l_int|1
)braket
dot
id|tv_usec
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|do_utimes
c_func
(paren
id|filename
comma
id|t
ques
c_cond
id|tv
suffix:colon
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|compat_sys_newstat
id|asmlinkage
r_int
id|compat_sys_newstat
c_func
(paren
r_char
op_star
id|filename
comma
r_struct
id|compat_stat
op_star
id|statbuf
)paren
(brace
r_struct
id|kstat
id|stat
suffix:semicolon
r_int
id|error
op_assign
id|vfs_stat
c_func
(paren
id|filename
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|cp_compat_stat
c_func
(paren
op_amp
id|stat
comma
id|statbuf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_sys_newlstat
id|asmlinkage
r_int
id|compat_sys_newlstat
c_func
(paren
r_char
op_star
id|filename
comma
r_struct
id|compat_stat
op_star
id|statbuf
)paren
(brace
r_struct
id|kstat
id|stat
suffix:semicolon
r_int
id|error
op_assign
id|vfs_lstat
c_func
(paren
id|filename
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|cp_compat_stat
c_func
(paren
op_amp
id|stat
comma
id|statbuf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_sys_newfstat
id|asmlinkage
r_int
id|compat_sys_newfstat
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|compat_stat
op_star
id|statbuf
)paren
(brace
r_struct
id|kstat
id|stat
suffix:semicolon
r_int
id|error
op_assign
id|vfs_fstat
c_func
(paren
id|fd
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|cp_compat_stat
c_func
(paren
op_amp
id|stat
comma
id|statbuf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|put_compat_statfs
r_static
r_int
id|put_compat_statfs
c_func
(paren
r_struct
id|compat_statfs
op_star
id|ubuf
comma
r_struct
id|kstatfs
op_star
id|kbuf
)paren
(brace
r_if
c_cond
(paren
r_sizeof
id|ubuf-&gt;f_blocks
op_eq
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|kbuf-&gt;f_blocks
op_or
id|kbuf-&gt;f_bfree
op_or
id|kbuf-&gt;f_bavail
op_or
id|kbuf-&gt;f_files
op_or
id|kbuf-&gt;f_ffree
)paren
op_amp
l_int|0xffffffff00000000ULL
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ubuf
comma
r_sizeof
(paren
op_star
id|ubuf
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_type
comma
op_amp
id|ubuf-&gt;f_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bsize
comma
op_amp
id|ubuf-&gt;f_bsize
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_blocks
comma
op_amp
id|ubuf-&gt;f_blocks
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bfree
comma
op_amp
id|ubuf-&gt;f_bfree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bavail
comma
op_amp
id|ubuf-&gt;f_bavail
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_files
comma
op_amp
id|ubuf-&gt;f_files
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_ffree
comma
op_amp
id|ubuf-&gt;f_ffree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_namelen
comma
op_amp
id|ubuf-&gt;f_namelen
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|0
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|0
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|1
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|1
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_frsize
comma
op_amp
id|ubuf-&gt;f_frsize
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|0
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|1
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|2
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|3
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
l_int|0
comma
op_amp
id|ubuf-&gt;f_spare
(braket
l_int|4
)braket
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The following statfs calls are copies of code from fs/open.c and&n; * should be checked against those from time to time&n; */
DECL|function|compat_sys_statfs
id|asmlinkage
r_int
id|compat_sys_statfs
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|compat_statfs
op_star
id|buf
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|user_path_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|kstatfs
id|tmp
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|nd.dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_sys_fstatfs
id|asmlinkage
r_int
id|compat_sys_fstatfs
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|compat_statfs
op_star
id|buf
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|kstatfs
id|tmp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|put_compat_statfs64
r_static
r_int
id|put_compat_statfs64
c_func
(paren
r_struct
id|compat_statfs64
op_star
id|ubuf
comma
r_struct
id|kstatfs
op_star
id|kbuf
)paren
(brace
r_if
c_cond
(paren
r_sizeof
id|ubuf-&gt;f_blocks
op_eq
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|kbuf-&gt;f_blocks
op_or
id|kbuf-&gt;f_bfree
op_or
id|kbuf-&gt;f_bavail
op_or
id|kbuf-&gt;f_files
op_or
id|kbuf-&gt;f_ffree
)paren
op_amp
l_int|0xffffffff00000000ULL
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|ubuf
comma
r_sizeof
(paren
op_star
id|ubuf
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_type
comma
op_amp
id|ubuf-&gt;f_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bsize
comma
op_amp
id|ubuf-&gt;f_bsize
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_blocks
comma
op_amp
id|ubuf-&gt;f_blocks
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bfree
comma
op_amp
id|ubuf-&gt;f_bfree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_bavail
comma
op_amp
id|ubuf-&gt;f_bavail
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_files
comma
op_amp
id|ubuf-&gt;f_files
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_ffree
comma
op_amp
id|ubuf-&gt;f_ffree
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_namelen
comma
op_amp
id|ubuf-&gt;f_namelen
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|0
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|0
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_fsid.val
(braket
l_int|1
)braket
comma
op_amp
id|ubuf-&gt;f_fsid.val
(braket
l_int|1
)braket
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kbuf-&gt;f_frsize
comma
op_amp
id|ubuf-&gt;f_frsize
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|compat_statfs64
id|asmlinkage
r_int
id|compat_statfs64
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_struct
id|compat_statfs64
op_star
id|buf
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|user_path_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|kstatfs
id|tmp
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|nd.dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs64
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|compat_fstatfs64
id|asmlinkage
r_int
id|compat_fstatfs64
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|compat_statfs64
op_star
id|buf
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|kstatfs
id|tmp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|vfs_statfs
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_sb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|put_compat_statfs64
c_func
(paren
id|buf
comma
op_amp
id|tmp
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* ioctl32 stuff, used by sparc64, parisc, s390x, ppc64, x86_64 */
DECL|macro|IOCTL_HASHSIZE
mdefine_line|#define IOCTL_HASHSIZE 256
DECL|variable|ioctl32_hash_table
r_struct
id|ioctl_trans
op_star
id|ioctl32_hash_table
(braket
id|IOCTL_HASHSIZE
)braket
suffix:semicolon
r_extern
r_struct
id|ioctl_trans
id|ioctl_start
(braket
)braket
suffix:semicolon
r_extern
r_int
id|ioctl_table_size
suffix:semicolon
DECL|function|ioctl32_hash
r_static
r_inline
r_int
r_int
id|ioctl32_hash
c_func
(paren
r_int
r_int
id|cmd
)paren
(brace
r_return
(paren
(paren
(paren
id|cmd
op_rshift
l_int|6
)paren
op_xor
(paren
id|cmd
op_rshift
l_int|4
)paren
op_xor
id|cmd
)paren
)paren
op_mod
id|IOCTL_HASHSIZE
suffix:semicolon
)brace
DECL|function|ioctl32_insert_translation
r_static
r_void
id|ioctl32_insert_translation
c_func
(paren
r_struct
id|ioctl_trans
op_star
id|trans
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
r_struct
id|ioctl_trans
op_star
id|t
suffix:semicolon
id|hash
op_assign
id|ioctl32_hash
(paren
id|trans-&gt;cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioctl32_hash_table
(braket
id|hash
)braket
)paren
id|ioctl32_hash_table
(braket
id|hash
)braket
op_assign
id|trans
suffix:semicolon
r_else
(brace
id|t
op_assign
id|ioctl32_hash_table
(braket
id|hash
)braket
suffix:semicolon
r_while
c_loop
(paren
id|t-&gt;next
)paren
id|t
op_assign
id|t-&gt;next
suffix:semicolon
id|trans-&gt;next
op_assign
l_int|0
suffix:semicolon
id|t-&gt;next
op_assign
id|trans
suffix:semicolon
)brace
)brace
DECL|function|init_sys32_ioctl
r_static
r_int
id|__init
id|init_sys32_ioctl
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ioctl_table_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioctl_start
(braket
id|i
)braket
dot
id|next
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ioctl translation %d bad&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ioctl32_insert_translation
c_func
(paren
op_amp
id|ioctl_start
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_sys32_ioctl
id|__initcall
c_func
(paren
id|init_sys32_ioctl
)paren
suffix:semicolon
DECL|variable|ioctl_free_list
r_static
r_struct
id|ioctl_trans
op_star
id|ioctl_free_list
suffix:semicolon
multiline_comment|/* Never free them really. This avoids SMP races. With a Read-Copy-Update&n;   enabled kernel we could just use the RCU infrastructure for this. */
DECL|function|free_ioctl
r_static
r_void
id|free_ioctl
c_func
(paren
r_struct
id|ioctl_trans
op_star
id|t
)paren
(brace
id|t-&gt;cmd
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|t-&gt;next
op_assign
id|ioctl_free_list
suffix:semicolon
id|ioctl_free_list
op_assign
id|t
suffix:semicolon
)brace
DECL|function|register_ioctl32_conversion
r_int
id|register_ioctl32_conversion
c_func
(paren
r_int
r_int
id|cmd
comma
r_int
(paren
op_star
id|handler
)paren
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|file
op_star
)paren
)paren
(brace
r_struct
id|ioctl_trans
op_star
id|t
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|ioctl32_hash
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|t
op_assign
(paren
r_struct
id|ioctl_trans
op_star
)paren
id|ioctl32_hash_table
(braket
id|hash
)braket
suffix:semicolon
id|t
suffix:semicolon
id|t
op_assign
id|t-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;cmd
op_eq
id|cmd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to register duplicated ioctl32 handler %x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ioctl_free_list
)paren
(brace
id|t
op_assign
id|ioctl_free_list
suffix:semicolon
id|ioctl_free_list
op_assign
id|t-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|t
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ioctl_trans
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|t-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|t-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|t-&gt;handler
op_assign
id|handler
suffix:semicolon
id|ioctl32_insert_translation
c_func
(paren
id|t
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|builtin_ioctl
r_static
r_inline
r_int
id|builtin_ioctl
c_func
(paren
r_struct
id|ioctl_trans
op_star
id|t
)paren
(brace
r_return
id|t
op_ge
id|ioctl_start
op_logical_and
id|t
OL
(paren
id|ioctl_start
op_plus
id|ioctl_table_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Problem: &n;   This function cannot unregister duplicate ioctls, because they are not&n;   unique.&n;   When they happen we need to extend the prototype to pass the handler too. */
DECL|function|unregister_ioctl32_conversion
r_int
id|unregister_ioctl32_conversion
c_func
(paren
r_int
r_int
id|cmd
)paren
(brace
r_int
r_int
id|hash
op_assign
id|ioctl32_hash
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_struct
id|ioctl_trans
op_star
id|t
comma
op_star
id|t1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
(paren
r_struct
id|ioctl_trans
op_star
)paren
id|ioctl32_hash_table
(braket
id|hash
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t-&gt;cmd
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|builtin_ioctl
c_func
(paren
id|t
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%p tried to unregister builtin ioctl %x&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|cmd
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioctl32_hash_table
(braket
id|hash
)braket
op_assign
id|t-&gt;next
suffix:semicolon
id|free_ioctl
c_func
(paren
id|t
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|t-&gt;next
)paren
(brace
id|t1
op_assign
(paren
r_struct
id|ioctl_trans
op_star
)paren
(paren
r_int
)paren
id|t-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|t1-&gt;cmd
op_eq
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|builtin_ioctl
c_func
(paren
id|t1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%p tried to unregister builtin ioctl %x&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
comma
id|cmd
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|t-&gt;next
op_assign
id|t1-&gt;next
suffix:semicolon
id|free_ioctl
c_func
(paren
id|t1
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|t
op_assign
id|t1
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trying to free unknown 32bit ioctl handler %x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|register_ioctl32_conversion
id|EXPORT_SYMBOL
c_func
(paren
id|register_ioctl32_conversion
)paren
suffix:semicolon
DECL|variable|unregister_ioctl32_conversion
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_ioctl32_conversion
)paren
suffix:semicolon
DECL|function|compat_sys_ioctl
id|asmlinkage
r_int
id|compat_sys_ioctl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_struct
id|ioctl_trans
op_star
id|t
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
(brace
r_goto
id|out2
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_op
op_logical_or
op_logical_neg
id|filp-&gt;f_op-&gt;ioctl
)paren
(brace
id|error
op_assign
id|sys_ioctl
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|t
op_assign
(paren
r_struct
id|ioctl_trans
op_star
)paren
id|ioctl32_hash_table
(braket
id|ioctl32_hash
(paren
id|cmd
)paren
)braket
suffix:semicolon
r_while
c_loop
(paren
id|t
op_logical_and
id|t-&gt;cmd
op_ne
id|cmd
)paren
id|t
op_assign
(paren
r_struct
id|ioctl_trans
op_star
)paren
id|t-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|t
)paren
(brace
r_if
c_cond
(paren
id|t-&gt;handler
)paren
id|error
op_assign
id|t
op_member_access_from_pointer
id|handler
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
comma
id|filp
)paren
suffix:semicolon
r_else
id|error
op_assign
id|sys_ioctl
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_ge
id|SIOCDEVPRIVATE
op_logical_and
id|cmd
op_le
(paren
id|SIOCDEVPRIVATE
op_plus
l_int|15
)paren
)paren
(brace
id|error
op_assign
id|siocdevprivate_ioctl
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
op_le
l_int|50
)paren
(brace
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_char
op_star
id|path
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
comma
op_star
id|fn
op_assign
l_string|&quot;?&quot;
suffix:semicolon
multiline_comment|/* find the name of the device. */
r_if
c_cond
(paren
id|path
)paren
(brace
id|fn
op_assign
id|d_path
c_func
(paren
id|filp-&gt;f_dentry
comma
id|filp-&gt;f_vfsmnt
comma
id|path
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&squot;%c&squot;&quot;
comma
(paren
id|cmd
op_rshift
l_int|24
)paren
op_amp
l_int|0x3f
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isprint
c_func
(paren
id|buf
(braket
l_int|1
)braket
)paren
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%02x&quot;
comma
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ioctl32(%s:%d): Unknown cmd fd(%d) &quot;
l_string|&quot;cmd(%08x){%s} arg(%08x) on %s&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
(paren
r_int
)paren
id|fd
comma
(paren
r_int
r_int
)paren
id|cmd
comma
id|buf
comma
(paren
r_int
r_int
)paren
id|arg
comma
id|fn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|path
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|out
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out2
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|get_compat_flock
r_static
r_int
id|get_compat_flock
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|put_compat_flock
r_static
r_int
id|put_compat_flock
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef HAVE_ARCH_GET_COMPAT_FLOCK64
DECL|function|get_compat_flock64
r_static
r_int
id|get_compat_flock64
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock64
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__get_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef HAVE_ARCH_PUT_COMPAT_FLOCK64
DECL|function|put_compat_flock64
r_static
r_int
id|put_compat_flock64
c_func
(paren
r_struct
id|flock
op_star
id|kfl
comma
r_struct
id|compat_flock64
op_star
id|ufl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|ufl
comma
r_sizeof
(paren
op_star
id|ufl
)paren
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_type
comma
op_amp
id|ufl-&gt;l_type
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_whence
comma
op_amp
id|ufl-&gt;l_whence
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_start
comma
op_amp
id|ufl-&gt;l_start
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_len
comma
op_amp
id|ufl-&gt;l_len
)paren
op_logical_or
id|__put_user
c_func
(paren
id|kfl-&gt;l_pid
comma
op_amp
id|ufl-&gt;l_pid
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_extern
id|asmlinkage
r_int
id|sys_fcntl
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|function|compat_sys_fcntl64
id|asmlinkage
r_int
id|compat_sys_fcntl64
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|mm_segment_t
id|old_fs
suffix:semicolon
r_struct
id|flock
id|f
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|F_GETLK
suffix:colon
r_case
id|F_SETLK
suffix:colon
r_case
id|F_SETLKW
suffix:colon
id|ret
op_assign
id|get_compat_flock
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|sys_fcntl
c_func
(paren
id|fd
comma
id|cmd
comma
(paren
r_int
r_int
)paren
op_amp
id|f
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|F_GETLK
)paren
op_logical_and
(paren
id|ret
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|f.l_start
op_ge
id|COMPAT_OFF_T_MAX
)paren
op_logical_or
(paren
(paren
id|f.l_start
op_plus
id|f.l_len
)paren
op_ge
id|COMPAT_OFF_T_MAX
)paren
)paren
id|ret
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|put_compat_flock
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|F_GETLK64
suffix:colon
r_case
id|F_SETLK64
suffix:colon
r_case
id|F_SETLKW64
suffix:colon
id|ret
op_assign
id|get_compat_flock64
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|sys_fcntl
c_func
(paren
id|fd
comma
(paren
id|cmd
op_eq
id|F_GETLK64
)paren
ques
c_cond
id|F_GETLK
suffix:colon
(paren
(paren
id|cmd
op_eq
id|F_SETLK64
)paren
ques
c_cond
id|F_SETLK
suffix:colon
id|F_SETLKW
)paren
comma
(paren
r_int
r_int
)paren
op_amp
id|f
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|F_GETLK64
)paren
op_logical_and
(paren
id|ret
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|f.l_start
op_ge
id|COMPAT_LOFF_T_MAX
)paren
op_logical_or
(paren
(paren
id|f.l_start
op_plus
id|f.l_len
)paren
op_ge
id|COMPAT_LOFF_T_MAX
)paren
)paren
id|ret
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|put_compat_flock64
c_func
(paren
op_amp
id|f
comma
id|compat_ptr
c_func
(paren
id|arg
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
id|sys_fcntl
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|compat_sys_fcntl
id|asmlinkage
r_int
id|compat_sys_fcntl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|F_GETLK64
)paren
op_logical_or
(paren
id|cmd
op_eq
id|F_SETLK64
)paren
op_logical_or
(paren
id|cmd
op_eq
id|F_SETLKW64
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|compat_sys_fcntl64
c_func
(paren
id|fd
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
eof
