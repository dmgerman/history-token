multiline_comment|/*&n; * linux/fs/befs/btree.c&n; *&n; * Copyright (C) 2001-2002 Will Dyson &lt;will_dyson@pobox.com&gt;&n; *&n; * Licensed under the GNU GPL. See the file COPYING for details.&n; *&n; * 2002-02-05: Sergey S. Kostyliov added binary search withing&n; * &t;&t;btree nodes.&n; *&n; * Many thanks to:&n; *&n; * Dominic Giampaolo, author of &quot;Practical File System&n; * Design with the Be File System&quot;, for such a helpful book.&n; * &n; * Marcus J. Ranum, author of the b+tree package in &n; * comp.sources.misc volume 10. This code is not copied from that&n; * work, but it is partially based on it.&n; *&n; * Makoto Kato, author of the original BeFS for linux filesystem&n; * driver.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;befs.h&quot;
macro_line|#include &quot;btree.h&quot;
macro_line|#include &quot;datastream.h&quot;
macro_line|#include &quot;endian.h&quot;
multiline_comment|/*&n; * The btree functions in this file are built on top of the&n; * datastream.c interface, which is in turn built on top of the&n; * io.c interface.&n; */
multiline_comment|/* Befs B+tree structure:&n; * &n; * The first thing in the tree is the tree superblock. It tells you&n; * all kinds of usefull things about the tree, like where the rootnode&n; * is located, and the size of the nodes (always 1024 with current version&n; * of BeOS).&n; *&n; * The rest of the tree consists of a series of nodes. Nodes contain a header&n; * (struct befs_btree_nodehead), the packed key data, an array of shorts &n; * containing the ending offsets for each of the keys, and an array of&n; * befs_off_t values. In interior nodes, the keys are the ending keys for &n; * the childnode they point to, and the values are offsets into the &n; * datastream containing the tree. &n; */
multiline_comment|/* Note:&n; * &n; * The book states 2 confusing things about befs b+trees. First, &n; * it states that the overflow field of node headers is used by internal nodes&n; * to point to another node that &quot;effectively continues this one&quot;. Here is what&n; * I believe that means. Each key in internal nodes points to another node that&n; * contains key values less than itself. Inspection reveals that the last key &n; * in the internal node is not the last key in the index. Keys that are &n; * greater than the last key in the internal node go into the overflow node. &n; * I imagine there is a performance reason for this.&n; *&n; * Second, it states that the header of a btree node is sufficient to &n; * distinguish internal nodes from leaf nodes. Without saying exactly how. &n; * After figuring out the first, it becomes obvious that internal nodes have&n; * overflow nodes and leafnodes do not.&n; */
multiline_comment|/* &n; * Currently, this code is only good for directory B+trees.&n; * In order to be used for other BFS indexes, it needs to be extended to handle&n; * duplicate keys and non-string keytypes (int32, int64, float, double).&n; */
multiline_comment|/*&n; * In memory structure of each btree node&n; */
r_typedef
r_struct
(brace
DECL|member|head
id|befs_btree_nodehead
id|head
suffix:semicolon
multiline_comment|/* head of node converted to cpu byteorder */
DECL|member|bh
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
DECL|member|od_node
id|befs_btree_nodehead
op_star
id|od_node
suffix:semicolon
multiline_comment|/* on disk node */
DECL|typedef|befs_btree_node
)brace
id|befs_btree_node
suffix:semicolon
multiline_comment|/* local constants */
DECL|variable|befs_bt_inval
r_static
r_const
id|befs_off_t
id|befs_bt_inval
op_assign
l_int|0xffffffffffffffff
suffix:semicolon
multiline_comment|/* local functions */
r_static
r_int
id|befs_btree_seekleaf
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|befs_btree_super
op_star
id|bt_super
comma
id|befs_btree_node
op_star
id|this_node
comma
id|befs_off_t
op_star
id|node_off
)paren
suffix:semicolon
r_static
r_int
id|befs_bt_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|befs_btree_super
op_star
id|sup
)paren
suffix:semicolon
r_static
r_int
id|befs_bt_read_node
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|befs_btree_node
op_star
id|node
comma
id|befs_off_t
id|node_off
)paren
suffix:semicolon
r_static
r_int
id|befs_leafnode
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
suffix:semicolon
r_static
id|u16
op_star
id|befs_bt_keylen_index
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
suffix:semicolon
r_static
id|befs_off_t
op_star
id|befs_bt_valarray
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
suffix:semicolon
r_static
r_char
op_star
id|befs_bt_keydata
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
suffix:semicolon
r_static
r_int
id|befs_find_key
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_btree_node
op_star
id|node
comma
r_const
r_char
op_star
id|findkey
comma
id|befs_off_t
op_star
id|value
)paren
suffix:semicolon
r_static
r_char
op_star
id|befs_bt_get_key
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_btree_node
op_star
id|node
comma
r_int
id|index
comma
id|u16
op_star
id|keylen
)paren
suffix:semicolon
r_static
r_int
id|befs_compare_strings
c_func
(paren
r_const
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
suffix:semicolon
multiline_comment|/**&n; * befs_bt_read_super - read in btree superblock convert to cpu byteorder&n; * @sb: Filesystem superblock&n; * @ds: Datastream to read from&n; * @sup: Buffer in which to place the btree superblock&n; *&n; * Calls befs_read_datastream to read in the btree superblock and&n; * makes sure it is in cpu byteorder, byteswapping if necessary.&n; *&n; * On success, returns BEFS_OK and *@sup contains the btree superblock,&n; * in cpu byte order.&n; *&n; * On failure, BEFS_ERR is returned.&n; */
r_static
r_int
DECL|function|befs_bt_read_super
id|befs_bt_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|befs_btree_super
op_star
id|sup
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
id|befs_btree_super
op_star
id|od_sup
op_assign
l_int|NULL
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_btree_read_super()&quot;
)paren
suffix:semicolon
id|bh
op_assign
id|befs_read_datastream
c_func
(paren
id|sb
comma
id|ds
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;Couldn&squot;t read index header.&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|od_sup
op_assign
(paren
id|befs_btree_super
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|befs_dump_index_entry
c_func
(paren
id|sb
comma
id|od_sup
)paren
suffix:semicolon
id|sup-&gt;magic
op_assign
id|fs32_to_cpu
c_func
(paren
id|sb
comma
id|od_sup-&gt;magic
)paren
suffix:semicolon
id|sup-&gt;node_size
op_assign
id|fs32_to_cpu
c_func
(paren
id|sb
comma
id|od_sup-&gt;node_size
)paren
suffix:semicolon
id|sup-&gt;max_depth
op_assign
id|fs32_to_cpu
c_func
(paren
id|sb
comma
id|od_sup-&gt;max_depth
)paren
suffix:semicolon
id|sup-&gt;data_type
op_assign
id|fs32_to_cpu
c_func
(paren
id|sb
comma
id|od_sup-&gt;data_type
)paren
suffix:semicolon
id|sup-&gt;root_node_ptr
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|od_sup-&gt;root_node_ptr
)paren
suffix:semicolon
id|sup-&gt;free_node_ptr
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|od_sup-&gt;free_node_ptr
)paren
suffix:semicolon
id|sup-&gt;max_size
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|od_sup-&gt;max_size
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sup-&gt;magic
op_ne
id|BEFS_BTREE_MAGIC
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;Index header has bad magic.&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_read_super()&quot;
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
id|error
suffix:colon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_read_super() ERROR&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_bt_read_node - read in btree node and convert to cpu byteorder&n; * @sb: Filesystem superblock&n; * @ds: Datastream to read from&n; * @node: Buffer in which to place the btree node&n; * @node_off: Starting offset (in bytes) of the node in @ds&n; *&n; * Calls befs_read_datastream to read in the indicated btree node and&n; * makes sure its header fields are in cpu byteorder, byteswapping if&n; * necessary.&n; * Note: node-&gt;bh must be NULL when this function called first&n; * time. Don&squot;t forget brelse(node-&gt;bh) after last call.&n; *&n; * On success, returns BEFS_OK and *@node contains the btree node that&n; * starts at @node_off, with the node-&gt;head fields in cpu byte order.&n; *&n; * On failure, BEFS_ERR is returned.&n; */
r_static
r_int
DECL|function|befs_bt_read_node
id|befs_bt_read_node
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|befs_btree_node
op_star
id|node
comma
id|befs_off_t
id|node_off
)paren
(brace
id|uint
id|off
op_assign
l_int|0
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_bt_read_node()&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;bh
)paren
id|brelse
c_func
(paren
id|node-&gt;bh
)paren
suffix:semicolon
id|node-&gt;bh
op_assign
id|befs_read_datastream
c_func
(paren
id|sb
comma
id|ds
comma
id|node_off
comma
op_amp
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node-&gt;bh
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_bt_read_node() failed to read &quot;
l_string|&quot;node at %Lu&quot;
comma
id|node_off
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_bt_read_node() ERROR&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
id|node-&gt;od_node
op_assign
(paren
id|befs_btree_nodehead
op_star
)paren
(paren
(paren
r_void
op_star
)paren
id|node-&gt;bh-&gt;b_data
op_plus
id|off
)paren
suffix:semicolon
id|befs_dump_index_node
c_func
(paren
id|sb
comma
id|node-&gt;od_node
)paren
suffix:semicolon
id|node-&gt;head.left
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|node-&gt;od_node-&gt;left
)paren
suffix:semicolon
id|node-&gt;head.right
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|node-&gt;od_node-&gt;right
)paren
suffix:semicolon
id|node-&gt;head.overflow
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|node-&gt;od_node-&gt;overflow
)paren
suffix:semicolon
id|node-&gt;head.all_key_count
op_assign
id|fs16_to_cpu
c_func
(paren
id|sb
comma
id|node-&gt;od_node-&gt;all_key_count
)paren
suffix:semicolon
id|node-&gt;head.all_key_length
op_assign
id|fs16_to_cpu
c_func
(paren
id|sb
comma
id|node-&gt;od_node-&gt;all_key_length
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_read_node()&quot;
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_btree_find - Find a key in a befs B+tree&n; * @sb: Filesystem superblock&n; * @ds: Datastream containing btree&n; * @key: Key string to lookup in btree&n; * @value: Value stored with @key&n; *&n; * On sucess, returns BEFS_OK and sets *@value to the value stored&n; * with @key (usually the disk block number of an inode).&n; *&n; * On failure, returns BEFS_ERR or BEFS_BT_NOT_FOUND.&n; * &n; * Algorithm: &n; *   Read the superblock and rootnode of the b+tree.&n; *   Drill down through the interior nodes using befs_find_key().&n; *   Once at the correct leaf node, use befs_find_key() again to get the&n; *   actuall value stored with the key.&n; */
r_int
DECL|function|befs_btree_find
id|befs_btree_find
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
r_const
r_char
op_star
id|key
comma
id|befs_off_t
op_star
id|value
)paren
(brace
id|befs_btree_node
op_star
id|this_node
op_assign
l_int|NULL
suffix:semicolon
id|befs_btree_super
id|bt_super
suffix:semicolon
id|befs_off_t
id|node_off
suffix:semicolon
r_int
id|res
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_btree_find() Key: %s&quot;
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|befs_bt_read_super
c_func
(paren
id|sb
comma
id|ds
comma
op_amp
id|bt_super
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_find() failed to read index superblock&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|this_node
op_assign
(paren
id|befs_btree_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|befs_btree_node
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this_node
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_find() failed to allocate %u &quot;
l_string|&quot;bytes of memory&quot;
comma
r_sizeof
(paren
id|befs_btree_node
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|this_node-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* read in root node */
id|node_off
op_assign
id|bt_super.root_node_ptr
suffix:semicolon
r_if
c_cond
(paren
id|befs_bt_read_node
c_func
(paren
id|sb
comma
id|ds
comma
id|this_node
comma
id|node_off
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_find() failed to read &quot;
l_string|&quot;node at %Lu&quot;
comma
id|node_off
)paren
suffix:semicolon
r_goto
id|error_alloc
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|befs_leafnode
c_func
(paren
id|this_node
)paren
)paren
(brace
id|res
op_assign
id|befs_find_key
c_func
(paren
id|sb
comma
id|this_node
comma
id|key
comma
op_amp
id|node_off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|BEFS_BT_NOT_FOUND
)paren
id|node_off
op_assign
id|this_node-&gt;head.overflow
suffix:semicolon
multiline_comment|/* if no match, go to overflow node */
r_if
c_cond
(paren
id|befs_bt_read_node
c_func
(paren
id|sb
comma
id|ds
comma
id|this_node
comma
id|node_off
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_find() failed to read &quot;
l_string|&quot;node at %Lu&quot;
comma
id|node_off
)paren
suffix:semicolon
r_goto
id|error_alloc
suffix:semicolon
)brace
)brace
multiline_comment|/* at the correct leaf node now */
id|res
op_assign
id|befs_find_key
c_func
(paren
id|sb
comma
id|this_node
comma
id|key
comma
id|value
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|this_node-&gt;bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this_node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
id|BEFS_BT_MATCH
)paren
(brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_find() Key %s not found&quot;
comma
id|key
)paren
suffix:semicolon
op_star
id|value
op_assign
l_int|0
suffix:semicolon
r_return
id|BEFS_BT_NOT_FOUND
suffix:semicolon
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_find() Found key %s, value %Lu&quot;
comma
id|key
comma
op_star
id|value
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
id|error_alloc
suffix:colon
id|kfree
c_func
(paren
id|this_node
)paren
suffix:semicolon
id|error
suffix:colon
op_star
id|value
op_assign
l_int|0
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_find() ERROR&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_find_key - Search for a key within a node&n; * @sb: Filesystem superblock&n; * @node: Node to find the key within&n; * @key: Keystring to search for&n; * @value: If key is found, the value stored with the key is put here&n; *&n; * finds exact match if one exists, and returns BEFS_BT_MATCH&n; * If no exact match, finds first key in node that is greater&n; * (alpabeticly) than the search key and returns BEFS_BT_PARMATCH&n; * (for partial match, I guess). Can you think of something better to&n; * call it?&n; *&n; * If no key was a match or greater than the search key, return&n; * BEFS_BT_NOT_FOUND.&n; *&n; * Use binary search instead of a linear.&n; */
r_static
r_int
DECL|function|befs_find_key
id|befs_find_key
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_btree_node
op_star
id|node
comma
r_const
r_char
op_star
id|findkey
comma
id|befs_off_t
op_star
id|value
)paren
(brace
r_int
id|first
comma
id|last
comma
id|mid
suffix:semicolon
r_int
id|eq
suffix:semicolon
id|u16
id|keylen
suffix:semicolon
r_int
id|findkey_len
suffix:semicolon
r_char
op_star
id|thiskey
suffix:semicolon
id|befs_off_t
op_star
id|valarray
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_find_key() %s&quot;
comma
id|findkey
)paren
suffix:semicolon
op_star
id|value
op_assign
l_int|0
suffix:semicolon
id|findkey_len
op_assign
id|strlen
c_func
(paren
id|findkey
)paren
suffix:semicolon
multiline_comment|/* if node can not contain key, just skeep this node */
id|last
op_assign
id|node-&gt;head.all_key_count
op_minus
l_int|1
suffix:semicolon
id|thiskey
op_assign
id|befs_bt_get_key
c_func
(paren
id|sb
comma
id|node
comma
id|last
comma
op_amp
id|keylen
)paren
suffix:semicolon
id|eq
op_assign
id|befs_compare_strings
c_func
(paren
id|thiskey
comma
id|keylen
comma
id|findkey
comma
id|findkey_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eq
OL
l_int|0
)paren
(brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_find_key() %s not found&quot;
comma
id|findkey
)paren
suffix:semicolon
r_return
id|BEFS_BT_NOT_FOUND
suffix:semicolon
)brace
id|valarray
op_assign
id|befs_bt_valarray
c_func
(paren
id|node
)paren
suffix:semicolon
multiline_comment|/* simple binary search */
id|first
op_assign
l_int|0
suffix:semicolon
id|mid
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|last
op_ge
id|first
)paren
(brace
id|mid
op_assign
(paren
id|last
op_plus
id|first
)paren
op_div
l_int|2
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;first: %d, last: %d, mid: %d&quot;
comma
id|first
comma
id|last
comma
id|mid
)paren
suffix:semicolon
id|thiskey
op_assign
id|befs_bt_get_key
c_func
(paren
id|sb
comma
id|node
comma
id|mid
comma
op_amp
id|keylen
)paren
suffix:semicolon
id|eq
op_assign
id|befs_compare_strings
c_func
(paren
id|thiskey
comma
id|keylen
comma
id|findkey
comma
id|findkey_len
)paren
suffix:semicolon
op_star
id|value
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|valarray
(braket
id|mid
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eq
op_eq
l_int|0
)paren
(brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_find_key() found %s at %d&quot;
comma
id|thiskey
comma
id|mid
)paren
suffix:semicolon
r_return
id|BEFS_BT_MATCH
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eq
OG
l_int|0
)paren
id|last
op_assign
id|mid
op_minus
l_int|1
suffix:semicolon
r_else
id|first
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eq
OL
l_int|0
)paren
op_star
id|value
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|valarray
(braket
id|mid
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_find_key() found %s at %d&quot;
comma
id|thiskey
comma
id|mid
)paren
suffix:semicolon
r_return
id|BEFS_BT_PARMATCH
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_btree_read - Traverse leafnodes of a btree&n; * @sb: Filesystem superblock&n; * @ds: Datastream containing btree&n; * @key_no: Key number (alphabetical order) of key to read&n; * @bufsize: Size of the buffer to return key in&n; * @keybuf: Pointer to a buffer to put the key in&n; * @keysize: Length of the returned key&n; * @value: Value stored with the returned key&n; *&n; * Heres how it works: Key_no is the index of the key/value pair to &n; * retun in keybuf/value.&n; * Bufsize is the size of keybuf (BEFS_NAME_LEN+1 is a good size). Keysize is &n; * the number of charecters in the key (just a convience).&n; *&n; * Algorithm:&n; *   Get the first leafnode of the tree. See if the requested key is in that&n; *   node. If not, follow the node-&gt;right link to the next leafnode. Repeat &n; *   until the (key_no)th key is found or the tree is out of keys.&n; */
r_int
DECL|function|befs_btree_read
id|befs_btree_read
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|loff_t
id|key_no
comma
r_int
id|bufsize
comma
r_char
op_star
id|keybuf
comma
r_int
op_star
id|keysize
comma
id|befs_off_t
op_star
id|value
)paren
(brace
id|befs_btree_node
op_star
id|this_node
suffix:semicolon
id|befs_btree_super
id|bt_super
suffix:semicolon
id|befs_off_t
id|node_off
op_assign
l_int|0
suffix:semicolon
r_int
id|cur_key
suffix:semicolon
id|befs_off_t
op_star
id|valarray
suffix:semicolon
r_char
op_star
id|keystart
suffix:semicolon
id|u16
id|keylen
suffix:semicolon
r_int
id|res
suffix:semicolon
id|uint
id|key_sum
op_assign
l_int|0
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_btree_read()&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|befs_bt_read_super
c_func
(paren
id|sb
comma
id|ds
comma
op_amp
id|bt_super
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_read() failed to read index superblock&quot;
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|this_node
op_assign
(paren
id|befs_btree_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|befs_btree_node
)paren
comma
id|GFP_NOFS
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_read() failed to allocate %u &quot;
l_string|&quot;bytes of memory&quot;
comma
r_sizeof
(paren
id|befs_btree_node
)paren
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|node_off
op_assign
id|bt_super.root_node_ptr
suffix:semicolon
id|this_node-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* seeks down to first leafnode, reads it into this_node */
id|res
op_assign
id|befs_btree_seekleaf
c_func
(paren
id|sb
comma
id|ds
comma
op_amp
id|bt_super
comma
id|this_node
comma
op_amp
id|node_off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
id|BEFS_BT_EMPTY
)paren
(brace
id|brelse
c_func
(paren
id|this_node-&gt;bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this_node
)paren
suffix:semicolon
op_star
id|value
op_assign
l_int|0
suffix:semicolon
op_star
id|keysize
op_assign
l_int|0
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_read() Tree is EMPTY&quot;
)paren
suffix:semicolon
r_return
id|BEFS_BT_EMPTY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res
op_eq
id|BEFS_ERR
)paren
(brace
r_goto
id|error_alloc
suffix:semicolon
)brace
multiline_comment|/* find the leaf node containing the key_no key */
r_while
c_loop
(paren
id|key_sum
op_plus
id|this_node-&gt;head.all_key_count
op_le
id|key_no
)paren
(brace
multiline_comment|/* no more nodes to look in: key_no is too large */
r_if
c_cond
(paren
id|this_node-&gt;head.right
op_eq
id|befs_bt_inval
)paren
(brace
op_star
id|keysize
op_assign
l_int|0
suffix:semicolon
op_star
id|value
op_assign
l_int|0
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_read() END of keys at %Lu&quot;
comma
id|key_sum
op_plus
id|this_node-&gt;head.all_key_count
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|this_node-&gt;bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this_node
)paren
suffix:semicolon
r_return
id|BEFS_BT_END
suffix:semicolon
)brace
id|key_sum
op_add_assign
id|this_node-&gt;head.all_key_count
suffix:semicolon
id|node_off
op_assign
id|this_node-&gt;head.right
suffix:semicolon
r_if
c_cond
(paren
id|befs_bt_read_node
c_func
(paren
id|sb
comma
id|ds
comma
id|this_node
comma
id|node_off
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_read() failed to read &quot;
l_string|&quot;node at %Lu&quot;
comma
id|node_off
)paren
suffix:semicolon
r_goto
id|error_alloc
suffix:semicolon
)brace
)brace
multiline_comment|/* how many keys into this_node is key_no */
id|cur_key
op_assign
id|key_no
op_minus
id|key_sum
suffix:semicolon
multiline_comment|/* get pointers to datastructures within the node body */
id|valarray
op_assign
id|befs_bt_valarray
c_func
(paren
id|this_node
)paren
suffix:semicolon
id|keystart
op_assign
id|befs_bt_get_key
c_func
(paren
id|sb
comma
id|this_node
comma
id|cur_key
comma
op_amp
id|keylen
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;Read [%Lu,%d]: keysize %d&quot;
comma
id|node_off
comma
id|cur_key
comma
id|keylen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufsize
OL
id|keylen
op_plus
l_int|1
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_read() keybuf too small (%u) &quot;
l_string|&quot;for key of size %d&quot;
comma
id|bufsize
comma
id|keylen
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|this_node-&gt;bh
)paren
suffix:semicolon
r_goto
id|error_alloc
suffix:semicolon
)brace
suffix:semicolon
id|strncpy
c_func
(paren
id|keybuf
comma
id|keystart
comma
id|keylen
)paren
suffix:semicolon
op_star
id|value
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|valarray
(braket
id|cur_key
)braket
)paren
suffix:semicolon
op_star
id|keysize
op_assign
id|keylen
suffix:semicolon
id|keybuf
(braket
id|keylen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;Read [%Lu,%d]: Key &bslash;&quot;%.*s&bslash;&quot;, Value %Lu&quot;
comma
id|node_off
comma
id|cur_key
comma
id|keylen
comma
id|keybuf
comma
op_star
id|value
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|this_node-&gt;bh
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this_node
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_read()&quot;
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
id|error_alloc
suffix:colon
id|kfree
c_func
(paren
id|this_node
)paren
suffix:semicolon
id|error
suffix:colon
op_star
id|keysize
op_assign
l_int|0
suffix:semicolon
op_star
id|value
op_assign
l_int|0
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_read() ERROR&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_btree_seekleaf - Find the first leafnode in the btree&n; * @sb: Filesystem superblock&n; * @ds: Datastream containing btree&n; * @bt_super: Pointer to the uperblock of the btree&n; * @this_node: Buffer to return the leafnode in&n; * @node_off: Pointer to offset of current node within datastream. Modified&n; * &t;&t;by the function.&n; *&n; *&n; * Helper function for btree traverse. Moves the current position to the &n; * start of the first leaf node.&n; *&n; * Also checks for an empty tree. If there are no keys, returns BEFS_BT_EMPTY.&n; */
r_static
r_int
DECL|function|befs_btree_seekleaf
id|befs_btree_seekleaf
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|befs_btree_super
op_star
id|bt_super
comma
id|befs_btree_node
op_star
id|this_node
comma
id|befs_off_t
op_star
id|node_off
)paren
(brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_btree_seekleaf()&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|befs_bt_read_node
c_func
(paren
id|sb
comma
id|ds
comma
id|this_node
comma
op_star
id|node_off
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_seekleaf() failed to read &quot;
l_string|&quot;node at %Lu&quot;
comma
op_star
id|node_off
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;Seekleaf to root node %Lu&quot;
comma
op_star
id|node_off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_node-&gt;head.all_key_count
op_eq
l_int|0
op_logical_and
id|befs_leafnode
c_func
(paren
id|this_node
)paren
)paren
(brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_seekleaf() Tree is EMPTY&quot;
)paren
suffix:semicolon
r_return
id|BEFS_BT_EMPTY
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|befs_leafnode
c_func
(paren
id|this_node
)paren
)paren
(brace
r_if
c_cond
(paren
id|this_node-&gt;head.all_key_count
op_eq
l_int|0
)paren
(brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_seekleaf() encountered &quot;
l_string|&quot;an empty interior node: %Lu. Using Overflow &quot;
l_string|&quot;node: %Lu&quot;
comma
op_star
id|node_off
comma
id|this_node-&gt;head.overflow
)paren
suffix:semicolon
op_star
id|node_off
op_assign
id|this_node-&gt;head.overflow
suffix:semicolon
)brace
r_else
(brace
id|befs_off_t
op_star
id|valarray
op_assign
id|befs_bt_valarray
c_func
(paren
id|this_node
)paren
suffix:semicolon
op_star
id|node_off
op_assign
id|fs64_to_cpu
c_func
(paren
id|sb
comma
id|valarray
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|befs_bt_read_node
c_func
(paren
id|sb
comma
id|ds
comma
id|this_node
comma
op_star
id|node_off
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_btree_seekleaf() failed to read &quot;
l_string|&quot;node at %Lu&quot;
comma
op_star
id|node_off
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;Seekleaf to child node %Lu&quot;
comma
op_star
id|node_off
)paren
suffix:semicolon
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;Node %Lu is a leaf node&quot;
comma
op_star
id|node_off
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
id|error
suffix:colon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_btree_seekleaf() ERROR&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_leafnode - Determine if the btree node is a leaf node or an &n; * interior node&n; * @node: Pointer to node structure to test&n; * &n; * Return 1 if leaf, 0 if interior&n; */
r_static
r_int
DECL|function|befs_leafnode
id|befs_leafnode
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
(brace
multiline_comment|/* all interior nodes (and only interior nodes) have an overflow node */
r_if
c_cond
(paren
id|node-&gt;head.overflow
op_eq
id|befs_bt_inval
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_bt_keylen_index - Finds start of keylen index in a node&n; * @node: Pointer to the node structure to find the keylen index within&n; *&n; * Returns a pointer to the start of the key length index array&n; * of the B+tree node *@node&n; *&n; * &quot;The length of all the keys in the node is added to the size of the&n; * header and then rounded up to a multiple of four to get the begining&n; * of the key length index&quot; (p.88, practical filesystem design).&n; *&n; * Exept that rounding up to 8 works, and rounding up to 4 doesn&squot;t.&n; */
r_static
id|u16
op_star
DECL|function|befs_bt_keylen_index
id|befs_bt_keylen_index
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
(brace
r_const
r_int
id|keylen_align
op_assign
l_int|8
suffix:semicolon
r_int
r_int
r_int
id|off
op_assign
(paren
r_sizeof
(paren
id|befs_btree_nodehead
)paren
op_plus
id|node-&gt;head.all_key_length
)paren
suffix:semicolon
id|ulong
id|tmp
op_assign
id|off
op_mod
id|keylen_align
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|off
op_add_assign
id|keylen_align
op_minus
id|tmp
suffix:semicolon
r_return
(paren
id|u16
op_star
)paren
(paren
(paren
r_void
op_star
)paren
id|node-&gt;od_node
op_plus
id|off
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_bt_valarray - Finds the start of value array in a node&n; * @node: Pointer to the node structure to find the value array within&n; *&n; * Returns a pointer to the start of the value array&n; * of the node pointed to by the node header&n; */
r_static
id|befs_off_t
op_star
DECL|function|befs_bt_valarray
id|befs_bt_valarray
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
(brace
r_void
op_star
id|keylen_index_start
op_assign
(paren
r_void
op_star
)paren
id|befs_bt_keylen_index
c_func
(paren
id|node
)paren
suffix:semicolon
r_int
id|keylen_index_size
op_assign
id|node-&gt;head.all_key_count
op_star
r_sizeof
(paren
id|u16
)paren
suffix:semicolon
r_return
(paren
id|befs_off_t
op_star
)paren
(paren
id|keylen_index_start
op_plus
id|keylen_index_size
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_bt_keydata - Finds start of keydata array in a node&n; * @node: Pointer to the node structure to find the keydata array within&n; *&n; * Returns a pointer to the start of the keydata array&n; * of the node pointed to by the node header &n; */
r_static
r_char
op_star
DECL|function|befs_bt_keydata
id|befs_bt_keydata
c_func
(paren
id|befs_btree_node
op_star
id|node
)paren
(brace
r_return
(paren
r_char
op_star
)paren
(paren
(paren
r_void
op_star
)paren
id|node-&gt;od_node
op_plus
r_sizeof
(paren
id|befs_btree_nodehead
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_bt_get_key - returns a pointer to the start of a key&n; * @sb: filesystem superblock&n; * @node: node in which to look for the key&n; * @index: the index of the key to get&n; * @keylen: modified to be the length of the key at @index&n; *&n; * Returns a valid pointer into @node on success.&n; * Returns NULL on failure (bad input) and sets *@keylen = 0&n; */
r_static
r_char
op_star
DECL|function|befs_bt_get_key
id|befs_bt_get_key
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_btree_node
op_star
id|node
comma
r_int
id|index
comma
id|u16
op_star
id|keylen
)paren
(brace
r_int
id|prev_key_end
suffix:semicolon
r_char
op_star
id|keystart
suffix:semicolon
id|u16
op_star
id|keylen_index
suffix:semicolon
r_if
c_cond
(paren
id|index
template_param
id|node-&gt;head.all_key_count
)paren
(brace
op_star
id|keylen
op_assign
l_int|0
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|keystart
op_assign
id|befs_bt_keydata
c_func
(paren
id|node
)paren
suffix:semicolon
id|keylen_index
op_assign
id|befs_bt_keylen_index
c_func
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
l_int|0
)paren
id|prev_key_end
op_assign
l_int|0
suffix:semicolon
r_else
id|prev_key_end
op_assign
id|fs16_to_cpu
c_func
(paren
id|sb
comma
id|keylen_index
(braket
id|index
op_minus
l_int|1
)braket
)paren
suffix:semicolon
op_star
id|keylen
op_assign
id|fs16_to_cpu
c_func
(paren
id|sb
comma
id|keylen_index
(braket
id|index
)braket
)paren
op_minus
id|prev_key_end
suffix:semicolon
r_return
id|keystart
op_plus
id|prev_key_end
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_compare_strings - compare two strings&n; * @key1: pointer to the first key to be compared &n; * @keylen1: length in bytes of key1&n; * @key2: pointer to the second key to be compared&n; * @kelen2: lenght in bytes of key2&n; *&n; * Returns 0 if @key1 and @key2 are equal.&n; * Returns &gt;0 if @key1 is greater.&n; * Returns &lt;0 if @key2 is greater..&n; */
r_static
r_int
DECL|function|befs_compare_strings
id|befs_compare_strings
c_func
(paren
r_const
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
(brace
r_int
id|len
op_assign
id|min_t
c_func
(paren
r_int
comma
id|keylen1
comma
id|keylen2
)paren
suffix:semicolon
r_int
id|result
op_assign
id|strncmp
c_func
(paren
id|key1
comma
id|key2
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
id|result
op_assign
id|keylen1
op_minus
id|keylen2
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* These will be used for non-string keyed btrees */
macro_line|#if 0
r_static
r_int
id|btree_compare_int32
c_func
(paren
id|cont
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
(brace
r_return
op_star
(paren
r_int32
op_star
)paren
id|key1
op_minus
op_star
(paren
r_int32
op_star
)paren
id|key2
suffix:semicolon
)brace
r_static
r_int
id|btree_compare_uint32
c_func
(paren
id|cont
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|u_int32_t
op_star
)paren
id|key1
op_eq
op_star
(paren
id|u_int32_t
op_star
)paren
id|key2
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
(paren
id|u_int32_t
op_star
)paren
id|key1
OG
op_star
(paren
id|u_int32_t
op_star
)paren
id|key2
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|btree_compare_int64
c_func
(paren
id|cont
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
r_int64
op_star
)paren
id|key1
op_eq
op_star
(paren
r_int64
op_star
)paren
id|key2
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
(paren
r_int64
op_star
)paren
id|key1
OG
op_star
(paren
r_int64
op_star
)paren
id|key2
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|btree_compare_uint64
c_func
(paren
id|cont
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|u_int64_t
op_star
)paren
id|key1
op_eq
op_star
(paren
id|u_int64_t
op_star
)paren
id|key2
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
(paren
id|u_int64_t
op_star
)paren
id|key1
OG
op_star
(paren
id|u_int64_t
op_star
)paren
id|key2
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|btree_compare_float
c_func
(paren
id|cont
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
(brace
r_float
id|result
op_assign
op_star
(paren
r_float
op_star
)paren
id|key1
op_minus
op_star
(paren
r_float
op_star
)paren
id|key2
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_float|0.0f
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|result
OL
l_float|0.0f
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|btree_compare_double
c_func
(paren
id|cont
r_void
op_star
id|key1
comma
r_int
id|keylen1
comma
r_const
r_void
op_star
id|key2
comma
r_int
id|keylen2
)paren
(brace
r_float
id|result
op_assign
op_star
(paren
r_float
op_star
)paren
id|key1
op_minus
op_star
(paren
r_float
op_star
)paren
id|key2
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_float|0.0
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|result
OL
l_float|0.0
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;
singleline_comment|//0
eof
