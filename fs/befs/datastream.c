multiline_comment|/*&n; * linux/fs/befs/datastream.c&n; *&n; * Copyright (C) 2001 Will Dyson &lt;will_dyson@pobox.com&gt;&n; *&n; * Based on portions of file.c by Makoto Kato &lt;m_kato@ga2.so-net.ne.jp&gt;&n; *&n; * Many thanks to Dominic Giampaolo, author of &quot;Practical File System&n; * Design with the Be File System&quot;, for such a helpful book.&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &quot;befs.h&quot;
macro_line|#include &quot;datastream.h&quot;
macro_line|#include &quot;io.h&quot;
macro_line|#include &quot;endian.h&quot;
DECL|variable|BAD_IADDR
r_const
id|befs_inode_addr
id|BAD_IADDR
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_static
r_int
id|befs_find_brun_direct
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|data
comma
id|befs_blocknr_t
id|blockno
comma
id|befs_block_run
op_star
id|run
)paren
suffix:semicolon
r_static
r_int
id|befs_find_brun_indirect
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|data
comma
id|befs_blocknr_t
id|blockno
comma
id|befs_block_run
op_star
id|run
)paren
suffix:semicolon
r_static
r_int
id|befs_find_brun_dblindirect
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|data
comma
id|befs_blocknr_t
id|blockno
comma
id|befs_block_run
op_star
id|run
)paren
suffix:semicolon
multiline_comment|/**&n; * befs_read_datastream - get buffer_head containing data, starting from pos.&n; * @sb: Filesystem superblock&n; * @ds: datastrem to find data with&n; * @pos: start of data&n; * @off: offset of data in buffer_head-&gt;b_data&n; *&n; * Returns pointer to buffer_head containing data starting with offset @off,&n; * if you don&squot;t need to know offset just set @off = NULL.&n; */
r_struct
id|buffer_head
op_star
DECL|function|befs_read_datastream
id|befs_read_datastream
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
id|befs_off_t
id|pos
comma
id|uint
op_star
id|off
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
id|befs_block_run
id|run
suffix:semicolon
id|befs_blocknr_t
id|block
suffix:semicolon
multiline_comment|/* block coresponding to pos */
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_read_datastream() %Lu&quot;
comma
id|pos
)paren
suffix:semicolon
id|block
op_assign
id|pos
op_rshift
id|BEFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|block_shift
suffix:semicolon
r_if
c_cond
(paren
id|off
)paren
op_star
id|off
op_assign
id|pos
op_minus
(paren
id|block
op_lshift
id|BEFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|block_shift
)paren
suffix:semicolon
r_if
c_cond
(paren
id|befs_fblock2brun
c_func
(paren
id|sb
comma
id|ds
comma
id|block
comma
op_amp
id|run
)paren
op_ne
id|BEFS_OK
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;BeFS: Error finding disk addr of block %lu&quot;
comma
id|block
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_read_datastream() ERROR&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bh
op_assign
id|befs_bread_iaddr
c_func
(paren
id|sb
comma
id|run
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;BeFS: Error reading block %lu from datastream&quot;
comma
id|block
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_read_datastream() read data, starting at %Lu&quot;
comma
id|pos
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n; * Takes a file position and gives back a brun who&squot;s starting block&n; * is block number fblock of the file.&n; * &n; * Returns BEFS_OK or BEFS_ERR.&n; * &n; * Calls specialized functions for each of the three possible&n; * datastream regions.&n; *&n; * 2001-11-15 Will Dyson&n; */
r_int
DECL|function|befs_fblock2brun
id|befs_fblock2brun
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|data
comma
id|befs_blocknr_t
id|fblock
comma
id|befs_block_run
op_star
id|run
)paren
(brace
r_int
id|err
suffix:semicolon
id|befs_off_t
id|pos
op_assign
id|fblock
op_lshift
id|BEFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|block_shift
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|data-&gt;max_direct_range
)paren
(brace
id|err
op_assign
id|befs_find_brun_direct
c_func
(paren
id|sb
comma
id|data
comma
id|fblock
comma
id|run
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pos
OL
id|data-&gt;max_indirect_range
)paren
(brace
id|err
op_assign
id|befs_find_brun_indirect
c_func
(paren
id|sb
comma
id|data
comma
id|fblock
comma
id|run
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pos
OL
id|data-&gt;max_double_indirect_range
)paren
(brace
id|err
op_assign
id|befs_find_brun_dblindirect
c_func
(paren
id|sb
comma
id|data
comma
id|fblock
comma
id|run
)paren
suffix:semicolon
)brace
r_else
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_fblock2brun() was asked to find block %lu, &quot;
l_string|&quot;which is not mapped by the datastream&bslash;n&quot;
comma
id|fblock
)paren
suffix:semicolon
id|err
op_assign
id|BEFS_ERR
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_read_lsmylink - read long symlink from datastream.&n; * @sb: Filesystem superblock &n; * @ds: Datastrem to read from&n; * @buf: Buffer in wich to place long symlink data&n; * @len: Length of the long symlink in bytes&n; *&n; * Returns the number of bytes read&n; */
r_int
DECL|function|befs_read_lsymlink
id|befs_read_lsymlink
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
comma
r_void
op_star
id|buff
comma
id|befs_off_t
id|len
)paren
(brace
id|befs_off_t
id|bytes_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bytes readed */
id|u16
id|plen
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_read_lsymlink() length: %Lu&quot;
comma
id|len
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bytes_read
OL
id|len
)paren
(brace
id|bh
op_assign
id|befs_read_datastream
c_func
(paren
id|sb
comma
id|ds
comma
id|bytes_read
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;BeFS: Error reading datastream block &quot;
l_string|&quot;starting from %Lu&quot;
comma
id|bytes_read
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_read_lsymlink() ERROR&quot;
)paren
suffix:semicolon
r_return
id|bytes_read
suffix:semicolon
)brace
id|plen
op_assign
(paren
(paren
id|bytes_read
op_plus
id|BEFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|block_size
)paren
OL
id|len
)paren
ques
c_cond
id|BEFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|block_size
suffix:colon
id|len
op_minus
id|bytes_read
suffix:semicolon
id|memcpy
c_func
(paren
id|buff
op_plus
id|bytes_read
comma
id|bh-&gt;b_data
comma
id|plen
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bytes_read
op_add_assign
id|plen
suffix:semicolon
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_read_lsymlink() read %u bytes&quot;
comma
id|bytes_read
)paren
suffix:semicolon
r_return
id|bytes_read
suffix:semicolon
)brace
multiline_comment|/**&n; * befs_count_blocks - blocks used by a file&n; * @sb: Filesystem superblock&n; * @ds: Datastream of the file&n; *&n; * Counts the number of fs blocks that the file represented by&n; * inode occupies on the filesystem, counting both regular file&n; * data and filesystem metadata (and eventually attribute data&n; * when we support attributes)&n;*/
id|befs_blocknr_t
DECL|function|befs_count_blocks
id|befs_count_blocks
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|ds
)paren
(brace
id|befs_blocknr_t
id|blocks
suffix:semicolon
id|befs_blocknr_t
id|datablocks
suffix:semicolon
multiline_comment|/* File data blocks */
id|befs_blocknr_t
id|metablocks
suffix:semicolon
multiline_comment|/* FS metadata blocks */
id|befs_sb_info
op_star
id|befs_sb
op_assign
id|BEFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_count_blocks()&quot;
)paren
suffix:semicolon
id|datablocks
op_assign
id|ds-&gt;size
op_rshift
id|befs_sb-&gt;block_shift
suffix:semicolon
r_if
c_cond
(paren
id|ds-&gt;size
op_amp
(paren
id|befs_sb-&gt;block_size
op_minus
l_int|1
)paren
)paren
id|datablocks
op_add_assign
l_int|1
suffix:semicolon
id|metablocks
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Start with 1 block for inode */
multiline_comment|/* Size of indirect block */
r_if
c_cond
(paren
id|ds-&gt;size
OG
id|ds-&gt;max_direct_range
)paren
id|metablocks
op_add_assign
id|ds-&gt;indirect.len
suffix:semicolon
multiline_comment|/*&n;&t;   Double indir block, plus all the indirect blocks it mapps&n;&t;   In the double-indirect range, all block runs of data are&n;&t;   BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know &n;&t;   how many data block runs are in the double-indirect region,&n;&t;   and from that we know how many indirect blocks it takes to&n;&t;   map them. We assume that the indirect blocks are also&n;&t;   BEFS_DBLINDIR_BRUN_LEN blocks long.&n;&t; */
r_if
c_cond
(paren
id|ds-&gt;size
OG
id|ds-&gt;max_indirect_range
op_logical_and
id|ds-&gt;max_indirect_range
op_ne
l_int|0
)paren
(brace
id|uint
id|dbl_bytes
suffix:semicolon
id|uint
id|dbl_bruns
suffix:semicolon
id|uint
id|indirblocks
suffix:semicolon
id|dbl_bytes
op_assign
id|ds-&gt;max_double_indirect_range
op_minus
id|ds-&gt;max_indirect_range
suffix:semicolon
id|dbl_bruns
op_assign
id|dbl_bytes
op_div
(paren
id|befs_sb-&gt;block_size
op_star
id|BEFS_DBLINDIR_BRUN_LEN
)paren
suffix:semicolon
id|indirblocks
op_assign
id|dbl_bruns
op_div
id|befs_iaddrs_per_block
c_func
(paren
id|sb
)paren
suffix:semicolon
id|metablocks
op_add_assign
id|ds-&gt;double_indirect.len
suffix:semicolon
id|metablocks
op_add_assign
id|indirblocks
suffix:semicolon
)brace
id|blocks
op_assign
id|datablocks
op_plus
id|metablocks
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_count_blocks() %u blocks&quot;
comma
id|blocks
)paren
suffix:semicolon
r_return
id|blocks
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Finds the block run that starts at file block number blockno&n;&t;in the file represented by the datastream data, if that &n;&t;blockno is in the direct region of the datastream.&n;&t;&n;&t;sb: the superblock&n;&t;data: the datastream&n;&t;blockno: the blocknumber to find&n;&t;run: The found run is passed back through this pointer&n;&t;&n;&t;Return value is BEFS_OK if the blockrun is found, BEFS_ERR&n;&t;otherwise.&n;&t;&n;&t;Algorithm:&n;&t;Linear search. Checks each element of array[] to see if it&n;&t;contains the blockno-th filesystem block. This is necessary&n;&t;because the block runs map variable amounts of data. Simply&n;&t;keeps a count of the number of blocks searched so far (sum),&n;&t;incrementing this by the length of each block run as we come&n;&t;across it. Adds sum to *count before returning (this is so&n;&t;you can search multiple arrays that are logicaly one array,&n;&t;as in the indirect region code).&n;&t;&n;&t;When/if blockno is found, if blockno is inside of a block &n;&t;run as stored on disk, we offset the start and lenght members &n;&t;of the block run, so that blockno is the start and len is&n;&t;still valid (the run ends in the same place).&n;&t;&n;&t;2001-11-15 Will Dyson&n;*/
r_static
r_int
DECL|function|befs_find_brun_direct
id|befs_find_brun_direct
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|data
comma
id|befs_blocknr_t
id|blockno
comma
id|befs_block_run
op_star
id|run
)paren
(brace
r_int
id|i
suffix:semicolon
id|befs_block_run
op_star
id|array
op_assign
id|data-&gt;direct
suffix:semicolon
id|befs_blocknr_t
id|sum
suffix:semicolon
id|befs_blocknr_t
id|max_block
op_assign
id|data-&gt;max_direct_range
op_rshift
id|BEFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|block_shift
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_find_brun_direct(), find %lu&quot;
comma
id|blockno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blockno
OG
id|max_block
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_find_brun_direct() passed block outside of&quot;
l_string|&quot;direct region&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sum
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BEFS_NUM_DIRECT_BLOCKS
suffix:semicolon
id|sum
op_add_assign
id|array
(braket
id|i
)braket
dot
id|len
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blockno
op_ge
id|sum
op_logical_and
id|blockno
OL
id|sum
op_plus
(paren
id|array
(braket
id|i
)braket
dot
id|len
)paren
)paren
(brace
r_int
id|offset
op_assign
id|blockno
op_minus
id|sum
suffix:semicolon
id|run-&gt;allocation_group
op_assign
id|array
(braket
id|i
)braket
dot
id|allocation_group
suffix:semicolon
id|run-&gt;start
op_assign
id|array
(braket
id|i
)braket
dot
id|start
op_plus
id|offset
suffix:semicolon
id|run-&gt;len
op_assign
id|array
(braket
id|i
)braket
dot
id|len
op_minus
id|offset
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_find_brun_direct(), &quot;
l_string|&quot;found %lu at direct[%d]&quot;
comma
id|blockno
comma
id|i
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
)brace
)brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_find_brun_direct() ERROR&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Finds the block run that starts at file block number blockno&n;&t;in the file represented by the datastream data, if that &n;&t;blockno is in the indirect region of the datastream.&n;&t;&n;&t;sb: the superblock&n;&t;data: the datastream&n;&t;blockno: the blocknumber to find&n;&t;run: The found run is passed back through this pointer&n;&t;&n;&t;Return value is BEFS_OK if the blockrun is found, BEFS_ERR&n;&t;otherwise.&n;&t;&n;&t;Algorithm:&n;&t;For each block in the indirect run of the datastream, read&n;&t;it in and search through it for&t;search_blk.&n;&t;&n;&t;XXX:&n;&t;Really should check to make sure blockno is inside indirect&n;&t;region.&n;&t;&n;&t;2001-11-15 Will Dyson&n;*/
r_static
r_int
DECL|function|befs_find_brun_indirect
id|befs_find_brun_indirect
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|data
comma
id|befs_blocknr_t
id|blockno
comma
id|befs_block_run
op_star
id|run
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|befs_blocknr_t
id|sum
op_assign
l_int|0
suffix:semicolon
id|befs_blocknr_t
id|indir_start_blk
suffix:semicolon
id|befs_blocknr_t
id|search_blk
suffix:semicolon
r_struct
id|buffer_head
op_star
id|indirblock
suffix:semicolon
id|befs_block_run
op_star
id|array
suffix:semicolon
id|befs_block_run
id|indirect
op_assign
id|data-&gt;indirect
suffix:semicolon
id|befs_blocknr_t
id|indirblockno
op_assign
id|iaddr2blockno
c_func
(paren
id|sb
comma
op_amp
id|indirect
)paren
suffix:semicolon
r_int
id|arraylen
op_assign
id|befs_iaddrs_per_block
c_func
(paren
id|sb
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_find_brun_indirect(), find %lu&quot;
comma
id|blockno
)paren
suffix:semicolon
id|indir_start_blk
op_assign
id|data-&gt;max_direct_range
op_rshift
id|BEFS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|block_shift
suffix:semicolon
id|search_blk
op_assign
id|blockno
op_minus
id|indir_start_blk
suffix:semicolon
multiline_comment|/* Examine blocks of the indirect run one at a time */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|indirect.len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|indirblock
op_assign
id|befs_bread
c_func
(paren
id|sb
comma
id|indirblockno
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|indirblock
op_eq
l_int|NULL
)paren
(brace
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_find_brun_indirect() failed to &quot;
l_string|&quot;read disk block %lu from the indirect brun&quot;
comma
id|indirblockno
op_plus
id|i
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
id|array
op_assign
(paren
id|befs_block_run
op_star
)paren
id|indirblock-&gt;b_data
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|arraylen
suffix:semicolon
op_increment
id|j
)paren
(brace
r_int
id|len
op_assign
id|fs16_to_cpu
c_func
(paren
id|sb
comma
id|array
(braket
id|j
)braket
dot
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|search_blk
op_ge
id|sum
op_logical_and
id|search_blk
OL
id|sum
op_plus
id|len
)paren
(brace
r_int
id|offset
op_assign
id|search_blk
op_minus
id|sum
suffix:semicolon
id|run-&gt;allocation_group
op_assign
id|fs32_to_cpu
c_func
(paren
id|sb
comma
id|array
(braket
id|j
)braket
dot
id|allocation_group
)paren
suffix:semicolon
id|run-&gt;start
op_assign
id|fs16_to_cpu
c_func
(paren
id|sb
comma
id|array
(braket
id|j
)braket
dot
id|start
)paren
op_plus
id|offset
suffix:semicolon
id|run-&gt;len
op_assign
id|fs16_to_cpu
c_func
(paren
id|sb
comma
id|array
(braket
id|j
)braket
dot
id|len
)paren
op_minus
id|offset
suffix:semicolon
id|brelse
c_func
(paren
id|indirblock
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_find_brun_indirect() found &quot;
l_string|&quot;file block %lu at indirect[%d]&quot;
comma
id|blockno
comma
id|j
op_plus
(paren
id|i
op_star
id|arraylen
)paren
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
)brace
id|sum
op_add_assign
id|len
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|indirblock
)paren
suffix:semicolon
)brace
multiline_comment|/* Only fallthrough is an error */
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;BeFS: befs_find_brun_indirect() failed to find &quot;
l_string|&quot;file block %lu&quot;
comma
id|blockno
)paren
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;&lt;--- befs_find_brun_indirect() ERROR&quot;
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Finds the block run that starts at file block number blockno&n;&t;in the file represented by the datastream data, if that &n;&t;blockno is in the double-indirect region of the datastream.&n;&t;&n;&t;sb: the superblock&n;&t;data: the datastream&n;&t;blockno: the blocknumber to find&n;&t;run: The found run is passed back through this pointer&n;&t;&n;&t;Return value is BEFS_OK if the blockrun is found, BEFS_ERR&n;&t;otherwise.&n;&t;&n;&t;Algorithm:&n;&t;The block runs in the double-indirect region are different.&n;&t;They are always allocated 4 fs blocks at a time, so each&n;&t;block run maps a constant amount of file data. This means&n;&t;that we can directly calculate how many block runs into the&n;&t;double-indirect region we need to go to get to the one that&n;&t;maps a particular filesystem block.&n;&t;&n;&t;We do this in two stages. First we calculate which of the&n;&t;inode addresses in the double-indirect block will point us&n;&t;to the indirect block that contains the mapping for the data,&n;&t;then we calculate which of the inode addresses in that &n;&t;indirect block maps the data block we are after.&n;&t;&n;&t;Oh, and once we&squot;ve done that, we actually read in the blocks &n;&t;that contain the inode addresses we calculated above. Even &n;&t;though the double-indirect run may be several blocks long, &n;&t;we can calculate which of those blocks will contain the index&n;&t;we are after and only read that one. We then follow it to &n;&t;the indirect block and perform a  similar process to find&n;&t;the actual block run that maps the data block we are interested&n;&t;in.&n;&t;&n;&t;Then we offset the run as in befs_find_brun_array() and we are &n;&t;done.&n;&t;&n;&t;2001-11-15 Will Dyson&n;*/
r_static
r_int
DECL|function|befs_find_brun_dblindirect
id|befs_find_brun_dblindirect
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
id|befs_data_stream
op_star
id|data
comma
id|befs_blocknr_t
id|blockno
comma
id|befs_block_run
op_star
id|run
)paren
(brace
r_int
id|dblindir_indx
suffix:semicolon
r_int
id|indir_indx
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|dbl_which_block
suffix:semicolon
r_int
id|which_block
suffix:semicolon
r_int
id|dbl_block_indx
suffix:semicolon
r_int
id|block_indx
suffix:semicolon
id|off_t
id|dblindir_leftover
suffix:semicolon
id|befs_blocknr_t
id|blockno_at_run_start
suffix:semicolon
r_struct
id|buffer_head
op_star
id|dbl_indir_block
suffix:semicolon
r_struct
id|buffer_head
op_star
id|indir_block
suffix:semicolon
id|befs_block_run
id|indir_run
suffix:semicolon
id|befs_inode_addr
op_star
id|iaddr_array
op_assign
l_int|NULL
suffix:semicolon
id|befs_sb_info
op_star
id|befs_sb
op_assign
id|BEFS_SB
c_func
(paren
id|sb
)paren
suffix:semicolon
id|befs_blocknr_t
id|indir_start_blk
op_assign
id|data-&gt;max_indirect_range
op_rshift
id|befs_sb-&gt;block_shift
suffix:semicolon
id|off_t
id|dbl_indir_off
op_assign
id|blockno
op_minus
id|indir_start_blk
suffix:semicolon
multiline_comment|/* number of data blocks mapped by each of the iaddrs in&n;&t; * the indirect block pointed to by the double indirect block&n;&t; */
r_int
id|iblklen
op_assign
id|BEFS_DBLINDIR_BRUN_LEN
suffix:semicolon
multiline_comment|/* number of data blocks mapped by each of the iaddrs in&n;&t; * the double indirect block&n;&t; */
r_int
id|diblklen
op_assign
id|iblklen
op_star
id|befs_iaddrs_per_block
c_func
(paren
id|sb
)paren
op_star
id|BEFS_DBLINDIR_BRUN_LEN
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;---&gt; befs_find_brun_dblindirect() find %lu&quot;
comma
id|blockno
)paren
suffix:semicolon
multiline_comment|/* First, discover which of the double_indir-&gt;indir blocks&n;&t; * contains pos. Then figure out how much of pos that&n;&t; * accounted for. Then discover which of the iaddrs in&n;&t; * the indirect block contains pos.&n;&t; */
id|dblindir_indx
op_assign
id|dbl_indir_off
op_div
id|diblklen
suffix:semicolon
id|dblindir_leftover
op_assign
id|dbl_indir_off
op_mod
id|diblklen
suffix:semicolon
id|indir_indx
op_assign
id|dblindir_leftover
op_div
id|diblklen
suffix:semicolon
multiline_comment|/* Read double indirect block */
id|dbl_which_block
op_assign
id|dblindir_indx
op_div
id|befs_iaddrs_per_block
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dbl_which_block
OG
id|data-&gt;double_indirect.len
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;The double-indirect index calculated by &quot;
l_string|&quot;befs_read_brun_dblindirect(), %d, is outside the range &quot;
l_string|&quot;of the double-indirect block&quot;
comma
id|dblindir_indx
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
id|dbl_indir_block
op_assign
id|befs_bread
c_func
(paren
id|sb
comma
id|iaddr2blockno
c_func
(paren
id|sb
comma
op_amp
id|data-&gt;double_indirect
)paren
op_plus
id|dbl_which_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dbl_indir_block
op_eq
l_int|NULL
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_read_brun_dblindirect() couldn&squot;t read the &quot;
l_string|&quot;double-indirect block at blockno %lu&quot;
comma
id|iaddr2blockno
c_func
(paren
id|sb
comma
op_amp
id|data-&gt;double_indirect
)paren
op_plus
id|dbl_which_block
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|dbl_indir_block
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
id|dbl_block_indx
op_assign
id|dblindir_indx
op_minus
(paren
id|dbl_which_block
op_star
id|befs_iaddrs_per_block
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
id|iaddr_array
op_assign
(paren
id|befs_inode_addr
op_star
)paren
id|dbl_indir_block-&gt;b_data
suffix:semicolon
id|indir_run
op_assign
id|fsrun_to_cpu
c_func
(paren
id|sb
comma
id|iaddr_array
(braket
id|dbl_block_indx
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|dbl_indir_block
)paren
suffix:semicolon
id|iaddr_array
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Read indirect block */
id|which_block
op_assign
id|indir_indx
op_div
id|befs_iaddrs_per_block
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|which_block
OG
id|indir_run.len
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;The indirect index calculated by &quot;
l_string|&quot;befs_read_brun_dblindirect(), %d, is outside the range &quot;
l_string|&quot;of the indirect block&quot;
comma
id|indir_indx
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
id|indir_block
op_assign
id|befs_bread
c_func
(paren
id|sb
comma
id|iaddr2blockno
c_func
(paren
id|sb
comma
op_amp
id|indir_run
)paren
op_plus
id|which_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|indir_block
op_eq
l_int|NULL
)paren
(brace
id|befs_error
c_func
(paren
id|sb
comma
l_string|&quot;befs_read_brun_dblindirect() couldn&squot;t read the &quot;
l_string|&quot;indirect block at blockno %lu&quot;
comma
id|iaddr2blockno
c_func
(paren
id|sb
comma
op_amp
id|indir_run
)paren
op_plus
id|which_block
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|indir_block
)paren
suffix:semicolon
r_return
id|BEFS_ERR
suffix:semicolon
)brace
id|block_indx
op_assign
id|indir_indx
op_minus
(paren
id|which_block
op_star
id|befs_iaddrs_per_block
c_func
(paren
id|sb
)paren
)paren
suffix:semicolon
id|iaddr_array
op_assign
(paren
id|befs_inode_addr
op_star
)paren
id|indir_block-&gt;b_data
suffix:semicolon
op_star
id|run
op_assign
id|fsrun_to_cpu
c_func
(paren
id|sb
comma
id|iaddr_array
(braket
id|block_indx
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|indir_block
)paren
suffix:semicolon
id|iaddr_array
op_assign
l_int|NULL
suffix:semicolon
id|blockno_at_run_start
op_assign
id|indir_start_blk
suffix:semicolon
id|blockno_at_run_start
op_add_assign
id|diblklen
op_star
id|dblindir_indx
suffix:semicolon
id|blockno_at_run_start
op_add_assign
id|iblklen
op_star
id|indir_indx
suffix:semicolon
id|offset
op_assign
id|blockno
op_minus
id|blockno_at_run_start
suffix:semicolon
id|run-&gt;start
op_add_assign
id|offset
suffix:semicolon
id|run-&gt;len
op_sub_assign
id|offset
suffix:semicolon
id|befs_debug
c_func
(paren
id|sb
comma
l_string|&quot;Found file block %lu in double_indirect[%d][%d],&quot;
l_string|&quot; double_indirect_leftover = %lu&quot;
comma
id|blockno
comma
id|dblindir_indx
comma
id|indir_indx
comma
id|dblindir_leftover
)paren
suffix:semicolon
r_return
id|BEFS_OK
suffix:semicolon
)brace
eof
