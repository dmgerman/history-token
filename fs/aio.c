multiline_comment|/*&n; *&t;An async IO implementation for Linux&n; *&t;Written by Benjamin LaHaise &lt;bcrl@redhat.com&gt;&n; *&n; *&t;Implements an efficient asynchronous io interface.&n; *&n; *&t;Copyright 2000, 2001, 2002 Red Hat, Inc.  All Rights Reserved.&n; *&n; *&t;See ../COPYING for licensing terms.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/aio_abi.h&gt;
singleline_comment|//#define DEBUG 1
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/iobuf.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/brlock.h&gt;
macro_line|#include &lt;linux/aio.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/brlock.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;asm/kmap_types.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#if DEBUG &gt; 1
DECL|macro|dprintk
mdefine_line|#define dprintk&t;&t;printk
macro_line|#else
DECL|macro|dprintk
mdefine_line|#define dprintk(x...)&t;do { ; } while (0)
macro_line|#endif
multiline_comment|/*------ sysctl variables----*/
DECL|variable|aio_nr
id|atomic_t
id|aio_nr
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* current system wide number of aio requests */
DECL|variable|aio_max_nr
r_int
id|aio_max_nr
op_assign
l_int|0x10000
suffix:semicolon
multiline_comment|/* system wide maximum number of aio requests */
multiline_comment|/*----end sysctl variables---*/
DECL|variable|kiocb_cachep
r_static
id|kmem_cache_t
op_star
id|kiocb_cachep
suffix:semicolon
DECL|variable|kioctx_cachep
r_static
id|kmem_cache_t
op_star
id|kioctx_cachep
suffix:semicolon
multiline_comment|/* Used for rare fput completion. */
r_static
r_void
id|aio_fput_routine
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|variable|fput_tqueue
r_static
r_struct
id|tq_struct
id|fput_tqueue
op_assign
(brace
dot
id|routine
op_assign
id|aio_fput_routine
comma
)brace
suffix:semicolon
DECL|variable|fput_lock
r_static
id|spinlock_t
id|fput_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|fput_head
id|LIST_HEAD
c_func
(paren
id|fput_head
)paren
suffix:semicolon
r_static
r_void
id|aio_kick_handler
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/* aio_setup&n; *&t;Creates the slab caches used by the aio routines, panic on&n; *&t;failure as this is done early during the boot sequence.&n; */
DECL|function|aio_setup
r_static
r_int
id|__init
id|aio_setup
c_func
(paren
r_void
)paren
(brace
id|kiocb_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;kiocb&quot;
comma
r_sizeof
(paren
r_struct
id|kiocb
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kiocb_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;unable to create kiocb cache&bslash;n&quot;
)paren
suffix:semicolon
id|kioctx_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;kioctx&quot;
comma
r_sizeof
(paren
r_struct
id|kioctx
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kioctx_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;unable to create kioctx cache&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;aio_setup: sizeof(struct page) = %d&bslash;n&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|page
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|aio_free_ring
r_static
r_void
id|aio_free_ring
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|aio_ring_info
op_star
id|info
op_assign
op_amp
id|ctx-&gt;ring_info
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;nr_pages
suffix:semicolon
id|i
op_increment
)paren
id|put_page
c_func
(paren
id|info-&gt;ring_pages
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;mmap_size
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|ctx-&gt;mm
comma
id|info-&gt;mmap_base
comma
id|info-&gt;mmap_size
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;ring_pages
op_logical_and
id|info-&gt;ring_pages
op_ne
id|info-&gt;internal_pages
)paren
id|kfree
c_func
(paren
id|info-&gt;ring_pages
)paren
suffix:semicolon
id|info-&gt;ring_pages
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;nr
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|aio_setup_ring
r_static
r_int
id|aio_setup_ring
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_struct
id|aio_ring_info
op_star
id|info
op_assign
op_amp
id|ctx-&gt;ring_info
suffix:semicolon
r_int
id|nr_events
op_assign
id|ctx-&gt;max_reqs
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|nr_pages
suffix:semicolon
multiline_comment|/* Compensate for the ring buffer&squot;s head/tail overlap entry */
id|nr_events
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* 1 is required, 2 for good luck */
id|size
op_assign
r_sizeof
(paren
r_struct
id|aio_ring
)paren
suffix:semicolon
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|io_event
)paren
op_star
id|nr_events
suffix:semicolon
id|nr_pages
op_assign
(paren
id|size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|info-&gt;nr_pages
op_assign
id|nr_pages
suffix:semicolon
id|nr_events
op_assign
(paren
id|PAGE_SIZE
op_star
id|nr_pages
op_minus
r_sizeof
(paren
r_struct
id|aio_ring
)paren
)paren
op_div
r_sizeof
(paren
r_struct
id|io_event
)paren
suffix:semicolon
id|info-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|info-&gt;ring_pages
op_assign
id|info-&gt;internal_pages
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
OG
id|AIO_RING_PAGES
)paren
(brace
id|info-&gt;ring_pages
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|nr_pages
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;ring_pages
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|info-&gt;ring_pages
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|nr_pages
)paren
suffix:semicolon
)brace
id|info-&gt;mmap_size
op_assign
id|nr_pages
op_star
id|PAGE_SIZE
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;attempting mmap of %lu bytes&bslash;n&quot;
comma
id|info-&gt;mmap_size
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|info-&gt;mmap_base
op_assign
id|do_mmap
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|info-&gt;mmap_size
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_ANON
op_or
id|MAP_PRIVATE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|info-&gt;mmap_base
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mmap err: %ld&bslash;n&quot;
comma
op_minus
id|info-&gt;mmap_base
)paren
suffix:semicolon
id|info-&gt;mmap_size
op_assign
l_int|0
suffix:semicolon
id|aio_free_ring
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;mmap address: 0x%08lx&bslash;n&quot;
comma
id|info-&gt;mmap_base
)paren
suffix:semicolon
id|info-&gt;nr_pages
op_assign
id|get_user_pages
c_func
(paren
id|current
comma
id|ctx-&gt;mm
comma
id|info-&gt;mmap_base
comma
id|info-&gt;mmap_size
comma
l_int|1
comma
l_int|0
comma
id|info-&gt;ring_pages
comma
l_int|NULL
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|info-&gt;nr_pages
op_ne
id|nr_pages
)paren
)paren
(brace
id|aio_free_ring
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|ctx-&gt;user_id
op_assign
id|info-&gt;mmap_base
suffix:semicolon
id|info-&gt;nr
op_assign
id|nr_events
suffix:semicolon
multiline_comment|/* trusted copy */
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|info-&gt;ring_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|ring-&gt;nr
op_assign
id|nr_events
suffix:semicolon
multiline_comment|/* user copy */
id|ring-&gt;id
op_assign
id|ctx-&gt;user_id
suffix:semicolon
id|ring-&gt;head
op_assign
id|ring-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|ring-&gt;magic
op_assign
id|AIO_RING_MAGIC
suffix:semicolon
id|ring-&gt;compat_features
op_assign
id|AIO_RING_COMPAT_FEATURES
suffix:semicolon
id|ring-&gt;incompat_features
op_assign
id|AIO_RING_INCOMPAT_FEATURES
suffix:semicolon
id|ring-&gt;header_length
op_assign
r_sizeof
(paren
r_struct
id|aio_ring
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_USER0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* aio_ring_event: returns a pointer to the event at the given index from&n; * kmap_atomic(, km).  Release the pointer with put_aio_ring_event();&n; */
DECL|macro|AIO_EVENTS_PER_PAGE
mdefine_line|#define AIO_EVENTS_PER_PAGE&t;(PAGE_SIZE / sizeof(struct io_event))
DECL|macro|AIO_EVENTS_FIRST_PAGE
mdefine_line|#define AIO_EVENTS_FIRST_PAGE&t;((PAGE_SIZE - sizeof(struct aio_ring)) / sizeof(struct io_event))
DECL|macro|AIO_EVENTS_OFFSET
mdefine_line|#define AIO_EVENTS_OFFSET&t;(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)
DECL|macro|aio_ring_event
mdefine_line|#define aio_ring_event(info, nr, km) ({&t;&t;&t;&t;&t;&bslash;&n;&t;unsigned pos = (nr) + AIO_EVENTS_OFFSET;&t;&t;&t;&bslash;&n;&t;struct io_event *__event;&t;&t;&t;&t;&t;&bslash;&n;&t;__event = kmap_atomic(&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;(info)-&gt;ring_pages[pos / AIO_EVENTS_PER_PAGE], km); &bslash;&n;&t;__event += pos % AIO_EVENTS_PER_PAGE;&t;&t;&t;&t;&bslash;&n;&t;__event;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|put_aio_ring_event
mdefine_line|#define put_aio_ring_event(event, km) do {&t;&bslash;&n;&t;struct io_event *__event = (event);&t;&bslash;&n;&t;(void)__event;&t;&t;&t;&t;&bslash;&n;&t;kunmap_atomic((void *)((unsigned long)__event &amp; PAGE_MASK), km); &bslash;&n;} while(0)
multiline_comment|/* ioctx_alloc&n; *&t;Allocates and initializes an ioctx.  Returns an ERR_PTR if it failed.&n; */
DECL|function|ioctx_alloc
r_static
r_struct
id|kioctx
op_star
id|ioctx_alloc
c_func
(paren
r_int
id|nr_events
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_struct
id|kioctx
op_star
id|ctx
suffix:semicolon
multiline_comment|/* Prevent overflows */
r_if
c_cond
(paren
(paren
id|nr_events
OG
(paren
l_int|0x10000000U
op_div
r_sizeof
(paren
r_struct
id|io_event
)paren
)paren
)paren
op_logical_or
(paren
id|nr_events
OG
(paren
l_int|0x10000000U
op_div
r_sizeof
(paren
r_struct
id|kiocb
)paren
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;ENOMEM: nr_events too high&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_events
OG
id|aio_max_nr
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|ctx
op_assign
id|kmem_cache_alloc
c_func
(paren
id|kioctx_cachep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ctx
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ctx
)paren
)paren
suffix:semicolon
id|ctx-&gt;max_reqs
op_assign
id|nr_events
suffix:semicolon
id|mm
op_assign
id|ctx-&gt;mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ring_info.ring_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ctx-&gt;active_reqs
)paren
suffix:semicolon
id|INIT_TQUEUE
c_func
(paren
op_amp
id|ctx-&gt;tq
comma
id|aio_kick_handler
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aio_setup_ring
c_func
(paren
id|ctx
)paren
OL
l_int|0
)paren
r_goto
id|out_freectx
suffix:semicolon
multiline_comment|/* limit the number of system wide aios */
id|atomic_add
c_func
(paren
id|ctx-&gt;max_reqs
comma
op_amp
id|aio_nr
)paren
suffix:semicolon
multiline_comment|/* undone by __put_ioctx */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|aio_nr
)paren
OG
id|aio_max_nr
)paren
)paren
r_goto
id|out_cleanup
suffix:semicolon
multiline_comment|/* now link into global list.  kludge.  FIXME */
id|write_lock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|ctx-&gt;next
op_assign
id|mm-&gt;ioctx_list
suffix:semicolon
id|mm-&gt;ioctx_list
op_assign
id|ctx
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio: allocated ioctx %p[%ld]: mm=%p mask=0x%x&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;user_id
comma
id|current-&gt;mm
comma
id|ctx-&gt;ring_info.ring-&gt;nr
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
id|out_cleanup
suffix:colon
id|atomic_sub
c_func
(paren
id|ctx-&gt;max_reqs
comma
op_amp
id|aio_nr
)paren
suffix:semicolon
multiline_comment|/* undone by __put_ioctx */
id|ctx-&gt;max_reqs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* prevent __put_ioctx from sub&squot;ing aio_nr */
id|__put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|out_freectx
suffix:colon
id|kmem_cache_free
c_func
(paren
id|kioctx_cachep
comma
id|ctx
)paren
suffix:semicolon
id|ctx
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio: error allocating ioctx %p&bslash;n&quot;
comma
id|ctx
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
)brace
multiline_comment|/* aio_cancel_all&n; *&t;Cancels all outstanding aio requests on an aio context.  Used &n; *&t;when the processes owning a context have all exited to encourage &n; *&t;the rapid destruction of the kioctx.&n; */
DECL|function|aio_cancel_all
r_static
r_void
id|aio_cancel_all
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_int
(paren
op_star
id|cancel
)paren
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|io_event
op_star
)paren
suffix:semicolon
r_struct
id|io_event
id|res
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ctx-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ctx-&gt;active_reqs
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|pos
op_assign
id|ctx-&gt;active_reqs.next
suffix:semicolon
r_struct
id|kiocb
op_star
id|iocb
op_assign
id|list_kiocb
c_func
(paren
id|pos
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|iocb-&gt;ki_list
)paren
suffix:semicolon
id|cancel
op_assign
id|iocb-&gt;ki_cancel
suffix:semicolon
r_if
c_cond
(paren
id|cancel
)paren
id|iocb-&gt;ki_users
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cancel
)paren
id|cancel
c_func
(paren
id|iocb
comma
op_amp
id|res
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
DECL|function|wait_for_all_aios
r_void
id|wait_for_all_aios
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;reqs_active
)paren
r_return
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ctx-&gt;reqs_active
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ctx-&gt;reqs_active = %d&bslash;n&quot;
comma
id|ctx-&gt;reqs_active
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/* wait_on_sync_kiocb:&n; *&t;Waits on the given sync kiocb to complete.&n; */
DECL|function|wait_on_sync_kiocb
id|ssize_t
id|wait_on_sync_kiocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_while
c_loop
(paren
id|iocb-&gt;ki_users
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iocb-&gt;ki_users
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|iocb-&gt;ki_user_data
suffix:semicolon
)brace
multiline_comment|/* exit_aio: called when the last user of mm goes away.  At this point, &n; * there is no way for any new requests to be submited or any of the &n; * io_* syscalls to be called on the context.  However, there may be &n; * outstanding requests which hold references to the context; as they &n; * go away, they will call put_ioctx and release any pinned memory&n; * associated with the request (held via struct page * references).&n; */
DECL|function|exit_aio
r_void
id|exit_aio
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|mm-&gt;ioctx_list
suffix:semicolon
id|mm-&gt;ioctx_list
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|ctx
)paren
(brace
r_struct
id|kioctx
op_star
id|next
op_assign
id|ctx-&gt;next
suffix:semicolon
id|ctx-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|aio_cancel_all
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|wait_for_all_aios
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_ne
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;users
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;exit_aio:ioctx still alive: %d %d %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;users
)paren
comma
id|ctx-&gt;dead
comma
id|ctx-&gt;reqs_active
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* __put_ioctx&n; *&t;Called when the last user of an aio context has gone away,&n; *&t;and the struct needs to be freed.&n; */
DECL|function|__put_ioctx
r_void
id|__put_ioctx
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_int
id|nr_events
op_assign
id|ctx-&gt;max_reqs
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;reqs_active
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|aio_free_ring
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|mmdrop
c_func
(paren
id|ctx-&gt;mm
)paren
suffix:semicolon
id|ctx-&gt;mm
op_assign
l_int|NULL
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;__put_ioctx: freeing %p&bslash;n&quot;
comma
id|ctx
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|kioctx_cachep
comma
id|ctx
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|nr_events
comma
op_amp
id|aio_nr
)paren
suffix:semicolon
)brace
multiline_comment|/* aio_get_req&n; *&t;Allocate a slot for an aio request.  Increments the users count&n; * of the kioctx so that the kioctx stays around until all requests are&n; * complete.  Returns -EAGAIN if no requests are free.&n; */
r_static
r_struct
id|kiocb
op_star
id|FASTCALL
c_func
(paren
id|__aio_get_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
)paren
suffix:semicolon
DECL|function|__aio_get_req
r_static
r_struct
id|kiocb
op_star
id|__aio_get_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|kiocb
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_int
id|okay
op_assign
l_int|0
suffix:semicolon
id|req
op_assign
id|kmem_cache_alloc
c_func
(paren
id|kiocb_cachep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|req
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|req-&gt;ki_flags
op_assign
l_int|1
op_lshift
id|KIF_LOCKED
suffix:semicolon
id|req-&gt;ki_users
op_assign
l_int|1
suffix:semicolon
id|req-&gt;ki_key
op_assign
l_int|0
suffix:semicolon
id|req-&gt;ki_ctx
op_assign
id|ctx
suffix:semicolon
id|req-&gt;ki_cancel
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_retry
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_user_obj
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check if the completion queue has enough free space to&n;&t; * accept an event from this io.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|ctx-&gt;ring_info.ring_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;reqs_active
OL
id|aio_ring_avail
c_func
(paren
op_amp
id|ctx-&gt;ring_info
comma
id|ring
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|req-&gt;ki_list
comma
op_amp
id|ctx-&gt;active_reqs
)paren
suffix:semicolon
id|get_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;reqs_active
op_increment
suffix:semicolon
id|okay
op_assign
l_int|1
suffix:semicolon
)brace
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_USER0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|okay
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|kiocb_cachep
comma
id|req
)paren
suffix:semicolon
id|req
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|req
suffix:semicolon
)brace
DECL|function|aio_get_req
r_static
r_inline
r_struct
id|kiocb
op_star
id|aio_get_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|kiocb
op_star
id|req
suffix:semicolon
multiline_comment|/* Handle a potential starvation case -- should be exceedingly rare as &n;&t; * requests will be stuck on fput_head only if the aio_fput_routine is &n;&t; * delayed and the requests were the last user of the struct file.&n;&t; */
id|req
op_assign
id|__aio_get_req
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|NULL
op_eq
id|req
)paren
)paren
(brace
id|aio_fput_routine
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|req
op_assign
id|__aio_get_req
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
r_return
id|req
suffix:semicolon
)brace
DECL|function|really_put_req
r_static
r_inline
r_void
id|really_put_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|kiocb
op_star
id|req
)paren
(brace
id|req-&gt;ki_ctx
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_filp
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_user_obj
op_assign
l_int|NULL
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|kiocb_cachep
comma
id|req
)paren
suffix:semicolon
id|ctx-&gt;reqs_active
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx-&gt;reqs_active
op_logical_and
id|ctx-&gt;dead
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
suffix:semicolon
)brace
DECL|function|aio_fput_routine
r_static
r_void
id|aio_fput_routine
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|likely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fput_head
)paren
)paren
)paren
(brace
r_struct
id|kiocb
op_star
id|req
op_assign
id|list_kiocb
c_func
(paren
id|fput_head.next
)paren
suffix:semicolon
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|req-&gt;ki_ctx
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req-&gt;ki_list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
multiline_comment|/* Complete the fput */
id|__fput
c_func
(paren
id|req-&gt;ki_filp
)paren
suffix:semicolon
multiline_comment|/* Link the iocb into the context&squot;s free list */
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|really_put_req
c_func
(paren
id|ctx
comma
id|req
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* __aio_put_req&n; *&t;Returns true if this put was the last user of the request.&n; */
DECL|function|__aio_put_req
r_static
r_inline
r_int
id|__aio_put_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|kiocb
op_star
id|req
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aio_put(%p): f_count=%d&bslash;n&quot;
comma
id|req
comma
id|atomic_read
c_func
(paren
op_amp
id|req-&gt;ki_filp-&gt;f_count
)paren
)paren
suffix:semicolon
id|req-&gt;ki_users
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|req-&gt;ki_users
OL
l_int|0
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|req-&gt;ki_users
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req-&gt;ki_list
)paren
suffix:semicolon
multiline_comment|/* remove from active_reqs */
id|req-&gt;ki_cancel
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_retry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Must be done under the lock to serialise against cancellation.&n;&t; * Call this aio_fput as it duplicates fput via the fput_tqueue.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|req-&gt;ki_filp-&gt;f_count
)paren
)paren
)paren
(brace
id|get_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req-&gt;ki_list
comma
op_amp
id|fput_head
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
id|schedule_task
c_func
(paren
op_amp
id|fput_tqueue
)paren
suffix:semicolon
)brace
r_else
id|really_put_req
c_func
(paren
id|ctx
comma
id|req
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* aio_put_req&n; *&t;Returns true if this put was the last user of the kiocb,&n; *&t;false if the request is still in use.&n; */
DECL|function|aio_put_req
r_int
id|aio_put_req
c_func
(paren
r_struct
id|kiocb
op_star
id|req
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|req-&gt;ki_ctx
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ret
op_assign
id|__aio_put_req
c_func
(paren
id|ctx
comma
id|req
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&t;Lookup an ioctx id.  ioctx_list is lockless for reads.&n; *&t;FIXME: this is O(n) and is only suitable for development.&n; */
DECL|function|lookup_ioctx
r_static
r_inline
r_struct
id|kioctx
op_star
id|lookup_ioctx
c_func
(paren
r_int
r_int
id|ctx_id
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ioctx
op_assign
id|mm-&gt;ioctx_list
suffix:semicolon
id|ioctx
suffix:semicolon
id|ioctx
op_assign
id|ioctx-&gt;next
)paren
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ioctx-&gt;user_id
op_eq
id|ctx_id
op_logical_and
op_logical_neg
id|ioctx-&gt;dead
)paren
)paren
(brace
id|get_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
r_return
id|ioctx
suffix:semicolon
)brace
DECL|function|use_mm
r_static
r_void
id|use_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|mm_struct
op_star
id|active_mm
op_assign
id|current-&gt;active_mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
suffix:semicolon
id|current-&gt;mm
op_assign
id|mm
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_ne
id|active_mm
)paren
(brace
id|current-&gt;active_mm
op_assign
id|mm
suffix:semicolon
id|activate_mm
c_func
(paren
id|active_mm
comma
id|mm
)paren
suffix:semicolon
)brace
id|mmdrop
c_func
(paren
id|active_mm
)paren
suffix:semicolon
)brace
DECL|function|unuse_mm
r_static
r_void
id|unuse_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|current-&gt;mm
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* active_mm is still &squot;mm&squot; */
id|enter_lazy_tlb
c_func
(paren
id|mm
comma
id|current
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Run on kevent&squot;s context.  FIXME: needs to be per-cpu and warn if an&n; * operation blocks.&n; */
DECL|function|aio_kick_handler
r_static
r_void
id|aio_kick_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|data
suffix:semicolon
id|use_mm
c_func
(paren
id|ctx-&gt;mm
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ctx-&gt;run_list
)paren
)paren
(brace
r_struct
id|kiocb
op_star
id|iocb
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|iocb
op_assign
id|list_entry
c_func
(paren
id|ctx-&gt;run_list.next
comma
r_struct
id|kiocb
comma
id|ki_run_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
)paren
suffix:semicolon
id|iocb-&gt;ki_users
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|kiocbClearKicked
c_func
(paren
id|iocb
)paren
suffix:semicolon
id|ret
op_assign
id|iocb
op_member_access_from_pointer
id|ki_retry
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
id|EIOCBQUEUED
op_ne
id|ret
)paren
(brace
id|aio_complete
c_func
(paren
id|iocb
comma
id|ret
comma
l_int|0
)paren
suffix:semicolon
id|iocb
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|iocb
)paren
id|__aio_put_req
c_func
(paren
id|ctx
comma
id|iocb
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|unuse_mm
c_func
(paren
id|ctx-&gt;mm
)paren
suffix:semicolon
)brace
DECL|function|kick_iocb
r_void
id|kick_iocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|iocb-&gt;ki_ctx
suffix:semicolon
multiline_comment|/* sync iocbs are easy: they can only ever be executing from a &n;&t; * single context. */
r_if
c_cond
(paren
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
)paren
(brace
id|kiocbSetKicked
c_func
(paren
id|iocb
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|iocb-&gt;ki_user_obj
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kiocbTryKick
c_func
(paren
id|iocb
)paren
)paren
(brace
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
comma
op_amp
id|ctx-&gt;run_list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
id|schedule_task
c_func
(paren
op_amp
id|ctx-&gt;tq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* aio_complete&n; *&t;Called when the io request on the given iocb is complete.&n; *&t;Returns true if this is the last user of the request.  The &n; *&t;only other user of the request can be the cancellation code.&n; */
DECL|function|aio_complete
r_int
id|aio_complete
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_int
id|res
comma
r_int
id|res2
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|iocb-&gt;ki_ctx
suffix:semicolon
r_struct
id|aio_ring_info
op_star
id|info
suffix:semicolon
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_struct
id|io_event
op_star
id|event
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tail
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Special case handling for sync iocbs: events go directly&n;&t; * into the iocb for fast handling.  Note that this will not &n;&t; * work if we allow sync kiocbs to be cancelled. in which&n;&t; * case the usage count checks will have to move under ctx_lock&n;&t; * for all cases.&n;&t; */
r_if
c_cond
(paren
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
id|iocb-&gt;ki_user_data
op_assign
id|res
suffix:semicolon
r_if
c_cond
(paren
id|iocb-&gt;ki_users
op_eq
l_int|1
)paren
(brace
id|iocb-&gt;ki_users
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|iocb-&gt;ki_users
op_decrement
suffix:semicolon
id|ret
op_assign
(paren
l_int|0
op_eq
id|iocb-&gt;ki_users
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/* sync iocbs put the task here for us */
id|wake_up_process
c_func
(paren
id|iocb-&gt;ki_user_obj
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|info
op_assign
op_amp
id|ctx-&gt;ring_info
suffix:semicolon
multiline_comment|/* add a completion event to the ring buffer.&n;&t; * must be done holding ctx-&gt;ctx_lock to prevent&n;&t; * other code from messing with the tail&n;&t; * pointer since we might be called from irq&n;&t; * context.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|info-&gt;ring_pages
(braket
l_int|0
)braket
comma
id|KM_IRQ1
)paren
suffix:semicolon
id|tail
op_assign
id|info-&gt;tail
suffix:semicolon
id|event
op_assign
id|aio_ring_event
c_func
(paren
id|info
comma
id|tail
comma
id|KM_IRQ0
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_mod
id|info-&gt;nr
suffix:semicolon
id|event-&gt;obj
op_assign
(paren
id|u64
)paren
(paren
r_int
r_int
)paren
id|iocb-&gt;ki_user_obj
suffix:semicolon
id|event-&gt;data
op_assign
id|iocb-&gt;ki_user_data
suffix:semicolon
id|event-&gt;res
op_assign
id|res
suffix:semicolon
id|event-&gt;res2
op_assign
id|res2
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio_complete: %p[%lu]: %p: %p %Lx %lx %lx&bslash;n&quot;
comma
id|ctx
comma
id|tail
comma
id|iocb
comma
id|iocb-&gt;ki_user_obj
comma
id|iocb-&gt;ki_user_data
comma
id|res
comma
id|res2
)paren
suffix:semicolon
multiline_comment|/* after flagging the request as done, we&n;&t; * must never even look at it again&n;&t; */
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|info-&gt;tail
op_assign
id|tail
suffix:semicolon
id|ring-&gt;tail
op_assign
id|tail
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|put_aio_ring_event
c_func
(paren
id|event
comma
id|KM_IRQ0
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_IRQ1
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;added to ring %p at [%lu]&bslash;n&quot;
comma
id|iocb
comma
id|tail
)paren
suffix:semicolon
multiline_comment|/* everything turned out well, dispose of the aiocb. */
id|ret
op_assign
id|__aio_put_req
c_func
(paren
id|ctx
comma
id|iocb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* aio_read_evt&n; *&t;Pull an event off of the ioctx&squot;s event ring.  Returns the number of &n; *&t;events fetched (0 or 1 ;-)&n; *&t;FIXME: make this use cmpxchg.&n; *&t;TODO: make the ringbuffer user mmap()able (requires FIXME).&n; */
DECL|function|aio_read_evt
r_static
r_int
id|aio_read_evt
c_func
(paren
r_struct
id|kioctx
op_star
id|ioctx
comma
r_struct
id|io_event
op_star
id|ent
)paren
(brace
r_struct
id|aio_ring_info
op_star
id|info
op_assign
op_amp
id|ioctx-&gt;ring_info
suffix:semicolon
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_int
r_int
id|head
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|info-&gt;ring_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;in aio_read_evt h%lu t%lu m%lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ring-&gt;head
comma
(paren
r_int
r_int
)paren
id|ring-&gt;tail
comma
(paren
r_int
r_int
)paren
id|ring-&gt;nr
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ring-&gt;head
op_eq
id|ring-&gt;tail
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;ring_lock
)paren
suffix:semicolon
id|head
op_assign
id|ring-&gt;head
op_mod
id|info-&gt;nr
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
id|ring-&gt;tail
)paren
(brace
r_struct
id|io_event
op_star
id|evp
op_assign
id|aio_ring_event
c_func
(paren
id|info
comma
id|head
comma
id|KM_USER1
)paren
suffix:semicolon
op_star
id|ent
op_assign
op_star
id|evp
suffix:semicolon
id|head
op_assign
(paren
id|head
op_plus
l_int|1
)paren
op_mod
id|info-&gt;nr
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|ring-&gt;head
op_assign
id|head
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
id|put_aio_ring_event
c_func
(paren
id|evp
comma
id|KM_USER1
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;ring_lock
)paren
suffix:semicolon
id|out
suffix:colon
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_USER0
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;leaving aio_read_evt: %d  h%lu t%lu&bslash;n&quot;
comma
id|ret
comma
(paren
r_int
r_int
)paren
id|ring-&gt;head
comma
(paren
r_int
r_int
)paren
id|ring-&gt;tail
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|struct|timeout
r_struct
id|timeout
(brace
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|timed_out
r_int
id|timed_out
suffix:semicolon
DECL|member|p
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
)brace
suffix:semicolon
DECL|function|timeout_func
r_static
r_void
id|timeout_func
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|timeout
op_star
id|to
op_assign
(paren
r_struct
id|timeout
op_star
)paren
id|data
suffix:semicolon
id|to-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
id|wake_up_process
c_func
(paren
id|to-&gt;p
)paren
suffix:semicolon
)brace
DECL|function|init_timeout
r_static
r_inline
r_void
id|init_timeout
c_func
(paren
r_struct
id|timeout
op_star
id|to
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|to-&gt;timer
)paren
suffix:semicolon
id|to-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|to
suffix:semicolon
id|to-&gt;timer.function
op_assign
id|timeout_func
suffix:semicolon
id|to-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
id|to-&gt;p
op_assign
id|current
suffix:semicolon
)brace
DECL|function|set_timeout
r_static
r_inline
r_void
id|set_timeout
c_func
(paren
r_int
id|start_jiffies
comma
r_struct
id|timeout
op_star
id|to
comma
r_const
r_struct
id|timespec
op_star
id|ts
)paren
(brace
r_int
r_int
id|how_long
suffix:semicolon
r_if
c_cond
(paren
id|ts-&gt;tv_sec
OL
l_int|0
op_logical_or
(paren
op_logical_neg
id|ts-&gt;tv_sec
op_logical_and
op_logical_neg
id|ts-&gt;tv_nsec
)paren
)paren
(brace
id|to-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|how_long
op_assign
id|ts-&gt;tv_sec
op_star
id|HZ
suffix:semicolon
DECL|macro|HZ_NS
mdefine_line|#define HZ_NS (1000000000 / HZ)
id|how_long
op_add_assign
(paren
id|ts-&gt;tv_nsec
op_plus
id|HZ_NS
op_minus
l_int|1
)paren
op_div
id|HZ_NS
suffix:semicolon
id|to-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|how_long
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|to-&gt;timer
)paren
suffix:semicolon
)brace
DECL|function|clear_timeout
r_static
r_inline
r_void
id|clear_timeout
c_func
(paren
r_struct
id|timeout
op_star
id|to
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|to-&gt;timer
)paren
suffix:semicolon
)brace
DECL|function|read_events
r_static
r_int
id|read_events
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_int
id|min_nr
comma
r_int
id|nr
comma
r_struct
id|io_event
op_star
id|event
comma
r_struct
id|timespec
op_star
id|timeout
)paren
(brace
r_int
id|start_jiffies
op_assign
id|jiffies
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|io_event
id|ent
suffix:semicolon
r_struct
id|timeout
id|to
suffix:semicolon
multiline_comment|/* needed to zero any padding within an entry (there shouldn&squot;t be &n;&t; * any, but C is fun!&n;&t; */
id|memset
c_func
(paren
op_amp
id|ent
comma
l_int|0
comma
r_sizeof
(paren
id|ent
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|likely
c_func
(paren
id|i
OL
id|nr
)paren
)paren
(brace
id|ret
op_assign
id|aio_read_evt
c_func
(paren
id|ctx
comma
op_amp
id|ent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
op_le
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;read event: %Lx %Lx %Lx %Lx&bslash;n&quot;
comma
id|ent.data
comma
id|ent.obj
comma
id|ent.res
comma
id|ent.res2
)paren
suffix:semicolon
multiline_comment|/* Could we split the check in two? */
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_to_user
c_func
(paren
id|event
comma
op_amp
id|ent
comma
r_sizeof
(paren
id|ent
)paren
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;aio: lost an event due to EFAULT.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Good, event copied to userland, update counts. */
id|event
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|min_nr
op_le
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* End fast path */
r_if
c_cond
(paren
id|timeout
)paren
(brace
r_struct
id|timespec
id|ts
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ts
comma
id|timeout
comma
r_sizeof
(paren
id|ts
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|init_timeout
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
id|set_timeout
c_func
(paren
id|start_jiffies
comma
op_amp
id|to
comma
op_amp
id|ts
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|likely
c_func
(paren
id|i
OL
id|nr
)paren
)paren
(brace
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_do
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|ret
op_assign
id|aio_read_evt
c_func
(paren
id|ctx
comma
op_amp
id|ent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|min_nr
op_le
id|i
)paren
r_break
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|to.timed_out
)paren
multiline_comment|/* Only check after read evt */
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*ret = aio_read_evt(ctx, &amp;ent);*/
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
op_le
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_to_user
c_func
(paren
id|event
comma
op_amp
id|ent
comma
r_sizeof
(paren
id|ent
)paren
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;aio: lost an event due to EFAULT.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Good, event copied to userland, update counts. */
id|event
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
id|clear_timeout
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|i
ques
c_cond
id|i
suffix:colon
id|ret
suffix:semicolon
)brace
multiline_comment|/* Take an ioctx and remove it from the list of ioctx&squot;s.  Protects &n; * against races with itself via -&gt;dead.&n; */
DECL|function|io_destroy
r_static
r_void
id|io_destroy
c_func
(paren
r_struct
id|kioctx
op_star
id|ioctx
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|kioctx
op_star
op_star
id|tmp
suffix:semicolon
r_int
id|was_dead
suffix:semicolon
multiline_comment|/* delete the entry from the list is someone else hasn&squot;t already */
id|write_lock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|was_dead
op_assign
id|ioctx-&gt;dead
suffix:semicolon
id|ioctx-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
op_amp
id|mm-&gt;ioctx_list
suffix:semicolon
op_star
id|tmp
op_logical_and
op_star
id|tmp
op_ne
id|ioctx
suffix:semicolon
id|tmp
op_assign
op_amp
(paren
op_star
id|tmp
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|tmp
)paren
op_star
id|tmp
op_assign
id|ioctx-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio_release(%p)&bslash;n&quot;
comma
id|ioctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|was_dead
)paren
)paren
id|put_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
multiline_comment|/* twice for the list */
id|aio_cancel_all
c_func
(paren
id|ioctx
)paren
suffix:semicolon
id|wait_for_all_aios
c_func
(paren
id|ioctx
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
multiline_comment|/* once for the lookup */
)brace
multiline_comment|/* sys_io_setup:&n; *&t;Create an aio_context capable of receiving at least nr_events.&n; *&t;ctxp must not point to an aio_context that already exists, and&n; *&t;must be initialized to 0 prior to the call.  On successful&n; *&t;creation of the aio_context, *ctxp is filled in with the resulting &n; *&t;handle.  May fail with -EINVAL if *ctxp is not initialized,&n; *&t;if the specified nr_events exceeds internal limits.  May fail &n; *&t;with -EAGAIN if the specified nr_events exceeds the user&squot;s limit &n; *&t;of available events.  May fail with -ENOMEM if insufficient kernel&n; *&t;resources are available.  May fail with -EFAULT if an invalid&n; *&t;pointer is passed for ctxp.  Will fail with -ENOSYS if not&n; *&t;implemented.&n; */
DECL|function|sys_io_setup
id|asmlinkage
r_int
id|sys_io_setup
c_func
(paren
r_int
id|nr_events
comma
id|aio_context_t
op_star
id|ctxp
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|ctx
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|get_user
c_func
(paren
id|ctx
comma
id|ctxp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx
op_logical_or
op_logical_neg
id|nr_events
op_logical_or
(paren
r_int
)paren
id|nr_events
OL
l_int|0
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_setup: ctx or nr_events &gt; max&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ioctx
op_assign
id|ioctx_alloc
c_func
(paren
id|nr_events
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|ioctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|ioctx
)paren
)paren
(brace
id|ret
op_assign
id|put_user
c_func
(paren
id|ioctx-&gt;user_id
comma
id|ctxp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_return
l_int|0
suffix:semicolon
id|io_destroy
c_func
(paren
id|ioctx
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* sys_io_destroy:&n; *&t;Destroy the aio_context specified.  May cancel any outstanding &n; *&t;AIOs and block on completion.  Will fail with -ENOSYS if not&n; *&t;implemented.  May fail with -EFAULT if the context pointed to&n; *&t;is invalid.&n; */
DECL|function|sys_io_destroy
id|asmlinkage
r_int
id|sys_io_destroy
c_func
(paren
id|aio_context_t
id|ctx
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
l_int|NULL
op_ne
id|ioctx
)paren
)paren
(brace
id|io_destroy
c_func
(paren
id|ioctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_destroy: invalid context id&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_int
id|FASTCALL
c_func
(paren
id|io_submit_one
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|iocb
op_star
id|user_iocb
comma
r_struct
id|iocb
op_star
id|iocb
)paren
)paren
suffix:semicolon
DECL|function|io_submit_one
r_static
r_int
id|io_submit_one
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|iocb
op_star
id|user_iocb
comma
r_struct
id|iocb
op_star
id|iocb
)paren
(brace
r_struct
id|kiocb
op_star
id|req
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* enforce forwards compatibility on users */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|iocb-&gt;aio_reserved1
op_logical_or
id|iocb-&gt;aio_reserved2
op_logical_or
id|iocb-&gt;aio_reserved3
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_submit: reserve field set&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* prevent overflows */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|iocb-&gt;aio_buf
op_ne
(paren
r_int
r_int
)paren
id|iocb-&gt;aio_buf
)paren
op_logical_or
(paren
id|iocb-&gt;aio_nbytes
op_ne
(paren
r_int
)paren
id|iocb-&gt;aio_nbytes
)paren
op_logical_or
(paren
(paren
id|ssize_t
)paren
id|iocb-&gt;aio_nbytes
OL
l_int|0
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_submit: overflow check&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|file
op_assign
id|fget
c_func
(paren
id|iocb-&gt;aio_fildes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|file
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|req
op_assign
id|aio_get_req
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|req
)paren
)paren
(brace
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|req-&gt;ki_filp
op_assign
id|file
suffix:semicolon
id|iocb-&gt;aio_key
op_assign
id|req-&gt;ki_key
suffix:semicolon
id|ret
op_assign
id|put_user
c_func
(paren
id|iocb-&gt;aio_key
comma
op_amp
id|user_iocb-&gt;aio_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;EFAULT: aio_key&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_put_req
suffix:semicolon
)brace
id|req-&gt;ki_user_obj
op_assign
id|user_iocb
suffix:semicolon
id|req-&gt;ki_user_data
op_assign
id|iocb-&gt;aio_data
suffix:semicolon
id|req-&gt;ki_pos
op_assign
id|iocb-&gt;aio_offset
suffix:semicolon
id|buf
op_assign
(paren
r_char
op_star
)paren
(paren
r_int
r_int
)paren
id|iocb-&gt;aio_buf
suffix:semicolon
r_switch
c_cond
(paren
id|iocb-&gt;aio_lio_opcode
)paren
(brace
r_case
id|IOCB_CMD_PREAD
suffix:colon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
)paren
r_goto
id|out_put_req
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|iocb-&gt;aio_nbytes
)paren
)paren
)paren
r_goto
id|out_put_req
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_read
)paren
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_read
c_func
(paren
id|req
comma
id|buf
comma
id|iocb-&gt;aio_nbytes
comma
id|req-&gt;ki_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCB_CMD_PWRITE
suffix:colon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
)paren
r_goto
id|out_put_req
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|iocb-&gt;aio_nbytes
)paren
)paren
)paren
r_goto
id|out_put_req
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_write
)paren
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_write
c_func
(paren
id|req
comma
id|buf
comma
id|iocb-&gt;aio_nbytes
comma
id|req-&gt;ki_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCB_CMD_FDSYNC
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_fsync
)paren
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_fsync
c_func
(paren
id|req
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCB_CMD_FSYNC
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_fsync
)paren
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_fsync
c_func
(paren
id|req
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;EINVAL: io_submit: no operation provided&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_minus
id|EIOCBQUEUED
op_eq
id|ret
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|aio_complete
c_func
(paren
id|req
comma
id|ret
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_put_req
suffix:colon
id|aio_put_req
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* sys_io_submit:&n; *&t;Queue the nr iocbs pointed to by iocbpp for processing.  Returns&n; *&t;the number of iocbs queued.  May return -EINVAL if the aio_context&n; *&t;specified by ctx_id is invalid, if nr is &lt; 0, if the iocb at&n; *&t;*iocbpp[0] is not properly initialized, if the operation specified&n; *&t;is invalid for the file descriptor in the iocb.  May fail with&n; *&t;-EFAULT if any of the data structures point to invalid data.  May&n; *&t;fail with -EBADF if the file descriptor specified in the first&n; *&t;iocb is invalid.  May fail with -EAGAIN if insufficient resources&n; *&t;are available to queue any iocbs.  Will return 0 if nr is 0.  Will&n; *&t;fail with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_submit
id|asmlinkage
r_int
id|sys_io_submit
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
id|nr
comma
r_struct
id|iocb
op_star
op_star
id|iocbpp
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|nr
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|iocbpp
comma
(paren
id|nr
op_star
r_sizeof
(paren
op_star
id|iocbpp
)paren
)paren
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_submit: invalid context id&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|iocb
op_star
id|user_iocb
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|__get_user
c_func
(paren
id|user_iocb
comma
id|iocbpp
op_plus
id|i
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user_iocb
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|io_submit_one
c_func
(paren
id|ctx
comma
id|user_iocb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
)brace
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|i
ques
c_cond
id|i
suffix:colon
id|ret
suffix:semicolon
)brace
multiline_comment|/* lookup_kiocb&n; *&t;Finds a given iocb for cancellation.&n; *&t;MUST be called with ctx-&gt;ctx_lock held.&n; */
DECL|function|lookup_kiocb
r_struct
id|kiocb
op_star
id|lookup_kiocb
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|iocb
op_star
id|iocb
comma
id|u32
id|key
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* TODO: use a hash or array, this sucks. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|ctx-&gt;active_reqs
)paren
(brace
r_struct
id|kiocb
op_star
id|kiocb
op_assign
id|list_kiocb
c_func
(paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kiocb-&gt;ki_user_obj
op_eq
id|iocb
op_logical_and
id|kiocb-&gt;ki_key
op_eq
id|key
)paren
r_return
id|kiocb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* sys_io_cancel:&n; *&t;Attempts to cancel an iocb previously passed to io_submit.  If&n; *&t;the operation is successfully cancelled, the resulting event is&n; *&t;copied into the memory pointed to by result without being placed&n; *&t;into the completion queue and 0 is returned.  May fail with&n; *&t;-EFAULT if any of the data structures pointed to are invalid.&n; *&t;May fail with -EINVAL if aio_context specified by ctx_id is&n; *&t;invalid.  May fail with -EAGAIN if the iocb specified was not&n; *&t;cancelled.  Will fail with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_cancel
id|asmlinkage
r_int
id|sys_io_cancel
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_struct
id|iocb
op_star
id|iocb
comma
r_struct
id|io_event
op_star
id|result
)paren
(brace
r_int
(paren
op_star
id|cancel
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|io_event
op_star
id|res
)paren
suffix:semicolon
r_struct
id|kioctx
op_star
id|ctx
suffix:semicolon
r_struct
id|kiocb
op_star
id|kiocb
suffix:semicolon
id|u32
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|get_user
c_func
(paren
id|key
comma
op_amp
id|iocb-&gt;aio_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|kiocb
op_assign
id|lookup_kiocb
c_func
(paren
id|ctx
comma
id|iocb
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kiocb
op_logical_and
id|kiocb-&gt;ki_cancel
)paren
(brace
id|cancel
op_assign
id|kiocb-&gt;ki_cancel
suffix:semicolon
id|kiocb-&gt;ki_users
op_increment
suffix:semicolon
)brace
r_else
id|cancel
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|cancel
)paren
(brace
r_struct
id|io_event
id|tmp
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;calling cancel&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|cancel
c_func
(paren
id|kiocb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/* Cancellation succeeded -- copy the result&n;&t;&t;&t; * into the user&squot;s buffer.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|result
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iocb has no cancel operation&bslash;n&quot;
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* io_getevents:&n; *&t;Attempts to read at least min_nr events and up to nr events from&n; *&t;the completion queue for the aio_context specified by ctx_id.  May&n; *&t;fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,&n; *&t;if nr is out of range, if when is out of range.  May fail with&n; *&t;-EFAULT if any of the memory specified to is invalid.  May return&n; *&t;0 or &lt; min_nr if no events are available and the timeout specified&n; *&t;by when&t;has elapsed, where when == NULL specifies an infinite&n; *&t;timeout.  Note that the timeout pointed to by when is relative and&n; *&t;will be updated if not NULL and the operation blocks.  Will fail&n; *&t;with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_getevents
id|asmlinkage
r_int
id|sys_io_getevents
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
id|min_nr
comma
r_int
id|nr
comma
r_struct
id|io_event
op_star
id|events
comma
r_struct
id|timespec
op_star
id|timeout
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx_id
)paren
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|min_nr
OG
id|nr
op_logical_or
id|min_nr
OL
l_int|0
op_logical_or
id|nr
OL
l_int|0
)paren
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
l_int|NULL
op_ne
id|ioctx
)paren
)paren
(brace
id|ret
op_assign
id|read_events
c_func
(paren
id|ioctx
comma
id|min_nr
comma
id|nr
comma
id|events
comma
id|timeout
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|aio_setup
id|__initcall
c_func
(paren
id|aio_setup
)paren
suffix:semicolon
DECL|variable|aio_complete
id|EXPORT_SYMBOL
c_func
(paren
id|aio_complete
)paren
suffix:semicolon
DECL|variable|aio_put_req
id|EXPORT_SYMBOL
c_func
(paren
id|aio_put_req
)paren
suffix:semicolon
eof
