multiline_comment|/*&n; *&t;An async IO implementation for Linux&n; *&t;Written by Benjamin LaHaise &lt;bcrl@redhat.com&gt;&n; *&n; *&t;Implements an efficient asynchronous io interface.&n; *&n; *&t;Copyright 2000, 2001, 2002 Red Hat, Inc.  All Rights Reserved.&n; *&n; *&t;See ../COPYING for licensing terms.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/aio_abi.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/syscalls.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG 0
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/aio.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;asm/kmap_types.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#if DEBUG &gt; 1
DECL|macro|dprintk
mdefine_line|#define dprintk&t;&t;printk
macro_line|#else
DECL|macro|dprintk
mdefine_line|#define dprintk(x...)&t;do { ; } while (0)
macro_line|#endif
DECL|variable|aio_run
r_int
id|aio_run
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for testing only */
DECL|variable|aio_wakeups
r_int
id|aio_wakeups
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for testing only */
multiline_comment|/*------ sysctl variables----*/
DECL|variable|aio_nr
id|atomic_t
id|aio_nr
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* current system wide number of aio requests */
DECL|variable|aio_max_nr
r_int
id|aio_max_nr
op_assign
l_int|0x10000
suffix:semicolon
multiline_comment|/* system wide maximum number of aio requests */
multiline_comment|/*----end sysctl variables---*/
DECL|variable|kiocb_cachep
r_static
id|kmem_cache_t
op_star
id|kiocb_cachep
suffix:semicolon
DECL|variable|kioctx_cachep
r_static
id|kmem_cache_t
op_star
id|kioctx_cachep
suffix:semicolon
DECL|variable|aio_wq
r_static
r_struct
id|workqueue_struct
op_star
id|aio_wq
suffix:semicolon
multiline_comment|/* Used for rare fput completion. */
r_static
r_void
id|aio_fput_routine
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
id|DECLARE_WORK
c_func
(paren
id|fput_work
comma
id|aio_fput_routine
comma
l_int|NULL
)paren
suffix:semicolon
DECL|variable|fput_lock
r_static
id|spinlock_t
id|fput_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|fput_head
id|LIST_HEAD
c_func
(paren
id|fput_head
)paren
suffix:semicolon
r_static
r_void
id|aio_kick_handler
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/* aio_setup&n; *&t;Creates the slab caches used by the aio routines, panic on&n; *&t;failure as this is done early during the boot sequence.&n; */
DECL|function|aio_setup
r_static
r_int
id|__init
id|aio_setup
c_func
(paren
r_void
)paren
(brace
id|kiocb_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;kiocb&quot;
comma
r_sizeof
(paren
r_struct
id|kiocb
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_PANIC
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|kioctx_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;kioctx&quot;
comma
r_sizeof
(paren
r_struct
id|kioctx
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_PANIC
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|aio_wq
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;aio&quot;
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;aio_setup: sizeof(struct page) = %d&bslash;n&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
r_struct
id|page
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|aio_free_ring
r_static
r_void
id|aio_free_ring
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|aio_ring_info
op_star
id|info
op_assign
op_amp
id|ctx-&gt;ring_info
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;nr_pages
suffix:semicolon
id|i
op_increment
)paren
id|put_page
c_func
(paren
id|info-&gt;ring_pages
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;mmap_size
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|do_munmap
c_func
(paren
id|ctx-&gt;mm
comma
id|info-&gt;mmap_base
comma
id|info-&gt;mmap_size
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;ring_pages
op_logical_and
id|info-&gt;ring_pages
op_ne
id|info-&gt;internal_pages
)paren
id|kfree
c_func
(paren
id|info-&gt;ring_pages
)paren
suffix:semicolon
id|info-&gt;ring_pages
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;nr
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|aio_setup_ring
r_static
r_int
id|aio_setup_ring
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_struct
id|aio_ring_info
op_star
id|info
op_assign
op_amp
id|ctx-&gt;ring_info
suffix:semicolon
r_int
id|nr_events
op_assign
id|ctx-&gt;max_reqs
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
id|nr_pages
suffix:semicolon
multiline_comment|/* Compensate for the ring buffer&squot;s head/tail overlap entry */
id|nr_events
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* 1 is required, 2 for good luck */
id|size
op_assign
r_sizeof
(paren
r_struct
id|aio_ring
)paren
suffix:semicolon
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|io_event
)paren
op_star
id|nr_events
suffix:semicolon
id|nr_pages
op_assign
(paren
id|size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|nr_events
op_assign
(paren
id|PAGE_SIZE
op_star
id|nr_pages
op_minus
r_sizeof
(paren
r_struct
id|aio_ring
)paren
)paren
op_div
r_sizeof
(paren
r_struct
id|io_event
)paren
suffix:semicolon
id|info-&gt;nr
op_assign
l_int|0
suffix:semicolon
id|info-&gt;ring_pages
op_assign
id|info-&gt;internal_pages
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
OG
id|AIO_RING_PAGES
)paren
(brace
id|info-&gt;ring_pages
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|nr_pages
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;ring_pages
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|info-&gt;ring_pages
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|nr_pages
)paren
suffix:semicolon
)brace
id|info-&gt;mmap_size
op_assign
id|nr_pages
op_star
id|PAGE_SIZE
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;attempting mmap of %lu bytes&bslash;n&quot;
comma
id|info-&gt;mmap_size
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|info-&gt;mmap_base
op_assign
id|do_mmap
c_func
(paren
l_int|NULL
comma
l_int|0
comma
id|info-&gt;mmap_size
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_ANON
op_or
id|MAP_PRIVATE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
(paren
r_void
op_star
)paren
id|info-&gt;mmap_base
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mmap err: %ld&bslash;n&quot;
comma
op_minus
id|info-&gt;mmap_base
)paren
suffix:semicolon
id|info-&gt;mmap_size
op_assign
l_int|0
suffix:semicolon
id|aio_free_ring
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;mmap address: 0x%08lx&bslash;n&quot;
comma
id|info-&gt;mmap_base
)paren
suffix:semicolon
id|info-&gt;nr_pages
op_assign
id|get_user_pages
c_func
(paren
id|current
comma
id|ctx-&gt;mm
comma
id|info-&gt;mmap_base
comma
id|nr_pages
comma
l_int|1
comma
l_int|0
comma
id|info-&gt;ring_pages
comma
l_int|NULL
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ctx-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|info-&gt;nr_pages
op_ne
id|nr_pages
)paren
)paren
(brace
id|aio_free_ring
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|ctx-&gt;user_id
op_assign
id|info-&gt;mmap_base
suffix:semicolon
id|info-&gt;nr
op_assign
id|nr_events
suffix:semicolon
multiline_comment|/* trusted copy */
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|info-&gt;ring_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|ring-&gt;nr
op_assign
id|nr_events
suffix:semicolon
multiline_comment|/* user copy */
id|ring-&gt;id
op_assign
id|ctx-&gt;user_id
suffix:semicolon
id|ring-&gt;head
op_assign
id|ring-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|ring-&gt;magic
op_assign
id|AIO_RING_MAGIC
suffix:semicolon
id|ring-&gt;compat_features
op_assign
id|AIO_RING_COMPAT_FEATURES
suffix:semicolon
id|ring-&gt;incompat_features
op_assign
id|AIO_RING_INCOMPAT_FEATURES
suffix:semicolon
id|ring-&gt;header_length
op_assign
r_sizeof
(paren
r_struct
id|aio_ring
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_USER0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* aio_ring_event: returns a pointer to the event at the given index from&n; * kmap_atomic(, km).  Release the pointer with put_aio_ring_event();&n; */
DECL|macro|AIO_EVENTS_PER_PAGE
mdefine_line|#define AIO_EVENTS_PER_PAGE&t;(PAGE_SIZE / sizeof(struct io_event))
DECL|macro|AIO_EVENTS_FIRST_PAGE
mdefine_line|#define AIO_EVENTS_FIRST_PAGE&t;((PAGE_SIZE - sizeof(struct aio_ring)) / sizeof(struct io_event))
DECL|macro|AIO_EVENTS_OFFSET
mdefine_line|#define AIO_EVENTS_OFFSET&t;(AIO_EVENTS_PER_PAGE - AIO_EVENTS_FIRST_PAGE)
DECL|macro|aio_ring_event
mdefine_line|#define aio_ring_event(info, nr, km) ({&t;&t;&t;&t;&t;&bslash;&n;&t;unsigned pos = (nr) + AIO_EVENTS_OFFSET;&t;&t;&t;&bslash;&n;&t;struct io_event *__event;&t;&t;&t;&t;&t;&bslash;&n;&t;__event = kmap_atomic(&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;(info)-&gt;ring_pages[pos / AIO_EVENTS_PER_PAGE], km); &bslash;&n;&t;__event += pos % AIO_EVENTS_PER_PAGE;&t;&t;&t;&t;&bslash;&n;&t;__event;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|put_aio_ring_event
mdefine_line|#define put_aio_ring_event(event, km) do {&t;&bslash;&n;&t;struct io_event *__event = (event);&t;&bslash;&n;&t;(void)__event;&t;&t;&t;&t;&bslash;&n;&t;kunmap_atomic((void *)((unsigned long)__event &amp; PAGE_MASK), km); &bslash;&n;} while(0)
multiline_comment|/* ioctx_alloc&n; *&t;Allocates and initializes an ioctx.  Returns an ERR_PTR if it failed.&n; */
DECL|function|ioctx_alloc
r_static
r_struct
id|kioctx
op_star
id|ioctx_alloc
c_func
(paren
r_int
id|nr_events
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
r_struct
id|kioctx
op_star
id|ctx
suffix:semicolon
multiline_comment|/* Prevent overflows */
r_if
c_cond
(paren
(paren
id|nr_events
OG
(paren
l_int|0x10000000U
op_div
r_sizeof
(paren
r_struct
id|io_event
)paren
)paren
)paren
op_logical_or
(paren
id|nr_events
OG
(paren
l_int|0x10000000U
op_div
r_sizeof
(paren
r_struct
id|kiocb
)paren
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;ENOMEM: nr_events too high&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_events
OG
id|aio_max_nr
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|ctx
op_assign
id|kmem_cache_alloc
c_func
(paren
id|kioctx_cachep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ctx
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ctx
)paren
)paren
suffix:semicolon
id|ctx-&gt;max_reqs
op_assign
id|nr_events
suffix:semicolon
id|mm
op_assign
id|ctx-&gt;mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ctx-&gt;users
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|ctx-&gt;ring_info.ring_lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ctx-&gt;active_reqs
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ctx-&gt;run_list
)paren
suffix:semicolon
id|INIT_WORK
c_func
(paren
op_amp
id|ctx-&gt;wq
comma
id|aio_kick_handler
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aio_setup_ring
c_func
(paren
id|ctx
)paren
OL
l_int|0
)paren
r_goto
id|out_freectx
suffix:semicolon
multiline_comment|/* limit the number of system wide aios */
id|atomic_add
c_func
(paren
id|ctx-&gt;max_reqs
comma
op_amp
id|aio_nr
)paren
suffix:semicolon
multiline_comment|/* undone by __put_ioctx */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|aio_nr
)paren
OG
id|aio_max_nr
)paren
)paren
r_goto
id|out_cleanup
suffix:semicolon
multiline_comment|/* now link into global list.  kludge.  FIXME */
id|write_lock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|ctx-&gt;next
op_assign
id|mm-&gt;ioctx_list
suffix:semicolon
id|mm-&gt;ioctx_list
op_assign
id|ctx
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio: allocated ioctx %p[%ld]: mm=%p mask=0x%x&bslash;n&quot;
comma
id|ctx
comma
id|ctx-&gt;user_id
comma
id|current-&gt;mm
comma
id|ctx-&gt;ring_info.nr
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
id|out_cleanup
suffix:colon
id|atomic_sub
c_func
(paren
id|ctx-&gt;max_reqs
comma
op_amp
id|aio_nr
)paren
suffix:semicolon
id|ctx-&gt;max_reqs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* prevent __put_ioctx from sub&squot;ing aio_nr */
id|__put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|out_freectx
suffix:colon
id|mmdrop
c_func
(paren
id|mm
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|kioctx_cachep
comma
id|ctx
)paren
suffix:semicolon
id|ctx
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio: error allocating ioctx %p&bslash;n&quot;
comma
id|ctx
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
)brace
multiline_comment|/* aio_cancel_all&n; *&t;Cancels all outstanding aio requests on an aio context.  Used &n; *&t;when the processes owning a context have all exited to encourage &n; *&t;the rapid destruction of the kioctx.&n; */
DECL|function|aio_cancel_all
r_static
r_void
id|aio_cancel_all
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_int
(paren
op_star
id|cancel
)paren
(paren
r_struct
id|kiocb
op_star
comma
r_struct
id|io_event
op_star
)paren
suffix:semicolon
r_struct
id|io_event
id|res
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ctx-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ctx-&gt;active_reqs
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|pos
op_assign
id|ctx-&gt;active_reqs.next
suffix:semicolon
r_struct
id|kiocb
op_star
id|iocb
op_assign
id|list_kiocb
c_func
(paren
id|pos
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|iocb-&gt;ki_list
)paren
suffix:semicolon
id|cancel
op_assign
id|iocb-&gt;ki_cancel
suffix:semicolon
id|kiocbSetCancelled
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cancel
)paren
(brace
id|iocb-&gt;ki_users
op_increment
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|cancel
c_func
(paren
id|iocb
comma
op_amp
id|res
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
DECL|function|wait_for_all_aios
r_void
id|wait_for_all_aios
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;reqs_active
)paren
r_return
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ctx-&gt;reqs_active
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|__set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
multiline_comment|/* wait_on_sync_kiocb:&n; *&t;Waits on the given sync kiocb to complete.&n; */
DECL|function|wait_on_sync_kiocb
id|ssize_t
id|fastcall
id|wait_on_sync_kiocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_while
c_loop
(paren
id|iocb-&gt;ki_users
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iocb-&gt;ki_users
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|iocb-&gt;ki_user_data
suffix:semicolon
)brace
multiline_comment|/* exit_aio: called when the last user of mm goes away.  At this point, &n; * there is no way for any new requests to be submited or any of the &n; * io_* syscalls to be called on the context.  However, there may be &n; * outstanding requests which hold references to the context; as they &n; * go away, they will call put_ioctx and release any pinned memory&n; * associated with the request (held via struct page * references).&n; */
DECL|function|exit_aio
r_void
id|fastcall
id|exit_aio
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|mm-&gt;ioctx_list
suffix:semicolon
id|mm-&gt;ioctx_list
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|ctx
)paren
(brace
r_struct
id|kioctx
op_star
id|next
op_assign
id|ctx-&gt;next
suffix:semicolon
id|ctx-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|aio_cancel_all
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|wait_for_all_aios
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this is an overkill, but ensures we don&squot;t leave&n;&t;&t; * the ctx on the aio_wq&n;&t;&t; */
id|flush_workqueue
c_func
(paren
id|aio_wq
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_ne
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;users
)paren
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;exit_aio:ioctx still alive: %d %d %d&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|ctx-&gt;users
)paren
comma
id|ctx-&gt;dead
comma
id|ctx-&gt;reqs_active
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* __put_ioctx&n; *&t;Called when the last user of an aio context has gone away,&n; *&t;and the struct needs to be freed.&n; */
DECL|function|__put_ioctx
r_void
id|fastcall
id|__put_ioctx
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_int
id|nr_events
op_assign
id|ctx-&gt;max_reqs
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx-&gt;reqs_active
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|cancel_delayed_work
c_func
(paren
op_amp
id|ctx-&gt;wq
)paren
suffix:semicolon
id|flush_workqueue
c_func
(paren
id|aio_wq
)paren
suffix:semicolon
id|aio_free_ring
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|mmdrop
c_func
(paren
id|ctx-&gt;mm
)paren
suffix:semicolon
id|ctx-&gt;mm
op_assign
l_int|NULL
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;__put_ioctx: freeing %p&bslash;n&quot;
comma
id|ctx
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|kioctx_cachep
comma
id|ctx
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|nr_events
comma
op_amp
id|aio_nr
)paren
suffix:semicolon
)brace
multiline_comment|/* aio_get_req&n; *&t;Allocate a slot for an aio request.  Increments the users count&n; * of the kioctx so that the kioctx stays around until all requests are&n; * complete.  Returns NULL if no requests are free.&n; *&n; * Returns with kiocb-&gt;users set to 2.  The io submit code path holds&n; * an extra reference while submitting the i/o.&n; * This prevents races between the aio code path referencing the&n; * req (after submitting it) and aio_complete() freeing the req.&n; */
r_static
r_struct
id|kiocb
op_star
id|FASTCALL
c_func
(paren
id|__aio_get_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
)paren
suffix:semicolon
DECL|function|__aio_get_req
r_static
r_struct
id|kiocb
id|fastcall
op_star
id|__aio_get_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|kiocb
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_int
id|okay
op_assign
l_int|0
suffix:semicolon
id|req
op_assign
id|kmem_cache_alloc
c_func
(paren
id|kiocb_cachep
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|req
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|req-&gt;ki_flags
op_assign
l_int|1
op_lshift
id|KIF_LOCKED
suffix:semicolon
id|req-&gt;ki_users
op_assign
l_int|2
suffix:semicolon
id|req-&gt;ki_key
op_assign
l_int|0
suffix:semicolon
id|req-&gt;ki_ctx
op_assign
id|ctx
suffix:semicolon
id|req-&gt;ki_cancel
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_retry
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_obj.user
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_dtor
op_assign
l_int|NULL
suffix:semicolon
id|req
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|req-&gt;ki_run_list
)paren
suffix:semicolon
multiline_comment|/* Check if the completion queue has enough free space to&n;&t; * accept an event from this io.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|ctx-&gt;ring_info.ring_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;reqs_active
OL
id|aio_ring_avail
c_func
(paren
op_amp
id|ctx-&gt;ring_info
comma
id|ring
)paren
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|req-&gt;ki_list
comma
op_amp
id|ctx-&gt;active_reqs
)paren
suffix:semicolon
id|get_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|ctx-&gt;reqs_active
op_increment
suffix:semicolon
id|okay
op_assign
l_int|1
suffix:semicolon
)brace
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_USER0
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|okay
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|kiocb_cachep
comma
id|req
)paren
suffix:semicolon
id|req
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|req
suffix:semicolon
)brace
DECL|function|aio_get_req
r_static
r_inline
r_struct
id|kiocb
op_star
id|aio_get_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|kiocb
op_star
id|req
suffix:semicolon
multiline_comment|/* Handle a potential starvation case -- should be exceedingly rare as &n;&t; * requests will be stuck on fput_head only if the aio_fput_routine is &n;&t; * delayed and the requests were the last user of the struct file.&n;&t; */
id|req
op_assign
id|__aio_get_req
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
l_int|NULL
op_eq
id|req
)paren
)paren
(brace
id|aio_fput_routine
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|req
op_assign
id|__aio_get_req
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
r_return
id|req
suffix:semicolon
)brace
DECL|function|really_put_req
r_static
r_inline
r_void
id|really_put_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|kiocb
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;ki_dtor
)paren
id|req
op_member_access_from_pointer
id|ki_dtor
c_func
(paren
id|req
)paren
suffix:semicolon
id|req-&gt;ki_ctx
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_filp
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_obj.user
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_dtor
op_assign
l_int|NULL
suffix:semicolon
id|req
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|kiocb_cachep
comma
id|req
)paren
suffix:semicolon
id|ctx-&gt;reqs_active
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx-&gt;reqs_active
op_logical_and
id|ctx-&gt;dead
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
suffix:semicolon
)brace
DECL|function|aio_fput_routine
r_static
r_void
id|aio_fput_routine
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|likely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fput_head
)paren
)paren
)paren
(brace
r_struct
id|kiocb
op_star
id|req
op_assign
id|list_kiocb
c_func
(paren
id|fput_head.next
)paren
suffix:semicolon
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|req-&gt;ki_ctx
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req-&gt;ki_list
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
multiline_comment|/* Complete the fput */
id|__fput
c_func
(paren
id|req-&gt;ki_filp
)paren
suffix:semicolon
multiline_comment|/* Link the iocb into the context&squot;s free list */
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|really_put_req
c_func
(paren
id|ctx
comma
id|req
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* __aio_put_req&n; *&t;Returns true if this put was the last user of the request.&n; */
DECL|function|__aio_put_req
r_static
r_int
id|__aio_put_req
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|kiocb
op_star
id|req
)paren
(brace
id|dprintk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;aio_put(%p): f_count=%d&bslash;n&quot;
comma
id|req
comma
id|atomic_read
c_func
(paren
op_amp
id|req-&gt;ki_filp-&gt;f_count
)paren
)paren
suffix:semicolon
id|req-&gt;ki_users
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|req-&gt;ki_users
OL
l_int|0
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|req-&gt;ki_users
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req-&gt;ki_list
)paren
suffix:semicolon
multiline_comment|/* remove from active_reqs */
id|req-&gt;ki_cancel
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_retry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Must be done under the lock to serialise against cancellation.&n;&t; * Call this aio_fput as it duplicates fput via the fput_work.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|req-&gt;ki_filp-&gt;f_count
)paren
)paren
)paren
(brace
id|get_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req-&gt;ki_list
comma
op_amp
id|fput_head
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|fput_lock
)paren
suffix:semicolon
id|queue_work
c_func
(paren
id|aio_wq
comma
op_amp
id|fput_work
)paren
suffix:semicolon
)brace
r_else
id|really_put_req
c_func
(paren
id|ctx
comma
id|req
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* aio_put_req&n; *&t;Returns true if this put was the last user of the kiocb,&n; *&t;false if the request is still in use.&n; */
DECL|function|aio_put_req
r_int
id|fastcall
id|aio_put_req
c_func
(paren
r_struct
id|kiocb
op_star
id|req
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|req-&gt;ki_ctx
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ret
op_assign
id|__aio_put_req
c_func
(paren
id|ctx
comma
id|req
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&t;Lookup an ioctx id.  ioctx_list is lockless for reads.&n; *&t;FIXME: this is O(n) and is only suitable for development.&n; */
DECL|function|lookup_ioctx
r_struct
id|kioctx
op_star
id|lookup_ioctx
c_func
(paren
r_int
r_int
id|ctx_id
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ioctx
op_assign
id|mm-&gt;ioctx_list
suffix:semicolon
id|ioctx
suffix:semicolon
id|ioctx
op_assign
id|ioctx-&gt;next
)paren
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ioctx-&gt;user_id
op_eq
id|ctx_id
op_logical_and
op_logical_neg
id|ioctx-&gt;dead
)paren
)paren
(brace
id|get_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
r_return
id|ioctx
suffix:semicolon
)brace
multiline_comment|/*&n; * use_mm&n; *&t;Makes the calling kernel thread take on the specified&n; *&t;mm context.&n; *&t;Called by the retry thread execute retries within the&n; *&t;iocb issuer&squot;s mm context, so that copy_from/to_user&n; *&t;operations work seamlessly for aio.&n; *&t;(Note: this routine is intended to be called only&n; *&t;from a kernel thread context)&n; */
DECL|function|use_mm
r_static
r_void
id|use_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|mm_struct
op_star
id|active_mm
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;flags
op_or_assign
id|PF_BORROWED_MM
suffix:semicolon
id|active_mm
op_assign
id|tsk-&gt;active_mm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
suffix:semicolon
id|tsk-&gt;mm
op_assign
id|mm
suffix:semicolon
id|tsk-&gt;active_mm
op_assign
id|mm
suffix:semicolon
id|activate_mm
c_func
(paren
id|active_mm
comma
id|mm
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|mmdrop
c_func
(paren
id|active_mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * unuse_mm&n; *&t;Reverses the effect of use_mm, i.e. releases the&n; *&t;specified mm context which was earlier taken on&n; *&t;by the calling kernel thread&n; *&t;(Note: this routine is intended to be called only&n; *&t;from a kernel thread context)&n; *&n; * Comments: Called with ctx-&gt;ctx_lock held. This nests&n; * task_lock instead ctx_lock.&n; */
DECL|function|unuse_mm
r_void
id|unuse_mm
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|task_lock
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;flags
op_and_assign
op_complement
id|PF_BORROWED_MM
suffix:semicolon
id|tsk-&gt;mm
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* active_mm is still &squot;mm&squot; */
id|enter_lazy_tlb
c_func
(paren
id|mm
comma
id|tsk
)paren
suffix:semicolon
id|task_unlock
c_func
(paren
id|tsk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Queue up a kiocb to be retried. Assumes that the kiocb&n; * has already been marked as kicked, and places it on&n; * the retry run list for the corresponding ioctx, if it&n; * isn&squot;t already queued. Returns 1 if it actually queued&n; * the kiocb (to tell the caller to activate the work&n; * queue to process it), or 0, if it found that it was&n; * already queued.&n; *&n; * Should be called with the spin lock iocb-&gt;ki_ctx-&gt;ctx_lock&n; * held&n; */
DECL|function|__queue_kicked_iocb
r_static
r_inline
r_int
id|__queue_kicked_iocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|iocb-&gt;ki_ctx
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
comma
op_amp
id|ctx-&gt;run_list
)paren
suffix:semicolon
id|iocb-&gt;ki_queued
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* aio_run_iocb&n; *&t;This is the core aio execution routine. It is&n; *&t;invoked both for initial i/o submission and&n; *&t;subsequent retries via the aio_kick_handler.&n; *&t;Expects to be invoked with iocb-&gt;ki_ctx-&gt;lock&n; *&t;already held. The lock is released and reaquired&n; *&t;as needed during processing.&n; *&n; * Calls the iocb retry method (already setup for the&n; * iocb on initial submission) for operation specific&n; * handling, but takes care of most of common retry&n; * execution details for a given iocb. The retry method&n; * needs to be non-blocking as far as possible, to avoid&n; * holding up other iocbs waiting to be serviced by the&n; * retry kernel thread.&n; *&n; * The trickier parts in this code have to do with&n; * ensuring that only one retry instance is in progress&n; * for a given iocb at any time. Providing that guarantee&n; * simplifies the coding of individual aio operations as&n; * it avoids various potential races.&n; */
DECL|function|aio_run_iocb
r_static
id|ssize_t
id|aio_run_iocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|iocb-&gt;ki_ctx
suffix:semicolon
id|ssize_t
(paren
op_star
id|retry
)paren
(paren
r_struct
id|kiocb
op_star
)paren
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|iocb-&gt;ki_retried
op_increment
OG
l_int|1024
op_star
l_int|1024
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Maximal retry count.  Bytes done %Zd&bslash;n&quot;
comma
id|iocb-&gt;ki_nbytes
op_minus
id|iocb-&gt;ki_left
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|iocb-&gt;ki_retried
op_amp
l_int|0xff
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;%ld retry: %d of %d (kick %ld, Q %ld run %ld, wake %ld)&bslash;n&quot;
comma
id|iocb-&gt;ki_retried
comma
id|iocb-&gt;ki_nbytes
op_minus
id|iocb-&gt;ki_left
comma
id|iocb-&gt;ki_nbytes
comma
id|iocb-&gt;ki_kicked
comma
id|iocb-&gt;ki_queued
comma
id|aio_run
comma
id|aio_wakeups
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|retry
op_assign
id|iocb-&gt;ki_retry
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aio_run_iocb: iocb-&gt;ki_retry = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t want the next retry iteration for this&n;&t; * operation to start until this one has returned and&n;&t; * updated the iocb state. However, wait_queue functions&n;&t; * can trigger a kick_iocb from interrupt context in the&n;&t; * meantime, indicating that data is available for the next&n;&t; * iteration. We want to remember that and enable the&n;&t; * next retry iteration _after_ we are through with&n;&t; * this one.&n;&t; *&n;&t; * So, in order to be able to register a &quot;kick&quot;, but&n;&t; * prevent it from being queued now, we clear the kick&n;&t; * flag, but make the kick code *think* that the iocb is&n;&t; * still on the run list until we are actually done.&n;&t; * When we are done with this iteration, we check if&n;&t; * the iocb was kicked in the meantime and if so, queue&n;&t; * it up afresh.&n;&t; */
id|kiocbClearKicked
c_func
(paren
id|iocb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is so that aio_complete knows it doesn&squot;t need to&n;&t; * pull the iocb off the run list (We can&squot;t just call&n;&t; * INIT_LIST_HEAD because we don&squot;t want a kick_iocb to&n;&t; * queue this on the run list yet)&n;&t; */
id|iocb-&gt;ki_run_list.next
op_assign
id|iocb-&gt;ki_run_list.prev
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
multiline_comment|/* Quit retrying if the i/o has been cancelled */
r_if
c_cond
(paren
id|kiocbIsCancelled
c_func
(paren
id|iocb
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
id|aio_complete
c_func
(paren
id|iocb
comma
id|ret
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* must not access the iocb after this */
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we are all set to call the retry method in async&n;&t; * context. By setting this thread&squot;s io_wait context&n;&t; * to point to the wait queue entry inside the currently&n;&t; * running iocb for the duration of the retry, we ensure&n;&t; * that async notification wakeups are queued by the&n;&t; * operation instead of blocking waits, and when notified,&n;&t; * cause the iocb to be kicked for continuation (through&n;&t; * the aio_wake_function callback).&n;&t; */
id|BUG_ON
c_func
(paren
id|current-&gt;io_wait
op_ne
l_int|NULL
)paren
suffix:semicolon
id|current-&gt;io_wait
op_assign
op_amp
id|iocb-&gt;ki_wait
suffix:semicolon
id|ret
op_assign
id|retry
c_func
(paren
id|iocb
)paren
suffix:semicolon
id|current-&gt;io_wait
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_minus
id|EIOCBRETRY
op_ne
id|ret
)paren
(brace
r_if
c_cond
(paren
op_minus
id|EIOCBQUEUED
op_ne
id|ret
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|iocb-&gt;ki_wait.task_list
)paren
)paren
suffix:semicolon
id|aio_complete
c_func
(paren
id|iocb
comma
id|ret
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* must not access the iocb after this */
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Issue an additional retry to avoid waiting forever if&n;&t;&t; * no waits were queued (e.g. in case of a short read).&n;&t;&t; */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|iocb-&gt;ki_wait.task_list
)paren
)paren
id|kiocbSetKicked
c_func
(paren
id|iocb
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
id|EIOCBRETRY
op_eq
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t; * OK, now that we are done with this iteration&n;&t;&t; * and know that there is more left to go,&n;&t;&t; * this is where we let go so that a subsequent&n;&t;&t; * &quot;kick&quot; can start the next iteration&n;&t;&t; */
multiline_comment|/* will make __queue_kicked_iocb succeed from here on */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
)paren
suffix:semicolon
multiline_comment|/* we must queue the next iteration ourselves, if it&n;&t;&t; * has already been kicked */
r_if
c_cond
(paren
id|kiocbIsKicked
c_func
(paren
id|iocb
)paren
)paren
(brace
id|__queue_kicked_iocb
c_func
(paren
id|iocb
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * __aio_run_iocbs:&n; * &t;Process all pending retries queued on the ioctx&n; * &t;run list.&n; * Assumes it is operating within the aio issuer&squot;s mm&n; * context. Expects to be called with ctx-&gt;ctx_lock held&n; */
DECL|function|__aio_run_iocbs
r_static
r_int
id|__aio_run_iocbs
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_struct
id|kiocb
op_star
id|iocb
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|run_list
)paren
suffix:semicolon
id|list_splice_init
c_func
(paren
op_amp
id|ctx-&gt;run_list
comma
op_amp
id|run_list
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|run_list
)paren
)paren
(brace
id|iocb
op_assign
id|list_entry
c_func
(paren
id|run_list.next
comma
r_struct
id|kiocb
comma
id|ki_run_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Hold an extra reference while retrying i/o.&n;&t;&t; */
id|iocb-&gt;ki_users
op_increment
suffix:semicolon
multiline_comment|/* grab extra reference */
id|aio_run_iocb
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__aio_put_req
c_func
(paren
id|ctx
comma
id|iocb
)paren
)paren
multiline_comment|/* drop extra ref */
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|aio_run
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ctx-&gt;run_list
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|aio_queue_work
r_static
r_void
id|aio_queue_work
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t; * if someone is waiting, get the work started right&n;&t; * away, otherwise, use a longer delay&n;&t; */
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
)paren
id|timeout
op_assign
l_int|1
suffix:semicolon
r_else
id|timeout
op_assign
id|HZ
op_div
l_int|10
suffix:semicolon
id|queue_delayed_work
c_func
(paren
id|aio_wq
comma
op_amp
id|ctx-&gt;wq
comma
id|timeout
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * aio_run_iocbs:&n; * &t;Process all pending retries queued on the ioctx&n; * &t;run list.&n; * Assumes it is operating within the aio issuer&squot;s mm&n; * context.&n; */
DECL|function|aio_run_iocbs
r_static
r_inline
r_void
id|aio_run_iocbs
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
r_int
id|requeue
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|requeue
op_assign
id|__aio_run_iocbs
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|requeue
)paren
id|aio_queue_work
c_func
(paren
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * just like aio_run_iocbs, but keeps running them until&n; * the list stays empty&n; */
DECL|function|aio_run_all_iocbs
r_static
r_inline
r_void
id|aio_run_all_iocbs
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|__aio_run_iocbs
c_func
(paren
id|ctx
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * aio_kick_handler:&n; * &t;Work queue handler triggered to process pending&n; * &t;retries on an ioctx. Takes on the aio issuer&squot;s&n; *&t;mm context before running the iocbs, so that&n; *&t;copy_xxx_user operates on the issuer&squot;s address&n; *      space.&n; * Run on aiod&squot;s context.&n; */
DECL|function|aio_kick_handler
r_static
r_void
id|aio_kick_handler
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|data
suffix:semicolon
id|mm_segment_t
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
r_int
id|requeue
suffix:semicolon
id|set_fs
c_func
(paren
id|USER_DS
)paren
suffix:semicolon
id|use_mm
c_func
(paren
id|ctx-&gt;mm
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|requeue
op_assign
id|__aio_run_iocbs
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unuse_mm
c_func
(paren
id|ctx-&gt;mm
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we&squot;re in a worker thread already, don&squot;t use queue_delayed_work,&n;&t; */
r_if
c_cond
(paren
id|requeue
)paren
id|queue_work
c_func
(paren
id|aio_wq
comma
op_amp
id|ctx-&gt;wq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by kick_iocb to queue the kiocb for retry&n; * and if required activate the aio work queue to process&n; * it&n; */
DECL|function|queue_kicked_iocb
r_void
id|queue_kicked_iocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|iocb-&gt;ki_ctx
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|run
op_assign
l_int|0
suffix:semicolon
id|WARN_ON
c_func
(paren
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|iocb-&gt;ki_wait.task_list
)paren
)paren
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
id|run
op_assign
id|__queue_kicked_iocb
c_func
(paren
id|iocb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|run
)paren
(brace
id|aio_queue_work
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|aio_wakeups
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * kick_iocb:&n; *      Called typically from a wait queue callback context&n; *      (aio_wake_function) to trigger a retry of the iocb.&n; *      The retry is usually executed by aio workqueue&n; *      threads (See aio_kick_handler).&n; */
DECL|function|kick_iocb
r_void
id|fastcall
id|kick_iocb
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
multiline_comment|/* sync iocbs are easy: they can only ever be executing from a &n;&t; * single context. */
r_if
c_cond
(paren
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
)paren
(brace
id|kiocbSetKicked
c_func
(paren
id|iocb
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|iocb-&gt;ki_obj.tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|iocb-&gt;ki_kicked
op_increment
suffix:semicolon
multiline_comment|/* If its already kicked we shouldn&squot;t queue it again */
r_if
c_cond
(paren
op_logical_neg
id|kiocbTryKick
c_func
(paren
id|iocb
)paren
)paren
(brace
id|queue_kicked_iocb
c_func
(paren
id|iocb
)paren
suffix:semicolon
)brace
)brace
DECL|variable|kick_iocb
id|EXPORT_SYMBOL
c_func
(paren
id|kick_iocb
)paren
suffix:semicolon
multiline_comment|/* aio_complete&n; *&t;Called when the io request on the given iocb is complete.&n; *&t;Returns true if this is the last user of the request.  The &n; *&t;only other user of the request can be the cancellation code.&n; */
DECL|function|aio_complete
r_int
id|fastcall
id|aio_complete
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_int
id|res
comma
r_int
id|res2
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
op_assign
id|iocb-&gt;ki_ctx
suffix:semicolon
r_struct
id|aio_ring_info
op_star
id|info
suffix:semicolon
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_struct
id|io_event
op_star
id|event
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|tail
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Special case handling for sync iocbs: events go directly&n;&t; * into the iocb for fast handling.  Note that this will not &n;&t; * work if we allow sync kiocbs to be cancelled. in which&n;&t; * case the usage count checks will have to move under ctx_lock&n;&t; * for all cases.&n;&t; */
r_if
c_cond
(paren
id|is_sync_kiocb
c_func
(paren
id|iocb
)paren
)paren
(brace
r_int
id|ret
suffix:semicolon
id|iocb-&gt;ki_user_data
op_assign
id|res
suffix:semicolon
r_if
c_cond
(paren
id|iocb-&gt;ki_users
op_eq
l_int|1
)paren
(brace
id|iocb-&gt;ki_users
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|iocb-&gt;ki_users
op_decrement
suffix:semicolon
id|ret
op_assign
(paren
l_int|0
op_eq
id|iocb-&gt;ki_users
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* sync iocbs put the task here for us */
id|wake_up_process
c_func
(paren
id|iocb-&gt;ki_obj.tsk
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|info
op_assign
op_amp
id|ctx-&gt;ring_info
suffix:semicolon
multiline_comment|/* add a completion event to the ring buffer.&n;&t; * must be done holding ctx-&gt;ctx_lock to prevent&n;&t; * other code from messing with the tail&n;&t; * pointer since we might be called from irq&n;&t; * context.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iocb-&gt;ki_run_list.prev
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
)paren
)paren
id|list_del_init
c_func
(paren
op_amp
id|iocb-&gt;ki_run_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * cancelled requests don&squot;t get events, userland was given one&n;&t; * when the event got cancelled.&n;&t; */
r_if
c_cond
(paren
id|kiocbIsCancelled
c_func
(paren
id|iocb
)paren
)paren
r_goto
id|put_rq
suffix:semicolon
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|info-&gt;ring_pages
(braket
l_int|0
)braket
comma
id|KM_IRQ1
)paren
suffix:semicolon
id|tail
op_assign
id|info-&gt;tail
suffix:semicolon
id|event
op_assign
id|aio_ring_event
c_func
(paren
id|info
comma
id|tail
comma
id|KM_IRQ0
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_mod
id|info-&gt;nr
suffix:semicolon
id|event-&gt;obj
op_assign
(paren
id|u64
)paren
(paren
r_int
r_int
)paren
id|iocb-&gt;ki_obj.user
suffix:semicolon
id|event-&gt;data
op_assign
id|iocb-&gt;ki_user_data
suffix:semicolon
id|event-&gt;res
op_assign
id|res
suffix:semicolon
id|event-&gt;res2
op_assign
id|res2
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio_complete: %p[%lu]: %p: %p %Lx %lx %lx&bslash;n&quot;
comma
id|ctx
comma
id|tail
comma
id|iocb
comma
id|iocb-&gt;ki_obj.user
comma
id|iocb-&gt;ki_user_data
comma
id|res
comma
id|res2
)paren
suffix:semicolon
multiline_comment|/* after flagging the request as done, we&n;&t; * must never even look at it again&n;&t; */
id|smp_wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make event visible before updating tail */
id|info-&gt;tail
op_assign
id|tail
suffix:semicolon
id|ring-&gt;tail
op_assign
id|tail
suffix:semicolon
id|put_aio_ring_event
c_func
(paren
id|event
comma
id|KM_IRQ0
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_IRQ1
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;added to ring %p at [%lu]&bslash;n&quot;
comma
id|iocb
comma
id|tail
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;%ld retries: %d of %d (kicked %ld, Q %ld run %ld wake %ld)&bslash;n&quot;
comma
id|iocb-&gt;ki_retried
comma
id|iocb-&gt;ki_nbytes
op_minus
id|iocb-&gt;ki_left
comma
id|iocb-&gt;ki_nbytes
comma
id|iocb-&gt;ki_kicked
comma
id|iocb-&gt;ki_queued
comma
id|aio_run
comma
id|aio_wakeups
)paren
suffix:semicolon
id|put_rq
suffix:colon
multiline_comment|/* everything turned out well, dispose of the aiocb. */
id|ret
op_assign
id|__aio_put_req
c_func
(paren
id|ctx
comma
id|iocb
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ctx-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* aio_read_evt&n; *&t;Pull an event off of the ioctx&squot;s event ring.  Returns the number of &n; *&t;events fetched (0 or 1 ;-)&n; *&t;FIXME: make this use cmpxchg.&n; *&t;TODO: make the ringbuffer user mmap()able (requires FIXME).&n; */
DECL|function|aio_read_evt
r_static
r_int
id|aio_read_evt
c_func
(paren
r_struct
id|kioctx
op_star
id|ioctx
comma
r_struct
id|io_event
op_star
id|ent
)paren
(brace
r_struct
id|aio_ring_info
op_star
id|info
op_assign
op_amp
id|ioctx-&gt;ring_info
suffix:semicolon
r_struct
id|aio_ring
op_star
id|ring
suffix:semicolon
r_int
r_int
id|head
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ring
op_assign
id|kmap_atomic
c_func
(paren
id|info-&gt;ring_pages
(braket
l_int|0
)braket
comma
id|KM_USER0
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;in aio_read_evt h%lu t%lu m%lu&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ring-&gt;head
comma
(paren
r_int
r_int
)paren
id|ring-&gt;tail
comma
(paren
r_int
r_int
)paren
id|ring-&gt;nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ring-&gt;head
op_eq
id|ring-&gt;tail
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;ring_lock
)paren
suffix:semicolon
id|head
op_assign
id|ring-&gt;head
op_mod
id|info-&gt;nr
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
id|ring-&gt;tail
)paren
(brace
r_struct
id|io_event
op_star
id|evp
op_assign
id|aio_ring_event
c_func
(paren
id|info
comma
id|head
comma
id|KM_USER1
)paren
suffix:semicolon
op_star
id|ent
op_assign
op_star
id|evp
suffix:semicolon
id|head
op_assign
(paren
id|head
op_plus
l_int|1
)paren
op_mod
id|info-&gt;nr
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* finish reading the event before updatng the head */
id|ring-&gt;head
op_assign
id|head
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
id|put_aio_ring_event
c_func
(paren
id|evp
comma
id|KM_USER1
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;ring_lock
)paren
suffix:semicolon
id|out
suffix:colon
id|kunmap_atomic
c_func
(paren
id|ring
comma
id|KM_USER0
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;leaving aio_read_evt: %d  h%lu t%lu&bslash;n&quot;
comma
id|ret
comma
(paren
r_int
r_int
)paren
id|ring-&gt;head
comma
(paren
r_int
r_int
)paren
id|ring-&gt;tail
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|struct|aio_timeout
r_struct
id|aio_timeout
(brace
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
DECL|member|timed_out
r_int
id|timed_out
suffix:semicolon
DECL|member|p
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
)brace
suffix:semicolon
DECL|function|timeout_func
r_static
r_void
id|timeout_func
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|aio_timeout
op_star
id|to
op_assign
(paren
r_struct
id|aio_timeout
op_star
)paren
id|data
suffix:semicolon
id|to-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
id|wake_up_process
c_func
(paren
id|to-&gt;p
)paren
suffix:semicolon
)brace
DECL|function|init_timeout
r_static
r_inline
r_void
id|init_timeout
c_func
(paren
r_struct
id|aio_timeout
op_star
id|to
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|to-&gt;timer
)paren
suffix:semicolon
id|to-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|to
suffix:semicolon
id|to-&gt;timer.function
op_assign
id|timeout_func
suffix:semicolon
id|to-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
id|to-&gt;p
op_assign
id|current
suffix:semicolon
)brace
DECL|function|set_timeout
r_static
r_inline
r_void
id|set_timeout
c_func
(paren
r_int
id|start_jiffies
comma
r_struct
id|aio_timeout
op_star
id|to
comma
r_const
r_struct
id|timespec
op_star
id|ts
)paren
(brace
id|to-&gt;timer.expires
op_assign
id|start_jiffies
op_plus
id|timespec_to_jiffies
c_func
(paren
id|ts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|to-&gt;timer.expires
comma
id|jiffies
)paren
)paren
id|add_timer
c_func
(paren
op_amp
id|to-&gt;timer
)paren
suffix:semicolon
r_else
id|to-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|clear_timeout
r_static
r_inline
r_void
id|clear_timeout
c_func
(paren
r_struct
id|aio_timeout
op_star
id|to
)paren
(brace
id|del_singleshot_timer_sync
c_func
(paren
op_amp
id|to-&gt;timer
)paren
suffix:semicolon
)brace
DECL|function|read_events
r_static
r_int
id|read_events
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_int
id|min_nr
comma
r_int
id|nr
comma
r_struct
id|io_event
id|__user
op_star
id|event
comma
r_struct
id|timespec
id|__user
op_star
id|timeout
)paren
(brace
r_int
id|start_jiffies
op_assign
id|jiffies
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_struct
id|io_event
id|ent
suffix:semicolon
r_struct
id|aio_timeout
id|to
suffix:semicolon
r_int
id|event_loop
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* testing only */
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* needed to zero any padding within an entry (there shouldn&squot;t be &n;&t; * any, but C is fun!&n;&t; */
id|memset
c_func
(paren
op_amp
id|ent
comma
l_int|0
comma
r_sizeof
(paren
id|ent
)paren
)paren
suffix:semicolon
id|retry
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|likely
c_func
(paren
id|i
OL
id|nr
)paren
)paren
(brace
id|ret
op_assign
id|aio_read_evt
c_func
(paren
id|ctx
comma
op_amp
id|ent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
op_le
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;read event: %Lx %Lx %Lx %Lx&bslash;n&quot;
comma
id|ent.data
comma
id|ent.obj
comma
id|ent.res
comma
id|ent.res2
)paren
suffix:semicolon
multiline_comment|/* Could we split the check in two? */
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_to_user
c_func
(paren
id|event
comma
op_amp
id|ent
comma
r_sizeof
(paren
id|ent
)paren
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;aio: lost an event due to EFAULT.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Good, event copied to userland, update counts. */
id|event
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|min_nr
op_le
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* End fast path */
multiline_comment|/* racey check, but it gets redone */
r_if
c_cond
(paren
op_logical_neg
id|retry
op_logical_and
id|unlikely
c_func
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ctx-&gt;run_list
)paren
)paren
)paren
(brace
id|retry
op_assign
l_int|1
suffix:semicolon
id|aio_run_all_iocbs
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|init_timeout
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
(brace
r_struct
id|timespec
id|ts
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_from_user
c_func
(paren
op_amp
id|ts
comma
id|timeout
comma
r_sizeof
(paren
id|ts
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|set_timeout
c_func
(paren
id|start_jiffies
comma
op_amp
id|to
comma
op_amp
id|ts
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|likely
c_func
(paren
id|i
OL
id|nr
)paren
)paren
(brace
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_do
(brace
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|ret
op_assign
id|aio_read_evt
c_func
(paren
id|ctx
comma
op_amp
id|ent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|min_nr
op_le
id|i
)paren
r_break
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|to.timed_out
)paren
multiline_comment|/* Only check after read evt */
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|event_loop
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*ret = aio_read_evt(ctx, &amp;ent);*/
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ctx-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
op_le
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_to_user
c_func
(paren
id|event
comma
op_amp
id|ent
comma
r_sizeof
(paren
id|ent
)paren
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;aio: lost an event due to EFAULT.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Good, event copied to userland, update counts. */
id|event
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
id|clear_timeout
c_func
(paren
op_amp
id|to
)paren
suffix:semicolon
id|out
suffix:colon
id|pr_debug
c_func
(paren
l_string|&quot;event loop executed %d times&bslash;n&quot;
comma
id|event_loop
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;aio_run %ld&bslash;n&quot;
comma
id|aio_run
)paren
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;aio_wakeups %ld&bslash;n&quot;
comma
id|aio_wakeups
)paren
suffix:semicolon
r_return
id|i
ques
c_cond
id|i
suffix:colon
id|ret
suffix:semicolon
)brace
multiline_comment|/* Take an ioctx and remove it from the list of ioctx&squot;s.  Protects &n; * against races with itself via -&gt;dead.&n; */
DECL|function|io_destroy
r_static
r_void
id|io_destroy
c_func
(paren
r_struct
id|kioctx
op_star
id|ioctx
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_struct
id|kioctx
op_star
op_star
id|tmp
suffix:semicolon
r_int
id|was_dead
suffix:semicolon
multiline_comment|/* delete the entry from the list is someone else hasn&squot;t already */
id|write_lock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|was_dead
op_assign
id|ioctx-&gt;dead
suffix:semicolon
id|ioctx-&gt;dead
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
op_amp
id|mm-&gt;ioctx_list
suffix:semicolon
op_star
id|tmp
op_logical_and
op_star
id|tmp
op_ne
id|ioctx
suffix:semicolon
id|tmp
op_assign
op_amp
(paren
op_star
id|tmp
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|tmp
)paren
op_star
id|tmp
op_assign
id|ioctx-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|mm-&gt;ioctx_list_lock
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;aio_release(%p)&bslash;n&quot;
comma
id|ioctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|was_dead
)paren
)paren
id|put_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
multiline_comment|/* twice for the list */
id|aio_cancel_all
c_func
(paren
id|ioctx
)paren
suffix:semicolon
id|wait_for_all_aios
c_func
(paren
id|ioctx
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
multiline_comment|/* once for the lookup */
)brace
multiline_comment|/* sys_io_setup:&n; *&t;Create an aio_context capable of receiving at least nr_events.&n; *&t;ctxp must not point to an aio_context that already exists, and&n; *&t;must be initialized to 0 prior to the call.  On successful&n; *&t;creation of the aio_context, *ctxp is filled in with the resulting &n; *&t;handle.  May fail with -EINVAL if *ctxp is not initialized,&n; *&t;if the specified nr_events exceeds internal limits.  May fail &n; *&t;with -EAGAIN if the specified nr_events exceeds the user&squot;s limit &n; *&t;of available events.  May fail with -ENOMEM if insufficient kernel&n; *&t;resources are available.  May fail with -EFAULT if an invalid&n; *&t;pointer is passed for ctxp.  Will fail with -ENOSYS if not&n; *&t;implemented.&n; */
DECL|function|sys_io_setup
id|asmlinkage
r_int
id|sys_io_setup
c_func
(paren
r_int
id|nr_events
comma
id|aio_context_t
id|__user
op_star
id|ctxp
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|ctx
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|get_user
c_func
(paren
id|ctx
comma
id|ctxp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ctx
op_logical_or
(paren
r_int
)paren
id|nr_events
op_le
l_int|0
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_setup: ctx or nr_events &gt; max&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ioctx
op_assign
id|ioctx_alloc
c_func
(paren
id|nr_events
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|ioctx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|ioctx
)paren
)paren
(brace
id|ret
op_assign
id|put_user
c_func
(paren
id|ioctx-&gt;user_id
comma
id|ctxp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_return
l_int|0
suffix:semicolon
id|io_destroy
c_func
(paren
id|ioctx
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* sys_io_destroy:&n; *&t;Destroy the aio_context specified.  May cancel any outstanding &n; *&t;AIOs and block on completion.  Will fail with -ENOSYS if not&n; *&t;implemented.  May fail with -EFAULT if the context pointed to&n; *&t;is invalid.&n; */
DECL|function|sys_io_destroy
id|asmlinkage
r_int
id|sys_io_destroy
c_func
(paren
id|aio_context_t
id|ctx
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
l_int|NULL
op_ne
id|ioctx
)paren
)paren
(brace
id|io_destroy
c_func
(paren
id|ioctx
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_destroy: invalid context id&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Default retry method for aio_read (also used for first time submit)&n; * Responsible for updating iocb state as retries progress&n; */
DECL|function|aio_pread
r_static
id|ssize_t
id|aio_pread
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_read
c_func
(paren
id|iocb
comma
id|iocb-&gt;ki_buf
comma
id|iocb-&gt;ki_left
comma
id|iocb-&gt;ki_pos
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Can&squot;t just depend on iocb-&gt;ki_left to determine&n;&t; * whether we are done. This may have been a short read.&n;&t; */
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
(brace
id|iocb-&gt;ki_buf
op_add_assign
id|ret
suffix:semicolon
id|iocb-&gt;ki_left
op_sub_assign
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For pipes and sockets we return once we have&n;&t;&t; * some data; for regular files we retry till we&n;&t;&t; * complete the entire read or find that we can&squot;t&n;&t;&t; * read any more data (e.g short reads).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|S_ISSOCK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|ret
op_assign
op_minus
id|EIOCBRETRY
suffix:semicolon
)brace
multiline_comment|/* This means we must have transferred all that we could */
multiline_comment|/* No need to retry anymore */
r_if
c_cond
(paren
(paren
id|ret
op_eq
l_int|0
)paren
op_logical_or
(paren
id|iocb-&gt;ki_left
op_eq
l_int|0
)paren
)paren
id|ret
op_assign
id|iocb-&gt;ki_nbytes
op_minus
id|iocb-&gt;ki_left
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Default retry method for aio_write (also used for first time submit)&n; * Responsible for updating iocb state as retries progress&n; */
DECL|function|aio_pwrite
r_static
id|ssize_t
id|aio_pwrite
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_write
c_func
(paren
id|iocb
comma
id|iocb-&gt;ki_buf
comma
id|iocb-&gt;ki_left
comma
id|iocb-&gt;ki_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
(brace
id|iocb-&gt;ki_buf
op_add_assign
id|ret
suffix:semicolon
id|iocb-&gt;ki_left
op_sub_assign
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|EIOCBRETRY
suffix:semicolon
)brace
multiline_comment|/* This means we must have transferred all that we could */
multiline_comment|/* No need to retry anymore */
r_if
c_cond
(paren
(paren
id|ret
op_eq
l_int|0
)paren
op_logical_or
(paren
id|iocb-&gt;ki_left
op_eq
l_int|0
)paren
)paren
id|ret
op_assign
id|iocb-&gt;ki_nbytes
op_minus
id|iocb-&gt;ki_left
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|aio_fdsync
r_static
id|ssize_t
id|aio_fdsync
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
id|ssize_t
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_fsync
)paren
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_fsync
c_func
(paren
id|iocb
comma
l_int|1
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|aio_fsync
r_static
id|ssize_t
id|aio_fsync
c_func
(paren
r_struct
id|kiocb
op_star
id|iocb
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
id|ssize_t
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_fsync
)paren
id|ret
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|aio_fsync
c_func
(paren
id|iocb
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * aio_setup_iocb:&n; *&t;Performs the initial checks and aio retry method&n; *&t;setup for the kiocb at the time of io submission.&n; */
DECL|function|aio_setup_iocb
id|ssize_t
id|aio_setup_iocb
c_func
(paren
r_struct
id|kiocb
op_star
id|kiocb
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|kiocb-&gt;ki_filp
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|kiocb-&gt;ki_opcode
)paren
(brace
r_case
id|IOCB_CMD_PREAD
suffix:colon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|kiocb-&gt;ki_buf
comma
id|kiocb-&gt;ki_left
)paren
)paren
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_read
)paren
id|kiocb-&gt;ki_retry
op_assign
id|aio_pread
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCB_CMD_PWRITE
suffix:colon
id|ret
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|kiocb-&gt;ki_buf
comma
id|kiocb-&gt;ki_left
)paren
)paren
)paren
r_break
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_write
)paren
id|kiocb-&gt;ki_retry
op_assign
id|aio_pwrite
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCB_CMD_FDSYNC
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_fsync
)paren
id|kiocb-&gt;ki_retry
op_assign
id|aio_fdsync
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IOCB_CMD_FSYNC
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;aio_fsync
)paren
id|kiocb-&gt;ki_retry
op_assign
id|aio_fsync
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;EINVAL: io_submit: no operation provided&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|kiocb-&gt;ki_retry
)paren
r_return
id|ret
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * aio_wake_function:&n; * &t;wait queue callback function for aio notification,&n; * &t;Simply triggers a retry of the operation via kick_iocb.&n; *&n; * &t;This callback is specified in the wait queue entry in&n; *&t;a kiocb&t;(current-&gt;io_wait points to this wait queue&n; *&t;entry when an aio operation executes; it is used&n; * &t;instead of a synchronous wait when an i/o blocking&n; *&t;condition is encountered during aio).&n; *&n; * Note:&n; * This routine is executed with the wait queue lock held.&n; * Since kick_iocb acquires iocb-&gt;ctx-&gt;ctx_lock, it nests&n; * the ioctx lock inside the wait queue lock. This is safe&n; * because this callback isn&squot;t used for wait queues which&n; * are nested inside ioctx lock (i.e. ctx-&gt;wait)&n; */
DECL|function|aio_wake_function
r_int
id|aio_wake_function
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
comma
r_void
op_star
id|key
)paren
(brace
r_struct
id|kiocb
op_star
id|iocb
op_assign
id|container_of
c_func
(paren
id|wait
comma
r_struct
id|kiocb
comma
id|ki_wait
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|wait-&gt;task_list
)paren
suffix:semicolon
id|kick_iocb
c_func
(paren
id|iocb
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|io_submit_one
r_int
id|fastcall
id|io_submit_one
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|iocb
id|__user
op_star
id|user_iocb
comma
r_struct
id|iocb
op_star
id|iocb
)paren
(brace
r_struct
id|kiocb
op_star
id|req
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
multiline_comment|/* enforce forwards compatibility on users */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|iocb-&gt;aio_reserved1
op_logical_or
id|iocb-&gt;aio_reserved2
op_logical_or
id|iocb-&gt;aio_reserved3
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_submit: reserve field set&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* prevent overflows */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|iocb-&gt;aio_buf
op_ne
(paren
r_int
r_int
)paren
id|iocb-&gt;aio_buf
)paren
op_logical_or
(paren
id|iocb-&gt;aio_nbytes
op_ne
(paren
r_int
)paren
id|iocb-&gt;aio_nbytes
)paren
op_logical_or
(paren
(paren
id|ssize_t
)paren
id|iocb-&gt;aio_nbytes
OL
l_int|0
)paren
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_submit: overflow check&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|file
op_assign
id|fget
c_func
(paren
id|iocb-&gt;aio_fildes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|file
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|req
op_assign
id|aio_get_req
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* returns with 2 references to req */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|req
)paren
)paren
(brace
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|req-&gt;ki_filp
op_assign
id|file
suffix:semicolon
id|iocb-&gt;aio_key
op_assign
id|req-&gt;ki_key
suffix:semicolon
id|ret
op_assign
id|put_user
c_func
(paren
id|iocb-&gt;aio_key
comma
op_amp
id|user_iocb-&gt;aio_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;EFAULT: aio_key&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_put_req
suffix:semicolon
)brace
id|req-&gt;ki_obj.user
op_assign
id|user_iocb
suffix:semicolon
id|req-&gt;ki_user_data
op_assign
id|iocb-&gt;aio_data
suffix:semicolon
id|req-&gt;ki_pos
op_assign
id|iocb-&gt;aio_offset
suffix:semicolon
id|req-&gt;ki_buf
op_assign
(paren
r_char
id|__user
op_star
)paren
(paren
r_int
r_int
)paren
id|iocb-&gt;aio_buf
suffix:semicolon
id|req-&gt;ki_left
op_assign
id|req-&gt;ki_nbytes
op_assign
id|iocb-&gt;aio_nbytes
suffix:semicolon
id|req-&gt;ki_opcode
op_assign
id|iocb-&gt;aio_lio_opcode
suffix:semicolon
id|init_waitqueue_func_entry
c_func
(paren
op_amp
id|req-&gt;ki_wait
comma
id|aio_wake_function
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|req-&gt;ki_wait.task_list
)paren
suffix:semicolon
id|req-&gt;ki_run_list.next
op_assign
id|req-&gt;ki_run_list.prev
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_retry
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;ki_retried
op_assign
l_int|0
suffix:semicolon
id|req-&gt;ki_kicked
op_assign
l_int|0
suffix:semicolon
id|req-&gt;ki_queued
op_assign
l_int|0
suffix:semicolon
id|aio_run
op_assign
l_int|0
suffix:semicolon
id|aio_wakeups
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|aio_setup_iocb
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_put_req
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;ki_run_list
comma
op_amp
id|ctx-&gt;run_list
)paren
suffix:semicolon
multiline_comment|/* drain the run list */
r_while
c_loop
(paren
id|__aio_run_iocbs
c_func
(paren
id|ctx
)paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|aio_put_req
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* drop extra ref to req */
r_return
l_int|0
suffix:semicolon
id|out_put_req
suffix:colon
id|aio_put_req
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* drop extra ref to req */
id|aio_put_req
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* drop i/o ref to req */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* sys_io_submit:&n; *&t;Queue the nr iocbs pointed to by iocbpp for processing.  Returns&n; *&t;the number of iocbs queued.  May return -EINVAL if the aio_context&n; *&t;specified by ctx_id is invalid, if nr is &lt; 0, if the iocb at&n; *&t;*iocbpp[0] is not properly initialized, if the operation specified&n; *&t;is invalid for the file descriptor in the iocb.  May fail with&n; *&t;-EFAULT if any of the data structures point to invalid data.  May&n; *&t;fail with -EBADF if the file descriptor specified in the first&n; *&t;iocb is invalid.  May fail with -EAGAIN if insufficient resources&n; *&t;are available to queue any iocbs.  Will return 0 if nr is 0.  Will&n; *&t;fail with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_submit
id|asmlinkage
r_int
id|sys_io_submit
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
id|nr
comma
r_struct
id|iocb
id|__user
op_star
id|__user
op_star
id|iocbpp
)paren
(brace
r_struct
id|kioctx
op_star
id|ctx
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|nr
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|iocbpp
comma
(paren
id|nr
op_star
r_sizeof
(paren
op_star
id|iocbpp
)paren
)paren
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|pr_debug
c_func
(paren
l_string|&quot;EINVAL: io_submit: invalid context id&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * AKPM: should this return a partial result if some of the IOs were&n;&t; * successfully submitted?&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|iocb
id|__user
op_star
id|user_iocb
suffix:semicolon
r_struct
id|iocb
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|__get_user
c_func
(paren
id|user_iocb
comma
id|iocbpp
op_plus
id|i
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user_iocb
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret
op_assign
id|io_submit_one
c_func
(paren
id|ctx
comma
id|user_iocb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
)brace
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|i
ques
c_cond
id|i
suffix:colon
id|ret
suffix:semicolon
)brace
multiline_comment|/* lookup_kiocb&n; *&t;Finds a given iocb for cancellation.&n; *&t;MUST be called with ctx-&gt;ctx_lock held.&n; */
DECL|function|lookup_kiocb
r_struct
id|kiocb
op_star
id|lookup_kiocb
c_func
(paren
r_struct
id|kioctx
op_star
id|ctx
comma
r_struct
id|iocb
id|__user
op_star
id|iocb
comma
id|u32
id|key
)paren
(brace
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
multiline_comment|/* TODO: use a hash or array, this sucks. */
id|list_for_each
c_func
(paren
id|pos
comma
op_amp
id|ctx-&gt;active_reqs
)paren
(brace
r_struct
id|kiocb
op_star
id|kiocb
op_assign
id|list_kiocb
c_func
(paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kiocb-&gt;ki_obj.user
op_eq
id|iocb
op_logical_and
id|kiocb-&gt;ki_key
op_eq
id|key
)paren
r_return
id|kiocb
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* sys_io_cancel:&n; *&t;Attempts to cancel an iocb previously passed to io_submit.  If&n; *&t;the operation is successfully cancelled, the resulting event is&n; *&t;copied into the memory pointed to by result without being placed&n; *&t;into the completion queue and 0 is returned.  May fail with&n; *&t;-EFAULT if any of the data structures pointed to are invalid.&n; *&t;May fail with -EINVAL if aio_context specified by ctx_id is&n; *&t;invalid.  May fail with -EAGAIN if the iocb specified was not&n; *&t;cancelled.  Will fail with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_cancel
id|asmlinkage
r_int
id|sys_io_cancel
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_struct
id|iocb
id|__user
op_star
id|iocb
comma
r_struct
id|io_event
id|__user
op_star
id|result
)paren
(brace
r_int
(paren
op_star
id|cancel
)paren
(paren
r_struct
id|kiocb
op_star
id|iocb
comma
r_struct
id|io_event
op_star
id|res
)paren
suffix:semicolon
r_struct
id|kioctx
op_star
id|ctx
suffix:semicolon
r_struct
id|kiocb
op_star
id|kiocb
suffix:semicolon
id|u32
id|key
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|get_user
c_func
(paren
id|key
comma
op_amp
id|iocb-&gt;aio_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|kiocb
op_assign
id|lookup_kiocb
c_func
(paren
id|ctx
comma
id|iocb
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kiocb
op_logical_and
id|kiocb-&gt;ki_cancel
)paren
(brace
id|cancel
op_assign
id|kiocb-&gt;ki_cancel
suffix:semicolon
id|kiocb-&gt;ki_users
op_increment
suffix:semicolon
id|kiocbSetCancelled
c_func
(paren
id|kiocb
)paren
suffix:semicolon
)brace
r_else
id|cancel
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|ctx-&gt;ctx_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|cancel
)paren
(brace
r_struct
id|io_event
id|tmp
suffix:semicolon
id|pr_debug
c_func
(paren
l_string|&quot;calling cancel&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|tmp.obj
op_assign
(paren
id|u64
)paren
(paren
r_int
r_int
)paren
id|kiocb-&gt;ki_obj.user
suffix:semicolon
id|tmp.data
op_assign
id|kiocb-&gt;ki_user_data
suffix:semicolon
id|ret
op_assign
id|cancel
c_func
(paren
id|kiocb
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/* Cancellation succeeded -- copy the result&n;&t;&t;&t; * into the user&squot;s buffer.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|result
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;iocb has no cancel operation&bslash;n&quot;
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* io_getevents:&n; *&t;Attempts to read at least min_nr events and up to nr events from&n; *&t;the completion queue for the aio_context specified by ctx_id.  May&n; *&t;fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,&n; *&t;if nr is out of range, if when is out of range.  May fail with&n; *&t;-EFAULT if any of the memory specified to is invalid.  May return&n; *&t;0 or &lt; min_nr if no events are available and the timeout specified&n; *&t;by when&t;has elapsed, where when == NULL specifies an infinite&n; *&t;timeout.  Note that the timeout pointed to by when is relative and&n; *&t;will be updated if not NULL and the operation blocks.  Will fail&n; *&t;with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_getevents
id|asmlinkage
r_int
id|sys_io_getevents
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
id|min_nr
comma
r_int
id|nr
comma
r_struct
id|io_event
id|__user
op_star
id|events
comma
r_struct
id|timespec
id|__user
op_star
id|timeout
)paren
(brace
r_struct
id|kioctx
op_star
id|ioctx
op_assign
id|lookup_ioctx
c_func
(paren
id|ctx_id
)paren
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ioctx
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|min_nr
op_le
id|nr
op_logical_and
id|min_nr
op_ge
l_int|0
op_logical_and
id|nr
op_ge
l_int|0
)paren
)paren
id|ret
op_assign
id|read_events
c_func
(paren
id|ioctx
comma
id|min_nr
comma
id|nr
comma
id|events
comma
id|timeout
)paren
suffix:semicolon
id|put_ioctx
c_func
(paren
id|ioctx
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|aio_setup
id|__initcall
c_func
(paren
id|aio_setup
)paren
suffix:semicolon
DECL|variable|aio_complete
id|EXPORT_SYMBOL
c_func
(paren
id|aio_complete
)paren
suffix:semicolon
DECL|variable|aio_put_req
id|EXPORT_SYMBOL
c_func
(paren
id|aio_put_req
)paren
suffix:semicolon
DECL|variable|wait_on_sync_kiocb
id|EXPORT_SYMBOL
c_func
(paren
id|wait_on_sync_kiocb
)paren
suffix:semicolon
eof
