multiline_comment|/*&n; *&t;An async IO implementation for Linux&n; *&t;Written by Benjamin LaHaise &lt;bcrl@redhat.com&gt;&n; *&n; *&t;Implements an efficient asynchronous io interface.&n; *&n; *&t;Copyright 2000, 2001, 2002 Red Hat, Inc.  All Rights Reserved.&n; *&n; *&t;See ../COPYING for licensing terms.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/aio_abi.h&gt;
multiline_comment|/* io_setup:&n; *&t;Create an aio_context capable of receiving at least nr_events.&n; *&t;ctxp must not point to an aio_context that already exists, and&n; *&t;must be initialized to 0 prior to the call.  On successful&n; *&t;creation of the aio_context, *ctxp is filled in with the resulting &n; *&t;handle.  May fail with -EINVAL if *ctxp is not initialized,&n; *&t;if the specified nr_events exceeds internal limits.  May fail &n; *&t;with -EAGAIN if the specified nr_events exceeds the user&squot;s limit &n; *&t;of available events.  May fail with -ENOMEM if insufficient kernel&n; *&t;resources are available.  May fail with -EFAULT if an invalid&n; *&t;pointer is passed for ctxp.  Will fail with -ENOSYS if not&n; *&t;implemented.&n; */
DECL|function|sys_io_setup
id|asmlinkage
r_int
id|sys_io_setup
c_func
(paren
r_int
id|nr_events
comma
id|aio_context_t
op_star
id|ctxp
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
multiline_comment|/* io_destroy:&n; *&t;Destroy the aio_context specified.  May cancel any outstanding &n; *&t;AIOs and block on completion.  Will fail with -ENOSYS if not&n; *&t;implemented.  May fail with -EFAULT if the context pointed to&n; *&t;is invalid.&n; */
DECL|function|sys_io_destroy
id|asmlinkage
r_int
id|sys_io_destroy
c_func
(paren
id|aio_context_t
id|ctx
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
multiline_comment|/* io_submit:&n; *&t;Queue the nr iocbs pointed to by iocbpp for processing.  Returns&n; *&t;the number of iocbs queued.  May return -EINVAL if the aio_context&n; *&t;specified by ctx_id is invalid, if nr is &lt; 0, if the iocb at&n; *&t;*iocbpp[0] is not properly initialized, if the operation specified&n; *&t;is invalid for the file descriptor in the iocb.  May fail with&n; *&t;-EFAULT if any of the data structures point to invalid data.  May&n; *&t;fail with -EBADF if the file descriptor specified in the first&n; *&t;iocb is invalid.  May fail with -EAGAIN if insufficient resources&n; *&t;are available to queue any iocbs.  Will return 0 if nr is 0.  Will&n; *&t;fail with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_submit
id|asmlinkage
r_int
id|sys_io_submit
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
id|nr
comma
r_struct
id|iocb
op_star
op_star
id|iocbpp
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
multiline_comment|/* io_cancel:&n; *&t;Attempts to cancel an iocb previously passed to io_submit.  If&n; *&t;the operation is successfully cancelled, the resulting event is&n; *&t;copied into the memory pointed to by result without being placed&n; *&t;into the completion queue and 0 is returned.  May fail with&n; *&t;-EFAULT if any of the data structures pointed to are invalid.&n; *&t;May fail with -EINVAL if aio_context specified by ctx_id is&n; *&t;invalid.  May fail with -EAGAIN if the iocb specified was not&n; *&t;cancelled.  Will fail with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_cancel
id|asmlinkage
r_int
id|sys_io_cancel
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_struct
id|iocb
op_star
id|iocb
comma
r_struct
id|io_event
op_star
id|result
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
multiline_comment|/* io_getevents:&n; *&t;Attempts to read at least min_nr events and up to nr events from&n; *&t;the completion queue for the aio_context specified by ctx_id.  May&n; *&t;fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,&n; *&t;if nr is out of range, if when is out of range.  May fail with&n; *&t;-EFAULT if any of the memory specified to is invalid.  May return&n; *&t;0 or &lt; min_nr if no events are available and the timeout specified&n; *&t;by when&t;has elapsed, where when == NULL specifies an infinite&n; *&t;timeout.  Note that the timeout pointed to by when is relative and&n; *&t;will be updated if not NULL and the operation blocks.  Will fail&n; *&t;with -ENOSYS if not implemented.&n; */
DECL|function|sys_io_getevents
id|asmlinkage
r_int
id|sys_io_getevents
c_func
(paren
id|aio_context_t
id|ctx_id
comma
r_int
id|min_nr
comma
r_int
id|nr
comma
r_struct
id|io_event
op_star
id|events
comma
r_struct
id|timespec
op_star
id|when
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
eof
