multiline_comment|/*&n; * linux/fs/binfmt_elf.c&n; *&n; * These are the functions used to load ELF format executables as used&n; * on SVr4 machines.  Information on the format may be found in the book&n; * &quot;UNIX SYSTEM V RELEASE 4 Programmers Guide: Ansi C and Programming Support&n; * Tools&quot;.&n; *&n; * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/shm.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/elfcore.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highuid.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/compiler.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
r_static
r_int
id|load_elf_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|load_elf_library
c_func
(paren
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|elf_map
(paren
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_struct
id|elf_phdr
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|dump_fpu
(paren
r_struct
id|pt_regs
op_star
comma
id|elf_fpregset_t
op_star
)paren
suffix:semicolon
macro_line|#ifndef elf_addr_t
DECL|macro|elf_addr_t
mdefine_line|#define elf_addr_t unsigned long
macro_line|#endif
multiline_comment|/*&n; * If we don&squot;t support core dumping, then supply a NULL so we&n; * don&squot;t even try.&n; */
macro_line|#ifdef USE_ELF_CORE_DUMP
r_static
r_int
id|elf_core_dump
c_func
(paren
r_int
id|signr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
macro_line|#else
DECL|macro|elf_core_dump
mdefine_line|#define elf_core_dump&t;NULL
macro_line|#endif
macro_line|#if ELF_EXEC_PAGESIZE &gt; PAGE_SIZE
DECL|macro|ELF_MIN_ALIGN
macro_line|# define ELF_MIN_ALIGN&t;ELF_EXEC_PAGESIZE
macro_line|#else
DECL|macro|ELF_MIN_ALIGN
macro_line|# define ELF_MIN_ALIGN&t;PAGE_SIZE
macro_line|#endif
DECL|macro|ELF_PAGESTART
mdefine_line|#define ELF_PAGESTART(_v) ((_v) &amp; ~(unsigned long)(ELF_MIN_ALIGN-1))
DECL|macro|ELF_PAGEOFFSET
mdefine_line|#define ELF_PAGEOFFSET(_v) ((_v) &amp; (ELF_MIN_ALIGN-1))
DECL|macro|ELF_PAGEALIGN
mdefine_line|#define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) &amp; ~(ELF_MIN_ALIGN - 1))
DECL|variable|elf_format
r_static
r_struct
id|linux_binfmt
id|elf_format
op_assign
(brace
dot
id|module
op_assign
id|THIS_MODULE
comma
dot
id|load_binary
op_assign
id|load_elf_binary
comma
dot
id|load_shlib
op_assign
id|load_elf_library
comma
dot
id|core_dump
op_assign
id|elf_core_dump
comma
dot
id|min_coredump
op_assign
id|ELF_EXEC_PAGESIZE
)brace
suffix:semicolon
DECL|macro|BAD_ADDR
mdefine_line|#define BAD_ADDR(x)&t;((unsigned long)(x) &gt; TASK_SIZE)
DECL|function|set_brk
r_static
r_int
id|set_brk
c_func
(paren
r_int
r_int
id|start
comma
r_int
r_int
id|end
)paren
(brace
id|start
op_assign
id|ELF_PAGEALIGN
c_func
(paren
id|start
)paren
suffix:semicolon
id|end
op_assign
id|ELF_PAGEALIGN
c_func
(paren
id|end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|start
)paren
(brace
r_int
r_int
id|addr
op_assign
id|do_brk
c_func
(paren
id|start
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BAD_ADDR
c_func
(paren
id|addr
)paren
)paren
r_return
id|addr
suffix:semicolon
)brace
id|current-&gt;mm-&gt;start_brk
op_assign
id|current-&gt;mm-&gt;brk
op_assign
id|end
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We need to explicitly zero any fractional pages&n;   after the data section (i.e. bss).  This would&n;   contain the junk from the file that should not&n;   be in memory */
DECL|function|padzero
r_static
r_void
id|padzero
c_func
(paren
r_int
r_int
id|elf_bss
)paren
(brace
r_int
r_int
id|nbyte
suffix:semicolon
id|nbyte
op_assign
id|ELF_PAGEOFFSET
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nbyte
)paren
(brace
id|nbyte
op_assign
id|ELF_MIN_ALIGN
op_minus
id|nbyte
suffix:semicolon
id|clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|elf_bss
comma
id|nbyte
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Let&squot;s use some macros to make this stack manipulation a litle clearer */
macro_line|#ifdef CONFIG_STACK_GROWSUP
DECL|macro|STACK_ADD
mdefine_line|#define STACK_ADD(sp, items) ((elf_addr_t *)(sp) + (items))
DECL|macro|STACK_ROUND
mdefine_line|#define STACK_ROUND(sp, items) &bslash;&n;&t;((15 + (unsigned long) ((sp) + (items))) &amp;~ 15UL)
DECL|macro|STACK_ALLOC
mdefine_line|#define STACK_ALLOC(sp, len) ({ elf_addr_t *old_sp = (elf_addr_t *)sp; sp += len; old_sp; })
macro_line|#else
DECL|macro|STACK_ADD
mdefine_line|#define STACK_ADD(sp, items) ((elf_addr_t *)(sp) - (items))
DECL|macro|STACK_ROUND
mdefine_line|#define STACK_ROUND(sp, items) &bslash;&n;&t;(((unsigned long) (sp - items)) &amp;~ 15UL)
DECL|macro|STACK_ALLOC
mdefine_line|#define STACK_ALLOC(sp, len) sp -= len
macro_line|#endif
r_static
r_void
DECL|function|create_elf_tables
id|create_elf_tables
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|elfhdr
op_star
id|exec
comma
r_int
id|interp_aout
comma
r_int
r_int
id|load_addr
comma
r_int
r_int
id|interp_load_addr
)paren
(brace
r_int
r_int
id|p
op_assign
id|bprm-&gt;p
suffix:semicolon
r_int
id|argc
op_assign
id|bprm-&gt;argc
suffix:semicolon
r_int
id|envc
op_assign
id|bprm-&gt;envc
suffix:semicolon
id|elf_addr_t
op_star
id|argv
comma
op_star
id|envp
suffix:semicolon
id|elf_addr_t
op_star
id|sp
comma
op_star
id|u_platform
suffix:semicolon
r_const
r_char
op_star
id|k_platform
op_assign
id|ELF_PLATFORM
suffix:semicolon
r_int
id|items
suffix:semicolon
id|elf_addr_t
op_star
id|elf_info
suffix:semicolon
r_int
id|ei_index
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; * If this architecture has a platform capability string, copy it&n;&t; * to userspace.  In some cases (Sparc), this info is impossible&n;&t; * for userspace to get any other way, in others (i386) it is&n;&t; * merely difficult.&n;&t; */
id|u_platform
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|k_platform
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|k_platform
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_X86_HT
multiline_comment|/*&n;&t;&t; * In some cases (e.g. Hyper-Threading), we want to avoid L1&n;&t;&t; * evictions by the processes running on the same package. One&n;&t;&t; * thing we can do is to shuffle the initial stack for them.&n;&t;&t; *&n;&t;&t; * The conditionals here are unneeded, but kept in to make the&n;&t;&t; * code behaviour the same as pre change unless we have&n;&t;&t; * hyperthreaded processors. This should be cleaned up&n;&t;&t; * before 2.6&n;&t;&t; */
r_if
c_cond
(paren
id|smp_num_siblings
OG
l_int|1
)paren
id|STACK_ALLOC
c_func
(paren
id|p
comma
(paren
(paren
id|current-&gt;pid
op_mod
l_int|64
)paren
op_lshift
l_int|7
)paren
)paren
suffix:semicolon
macro_line|#endif
id|u_platform
op_assign
(paren
id|elf_addr_t
op_star
)paren
id|STACK_ALLOC
c_func
(paren
id|p
comma
id|len
)paren
suffix:semicolon
id|__copy_to_user
c_func
(paren
id|u_platform
comma
id|k_platform
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* Create the ELF interpreter info */
id|elf_info
op_assign
(paren
id|elf_addr_t
op_star
)paren
id|current-&gt;mm-&gt;saved_auxv
suffix:semicolon
DECL|macro|NEW_AUX_ENT
mdefine_line|#define NEW_AUX_ENT(id, val) &bslash;&n;&t;do { elf_info[ei_index++] = id; elf_info[ei_index++] = val; } while (0)
macro_line|#ifdef ARCH_DLINFO
multiline_comment|/* &n;&t; * ARCH_DLINFO must come first so PPC can do its special alignment of&n;&t; * AUXV.&n;&t; */
id|ARCH_DLINFO
suffix:semicolon
macro_line|#endif
id|NEW_AUX_ENT
c_func
(paren
id|AT_HWCAP
comma
id|ELF_HWCAP
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_PAGESZ
comma
id|ELF_EXEC_PAGESIZE
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_CLKTCK
comma
id|CLOCKS_PER_SEC
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_PHDR
comma
id|load_addr
op_plus
id|exec-&gt;e_phoff
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_PHENT
comma
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_PHNUM
comma
id|exec-&gt;e_phnum
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_BASE
comma
id|interp_load_addr
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_FLAGS
comma
l_int|0
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_ENTRY
comma
id|exec-&gt;e_entry
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_UID
comma
(paren
id|elf_addr_t
)paren
id|tsk-&gt;uid
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_EUID
comma
(paren
id|elf_addr_t
)paren
id|tsk-&gt;euid
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_GID
comma
(paren
id|elf_addr_t
)paren
id|tsk-&gt;gid
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_EGID
comma
(paren
id|elf_addr_t
)paren
id|tsk-&gt;egid
)paren
suffix:semicolon
id|NEW_AUX_ENT
c_func
(paren
id|AT_SECURE
comma
(paren
id|elf_addr_t
)paren
id|security_bprm_secureexec
c_func
(paren
id|bprm
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k_platform
)paren
(brace
id|NEW_AUX_ENT
c_func
(paren
id|AT_PLATFORM
comma
(paren
id|elf_addr_t
)paren
(paren
r_int
)paren
id|u_platform
)paren
suffix:semicolon
)brace
DECL|macro|NEW_AUX_ENT
macro_line|#undef NEW_AUX_ENT
multiline_comment|/* AT_NULL is zero; clear the rest too */
id|memset
c_func
(paren
op_amp
id|elf_info
(braket
id|ei_index
)braket
comma
l_int|0
comma
r_sizeof
id|current-&gt;mm-&gt;saved_auxv
op_minus
id|ei_index
op_star
r_sizeof
id|elf_info
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* And advance past the AT_NULL entry.  */
id|ei_index
op_add_assign
l_int|2
suffix:semicolon
id|sp
op_assign
id|STACK_ADD
c_func
(paren
id|p
comma
id|ei_index
)paren
suffix:semicolon
id|items
op_assign
(paren
id|argc
op_plus
l_int|1
)paren
op_plus
(paren
id|envc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interp_aout
)paren
(brace
id|items
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* a.out interpreters require argv &amp; envp too */
)brace
r_else
(brace
id|items
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* ELF interpreters only put argc on the stack */
)brace
id|bprm-&gt;p
op_assign
id|STACK_ROUND
c_func
(paren
id|sp
comma
id|items
)paren
suffix:semicolon
multiline_comment|/* Point sp at the lowest address on the stack */
macro_line|#ifdef CONFIG_STACK_GROWSUP
id|sp
op_assign
(paren
id|elf_addr_t
op_star
)paren
id|bprm-&gt;p
op_minus
id|items
op_minus
id|ei_index
suffix:semicolon
id|bprm-&gt;exec
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
multiline_comment|/* XXX: PARISC HACK */
macro_line|#else
id|sp
op_assign
(paren
id|elf_addr_t
op_star
)paren
id|bprm-&gt;p
suffix:semicolon
macro_line|#endif
multiline_comment|/* Now, let&squot;s put argc (and argv, envp if appropriate) on the stack */
id|__put_user
c_func
(paren
id|argc
comma
id|sp
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interp_aout
)paren
(brace
id|argv
op_assign
id|sp
op_plus
l_int|2
suffix:semicolon
id|envp
op_assign
id|argv
op_plus
id|argc
op_plus
l_int|1
suffix:semicolon
id|__put_user
c_func
(paren
(paren
id|elf_addr_t
)paren
(paren
r_int
)paren
id|argv
comma
id|sp
op_increment
)paren
suffix:semicolon
id|__put_user
c_func
(paren
(paren
id|elf_addr_t
)paren
(paren
r_int
)paren
id|envp
comma
id|sp
op_increment
)paren
suffix:semicolon
)brace
r_else
(brace
id|argv
op_assign
id|sp
suffix:semicolon
id|envp
op_assign
id|argv
op_plus
id|argc
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Populate argv and envp */
id|p
op_assign
id|current-&gt;mm-&gt;arg_start
suffix:semicolon
r_while
c_loop
(paren
id|argc
op_decrement
OG
l_int|0
)paren
(brace
r_int
id|len
suffix:semicolon
id|__put_user
c_func
(paren
(paren
id|elf_addr_t
)paren
id|p
comma
id|argv
op_increment
)paren
suffix:semicolon
id|len
op_assign
id|strnlen_user
c_func
(paren
(paren
r_void
op_star
)paren
id|p
comma
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|len
OG
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
r_return
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
)brace
id|__put_user
c_func
(paren
l_int|0
comma
id|argv
)paren
suffix:semicolon
id|current-&gt;mm-&gt;arg_end
op_assign
id|current-&gt;mm-&gt;env_start
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
id|envc
op_decrement
OG
l_int|0
)paren
(brace
r_int
id|len
suffix:semicolon
id|__put_user
c_func
(paren
(paren
id|elf_addr_t
)paren
id|p
comma
id|envp
op_increment
)paren
suffix:semicolon
id|len
op_assign
id|strnlen_user
c_func
(paren
(paren
r_void
op_star
)paren
id|p
comma
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|len
OG
id|PAGE_SIZE
op_star
id|MAX_ARG_PAGES
)paren
r_return
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
)brace
id|__put_user
c_func
(paren
l_int|0
comma
id|envp
)paren
suffix:semicolon
id|current-&gt;mm-&gt;env_end
op_assign
id|p
suffix:semicolon
multiline_comment|/* Put the elf_info on the stack in the right place.  */
id|sp
op_assign
(paren
id|elf_addr_t
op_star
)paren
id|envp
op_plus
l_int|1
suffix:semicolon
id|copy_to_user
c_func
(paren
id|sp
comma
id|elf_info
comma
id|ei_index
op_star
r_sizeof
(paren
id|elf_addr_t
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifndef elf_map
DECL|function|elf_map
r_static
r_int
r_int
id|elf_map
c_func
(paren
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|addr
comma
r_struct
id|elf_phdr
op_star
id|eppnt
comma
r_int
id|prot
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|map_addr
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|map_addr
op_assign
id|do_mmap
c_func
(paren
id|filep
comma
id|ELF_PAGESTART
c_func
(paren
id|addr
)paren
comma
id|eppnt-&gt;p_filesz
op_plus
id|ELF_PAGEOFFSET
c_func
(paren
id|eppnt-&gt;p_vaddr
)paren
comma
id|prot
comma
id|type
comma
id|eppnt-&gt;p_offset
op_minus
id|ELF_PAGEOFFSET
c_func
(paren
id|eppnt-&gt;p_vaddr
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_return
id|map_addr
suffix:semicolon
)brace
macro_line|#endif /* !elf_map */
multiline_comment|/* This is much more generalized than the library routine read function,&n;   so we keep this separate.  Technically the library read function&n;   is only provided so that we can read a.out libraries that have&n;   an ELF header */
DECL|function|load_elf_interp
r_static
r_int
r_int
id|load_elf_interp
c_func
(paren
r_struct
id|elfhdr
op_star
id|interp_elf_ex
comma
r_struct
id|file
op_star
id|interpreter
comma
r_int
r_int
op_star
id|interp_load_addr
)paren
(brace
r_struct
id|elf_phdr
op_star
id|elf_phdata
suffix:semicolon
r_struct
id|elf_phdr
op_star
id|eppnt
suffix:semicolon
r_int
r_int
id|load_addr
op_assign
l_int|0
suffix:semicolon
r_int
id|load_addr_set
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|last_bss
op_assign
l_int|0
comma
id|elf_bss
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|error
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_int
id|retval
comma
id|i
comma
id|size
suffix:semicolon
multiline_comment|/* First of all, some simple consistency checks */
r_if
c_cond
(paren
id|interp_elf_ex-&gt;e_type
op_ne
id|ET_EXEC
op_logical_and
id|interp_elf_ex-&gt;e_type
op_ne
id|ET_DYN
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_check_arch
c_func
(paren
id|interp_elf_ex
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interpreter-&gt;f_op
op_logical_or
op_logical_neg
id|interpreter-&gt;f_op-&gt;mmap
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If the size of this structure has changed, then punt, since&n;&t; * we will be doing the wrong thing.&n;&t; */
r_if
c_cond
(paren
id|interp_elf_ex-&gt;e_phentsize
op_ne
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|interp_elf_ex-&gt;e_phnum
OG
l_int|65536U
op_div
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Now read in all of the header information */
id|size
op_assign
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|interp_elf_ex-&gt;e_phnum
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|ELF_MIN_ALIGN
)paren
r_goto
id|out
suffix:semicolon
id|elf_phdata
op_assign
(paren
r_struct
id|elf_phdr
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_phdata
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|interpreter
comma
id|interp_elf_ex-&gt;e_phoff
comma
(paren
r_char
op_star
)paren
id|elf_phdata
comma
id|size
)paren
suffix:semicolon
id|error
op_assign
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_close
suffix:semicolon
id|eppnt
op_assign
id|elf_phdata
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|interp_elf_ex-&gt;e_phnum
suffix:semicolon
id|i
op_increment
comma
id|eppnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|eppnt-&gt;p_type
op_eq
id|PT_LOAD
)paren
(brace
r_int
id|elf_type
op_assign
id|MAP_PRIVATE
op_or
id|MAP_DENYWRITE
suffix:semicolon
r_int
id|elf_prot
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|vaddr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|k
comma
id|map_addr
suffix:semicolon
r_if
c_cond
(paren
id|eppnt-&gt;p_flags
op_amp
id|PF_R
)paren
id|elf_prot
op_assign
id|PROT_READ
suffix:semicolon
r_if
c_cond
(paren
id|eppnt-&gt;p_flags
op_amp
id|PF_W
)paren
id|elf_prot
op_or_assign
id|PROT_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|eppnt-&gt;p_flags
op_amp
id|PF_X
)paren
id|elf_prot
op_or_assign
id|PROT_EXEC
suffix:semicolon
id|vaddr
op_assign
id|eppnt-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|interp_elf_ex-&gt;e_type
op_eq
id|ET_EXEC
op_logical_or
id|load_addr_set
)paren
id|elf_type
op_or_assign
id|MAP_FIXED
suffix:semicolon
id|map_addr
op_assign
id|elf_map
c_func
(paren
id|interpreter
comma
id|load_addr
op_plus
id|vaddr
comma
id|eppnt
comma
id|elf_prot
comma
id|elf_type
)paren
suffix:semicolon
id|error
op_assign
id|map_addr
suffix:semicolon
r_if
c_cond
(paren
id|BAD_ADDR
c_func
(paren
id|map_addr
)paren
)paren
r_goto
id|out_close
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|load_addr_set
op_logical_and
id|interp_elf_ex-&gt;e_type
op_eq
id|ET_DYN
)paren
(brace
id|load_addr
op_assign
id|map_addr
op_minus
id|ELF_PAGESTART
c_func
(paren
id|vaddr
)paren
suffix:semicolon
id|load_addr_set
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;     * Find the end of the file mapping for this phdr, and keep&n;&t;     * track of the largest address we see for this.&n;&t;     */
id|k
op_assign
id|load_addr
op_plus
id|eppnt-&gt;p_vaddr
op_plus
id|eppnt-&gt;p_filesz
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|elf_bss
)paren
id|elf_bss
op_assign
id|k
suffix:semicolon
multiline_comment|/*&n;&t;     * Do the same thing for the memory mapping - between&n;&t;     * elf_bss and last_bss is the bss section.&n;&t;     */
id|k
op_assign
id|load_addr
op_plus
id|eppnt-&gt;p_memsz
op_plus
id|eppnt-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|last_bss
)paren
id|last_bss
op_assign
id|k
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now fill out the bss section.  First pad the last page up&n;&t; * to the page boundary, and then perform a mmap to make sure&n;&t; * that there are zero-mapped pages up to and including the &n;&t; * last bss page.&n;&t; */
id|padzero
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
id|elf_bss
op_assign
id|ELF_PAGESTART
c_func
(paren
id|elf_bss
op_plus
id|ELF_MIN_ALIGN
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* What we have mapped so far */
multiline_comment|/* Map the last of the bss segment */
r_if
c_cond
(paren
id|last_bss
OG
id|elf_bss
)paren
(brace
id|error
op_assign
id|do_brk
c_func
(paren
id|elf_bss
comma
id|last_bss
op_minus
id|elf_bss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BAD_ADDR
c_func
(paren
id|error
)paren
)paren
r_goto
id|out_close
suffix:semicolon
)brace
op_star
id|interp_load_addr
op_assign
id|load_addr
suffix:semicolon
id|error
op_assign
(paren
(paren
r_int
r_int
)paren
id|interp_elf_ex-&gt;e_entry
)paren
op_plus
id|load_addr
suffix:semicolon
id|out_close
suffix:colon
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|load_aout_interp
r_static
r_int
r_int
id|load_aout_interp
c_func
(paren
r_struct
id|exec
op_star
id|interp_ex
comma
r_struct
id|file
op_star
id|interpreter
)paren
(brace
r_int
r_int
id|text_data
comma
id|elf_entry
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
id|interp_ex-&gt;a_text
suffix:semicolon
id|text_data
op_assign
id|interp_ex-&gt;a_text
op_plus
id|interp_ex-&gt;a_data
suffix:semicolon
id|current-&gt;mm-&gt;end_data
op_assign
id|text_data
suffix:semicolon
id|current-&gt;mm-&gt;brk
op_assign
id|interp_ex-&gt;a_bss
op_plus
id|text_data
suffix:semicolon
r_switch
c_cond
(paren
id|N_MAGIC
c_func
(paren
op_star
id|interp_ex
)paren
)paren
(brace
r_case
id|OMAGIC
suffix:colon
id|offset
op_assign
l_int|32
suffix:semicolon
id|addr
op_assign
(paren
r_char
op_star
)paren
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ZMAGIC
suffix:colon
r_case
id|QMAGIC
suffix:colon
id|offset
op_assign
id|N_TXTOFF
c_func
(paren
op_star
id|interp_ex
)paren
suffix:semicolon
id|addr
op_assign
(paren
r_char
op_star
)paren
id|N_TXTADDR
c_func
(paren
op_star
id|interp_ex
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|out
suffix:semicolon
)brace
id|do_brk
c_func
(paren
l_int|0
comma
id|text_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interpreter-&gt;f_op
op_logical_or
op_logical_neg
id|interpreter-&gt;f_op-&gt;read
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|interpreter-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|interpreter
comma
id|addr
comma
id|text_data
comma
op_amp
id|offset
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
(paren
r_int
r_int
)paren
id|addr
op_plus
id|text_data
)paren
suffix:semicolon
id|do_brk
c_func
(paren
id|ELF_PAGESTART
c_func
(paren
id|text_data
op_plus
id|ELF_MIN_ALIGN
op_minus
l_int|1
)paren
comma
id|interp_ex-&gt;a_bss
)paren
suffix:semicolon
id|elf_entry
op_assign
id|interp_ex-&gt;a_entry
suffix:semicolon
id|out
suffix:colon
r_return
id|elf_entry
suffix:semicolon
)brace
multiline_comment|/*&n; * These are the functions used to load ELF style executables and shared&n; * libraries.  There is no binary dependent code anywhere else.&n; */
DECL|macro|INTERPRETER_NONE
mdefine_line|#define INTERPRETER_NONE 0
DECL|macro|INTERPRETER_AOUT
mdefine_line|#define INTERPRETER_AOUT 1
DECL|macro|INTERPRETER_ELF
mdefine_line|#define INTERPRETER_ELF 2
DECL|function|load_elf_binary
r_static
r_int
id|load_elf_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|file
op_star
id|interpreter
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* to shut gcc up */
r_int
r_int
id|load_addr
op_assign
l_int|0
comma
id|load_bias
op_assign
l_int|0
suffix:semicolon
r_int
id|load_addr_set
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|elf_interpreter
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|interpreter_type
op_assign
id|INTERPRETER_NONE
suffix:semicolon
r_int
r_char
id|ibcs2_interpreter
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|error
suffix:semicolon
r_struct
id|elf_phdr
op_star
id|elf_ppnt
comma
op_star
id|elf_phdata
suffix:semicolon
r_int
r_int
id|elf_bss
comma
id|elf_brk
suffix:semicolon
r_int
id|elf_exec_fileno
suffix:semicolon
r_int
id|retval
comma
id|i
suffix:semicolon
r_int
r_int
id|size
suffix:semicolon
r_int
r_int
id|elf_entry
comma
id|interp_load_addr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|start_code
comma
id|end_code
comma
id|start_data
comma
id|end_data
suffix:semicolon
r_int
r_int
id|reloc_func_desc
op_assign
l_int|0
suffix:semicolon
r_struct
id|elfhdr
id|elf_ex
suffix:semicolon
r_struct
id|elfhdr
id|interp_elf_ex
suffix:semicolon
r_struct
id|exec
id|interp_ex
suffix:semicolon
r_char
id|passed_fileno
(braket
l_int|6
)braket
suffix:semicolon
r_struct
id|files_struct
op_star
id|files
suffix:semicolon
multiline_comment|/* Get the exec-header */
id|elf_ex
op_assign
op_star
(paren
(paren
r_struct
id|elfhdr
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
multiline_comment|/* First of all, some simple consistency checks */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|elf_ex.e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|elf_ex.e_type
op_ne
id|ET_EXEC
op_logical_and
id|elf_ex.e_type
op_ne
id|ET_DYN
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_check_arch
c_func
(paren
op_amp
id|elf_ex
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bprm-&gt;file-&gt;f_op
op_logical_or
op_logical_neg
id|bprm-&gt;file-&gt;f_op-&gt;mmap
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Now read in all of the header information */
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|elf_ex.e_phentsize
op_ne
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|elf_ex.e_phnum
OG
l_int|65536U
op_div
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
)paren
r_goto
id|out
suffix:semicolon
id|size
op_assign
id|elf_ex.e_phnum
op_star
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
suffix:semicolon
id|elf_phdata
op_assign
(paren
r_struct
id|elf_phdr
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_phdata
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|bprm-&gt;file
comma
id|elf_ex.e_phoff
comma
(paren
r_char
op_star
)paren
id|elf_phdata
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_free_ph
suffix:semicolon
id|files
op_assign
id|current-&gt;files
suffix:semicolon
multiline_comment|/* Refcounted so ok */
r_if
c_cond
(paren
id|unshare_files
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_goto
id|out_free_ph
suffix:semicolon
)brace
r_if
c_cond
(paren
id|files
op_eq
id|current-&gt;files
)paren
(brace
id|put_files_struct
c_func
(paren
id|files
)paren
suffix:semicolon
id|files
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* exec will make our files private anyway, but for the a.out&n;&t;   loader stuff we need to do it earlier */
id|retval
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_free_fh
suffix:semicolon
id|get_file
c_func
(paren
id|bprm-&gt;file
)paren
suffix:semicolon
id|fd_install
c_func
(paren
id|elf_exec_fileno
op_assign
id|retval
comma
id|bprm-&gt;file
)paren
suffix:semicolon
id|elf_ppnt
op_assign
id|elf_phdata
suffix:semicolon
id|elf_bss
op_assign
l_int|0
suffix:semicolon
id|elf_brk
op_assign
l_int|0
suffix:semicolon
id|start_code
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|end_code
op_assign
l_int|0
suffix:semicolon
id|start_data
op_assign
l_int|0
suffix:semicolon
id|end_data
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|elf_ex.e_phnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|elf_ppnt-&gt;p_type
op_eq
id|PT_INTERP
)paren
(brace
multiline_comment|/* This is the program interpreter used for&n;&t;&t;&t; * shared libraries - for now assume that this&n;&t;&t;&t; * is an a.out format binary&n;&t;&t;&t; */
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|elf_ppnt-&gt;p_filesz
OG
id|PATH_MAX
)paren
r_goto
id|out_free_file
suffix:semicolon
id|elf_interpreter
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|elf_ppnt-&gt;p_filesz
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_interpreter
)paren
r_goto
id|out_free_file
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|bprm-&gt;file
comma
id|elf_ppnt-&gt;p_offset
comma
id|elf_interpreter
comma
id|elf_ppnt-&gt;p_filesz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_free_interp
suffix:semicolon
multiline_comment|/* If the program interpreter is one of these two,&n;&t;&t;&t; * then assume an iBCS2 image. Otherwise assume&n;&t;&t;&t; * a native linux image.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|elf_interpreter
comma
l_string|&quot;/usr/lib/libc.so.1&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|elf_interpreter
comma
l_string|&quot;/usr/lib/ld.so.1&quot;
)paren
op_eq
l_int|0
)paren
id|ibcs2_interpreter
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The early SET_PERSONALITY here is so that the lookup&n;&t;&t;&t; * for the interpreter happens in the namespace of the &n;&t;&t;&t; * to-be-execed image.  SET_PERSONALITY can select an&n;&t;&t;&t; * alternate root.&n;&t;&t;&t; *&n;&t;&t;&t; * However, SET_PERSONALITY is NOT allowed to switch&n;&t;&t;&t; * this task into the new images&squot;s memory mapping&n;&t;&t;&t; * policy - that is, TASK_SIZE must still evaluate to&n;&t;&t;&t; * that which is appropriate to the execing application.&n;&t;&t;&t; * This is because exit_mmap() needs to have TASK_SIZE&n;&t;&t;&t; * evaluate to the size of the old image.&n;&t;&t;&t; *&n;&t;&t;&t; * So if (say) a 64-bit application is execing a 32-bit&n;&t;&t;&t; * application it is the architecture&squot;s responsibility&n;&t;&t;&t; * to defer changing the value of TASK_SIZE until the&n;&t;&t;&t; * switch really is going to happen - do this in&n;&t;&t;&t; * flush_thread().&t;- akpm&n;&t;&t;&t; */
id|SET_PERSONALITY
c_func
(paren
id|elf_ex
comma
id|ibcs2_interpreter
)paren
suffix:semicolon
id|interpreter
op_assign
id|open_exec
c_func
(paren
id|elf_interpreter
)paren
suffix:semicolon
id|retval
op_assign
id|PTR_ERR
c_func
(paren
id|interpreter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|interpreter
)paren
)paren
r_goto
id|out_free_interp
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|interpreter
comma
l_int|0
comma
id|bprm-&gt;buf
comma
id|BINPRM_BUF_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out_free_dentry
suffix:semicolon
multiline_comment|/* Get the exec headers */
id|interp_ex
op_assign
op_star
(paren
(paren
r_struct
id|exec
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
id|interp_elf_ex
op_assign
op_star
(paren
(paren
r_struct
id|elfhdr
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|elf_ppnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* Some simple consistency checks for the interpreter */
r_if
c_cond
(paren
id|elf_interpreter
)paren
(brace
id|interpreter_type
op_assign
id|INTERPRETER_ELF
op_or
id|INTERPRETER_AOUT
suffix:semicolon
multiline_comment|/* Now figure out which format our binary is */
r_if
c_cond
(paren
(paren
id|N_MAGIC
c_func
(paren
id|interp_ex
)paren
op_ne
id|OMAGIC
)paren
op_logical_and
(paren
id|N_MAGIC
c_func
(paren
id|interp_ex
)paren
op_ne
id|ZMAGIC
)paren
op_logical_and
(paren
id|N_MAGIC
c_func
(paren
id|interp_ex
)paren
op_ne
id|QMAGIC
)paren
)paren
id|interpreter_type
op_assign
id|INTERPRETER_ELF
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|interp_elf_ex.e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_ne
l_int|0
)paren
id|interpreter_type
op_and_assign
op_complement
id|INTERPRETER_ELF
suffix:semicolon
id|retval
op_assign
op_minus
id|ELIBBAD
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|interpreter_type
)paren
r_goto
id|out_free_dentry
suffix:semicolon
multiline_comment|/* Make sure only one type was selected */
r_if
c_cond
(paren
(paren
id|interpreter_type
op_amp
id|INTERPRETER_ELF
)paren
op_logical_and
id|interpreter_type
op_ne
id|INTERPRETER_ELF
)paren
(brace
singleline_comment|// FIXME - ratelimit this before re-enabling
singleline_comment|// printk(KERN_WARNING &quot;ELF: Ambiguous type, using ELF&bslash;n&quot;);
id|interpreter_type
op_assign
id|INTERPRETER_ELF
suffix:semicolon
)brace
multiline_comment|/* Verify the interpreter has a valid arch */
r_if
c_cond
(paren
(paren
id|interpreter_type
op_eq
id|INTERPRETER_ELF
)paren
op_logical_and
op_logical_neg
id|elf_check_arch
c_func
(paren
op_amp
id|interp_elf_ex
)paren
)paren
r_goto
id|out_free_dentry
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Executables without an interpreter also need a personality  */
id|SET_PERSONALITY
c_func
(paren
id|elf_ex
comma
id|ibcs2_interpreter
)paren
suffix:semicolon
)brace
multiline_comment|/* OK, we are done with that, now set up the arg stuff,&n;&t;   and then start this sucker up */
r_if
c_cond
(paren
(paren
op_logical_neg
id|bprm-&gt;sh_bang
)paren
op_logical_and
(paren
id|interpreter_type
op_eq
id|INTERPRETER_AOUT
)paren
)paren
(brace
r_char
op_star
id|passed_p
op_assign
id|passed_fileno
suffix:semicolon
id|sprintf
c_func
(paren
id|passed_fileno
comma
l_string|&quot;%d&quot;
comma
id|elf_exec_fileno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_interpreter
)paren
(brace
id|retval
op_assign
id|copy_strings_kernel
c_func
(paren
l_int|1
comma
op_amp
id|passed_p
comma
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out_free_dentry
suffix:semicolon
id|bprm-&gt;argc
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Flush all traces of the currently running executable */
id|retval
op_assign
id|flush_old_exec
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out_free_dentry
suffix:semicolon
multiline_comment|/* Discard our unneeded old files struct */
r_if
c_cond
(paren
id|files
)paren
(brace
id|steal_locks
c_func
(paren
id|files
)paren
suffix:semicolon
id|put_files_struct
c_func
(paren
id|files
)paren
suffix:semicolon
id|files
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* OK, This is the point of no return */
id|current-&gt;mm-&gt;start_data
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;end_data
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;mmap
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
multiline_comment|/* Do this immediately, since STACK_TOP as used in setup_arg_pages&n;&t;   may depend on the personality.  */
id|SET_PERSONALITY
c_func
(paren
id|elf_ex
comma
id|ibcs2_interpreter
)paren
suffix:semicolon
multiline_comment|/* Do this so that we can load the interpreter, if need be.  We will&n;&t;   change some of these later */
id|current-&gt;mm-&gt;rss
op_assign
l_int|0
suffix:semicolon
id|current-&gt;mm-&gt;free_area_cache
op_assign
id|TASK_UNMAPPED_BASE
suffix:semicolon
id|retval
op_assign
id|setup_arg_pages
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|out_free_dentry
suffix:semicolon
)brace
id|current-&gt;mm-&gt;start_stack
op_assign
id|bprm-&gt;p
suffix:semicolon
multiline_comment|/* Now we do a little grungy work by mmaping the ELF image into&n;&t;   the correct location in memory.  At this point, we assume that&n;&t;   the image should be loaded at fixed address, not at a variable&n;&t;   address. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|elf_ppnt
op_assign
id|elf_phdata
suffix:semicolon
id|i
OL
id|elf_ex.e_phnum
suffix:semicolon
id|i
op_increment
comma
id|elf_ppnt
op_increment
)paren
(brace
r_int
id|elf_prot
op_assign
l_int|0
comma
id|elf_flags
suffix:semicolon
r_int
r_int
id|k
comma
id|vaddr
suffix:semicolon
r_if
c_cond
(paren
id|elf_ppnt-&gt;p_type
op_ne
id|PT_LOAD
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|elf_brk
OG
id|elf_bss
)paren
)paren
(brace
r_int
r_int
id|nbyte
suffix:semicolon
multiline_comment|/* There was a PT_LOAD segment with p_memsz &gt; p_filesz&n;&t;&t;&t;   before this one. Map anonymous pages, if needed,&n;&t;&t;&t;   and clear the area.  */
id|retval
op_assign
id|set_brk
(paren
id|elf_bss
op_plus
id|load_bias
comma
id|elf_brk
op_plus
id|load_bias
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|out_free_dentry
suffix:semicolon
)brace
id|nbyte
op_assign
id|ELF_PAGEOFFSET
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nbyte
)paren
(brace
id|nbyte
op_assign
id|ELF_MIN_ALIGN
op_minus
id|nbyte
suffix:semicolon
r_if
c_cond
(paren
id|nbyte
OG
id|elf_brk
op_minus
id|elf_bss
)paren
id|nbyte
op_assign
id|elf_brk
op_minus
id|elf_bss
suffix:semicolon
id|clear_user
c_func
(paren
(paren
r_void
op_star
)paren
id|elf_bss
op_plus
id|load_bias
comma
id|nbyte
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|elf_ppnt-&gt;p_flags
op_amp
id|PF_R
)paren
id|elf_prot
op_or_assign
id|PROT_READ
suffix:semicolon
r_if
c_cond
(paren
id|elf_ppnt-&gt;p_flags
op_amp
id|PF_W
)paren
id|elf_prot
op_or_assign
id|PROT_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|elf_ppnt-&gt;p_flags
op_amp
id|PF_X
)paren
id|elf_prot
op_or_assign
id|PROT_EXEC
suffix:semicolon
id|elf_flags
op_assign
id|MAP_PRIVATE
op_or
id|MAP_DENYWRITE
op_or
id|MAP_EXECUTABLE
suffix:semicolon
id|vaddr
op_assign
id|elf_ppnt-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|elf_ex.e_type
op_eq
id|ET_EXEC
op_logical_or
id|load_addr_set
)paren
(brace
id|elf_flags
op_or_assign
id|MAP_FIXED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|elf_ex.e_type
op_eq
id|ET_DYN
)paren
(brace
multiline_comment|/* Try and get dynamic programs out of the way of the default mmap&n;&t;&t;&t;   base, as well as whatever program they might try to exec.  This&n;&t;&t;&t;   is because the brk will follow the loader, and is not movable.  */
id|load_bias
op_assign
id|ELF_PAGESTART
c_func
(paren
id|ELF_ET_DYN_BASE
op_minus
id|vaddr
)paren
suffix:semicolon
)brace
id|error
op_assign
id|elf_map
c_func
(paren
id|bprm-&gt;file
comma
id|load_bias
op_plus
id|vaddr
comma
id|elf_ppnt
comma
id|elf_prot
comma
id|elf_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BAD_ADDR
c_func
(paren
id|error
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|load_addr_set
)paren
(brace
id|load_addr_set
op_assign
l_int|1
suffix:semicolon
id|load_addr
op_assign
(paren
id|elf_ppnt-&gt;p_vaddr
op_minus
id|elf_ppnt-&gt;p_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_ex.e_type
op_eq
id|ET_DYN
)paren
(brace
id|load_bias
op_add_assign
id|error
op_minus
id|ELF_PAGESTART
c_func
(paren
id|load_bias
op_plus
id|vaddr
)paren
suffix:semicolon
id|load_addr
op_add_assign
id|load_bias
suffix:semicolon
id|reloc_func_desc
op_assign
id|load_bias
suffix:semicolon
)brace
)brace
id|k
op_assign
id|elf_ppnt-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|k
OL
id|start_code
)paren
id|start_code
op_assign
id|k
suffix:semicolon
r_if
c_cond
(paren
id|start_data
OL
id|k
)paren
id|start_data
op_assign
id|k
suffix:semicolon
id|k
op_assign
id|elf_ppnt-&gt;p_vaddr
op_plus
id|elf_ppnt-&gt;p_filesz
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|elf_bss
)paren
id|elf_bss
op_assign
id|k
suffix:semicolon
r_if
c_cond
(paren
(paren
id|elf_ppnt-&gt;p_flags
op_amp
id|PF_X
)paren
op_logical_and
id|end_code
OL
id|k
)paren
id|end_code
op_assign
id|k
suffix:semicolon
r_if
c_cond
(paren
id|end_data
OL
id|k
)paren
id|end_data
op_assign
id|k
suffix:semicolon
id|k
op_assign
id|elf_ppnt-&gt;p_vaddr
op_plus
id|elf_ppnt-&gt;p_memsz
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|elf_brk
)paren
id|elf_brk
op_assign
id|k
suffix:semicolon
)brace
id|elf_ex.e_entry
op_add_assign
id|load_bias
suffix:semicolon
id|elf_bss
op_add_assign
id|load_bias
suffix:semicolon
id|elf_brk
op_add_assign
id|load_bias
suffix:semicolon
id|start_code
op_add_assign
id|load_bias
suffix:semicolon
id|end_code
op_add_assign
id|load_bias
suffix:semicolon
id|start_data
op_add_assign
id|load_bias
suffix:semicolon
id|end_data
op_add_assign
id|load_bias
suffix:semicolon
multiline_comment|/* Calling set_brk effectively mmaps the pages that we need&n;&t; * for the bss and break sections.  We must do this before&n;&t; * mapping in the interpreter, to make sure it doesn&squot;t wind&n;&t; * up getting placed where the bss needs to go.&n;&t; */
id|retval
op_assign
id|set_brk
c_func
(paren
id|elf_bss
comma
id|elf_brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|out_free_dentry
suffix:semicolon
)brace
id|padzero
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_interpreter
)paren
(brace
r_if
c_cond
(paren
id|interpreter_type
op_eq
id|INTERPRETER_AOUT
)paren
id|elf_entry
op_assign
id|load_aout_interp
c_func
(paren
op_amp
id|interp_ex
comma
id|interpreter
)paren
suffix:semicolon
r_else
id|elf_entry
op_assign
id|load_elf_interp
c_func
(paren
op_amp
id|interp_elf_ex
comma
id|interpreter
comma
op_amp
id|interp_load_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BAD_ADDR
c_func
(paren
id|elf_entry
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to load interpreter&bslash;n&quot;
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGSEGV
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
multiline_comment|/* Nobody gets to see this, but.. */
r_goto
id|out_free_dentry
suffix:semicolon
)brace
id|reloc_func_desc
op_assign
id|interp_load_addr
suffix:semicolon
id|allow_write_access
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|fput
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|elf_interpreter
)paren
suffix:semicolon
)brace
r_else
(brace
id|elf_entry
op_assign
id|elf_ex.e_entry
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interpreter_type
op_ne
id|INTERPRETER_AOUT
)paren
id|sys_close
c_func
(paren
id|elf_exec_fileno
)paren
suffix:semicolon
id|set_binfmt
c_func
(paren
op_amp
id|elf_format
)paren
suffix:semicolon
id|compute_creds
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|current-&gt;flags
op_and_assign
op_complement
id|PF_FORKNOEXEC
suffix:semicolon
id|create_elf_tables
c_func
(paren
id|bprm
comma
op_amp
id|elf_ex
comma
(paren
id|interpreter_type
op_eq
id|INTERPRETER_AOUT
)paren
comma
id|load_addr
comma
id|interp_load_addr
)paren
suffix:semicolon
multiline_comment|/* N.B. passed_fileno might not be initialized? */
r_if
c_cond
(paren
id|interpreter_type
op_eq
id|INTERPRETER_AOUT
)paren
id|current-&gt;mm-&gt;arg_start
op_add_assign
id|strlen
c_func
(paren
id|passed_fileno
)paren
op_plus
l_int|1
suffix:semicolon
id|current-&gt;mm-&gt;end_code
op_assign
id|end_code
suffix:semicolon
id|current-&gt;mm-&gt;start_code
op_assign
id|start_code
suffix:semicolon
id|current-&gt;mm-&gt;start_data
op_assign
id|start_data
suffix:semicolon
id|current-&gt;mm-&gt;end_data
op_assign
id|end_data
suffix:semicolon
id|current-&gt;mm-&gt;start_stack
op_assign
id|bprm-&gt;p
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;personality
op_amp
id|MMAP_PAGE_ZERO
)paren
(brace
multiline_comment|/* Why this, you ask???  Well SVr4 maps page 0 as read-only,&n;&t;&t;   and some applications &quot;depend&quot; upon this behavior.&n;&t;&t;   Since we do not have the power to recompile these, we&n;&t;&t;   emulate the SVr4 behavior.  Sigh.  */
multiline_comment|/* N.B. Shouldn&squot;t the size here be PAGE_SIZE?? */
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|error
op_assign
id|do_mmap
c_func
(paren
l_int|NULL
comma
l_int|0
comma
l_int|4096
comma
id|PROT_READ
op_or
id|PROT_EXEC
comma
id|MAP_FIXED
op_or
id|MAP_PRIVATE
comma
l_int|0
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
)brace
macro_line|#ifdef ELF_PLAT_INIT
multiline_comment|/*&n;&t; * The ABI may specify that certain registers be set up in special&n;&t; * ways (on i386 %edx is the address of a DT_FINI function, for&n;&t; * example.  In addition, it may also specify (eg, PowerPC64 ELF)&n;&t; * that the e_entry field is the address of the function descriptor&n;&t; * for the startup routine, rather than the address of the startup&n;&t; * routine itself.  This macro performs whatever initialization to&n;&t; * the regs structure is required as well as any relocations to the&n;&t; * function descriptor entries when executing dynamically links apps.&n;&t; */
id|ELF_PLAT_INIT
c_func
(paren
id|regs
comma
id|reloc_func_desc
)paren
suffix:semicolon
macro_line|#endif
id|start_thread
c_func
(paren
id|regs
comma
id|elf_entry
comma
id|bprm-&gt;p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|current-&gt;ptrace
op_amp
id|PT_PTRACED
)paren
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;ptrace
op_amp
id|PT_TRACE_EXEC
)paren
id|ptrace_notify
(paren
(paren
id|PTRACE_EVENT_EXEC
op_lshift
l_int|8
)paren
op_or
id|SIGTRAP
)paren
suffix:semicolon
r_else
id|send_sig
c_func
(paren
id|SIGTRAP
comma
id|current
comma
l_int|0
)paren
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
multiline_comment|/* error cleanup */
id|out_free_dentry
suffix:colon
id|allow_write_access
c_func
(paren
id|interpreter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interpreter
)paren
id|fput
c_func
(paren
id|interpreter
)paren
suffix:semicolon
id|out_free_interp
suffix:colon
r_if
c_cond
(paren
id|elf_interpreter
)paren
id|kfree
c_func
(paren
id|elf_interpreter
)paren
suffix:semicolon
id|out_free_file
suffix:colon
id|sys_close
c_func
(paren
id|elf_exec_fileno
)paren
suffix:semicolon
id|out_free_fh
suffix:colon
r_if
c_cond
(paren
id|files
)paren
(brace
id|put_files_struct
c_func
(paren
id|current-&gt;files
)paren
suffix:semicolon
id|current-&gt;files
op_assign
id|files
suffix:semicolon
)brace
id|out_free_ph
suffix:colon
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* This is really simpleminded and specialized - we are loading an&n;   a.out library that is given an ELF header. */
DECL|function|load_elf_library
r_static
r_int
id|load_elf_library
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|elf_phdr
op_star
id|elf_phdata
suffix:semicolon
r_int
r_int
id|elf_bss
comma
id|bss
comma
id|len
suffix:semicolon
r_int
id|retval
comma
id|error
comma
id|i
comma
id|j
suffix:semicolon
r_struct
id|elfhdr
id|elf_ex
suffix:semicolon
id|error
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|file
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|elf_ex
comma
r_sizeof
(paren
id|elf_ex
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
r_sizeof
(paren
id|elf_ex
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|elf_ex.e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* First of all, some simple consistency checks */
r_if
c_cond
(paren
id|elf_ex.e_type
op_ne
id|ET_EXEC
op_logical_or
id|elf_ex.e_phnum
OG
l_int|2
op_logical_or
op_logical_neg
id|elf_check_arch
c_func
(paren
op_amp
id|elf_ex
)paren
op_logical_or
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;mmap
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Now read in all of the header information */
id|j
op_assign
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
op_star
id|elf_ex.e_phnum
suffix:semicolon
multiline_comment|/* j &lt; ELF_MIN_ALIGN because elf_ex.e_phnum &lt;= 2 */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|elf_phdata
op_assign
(paren
r_struct
id|elf_phdr
op_star
)paren
id|kmalloc
c_func
(paren
id|j
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf_phdata
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
id|retval
op_assign
id|kernel_read
c_func
(paren
id|file
comma
id|elf_ex.e_phoff
comma
(paren
r_char
op_star
)paren
id|elf_phdata
comma
id|j
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|j
)paren
r_goto
id|out_free_ph
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|elf_ex.e_phnum
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|elf_phdata
op_plus
id|i
)paren
op_member_access_from_pointer
id|p_type
op_eq
id|PT_LOAD
)paren
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ne
l_int|1
)paren
r_goto
id|out_free_ph
suffix:semicolon
r_while
c_loop
(paren
id|elf_phdata-&gt;p_type
op_ne
id|PT_LOAD
)paren
id|elf_phdata
op_increment
suffix:semicolon
multiline_comment|/* Now use mmap to map the library into memory. */
id|down_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
id|error
op_assign
id|do_mmap
c_func
(paren
id|file
comma
id|ELF_PAGESTART
c_func
(paren
id|elf_phdata-&gt;p_vaddr
)paren
comma
(paren
id|elf_phdata-&gt;p_filesz
op_plus
id|ELF_PAGEOFFSET
c_func
(paren
id|elf_phdata-&gt;p_vaddr
)paren
)paren
comma
id|PROT_READ
op_or
id|PROT_WRITE
op_or
id|PROT_EXEC
comma
id|MAP_FIXED
op_or
id|MAP_PRIVATE
op_or
id|MAP_DENYWRITE
comma
(paren
id|elf_phdata-&gt;p_offset
op_minus
id|ELF_PAGEOFFSET
c_func
(paren
id|elf_phdata-&gt;p_vaddr
)paren
)paren
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|current-&gt;mm-&gt;mmap_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
id|ELF_PAGESTART
c_func
(paren
id|elf_phdata-&gt;p_vaddr
)paren
)paren
r_goto
id|out_free_ph
suffix:semicolon
id|elf_bss
op_assign
id|elf_phdata-&gt;p_vaddr
op_plus
id|elf_phdata-&gt;p_filesz
suffix:semicolon
id|padzero
c_func
(paren
id|elf_bss
)paren
suffix:semicolon
id|len
op_assign
id|ELF_PAGESTART
c_func
(paren
id|elf_phdata-&gt;p_filesz
op_plus
id|elf_phdata-&gt;p_vaddr
op_plus
id|ELF_MIN_ALIGN
op_minus
l_int|1
)paren
suffix:semicolon
id|bss
op_assign
id|elf_phdata-&gt;p_memsz
op_plus
id|elf_phdata-&gt;p_vaddr
suffix:semicolon
r_if
c_cond
(paren
id|bss
OG
id|len
)paren
id|do_brk
c_func
(paren
id|len
comma
id|bss
op_minus
id|len
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out_free_ph
suffix:colon
id|kfree
c_func
(paren
id|elf_phdata
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that some platforms still use traditional core dumps and not&n; * the ELF core dump.  Each platform can select it as appropriate.&n; */
macro_line|#ifdef USE_ELF_CORE_DUMP
multiline_comment|/*&n; * ELF core dumper&n; *&n; * Modelled on fs/exec.c:aout_core_dump()&n; * Jeremy Fitzhardinge &lt;jeremy@sw.oz.au&gt;&n; */
multiline_comment|/*&n; * These are the only things you should do on a core-file: use only these&n; * functions to write out all the necessary info.&n; */
DECL|function|dump_write
r_static
r_int
id|dump_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_void
op_star
id|addr
comma
r_int
id|nr
)paren
(brace
r_return
id|file-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|file
comma
id|addr
comma
id|nr
comma
op_amp
id|file-&gt;f_pos
)paren
op_eq
id|nr
suffix:semicolon
)brace
DECL|function|dump_seek
r_static
r_int
id|dump_seek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|off_t
id|off
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_op-&gt;llseek
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|file
comma
id|off
comma
l_int|0
)paren
op_ne
id|off
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|file-&gt;f_pos
op_assign
id|off
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Decide whether a segment is worth dumping; default is yes to be&n; * sure (missing info is worse than too much; etc).&n; * Personally I&squot;d include everything, and use the coredump limit...&n; *&n; * I think we should skip something. But I am not sure how. H.J.&n; */
DECL|function|maydump
r_static
r_int
id|maydump
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
)paren
(brace
multiline_comment|/*&n;&t; * If we may not read the contents, don&squot;t allow us to dump&n;&t; * them either. &quot;dump_write()&quot; can&squot;t handle it anyway.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_READ
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Do not dump I/O mapped devices! -DaveM */
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_IO
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_WRITE
op_or
id|VM_GROWSUP
op_or
id|VM_GROWSDOWN
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
(paren
id|VM_READ
op_or
id|VM_EXEC
op_or
id|VM_EXECUTABLE
op_or
id|VM_SHARED
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|roundup
mdefine_line|#define roundup(x, y)  ((((x)+((y)-1))/(y))*(y))
multiline_comment|/* An ELF note in memory */
DECL|struct|memelfnote
r_struct
id|memelfnote
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|datasz
r_int
r_int
id|datasz
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
)brace
suffix:semicolon
DECL|function|notesize
r_static
r_int
id|notesize
c_func
(paren
r_struct
id|memelfnote
op_star
id|en
)paren
(brace
r_int
id|sz
suffix:semicolon
id|sz
op_assign
r_sizeof
(paren
r_struct
id|elf_note
)paren
suffix:semicolon
id|sz
op_add_assign
id|roundup
c_func
(paren
id|strlen
c_func
(paren
id|en-&gt;name
)paren
op_plus
l_int|1
comma
l_int|4
)paren
suffix:semicolon
id|sz
op_add_assign
id|roundup
c_func
(paren
id|en-&gt;datasz
comma
l_int|4
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|macro|DUMP_WRITE
mdefine_line|#define DUMP_WRITE(addr, nr)&t;&bslash;&n;&t;do { if (!dump_write(file, (addr), (nr))) return 0; } while(0)
DECL|macro|DUMP_SEEK
mdefine_line|#define DUMP_SEEK(off)&t;&bslash;&n;&t;do { if (!dump_seek(file, (off))) return 0; } while(0)
DECL|function|writenote
r_static
r_int
id|writenote
c_func
(paren
r_struct
id|memelfnote
op_star
id|men
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|elf_note
id|en
suffix:semicolon
id|en.n_namesz
op_assign
id|strlen
c_func
(paren
id|men-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
id|en.n_descsz
op_assign
id|men-&gt;datasz
suffix:semicolon
id|en.n_type
op_assign
id|men-&gt;type
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
op_amp
id|en
comma
r_sizeof
(paren
id|en
)paren
)paren
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
id|men-&gt;name
comma
id|en.n_namesz
)paren
suffix:semicolon
multiline_comment|/* XXX - cast from long long to long to avoid need for libgcc.a */
id|DUMP_SEEK
c_func
(paren
id|roundup
c_func
(paren
(paren
r_int
r_int
)paren
id|file-&gt;f_pos
comma
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX */
id|DUMP_WRITE
c_func
(paren
id|men-&gt;data
comma
id|men-&gt;datasz
)paren
suffix:semicolon
id|DUMP_SEEK
c_func
(paren
id|roundup
c_func
(paren
(paren
r_int
r_int
)paren
id|file-&gt;f_pos
comma
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX */
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|DUMP_WRITE
macro_line|#undef DUMP_WRITE
DECL|macro|DUMP_SEEK
macro_line|#undef DUMP_SEEK
DECL|macro|DUMP_WRITE
mdefine_line|#define DUMP_WRITE(addr, nr)&t;&bslash;&n;&t;if ((size += (nr)) &gt; limit || !dump_write(file, (addr), (nr))) &bslash;&n;&t;&t;goto end_coredump;
DECL|macro|DUMP_SEEK
mdefine_line|#define DUMP_SEEK(off)&t;&bslash;&n;&t;if (!dump_seek(file, (off))) &bslash;&n;&t;&t;goto end_coredump;
DECL|function|fill_elf_header
r_static
r_inline
r_void
id|fill_elf_header
c_func
(paren
r_struct
id|elfhdr
op_star
id|elf
comma
r_int
id|segs
)paren
(brace
id|memcpy
c_func
(paren
id|elf-&gt;e_ident
comma
id|ELFMAG
comma
id|SELFMAG
)paren
suffix:semicolon
id|elf-&gt;e_ident
(braket
id|EI_CLASS
)braket
op_assign
id|ELF_CLASS
suffix:semicolon
id|elf-&gt;e_ident
(braket
id|EI_DATA
)braket
op_assign
id|ELF_DATA
suffix:semicolon
id|elf-&gt;e_ident
(braket
id|EI_VERSION
)braket
op_assign
id|EV_CURRENT
suffix:semicolon
id|elf-&gt;e_ident
(braket
id|EI_OSABI
)braket
op_assign
id|ELF_OSABI
suffix:semicolon
id|memset
c_func
(paren
id|elf-&gt;e_ident
op_plus
id|EI_PAD
comma
l_int|0
comma
id|EI_NIDENT
op_minus
id|EI_PAD
)paren
suffix:semicolon
id|elf-&gt;e_type
op_assign
id|ET_CORE
suffix:semicolon
id|elf-&gt;e_machine
op_assign
id|ELF_ARCH
suffix:semicolon
id|elf-&gt;e_version
op_assign
id|EV_CURRENT
suffix:semicolon
id|elf-&gt;e_entry
op_assign
l_int|0
suffix:semicolon
id|elf-&gt;e_phoff
op_assign
r_sizeof
(paren
r_struct
id|elfhdr
)paren
suffix:semicolon
id|elf-&gt;e_shoff
op_assign
l_int|0
suffix:semicolon
id|elf-&gt;e_flags
op_assign
l_int|0
suffix:semicolon
id|elf-&gt;e_ehsize
op_assign
r_sizeof
(paren
r_struct
id|elfhdr
)paren
suffix:semicolon
id|elf-&gt;e_phentsize
op_assign
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
suffix:semicolon
id|elf-&gt;e_phnum
op_assign
id|segs
suffix:semicolon
id|elf-&gt;e_shentsize
op_assign
l_int|0
suffix:semicolon
id|elf-&gt;e_shnum
op_assign
l_int|0
suffix:semicolon
id|elf-&gt;e_shstrndx
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|fill_elf_note_phdr
r_static
r_inline
r_void
id|fill_elf_note_phdr
c_func
(paren
r_struct
id|elf_phdr
op_star
id|phdr
comma
r_int
id|sz
comma
id|off_t
id|offset
)paren
(brace
id|phdr-&gt;p_type
op_assign
id|PT_NOTE
suffix:semicolon
id|phdr-&gt;p_offset
op_assign
id|offset
suffix:semicolon
id|phdr-&gt;p_vaddr
op_assign
l_int|0
suffix:semicolon
id|phdr-&gt;p_paddr
op_assign
l_int|0
suffix:semicolon
id|phdr-&gt;p_filesz
op_assign
id|sz
suffix:semicolon
id|phdr-&gt;p_memsz
op_assign
l_int|0
suffix:semicolon
id|phdr-&gt;p_flags
op_assign
l_int|0
suffix:semicolon
id|phdr-&gt;p_align
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|fill_note
r_static
r_void
id|fill_note
c_func
(paren
r_struct
id|memelfnote
op_star
id|note
comma
r_const
r_char
op_star
id|name
comma
r_int
id|type
comma
r_int
r_int
id|sz
comma
r_void
op_star
id|data
)paren
(brace
id|note-&gt;name
op_assign
id|name
suffix:semicolon
id|note-&gt;type
op_assign
id|type
suffix:semicolon
id|note-&gt;datasz
op_assign
id|sz
suffix:semicolon
id|note-&gt;data
op_assign
id|data
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * fill up all the fields in prstatus from the given task struct, except registers&n; * which need to be filled up separately.&n; */
DECL|function|fill_prstatus
r_static
r_void
id|fill_prstatus
c_func
(paren
r_struct
id|elf_prstatus
op_star
id|prstatus
comma
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|signr
)paren
(brace
id|prstatus-&gt;pr_info.si_signo
op_assign
id|prstatus-&gt;pr_cursig
op_assign
id|signr
suffix:semicolon
id|prstatus-&gt;pr_sigpend
op_assign
id|p-&gt;pending.signal.sig
(braket
l_int|0
)braket
suffix:semicolon
id|prstatus-&gt;pr_sighold
op_assign
id|p-&gt;blocked.sig
(braket
l_int|0
)braket
suffix:semicolon
id|prstatus-&gt;pr_pid
op_assign
id|p-&gt;pid
suffix:semicolon
id|prstatus-&gt;pr_ppid
op_assign
id|p-&gt;parent-&gt;pid
suffix:semicolon
id|prstatus-&gt;pr_pgrp
op_assign
id|process_group
c_func
(paren
id|p
)paren
suffix:semicolon
id|prstatus-&gt;pr_sid
op_assign
id|p-&gt;session
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|p-&gt;utime
comma
op_amp
id|prstatus-&gt;pr_utime
)paren
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|p-&gt;stime
comma
op_amp
id|prstatus-&gt;pr_stime
)paren
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|p-&gt;cutime
comma
op_amp
id|prstatus-&gt;pr_cutime
)paren
suffix:semicolon
id|jiffies_to_timeval
c_func
(paren
id|p-&gt;cstime
comma
op_amp
id|prstatus-&gt;pr_cstime
)paren
suffix:semicolon
)brace
DECL|function|fill_psinfo
r_static
r_void
id|fill_psinfo
c_func
(paren
r_struct
id|elf_prpsinfo
op_star
id|psinfo
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
id|i
comma
id|len
suffix:semicolon
multiline_comment|/* first copy the parameters from user space */
id|memset
c_func
(paren
id|psinfo
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|elf_prpsinfo
)paren
)paren
suffix:semicolon
id|len
op_assign
id|mm-&gt;arg_end
op_minus
id|mm-&gt;arg_start
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|ELF_PRARGSZ
)paren
id|len
op_assign
id|ELF_PRARGSZ
op_minus
l_int|1
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|psinfo-&gt;pr_psargs
comma
(paren
r_const
r_char
op_star
)paren
id|mm-&gt;arg_start
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|psinfo-&gt;pr_psargs
(braket
id|i
)braket
op_eq
l_int|0
)paren
id|psinfo-&gt;pr_psargs
(braket
id|i
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|psinfo-&gt;pr_psargs
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|psinfo-&gt;pr_pid
op_assign
id|p-&gt;pid
suffix:semicolon
id|psinfo-&gt;pr_ppid
op_assign
id|p-&gt;parent-&gt;pid
suffix:semicolon
id|psinfo-&gt;pr_pgrp
op_assign
id|process_group
c_func
(paren
id|p
)paren
suffix:semicolon
id|psinfo-&gt;pr_sid
op_assign
id|p-&gt;session
suffix:semicolon
id|i
op_assign
id|p-&gt;state
ques
c_cond
id|ffz
c_func
(paren
op_complement
id|p-&gt;state
)paren
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|psinfo-&gt;pr_state
op_assign
id|i
suffix:semicolon
id|psinfo-&gt;pr_sname
op_assign
(paren
id|i
template_param
l_int|5
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
l_string|&quot;RSDTZW&quot;
(braket
id|i
)braket
suffix:semicolon
id|psinfo-&gt;pr_zomb
op_assign
id|psinfo-&gt;pr_sname
op_eq
l_char|&squot;Z&squot;
suffix:semicolon
id|psinfo-&gt;pr_nice
op_assign
id|task_nice
c_func
(paren
id|p
)paren
suffix:semicolon
id|psinfo-&gt;pr_flag
op_assign
id|p-&gt;flags
suffix:semicolon
id|SET_UID
c_func
(paren
id|psinfo-&gt;pr_uid
comma
id|p-&gt;uid
)paren
suffix:semicolon
id|SET_GID
c_func
(paren
id|psinfo-&gt;pr_gid
comma
id|p-&gt;gid
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|psinfo-&gt;pr_fname
comma
id|p-&gt;comm
comma
r_sizeof
(paren
id|psinfo-&gt;pr_fname
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Here is the structure in which status of each thread is captured. */
DECL|struct|elf_thread_status
r_struct
id|elf_thread_status
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|prstatus
r_struct
id|elf_prstatus
id|prstatus
suffix:semicolon
multiline_comment|/* NT_PRSTATUS */
DECL|member|fpu
id|elf_fpregset_t
id|fpu
suffix:semicolon
multiline_comment|/* NT_PRFPREG */
macro_line|#ifdef ELF_CORE_COPY_XFPREGS
DECL|member|xfpu
id|elf_fpxregset_t
id|xfpu
suffix:semicolon
multiline_comment|/* NT_PRXFPREG */
macro_line|#endif
DECL|member|notes
r_struct
id|memelfnote
id|notes
(braket
l_int|3
)braket
suffix:semicolon
DECL|member|num_notes
r_int
id|num_notes
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * In order to add the specific thread information for the elf file format,&n; * we need to keep a linked list of every threads pr_status and then&n; * create a single section for them in the final core file.&n; */
DECL|function|elf_dump_thread_status
r_static
r_int
id|elf_dump_thread_status
c_func
(paren
r_int
id|signr
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|list_head
op_star
id|thread_list
)paren
(brace
r_struct
id|elf_thread_status
op_star
id|t
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
id|t
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|t
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|t
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|t
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|t-&gt;list
)paren
suffix:semicolon
id|t-&gt;num_notes
op_assign
l_int|0
suffix:semicolon
id|fill_prstatus
c_func
(paren
op_amp
id|t-&gt;prstatus
comma
id|p
comma
id|signr
)paren
suffix:semicolon
id|elf_core_copy_task_regs
c_func
(paren
id|p
comma
op_amp
id|t-&gt;prstatus.pr_reg
)paren
suffix:semicolon
id|fill_note
c_func
(paren
op_amp
id|t-&gt;notes
(braket
l_int|0
)braket
comma
l_string|&quot;CORE&quot;
comma
id|NT_PRSTATUS
comma
r_sizeof
(paren
id|t-&gt;prstatus
)paren
comma
op_amp
(paren
id|t-&gt;prstatus
)paren
)paren
suffix:semicolon
id|t-&gt;num_notes
op_increment
suffix:semicolon
id|sz
op_add_assign
id|notesize
c_func
(paren
op_amp
id|t-&gt;notes
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t-&gt;prstatus.pr_fpvalid
op_assign
id|elf_core_copy_task_fpregs
c_func
(paren
id|p
comma
l_int|NULL
comma
op_amp
id|t-&gt;fpu
)paren
)paren
)paren
(brace
id|fill_note
c_func
(paren
op_amp
id|t-&gt;notes
(braket
l_int|1
)braket
comma
l_string|&quot;CORE&quot;
comma
id|NT_PRFPREG
comma
r_sizeof
(paren
id|t-&gt;fpu
)paren
comma
op_amp
(paren
id|t-&gt;fpu
)paren
)paren
suffix:semicolon
id|t-&gt;num_notes
op_increment
suffix:semicolon
id|sz
op_add_assign
id|notesize
c_func
(paren
op_amp
id|t-&gt;notes
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef ELF_CORE_COPY_XFPREGS
r_if
c_cond
(paren
id|elf_core_copy_task_xfpregs
c_func
(paren
id|p
comma
op_amp
id|t-&gt;xfpu
)paren
)paren
(brace
id|fill_note
c_func
(paren
op_amp
id|t-&gt;notes
(braket
l_int|2
)braket
comma
l_string|&quot;LINUX&quot;
comma
id|NT_PRXFPREG
comma
r_sizeof
(paren
id|t-&gt;xfpu
)paren
comma
op_amp
id|t-&gt;xfpu
)paren
suffix:semicolon
id|t-&gt;num_notes
op_increment
suffix:semicolon
id|sz
op_add_assign
id|notesize
c_func
(paren
op_amp
id|t-&gt;notes
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif&t;
id|list_add
c_func
(paren
op_amp
id|t-&gt;list
comma
id|thread_list
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
multiline_comment|/*&n; * Actual dumper&n; *&n; * This is a two-pass process; first we find the offsets of the bits,&n; * and then they are actually written out.  If we run out of core limit&n; * we just truncate.&n; */
DECL|function|elf_core_dump
r_static
r_int
id|elf_core_dump
c_func
(paren
r_int
id|signr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|file
op_star
id|file
)paren
(brace
DECL|macro|NUM_NOTES
mdefine_line|#define&t;NUM_NOTES&t;6
r_int
id|has_dumped
op_assign
l_int|0
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|segs
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_struct
id|elfhdr
op_star
id|elf
op_assign
l_int|NULL
suffix:semicolon
id|off_t
id|offset
op_assign
l_int|0
comma
id|dataoff
suffix:semicolon
r_int
r_int
id|limit
op_assign
id|current-&gt;rlim
(braket
id|RLIMIT_CORE
)braket
dot
id|rlim_cur
suffix:semicolon
r_int
id|numnote
suffix:semicolon
r_struct
id|memelfnote
op_star
id|notes
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|elf_prstatus
op_star
id|prstatus
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NT_PRSTATUS */
r_struct
id|elf_prpsinfo
op_star
id|psinfo
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* NT_PRPSINFO */
r_struct
id|task_struct
op_star
id|g
comma
op_star
id|p
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|thread_list
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|t
suffix:semicolon
id|elf_fpregset_t
op_star
id|fpu
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef ELF_CORE_COPY_XFPREGS
id|elf_fpxregset_t
op_star
id|xfpu
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
r_int
id|thread_status_size
op_assign
l_int|0
suffix:semicolon
id|elf_addr_t
op_star
id|auxv
suffix:semicolon
multiline_comment|/*&n;&t; * We no longer stop all VM operations.&n;&t; * &n;&t; * This is because those proceses that could possibly change map_count or&n;&t; * the mmap / vma pages are now blocked in do_exit on current finishing&n;&t; * this core dump.&n;&t; *&n;&t; * Only ptrace can touch these memory addresses, but it doesn&squot;t change&n;&t; * the map_count or the pages allocated.  So no possibility of crashing&n;&t; * exists while dumping the mm-&gt;vm_next areas to the core file.&n;&t; */
multiline_comment|/* alloc memory for large data structures: too large to be on stack */
id|elf
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|elf
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elf
)paren
r_goto
id|cleanup
suffix:semicolon
id|prstatus
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|prstatus
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prstatus
)paren
r_goto
id|cleanup
suffix:semicolon
id|psinfo
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|psinfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|psinfo
)paren
r_goto
id|cleanup
suffix:semicolon
id|notes
op_assign
id|kmalloc
c_func
(paren
id|NUM_NOTES
op_star
r_sizeof
(paren
r_struct
id|memelfnote
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|notes
)paren
r_goto
id|cleanup
suffix:semicolon
id|fpu
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|fpu
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fpu
)paren
r_goto
id|cleanup
suffix:semicolon
macro_line|#ifdef ELF_CORE_COPY_XFPREGS
id|xfpu
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|xfpu
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfpu
)paren
r_goto
id|cleanup
suffix:semicolon
macro_line|#endif
multiline_comment|/* capture the status of all other threads */
r_if
c_cond
(paren
id|signr
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|do_each_thread
c_func
(paren
id|g
comma
id|p
)paren
r_if
c_cond
(paren
id|current-&gt;mm
op_eq
id|p-&gt;mm
op_logical_and
id|current
op_ne
id|p
)paren
(brace
r_int
id|sz
op_assign
id|elf_dump_thread_status
c_func
(paren
id|signr
comma
id|p
comma
op_amp
id|thread_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sz
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_else
id|thread_status_size
op_add_assign
id|sz
suffix:semicolon
)brace
id|while_each_thread
c_func
(paren
id|g
comma
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* now collect the dump for the current */
id|memset
c_func
(paren
id|prstatus
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|prstatus
)paren
)paren
suffix:semicolon
id|fill_prstatus
c_func
(paren
id|prstatus
comma
id|current
comma
id|signr
)paren
suffix:semicolon
id|elf_core_copy_regs
c_func
(paren
op_amp
id|prstatus-&gt;pr_reg
comma
id|regs
)paren
suffix:semicolon
id|segs
op_assign
id|current-&gt;mm-&gt;map_count
suffix:semicolon
macro_line|#ifdef ELF_CORE_EXTRA_PHDRS
id|segs
op_add_assign
id|ELF_CORE_EXTRA_PHDRS
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set up header */
id|fill_elf_header
c_func
(paren
id|elf
comma
id|segs
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* including notes section */
id|has_dumped
op_assign
l_int|1
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_DUMPCORE
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the notes in similar form to SVR4 core dumps made&n;&t; * with info from their /proc.&n;&t; */
id|fill_note
c_func
(paren
id|notes
op_plus
l_int|0
comma
l_string|&quot;CORE&quot;
comma
id|NT_PRSTATUS
comma
r_sizeof
(paren
op_star
id|prstatus
)paren
comma
id|prstatus
)paren
suffix:semicolon
id|fill_psinfo
c_func
(paren
id|psinfo
comma
id|current-&gt;group_leader
comma
id|current-&gt;mm
)paren
suffix:semicolon
id|fill_note
c_func
(paren
id|notes
op_plus
l_int|1
comma
l_string|&quot;CORE&quot;
comma
id|NT_PRPSINFO
comma
r_sizeof
(paren
op_star
id|psinfo
)paren
comma
id|psinfo
)paren
suffix:semicolon
id|fill_note
c_func
(paren
id|notes
op_plus
l_int|2
comma
l_string|&quot;CORE&quot;
comma
id|NT_TASKSTRUCT
comma
r_sizeof
(paren
op_star
id|current
)paren
comma
id|current
)paren
suffix:semicolon
id|numnote
op_assign
l_int|3
suffix:semicolon
id|auxv
op_assign
(paren
id|elf_addr_t
op_star
)paren
id|current-&gt;mm-&gt;saved_auxv
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
id|i
op_add_assign
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|auxv
(braket
id|i
op_minus
l_int|2
)braket
op_ne
id|AT_NULL
)paren
suffix:semicolon
id|fill_note
c_func
(paren
op_amp
id|notes
(braket
id|numnote
op_increment
)braket
comma
l_string|&quot;CORE&quot;
comma
id|NT_AUXV
comma
id|i
op_star
r_sizeof
(paren
id|elf_addr_t
)paren
comma
id|auxv
)paren
suffix:semicolon
multiline_comment|/* Try to dump the FPU. */
r_if
c_cond
(paren
(paren
id|prstatus-&gt;pr_fpvalid
op_assign
id|elf_core_copy_task_fpregs
c_func
(paren
id|current
comma
id|regs
comma
id|fpu
)paren
)paren
)paren
id|fill_note
c_func
(paren
id|notes
op_plus
id|numnote
op_increment
comma
l_string|&quot;CORE&quot;
comma
id|NT_PRFPREG
comma
r_sizeof
(paren
op_star
id|fpu
)paren
comma
id|fpu
)paren
suffix:semicolon
macro_line|#ifdef ELF_CORE_COPY_XFPREGS
r_if
c_cond
(paren
id|elf_core_copy_task_xfpregs
c_func
(paren
id|current
comma
id|xfpu
)paren
)paren
id|fill_note
c_func
(paren
id|notes
op_plus
id|numnote
op_increment
comma
l_string|&quot;LINUX&quot;
comma
id|NT_PRXFPREG
comma
r_sizeof
(paren
op_star
id|xfpu
)paren
comma
id|xfpu
)paren
suffix:semicolon
macro_line|#endif&t;
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
id|elf
comma
r_sizeof
(paren
op_star
id|elf
)paren
)paren
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
op_star
id|elf
)paren
suffix:semicolon
multiline_comment|/* Elf header */
id|offset
op_add_assign
(paren
id|segs
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|elf_phdr
)paren
suffix:semicolon
multiline_comment|/* Program headers */
multiline_comment|/* Write notes phdr entry */
(brace
r_struct
id|elf_phdr
id|phdr
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numnote
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|notesize
c_func
(paren
id|notes
op_plus
id|i
)paren
suffix:semicolon
id|sz
op_add_assign
id|thread_status_size
suffix:semicolon
id|fill_elf_note_phdr
c_func
(paren
op_amp
id|phdr
comma
id|sz
comma
id|offset
)paren
suffix:semicolon
id|offset
op_add_assign
id|sz
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
op_amp
id|phdr
comma
r_sizeof
(paren
id|phdr
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Page-align dumped data */
id|dataoff
op_assign
id|offset
op_assign
id|roundup
c_func
(paren
id|offset
comma
id|ELF_EXEC_PAGESIZE
)paren
suffix:semicolon
multiline_comment|/* Write program headers for segments dump */
r_for
c_loop
(paren
id|vma
op_assign
id|current-&gt;mm-&gt;mmap
suffix:semicolon
id|vma
op_ne
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_struct
id|elf_phdr
id|phdr
suffix:semicolon
r_int
id|sz
suffix:semicolon
id|sz
op_assign
id|vma-&gt;vm_end
op_minus
id|vma-&gt;vm_start
suffix:semicolon
id|phdr.p_type
op_assign
id|PT_LOAD
suffix:semicolon
id|phdr.p_offset
op_assign
id|offset
suffix:semicolon
id|phdr.p_vaddr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
id|phdr.p_paddr
op_assign
l_int|0
suffix:semicolon
id|phdr.p_filesz
op_assign
id|maydump
c_func
(paren
id|vma
)paren
ques
c_cond
id|sz
suffix:colon
l_int|0
suffix:semicolon
id|phdr.p_memsz
op_assign
id|sz
suffix:semicolon
id|offset
op_add_assign
id|phdr.p_filesz
suffix:semicolon
id|phdr.p_flags
op_assign
id|vma-&gt;vm_flags
op_amp
id|VM_READ
ques
c_cond
id|PF_R
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_WRITE
)paren
id|phdr.p_flags
op_or_assign
id|PF_W
suffix:semicolon
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_EXEC
)paren
id|phdr.p_flags
op_or_assign
id|PF_X
suffix:semicolon
id|phdr.p_align
op_assign
id|ELF_EXEC_PAGESIZE
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
op_amp
id|phdr
comma
r_sizeof
(paren
id|phdr
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef ELF_CORE_WRITE_EXTRA_PHDRS
id|ELF_CORE_WRITE_EXTRA_PHDRS
suffix:semicolon
macro_line|#endif
multiline_comment|/* write out the notes section */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numnote
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|writenote
c_func
(paren
id|notes
op_plus
id|i
comma
id|file
)paren
)paren
r_goto
id|end_coredump
suffix:semicolon
multiline_comment|/* write out the thread status notes section */
id|list_for_each
c_func
(paren
id|t
comma
op_amp
id|thread_list
)paren
(brace
r_struct
id|elf_thread_status
op_star
id|tmp
op_assign
id|list_entry
c_func
(paren
id|t
comma
r_struct
id|elf_thread_status
comma
id|list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|tmp-&gt;num_notes
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|writenote
c_func
(paren
op_amp
id|tmp-&gt;notes
(braket
id|i
)braket
comma
id|file
)paren
)paren
r_goto
id|end_coredump
suffix:semicolon
)brace
id|DUMP_SEEK
c_func
(paren
id|dataoff
)paren
suffix:semicolon
r_for
c_loop
(paren
id|vma
op_assign
id|current-&gt;mm-&gt;mmap
suffix:semicolon
id|vma
op_ne
l_int|NULL
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|maydump
c_func
(paren
id|vma
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|addr
op_assign
id|vma-&gt;vm_start
suffix:semicolon
id|addr
OL
id|vma-&gt;vm_end
suffix:semicolon
id|addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|vm_area_struct
op_star
id|vma
suffix:semicolon
r_if
c_cond
(paren
id|get_user_pages
c_func
(paren
id|current
comma
id|current-&gt;mm
comma
id|addr
comma
l_int|1
comma
l_int|0
comma
l_int|1
comma
op_amp
id|page
comma
op_amp
id|vma
)paren
op_le
l_int|0
)paren
(brace
id|DUMP_SEEK
(paren
id|file-&gt;f_pos
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|page
op_eq
id|ZERO_PAGE
c_func
(paren
id|addr
)paren
)paren
(brace
id|DUMP_SEEK
(paren
id|file-&gt;f_pos
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
r_void
op_star
id|kaddr
suffix:semicolon
id|flush_cache_page
c_func
(paren
id|vma
comma
id|addr
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|DUMP_WRITE
c_func
(paren
id|kaddr
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef ELF_CORE_WRITE_EXTRA_DATA
id|ELF_CORE_WRITE_EXTRA_DATA
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|off_t
)paren
id|file-&gt;f_pos
op_ne
id|offset
)paren
(brace
multiline_comment|/* Sanity check */
id|printk
c_func
(paren
l_string|&quot;elf_core_dump: file-&gt;f_pos (%ld) != offset (%ld)&bslash;n&quot;
comma
(paren
id|off_t
)paren
id|file-&gt;f_pos
comma
id|offset
)paren
suffix:semicolon
)brace
id|end_coredump
suffix:colon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
id|cleanup
suffix:colon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|thread_list
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|thread_list.next
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|elf_thread_status
comma
id|list
)paren
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|elf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|prstatus
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|psinfo
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|notes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fpu
)paren
suffix:semicolon
macro_line|#ifdef ELF_CORE_COPY_XFPREGS
id|kfree
c_func
(paren
id|xfpu
)paren
suffix:semicolon
macro_line|#endif
r_return
id|has_dumped
suffix:semicolon
DECL|macro|NUM_NOTES
macro_line|#undef NUM_NOTES
)brace
macro_line|#endif&t;&t;/* USE_ELF_CORE_DUMP */
DECL|function|init_elf_binfmt
r_static
r_int
id|__init
id|init_elf_binfmt
c_func
(paren
r_void
)paren
(brace
r_return
id|register_binfmt
c_func
(paren
op_amp
id|elf_format
)paren
suffix:semicolon
)brace
DECL|function|exit_elf_binfmt
r_static
r_void
id|__exit
id|exit_elf_binfmt
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Remove the COFF and ELF loaders. */
id|unregister_binfmt
c_func
(paren
op_amp
id|elf_format
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|init_elf_binfmt
)paren
id|module_exit
c_func
(paren
id|exit_elf_binfmt
)paren
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
