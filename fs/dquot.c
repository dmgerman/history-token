multiline_comment|/*&n; * Implementation of the diskquota system for the LINUX operating system. QUOTA&n; * is implemented using the BSD system call interface as the means of&n; * communication with the user level. This file contains the generic routines&n; * called by the different filesystems on allocation of an inode or block.&n; * These routines take care of the administration needed to have a consistent&n; * diskquota tracking system. The ideas of both user and group quotas are based&n; * on the Melbourne quota system as used on BSD derived systems. The internal&n; * implementation is based on one of the several variants of the LINUX&n; * inode-subsystem with added complexity of the diskquota system.&n; * &n; * Version: $Id: dquot.c,v 6.3 1996/11/17 18:35:34 mvw Exp mvw $&n; * &n; * Author:&t;Marco van Wieringen &lt;mvw@planets.elm.net&gt;&n; *&n; * Fixes:   Dmitry Gorodchanin &lt;pgmdsg@ibi.com&gt;, 11 Feb 96&n; *&n; *&t;&t;Revised list management to avoid races&n; *&t;&t;-- Bill Hawes, &lt;whawes@star.net&gt;, 9/98&n; *&n; *&t;&t;Fixed races in dquot_transfer(), dqget() and dquot_alloc_...().&n; *&t;&t;As the consequence the locking was moved from dquot_decr_...(),&n; *&t;&t;dquot_incr_...() to calling functions.&n; *&t;&t;invalidate_dquots() now writes modified dquots.&n; *&t;&t;Serialized quota_off() and quota_on() for mount point.&n; *&t;&t;Fixed a few bugs in grow_dquots().&n; *&t;&t;Fixed deadlock in write_dquot() - we no longer account quotas on&n; *&t;&t;quota files&n; *&t;&t;remove_dquot_ref() moved to inode.c - it now traverses through inodes&n; *&t;&t;add_dquot_ref() restarts after blocking&n; *&t;&t;Added check for bogus uid and fixed check for group in quotactl.&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, sponsored by SuSE CR, 10-11/99&n; *&n; *&t;&t;Used struct list_head instead of own list struct&n; *&t;&t;Invalidation of referenced dquots is no longer possible&n; *&t;&t;Improved free_dquots list management&n; *&t;&t;Quota and i_blocks are now updated in one place to avoid races&n; *&t;&t;Warnings are now delayed so we won&squot;t block in critical section&n; *&t;&t;Write updated not to require dquot lock&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, 9/2000&n; *&n; *&t;&t;Added dynamic quota structure allocation&n; *&t;&t;Jan Kara &lt;jack@suse.cz&gt; 12/2000&n; *&n; *&t;&t;Rewritten quota interface. Implemented new quota format and&n; *&t;&t;formats registering.&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, 2001,2002&n; *&n; *&t;&t;New SMP locking.&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, 10/2002&n; *&n; *&t;&t;Added journalled quota support&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, 2003,2004&n; *&n; * (C) Copyright 1994 - 1997 Marco van Wieringen &n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|__DQUOT_PARANOIA
mdefine_line|#define __DQUOT_PARANOIA
multiline_comment|/*&n; * There are two quota SMP locks. dq_list_lock protects all lists with quotas&n; * and quota formats and also dqstats structure containing statistics about the&n; * lists. dq_data_lock protects data from dq_dqb and also mem_dqinfo structures&n; * and also guards consistency of dquot-&gt;dq_dqb with inode-&gt;i_blocks, i_bytes.&n; * i_blocks and i_bytes updates itself are guarded by i_lock acquired directly&n; * in inode_add_bytes() and inode_sub_bytes().&n; *&n; * The spinlock ordering is hence: dq_data_lock &gt; dq_list_lock &gt; i_lock&n; *&n; * Note that some things (eg. sb pointer, type, id) doesn&squot;t change during&n; * the life of the dquot structure and so needn&squot;t to be protected by a lock&n; *&n; * Any operation working on dquots via inode pointers must hold dqptr_sem.  If&n; * operation is just reading pointers from inode (or not using them at all) the&n; * read lock is enough. If pointers are altered function must hold write lock.&n; * If operation is holding reference to dquot in other way (e.g. quotactl ops)&n; * it must be guarded by dqonoff_sem.&n; * This locking assures that:&n; *   a) update/access to dquot pointers in inode is serialized&n; *   b) everyone is guarded against invalidate_dquots()&n; *&n; * Each dquot has its dq_lock semaphore. Locked dquots might not be referenced&n; * from inodes (dquot_alloc_space() and such don&squot;t check the dq_lock).&n; * Currently dquot is locked only when it is being read to memory (or space for&n; * it is being allocated) on the first dqget() and when it is being released on&n; * the last dqput(). The allocation and release oparations are serialized by&n; * the dq_lock and by checking the use count in dquot_release().  Write&n; * operations on dquots don&squot;t hold dq_lock as they copy data under dq_data_lock&n; * spinlock to internal buffers before writing.&n; *&n; * Lock ordering (including journal_lock) is following:&n; *  dqonoff_sem &gt; journal_lock &gt; dqptr_sem &gt; dquot-&gt;dq_lock &gt; dqio_sem&n; */
DECL|variable|dq_list_lock
id|spinlock_t
id|dq_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|dq_data_lock
id|spinlock_t
id|dq_data_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|quotatypes
r_static
r_char
op_star
id|quotatypes
(braket
)braket
op_assign
id|INITQFNAMES
suffix:semicolon
DECL|variable|quota_formats
r_static
r_struct
id|quota_format_type
op_star
id|quota_formats
suffix:semicolon
multiline_comment|/* List of registered formats */
DECL|variable|module_names
r_static
r_struct
id|quota_module_name
id|module_names
(braket
)braket
op_assign
id|INIT_QUOTA_MODULE_NAMES
suffix:semicolon
DECL|function|register_quota_format
r_int
id|register_quota_format
c_func
(paren
r_struct
id|quota_format_type
op_star
id|fmt
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|fmt-&gt;qf_next
op_assign
id|quota_formats
suffix:semicolon
id|quota_formats
op_assign
id|fmt
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_quota_format
r_void
id|unregister_quota_format
c_func
(paren
r_struct
id|quota_format_type
op_star
id|fmt
)paren
(brace
r_struct
id|quota_format_type
op_star
op_star
id|actqf
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|actqf
op_assign
op_amp
id|quota_formats
suffix:semicolon
op_star
id|actqf
op_logical_and
op_star
id|actqf
op_ne
id|fmt
suffix:semicolon
id|actqf
op_assign
op_amp
(paren
op_star
id|actqf
)paren
op_member_access_from_pointer
id|qf_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|actqf
)paren
op_star
id|actqf
op_assign
(paren
op_star
id|actqf
)paren
op_member_access_from_pointer
id|qf_next
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
)brace
DECL|function|find_quota_format
r_static
r_struct
id|quota_format_type
op_star
id|find_quota_format
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|quota_format_type
op_star
id|actqf
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|actqf
op_assign
id|quota_formats
suffix:semicolon
id|actqf
op_logical_and
id|actqf-&gt;qf_fmt_id
op_ne
id|id
suffix:semicolon
id|actqf
op_assign
id|actqf-&gt;qf_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|actqf
op_logical_or
op_logical_neg
id|try_module_get
c_func
(paren
id|actqf-&gt;qf_owner
)paren
)paren
(brace
r_int
id|qm
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|qm
op_assign
l_int|0
suffix:semicolon
id|module_names
(braket
id|qm
)braket
dot
id|qm_fmt_id
op_logical_and
id|module_names
(braket
id|qm
)braket
dot
id|qm_fmt_id
op_ne
id|id
suffix:semicolon
id|qm
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|module_names
(braket
id|qm
)braket
dot
id|qm_fmt_id
op_logical_or
id|request_module
c_func
(paren
id|module_names
(braket
id|qm
)braket
dot
id|qm_mod_name
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|actqf
op_assign
id|quota_formats
suffix:semicolon
id|actqf
op_logical_and
id|actqf-&gt;qf_fmt_id
op_ne
id|id
suffix:semicolon
id|actqf
op_assign
id|actqf-&gt;qf_next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actqf
op_logical_and
op_logical_neg
id|try_module_get
c_func
(paren
id|actqf-&gt;qf_owner
)paren
)paren
id|actqf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_return
id|actqf
suffix:semicolon
)brace
DECL|function|put_quota_format
r_static
r_void
id|put_quota_format
c_func
(paren
r_struct
id|quota_format_type
op_star
id|fmt
)paren
(brace
id|module_put
c_func
(paren
id|fmt-&gt;qf_owner
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dquot List Management:&n; * The quota code uses three lists for dquot management: the inuse_list,&n; * free_dquots, and dquot_hash[] array. A single dquot structure may be&n; * on all three lists, depending on its current state.&n; *&n; * All dquots are placed to the end of inuse_list when first created, and this&n; * list is used for the sync and invalidate operations, which must look&n; * at every dquot.&n; *&n; * Unused dquots (dq_count == 0) are added to the free_dquots list when freed,&n; * and this list is searched whenever we need an available dquot.  Dquots are&n; * removed from the list as soon as they are used again, and&n; * dqstats.free_dquots gives the number of dquots on the list. When&n; * dquot is invalidated it&squot;s completely released from memory.&n; *&n; * Dquots with a specific identity (device, type and id) are placed on&n; * one of the dquot_hash[] hash chains. The provides an efficient search&n; * mechanism to locate a specific dquot.&n; */
r_static
id|LIST_HEAD
c_func
(paren
id|inuse_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|free_dquots
)paren
suffix:semicolon
DECL|variable|dq_hash_bits
DECL|variable|dq_hash_mask
r_int
r_int
id|dq_hash_bits
comma
id|dq_hash_mask
suffix:semicolon
DECL|variable|dquot_hash
r_static
r_struct
id|hlist_head
op_star
id|dquot_hash
suffix:semicolon
DECL|variable|dqstats
r_struct
id|dqstats
id|dqstats
suffix:semicolon
r_static
r_void
id|dqput
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
suffix:semicolon
DECL|function|hashfn
r_static
r_inline
r_int
r_const
id|hashfn
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|tmp
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|sb
op_rshift
id|L1_CACHE_SHIFT
)paren
op_xor
id|id
)paren
op_star
(paren
id|MAXQUOTAS
op_minus
id|type
)paren
suffix:semicolon
r_return
(paren
id|tmp
op_plus
(paren
id|tmp
op_rshift
id|dq_hash_bits
)paren
)paren
op_amp
id|dq_hash_mask
suffix:semicolon
)brace
multiline_comment|/*&n; * Following list functions expect dq_list_lock to be held&n; */
DECL|function|insert_dquot_hash
r_static
r_inline
r_void
id|insert_dquot_hash
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_struct
id|hlist_head
op_star
id|head
op_assign
id|dquot_hash
op_plus
id|hashfn
c_func
(paren
id|dquot-&gt;dq_sb
comma
id|dquot-&gt;dq_id
comma
id|dquot-&gt;dq_type
)paren
suffix:semicolon
id|hlist_add_head
c_func
(paren
op_amp
id|dquot-&gt;dq_hash
comma
id|head
)paren
suffix:semicolon
)brace
DECL|function|remove_dquot_hash
r_static
r_inline
r_void
id|remove_dquot_hash
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|hlist_del_init
c_func
(paren
op_amp
id|dquot-&gt;dq_hash
)paren
suffix:semicolon
)brace
DECL|function|find_dquot
r_static
r_inline
r_struct
id|dquot
op_star
id|find_dquot
c_func
(paren
r_int
r_int
id|hashent
comma
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_struct
id|hlist_node
op_star
id|node
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|hlist_for_each
(paren
id|node
comma
id|dquot_hash
op_plus
id|hashent
)paren
(brace
id|dquot
op_assign
id|hlist_entry
c_func
(paren
id|node
comma
r_struct
id|dquot
comma
id|dq_hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_sb
op_eq
id|sb
op_logical_and
id|dquot-&gt;dq_id
op_eq
id|id
op_logical_and
id|dquot-&gt;dq_type
op_eq
id|type
)paren
r_return
id|dquot
suffix:semicolon
)brace
r_return
id|NODQUOT
suffix:semicolon
)brace
multiline_comment|/* Add a dquot to the tail of the free list */
DECL|function|put_dquot_last
r_static
r_inline
r_void
id|put_dquot_last
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
id|free_dquots.prev
)paren
suffix:semicolon
id|dqstats.free_dquots
op_increment
suffix:semicolon
)brace
DECL|function|remove_free_dquot
r_static
r_inline
r_void
id|remove_free_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
)paren
r_return
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|dqstats.free_dquots
op_decrement
suffix:semicolon
)brace
DECL|function|put_inuse
r_static
r_inline
r_void
id|put_inuse
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
multiline_comment|/* We add to the back of inuse list so we don&squot;t have to restart&n;&t; * when traversing this list and we block */
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_inuse
comma
id|inuse_list.prev
)paren
suffix:semicolon
id|dqstats.allocated_dquots
op_increment
suffix:semicolon
)brace
DECL|function|remove_inuse
r_static
r_inline
r_void
id|remove_inuse
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|dqstats.allocated_dquots
op_decrement
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_inuse
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * End of list functions needing dq_list_lock&n; */
DECL|function|wait_on_dquot
r_static
r_void
id|wait_on_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|down
c_func
(paren
op_amp
id|dquot-&gt;dq_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dquot-&gt;dq_lock
)paren
suffix:semicolon
)brace
DECL|macro|mark_dquot_dirty
mdefine_line|#define mark_dquot_dirty(dquot) ((dquot)-&gt;dq_sb-&gt;dq_op-&gt;mark_dirty(dquot))
DECL|function|dquot_mark_dquot_dirty
r_int
id|dquot_mark_dquot_dirty
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|DQ_MOD_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_dirty
comma
op_amp
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_dirty_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function needs dq_list_lock */
DECL|function|clear_dquot_dirty
r_static
r_inline
r_int
id|clear_dquot_dirty
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|DQ_MOD_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|dquot-&gt;dq_dirty
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|mark_info_dirty
r_void
id|mark_info_dirty
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
id|set_bit
c_func
(paren
id|DQF_INFO_DIRTY_B
comma
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
(braket
id|type
)braket
dot
id|dqi_flags
)paren
suffix:semicolon
)brace
DECL|variable|mark_info_dirty
id|EXPORT_SYMBOL
c_func
(paren
id|mark_info_dirty
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Read dquot from disk and alloc space for it&n; */
DECL|function|dquot_acquire
r_int
id|dquot_acquire
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dquot-&gt;dq_lock
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DQ_READ_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
id|ret
op_assign
id|dqopt-&gt;ops
(braket
id|dquot-&gt;dq_type
)braket
op_member_access_from_pointer
id|read_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out_iolock
suffix:semicolon
id|set_bit
c_func
(paren
id|DQ_READ_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
multiline_comment|/* Instantiate dquot if needed */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
op_logical_and
op_logical_neg
id|dquot-&gt;dq_off
)paren
(brace
id|ret
op_assign
id|dqopt-&gt;ops
(braket
id|dquot-&gt;dq_type
)braket
op_member_access_from_pointer
id|commit_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out_iolock
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
id|out_iolock
suffix:colon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dquot-&gt;dq_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write dquot to disk&n; */
DECL|function|dquot_commit
r_int
id|dquot_commit
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_dquot_dirty
c_func
(paren
id|dquot
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_goto
id|out_sem
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
multiline_comment|/* Inactive dquot can be only if there was error during read/init&n;&t; * =&gt; we have better not writing it */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
id|ret
op_assign
id|dqopt-&gt;ops
(braket
id|dquot-&gt;dq_type
)braket
op_member_access_from_pointer
id|commit_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|out_sem
suffix:colon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info_dirty
c_func
(paren
op_amp
id|dqopt-&gt;info
(braket
id|dquot-&gt;dq_type
)braket
)paren
)paren
id|dquot-&gt;dq_sb-&gt;dq_op
op_member_access_from_pointer
id|write_info
c_func
(paren
id|dquot-&gt;dq_sb
comma
id|dquot-&gt;dq_type
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Release dquot&n; */
DECL|function|dquot_release
r_int
id|dquot_release
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dquot-&gt;dq_lock
)paren
suffix:semicolon
multiline_comment|/* Check whether we are not racing with some other dqget() */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
OG
l_int|1
)paren
r_goto
id|out_dqlock
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|ret
op_assign
id|dqopt-&gt;ops
(braket
id|dquot-&gt;dq_type
)braket
op_member_access_from_pointer
id|release_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|out_dqlock
suffix:colon
id|up
c_func
(paren
op_amp
id|dquot-&gt;dq_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Invalidate all dquots on the list. Note that this function is called after&n; * quota is disabled and pointers from inodes removed so there cannot be new&n; * quota users. Also because we hold dqonoff_sem there can be no quota users&n; * for this sb+type at all. */
DECL|function|invalidate_dquots
r_static
r_void
id|invalidate_dquots
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_struct
id|list_head
op_star
id|head
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|head
op_assign
id|inuse_list.next
suffix:semicolon
id|head
op_ne
op_amp
id|inuse_list
suffix:semicolon
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|dquot
comma
id|dq_inuse
)paren
suffix:semicolon
id|head
op_assign
id|head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_sb
op_ne
id|sb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_type
op_ne
id|type
)paren
r_continue
suffix:semicolon
macro_line|#ifdef __DQUOT_PARANOIA
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Quota now has no users and it has been written on last dqput() */
id|remove_dquot_hash
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_inuse
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|dquot_cachep
comma
id|dquot
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
)brace
DECL|function|vfs_quota_sync
r_int
id|vfs_quota_sync
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|list_head
op_star
id|dirty
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqonoff_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|cnt
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|dirty
op_assign
op_amp
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_dirty_list
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|dirty
)paren
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|dirty-&gt;next
comma
r_struct
id|dquot
comma
id|dq_dirty
)paren
suffix:semicolon
multiline_comment|/* Dirty and inactive can be only bad dquot... */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
(brace
id|clear_dquot_dirty
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Now we have active dquot from which someone is&n; &t;&t;&t; * holding reference so we can safely just increase&n;&t;&t;&t; * use count */
id|atomic_inc
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
suffix:semicolon
id|dqstats.lookups
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|sb-&gt;dq_op
op_member_access_from_pointer
id|write_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
(paren
id|cnt
op_eq
id|type
op_logical_or
id|type
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|cnt
)paren
op_logical_and
id|info_dirty
c_func
(paren
op_amp
id|dqopt-&gt;info
(braket
id|cnt
)braket
)paren
)paren
id|sb-&gt;dq_op
op_member_access_from_pointer
id|write_info
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|dqstats.syncs
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqonoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free unused dquots from cache */
DECL|function|prune_dqcache
r_static
r_void
id|prune_dqcache
c_func
(paren
r_int
id|count
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|head
op_assign
id|free_dquots.prev
suffix:semicolon
r_while
c_loop
(paren
id|head
op_ne
op_amp
id|free_dquots
op_logical_and
id|count
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|dquot
comma
id|dq_free
)paren
suffix:semicolon
id|remove_dquot_hash
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_inuse
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|dquot_cachep
comma
id|dquot
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|head
op_assign
id|free_dquots.prev
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called from kswapd when we think we need some&n; * more memory&n; */
DECL|function|shrink_dqcache_memory
r_static
r_int
id|shrink_dqcache_memory
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|gfp_mask
)paren
(brace
r_int
id|ret
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
id|prune_dqcache
c_func
(paren
id|nr
)paren
suffix:semicolon
id|ret
op_assign
id|dqstats.allocated_dquots
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Put reference to dquot&n; * NOTE: If you change this function please check whether dqput_blocks() works right...&n; * MUST be called with either dqptr_sem or dqonoff_sem held&n; */
DECL|function|dqput
r_static
r_void
id|dqput
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
r_return
suffix:semicolon
macro_line|#ifdef __DQUOT_PARANOIA
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: dqput: trying to free free dquot&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VFS: device %s, dquot of %s %d&bslash;n&quot;
comma
id|dquot-&gt;dq_sb-&gt;s_id
comma
id|quotatypes
(braket
id|dquot-&gt;dq_type
)braket
comma
id|dquot-&gt;dq_id
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|dqstats.drops
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|we_slept
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
OG
l_int|1
)paren
(brace
multiline_comment|/* We have more than one user... nothing to do */
id|atomic_dec
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Need to release dquot? */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
op_logical_and
id|dquot_dirty
c_func
(paren
id|dquot
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
multiline_comment|/* Commit dquot before releasing */
id|dquot-&gt;dq_sb-&gt;dq_op
op_member_access_from_pointer
id|write_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_goto
id|we_slept
suffix:semicolon
)brace
multiline_comment|/* Clear flag in case dquot was inactive (something bad happened) */
id|clear_dquot_dirty
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|dquot-&gt;dq_sb-&gt;dq_op
op_member_access_from_pointer
id|release_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_goto
id|we_slept
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
suffix:semicolon
macro_line|#ifdef __DQUOT_PARANOIA
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|put_dquot_last
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
)brace
DECL|function|get_empty_dquot
r_static
r_struct
id|dquot
op_star
id|get_empty_dquot
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|dquot
op_assign
id|kmem_cache_alloc
c_func
(paren
id|dquot_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
(brace
r_return
id|NODQUOT
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|dquot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dquot
)paren
)paren
suffix:semicolon
id|sema_init
c_func
(paren
op_amp
id|dquot-&gt;dq_lock
comma
l_int|1
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_inuse
)paren
suffix:semicolon
id|INIT_HLIST_NODE
c_func
(paren
op_amp
id|dquot-&gt;dq_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_dirty
)paren
suffix:semicolon
id|dquot-&gt;dq_sb
op_assign
id|sb
suffix:semicolon
id|dquot-&gt;dq_type
op_assign
id|type
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|dquot-&gt;dq_count
comma
l_int|1
)paren
suffix:semicolon
r_return
id|dquot
suffix:semicolon
)brace
multiline_comment|/*&n; * Get reference to dquot&n; * MUST be called with either dqptr_sem or dqonoff_sem held&n; */
DECL|function|dqget
r_static
r_struct
id|dquot
op_star
id|dqget
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|hashent
op_assign
id|hashfn
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
comma
op_star
id|empty
op_assign
id|NODQUOT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|type
)paren
)paren
r_return
id|NODQUOT
suffix:semicolon
id|we_slept
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dquot
op_assign
id|find_dquot
c_func
(paren
id|hashent
comma
id|sb
comma
id|id
comma
id|type
)paren
)paren
op_eq
id|NODQUOT
)paren
(brace
r_if
c_cond
(paren
id|empty
op_eq
id|NODQUOT
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|empty
op_assign
id|get_empty_dquot
c_func
(paren
id|sb
comma
id|type
)paren
)paren
op_eq
id|NODQUOT
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Try to wait for a moment... */
r_goto
id|we_slept
suffix:semicolon
)brace
id|dquot
op_assign
id|empty
suffix:semicolon
id|dquot-&gt;dq_id
op_assign
id|id
suffix:semicolon
multiline_comment|/* all dquots go on the inuse_list */
id|put_inuse
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* hash it first so it can be found */
id|insert_dquot_hash
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dqstats.lookups
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
)paren
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
suffix:semicolon
id|dqstats.cache_hits
op_increment
suffix:semicolon
id|dqstats.lookups
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
id|kmem_cache_free
c_func
(paren
id|dquot_cachep
comma
id|empty
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for dq_lock - after this we know that either dquot_release() is already&n;&t; * finished or it will be canceled due to dq_count &gt; 1 test */
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* Read the dquot and instantiate it (everything done only if needed) */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|DQ_ACTIVE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
op_logical_and
id|sb-&gt;dq_op
op_member_access_from_pointer
id|acquire_dquot
c_func
(paren
id|dquot
)paren
OL
l_int|0
)paren
(brace
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
id|NODQUOT
suffix:semicolon
)brace
macro_line|#ifdef __DQUOT_PARANOIA
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
multiline_comment|/* Has somebody invalidated entry under us? */
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|dquot
suffix:semicolon
)brace
DECL|function|dqinit_needed
r_static
r_int
id|dqinit_needed
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
r_return
id|inode-&gt;i_dquot
(braket
id|type
)braket
op_eq
id|NODQUOT
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This routine is guarded by dqonoff_sem semaphore */
DECL|function|add_dquot_ref
r_static
r_void
id|add_dquot_ref
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|restart
suffix:colon
id|file_list_lock
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|sb-&gt;s_files
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|file
comma
id|f_list
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|dqinit_needed
c_func
(paren
id|inode
comma
id|type
)paren
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|dget
c_func
(paren
id|filp-&gt;f_dentry
)paren
suffix:semicolon
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|inode
comma
id|type
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* As we may have blocked we had better restart... */
r_goto
id|restart
suffix:semicolon
)brace
)brace
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Return 0 if dqput() won&squot;t block (note that 1 doesn&squot;t necessarily mean blocking) */
DECL|function|dqput_blocks
r_static
r_inline
r_int
id|dqput_blocks
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
op_le
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remove references to dquots from inode - add dquot to list for freeing if needed */
multiline_comment|/* We can&squot;t race with anybody because we hold dqptr_sem for writing... */
DECL|function|remove_inode_dquot_ref
r_int
id|remove_inode_dquot_ref
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
comma
r_struct
id|list_head
op_star
id|tofree_head
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
op_assign
id|inode-&gt;i_dquot
(braket
id|type
)braket
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|type
)braket
op_assign
id|NODQUOT
suffix:semicolon
multiline_comment|/* any other quota in use? */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
r_goto
id|put_it
suffix:semicolon
)brace
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_QUOTA
suffix:semicolon
id|put_it
suffix:colon
r_if
c_cond
(paren
id|dquot
op_ne
id|NODQUOT
)paren
(brace
r_if
c_cond
(paren
id|dqput_blocks
c_func
(paren
id|dquot
)paren
)paren
(brace
macro_line|#ifdef __DQUOT_PARANOIA
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFS: Adding dquot with dq_count %d to dispose list.&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|dquot-&gt;dq_count
)paren
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
id|tofree_head
)paren
suffix:semicolon
multiline_comment|/* As dquot must have currently users it can&squot;t be on the free list... */
id|spin_unlock
c_func
(paren
op_amp
id|dq_list_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* We have guaranteed we won&squot;t block */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free list of dquots - called from inode.c */
multiline_comment|/* dquots are removed from inodes, no new references can be got so we are the only ones holding reference */
DECL|function|put_dquot_list
r_static
r_void
id|put_dquot_list
c_func
(paren
r_struct
id|list_head
op_star
id|tofree_head
)paren
(brace
r_struct
id|list_head
op_star
id|act_head
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|act_head
op_assign
id|tofree_head-&gt;next
suffix:semicolon
multiline_comment|/* So now we have dquots on the list... Just free them */
r_while
c_loop
(paren
id|act_head
op_ne
id|tofree_head
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|act_head
comma
r_struct
id|dquot
comma
id|dq_free
)paren
suffix:semicolon
id|act_head
op_assign
id|act_head-&gt;next
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
multiline_comment|/* Remove dquot from the list so we won&squot;t have problems... */
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Function in inode.c - remove pointers to dquots in icache */
r_extern
r_void
id|remove_dquot_ref
c_func
(paren
r_struct
id|super_block
op_star
comma
r_int
comma
r_struct
id|list_head
op_star
)paren
suffix:semicolon
multiline_comment|/* Gather all references from inodes and drop them */
DECL|function|drop_dquot_ref
r_static
r_void
id|drop_dquot_ref
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|tofree_head
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
id|remove_dquot_ref
c_func
(paren
id|sb
comma
id|type
comma
op_amp
id|tofree_head
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
id|put_dquot_list
c_func
(paren
op_amp
id|tofree_head
)paren
suffix:semicolon
)brace
DECL|function|dquot_incr_inodes
r_static
r_inline
r_void
id|dquot_incr_inodes
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
id|dquot-&gt;dq_dqb.dqb_curinodes
op_add_assign
id|number
suffix:semicolon
)brace
DECL|function|dquot_incr_space
r_static
r_inline
r_void
id|dquot_incr_space
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|qsize_t
id|number
)paren
(brace
id|dquot-&gt;dq_dqb.dqb_curspace
op_add_assign
id|number
suffix:semicolon
)brace
DECL|function|dquot_decr_inodes
r_static
r_inline
r_void
id|dquot_decr_inodes
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
OG
id|number
)paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_sub_assign
id|number
suffix:semicolon
r_else
id|dquot-&gt;dq_dqb.dqb_curinodes
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
OL
id|dquot-&gt;dq_dqb.dqb_isoftlimit
)paren
id|dquot-&gt;dq_dqb.dqb_itime
op_assign
(paren
id|time_t
)paren
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|DQ_INODES_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
)brace
DECL|function|dquot_decr_space
r_static
r_inline
r_void
id|dquot_decr_space
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|qsize_t
id|number
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
OG
id|number
)paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_sub_assign
id|number
suffix:semicolon
r_else
id|dquot-&gt;dq_dqb.dqb_curspace
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
)paren
OL
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
)paren
id|dquot-&gt;dq_dqb.dqb_btime
op_assign
(paren
id|time_t
)paren
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|DQ_BLKS_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
)brace
DECL|function|need_print_warning
r_static
r_inline
r_int
id|need_print_warning
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_switch
c_cond
(paren
id|dquot-&gt;dq_type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
r_return
id|current-&gt;fsuid
op_eq
id|dquot-&gt;dq_id
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
r_return
id|in_group_p
c_func
(paren
id|dquot-&gt;dq_id
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Values of warnings */
DECL|macro|NOWARN
mdefine_line|#define NOWARN 0
DECL|macro|IHARDWARN
mdefine_line|#define IHARDWARN 1
DECL|macro|ISOFTLONGWARN
mdefine_line|#define ISOFTLONGWARN 2
DECL|macro|ISOFTWARN
mdefine_line|#define ISOFTWARN 3
DECL|macro|BHARDWARN
mdefine_line|#define BHARDWARN 4
DECL|macro|BSOFTLONGWARN
mdefine_line|#define BSOFTLONGWARN 5
DECL|macro|BSOFTWARN
mdefine_line|#define BSOFTWARN 6
multiline_comment|/* Print warning to user which exceeded quota */
DECL|function|print_warning
r_static
r_void
id|print_warning
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_const
r_char
id|warntype
)paren
(brace
r_char
op_star
id|msg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|flag
op_assign
(paren
id|warntype
op_eq
id|BHARDWARN
op_logical_or
id|warntype
op_eq
id|BSOFTLONGWARN
)paren
ques
c_cond
id|DQ_BLKS_B
suffix:colon
(paren
(paren
id|warntype
op_eq
id|IHARDWARN
op_logical_or
id|warntype
op_eq
id|ISOFTLONGWARN
)paren
ques
c_cond
id|DQ_INODES_B
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|need_print_warning
c_func
(paren
id|dquot
)paren
op_logical_or
(paren
id|flag
op_logical_and
id|test_and_set_bit
c_func
(paren
id|flag
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
)paren
r_return
suffix:semicolon
id|tty_write_message
c_func
(paren
id|current-&gt;signal-&gt;tty
comma
id|dquot-&gt;dq_sb-&gt;s_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warntype
op_eq
id|ISOFTWARN
op_logical_or
id|warntype
op_eq
id|BSOFTWARN
)paren
id|tty_write_message
c_func
(paren
id|current-&gt;signal-&gt;tty
comma
l_string|&quot;: warning, &quot;
)paren
suffix:semicolon
r_else
id|tty_write_message
c_func
(paren
id|current-&gt;signal-&gt;tty
comma
l_string|&quot;: write failed, &quot;
)paren
suffix:semicolon
id|tty_write_message
c_func
(paren
id|current-&gt;signal-&gt;tty
comma
id|quotatypes
(braket
id|dquot-&gt;dq_type
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|warntype
)paren
(brace
r_case
id|IHARDWARN
suffix:colon
id|msg
op_assign
l_string|&quot; file limit reached.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISOFTLONGWARN
suffix:colon
id|msg
op_assign
l_string|&quot; file quota exceeded too long.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISOFTWARN
suffix:colon
id|msg
op_assign
l_string|&quot; file quota exceeded.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BHARDWARN
suffix:colon
id|msg
op_assign
l_string|&quot; block limit reached.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BSOFTLONGWARN
suffix:colon
id|msg
op_assign
l_string|&quot; block quota exceeded too long.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BSOFTWARN
suffix:colon
id|msg
op_assign
l_string|&quot; block quota exceeded.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tty_write_message
c_func
(paren
id|current-&gt;signal-&gt;tty
comma
id|msg
)paren
suffix:semicolon
)brace
DECL|function|flush_warnings
r_static
r_inline
r_void
id|flush_warnings
c_func
(paren
r_struct
id|dquot
op_star
op_star
id|dquots
comma
r_char
op_star
id|warntype
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXQUOTAS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dquots
(braket
id|i
)braket
op_ne
id|NODQUOT
op_logical_and
id|warntype
(braket
id|i
)braket
op_ne
id|NOWARN
)paren
id|print_warning
c_func
(paren
id|dquots
(braket
id|i
)braket
comma
id|warntype
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|ignore_hardlimit
r_static
r_inline
r_char
id|ignore_hardlimit
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
op_amp
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
suffix:semicolon
r_return
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
op_logical_and
(paren
id|info-&gt;dqi_format-&gt;qf_fmt_id
op_ne
id|QFMT_VFS_OLD
op_logical_or
op_logical_neg
(paren
id|info-&gt;dqi_flags
op_amp
id|V1_DQF_RSQUASH
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* needs dq_data_lock */
DECL|function|check_idq
r_static
r_int
id|check_idq
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|ulong
id|inodes
comma
r_char
op_star
id|warntype
)paren
(brace
op_star
id|warntype
op_assign
id|NOWARN
suffix:semicolon
r_if
c_cond
(paren
id|inodes
op_le
l_int|0
op_logical_or
id|test_bit
c_func
(paren
id|DQ_FAKE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
r_return
id|QUOTA_OK
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_ihardlimit
op_logical_and
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_dqb.dqb_ihardlimit
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
op_star
id|warntype
op_assign
id|IHARDWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_itime
op_logical_and
id|get_seconds
c_func
(paren
)paren
op_ge
id|dquot-&gt;dq_dqb.dqb_itime
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
op_star
id|warntype
op_assign
id|ISOFTLONGWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_itime
op_eq
l_int|0
)paren
(brace
op_star
id|warntype
op_assign
id|ISOFTWARN
suffix:semicolon
id|dquot-&gt;dq_dqb.dqb_itime
op_assign
id|get_seconds
c_func
(paren
)paren
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_igrace
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
)brace
multiline_comment|/* needs dq_data_lock */
DECL|function|check_bdq
r_static
r_int
id|check_bdq
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|qsize_t
id|space
comma
r_int
id|prealloc
comma
r_char
op_star
id|warntype
)paren
(brace
op_star
id|warntype
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|space
op_le
l_int|0
op_logical_or
id|test_bit
c_func
(paren
id|DQ_FAKE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
)paren
r_return
id|QUOTA_OK
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_bhardlimit
op_logical_and
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_plus
id|space
)paren
OG
id|dquot-&gt;dq_dqb.dqb_bhardlimit
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
op_star
id|warntype
op_assign
id|BHARDWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_plus
id|space
)paren
OG
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_btime
op_logical_and
id|get_seconds
c_func
(paren
)paren
op_ge
id|dquot-&gt;dq_dqb.dqb_btime
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
op_star
id|warntype
op_assign
id|BSOFTLONGWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_plus
id|space
)paren
OG
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_btime
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
(brace
op_star
id|warntype
op_assign
id|BSOFTWARN
suffix:semicolon
id|dquot-&gt;dq_dqb.dqb_btime
op_assign
id|get_seconds
c_func
(paren
)paren
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_bgrace
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t allow preallocation to exceed softlimit so exceeding will&n;&t;&t;&t; * be always printed&n;&t;&t;&t; */
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Initialize quota pointers in inode&n; *&t;Transaction must be started at entry&n; */
DECL|function|dquot_initialize
r_int
id|dquot_initialize
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|id
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
comma
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* First test before acquiring semaphore - solves deadlocks when we&n;         * re-enter the quota code and are already holding the semaphore */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
multiline_comment|/* Having dqptr_sem we know NOQUOTA flags can&squot;t be altered... */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_goto
id|out_err
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|cnt
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
(brace
r_switch
c_cond
(paren
id|cnt
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|id
op_assign
id|inode-&gt;i_uid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|id
op_assign
id|inode-&gt;i_gid
suffix:semicolon
r_break
suffix:semicolon
)brace
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|id
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
id|inode-&gt;i_flags
op_or_assign
id|S_QUOTA
suffix:semicolon
)brace
)brace
id|out_err
suffix:colon
id|up_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Release all quotas referenced by inode&n; *&t;Transaction must be started at an entry&n; */
DECL|function|dquot_drop
r_int
id|dquot_drop
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|cnt
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_QUOTA
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
(brace
id|dqput
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
)brace
)brace
id|up_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Following four functions update i_blocks+i_bytes fields and&n; * quota information (together with appropriate checks)&n; * NOTE: We absolutely rely on the fact that caller dirties&n; * the inode (usually macros in quotaops.h care about this) and&n; * holds a handle for the current transaction so that dquot write and&n; * inode write go into the same transaction.&n; */
multiline_comment|/*&n; * This operation can block, but only after everything is updated&n; */
DECL|function|dquot_alloc_space
r_int
id|dquot_alloc_space
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|qsize_t
id|number
comma
r_int
id|warn
)paren
(brace
r_int
id|cnt
comma
id|ret
op_assign
id|NO_QUOTA
suffix:semicolon
r_char
id|warntype
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
multiline_comment|/* First test before acquiring semaphore - solves deadlocks when we&n;         * re-enter the quota code and are already holding the semaphore */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
(brace
id|out_add
suffix:colon
id|inode_add_bytes
c_func
(paren
id|inode
comma
id|number
)paren
suffix:semicolon
r_return
id|QUOTA_OK
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
id|warntype
(braket
id|cnt
)braket
op_assign
id|NOWARN
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* Now we can do reliable test... */
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_goto
id|out_add
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_bdq
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
comma
id|number
comma
id|warn
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
)paren
r_goto
id|warn_put_all
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_incr_space
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
)brace
id|inode_add_bytes
c_func
(paren
id|inode
comma
id|number
)paren
suffix:semicolon
id|ret
op_assign
id|QUOTA_OK
suffix:semicolon
id|warn_put_all
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|QUOTA_OK
)paren
multiline_comment|/* Dirtify all the dquots - this can block when journalling */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
id|mark_dquot_dirty
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|flush_warnings
c_func
(paren
id|inode-&gt;i_dquot
comma
id|warntype
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This operation can block, but only after everything is updated&n; */
DECL|function|dquot_alloc_inode
r_int
id|dquot_alloc_inode
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
)paren
(brace
r_int
id|cnt
comma
id|ret
op_assign
id|NO_QUOTA
suffix:semicolon
r_char
id|warntype
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
multiline_comment|/* First test before acquiring semaphore - solves deadlocks when we&n;         * re-enter the quota code and are already holding the semaphore */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_return
id|QUOTA_OK
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
id|warntype
(braket
id|cnt
)braket
op_assign
id|NOWARN
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|QUOTA_OK
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_idq
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
comma
id|number
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
)paren
r_goto
id|warn_put_all
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_incr_inodes
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|QUOTA_OK
suffix:semicolon
id|warn_put_all
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|QUOTA_OK
)paren
multiline_comment|/* Dirtify all the dquots - this can block when journalling */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
id|mark_dquot_dirty
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|flush_warnings
c_func
(paren
(paren
r_struct
id|dquot
op_star
op_star
)paren
id|inode-&gt;i_dquot
comma
id|warntype
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a non-blocking operation.&n; */
DECL|function|dquot_free_space
r_int
id|dquot_free_space
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|qsize_t
id|number
)paren
(brace
r_int
r_int
id|cnt
suffix:semicolon
multiline_comment|/* First test before acquiring semaphore - solves deadlocks when we&n;         * re-enter the quota code and are already holding the semaphore */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
(brace
id|out_sub
suffix:colon
id|inode_sub_bytes
c_func
(paren
id|inode
comma
id|number
)paren
suffix:semicolon
r_return
id|QUOTA_OK
suffix:semicolon
)brace
id|down_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
multiline_comment|/* Now recheck reliably when holding dqptr_sem */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_goto
id|out_sub
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_decr_space
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
)brace
id|inode_sub_bytes
c_func
(paren
id|inode
comma
id|number
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
multiline_comment|/* Dirtify all the dquots - this can block when journalling */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
id|mark_dquot_dirty
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|QUOTA_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a non-blocking operation.&n; */
DECL|function|dquot_free_inode
r_int
id|dquot_free_inode
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
)paren
(brace
r_int
r_int
id|cnt
suffix:semicolon
multiline_comment|/* First test before acquiring semaphore - solves deadlocks when we&n;         * re-enter the quota code and are already holding the semaphore */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_return
id|QUOTA_OK
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
multiline_comment|/* Now recheck reliably when holding dqptr_sem */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|QUOTA_OK
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_decr_inodes
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
multiline_comment|/* Dirtify all the dquots - this can block when journalling */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
id|mark_dquot_dirty
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|QUOTA_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * Transfer the number of inode and blocks from one diskquota to an other.&n; *&n; * This operation can block, but only after everything is updated&n; */
DECL|function|dquot_transfer
r_int
id|dquot_transfer
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|iattr
)paren
(brace
id|qsize_t
id|space
suffix:semicolon
r_struct
id|dquot
op_star
id|transfer_from
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_struct
id|dquot
op_star
id|transfer_to
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_int
id|cnt
comma
id|ret
op_assign
id|NO_QUOTA
comma
id|chuid
op_assign
(paren
id|iattr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
op_logical_and
id|inode-&gt;i_uid
op_ne
id|iattr-&gt;ia_uid
comma
id|chgid
op_assign
(paren
id|iattr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
op_logical_and
id|inode-&gt;i_gid
op_ne
id|iattr-&gt;ia_gid
suffix:semicolon
r_char
id|warntype
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
multiline_comment|/* First test before acquiring semaphore - solves deadlocks when we&n;         * re-enter the quota code and are already holding the semaphore */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_return
id|QUOTA_OK
suffix:semicolon
multiline_comment|/* Clear the arrays */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|warntype
(braket
id|cnt
)braket
op_assign
id|NOWARN
suffix:semicolon
)brace
id|down_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
multiline_comment|/* Now recheck reliably when holding dqptr_sem */
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* File without quota accounting? */
id|up_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|QUOTA_OK
suffix:semicolon
)brace
multiline_comment|/* First build the transfer_to list - here we can block on&n;&t; * reading/instantiating of dquots.  We know that the transaction for&n;&t; * us was already started so we don&squot;t violate lock ranking here */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|cnt
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|chuid
)paren
r_continue
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|iattr-&gt;ia_uid
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|chgid
)paren
r_continue
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|iattr-&gt;ia_gid
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|space
op_assign
id|inode_get_bytes
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* Build the transfer_from list and check the limits */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|transfer_to
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_idq
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
l_int|1
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
op_logical_or
id|check_bdq
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
id|space
comma
l_int|0
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
)paren
r_goto
id|warn_put_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally perform the needed transfer from transfer_from to transfer_to&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip changes for same uid or gid or for turned off quota-type.&n;&t;&t; */
r_if
c_cond
(paren
id|transfer_to
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_decr_inodes
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
comma
l_int|1
)paren
suffix:semicolon
id|dquot_decr_space
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
comma
id|space
)paren
suffix:semicolon
id|dquot_incr_inodes
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
l_int|1
)paren
suffix:semicolon
id|dquot_incr_space
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
id|space
)paren
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|transfer_to
(braket
id|cnt
)braket
suffix:semicolon
)brace
id|ret
op_assign
id|QUOTA_OK
suffix:semicolon
id|warn_put_all
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
multiline_comment|/* Dirtify all the dquots - this can block when journalling */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
id|mark_dquot_dirty
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
id|mark_dquot_dirty
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|flush_warnings
c_func
(paren
id|transfer_to
comma
id|warntype
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
id|QUOTA_OK
op_logical_and
id|transfer_from
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
id|dqput
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
id|NO_QUOTA
op_logical_and
id|transfer_to
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
id|dqput
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|dqptr_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write info of quota file to disk&n; */
DECL|function|dquot_commit_info
r_int
id|dquot_commit_info
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|ret
op_assign
id|dqopt-&gt;ops
(braket
id|type
)braket
op_member_access_from_pointer
id|write_file_info
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Definitions of diskquota operations.&n; */
DECL|variable|dquot_operations
r_struct
id|dquot_operations
id|dquot_operations
op_assign
(brace
dot
id|initialize
op_assign
id|dquot_initialize
comma
dot
id|drop
op_assign
id|dquot_drop
comma
dot
id|alloc_space
op_assign
id|dquot_alloc_space
comma
dot
id|alloc_inode
op_assign
id|dquot_alloc_inode
comma
dot
id|free_space
op_assign
id|dquot_free_space
comma
dot
id|free_inode
op_assign
id|dquot_free_inode
comma
dot
id|transfer
op_assign
id|dquot_transfer
comma
dot
id|write_dquot
op_assign
id|dquot_commit
comma
dot
id|acquire_dquot
op_assign
id|dquot_acquire
comma
dot
id|release_dquot
op_assign
id|dquot_release
comma
dot
id|mark_dirty
op_assign
id|dquot_mark_dquot_dirty
comma
dot
id|write_info
op_assign
id|dquot_commit_info
)brace
suffix:semicolon
DECL|function|set_enable_flags
r_static
r_inline
r_void
id|set_enable_flags
c_func
(paren
r_struct
id|quota_info
op_star
id|dqopt
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|dqopt-&gt;flags
op_or_assign
id|DQUOT_USR_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|dqopt-&gt;flags
op_or_assign
id|DQUOT_GRP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|reset_enable_flags
r_static
r_inline
r_void
id|reset_enable_flags
c_func
(paren
r_struct
id|quota_info
op_star
id|dqopt
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|dqopt-&gt;flags
op_and_assign
op_complement
id|DQUOT_USR_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|dqopt-&gt;flags
op_and_assign
op_complement
id|DQUOT_GRP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Turn quota off on a device. type == -1 ==&gt; quotaoff for all types (umount)&n; */
DECL|function|vfs_quota_off
r_int
id|vfs_quota_off
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* We need to serialize quota_off() for device */
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqonoff_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|cnt
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
id|reset_enable_flags
c_func
(paren
id|dqopt
comma
id|cnt
)paren
suffix:semicolon
multiline_comment|/* Note: these are blocking operations */
id|drop_dquot_ref
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
id|invalidate_dquots
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now all dquots should be invalidated, all writes done so we should be only&n;&t;&t; * users of the info. No locks needed.&n;&t;&t; */
r_if
c_cond
(paren
id|info_dirty
c_func
(paren
op_amp
id|dqopt-&gt;info
(braket
id|cnt
)braket
)paren
)paren
id|sb-&gt;dq_op
op_member_access_from_pointer
id|write_info
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_member_access_from_pointer
id|free_file_info
)paren
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_member_access_from_pointer
id|free_file_info
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
id|put_quota_format
c_func
(paren
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_format
)paren
suffix:semicolon
id|fput
c_func
(paren
id|dqopt-&gt;files
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqopt-&gt;files
(braket
id|cnt
)braket
op_assign
l_int|NULL
suffix:semicolon
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_flags
op_assign
l_int|0
suffix:semicolon
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_igrace
op_assign
l_int|0
suffix:semicolon
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_bgrace
op_assign
l_int|0
suffix:semicolon
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqonoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Turn quotas on on a device&n; */
multiline_comment|/* Helper function when we already have file open */
DECL|function|vfs_quota_on_file
r_static
r_int
id|vfs_quota_on_file
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_int
id|type
comma
r_int
id|format_id
)paren
(brace
r_struct
id|quota_format_type
op_star
id|fmt
op_assign
id|find_quota_format
c_func
(paren
id|format_id
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|f-&gt;f_dentry-&gt;d_sb
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|dquot
op_star
id|to_drop
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_int
id|error
comma
id|cnt
suffix:semicolon
r_int
r_int
id|oldflags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
r_return
op_minus
id|ESRCH
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;f_op
op_logical_or
op_logical_neg
id|f-&gt;f_op-&gt;read
op_logical_or
op_logical_neg
id|f-&gt;f_op-&gt;write
)paren
r_goto
id|out_fmt
suffix:semicolon
id|inode
op_assign
id|f-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_goto
id|out_fmt
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqonoff_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|type
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out_lock
suffix:semicolon
)brace
id|oldflags
op_assign
id|inode-&gt;i_flags
suffix:semicolon
id|dqopt-&gt;files
(braket
id|type
)braket
op_assign
id|f
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt-&gt;qf_ops
op_member_access_from_pointer
id|check_quota_file
c_func
(paren
id|sb
comma
id|type
)paren
)paren
r_goto
id|out_file_init
suffix:semicolon
multiline_comment|/* We don&squot;t want quota and atime on quota files (deadlocks possible) */
id|down_write
c_func
(paren
op_amp
id|dqopt-&gt;dqptr_sem
)paren
suffix:semicolon
id|inode-&gt;i_flags
op_or_assign
id|S_NOQUOTA
op_or
id|S_NOATIME
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|to_drop
(braket
id|cnt
)braket
op_assign
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
)brace
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_QUOTA
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|dqopt-&gt;dqptr_sem
)paren
suffix:semicolon
multiline_comment|/* We must put dquots outside of dqptr_sem because we may need to&n;&t; * start transaction for dquot_release() */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|to_drop
(braket
id|cnt
)braket
)paren
id|dqput
c_func
(paren
id|to_drop
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
id|dqopt-&gt;ops
(braket
id|type
)braket
op_assign
id|fmt-&gt;qf_ops
suffix:semicolon
id|dqopt-&gt;info
(braket
id|type
)braket
dot
id|dqi_format
op_assign
id|fmt
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dqopt-&gt;info
(braket
id|type
)braket
dot
id|dqi_dirty_list
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|dqopt-&gt;ops
(braket
id|type
)braket
op_member_access_from_pointer
id|read_file_info
c_func
(paren
id|sb
comma
id|type
)paren
)paren
OL
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
r_goto
id|out_file_init
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|set_enable_flags
c_func
(paren
id|dqopt
comma
id|type
)paren
suffix:semicolon
id|add_dquot_ref
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqonoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_file_init
suffix:colon
id|inode-&gt;i_flags
op_assign
id|oldflags
suffix:semicolon
id|dqopt-&gt;files
(braket
id|type
)braket
op_assign
l_int|NULL
suffix:semicolon
id|out_lock
suffix:colon
id|up_write
c_func
(paren
op_amp
id|dqopt-&gt;dqptr_sem
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqonoff_sem
)paren
suffix:semicolon
id|out_fmt
suffix:colon
id|put_quota_format
c_func
(paren
id|fmt
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Actual function called from quotactl() */
DECL|function|vfs_quota_on
r_int
id|vfs_quota_on
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_int
id|format_id
comma
r_char
op_star
id|path
)paren
(brace
r_struct
id|file
op_star
id|f
suffix:semicolon
r_int
id|error
suffix:semicolon
id|f
op_assign
id|filp_open
c_func
(paren
id|path
comma
id|O_RDWR
comma
l_int|0600
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|f
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|f
)paren
suffix:semicolon
id|error
op_assign
id|security_quota_on
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_f
suffix:semicolon
id|error
op_assign
id|vfs_quota_on_file
c_func
(paren
id|f
comma
id|type
comma
id|format_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_return
l_int|0
suffix:semicolon
id|out_f
suffix:colon
id|filp_close
c_func
(paren
id|f
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Function used by filesystems when filp_open() would fail (filesystem is&n; * being mounted now). We will use a private file structure. Caller is&n; * responsible that it&squot;s IO functions won&squot;t need vfsmnt structure or&n; * some dentry tricks...&n; */
DECL|function|vfs_quota_on_mount
r_int
id|vfs_quota_on_mount
c_func
(paren
r_int
id|type
comma
r_int
id|format_id
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|file
op_star
id|f
suffix:semicolon
r_int
id|error
suffix:semicolon
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Get a reference for struct file */
id|f
op_assign
id|dentry_open
c_func
(paren
id|dentry
comma
l_int|NULL
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|f
)paren
)paren
(brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|f
)paren
suffix:semicolon
r_goto
id|out_dentry
suffix:semicolon
)brace
id|error
op_assign
id|vfs_quota_on_file
c_func
(paren
id|f
comma
id|type
comma
id|format_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_return
l_int|0
suffix:semicolon
id|fput
c_func
(paren
id|f
)paren
suffix:semicolon
id|out_dentry
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Generic routine for getting common part of quota structure */
DECL|function|do_get_dqblk
r_static
r_void
id|do_get_dqblk
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|mem_dqblk
op_star
id|dm
op_assign
op_amp
id|dquot-&gt;dq_dqb
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|di-&gt;dqb_bhardlimit
op_assign
id|dm-&gt;dqb_bhardlimit
suffix:semicolon
id|di-&gt;dqb_bsoftlimit
op_assign
id|dm-&gt;dqb_bsoftlimit
suffix:semicolon
id|di-&gt;dqb_curspace
op_assign
id|dm-&gt;dqb_curspace
suffix:semicolon
id|di-&gt;dqb_ihardlimit
op_assign
id|dm-&gt;dqb_ihardlimit
suffix:semicolon
id|di-&gt;dqb_isoftlimit
op_assign
id|dm-&gt;dqb_isoftlimit
suffix:semicolon
id|di-&gt;dqb_curinodes
op_assign
id|dm-&gt;dqb_curinodes
suffix:semicolon
id|di-&gt;dqb_btime
op_assign
id|dm-&gt;dqb_btime
suffix:semicolon
id|di-&gt;dqb_itime
op_assign
id|dm-&gt;dqb_itime
suffix:semicolon
id|di-&gt;dqb_valid
op_assign
id|QIF_ALL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
)brace
DECL|function|vfs_get_dqblk
r_int
id|vfs_get_dqblk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|qid_t
id|id
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dquot
op_assign
id|dqget
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
id|do_get_dqblk
c_func
(paren
id|dquot
comma
id|di
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generic routine for setting common part of quota structure */
DECL|function|do_set_dqblk
r_static
r_void
id|do_set_dqblk
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|mem_dqblk
op_star
id|dm
op_assign
op_amp
id|dquot-&gt;dq_dqb
suffix:semicolon
r_int
id|check_blim
op_assign
l_int|0
comma
id|check_ilim
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_SPACE
)paren
(brace
id|dm-&gt;dqb_curspace
op_assign
id|di-&gt;dqb_curspace
suffix:semicolon
id|check_blim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_BLIMITS
)paren
(brace
id|dm-&gt;dqb_bsoftlimit
op_assign
id|di-&gt;dqb_bsoftlimit
suffix:semicolon
id|dm-&gt;dqb_bhardlimit
op_assign
id|di-&gt;dqb_bhardlimit
suffix:semicolon
id|check_blim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_INODES
)paren
(brace
id|dm-&gt;dqb_curinodes
op_assign
id|di-&gt;dqb_curinodes
suffix:semicolon
id|check_ilim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_ILIMITS
)paren
(brace
id|dm-&gt;dqb_isoftlimit
op_assign
id|di-&gt;dqb_isoftlimit
suffix:semicolon
id|dm-&gt;dqb_ihardlimit
op_assign
id|di-&gt;dqb_ihardlimit
suffix:semicolon
id|check_ilim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_BTIME
)paren
id|dm-&gt;dqb_btime
op_assign
id|di-&gt;dqb_btime
suffix:semicolon
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_ITIME
)paren
id|dm-&gt;dqb_itime
op_assign
id|di-&gt;dqb_itime
suffix:semicolon
r_if
c_cond
(paren
id|check_blim
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dm-&gt;dqb_bsoftlimit
op_logical_or
id|toqb
c_func
(paren
id|dm-&gt;dqb_curspace
)paren
OL
id|dm-&gt;dqb_bsoftlimit
)paren
(brace
id|dm-&gt;dqb_btime
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|DQ_BLKS_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_BTIME
)paren
)paren
multiline_comment|/* Set grace only if user hasn&squot;t provided his own... */
id|dm-&gt;dqb_btime
op_assign
id|get_seconds
c_func
(paren
)paren
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_bgrace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_ilim
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dm-&gt;dqb_isoftlimit
op_logical_or
id|dm-&gt;dqb_curinodes
OL
id|dm-&gt;dqb_isoftlimit
)paren
(brace
id|dm-&gt;dqb_itime
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|DQ_INODES_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_ITIME
)paren
)paren
multiline_comment|/* Set grace only if user hasn&squot;t provided his own... */
id|dm-&gt;dqb_itime
op_assign
id|get_seconds
c_func
(paren
)paren
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_igrace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dm-&gt;dqb_bhardlimit
op_logical_or
id|dm-&gt;dqb_bsoftlimit
op_logical_or
id|dm-&gt;dqb_ihardlimit
op_logical_or
id|dm-&gt;dqb_isoftlimit
)paren
id|clear_bit
c_func
(paren
id|DQ_FAKE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|DQ_FAKE_B
comma
op_amp
id|dquot-&gt;dq_flags
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|mark_dquot_dirty
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|vfs_set_dqblk
r_int
id|vfs_set_dqblk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|qid_t
id|id
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dquot
op_assign
id|dqget
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
id|do_set_dqblk
c_func
(paren
id|dquot
comma
id|di
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generic routine for getting common part of quota file information */
DECL|function|vfs_get_dqinfo
r_int
id|vfs_get_dqinfo
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_struct
id|if_dqinfo
op_star
id|ii
)paren
(brace
r_struct
id|mem_dqinfo
op_star
id|mi
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|type
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
id|mi
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
op_plus
id|type
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|ii-&gt;dqi_bgrace
op_assign
id|mi-&gt;dqi_bgrace
suffix:semicolon
id|ii-&gt;dqi_igrace
op_assign
id|mi-&gt;dqi_igrace
suffix:semicolon
id|ii-&gt;dqi_flags
op_assign
id|mi-&gt;dqi_flags
op_amp
id|DQF_MASK
suffix:semicolon
id|ii-&gt;dqi_valid
op_assign
id|IIF_ALL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generic routine for setting common part of quota file information */
DECL|function|vfs_set_dqinfo
r_int
id|vfs_set_dqinfo
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_struct
id|if_dqinfo
op_star
id|ii
)paren
(brace
r_struct
id|mem_dqinfo
op_star
id|mi
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|type
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
op_minus
id|ESRCH
suffix:semicolon
)brace
id|mi
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
op_plus
id|type
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ii-&gt;dqi_valid
op_amp
id|IIF_BGRACE
)paren
id|mi-&gt;dqi_bgrace
op_assign
id|ii-&gt;dqi_bgrace
suffix:semicolon
r_if
c_cond
(paren
id|ii-&gt;dqi_valid
op_amp
id|IIF_IGRACE
)paren
id|mi-&gt;dqi_igrace
op_assign
id|ii-&gt;dqi_igrace
suffix:semicolon
r_if
c_cond
(paren
id|ii-&gt;dqi_valid
op_amp
id|IIF_FLAGS
)paren
id|mi-&gt;dqi_flags
op_assign
(paren
id|mi-&gt;dqi_flags
op_amp
op_complement
id|DQF_MASK
)paren
op_or
(paren
id|ii-&gt;dqi_flags
op_amp
id|DQF_MASK
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dq_data_lock
)paren
suffix:semicolon
id|mark_info_dirty
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* Force write to disk */
id|sb-&gt;dq_op
op_member_access_from_pointer
id|write_info
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|dqonoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vfs_quotactl_ops
r_struct
id|quotactl_ops
id|vfs_quotactl_ops
op_assign
(brace
dot
id|quota_on
op_assign
id|vfs_quota_on
comma
dot
id|quota_off
op_assign
id|vfs_quota_off
comma
dot
id|quota_sync
op_assign
id|vfs_quota_sync
comma
dot
id|get_info
op_assign
id|vfs_get_dqinfo
comma
dot
id|set_info
op_assign
id|vfs_set_dqinfo
comma
dot
id|get_dqblk
op_assign
id|vfs_get_dqblk
comma
dot
id|set_dqblk
op_assign
id|vfs_set_dqblk
)brace
suffix:semicolon
DECL|variable|fs_dqstats_table
r_static
id|ctl_table
id|fs_dqstats_table
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_LOOKUPS
comma
dot
id|procname
op_assign
l_string|&quot;lookups&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.lookups
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_DROPS
comma
dot
id|procname
op_assign
l_string|&quot;drops&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.drops
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_READS
comma
dot
id|procname
op_assign
l_string|&quot;reads&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.reads
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_WRITES
comma
dot
id|procname
op_assign
l_string|&quot;writes&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.writes
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_CACHE_HITS
comma
dot
id|procname
op_assign
l_string|&quot;cache_hits&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.cache_hits
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_ALLOCATED
comma
dot
id|procname
op_assign
l_string|&quot;allocated_dquots&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.allocated_dquots
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_FREE
comma
dot
id|procname
op_assign
l_string|&quot;free_dquots&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.free_dquots
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
id|FS_DQ_SYNCS
comma
dot
id|procname
op_assign
l_string|&quot;syncs&quot;
comma
dot
id|data
op_assign
op_amp
id|dqstats.syncs
comma
dot
id|maxlen
op_assign
r_sizeof
(paren
r_int
)paren
comma
dot
id|mode
op_assign
l_int|0444
comma
dot
id|proc_handler
op_assign
op_amp
id|proc_dointvec
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|variable|fs_table
r_static
id|ctl_table
id|fs_table
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|FS_DQSTATS
comma
dot
id|procname
op_assign
l_string|&quot;quota&quot;
comma
dot
id|mode
op_assign
l_int|0555
comma
dot
id|child
op_assign
id|fs_dqstats_table
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|variable|sys_table
r_static
id|ctl_table
id|sys_table
(braket
)braket
op_assign
(brace
(brace
dot
id|ctl_name
op_assign
id|CTL_FS
comma
dot
id|procname
op_assign
l_string|&quot;fs&quot;
comma
dot
id|mode
op_assign
l_int|0555
comma
dot
id|child
op_assign
id|fs_table
comma
)brace
comma
(brace
dot
id|ctl_name
op_assign
l_int|0
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* SLAB cache for dquot structures */
DECL|variable|dquot_cachep
id|kmem_cache_t
op_star
id|dquot_cachep
suffix:semicolon
DECL|function|dquot_init
r_static
r_int
id|__init
id|dquot_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|nr_hash
comma
id|order
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;VFS: Disk quotas %s&bslash;n&quot;
comma
id|__DQUOT_VERSION__
)paren
suffix:semicolon
id|register_sysctl_table
c_func
(paren
id|sys_table
comma
l_int|0
)paren
suffix:semicolon
id|dquot_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dquot&quot;
comma
r_sizeof
(paren
r_struct
id|dquot
)paren
comma
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|4
comma
id|SLAB_HWCACHE_ALIGN
op_or
id|SLAB_RECLAIM_ACCOUNT
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create dquot SLAB cache&quot;
)paren
suffix:semicolon
id|order
op_assign
l_int|0
suffix:semicolon
id|dquot_hash
op_assign
(paren
r_struct
id|hlist_head
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot_hash
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create dquot hash table&quot;
)paren
suffix:semicolon
multiline_comment|/* Find power-of-two hlist_heads which can fit into allocation */
id|nr_hash
op_assign
(paren
l_int|1UL
op_lshift
id|order
)paren
op_star
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|hlist_head
)paren
suffix:semicolon
id|dq_hash_bits
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|dq_hash_bits
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr_hash
op_rshift
id|dq_hash_bits
)paren
suffix:semicolon
id|dq_hash_bits
op_decrement
suffix:semicolon
id|nr_hash
op_assign
l_int|1UL
op_lshift
id|dq_hash_bits
suffix:semicolon
id|dq_hash_mask
op_assign
id|nr_hash
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_hash
suffix:semicolon
id|i
op_increment
)paren
id|INIT_HLIST_HEAD
c_func
(paren
id|dquot_hash
op_plus
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dquot-cache hash table entries: %ld (order %ld, %ld bytes)&bslash;n&quot;
comma
id|nr_hash
comma
id|order
comma
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
)paren
suffix:semicolon
id|set_shrinker
c_func
(paren
id|DEFAULT_SEEKS
comma
id|shrink_dqcache_memory
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dquot_init
id|module_init
c_func
(paren
id|dquot_init
)paren
suffix:semicolon
DECL|variable|register_quota_format
id|EXPORT_SYMBOL
c_func
(paren
id|register_quota_format
)paren
suffix:semicolon
DECL|variable|unregister_quota_format
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_quota_format
)paren
suffix:semicolon
DECL|variable|dqstats
id|EXPORT_SYMBOL
c_func
(paren
id|dqstats
)paren
suffix:semicolon
DECL|variable|dq_list_lock
id|EXPORT_SYMBOL
c_func
(paren
id|dq_list_lock
)paren
suffix:semicolon
DECL|variable|dq_data_lock
id|EXPORT_SYMBOL
c_func
(paren
id|dq_data_lock
)paren
suffix:semicolon
DECL|variable|vfs_quota_on
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_quota_on
)paren
suffix:semicolon
DECL|variable|vfs_quota_on_mount
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_quota_on_mount
)paren
suffix:semicolon
DECL|variable|vfs_quota_off
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_quota_off
)paren
suffix:semicolon
DECL|variable|vfs_quota_sync
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_quota_sync
)paren
suffix:semicolon
DECL|variable|vfs_get_dqinfo
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_get_dqinfo
)paren
suffix:semicolon
DECL|variable|vfs_set_dqinfo
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_set_dqinfo
)paren
suffix:semicolon
DECL|variable|vfs_get_dqblk
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_get_dqblk
)paren
suffix:semicolon
DECL|variable|vfs_set_dqblk
id|EXPORT_SYMBOL
c_func
(paren
id|vfs_set_dqblk
)paren
suffix:semicolon
DECL|variable|dquot_commit
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_commit
)paren
suffix:semicolon
DECL|variable|dquot_commit_info
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_commit_info
)paren
suffix:semicolon
DECL|variable|dquot_acquire
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_acquire
)paren
suffix:semicolon
DECL|variable|dquot_release
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_release
)paren
suffix:semicolon
DECL|variable|dquot_mark_dquot_dirty
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_mark_dquot_dirty
)paren
suffix:semicolon
DECL|variable|dquot_initialize
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_initialize
)paren
suffix:semicolon
DECL|variable|dquot_drop
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_drop
)paren
suffix:semicolon
DECL|variable|dquot_alloc_space
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_alloc_space
)paren
suffix:semicolon
DECL|variable|dquot_alloc_inode
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_alloc_inode
)paren
suffix:semicolon
DECL|variable|dquot_free_space
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_free_space
)paren
suffix:semicolon
DECL|variable|dquot_free_inode
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_free_inode
)paren
suffix:semicolon
DECL|variable|dquot_transfer
id|EXPORT_SYMBOL
c_func
(paren
id|dquot_transfer
)paren
suffix:semicolon
eof
