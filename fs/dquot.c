multiline_comment|/*&n; * Implementation of the diskquota system for the LINUX operating&n; * system. QUOTA is implemented using the BSD system call interface as&n; * the means of communication with the user level. Currently only the&n; * ext2 filesystem has support for disk quotas. Other filesystems may&n; * be added in the future. This file contains the generic routines&n; * called by the different filesystems on allocation of an inode or&n; * block. These routines take care of the administration needed to&n; * have a consistent diskquota tracking system. The ideas of both&n; * user and group quotas are based on the Melbourne quota system as&n; * used on BSD derived systems. The internal implementation is &n; * based on one of the several variants of the LINUX inode-subsystem&n; * with added complexity of the diskquota system.&n; * &n; * Version: $Id: dquot.c,v 6.3 1996/11/17 18:35:34 mvw Exp mvw $&n; * &n; * Author:&t;Marco van Wieringen &lt;mvw@planets.elm.net&gt;&n; *&n; * Fixes:   Dmitry Gorodchanin &lt;pgmdsg@ibi.com&gt;, 11 Feb 96&n; *&n; *&t;&t;Revised list management to avoid races&n; *&t;&t;-- Bill Hawes, &lt;whawes@star.net&gt;, 9/98&n; *&n; *&t;&t;Fixed races in dquot_transfer(), dqget() and dquot_alloc_...().&n; *&t;&t;As the consequence the locking was moved from dquot_decr_...(),&n; *&t;&t;dquot_incr_...() to calling functions.&n; *&t;&t;invalidate_dquots() now writes modified dquots.&n; *&t;&t;Serialized quota_off() and quota_on() for mount point.&n; *&t;&t;Fixed a few bugs in grow_dquots().&n; *&t;&t;Fixed deadlock in write_dquot() - we no longer account quotas on&n; *&t;&t;quota files&n; *&t;&t;remove_dquot_ref() moved to inode.c - it now traverses through inodes&n; *&t;&t;add_dquot_ref() restarts after blocking&n; *&t;&t;Added check for bogus uid and fixed check for group in quotactl.&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, sponsored by SuSE CR, 10-11/99&n; *&n; *&t;&t;Used struct list_head instead of own list struct&n; *&t;&t;Invalidation of referenced dquots is no longer possible&n; *&t;&t;Improved free_dquots list management&n; *&t;&t;Quota and i_blocks are now updated in one place to avoid races&n; *&t;&t;Warnings are now delayed so we won&squot;t block in critical section&n; *&t;&t;Write updated not to require dquot lock&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, 9/2000&n; *&n; *&t;&t;Added dynamic quota structure allocation&n; *&t;&t;Jan Kara &lt;jack@suse.cz&gt; 12/2000&n; *&n; * (C) Copyright 1994 - 1997 Marco van Wieringen &n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|quotatypes
r_static
r_char
op_star
id|quotatypes
(braket
)braket
op_assign
id|INITQFNAMES
suffix:semicolon
DECL|variable|quota_formats
r_static
r_struct
id|quota_format_type
op_star
id|quota_formats
suffix:semicolon
multiline_comment|/* List of registered formats */
DECL|function|register_quota_format
r_int
id|register_quota_format
c_func
(paren
r_struct
id|quota_format_type
op_star
id|fmt
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|fmt-&gt;qf_next
op_assign
id|quota_formats
suffix:semicolon
id|quota_formats
op_assign
id|fmt
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|unregister_quota_format
r_void
id|unregister_quota_format
c_func
(paren
r_struct
id|quota_format_type
op_star
id|fmt
)paren
(brace
r_struct
id|quota_format_type
op_star
op_star
id|actqf
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|actqf
op_assign
op_amp
id|quota_formats
suffix:semicolon
op_star
id|actqf
op_logical_and
op_star
id|actqf
op_ne
id|fmt
suffix:semicolon
id|actqf
op_assign
op_amp
(paren
op_star
id|actqf
)paren
op_member_access_from_pointer
id|qf_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|actqf
)paren
op_star
id|actqf
op_assign
(paren
op_star
id|actqf
)paren
op_member_access_from_pointer
id|qf_next
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|find_quota_format
r_static
r_struct
id|quota_format_type
op_star
id|find_quota_format
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|quota_format_type
op_star
id|actqf
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|actqf
op_assign
id|quota_formats
suffix:semicolon
id|actqf
op_logical_and
id|actqf-&gt;qf_fmt_id
op_ne
id|id
suffix:semicolon
id|actqf
op_assign
id|actqf-&gt;qf_next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actqf
op_logical_and
op_logical_neg
id|try_inc_mod_count
c_func
(paren
id|actqf-&gt;qf_owner
)paren
)paren
id|actqf
op_assign
l_int|NULL
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|actqf
suffix:semicolon
)brace
DECL|function|put_quota_format
r_static
r_void
id|put_quota_format
c_func
(paren
r_struct
id|quota_format_type
op_star
id|fmt
)paren
(brace
r_if
c_cond
(paren
id|fmt-&gt;qf_owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|fmt-&gt;qf_owner
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dquot List Management:&n; * The quota code uses three lists for dquot management: the inuse_list,&n; * free_dquots, and dquot_hash[] array. A single dquot structure may be&n; * on all three lists, depending on its current state.&n; *&n; * All dquots are placed to the end of inuse_list when first created, and this&n; * list is used for the sync and invalidate operations, which must look&n; * at every dquot.&n; *&n; * Unused dquots (dq_count == 0) are added to the free_dquots list when freed,&n; * and this list is searched whenever we need an available dquot.  Dquots are&n; * removed from the list as soon as they are used again, and&n; * dqstats_array[DQSTATS_FREE] gives the number of dquots on the list. When&n; * dquot is invalidated it&squot;s completely released from memory.&n; *&n; * Dquots with a specific identity (device, type and id) are placed on&n; * one of the dquot_hash[] hash chains. The provides an efficient search&n; * mechanism to locate a specific dquot.&n; */
multiline_comment|/*&n; * Note that any operation which operates on dquot data (ie. dq_dqb) mustn&squot;t&n; * block while it&squot;s updating/reading it. Otherwise races would occur.&n; *&n; * Locked dquots might not be referenced in inodes - operations like&n; * add_dquot_space() does dqduplicate() and would complain. Currently&n; * dquot it locked only once in its existence - when it&squot;s being read&n; * to memory on first dqget() and at that time it can&squot;t be referenced&n; * from inode. Write operations on dquots don&squot;t hold dquot lock as they&n; * copy data to internal buffers before writing anyway and copying as well&n; * as any data update should be atomic. Also nobody can change used&n; * entries in dquot structure as this is done only when quota is destroyed&n; * and invalidate_dquots() waits for dquot to have dq_count == 0.&n; */
r_static
id|LIST_HEAD
c_func
(paren
id|inuse_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|free_dquots
)paren
suffix:semicolon
DECL|variable|dquot_hash
r_static
r_struct
id|list_head
id|dquot_hash
(braket
id|NR_DQHASH
)braket
suffix:semicolon
DECL|variable|dqstats_array
id|__u32
id|dqstats_array
(braket
id|DQSTATS_SIZE
)braket
suffix:semicolon
r_static
r_void
id|dqput
c_func
(paren
r_struct
id|dquot
op_star
)paren
suffix:semicolon
r_static
r_struct
id|dquot
op_star
id|dqduplicate
c_func
(paren
r_struct
id|dquot
op_star
)paren
suffix:semicolon
DECL|function|get_dquot_ref
r_static
r_inline
r_void
id|get_dquot_ref
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|dquot-&gt;dq_count
op_increment
suffix:semicolon
)brace
DECL|function|put_dquot_ref
r_static
r_inline
r_void
id|put_dquot_ref
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|dquot-&gt;dq_count
op_decrement
suffix:semicolon
)brace
DECL|function|get_dquot_dup_ref
r_static
r_inline
r_void
id|get_dquot_dup_ref
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|dquot-&gt;dq_dup_ref
op_increment
suffix:semicolon
)brace
DECL|function|put_dquot_dup_ref
r_static
r_inline
r_void
id|put_dquot_dup_ref
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|dquot-&gt;dq_dup_ref
op_decrement
suffix:semicolon
)brace
DECL|function|hashfn
r_static
r_inline
r_int
r_const
id|hashfn
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_return
(paren
(paren
id|HASHDEV
c_func
(paren
id|sb-&gt;s_dev
)paren
op_xor
id|id
)paren
op_star
(paren
id|MAXQUOTAS
op_minus
id|type
)paren
)paren
op_mod
id|NR_DQHASH
suffix:semicolon
)brace
DECL|function|insert_dquot_hash
r_static
r_inline
r_void
id|insert_dquot_hash
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
id|dquot_hash
op_plus
id|hashfn
c_func
(paren
id|dquot-&gt;dq_sb
comma
id|dquot-&gt;dq_id
comma
id|dquot-&gt;dq_type
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_hash
comma
id|head
)paren
suffix:semicolon
)brace
DECL|function|remove_dquot_hash
r_static
r_inline
r_void
id|remove_dquot_hash
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_hash
)paren
suffix:semicolon
)brace
DECL|function|find_dquot
r_static
r_inline
r_struct
id|dquot
op_star
id|find_dquot
c_func
(paren
r_int
r_int
id|hashent
comma
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_for
c_loop
(paren
id|head
op_assign
id|dquot_hash
(braket
id|hashent
)braket
dot
id|next
suffix:semicolon
id|head
op_ne
id|dquot_hash
op_plus
id|hashent
suffix:semicolon
id|head
op_assign
id|head-&gt;next
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|dquot
comma
id|dq_hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_sb
op_eq
id|sb
op_logical_and
id|dquot-&gt;dq_id
op_eq
id|id
op_logical_and
id|dquot-&gt;dq_type
op_eq
id|type
)paren
r_return
id|dquot
suffix:semicolon
)brace
r_return
id|NODQUOT
suffix:semicolon
)brace
multiline_comment|/* Add a dquot to the head of the free list */
DECL|function|put_dquot_head
r_static
r_inline
r_void
id|put_dquot_head
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
op_amp
id|free_dquots
)paren
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_FREE
)braket
suffix:semicolon
)brace
multiline_comment|/* Add a dquot to the tail of the free list */
DECL|function|put_dquot_last
r_static
r_inline
r_void
id|put_dquot_last
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
id|free_dquots.prev
)paren
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_FREE
)braket
suffix:semicolon
)brace
multiline_comment|/* Move dquot to the head of free list (it must be already on it) */
DECL|function|move_dquot_head
r_static
r_inline
r_void
id|move_dquot_head
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
op_amp
id|free_dquots
)paren
suffix:semicolon
)brace
DECL|function|remove_free_dquot
r_static
r_inline
r_void
id|remove_free_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
)paren
r_return
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
op_decrement
id|dqstats_array
(braket
id|DQSTATS_FREE
)braket
suffix:semicolon
)brace
DECL|function|put_inuse
r_static
r_inline
r_void
id|put_inuse
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
multiline_comment|/* We add to the back of inuse list so we don&squot;t have to restart&n;&t; * when traversing this list and we block */
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_inuse
comma
id|inuse_list.prev
)paren
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_ALLOCATED
)braket
suffix:semicolon
)brace
DECL|function|remove_inuse
r_static
r_inline
r_void
id|remove_inuse
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
op_decrement
id|dqstats_array
(braket
id|DQSTATS_ALLOCATED
)braket
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_inuse
)paren
suffix:semicolon
)brace
DECL|function|__wait_on_dquot
r_static
r_void
id|__wait_on_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_lock
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_lock
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
DECL|function|wait_on_dquot
r_static
r_inline
r_void
id|wait_on_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
id|__wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|lock_dquot
r_static
r_inline
r_void
id|lock_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_LOCKED
suffix:semicolon
)brace
DECL|function|unlock_dquot
r_static
r_inline
r_void
id|unlock_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_LOCKED
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for dquot to be unused */
DECL|function|__wait_dquot_unused
r_static
r_void
id|__wait_dquot_unused
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_free
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_count
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_free
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/* Wait for all duplicated dquot references to be dropped */
DECL|function|__wait_dup_drop
r_static
r_void
id|__wait_dup_drop
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_free
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dup_ref
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_free
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
DECL|function|read_dqblk
r_static
r_int
id|read_dqblk
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
suffix:semicolon
id|lock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|ret
op_assign
id|dqopt-&gt;ops
(braket
id|dquot-&gt;dq_type
)braket
op_member_access_from_pointer
id|read_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|commit_dqblk
r_static
r_int
id|commit_dqblk
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|ret
op_assign
id|dqopt-&gt;ops
(braket
id|dquot-&gt;dq_type
)braket
op_member_access_from_pointer
id|commit_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Invalidate all dquots on the list, wait for all users. Note that this function is called&n; * after quota is disabled so no new quota might be created. As we only insert to the end of&n; * inuse list, we don&squot;t have to restart searching... */
DECL|function|invalidate_dquots
r_static
r_void
id|invalidate_dquots
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_struct
id|list_head
op_star
id|head
suffix:semicolon
id|restart
suffix:colon
id|list_for_each
c_func
(paren
id|head
comma
op_amp
id|inuse_list
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|dquot
comma
id|dq_inuse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_sb
op_ne
id|sb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_type
op_ne
id|type
)paren
r_continue
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_INVAL
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_count
)paren
multiline_comment|/*&n;&t;&t;&t; *  Wait for any users of quota. As we have already cleared the flags in&n;&t;&t;&t; *  superblock and cleared all pointers from inodes we are assured&n;&t;&t;&t; *  that there will be no new users of this quota.&n;&t;&t;&t; */
id|__wait_dquot_unused
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* Quota now have no users and it has been written on last dqput() */
id|remove_dquot_hash
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_inuse
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|dquot_cachep
comma
id|dquot
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
)brace
DECL|function|vfs_quota_sync
r_static
r_int
id|vfs_quota_sync
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|restart
suffix:colon
id|list_for_each
c_func
(paren
id|head
comma
op_amp
id|inuse_list
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|dquot
comma
id|dq_inuse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
op_logical_and
id|dquot-&gt;dq_sb
op_ne
id|sb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|dquot-&gt;dq_type
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
multiline_comment|/* Invalidated? */
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot_dirty
c_func
(paren
id|dquot
)paren
op_logical_and
op_logical_neg
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Get reference to quota so it won&squot;t be invalidated. get_dquot_ref()&n;&t;&t; * is enough since if dquot is locked/modified it can&squot;t be&n;&t;&t; * on the free list */
id|get_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot_dirty
c_func
(paren
id|dquot
)paren
)paren
id|commit_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
(paren
id|cnt
op_eq
id|type
op_logical_or
id|type
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|cnt
)paren
)paren
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_flags
op_and_assign
op_complement
id|DQF_ANY_DQUOT_DIRTY
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
(paren
id|cnt
op_eq
id|type
op_logical_or
id|type
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|cnt
)paren
op_logical_and
id|info_dirty
c_func
(paren
op_amp
id|dqopt-&gt;info
(braket
id|cnt
)braket
)paren
)paren
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_member_access_from_pointer
id|write_file_info
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_SYNCS
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_super_to_sync
r_static
r_struct
id|super_block
op_star
id|get_super_to_sync
c_func
(paren
r_int
id|type
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_int
id|cnt
comma
id|dirty
suffix:semicolon
id|restart
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|sb_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|head
comma
op_amp
id|super_blocks
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|super_block
comma
id|s_list
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
comma
id|dirty
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
(paren
id|type
op_eq
id|cnt
op_logical_or
id|type
op_eq
op_minus
l_int|1
)paren
op_logical_and
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|cnt
)paren
op_logical_and
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
(braket
id|cnt
)braket
dot
id|dqi_flags
op_amp
id|DQF_ANY_DQUOT_DIRTY
)paren
id|dirty
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirty
)paren
r_continue
suffix:semicolon
id|sb-&gt;s_count
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|sb_lock
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|sb-&gt;s_umount
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_root
)paren
(brace
id|drop_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_return
id|sb
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|sb_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|sync_dquots
r_void
id|sync_dquots
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_if
c_cond
(paren
id|sb
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_qcop-&gt;quota_sync
)paren
id|sb-&gt;s_qcop
op_member_access_from_pointer
id|quota_sync
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
id|sb
op_assign
id|get_super_to_sync
c_func
(paren
id|type
)paren
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_qcop-&gt;quota_sync
)paren
id|sb-&gt;s_qcop
op_member_access_from_pointer
id|quota_sync
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|drop_super
c_func
(paren
id|sb
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Free unused dquots from cache */
DECL|function|prune_dqcache
r_static
r_void
id|prune_dqcache
c_func
(paren
r_int
id|count
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|head
op_assign
id|free_dquots.prev
suffix:semicolon
r_while
c_loop
(paren
id|head
op_ne
op_amp
id|free_dquots
op_logical_and
id|count
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|dquot
comma
id|dq_free
)paren
suffix:semicolon
id|remove_dquot_hash
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|remove_inuse
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|dquot_cachep
comma
id|dquot
)paren
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|head
op_assign
id|free_dquots.prev
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called from kswapd when we think we need some&n; * more memory, but aren&squot;t really sure how much. So we&n; * carefully try to free a _bit_ of our dqcache, but not&n; * too much.&n; *&n; * Priority:&n; *   1 - very urgent: shrink everything&n; *   ...&n; *   6 - base-level: try to shrink a bit.&n; */
DECL|function|shrink_dqcache_memory
r_int
id|shrink_dqcache_memory
c_func
(paren
r_int
id|priority
comma
r_int
r_int
id|gfp_mask
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|count
op_assign
id|dqstats_array
(braket
id|DQSTATS_FREE
)braket
op_div
id|priority
suffix:semicolon
id|prune_dqcache
c_func
(paren
id|count
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|kmem_cache_shrink
c_func
(paren
id|dquot_cachep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Put reference to dquot&n; * NOTE: If you change this function please check whether dqput_blocks() works right...&n; */
DECL|function|dqput
r_static
r_void
id|dqput
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
r_return
suffix:semicolon
macro_line|#ifdef __DQUOT_PARANOIA
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: dqput: trying to free free dquot&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VFS: device %s, dquot of %s %d&bslash;n&quot;
comma
id|dquot-&gt;dq_sb-&gt;s_id
comma
id|quotatypes
(braket
id|dquot-&gt;dq_type
)braket
comma
id|dquot-&gt;dq_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
op_increment
id|dqstats_array
(braket
id|DQSTATS_DROPS
)braket
suffix:semicolon
id|we_slept
suffix:colon
r_if
c_cond
(paren
id|dquot-&gt;dq_dup_ref
op_logical_and
id|dquot-&gt;dq_count
op_minus
id|dquot-&gt;dq_dup_ref
op_le
l_int|1
)paren
(brace
multiline_comment|/* Last unduplicated reference? */
id|__wait_dup_drop
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_goto
id|we_slept
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_count
OG
l_int|1
)paren
(brace
multiline_comment|/* We have more than one user... We can simply decrement use count */
id|put_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot_dirty
c_func
(paren
id|dquot
)paren
)paren
(brace
id|commit_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_goto
id|we_slept
suffix:semicolon
)brace
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dqput: dquot already on free list??&bslash;n&quot;
)paren
suffix:semicolon
id|put_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* If dquot is going to be invalidated invalidate_dquots() is going to free it so */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_INVAL
)paren
)paren
id|put_dquot_last
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* Place at end of LRU free queue */
id|wake_up
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_free
)paren
suffix:semicolon
)brace
DECL|function|get_empty_dquot
r_static
r_struct
id|dquot
op_star
id|get_empty_dquot
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|dquot
op_assign
id|kmem_cache_alloc
c_func
(paren
id|dquot_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
(brace
r_return
id|NODQUOT
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|dquot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dquot
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_free
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_inuse
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_hash
)paren
suffix:semicolon
id|dquot-&gt;dq_sb
op_assign
id|sb
suffix:semicolon
id|dquot-&gt;dq_type
op_assign
id|type
suffix:semicolon
id|dquot-&gt;dq_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* all dquots go on the inuse_list */
id|put_inuse
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
id|dquot
suffix:semicolon
)brace
DECL|function|dqget
r_static
r_struct
id|dquot
op_star
id|dqget
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|hashent
op_assign
id|hashfn
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
comma
op_star
id|empty
op_assign
id|NODQUOT
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
id|we_slept
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|is_enabled
c_func
(paren
id|dqopt
comma
id|type
)paren
)paren
(brace
r_if
c_cond
(paren
id|empty
)paren
id|dqput
c_func
(paren
id|empty
)paren
suffix:semicolon
r_return
id|NODQUOT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dquot
op_assign
id|find_dquot
c_func
(paren
id|hashent
comma
id|sb
comma
id|id
comma
id|type
)paren
)paren
op_eq
id|NODQUOT
)paren
(brace
r_if
c_cond
(paren
id|empty
op_eq
id|NODQUOT
)paren
(brace
r_if
c_cond
(paren
(paren
id|empty
op_assign
id|get_empty_dquot
c_func
(paren
id|sb
comma
id|type
)paren
)paren
op_eq
id|NODQUOT
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Try to wait for a moment... */
r_goto
id|we_slept
suffix:semicolon
)brace
id|dquot
op_assign
id|empty
suffix:semicolon
id|dquot-&gt;dq_id
op_assign
id|id
suffix:semicolon
multiline_comment|/* hash it first so it can be found */
id|insert_dquot_hash
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|read_dqblk
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_count
)paren
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|get_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_CACHE_HITS
)braket
suffix:semicolon
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
id|dqput
c_func
(paren
id|empty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
(brace
multiline_comment|/* Has somebody invalidated entry under us? */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: dqget(): Quota invalidated in dqget()!&bslash;n&quot;
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
id|NODQUOT
suffix:semicolon
)brace
op_increment
id|dquot-&gt;dq_referenced
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_LOOKUPS
)braket
suffix:semicolon
r_return
id|dquot
suffix:semicolon
)brace
multiline_comment|/* Duplicate reference to dquot got from inode */
DECL|function|dqduplicate
r_static
r_struct
id|dquot
op_star
id|dqduplicate
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
)paren
r_return
id|NODQUOT
suffix:semicolon
id|get_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: dqduplicate(): Invalidated quota to be duplicated!&bslash;n&quot;
)paren
suffix:semicolon
id|put_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
id|NODQUOT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: dqduplicate(): Locked quota to be duplicated!&bslash;n&quot;
)paren
suffix:semicolon
id|get_dquot_dup_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dquot-&gt;dq_referenced
op_increment
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_LOOKUPS
)braket
suffix:semicolon
r_return
id|dquot
suffix:semicolon
)brace
multiline_comment|/* Put duplicated reference */
DECL|function|dqputduplicate
r_static
r_void
id|dqputduplicate
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_dup_ref
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: dqputduplicate(): Duplicated dquot put without duplicate reference.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_dquot_dup_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_dup_ref
)paren
id|wake_up
c_func
(paren
op_amp
id|dquot-&gt;dq_wait_free
)paren
suffix:semicolon
id|put_dquot_ref
c_func
(paren
id|dquot
)paren
suffix:semicolon
op_increment
id|dqstats_array
(braket
id|DQSTATS_DROPS
)braket
suffix:semicolon
)brace
DECL|function|dqinit_needed
r_static
r_int
id|dqinit_needed
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
r_return
id|inode-&gt;i_dquot
(braket
id|type
)braket
op_eq
id|NODQUOT
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_dquot_ref
r_static
r_void
id|add_dquot_ref
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|restart
suffix:colon
id|file_list_lock
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|sb-&gt;s_files
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|file
comma
id|f_list
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|dqinit_needed
c_func
(paren
id|inode
comma
id|type
)paren
)paren
(brace
r_struct
id|vfsmount
op_star
id|mnt
op_assign
id|mntget
c_func
(paren
id|filp-&gt;f_vfsmnt
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|dget
c_func
(paren
id|filp-&gt;f_dentry
)paren
suffix:semicolon
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|inode
comma
id|type
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|mnt
)paren
suffix:semicolon
multiline_comment|/* As we may have blocked we had better restart... */
r_goto
id|restart
suffix:semicolon
)brace
)brace
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Return 0 if dqput() won&squot;t block (note that 1 doesn&squot;t necessarily mean blocking) */
DECL|function|dqput_blocks
r_static
r_inline
r_int
id|dqput_blocks
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dup_ref
op_logical_and
id|dquot-&gt;dq_count
op_minus
id|dquot-&gt;dq_dup_ref
op_le
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_count
op_le
l_int|1
op_logical_and
id|dquot-&gt;dq_flags
op_amp
id|DQ_MOD
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remove references to dquots from inode - add dquot to list for freeing if needed */
DECL|function|remove_inode_dquot_ref
r_int
id|remove_inode_dquot_ref
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
comma
r_struct
id|list_head
op_star
id|tofree_head
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
op_assign
id|inode-&gt;i_dquot
(braket
id|type
)braket
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|type
)braket
op_assign
id|NODQUOT
suffix:semicolon
multiline_comment|/* any other quota in use? */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
r_goto
id|put_it
suffix:semicolon
)brace
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_QUOTA
suffix:semicolon
id|put_it
suffix:colon
r_if
c_cond
(paren
id|dquot
op_ne
id|NODQUOT
)paren
(brace
r_if
c_cond
(paren
id|dqput_blocks
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_count
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFS: Adding dquot with dq_count %d to dispose list.&bslash;n&quot;
comma
id|dquot-&gt;dq_count
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
id|tofree_head
)paren
suffix:semicolon
multiline_comment|/* As dquot must have currently users it can&squot;t be on the free list... */
r_return
l_int|1
suffix:semicolon
)brace
r_else
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* We have guaranteed we won&squot;t block */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free list of dquots - called from inode.c */
DECL|function|put_dquot_list
r_void
id|put_dquot_list
c_func
(paren
r_struct
id|list_head
op_star
id|tofree_head
)paren
(brace
r_struct
id|list_head
op_star
id|act_head
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|act_head
op_assign
id|tofree_head-&gt;next
suffix:semicolon
multiline_comment|/* So now we have dquots on the list... Just free them */
r_while
c_loop
(paren
id|act_head
op_ne
id|tofree_head
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|act_head
comma
r_struct
id|dquot
comma
id|dq_free
)paren
suffix:semicolon
id|act_head
op_assign
id|act_head-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
multiline_comment|/* Remove dquot from the list so we won&squot;t have problems... */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|dquot_incr_inodes
r_static
r_inline
r_void
id|dquot_incr_inodes
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
id|dquot-&gt;dq_dqb.dqb_curinodes
op_add_assign
id|number
suffix:semicolon
id|mark_dquot_dirty
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|dquot_incr_space
r_static
r_inline
r_void
id|dquot_incr_space
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|qsize_t
id|number
)paren
(brace
id|dquot-&gt;dq_dqb.dqb_curspace
op_add_assign
id|number
suffix:semicolon
id|mark_dquot_dirty
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|dquot_decr_inodes
r_static
r_inline
r_void
id|dquot_decr_inodes
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
OG
id|number
)paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_sub_assign
id|number
suffix:semicolon
r_else
id|dquot-&gt;dq_dqb.dqb_curinodes
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
OL
id|dquot-&gt;dq_dqb.dqb_isoftlimit
)paren
id|dquot-&gt;dq_dqb.dqb_itime
op_assign
(paren
id|time_t
)paren
l_int|0
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_INODES
suffix:semicolon
id|mark_dquot_dirty
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|dquot_decr_space
r_static
r_inline
r_void
id|dquot_decr_space
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|qsize_t
id|number
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
OG
id|number
)paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_sub_assign
id|number
suffix:semicolon
r_else
id|dquot-&gt;dq_dqb.dqb_curspace
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
)paren
OL
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
)paren
id|dquot-&gt;dq_dqb.dqb_btime
op_assign
(paren
id|time_t
)paren
l_int|0
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_BLKS
suffix:semicolon
id|mark_dquot_dirty
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|need_print_warning
r_static
r_inline
r_int
id|need_print_warning
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
id|flag
)paren
(brace
r_switch
c_cond
(paren
id|dquot-&gt;dq_type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
r_return
id|current-&gt;fsuid
op_eq
id|dquot-&gt;dq_id
op_logical_and
op_logical_neg
(paren
id|dquot-&gt;dq_flags
op_amp
id|flag
)paren
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
r_return
id|in_group_p
c_func
(paren
id|dquot-&gt;dq_id
)paren
op_logical_and
op_logical_neg
(paren
id|dquot-&gt;dq_flags
op_amp
id|flag
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Values of warnings */
DECL|macro|NOWARN
mdefine_line|#define NOWARN 0
DECL|macro|IHARDWARN
mdefine_line|#define IHARDWARN 1
DECL|macro|ISOFTLONGWARN
mdefine_line|#define ISOFTLONGWARN 2
DECL|macro|ISOFTWARN
mdefine_line|#define ISOFTWARN 3
DECL|macro|BHARDWARN
mdefine_line|#define BHARDWARN 4
DECL|macro|BSOFTLONGWARN
mdefine_line|#define BSOFTLONGWARN 5
DECL|macro|BSOFTWARN
mdefine_line|#define BSOFTWARN 6
multiline_comment|/* Print warning to user which exceeded quota */
DECL|function|print_warning
r_static
r_void
id|print_warning
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_const
r_char
id|warntype
)paren
(brace
r_char
op_star
id|msg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|flag
op_assign
(paren
id|warntype
op_eq
id|BHARDWARN
op_logical_or
id|warntype
op_eq
id|BSOFTLONGWARN
)paren
ques
c_cond
id|DQ_BLKS
suffix:colon
(paren
(paren
id|warntype
op_eq
id|IHARDWARN
op_logical_or
id|warntype
op_eq
id|ISOFTLONGWARN
)paren
ques
c_cond
id|DQ_INODES
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|need_print_warning
c_func
(paren
id|dquot
comma
id|flag
)paren
)paren
r_return
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|flag
suffix:semicolon
id|tty_write_message
c_func
(paren
id|current-&gt;tty
comma
id|dquot-&gt;dq_sb-&gt;s_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warntype
op_eq
id|ISOFTWARN
op_logical_or
id|warntype
op_eq
id|BSOFTWARN
)paren
id|tty_write_message
c_func
(paren
id|current-&gt;tty
comma
l_string|&quot;: warning, &quot;
)paren
suffix:semicolon
r_else
id|tty_write_message
c_func
(paren
id|current-&gt;tty
comma
l_string|&quot;: write failed, &quot;
)paren
suffix:semicolon
id|tty_write_message
c_func
(paren
id|current-&gt;tty
comma
id|quotatypes
(braket
id|dquot-&gt;dq_type
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|warntype
)paren
(brace
r_case
id|IHARDWARN
suffix:colon
id|msg
op_assign
l_string|&quot; file limit reached.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISOFTLONGWARN
suffix:colon
id|msg
op_assign
l_string|&quot; file quota exceeded too long.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ISOFTWARN
suffix:colon
id|msg
op_assign
l_string|&quot; file quota exceeded.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BHARDWARN
suffix:colon
id|msg
op_assign
l_string|&quot; block limit reached.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BSOFTLONGWARN
suffix:colon
id|msg
op_assign
l_string|&quot; block quota exceeded too long.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BSOFTWARN
suffix:colon
id|msg
op_assign
l_string|&quot; block quota exceeded.&bslash;n&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tty_write_message
c_func
(paren
id|current-&gt;tty
comma
id|msg
)paren
suffix:semicolon
)brace
DECL|function|flush_warnings
r_static
r_inline
r_void
id|flush_warnings
c_func
(paren
r_struct
id|dquot
op_star
op_star
id|dquots
comma
r_char
op_star
id|warntype
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAXQUOTAS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|dquots
(braket
id|i
)braket
op_ne
id|NODQUOT
op_logical_and
id|warntype
(braket
id|i
)braket
op_ne
id|NOWARN
)paren
id|print_warning
c_func
(paren
id|dquots
(braket
id|i
)braket
comma
id|warntype
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|ignore_hardlimit
r_static
r_inline
r_char
id|ignore_hardlimit
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_struct
id|mem_dqinfo
op_star
id|info
op_assign
op_amp
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
suffix:semicolon
r_return
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
op_logical_and
(paren
id|info-&gt;dqi_format-&gt;qf_fmt_id
op_ne
id|QFMT_VFS_OLD
op_logical_or
op_logical_neg
(paren
id|info-&gt;dqi_flags
op_amp
id|V1_DQF_RSQUASH
)paren
)paren
suffix:semicolon
)brace
DECL|function|check_idq
r_static
r_int
id|check_idq
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|ulong
id|inodes
comma
r_char
op_star
id|warntype
)paren
(brace
op_star
id|warntype
op_assign
id|NOWARN
suffix:semicolon
r_if
c_cond
(paren
id|inodes
op_le
l_int|0
op_logical_or
id|dquot-&gt;dq_flags
op_amp
id|DQ_FAKE
)paren
r_return
id|QUOTA_OK
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_ihardlimit
op_logical_and
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_dqb.dqb_ihardlimit
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
op_star
id|warntype
op_assign
id|IHARDWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_itime
op_logical_and
id|CURRENT_TIME
op_ge
id|dquot-&gt;dq_dqb.dqb_itime
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
op_star
id|warntype
op_assign
id|ISOFTLONGWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_dqb.dqb_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_dqb.dqb_isoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_itime
op_eq
l_int|0
)paren
(brace
op_star
id|warntype
op_assign
id|ISOFTWARN
suffix:semicolon
id|dquot-&gt;dq_dqb.dqb_itime
op_assign
id|CURRENT_TIME
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_igrace
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
)brace
DECL|function|check_bdq
r_static
r_int
id|check_bdq
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|qsize_t
id|space
comma
r_int
id|prealloc
comma
r_char
op_star
id|warntype
)paren
(brace
op_star
id|warntype
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|space
op_le
l_int|0
op_logical_or
id|dquot-&gt;dq_flags
op_amp
id|DQ_FAKE
)paren
r_return
id|QUOTA_OK
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_bhardlimit
op_logical_and
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_plus
id|space
)paren
OG
id|dquot-&gt;dq_dqb.dqb_bhardlimit
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
op_star
id|warntype
op_assign
id|BHARDWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_plus
id|space
)paren
OG
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_btime
op_logical_and
id|CURRENT_TIME
op_ge
id|dquot-&gt;dq_dqb.dqb_btime
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
op_star
id|warntype
op_assign
id|BSOFTLONGWARN
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|toqb
c_func
(paren
id|dquot-&gt;dq_dqb.dqb_curspace
op_plus
id|space
)paren
OG
id|dquot-&gt;dq_dqb.dqb_bsoftlimit
op_logical_and
id|dquot-&gt;dq_dqb.dqb_btime
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
(brace
op_star
id|warntype
op_assign
id|BSOFTWARN
suffix:semicolon
id|dquot-&gt;dq_dqb.dqb_btime
op_assign
id|CURRENT_TIME
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_bgrace
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t allow preallocation to exceed softlimit so exceeding will&n;&t;&t;&t; * be always printed&n;&t;&t;&t; */
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * Externally referenced functions through dquot_operations in inode.&n; *&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_initialize
r_void
id|dquot_initialize
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_int
r_int
id|id
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|IS_NOQUOTA
c_func
(paren
id|inode
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Build list of quotas to initialize... We can block here */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|cnt
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|inode-&gt;i_sb
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
(brace
r_switch
c_cond
(paren
id|cnt
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|id
op_assign
id|inode-&gt;i_uid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|id
op_assign
id|inode-&gt;i_gid
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|id
comma
id|cnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* NOBLOCK START: Here we shouldn&squot;t block */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
op_logical_or
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|inode-&gt;i_sb
comma
id|cnt
)paren
op_logical_or
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|dquot
(braket
id|cnt
)braket
suffix:semicolon
id|dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|inode-&gt;i_flags
op_or_assign
id|S_QUOTA
suffix:semicolon
)brace
multiline_comment|/* NOBLOCK END */
multiline_comment|/* Put quotas which we didn&squot;t use */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
id|dqput
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release all quota for the specified inode.&n; *&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_drop
r_void
id|dquot_drop
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_QUOTA
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot
op_assign
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This operation can block, but only after everything is updated&n; */
DECL|function|dquot_alloc_space
r_int
id|dquot_alloc_space
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|qsize_t
id|number
comma
r_int
id|warn
)paren
(brace
r_int
id|cnt
comma
id|ret
op_assign
id|NO_QUOTA
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_char
id|warntype
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|warntype
(braket
id|cnt
)braket
op_assign
id|NOWARN
suffix:semicolon
)brace
multiline_comment|/* NOBLOCK Start */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|dqduplicate
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_bdq
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
comma
id|warn
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
)paren
r_goto
id|warn_put_all
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_incr_space
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
)brace
id|inode_add_bytes
c_func
(paren
id|inode
comma
id|number
)paren
suffix:semicolon
multiline_comment|/* NOBLOCK End */
id|ret
op_assign
id|QUOTA_OK
suffix:semicolon
id|warn_put_all
suffix:colon
id|flush_warnings
c_func
(paren
id|dquot
comma
id|warntype
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
id|dqputduplicate
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This operation can block, but only after everything is updated&n; */
DECL|function|dquot_alloc_inode
r_int
id|dquot_alloc_inode
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
)paren
(brace
r_int
id|cnt
comma
id|ret
op_assign
id|NO_QUOTA
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_char
id|warntype
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|warntype
(braket
id|cnt
)braket
op_assign
id|NOWARN
suffix:semicolon
)brace
multiline_comment|/* NOBLOCK Start */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|dqduplicate
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_idq
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
)paren
r_goto
id|warn_put_all
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_incr_inodes
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
)brace
multiline_comment|/* NOBLOCK End */
id|ret
op_assign
id|QUOTA_OK
suffix:semicolon
id|warn_put_all
suffix:colon
id|flush_warnings
c_func
(paren
id|dquot
comma
id|warntype
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
id|dqputduplicate
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a non-blocking operation.&n; */
DECL|function|dquot_free_space
r_void
id|dquot_free_space
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|qsize_t
id|number
)paren
(brace
r_int
r_int
id|cnt
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
multiline_comment|/* NOBLOCK Start */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
op_assign
id|dqduplicate
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_decr_space
c_func
(paren
id|dquot
comma
id|number
)paren
suffix:semicolon
id|dqputduplicate
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
id|inode_sub_bytes
c_func
(paren
id|inode
comma
id|number
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* NOBLOCK End */
)brace
multiline_comment|/*&n; * This is a non-blocking operation.&n; */
DECL|function|dquot_free_inode
r_void
id|dquot_free_inode
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
)paren
(brace
r_int
r_int
id|cnt
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
multiline_comment|/* NOBLOCK Start */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
op_assign
id|dqduplicate
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_decr_inodes
c_func
(paren
id|dquot
comma
id|number
)paren
suffix:semicolon
id|dqputduplicate
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* NOBLOCK End */
)brace
multiline_comment|/*&n; * Transfer the number of inode and blocks from one diskquota to an other.&n; *&n; * This operation can block, but only after everything is updated&n; */
DECL|function|dquot_transfer
r_int
id|dquot_transfer
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|iattr
)paren
(brace
id|qsize_t
id|space
suffix:semicolon
r_struct
id|dquot
op_star
id|transfer_from
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_struct
id|dquot
op_star
id|transfer_to
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_int
id|cnt
comma
id|ret
op_assign
id|NO_QUOTA
comma
id|chuid
op_assign
(paren
id|iattr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
op_logical_and
id|inode-&gt;i_uid
op_ne
id|iattr-&gt;ia_uid
comma
id|chgid
op_assign
(paren
id|iattr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
op_logical_and
id|inode-&gt;i_gid
op_ne
id|iattr-&gt;ia_gid
suffix:semicolon
r_char
id|warntype
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
multiline_comment|/* Clear the arrays */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|warntype
(braket
id|cnt
)braket
op_assign
id|NOWARN
suffix:semicolon
)brace
multiline_comment|/* First build the transfer_to list - here we can block on reading of dquots... */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|inode-&gt;i_sb
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|cnt
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|chuid
)paren
r_continue
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|iattr-&gt;ia_uid
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|chgid
)paren
r_continue
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|iattr-&gt;ia_gid
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* NOBLOCK START: From now on we shouldn&squot;t block */
id|space
op_assign
id|inode_get_bytes
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* Build the transfer_from list and check the limits */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/* The second test can fail when quotaoff is in progress... */
r_if
c_cond
(paren
id|transfer_to
(braket
id|cnt
)braket
op_eq
id|NODQUOT
op_logical_or
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|inode-&gt;i_sb
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|dqduplicate
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
multiline_comment|/* Can happen on quotafiles (quota isn&squot;t initialized on them)... */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_idq
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
l_int|1
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
op_logical_or
id|check_bdq
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
id|space
comma
l_int|0
comma
id|warntype
op_plus
id|cnt
)paren
op_eq
id|NO_QUOTA
)paren
r_goto
id|warn_put_all
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally perform the needed transfer from transfer_from to transfer_to&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip changes for same uid or gid or for non-existing quota-type.&n;&t;&t; */
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
op_eq
id|NODQUOT
op_logical_or
id|transfer_to
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_decr_inodes
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
comma
l_int|1
)paren
suffix:semicolon
id|dquot_decr_space
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
comma
id|space
)paren
suffix:semicolon
id|dquot_incr_inodes
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
l_int|1
)paren
suffix:semicolon
id|dquot_incr_space
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
id|space
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|transfer_to
(braket
id|cnt
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We&squot;ve got to release transfer_from[] twice - once for dquot_transfer() and&n;&t;&t; * once for inode. We don&squot;t want to release transfer_to[] as it&squot;s now placed in inode&n;&t;&t; */
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|transfer_from
(braket
id|cnt
)braket
suffix:semicolon
)brace
multiline_comment|/* NOBLOCK END. From now on we can block as we wish */
id|ret
op_assign
id|QUOTA_OK
suffix:semicolon
id|warn_put_all
suffix:colon
id|flush_warnings
c_func
(paren
id|transfer_to
comma
id|warntype
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/* First we must put duplicate - otherwise we might deadlock */
r_if
c_cond
(paren
id|transfer_to
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
id|dqputduplicate
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
id|dqput
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Definitions of diskquota operations.&n; */
DECL|variable|dquot_operations
r_struct
id|dquot_operations
id|dquot_operations
op_assign
(brace
id|initialize
suffix:colon
id|dquot_initialize
comma
multiline_comment|/* mandatory */
id|drop
suffix:colon
id|dquot_drop
comma
multiline_comment|/* mandatory */
id|alloc_space
suffix:colon
id|dquot_alloc_space
comma
id|alloc_inode
suffix:colon
id|dquot_alloc_inode
comma
id|free_space
suffix:colon
id|dquot_free_space
comma
id|free_inode
suffix:colon
id|dquot_free_inode
comma
id|transfer
suffix:colon
id|dquot_transfer
)brace
suffix:semicolon
DECL|function|set_enable_flags
r_static
r_inline
r_void
id|set_enable_flags
c_func
(paren
r_struct
id|quota_info
op_star
id|dqopt
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|dqopt-&gt;flags
op_or_assign
id|DQUOT_USR_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|dqopt-&gt;flags
op_or_assign
id|DQUOT_GRP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|reset_enable_flags
r_static
r_inline
r_void
id|reset_enable_flags
c_func
(paren
r_struct
id|quota_info
op_star
id|dqopt
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|dqopt-&gt;flags
op_and_assign
op_complement
id|DQUOT_USR_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|dqopt-&gt;flags
op_and_assign
op_complement
id|DQUOT_GRP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Function in inode.c - remove pointers to dquots in icache */
r_extern
r_void
id|remove_dquot_ref
c_func
(paren
r_struct
id|super_block
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Turn quota off on a device. type == -1 ==&gt; quotaoff for all types (umount)&n; */
DECL|function|vfs_quota_off
r_int
id|vfs_quota_off
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We need to serialize quota_off() for device */
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|cnt
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_enabled
c_func
(paren
id|dqopt
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
id|reset_enable_flags
c_func
(paren
id|dqopt
comma
id|cnt
)paren
suffix:semicolon
multiline_comment|/* Note: these are blocking operations */
id|remove_dquot_ref
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
id|invalidate_dquots
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info_dirty
c_func
(paren
op_amp
id|dqopt-&gt;info
(braket
id|cnt
)braket
)paren
)paren
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_member_access_from_pointer
id|write_file_info
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_member_access_from_pointer
id|free_file_info
)paren
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_member_access_from_pointer
id|free_file_info
c_func
(paren
id|sb
comma
id|cnt
)paren
suffix:semicolon
id|put_quota_format
c_func
(paren
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_format
)paren
suffix:semicolon
id|fput
c_func
(paren
id|dqopt-&gt;files
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqopt-&gt;files
(braket
id|cnt
)braket
op_assign
(paren
r_struct
id|file
op_star
)paren
l_int|NULL
suffix:semicolon
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_flags
op_assign
l_int|0
suffix:semicolon
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_igrace
op_assign
l_int|0
suffix:semicolon
id|dqopt-&gt;info
(braket
id|cnt
)braket
dot
id|dqi_bgrace
op_assign
l_int|0
suffix:semicolon
id|dqopt-&gt;ops
(braket
id|cnt
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfs_quota_on
r_int
id|vfs_quota_on
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_int
id|format_id
comma
r_char
op_star
id|path
)paren
(brace
r_struct
id|file
op_star
id|f
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|quota_info
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
r_struct
id|quota_format_type
op_star
id|fmt
op_assign
id|find_quota_format
c_func
(paren
id|format_id
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|is_enabled
c_func
(paren
id|dqopt
comma
id|type
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|out_fmt
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
id|f
op_assign
id|filp_open
c_func
(paren
id|path
comma
id|O_RDWR
comma
l_int|0600
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|f
)paren
)paren
r_goto
id|out_lock
suffix:semicolon
id|dqopt-&gt;files
(braket
id|type
)braket
op_assign
id|f
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;f_op
op_logical_or
op_logical_neg
id|f-&gt;f_op-&gt;read
op_logical_or
op_logical_neg
id|f-&gt;f_op-&gt;write
)paren
r_goto
id|out_f
suffix:semicolon
id|inode
op_assign
id|f-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_goto
id|out_f
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt-&gt;qf_ops
op_member_access_from_pointer
id|check_quota_file
c_func
(paren
id|sb
comma
id|type
)paren
)paren
r_goto
id|out_f
suffix:semicolon
multiline_comment|/* We don&squot;t want quota on quota files */
id|dquot_drop
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_flags
op_or_assign
id|S_NOQUOTA
suffix:semicolon
id|dqopt-&gt;ops
(braket
id|type
)braket
op_assign
id|fmt-&gt;qf_ops
suffix:semicolon
id|dqopt-&gt;info
(braket
id|type
)braket
dot
id|dqi_format
op_assign
id|fmt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|dqopt-&gt;ops
(braket
id|type
)braket
op_member_access_from_pointer
id|read_file_info
c_func
(paren
id|sb
comma
id|type
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out_f
suffix:semicolon
id|set_enable_flags
c_func
(paren
id|dqopt
comma
id|type
)paren
suffix:semicolon
id|add_dquot_ref
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_f
suffix:colon
r_if
c_cond
(paren
id|f
)paren
id|filp_close
c_func
(paren
id|f
comma
l_int|NULL
)paren
suffix:semicolon
id|dqopt-&gt;files
(braket
id|type
)braket
op_assign
l_int|NULL
suffix:semicolon
id|out_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
id|out_fmt
suffix:colon
id|put_quota_format
c_func
(paren
id|fmt
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Generic routine for getting common part of quota structure */
DECL|function|do_get_dqblk
r_static
r_void
id|do_get_dqblk
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|mem_dqblk
op_star
id|dm
op_assign
op_amp
id|dquot-&gt;dq_dqb
suffix:semicolon
id|di-&gt;dqb_bhardlimit
op_assign
id|dm-&gt;dqb_bhardlimit
suffix:semicolon
id|di-&gt;dqb_bsoftlimit
op_assign
id|dm-&gt;dqb_bsoftlimit
suffix:semicolon
id|di-&gt;dqb_curspace
op_assign
id|dm-&gt;dqb_curspace
suffix:semicolon
id|di-&gt;dqb_ihardlimit
op_assign
id|dm-&gt;dqb_ihardlimit
suffix:semicolon
id|di-&gt;dqb_isoftlimit
op_assign
id|dm-&gt;dqb_isoftlimit
suffix:semicolon
id|di-&gt;dqb_curinodes
op_assign
id|dm-&gt;dqb_curinodes
suffix:semicolon
id|di-&gt;dqb_btime
op_assign
id|dm-&gt;dqb_btime
suffix:semicolon
id|di-&gt;dqb_itime
op_assign
id|dm-&gt;dqb_itime
suffix:semicolon
id|di-&gt;dqb_valid
op_assign
id|QIF_ALL
suffix:semicolon
)brace
DECL|function|vfs_get_dqblk
r_int
id|vfs_get_dqblk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|qid_t
id|id
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
op_assign
id|dqget
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|do_get_dqblk
c_func
(paren
id|dquot
comma
id|di
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generic routine for setting common part of quota structure */
DECL|function|do_set_dqblk
r_static
r_void
id|do_set_dqblk
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|mem_dqblk
op_star
id|dm
op_assign
op_amp
id|dquot-&gt;dq_dqb
suffix:semicolon
r_int
id|check_blim
op_assign
l_int|0
comma
id|check_ilim
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_SPACE
)paren
(brace
id|dm-&gt;dqb_curspace
op_assign
id|di-&gt;dqb_curspace
suffix:semicolon
id|check_blim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_BLIMITS
)paren
(brace
id|dm-&gt;dqb_bsoftlimit
op_assign
id|di-&gt;dqb_bsoftlimit
suffix:semicolon
id|dm-&gt;dqb_bhardlimit
op_assign
id|di-&gt;dqb_bhardlimit
suffix:semicolon
id|check_blim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_INODES
)paren
(brace
id|dm-&gt;dqb_curinodes
op_assign
id|di-&gt;dqb_curinodes
suffix:semicolon
id|check_ilim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_ILIMITS
)paren
(brace
id|dm-&gt;dqb_isoftlimit
op_assign
id|di-&gt;dqb_isoftlimit
suffix:semicolon
id|dm-&gt;dqb_ihardlimit
op_assign
id|di-&gt;dqb_ihardlimit
suffix:semicolon
id|check_ilim
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_BTIME
)paren
id|dm-&gt;dqb_btime
op_assign
id|di-&gt;dqb_btime
suffix:semicolon
r_if
c_cond
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_ITIME
)paren
id|dm-&gt;dqb_itime
op_assign
id|di-&gt;dqb_itime
suffix:semicolon
r_if
c_cond
(paren
id|check_blim
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dm-&gt;dqb_bsoftlimit
op_logical_or
id|toqb
c_func
(paren
id|dm-&gt;dqb_curspace
)paren
OL
id|dm-&gt;dqb_bsoftlimit
)paren
(brace
id|dm-&gt;dqb_btime
op_assign
l_int|0
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_BLKS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_BTIME
)paren
)paren
multiline_comment|/* Set grace only if user hasn&squot;t provided his own... */
id|dm-&gt;dqb_btime
op_assign
id|CURRENT_TIME
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_bgrace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_ilim
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dm-&gt;dqb_isoftlimit
op_logical_or
id|dm-&gt;dqb_curinodes
OL
id|dm-&gt;dqb_isoftlimit
)paren
(brace
id|dm-&gt;dqb_itime
op_assign
l_int|0
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_INODES
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|di-&gt;dqb_valid
op_amp
id|QIF_ITIME
)paren
)paren
multiline_comment|/* Set grace only if user hasn&squot;t provided his own... */
id|dm-&gt;dqb_itime
op_assign
id|CURRENT_TIME
op_plus
id|sb_dqopt
c_func
(paren
id|dquot-&gt;dq_sb
)paren
op_member_access_from_pointer
id|info
(braket
id|dquot-&gt;dq_type
)braket
dot
id|dqi_igrace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dm-&gt;dqb_bhardlimit
op_logical_or
id|dm-&gt;dqb_bsoftlimit
op_logical_or
id|dm-&gt;dqb_ihardlimit
op_logical_or
id|dm-&gt;dqb_isoftlimit
)paren
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_FAKE
suffix:semicolon
r_else
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_FAKE
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_MOD
suffix:semicolon
)brace
DECL|function|vfs_set_dqblk
r_int
id|vfs_set_dqblk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
id|qid_t
id|id
comma
r_struct
id|if_dqblk
op_star
id|di
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
op_assign
id|dqget
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|do_set_dqblk
c_func
(paren
id|dquot
comma
id|di
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generic routine for getting common part of quota file information */
DECL|function|vfs_get_info
r_int
id|vfs_get_info
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_struct
id|if_dqinfo
op_star
id|ii
)paren
(brace
r_struct
id|mem_dqinfo
op_star
id|mi
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
op_plus
id|type
suffix:semicolon
id|ii-&gt;dqi_bgrace
op_assign
id|mi-&gt;dqi_bgrace
suffix:semicolon
id|ii-&gt;dqi_igrace
op_assign
id|mi-&gt;dqi_igrace
suffix:semicolon
id|ii-&gt;dqi_flags
op_assign
id|mi-&gt;dqi_flags
op_amp
id|DQF_MASK
suffix:semicolon
id|ii-&gt;dqi_valid
op_assign
id|IIF_ALL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Generic routine for setting common part of quota file information */
DECL|function|vfs_set_info
r_int
id|vfs_set_info
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_struct
id|if_dqinfo
op_star
id|ii
)paren
(brace
r_struct
id|mem_dqinfo
op_star
id|mi
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|info
op_plus
id|type
suffix:semicolon
r_if
c_cond
(paren
id|ii-&gt;dqi_valid
op_amp
id|IIF_BGRACE
)paren
id|mi-&gt;dqi_bgrace
op_assign
id|ii-&gt;dqi_bgrace
suffix:semicolon
r_if
c_cond
(paren
id|ii-&gt;dqi_valid
op_amp
id|IIF_IGRACE
)paren
id|mi-&gt;dqi_igrace
op_assign
id|ii-&gt;dqi_igrace
suffix:semicolon
r_if
c_cond
(paren
id|ii-&gt;dqi_valid
op_amp
id|IIF_FLAGS
)paren
id|mi-&gt;dqi_flags
op_assign
(paren
id|mi-&gt;dqi_flags
op_amp
op_complement
id|DQF_MASK
)paren
op_or
(paren
id|ii-&gt;dqi_flags
op_amp
id|DQF_MASK
)paren
suffix:semicolon
id|mark_info_dirty
c_func
(paren
id|mi
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|vfs_quotactl_ops
r_struct
id|quotactl_ops
id|vfs_quotactl_ops
op_assign
(brace
id|quota_on
suffix:colon
id|vfs_quota_on
comma
id|quota_off
suffix:colon
id|vfs_quota_off
comma
id|quota_sync
suffix:colon
id|vfs_quota_sync
comma
id|get_info
suffix:colon
id|vfs_get_info
comma
id|set_info
suffix:colon
id|vfs_set_info
comma
id|get_dqblk
suffix:colon
id|vfs_get_dqblk
comma
id|set_dqblk
suffix:colon
id|vfs_set_dqblk
)brace
suffix:semicolon
DECL|variable|fs_table
r_static
id|ctl_table
id|fs_table
(braket
)braket
op_assign
(brace
(brace
id|FS_DQSTATS
comma
l_string|&quot;dqstats&quot;
comma
id|dqstats_array
comma
r_sizeof
(paren
id|dqstats_array
)paren
comma
l_int|0444
comma
l_int|NULL
comma
op_amp
id|proc_dointvec
)brace
comma
(brace
)brace
comma
)brace
suffix:semicolon
DECL|variable|dquot_table
r_static
id|ctl_table
id|dquot_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_FS
comma
l_string|&quot;fs&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|fs_table
)brace
comma
(brace
)brace
comma
)brace
suffix:semicolon
DECL|function|dquot_init
r_static
r_int
id|__init
id|dquot_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|register_sysctl_table
c_func
(paren
id|dquot_table
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_DQHASH
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|dquot_hash
op_plus
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;VFS: Disk quotas v%s&bslash;n&quot;
comma
id|__DQUOT_VERSION__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|dquot_init
id|__initcall
c_func
(paren
id|dquot_init
)paren
suffix:semicolon
DECL|variable|register_quota_format
id|EXPORT_SYMBOL
c_func
(paren
id|register_quota_format
)paren
suffix:semicolon
DECL|variable|unregister_quota_format
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_quota_format
)paren
suffix:semicolon
DECL|variable|dqstats_array
id|EXPORT_SYMBOL
c_func
(paren
id|dqstats_array
)paren
suffix:semicolon
eof
