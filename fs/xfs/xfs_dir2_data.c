multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * xfs_dir2_data.c&n; * Core data block handling routines for XFS V2 directories.&n; * See xfs_dir2_data.h for data structures.&n; */
macro_line|#include &lt;xfs.h&gt;
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Check the consistency of the data block.&n; * The input can also be a block-format directory.&n; * Pop an assert if we find anything bad.&n; */
r_void
DECL|function|xfs_dir2_data_check
id|xfs_dir2_data_check
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore inode pointer */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* data block&squot;s buffer */
(brace
id|xfs_dir2_dataptr_t
id|addr
suffix:semicolon
multiline_comment|/* addr for leaf lookup */
id|xfs_dir2_data_free_t
op_star
id|bf
suffix:semicolon
multiline_comment|/* bestfree table */
id|xfs_dir2_block_tail_t
op_star
id|btp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* block tail */
r_int
id|count
suffix:semicolon
multiline_comment|/* count of entries found */
id|xfs_dir2_data_t
op_star
id|d
suffix:semicolon
multiline_comment|/* data block pointer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry */
id|xfs_dir2_data_free_t
op_star
id|dfp
suffix:semicolon
multiline_comment|/* bestfree entry */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* unused entry */
r_char
op_star
id|endp
suffix:semicolon
multiline_comment|/* end of useful data */
r_int
id|freeseen
suffix:semicolon
multiline_comment|/* mask of bestfrees seen */
id|xfs_dahash_t
id|hash
suffix:semicolon
multiline_comment|/* hash of current name */
r_int
id|i
suffix:semicolon
multiline_comment|/* leaf index */
r_int
id|lastfree
suffix:semicolon
multiline_comment|/* last entry was unused */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* block leaf entries */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_char
op_star
id|p
suffix:semicolon
multiline_comment|/* current data position */
r_int
id|stale
suffix:semicolon
multiline_comment|/* count of stale leaves */
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|d
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
id|bf
op_assign
id|d-&gt;hdr.bestfree
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|d-&gt;u
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
(brace
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_block_t
op_star
)paren
id|d
)paren
suffix:semicolon
id|lep
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|endp
op_assign
(paren
r_char
op_star
)paren
id|lep
suffix:semicolon
)brace
r_else
id|endp
op_assign
(paren
r_char
op_star
)paren
id|d
op_plus
id|mp-&gt;m_dirblksize
suffix:semicolon
id|count
op_assign
id|lastfree
op_assign
id|freeseen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Account for zero bestfree entries.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|bf
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|bf
(braket
l_int|0
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|freeseen
op_or_assign
l_int|1
op_lshift
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|bf
(braket
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|bf
(braket
l_int|1
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|freeseen
op_or_assign
l_int|1
op_lshift
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|bf
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|bf
(braket
l_int|2
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|freeseen
op_or_assign
l_int|1
op_lshift
l_int|2
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the data/unused entries.&n;&t; */
r_while
c_loop
(paren
id|p
OL
id|endp
)paren
(brace
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|p
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s unused, look for the space in the bestfree table.&n;&t;&t; * If we find it, account for that, else make sure it&n;&t;&t; * doesn&squot;t need to be there.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
(brace
id|ASSERT
c_func
(paren
id|lastfree
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|dup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
)paren
op_eq
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
suffix:semicolon
id|dfp
op_assign
id|xfs_dir2_data_freefind
c_func
(paren
id|d
comma
id|dup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfp
)paren
(brace
id|i
op_assign
(paren
r_int
)paren
(paren
id|dfp
op_minus
id|bf
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|freeseen
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|freeseen
op_or_assign
l_int|1
op_lshift
id|i
suffix:semicolon
)brace
r_else
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|lastfree
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * It&squot;s a real entry.  Validate the fields.&n;&t;&t; * If this is a block directory then make sure it&squot;s&n;&t;&t; * in the leaf section of the block.&n;&t;&t; * The linear search is crude but this is DEBUG code.&n;&t;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|p
suffix:semicolon
id|ASSERT
c_func
(paren
id|dep-&gt;namelen
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_dir_ino_validate
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
op_star
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
comma
id|ARCH_CONVERT
)paren
op_eq
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|lastfree
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
(brace
id|addr
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|hash
op_assign
id|xfs_da_hashname
c_func
(paren
(paren
r_char
op_star
)paren
id|dep-&gt;name
comma
id|dep-&gt;namelen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|lep
(braket
id|i
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|addr
op_logical_and
id|INT_GET
c_func
(paren
id|lep
(braket
id|i
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hash
)paren
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
OL
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
id|p
op_add_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Need to have seen all the entries and all the bestfree slots.&n;&t; */
id|ASSERT
c_func
(paren
id|freeseen
op_eq
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|stale
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|lep
(braket
id|i
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
id|stale
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|lep
(braket
id|i
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|lep
(braket
id|i
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|count
op_eq
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|stale
op_eq
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * Given a data block and an unused entry from that block,&n; * return the bestfree entry if any that corresponds to it.&n; */
id|xfs_dir2_data_free_t
op_star
DECL|function|xfs_dir2_data_freefind
id|xfs_dir2_data_freefind
c_func
(paren
id|xfs_dir2_data_t
op_star
id|d
comma
multiline_comment|/* data block */
id|xfs_dir2_data_unused_t
op_star
id|dup
)paren
multiline_comment|/* data unused entry */
(brace
id|xfs_dir2_data_free_t
op_star
id|dfp
suffix:semicolon
multiline_comment|/* bestfree entry */
id|xfs_dir2_data_aoff_t
id|off
suffix:semicolon
multiline_comment|/* offset value needed */
macro_line|#if defined(DEBUG) &amp;&amp; defined(__KERNEL__)
r_int
id|matched
suffix:semicolon
multiline_comment|/* matched the value */
r_int
id|seenzero
suffix:semicolon
multiline_comment|/* saw a 0 bestfree entry */
macro_line|#endif
id|off
op_assign
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) &amp;&amp; defined(__KERNEL__)
multiline_comment|/*&n;&t; * Validate some consistency in the bestfree table.&n;&t; * Check order, non-overlapping entries, and if we find the&n;&t; * one we&squot;re looking for it has to be exact.&n;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dfp
op_assign
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
comma
id|seenzero
op_assign
id|matched
op_assign
l_int|0
suffix:semicolon
id|dfp
OL
op_amp
id|d-&gt;hdr.bestfree
(braket
id|XFS_DIR2_DATA_FD_COUNT
)braket
suffix:semicolon
id|dfp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|dfp-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|seenzero
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|seenzero
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
op_eq
id|off
)paren
(brace
id|matched
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;length
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|off
OL
id|INT_GET
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
)paren
id|ASSERT
c_func
(paren
id|off
op_plus
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_else
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|dfp-&gt;length
comma
id|ARCH_CONVERT
)paren
op_le
id|off
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|matched
op_logical_or
id|INT_GET
c_func
(paren
id|dfp-&gt;length
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfp
OG
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp
(braket
op_minus
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|dfp
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If this is smaller than the smallest bestfree entry,&n;&t; * it can&squot;t be there since they&squot;re sorted.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
id|XFS_DIR2_DATA_FD_COUNT
op_minus
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Look at the three bestfree entries for our guy.&n;&t; */
r_for
c_loop
(paren
id|dfp
op_assign
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
suffix:semicolon
id|dfp
OL
op_amp
id|d-&gt;hdr.bestfree
(braket
id|XFS_DIR2_DATA_FD_COUNT
)braket
suffix:semicolon
id|dfp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
op_eq
id|off
)paren
r_return
id|dfp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find it.  This only happens if there are duplicate lengths.&n;&t; */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert an unused-space entry into the bestfree table.&n; */
id|xfs_dir2_data_free_t
op_star
multiline_comment|/* entry inserted */
DECL|function|xfs_dir2_data_freeinsert
id|xfs_dir2_data_freeinsert
c_func
(paren
id|xfs_dir2_data_t
op_star
id|d
comma
multiline_comment|/* data block pointer */
id|xfs_dir2_data_unused_t
op_star
id|dup
comma
multiline_comment|/* unused space */
r_int
op_star
id|loghead
)paren
multiline_comment|/* log the data header (out) */
(brace
id|xfs_dir2_data_free_t
op_star
id|dfp
suffix:semicolon
multiline_comment|/* bestfree table pointer */
id|xfs_dir2_data_free_t
r_new
suffix:semicolon
multiline_comment|/* new bestfree entry */
macro_line|#ifdef __KERNEL__
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
macro_line|#endif
id|dfp
op_assign
id|d-&gt;hdr.bestfree
suffix:semicolon
id|INT_COPY
c_func
(paren
r_new
dot
id|length
comma
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
r_new
dot
id|offset
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Insert at position 0, 1, or 2; or not at all.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
r_new
dot
id|length
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|dfp
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|dfp
(braket
l_int|2
)braket
op_assign
id|dfp
(braket
l_int|1
)braket
suffix:semicolon
id|dfp
(braket
l_int|1
)braket
op_assign
id|dfp
(braket
l_int|0
)braket
suffix:semicolon
id|dfp
(braket
l_int|0
)braket
op_assign
r_new
suffix:semicolon
op_star
id|loghead
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|dfp
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
r_new
dot
id|length
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|dfp
(braket
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|dfp
(braket
l_int|2
)braket
op_assign
id|dfp
(braket
l_int|1
)braket
suffix:semicolon
id|dfp
(braket
l_int|1
)braket
op_assign
r_new
suffix:semicolon
op_star
id|loghead
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|dfp
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
r_new
dot
id|length
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|dfp
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|dfp
(braket
l_int|2
)braket
op_assign
r_new
suffix:semicolon
op_star
id|loghead
op_assign
l_int|1
suffix:semicolon
r_return
op_amp
id|dfp
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a bestfree entry from the table.&n; */
r_void
DECL|function|xfs_dir2_data_freeremove
id|xfs_dir2_data_freeremove
c_func
(paren
id|xfs_dir2_data_t
op_star
id|d
comma
multiline_comment|/* data block pointer */
id|xfs_dir2_data_free_t
op_star
id|dfp
comma
multiline_comment|/* bestfree entry pointer */
r_int
op_star
id|loghead
)paren
multiline_comment|/* out: log data header */
(brace
macro_line|#ifdef __KERNEL__
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * It&squot;s the first entry, slide the next 2 up.&n;&t; */
r_if
c_cond
(paren
id|dfp
op_eq
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
)paren
(brace
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
op_assign
id|d-&gt;hdr.bestfree
(braket
l_int|1
)braket
suffix:semicolon
id|d-&gt;hdr.bestfree
(braket
l_int|1
)braket
op_assign
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It&squot;s the second entry, slide the 3rd entry up.&n;&t; */
r_else
r_if
c_cond
(paren
id|dfp
op_eq
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|1
)braket
)paren
id|d-&gt;hdr.bestfree
(braket
l_int|1
)braket
op_assign
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Must be the last entry.&n;&t; */
r_else
id|ASSERT
c_func
(paren
id|dfp
op_eq
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the 3rd entry, must be zero now.&n;&t; */
id|INT_ZERO
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
op_star
id|loghead
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a data block, reconstruct its bestfree map.&n; */
r_void
DECL|function|xfs_dir2_data_freescan
id|xfs_dir2_data_freescan
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* filesystem mount point */
id|xfs_dir2_data_t
op_star
id|d
comma
multiline_comment|/* data block pointer */
r_int
op_star
id|loghead
comma
multiline_comment|/* out: log data header */
r_char
op_star
id|aendp
)paren
multiline_comment|/* in: caller&squot;s endp */
(brace
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* active data entry */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* unused data entry */
r_char
op_star
id|endp
suffix:semicolon
multiline_comment|/* end of block&squot;s data */
r_char
op_star
id|p
suffix:semicolon
multiline_comment|/* current entry pointer */
macro_line|#ifdef __KERNEL__
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Start by clearing the table.&n;&t; */
id|memset
c_func
(paren
id|d-&gt;hdr.bestfree
comma
l_int|0
comma
r_sizeof
(paren
id|d-&gt;hdr.bestfree
)paren
)paren
suffix:semicolon
op_star
id|loghead
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Set up pointers.&n;&t; */
id|p
op_assign
(paren
r_char
op_star
)paren
id|d-&gt;u
suffix:semicolon
r_if
c_cond
(paren
id|aendp
)paren
id|endp
op_assign
id|aendp
suffix:semicolon
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
(brace
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_block_t
op_star
)paren
id|d
)paren
suffix:semicolon
id|endp
op_assign
(paren
r_char
op_star
)paren
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
id|endp
op_assign
(paren
r_char
op_star
)paren
id|d
op_plus
id|mp-&gt;m_dirblksize
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the block&squot;s entries.&n;&t; */
r_while
c_loop
(paren
id|p
OL
id|endp
)paren
(brace
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|p
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s a free entry, insert it.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
(brace
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
op_eq
id|INT_GET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|dup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|dup
comma
id|loghead
)paren
suffix:semicolon
id|p
op_add_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For active entries, check their tags and skip them.&n;&t;&t; */
r_else
(brace
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|p
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|d
op_eq
id|INT_GET
c_func
(paren
op_star
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|p
op_add_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Initialize a data block at the given block number in the directory.&n; * Give back the buffer for the created block.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_data_init
id|xfs_dir2_data_init
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* directory operation args */
id|xfs_dir2_db_t
id|blkno
comma
multiline_comment|/* logical dir block number */
id|xfs_dabuf_t
op_star
op_star
id|bpp
)paren
multiline_comment|/* output block buffer */
(brace
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* block buffer */
id|xfs_dir2_data_t
op_star
id|d
suffix:semicolon
multiline_comment|/* pointer to block */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* unused entry pointer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* bestfree index */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
r_int
id|t
suffix:semicolon
multiline_comment|/* temp */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * Get the buffer set up for the block.&n;&t; */
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|blkno
)paren
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the header.&n;&t; */
id|d
op_assign
id|bp-&gt;data
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|offset
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
r_sizeof
(paren
id|d-&gt;hdr
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|XFS_DIR2_DATA_FD_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INT_ZERO
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
id|i
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
id|i
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set up an unused entry for the block&squot;s body.&n;&t; */
id|dup
op_assign
op_amp
id|d-&gt;u
(braket
l_int|0
)braket
dot
id|unused
suffix:semicolon
id|INT_SET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_FREE_TAG
)paren
suffix:semicolon
id|t
op_assign
id|mp-&gt;m_dirblksize
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|d-&gt;hdr
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
comma
id|t
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
comma
id|t
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|dup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log it and return it.&n;&t; */
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|dup
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Log an active data entry from the block.&n; */
r_void
DECL|function|xfs_dir2_data_log_entry
id|xfs_dir2_data_log_entry
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* block buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
)paren
multiline_comment|/* data entry pointer */
(brace
id|xfs_dir2_data_t
op_star
id|d
suffix:semicolon
multiline_comment|/* data block pointer */
id|d
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
op_plus
l_int|1
)paren
op_minus
(paren
r_char
op_star
)paren
id|d
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log a data block header.&n; */
r_void
DECL|function|xfs_dir2_data_log_header
id|xfs_dir2_data_log_header
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* block buffer */
(brace
id|xfs_dir2_data_t
op_star
id|d
suffix:semicolon
multiline_comment|/* data block pointer */
id|d
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|d-&gt;hdr
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
comma
(paren
id|uint
)paren
(paren
r_sizeof
(paren
id|d-&gt;hdr
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log a data unused entry.&n; */
r_void
DECL|function|xfs_dir2_data_log_unused
id|xfs_dir2_data_log_unused
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* block buffer */
id|xfs_dir2_data_unused_t
op_star
id|dup
)paren
multiline_comment|/* data unused pointer */
(brace
id|xfs_dir2_data_t
op_star
id|d
suffix:semicolon
multiline_comment|/* data block pointer */
id|d
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log the first part of the unused entry.&n;&t; */
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|dup-&gt;length
op_plus
r_sizeof
(paren
id|dup-&gt;length
)paren
op_minus
l_int|1
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log the end (tag) of the unused entry.&n;&t; */
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|dup
comma
id|ARCH_CONVERT
)paren
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|dup
comma
id|ARCH_CONVERT
)paren
op_minus
(paren
r_char
op_star
)paren
id|d
op_plus
r_sizeof
(paren
id|xfs_dir2_data_off_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Make a byte range in the data block unused.&n; * Its current contents are unimportant.&n; */
r_void
DECL|function|xfs_dir2_data_make_free
id|xfs_dir2_data_make_free
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* block buffer */
id|xfs_dir2_data_aoff_t
id|offset
comma
multiline_comment|/* starting byte offset */
id|xfs_dir2_data_aoff_t
id|len
comma
multiline_comment|/* length in bytes */
r_int
op_star
id|needlogp
comma
multiline_comment|/* out: log header */
r_int
op_star
id|needscanp
)paren
multiline_comment|/* out: regen bestfree */
(brace
id|xfs_dir2_data_t
op_star
id|d
suffix:semicolon
multiline_comment|/* data block pointer */
id|xfs_dir2_data_free_t
op_star
id|dfp
suffix:semicolon
multiline_comment|/* bestfree pointer */
r_char
op_star
id|endptr
suffix:semicolon
multiline_comment|/* end of data area */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to regen bestfree */
id|xfs_dir2_data_unused_t
op_star
id|newdup
suffix:semicolon
multiline_comment|/* new unused entry */
id|xfs_dir2_data_unused_t
op_star
id|postdup
suffix:semicolon
multiline_comment|/* unused entry after us */
id|xfs_dir2_data_unused_t
op_star
id|prevdup
suffix:semicolon
multiline_comment|/* unused entry before us */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|d
op_assign
id|bp-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out where the end of the data area is.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
)paren
id|endptr
op_assign
(paren
r_char
op_star
)paren
id|d
op_plus
id|mp-&gt;m_dirblksize
suffix:semicolon
r_else
(brace
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_block_t
op_star
)paren
id|d
)paren
suffix:semicolon
id|endptr
op_assign
(paren
r_char
op_star
)paren
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this isn&squot;t the start of the block, then back up to&n;&t; * the previous entry and see if it&squot;s free.&n;&t; */
r_if
c_cond
(paren
id|offset
OG
r_sizeof
(paren
id|d-&gt;hdr
)paren
)paren
(brace
id|xfs_dir2_data_off_t
op_star
id|tagp
suffix:semicolon
multiline_comment|/* tag just before us */
id|tagp
op_assign
(paren
id|xfs_dir2_data_off_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
)paren
op_minus
l_int|1
suffix:semicolon
id|prevdup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|INT_GET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|prevdup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_DATA_FREE_TAG
)paren
id|prevdup
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|prevdup
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If this isn&squot;t the end of the block, see if the entry after&n;&t; * us is free.&n;&t; */
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
op_plus
id|len
OL
id|endptr
)paren
(brace
id|postdup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
op_plus
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|postdup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_DATA_FREE_TAG
)paren
id|postdup
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
id|postdup
op_assign
l_int|NULL
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|needscanp
op_eq
l_int|0
)paren
suffix:semicolon
id|needscan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Previous and following entries are both free,&n;&t; * merge everything into a single free entry.&n;&t; */
r_if
c_cond
(paren
id|prevdup
op_logical_and
id|postdup
)paren
(brace
id|xfs_dir2_data_free_t
op_star
id|dfp2
suffix:semicolon
multiline_comment|/* another bestfree pointer */
multiline_comment|/*&n;&t;&t; * See if prevdup and/or postdup are in bestfree table.&n;&t;&t; */
id|dfp
op_assign
id|xfs_dir2_data_freefind
c_func
(paren
id|d
comma
id|prevdup
)paren
suffix:semicolon
id|dfp2
op_assign
id|xfs_dir2_data_freefind
c_func
(paren
id|d
comma
id|postdup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need a rescan unless there are exactly 2 free entries&n;&t;&t; * namely our two.  Then we know what&squot;s happening, otherwise&n;&t;&t; * since the third bestfree is there, there might be more&n;&t;&t; * entries.&n;&t;&t; */
id|needscan
op_assign
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fix up the new big freespace.&n;&t;&t; */
id|INT_MOD
c_func
(paren
id|prevdup-&gt;length
comma
id|ARCH_CONVERT
comma
id|len
op_plus
id|INT_GET
c_func
(paren
id|postdup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|prevdup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|prevdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|prevdup
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|needscan
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Has to be the case that entries 0 and 1 are&n;&t;&t;&t; * dfp and dfp2 (don&squot;t know which is which), and&n;&t;&t;&t; * entry 2 is empty.&n;&t;&t;&t; * Remove entry 1 first then entry 0.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|dfp
op_logical_and
id|dfp2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dfp
op_eq
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|1
)braket
)paren
(brace
id|dfp
op_assign
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|dfp2
op_eq
id|dfp
)paren
suffix:semicolon
id|dfp2
op_assign
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|1
)braket
suffix:semicolon
)brace
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp2
comma
id|needlogp
)paren
suffix:semicolon
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp
comma
id|needlogp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Now insert the new entry.&n;&t;&t;&t; */
id|dfp
op_assign
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|prevdup
comma
id|needlogp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dfp
op_eq
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;length
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|prevdup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|dfp
(braket
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|dfp
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The entry before us is free, merge with it.&n;&t; */
r_else
r_if
c_cond
(paren
id|prevdup
)paren
(brace
id|dfp
op_assign
id|xfs_dir2_data_freefind
c_func
(paren
id|d
comma
id|prevdup
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|prevdup-&gt;length
comma
id|ARCH_CONVERT
comma
id|len
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|prevdup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|prevdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|prevdup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the previous entry was in the table, the new entry&n;&t;&t; * is longer, so it will be in the table too.  Remove&n;&t;&t; * the old one and add the new one.&n;&t;&t; */
r_if
c_cond
(paren
id|dfp
)paren
(brace
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp
comma
id|needlogp
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|prevdup
comma
id|needlogp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Otherwise we need a scan if the new entry is big enough.&n;&t;&t; */
r_else
id|needscan
op_assign
id|INT_GET
c_func
(paren
id|prevdup-&gt;length
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The following entry is free, merge with it.&n;&t; */
r_else
r_if
c_cond
(paren
id|postdup
)paren
(brace
id|dfp
op_assign
id|xfs_dir2_data_freefind
c_func
(paren
id|d
comma
id|postdup
)paren
suffix:semicolon
id|newdup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;freetag
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_FREE_TAG
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
comma
id|len
op_plus
id|INT_GET
c_func
(paren
id|postdup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|newdup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|newdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|newdup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the following entry was in the table, the new entry&n;&t;&t; * is longer, so it will be in the table too.  Remove&n;&t;&t; * the old one and add the new one.&n;&t;&t; */
r_if
c_cond
(paren
id|dfp
)paren
(brace
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp
comma
id|needlogp
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|newdup
comma
id|needlogp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Otherwise we need a scan if the new entry is big enough.&n;&t;&t; */
r_else
id|needscan
op_assign
id|INT_GET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Neither neighbor is free.  Make a new entry.&n;&t; */
r_else
(brace
id|newdup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;freetag
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_FREE_TAG
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
comma
id|len
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|newdup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|newdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|newdup
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|newdup
comma
id|needlogp
)paren
suffix:semicolon
)brace
op_star
id|needscanp
op_assign
id|needscan
suffix:semicolon
)brace
multiline_comment|/*&n; * Take a byte range out of an existing unused space and make it un-free.&n; */
r_void
DECL|function|xfs_dir2_data_use_free
id|xfs_dir2_data_use_free
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* data block buffer */
id|xfs_dir2_data_unused_t
op_star
id|dup
comma
multiline_comment|/* unused entry */
id|xfs_dir2_data_aoff_t
id|offset
comma
multiline_comment|/* starting offset to use */
id|xfs_dir2_data_aoff_t
id|len
comma
multiline_comment|/* length to use */
r_int
op_star
id|needlogp
comma
multiline_comment|/* out: need to log header */
r_int
op_star
id|needscanp
)paren
multiline_comment|/* out: need regen bestfree */
(brace
id|xfs_dir2_data_t
op_star
id|d
suffix:semicolon
multiline_comment|/* data block */
id|xfs_dir2_data_free_t
op_star
id|dfp
suffix:semicolon
multiline_comment|/* bestfree pointer */
r_int
id|matchback
suffix:semicolon
multiline_comment|/* matches end of freespace */
r_int
id|matchfront
suffix:semicolon
multiline_comment|/* matches start of freespace */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to regen bestfree */
id|xfs_dir2_data_unused_t
op_star
id|newdup
suffix:semicolon
multiline_comment|/* new unused entry */
id|xfs_dir2_data_unused_t
op_star
id|newdup2
suffix:semicolon
multiline_comment|/* another new unused entry */
r_int
id|oldlen
suffix:semicolon
multiline_comment|/* old unused entry&squot;s length */
id|d
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|d-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
op_ge
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
op_plus
id|len
op_le
(paren
r_char
op_star
)paren
id|dup
op_plus
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
op_eq
id|INT_GET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|dup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the entry in the bestfree table.&n;&t; */
id|dfp
op_assign
id|xfs_dir2_data_freefind
c_func
(paren
id|d
comma
id|dup
)paren
suffix:semicolon
id|oldlen
op_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dfp
op_logical_or
id|oldlen
op_le
id|INT_GET
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for alignment with front and back of the entry.&n;&t; */
id|matchfront
op_assign
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|d
op_eq
id|offset
suffix:semicolon
id|matchback
op_assign
(paren
r_char
op_star
)paren
id|dup
op_plus
id|oldlen
op_minus
(paren
r_char
op_star
)paren
id|d
op_eq
id|offset
op_plus
id|len
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|needscanp
op_eq
l_int|0
)paren
suffix:semicolon
id|needscan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we matched it exactly we just need to get rid of it from&n;&t; * the bestfree table.&n;&t; */
r_if
c_cond
(paren
id|matchfront
op_logical_and
id|matchback
)paren
(brace
r_if
c_cond
(paren
id|dfp
)paren
(brace
id|needscan
op_assign
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|needscan
)paren
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp
comma
id|needlogp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We match the first part of the entry.&n;&t; * Make a new entry with the remaining freespace.&n;&t; */
r_else
r_if
c_cond
(paren
id|matchfront
)paren
(brace
id|newdup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;freetag
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_FREE_TAG
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
comma
id|oldlen
op_minus
id|len
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|newdup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|newdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|newdup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it was in the table, remove it and add the new one.&n;&t;&t; */
r_if
c_cond
(paren
id|dfp
)paren
(brace
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp
comma
id|needlogp
)paren
suffix:semicolon
id|dfp
op_assign
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|newdup
comma
id|needlogp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dfp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;length
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
op_eq
(paren
r_char
op_star
)paren
id|newdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we got inserted at the last slot,&n;&t;&t;&t; * that means we don&squot;t know if there was a better&n;&t;&t;&t; * choice for the last slot, or not.  Rescan.&n;&t;&t;&t; */
id|needscan
op_assign
id|dfp
op_eq
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We match the last part of the entry.&n;&t; * Trim the allocated space off the tail of the entry.&n;&t; */
r_else
r_if
c_cond
(paren
id|matchback
)paren
(brace
id|newdup
op_assign
id|dup
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
)paren
op_minus
(paren
r_char
op_star
)paren
id|newdup
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|newdup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|newdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|newdup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it was in the table, remove it and add the new one.&n;&t;&t; */
r_if
c_cond
(paren
id|dfp
)paren
(brace
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp
comma
id|needlogp
)paren
suffix:semicolon
id|dfp
op_assign
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|newdup
comma
id|needlogp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dfp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;length
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dfp-&gt;offset
comma
id|ARCH_CONVERT
)paren
op_eq
(paren
r_char
op_star
)paren
id|newdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we got inserted at the last slot,&n;&t;&t;&t; * that means we don&squot;t know if there was a better&n;&t;&t;&t; * choice for the last slot, or not.  Rescan.&n;&t;&t;&t; */
id|needscan
op_assign
id|dfp
op_eq
op_amp
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Poking out the middle of an entry.&n;&t; * Make two new entries.&n;&t; */
r_else
(brace
id|newdup
op_assign
id|dup
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
)paren
op_minus
(paren
r_char
op_star
)paren
id|newdup
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|newdup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|newdup
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|newdup
)paren
suffix:semicolon
id|newdup2
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|d
op_plus
id|offset
op_plus
id|len
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup2-&gt;freetag
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_FREE_TAG
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newdup2-&gt;length
comma
id|ARCH_CONVERT
comma
id|oldlen
op_minus
id|len
op_minus
id|INT_GET
c_func
(paren
id|newdup-&gt;length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|newdup2
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|newdup2
op_minus
(paren
r_char
op_star
)paren
id|d
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|newdup2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the old entry was in the table, we need to scan&n;&t;&t; * if the 3rd entry was valid, since these entries&n;&t;&t; * are smaller than the old one.&n;&t;&t; * If we don&squot;t need to scan that means there were 1 or 2&n;&t;&t; * entries in the table, and removing the old and adding&n;&t;&t; * the 2 new will work.&n;&t;&t; */
r_if
c_cond
(paren
id|dfp
)paren
(brace
id|needscan
op_assign
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|d-&gt;hdr.bestfree
(braket
l_int|2
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|needscan
)paren
(brace
id|xfs_dir2_data_freeremove
c_func
(paren
id|d
comma
id|dfp
comma
id|needlogp
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|newdup
comma
id|needlogp
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_dir2_data_freeinsert
c_func
(paren
id|d
comma
id|newdup2
comma
id|needlogp
)paren
suffix:semicolon
)brace
)brace
)brace
op_star
id|needscanp
op_assign
id|needscan
suffix:semicolon
)brace
eof
