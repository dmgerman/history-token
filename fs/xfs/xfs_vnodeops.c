multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_itable.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_refcache.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rtalloc.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_utils.h&quot;
macro_line|#include &quot;xfs_trans_space.h&quot;
macro_line|#include &quot;xfs_dir_leaf.h&quot;
macro_line|#include &quot;xfs_mac.h&quot;
macro_line|#include &quot;xfs_log_priv.h&quot;
multiline_comment|/*&n; * The maximum pathlen is 1024 bytes. Since the minimum file system&n; * blocksize is 512 bytes, we can get a max of 2 extents back from&n; * bmapi.&n; */
DECL|macro|SYMLINK_MAPS
mdefine_line|#define SYMLINK_MAPS 2
multiline_comment|/*&n; * For xfs, we check that the file isn&squot;t too big to be opened by this kernel.&n; * No other open action is required for regular files.  Devices are handled&n; * through the specfs file system, pipes through fifofs.  Device and&n; * fifo vnodes are &quot;wrapped&quot; by specfs and fifofs vnodes, respectively,&n; * when a new vnode is first looked up or created.&n; */
id|STATIC
r_int
DECL|function|xfs_open
id|xfs_open
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_int
id|mode
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s a directory with any blocks, read-ahead block 0&n;&t; * as we&squot;re almost certain to have the next operation be a read there.&n;&t; */
r_if
c_cond
(paren
id|vp-&gt;v_type
op_eq
id|VDIR
op_logical_and
id|ip-&gt;i_d.di_nextents
OG
l_int|0
)paren
(brace
id|mode
op_assign
id|xfs_ilock_map_shared
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nextents
OG
l_int|0
)paren
(paren
r_void
)paren
id|xfs_da_reada_buf
c_func
(paren
l_int|NULL
comma
id|ip
comma
l_int|0
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|mode
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_getattr&n; */
id|STATIC
r_int
DECL|function|xfs_getattr
id|xfs_getattr
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vattr_t
op_star
id|vap
comma
r_int
id|flags
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|ATTR_LAZY
)paren
)paren
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|vap-&gt;va_size
op_assign
id|ip-&gt;i_d.di_size
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_mask
op_eq
id|XFS_AT_SIZE
)paren
r_goto
id|all_done
suffix:semicolon
id|vap-&gt;va_nblocks
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|ip-&gt;i_d.di_nblocks
op_plus
id|ip-&gt;i_delayed_blks
)paren
suffix:semicolon
id|vap-&gt;va_nodeid
op_assign
id|ip-&gt;i_ino
suffix:semicolon
macro_line|#if XFS_BIG_INUMS
id|vap-&gt;va_nodeid
op_add_assign
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#endif
id|vap-&gt;va_nlink
op_assign
id|ip-&gt;i_d.di_nlink
suffix:semicolon
multiline_comment|/*&n;&t; * Quick exit for non-stat callers&n;&t; */
r_if
c_cond
(paren
(paren
id|vap-&gt;va_mask
op_amp
op_complement
(paren
id|XFS_AT_SIZE
op_or
id|XFS_AT_FSID
op_or
id|XFS_AT_NODEID
op_or
id|XFS_AT_NLINK
op_or
id|XFS_AT_BLKSIZE
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|all_done
suffix:semicolon
multiline_comment|/*&n;&t; * Copy from in-core inode.&n;&t; */
id|vap-&gt;va_type
op_assign
id|vp-&gt;v_type
suffix:semicolon
id|vap-&gt;va_mode
op_assign
id|ip-&gt;i_d.di_mode
op_amp
id|MODEMASK
suffix:semicolon
id|vap-&gt;va_uid
op_assign
id|ip-&gt;i_d.di_uid
suffix:semicolon
id|vap-&gt;va_gid
op_assign
id|ip-&gt;i_d.di_gid
suffix:semicolon
id|vap-&gt;va_projid
op_assign
id|ip-&gt;i_d.di_projid
suffix:semicolon
multiline_comment|/*&n;&t; * Check vnode type block/char vs. everything else.&n;&t; * Do it with bitmask because that&squot;s faster than looking&n;&t; * for multiple values individually.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|vp-&gt;v_type
)paren
op_amp
(paren
(paren
l_int|1
op_lshift
id|VBLK
)paren
op_or
(paren
l_int|1
op_lshift
id|VCHR
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|vap-&gt;va_rdev
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
)paren
(brace
macro_line|#if 0
multiline_comment|/* Large block sizes confuse various&n;&t;&t;&t; * user space programs, so letting the&n;&t;&t;&t; * stripe size through is not a good&n;&t;&t;&t; * idea for now.&n;&t;&t;&t; */
id|vap-&gt;va_blocksize
op_assign
id|mp-&gt;m_swidth
ques
c_cond
multiline_comment|/*&n;&t;&t;&t;&t; * If the underlying volume is a stripe, then&n;&t;&t;&t;&t; * return the stripe width in bytes as the&n;&t;&t;&t;&t; * recommended I/O size.&n;&t;&t;&t;&t; */
(paren
id|mp-&gt;m_swidth
op_lshift
id|mp-&gt;m_sb.sb_blocklog
)paren
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Return the largest of the preferred buffer&n;&t;&t;&t;&t; * sizes since doing small I/Os into larger&n;&t;&t;&t;&t; * buffers causes buffers to be decommissioned.&n;&t;&t;&t;&t; * The value returned is in bytes.&n;&t;&t;&t;&t; */
(paren
l_int|1
op_lshift
(paren
r_int
)paren
id|MAX
c_func
(paren
id|mp-&gt;m_readio_log
comma
id|mp-&gt;m_writeio_log
)paren
)paren
suffix:semicolon
macro_line|#else
id|vap-&gt;va_blocksize
op_assign
multiline_comment|/*&n;&t;&t;&t;&t; * Return the largest of the preferred buffer&n;&t;&t;&t;&t; * sizes since doing small I/Os into larger&n;&t;&t;&t;&t; * buffers causes buffers to be decommissioned.&n;&t;&t;&t;&t; * The value returned is in bytes.&n;&t;&t;&t;&t; */
l_int|1
op_lshift
(paren
r_int
)paren
id|MAX
c_func
(paren
id|mp-&gt;m_readio_log
comma
id|mp-&gt;m_writeio_log
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If the file blocks are being allocated from a&n;&t;&t;&t; * realtime partition, then return the inode&squot;s&n;&t;&t;&t; * realtime extent size or the realtime volume&squot;s&n;&t;&t;&t; * extent size.&n;&t;&t;&t; */
id|vap-&gt;va_blocksize
op_assign
id|ip-&gt;i_d.di_extsize
ques
c_cond
(paren
id|ip-&gt;i_d.di_extsize
op_lshift
id|mp-&gt;m_sb.sb_blocklog
)paren
suffix:colon
(paren
id|mp-&gt;m_sb.sb_rextsize
op_lshift
id|mp-&gt;m_sb.sb_blocklog
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|vap-&gt;va_rdev
op_assign
id|ip-&gt;i_df.if_u2.if_rdev
suffix:semicolon
id|vap-&gt;va_blocksize
op_assign
id|BLKDEV_IOSIZE
suffix:semicolon
)brace
id|vap-&gt;va_atime.tv_sec
op_assign
id|ip-&gt;i_d.di_atime.t_sec
suffix:semicolon
id|vap-&gt;va_atime.tv_nsec
op_assign
id|ip-&gt;i_d.di_atime.t_nsec
suffix:semicolon
id|vap-&gt;va_mtime.tv_sec
op_assign
id|ip-&gt;i_d.di_mtime.t_sec
suffix:semicolon
id|vap-&gt;va_mtime.tv_nsec
op_assign
id|ip-&gt;i_d.di_mtime.t_nsec
suffix:semicolon
id|vap-&gt;va_ctime.tv_sec
op_assign
id|ip-&gt;i_d.di_ctime.t_sec
suffix:semicolon
id|vap-&gt;va_ctime.tv_nsec
op_assign
id|ip-&gt;i_d.di_ctime.t_nsec
suffix:semicolon
multiline_comment|/*&n;&t; * Exit for stat callers.  See if any of the rest of the fields&n;&t; * to be filled in are needed.&n;&t; */
r_if
c_cond
(paren
(paren
id|vap-&gt;va_mask
op_amp
(paren
id|XFS_AT_XFLAGS
op_or
id|XFS_AT_EXTSIZE
op_or
id|XFS_AT_NEXTENTS
op_or
id|XFS_AT_ANEXTENTS
op_or
id|XFS_AT_GENCOUNT
op_or
id|XFS_AT_VCODE
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|all_done
suffix:semicolon
multiline_comment|/*&n;&t; * Convert di_flags to xflags.&n;&t; */
id|vap-&gt;va_xflags
op_assign
id|xfs_dic2xflags
c_func
(paren
op_amp
id|ip-&gt;i_d
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Exit for inode revalidate.  See if any of the rest of&n;&t; * the fields to be filled in are needed.&n;&t; */
r_if
c_cond
(paren
(paren
id|vap-&gt;va_mask
op_amp
(paren
id|XFS_AT_EXTSIZE
op_or
id|XFS_AT_NEXTENTS
op_or
id|XFS_AT_ANEXTENTS
op_or
id|XFS_AT_GENCOUNT
op_or
id|XFS_AT_VCODE
)paren
)paren
op_eq
l_int|0
)paren
r_goto
id|all_done
suffix:semicolon
id|vap-&gt;va_extsize
op_assign
id|ip-&gt;i_d.di_extsize
op_lshift
id|mp-&gt;m_sb.sb_blocklog
suffix:semicolon
id|vap-&gt;va_nextents
op_assign
(paren
id|ip-&gt;i_df.if_flags
op_amp
id|XFS_IFEXTENTS
)paren
ques
c_cond
id|ip-&gt;i_df.if_bytes
op_div
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:colon
id|ip-&gt;i_d.di_nextents
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_afp
)paren
id|vap-&gt;va_anextents
op_assign
(paren
id|ip-&gt;i_afp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
ques
c_cond
id|ip-&gt;i_afp-&gt;if_bytes
op_div
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:colon
id|ip-&gt;i_d.di_anextents
suffix:semicolon
r_else
id|vap-&gt;va_anextents
op_assign
l_int|0
suffix:semicolon
id|vap-&gt;va_gen
op_assign
id|ip-&gt;i_d.di_gen
suffix:semicolon
id|all_done
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|ATTR_LAZY
)paren
)paren
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_setattr&n; */
r_int
DECL|function|xfs_setattr
id|xfs_setattr
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vattr_t
op_star
id|vap
comma
r_int
id|flags
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|mask
suffix:semicolon
r_int
id|code
suffix:semicolon
id|uint
id|lock_flags
suffix:semicolon
id|uint
id|commit_flags
op_assign
l_int|0
suffix:semicolon
id|uid_t
id|uid
op_assign
l_int|0
comma
id|iuid
op_assign
l_int|0
suffix:semicolon
id|gid_t
id|gid
op_assign
l_int|0
comma
id|igid
op_assign
l_int|0
suffix:semicolon
r_int
id|timeflags
op_assign
l_int|0
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|xfs_prid_t
id|projid
op_assign
l_int|0
comma
id|iprojid
op_assign
l_int|0
suffix:semicolon
r_int
id|mandlock_before
comma
id|mandlock_after
suffix:semicolon
r_struct
id|xfs_dquot
op_star
id|udqp
comma
op_star
id|gdqp
comma
op_star
id|olddquot1
comma
op_star
id|olddquot2
suffix:semicolon
r_int
id|file_owner
suffix:semicolon
r_int
id|need_iolock
op_assign
(paren
id|flags
op_amp
id|ATTR_DMI
)paren
op_eq
l_int|0
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp-&gt;v_vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Cannot set certain attributes.&n;&t; */
id|mask
op_assign
id|vap-&gt;va_mask
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_NOSET
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Timestamps do not need to be logged and hence do not&n;&t; * need to be done within a transaction.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_UPDTIMES
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|mask
op_amp
op_complement
id|XFS_AT_UPDTIMES
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|timeflags
op_assign
(paren
(paren
id|mask
op_amp
id|XFS_AT_UPDATIME
)paren
ques
c_cond
id|XFS_ICHGTIME_ACC
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|mask
op_amp
id|XFS_AT_UPDCTIME
)paren
ques
c_cond
id|XFS_ICHGTIME_CHG
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|mask
op_amp
id|XFS_AT_UPDMTIME
)paren
ques
c_cond
id|XFS_ICHGTIME_MOD
suffix:colon
l_int|0
)paren
suffix:semicolon
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|timeflags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|olddquot1
op_assign
id|olddquot2
op_assign
l_int|NULL
suffix:semicolon
id|udqp
op_assign
id|gdqp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If disk quotas is on, we make sure that the dquots do exist on disk,&n;&t; * before we start any other transactions. Trying to do this later&n;&t; * is messy. We don&squot;t care to take a readlock to look at the ids&n;&t; * in inode here, because we can&squot;t hold it across the trans_reserve.&n;&t; * If the IDs do change before we take the ilock, we&squot;re covered&n;&t; * because the i_*dquot fields will get updated anyway.&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
(paren
id|mask
op_amp
(paren
id|XFS_AT_UID
op_or
id|XFS_AT_GID
)paren
)paren
)paren
(brace
id|uint
id|qflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_UID
)paren
(brace
id|uid
op_assign
id|vap-&gt;va_uid
suffix:semicolon
id|qflags
op_or_assign
id|XFS_QMOPT_UQUOTA
suffix:semicolon
)brace
r_else
(brace
id|uid
op_assign
id|ip-&gt;i_d.di_uid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_GID
)paren
(brace
id|gid
op_assign
id|vap-&gt;va_gid
suffix:semicolon
id|qflags
op_or_assign
id|XFS_QMOPT_GQUOTA
suffix:semicolon
)brace
r_else
(brace
id|gid
op_assign
id|ip-&gt;i_d.di_gid
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We take a reference when we initialize udqp and gdqp,&n;&t;&t; * so it is important that we never blindly double trip on&n;&t;&t; * the same variable. See xfs_create() for an example.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|udqp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|gdqp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|code
op_assign
id|XFS_QM_DQVOPALLOC
c_func
(paren
id|mp
comma
id|ip
comma
id|uid
comma
id|gid
comma
id|qflags
comma
op_amp
id|udqp
comma
op_amp
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
)paren
r_return
(paren
id|code
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For the other attributes, we acquire the inode lock and&n;&t; * first do an error checking pass.&n;&t; */
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|lock_flags
op_assign
id|XFS_ILOCK_EXCL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|XFS_AT_SIZE
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|mask
op_ne
(paren
id|XFS_AT_CTIME
op_or
id|XFS_AT_ATIME
op_or
id|XFS_AT_MTIME
)paren
)paren
op_logical_or
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
)paren
(brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_SETATTR_NOT_SIZE
)paren
suffix:semicolon
id|commit_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ICHANGE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
id|lock_flags
op_assign
l_int|0
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
(paren
id|vp-&gt;v_vfsp
comma
id|ip
comma
id|DM_EVENT_TRUNCATE
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|ATTR_DMI
)paren
)paren
(brace
r_int
id|dmflags
op_assign
id|AT_DELAY_FLAG
c_func
(paren
id|flags
)paren
op_or
id|DM_SEM_FLAG_WR
suffix:semicolon
id|code
op_assign
id|XFS_SEND_DATA
c_func
(paren
id|mp
comma
id|DM_EVENT_TRUNCATE
comma
id|vp
comma
id|vap-&gt;va_size
comma
l_int|0
comma
id|dmflags
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
)paren
(brace
id|lock_flags
op_assign
l_int|0
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|need_iolock
)paren
id|lock_flags
op_or_assign
id|XFS_IOLOCK_EXCL
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/* boolean: are we the file owner? */
id|file_owner
op_assign
(paren
id|current_fsuid
c_func
(paren
id|credp
)paren
op_eq
id|ip-&gt;i_d.di_uid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Change various properties of a file.&n;&t; * Only the owner or users with CAP_FOWNER&n;&t; * capability may do these things.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|XFS_AT_MODE
op_or
id|XFS_AT_XFLAGS
op_or
id|XFS_AT_EXTSIZE
op_or
id|XFS_AT_UID
op_or
id|XFS_AT_GID
op_or
id|XFS_AT_PROJID
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * CAP_FOWNER overrides the following restrictions:&n;&t;&t; *&n;&t;&t; * The user ID of the calling process must be equal&n;&t;&t; * to the file owner ID, except in cases where the&n;&t;&t; * CAP_FSETID capability is applicable.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|file_owner
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * CAP_FSETID overrides the following restrictions:&n;&t;&t; *&n;&t;&t; * The effective user ID of the calling process shall match&n;&t;&t; * the file owner when setting the set-user-ID and&n;&t;&t; * set-group-ID bits on that file.&n;&t;&t; *&n;&t;&t; * The effective group ID or one of the supplementary group&n;&t;&t; * IDs of the calling process shall match the group owner of&n;&t;&t; * the file when setting the set-group-ID bit on that file&n;&t;&t; */
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_MODE
)paren
(brace
id|mode_t
id|m
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vap-&gt;va_mode
op_amp
id|S_ISUID
)paren
op_logical_and
op_logical_neg
id|file_owner
)paren
id|m
op_or_assign
id|S_ISUID
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vap-&gt;va_mode
op_amp
id|S_ISGID
)paren
op_logical_and
op_logical_neg
id|in_group_p
c_func
(paren
(paren
id|gid_t
)paren
id|ip-&gt;i_d.di_gid
)paren
)paren
id|m
op_or_assign
id|S_ISGID
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Linux allows this, Irix doesn&squot;t. */
r_if
c_cond
(paren
(paren
id|vap-&gt;va_mode
op_amp
id|S_ISVTX
)paren
op_logical_and
id|vp-&gt;v_type
op_ne
id|VDIR
)paren
id|m
op_or_assign
id|S_ISVTX
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|m
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FSETID
)paren
)paren
id|vap-&gt;va_mode
op_and_assign
op_complement
id|m
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Change file ownership.  Must be the owner or privileged.&n;&t; * If the system was configured with the &quot;restricted_chown&quot;&n;&t; * option, the owner is not permitted to give away the file,&n;&t; * and can change the group id only to a group of which he&n;&t; * or she is a member.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|XFS_AT_UID
op_or
id|XFS_AT_GID
op_or
id|XFS_AT_PROJID
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * These IDs could have changed since we last looked at them.&n;&t;&t; * But, we&squot;re assured that if the ownership did change&n;&t;&t; * while we didn&squot;t have the inode locked, inode&squot;s dquot(s)&n;&t;&t; * would have changed also.&n;&t;&t; */
id|iuid
op_assign
id|ip-&gt;i_d.di_uid
suffix:semicolon
id|iprojid
op_assign
id|ip-&gt;i_d.di_projid
suffix:semicolon
id|igid
op_assign
id|ip-&gt;i_d.di_gid
suffix:semicolon
id|gid
op_assign
(paren
id|mask
op_amp
id|XFS_AT_GID
)paren
ques
c_cond
id|vap-&gt;va_gid
suffix:colon
id|igid
suffix:semicolon
id|uid
op_assign
(paren
id|mask
op_amp
id|XFS_AT_UID
)paren
ques
c_cond
id|vap-&gt;va_uid
suffix:colon
id|iuid
suffix:semicolon
id|projid
op_assign
(paren
id|mask
op_amp
id|XFS_AT_PROJID
)paren
ques
c_cond
(paren
id|xfs_prid_t
)paren
id|vap-&gt;va_projid
suffix:colon
id|iprojid
suffix:semicolon
multiline_comment|/*&n;&t;&t; * CAP_CHOWN overrides the following restrictions:&n;&t;&t; *&n;&t;&t; * If _POSIX_CHOWN_RESTRICTED is defined, this capability&n;&t;&t; * shall override the restriction that a process cannot&n;&t;&t; * change the user ID of a file it owns and the restriction&n;&t;&t; * that the group ID supplied to the chown() function&n;&t;&t; * shall be equal to either the group ID or one of the&n;&t;&t; * supplementary group IDs of the calling process.&n;&t;&t; *&n;&t;&t; * XXX: How does restricted_chown affect projid?&n;&t;&t; */
r_if
c_cond
(paren
id|restricted_chown
op_logical_and
(paren
id|iuid
op_ne
id|uid
op_logical_or
(paren
id|igid
op_ne
id|gid
op_logical_and
op_logical_neg
id|in_group_p
c_func
(paren
(paren
id|gid_t
)paren
id|gid
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_CHOWN
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Do a quota reservation only if uid or gid is actually&n;&t;&t; * going to change.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|iuid
op_ne
id|uid
)paren
op_logical_or
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|igid
op_ne
id|gid
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|tp
)paren
suffix:semicolon
id|code
op_assign
id|XFS_QM_DQVOPCHOWNRESV
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|udqp
comma
id|gdqp
comma
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
ques
c_cond
id|XFS_QMOPT_FORCE_RES
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
)paren
multiline_comment|/* out of quota */
r_goto
id|error_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Truncate file.  Must have write permission and not be a directory.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_SIZE
)paren
(brace
multiline_comment|/* Short circuit the truncate case for zero length files */
r_if
c_cond
(paren
(paren
id|vap-&gt;va_size
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_size
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_nextents
op_eq
l_int|0
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|lock_flags
op_and_assign
op_complement
id|XFS_ILOCK_EXCL
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_CTIME
)paren
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|code
op_assign
l_int|0
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vp-&gt;v_type
op_eq
id|VDIR
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EISDIR
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vp-&gt;v_type
op_ne
id|VREG
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Make sure that the dquots are attached to the inode.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|code
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|ip
comma
id|XFS_QMOPT_ILOCKED
)paren
)paren
)paren
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Change file access or modified times.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|XFS_AT_ATIME
op_or
id|XFS_AT_MTIME
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|file_owner
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|ATTR_UTIME
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Change extent size or realtime flag.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|XFS_AT_EXTSIZE
op_or
id|XFS_AT_XFLAGS
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Can&squot;t change extent size if any extents are allocated.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_nextents
op_logical_or
id|ip-&gt;i_delayed_blks
)paren
op_logical_and
(paren
id|mask
op_amp
id|XFS_AT_EXTSIZE
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_d.di_extsize
op_lshift
id|mp-&gt;m_sb.sb_blocklog
)paren
op_ne
id|vap-&gt;va_extsize
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* EFBIG? */
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Can&squot;t set extent size unless the file is marked, or&n;&t;&t; * about to be marked as a realtime file.&n;&t;&t; *&n;&t;&t; * This check will be removed when fixed size extents&n;&t;&t; * with buffered data writes is implemented.&n;&t;&t; *&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|XFS_AT_EXTSIZE
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_d.di_extsize
op_lshift
id|mp-&gt;m_sb.sb_blocklog
)paren
op_ne
id|vap-&gt;va_extsize
)paren
op_logical_and
(paren
op_logical_neg
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_logical_or
(paren
(paren
id|mask
op_amp
id|XFS_AT_XFLAGS
)paren
op_logical_and
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_REALTIME
)paren
)paren
)paren
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Can&squot;t change realtime flag if any extents are allocated.&n;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nextents
op_logical_and
(paren
id|mask
op_amp
id|XFS_AT_XFLAGS
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_REALTIME
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* EFBIG? */
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Extent size must be a multiple of the appropriate block&n;&t;&t; * size, if set at all.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|XFS_AT_EXTSIZE
)paren
op_logical_and
id|vap-&gt;va_extsize
op_ne
l_int|0
)paren
(brace
id|xfs_extlen_t
id|size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_logical_or
(paren
(paren
id|mask
op_amp
id|XFS_AT_XFLAGS
)paren
op_logical_and
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_REALTIME
)paren
)paren
)paren
(brace
id|size
op_assign
id|mp-&gt;m_sb.sb_rextsize
op_lshift
id|mp-&gt;m_sb.sb_blocklog
suffix:semicolon
)brace
r_else
(brace
id|size
op_assign
id|mp-&gt;m_sb.sb_blocksize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vap-&gt;va_extsize
op_mod
id|size
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If realtime flag is set then must have realtime data.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|XFS_AT_XFLAGS
)paren
op_logical_and
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_REALTIME
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|mp-&gt;m_sb.sb_rblocks
op_eq
l_int|0
)paren
op_logical_or
(paren
id|mp-&gt;m_sb.sb_rextsize
op_eq
l_int|0
)paren
op_logical_or
(paren
id|ip-&gt;i_d.di_extsize
op_mod
id|mp-&gt;m_sb.sb_rextsize
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Can&squot;t modify an immutable/append-only file unless&n;&t;&t; * we have appropriate permission.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|XFS_AT_XFLAGS
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_flags
op_amp
(paren
id|XFS_DIFLAG_IMMUTABLE
op_or
id|XFS_DIFLAG_APPEND
)paren
op_logical_or
(paren
id|vap-&gt;va_xflags
op_amp
(paren
id|XFS_XFLAG_IMMUTABLE
op_or
id|XFS_XFLAG_APPEND
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_LINUX_IMMUTABLE
)paren
)paren
(brace
id|code
op_assign
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now we can make the changes.  Before we join the inode&n;&t; * to the transaction, if XFS_AT_SIZE is set then take care of&n;&t; * the part of the truncation that must be done without the&n;&t; * inode lock.  This needs to be done before joining the inode&n;&t; * to the transaction, because the inode cannot be unlocked&n;&t; * once it is a part of the transaction.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_SIZE
)paren
(brace
id|code
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_size
OG
id|ip-&gt;i_d.di_size
)paren
id|code
op_assign
id|xfs_igrow_start
c_func
(paren
id|ip
comma
id|vap-&gt;va_size
comma
id|credp
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|code
)paren
id|code
op_assign
id|xfs_itruncate_data
c_func
(paren
id|ip
comma
id|vap-&gt;va_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
)paren
(brace
id|ASSERT
c_func
(paren
id|tp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|lock_flags
op_and_assign
op_complement
id|XFS_ILOCK_EXCL
suffix:semicolon
id|ASSERT
c_func
(paren
id|lock_flags
op_eq
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_SETATTR_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|code
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_iolock
)paren
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
id|code
suffix:semicolon
)brace
id|commit_flags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/* determine whether mandatory locking mode changes */
id|mandlock_before
op_assign
id|MANDLOCK
c_func
(paren
id|vp
comma
id|ip-&gt;i_d.di_mode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Truncate file.  Must have write permission and not be a directory.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_SIZE
)paren
(brace
r_if
c_cond
(paren
id|vap-&gt;va_size
OG
id|ip-&gt;i_d.di_size
)paren
(brace
id|xfs_igrow_finish
c_func
(paren
id|tp
comma
id|ip
comma
id|vap-&gt;va_size
comma
op_logical_neg
(paren
id|flags
op_amp
id|ATTR_DMI
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|vap-&gt;va_size
op_le
id|ip-&gt;i_d.di_size
)paren
op_logical_or
(paren
(paren
id|vap-&gt;va_size
op_eq
l_int|0
)paren
op_logical_and
id|ip-&gt;i_d.di_nextents
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * signal a sync transaction unless&n;&t;&t;&t; * we&squot;re truncating an already unlinked&n;&t;&t;&t; * file on a wsync filesystem&n;&t;&t;&t; */
id|code
op_assign
id|xfs_itruncate_finish
c_func
(paren
op_amp
id|tp
comma
id|ip
comma
(paren
id|xfs_fsize_t
)paren
id|vap-&gt;va_size
comma
id|XFS_DATA_FORK
comma
(paren
(paren
id|ip-&gt;i_d.di_nlink
op_ne
l_int|0
op_logical_or
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
)paren
(brace
r_goto
id|abort_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Have to do this even if the file&squot;s size doesn&squot;t change.&n;&t;&t; */
id|timeflags
op_or_assign
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Change file access modes.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_MODE
)paren
(brace
id|ip-&gt;i_d.di_mode
op_and_assign
id|S_IFMT
suffix:semicolon
id|ip-&gt;i_d.di_mode
op_or_assign
id|vap-&gt;va_mode
op_amp
op_complement
id|S_IFMT
suffix:semicolon
id|xfs_trans_log_inode
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|timeflags
op_or_assign
id|XFS_ICHGTIME_CHG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Change file ownership.  Must be the owner or privileged.&n;&t; * If the system was configured with the &quot;restricted_chown&quot;&n;&t; * option, the owner is not permitted to give away the file,&n;&t; * and can change the group id only to a group of which he&n;&t; * or she is a member.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|XFS_AT_UID
op_or
id|XFS_AT_GID
op_or
id|XFS_AT_PROJID
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * CAP_FSETID overrides the following restrictions:&n;&t;&t; *&n;&t;&t; * The set-user-ID and set-group-ID bits of a file will be&n;&t;&t; * cleared upon successful return from chown()&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FSETID
)paren
)paren
(brace
id|ip-&gt;i_d.di_mode
op_and_assign
op_complement
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Change the ownerships and register quota modifications&n;&t;&t; * in the transaction.&n;&t;&t; */
r_if
c_cond
(paren
id|iuid
op_ne
id|uid
)paren
(brace
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|mask
op_amp
id|XFS_AT_UID
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|udqp
)paren
suffix:semicolon
id|olddquot1
op_assign
id|XFS_QM_DQVOPCHOWN
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
op_amp
id|ip-&gt;i_udquot
comma
id|udqp
)paren
suffix:semicolon
)brace
id|ip-&gt;i_d.di_uid
op_assign
id|uid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|igid
op_ne
id|gid
)paren
(brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|mask
op_amp
id|XFS_AT_GID
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|olddquot2
op_assign
id|XFS_QM_DQVOPCHOWN
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
op_amp
id|ip-&gt;i_gdquot
comma
id|gdqp
)paren
suffix:semicolon
)brace
id|ip-&gt;i_d.di_gid
op_assign
id|gid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iprojid
op_ne
id|projid
)paren
(brace
id|ip-&gt;i_d.di_projid
op_assign
id|projid
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We may have to rev the inode as well as&n;&t;&t;&t; * the superblock version number since projids didn&squot;t&n;&t;&t;&t; * exist before DINODE_VERSION_2 and SB_VERSION_NLINK.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
id|xfs_bump_ino_vers2
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
id|xfs_trans_log_inode
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|timeflags
op_or_assign
id|XFS_ICHGTIME_CHG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Change file access or modified times.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|XFS_AT_ATIME
op_or
id|XFS_AT_MTIME
)paren
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_ATIME
)paren
(brace
id|ip-&gt;i_d.di_atime.t_sec
op_assign
id|vap-&gt;va_atime.tv_sec
suffix:semicolon
id|ip-&gt;i_d.di_atime.t_nsec
op_assign
id|vap-&gt;va_atime.tv_nsec
suffix:semicolon
id|ip-&gt;i_update_core
op_assign
l_int|1
suffix:semicolon
id|timeflags
op_and_assign
op_complement
id|XFS_ICHGTIME_ACC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_MTIME
)paren
(brace
id|ip-&gt;i_d.di_mtime.t_sec
op_assign
id|vap-&gt;va_mtime.tv_sec
suffix:semicolon
id|ip-&gt;i_d.di_mtime.t_nsec
op_assign
id|vap-&gt;va_mtime.tv_nsec
suffix:semicolon
id|timeflags
op_and_assign
op_complement
id|XFS_ICHGTIME_MOD
suffix:semicolon
id|timeflags
op_or_assign
id|XFS_ICHGTIME_CHG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp
op_logical_and
(paren
id|flags
op_amp
id|ATTR_UTIME
)paren
)paren
id|xfs_trans_log_inode
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Change XFS-added attributes.&n;&t; */
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|XFS_AT_EXTSIZE
op_or
id|XFS_AT_XFLAGS
)paren
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_EXTSIZE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Converting bytes to fs blocks.&n;&t;&t;&t; */
id|ip-&gt;i_d.di_extsize
op_assign
id|vap-&gt;va_extsize
op_rshift
id|mp-&gt;m_sb.sb_blocklog
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
op_amp
id|XFS_AT_XFLAGS
)paren
(brace
id|uint
id|di_flags
suffix:semicolon
multiline_comment|/* can&squot;t set PREALLOC this way, just preserve it */
id|di_flags
op_assign
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_PREALLOC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_IMMUTABLE
)paren
id|di_flags
op_or_assign
id|XFS_DIFLAG_IMMUTABLE
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_APPEND
)paren
id|di_flags
op_or_assign
id|XFS_DIFLAG_APPEND
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_SYNC
)paren
id|di_flags
op_or_assign
id|XFS_DIFLAG_SYNC
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_NOATIME
)paren
id|di_flags
op_or_assign
id|XFS_DIFLAG_NOATIME
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_NODUMP
)paren
id|di_flags
op_or_assign
id|XFS_DIFLAG_NODUMP
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFDIR
)paren
(brace
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_RTINHERIT
)paren
id|di_flags
op_or_assign
id|XFS_DIFLAG_RTINHERIT
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_NOSYMLINKS
)paren
id|di_flags
op_or_assign
id|XFS_DIFLAG_NOSYMLINKS
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|vap-&gt;va_xflags
op_amp
id|XFS_XFLAG_REALTIME
)paren
(brace
id|di_flags
op_or_assign
id|XFS_DIFLAG_REALTIME
suffix:semicolon
id|ip-&gt;i_iocore.io_flags
op_or_assign
id|XFS_IOCORE_RT
suffix:semicolon
)brace
r_else
(brace
id|ip-&gt;i_iocore.io_flags
op_and_assign
op_complement
id|XFS_IOCORE_RT
suffix:semicolon
)brace
)brace
id|ip-&gt;i_d.di_flags
op_assign
id|di_flags
suffix:semicolon
)brace
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|timeflags
op_or_assign
id|XFS_ICHGTIME_CHG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Change file inode change time only if XFS_AT_CTIME set&n;&t; * AND we have been called by a DMI function.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|ATTR_DMI
)paren
op_logical_and
(paren
id|mask
op_amp
id|XFS_AT_CTIME
)paren
)paren
(brace
id|ip-&gt;i_d.di_ctime.t_sec
op_assign
id|vap-&gt;va_ctime.tv_sec
suffix:semicolon
id|ip-&gt;i_d.di_ctime.t_nsec
op_assign
id|vap-&gt;va_ctime.tv_nsec
suffix:semicolon
id|ip-&gt;i_update_core
op_assign
l_int|1
suffix:semicolon
id|timeflags
op_and_assign
op_complement
id|XFS_ICHGTIME_CHG
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Send out timestamp changes that need to be set to the&n;&t; * current time.  Not done when called by a DMI function.&n;&t; */
r_if
c_cond
(paren
id|timeflags
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|ATTR_DMI
)paren
)paren
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|timeflags
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_attrchg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * transaction goes to disk before returning to the user.&n;&t; * This is slightly sub-optimal in that truncates require&n;&t; * two sync transactions instead of one for wsync filesytems.&n;&t; * One for the truncate and one for the timestamps since we&n;&t; * don&squot;t want to change the timestamps unless we&squot;re sure the&n;&t; * truncate worked.  Truncates are less than 1% of the laddis&n;&t; * mix so this probably isn&squot;t worth the trouble to optimize.&n;&t; */
id|code
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
id|code
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|commit_flags
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the (regular) file&squot;s mandatory locking mode changed, then&n;&t; * notify the vnode.  We do this under the inode lock to prevent&n;&t; * racing calls to vop_vnode_change.&n;&t; */
id|mandlock_after
op_assign
id|MANDLOCK
c_func
(paren
id|vp
comma
id|ip-&gt;i_d.di_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mandlock_before
op_ne
id|mandlock_after
)paren
(brace
id|VOP_VNODE_CHANGE
c_func
(paren
id|vp
comma
id|VCHANGE_FLAGS_ENF_LOCKING
comma
id|mandlock_after
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Release any dquot(s) the inode had kept before chown.&n;&t; */
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|olddquot1
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|olddquot2
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|code
)paren
(brace
r_return
id|code
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|ip
comma
id|DM_EVENT_ATTRIBUTE
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|ATTR_DMI
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_ATTRIBUTE
comma
id|vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|AT_DELAY_FLAG
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|abort_return
suffix:colon
id|commit_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
id|error_return
suffix:colon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|commit_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lock_flags
op_ne
l_int|0
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_return
id|code
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_access&n; * Null conversion from vnode mode bits to inode mode bits, as in efs.&n; */
id|STATIC
r_int
DECL|function|xfs_access
id|xfs_access
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|mode
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|error
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|ip
comma
id|mode
comma
id|credp
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_readlink&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_readlink
id|xfs_readlink
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|uio_t
op_star
id|uiop
comma
r_int
id|ioflags
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|count
suffix:semicolon
id|xfs_off_t
id|offset
suffix:semicolon
r_int
id|pathlen
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|nmaps
suffix:semicolon
id|xfs_bmbt_irec_t
id|mval
(braket
id|SYMLINK_MAPS
)braket
suffix:semicolon
id|xfs_daddr_t
id|d
suffix:semicolon
r_int
id|byte_cnt
suffix:semicolon
r_int
id|n
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFLNK
)paren
suffix:semicolon
id|offset
op_assign
id|uiop-&gt;uio_offset
suffix:semicolon
id|count
op_assign
id|uiop-&gt;uio_resid
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_le
l_int|0
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ioflags
op_amp
id|IO_INVIS
)paren
)paren
(brace
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_ACC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * See if the symlink is stored inline.&n;&t; */
id|pathlen
op_assign
(paren
r_int
)paren
id|ip-&gt;i_d.di_size
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
(brace
id|error
op_assign
id|uio_read
c_func
(paren
id|ip-&gt;i_df.if_u1.if_data
comma
id|pathlen
comma
id|uiop
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Symlink not inline.  Call bmap to get it in.&n;&t;&t; */
id|nmaps
op_assign
id|SYMLINK_MAPS
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|ip
comma
l_int|0
comma
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|pathlen
)paren
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|mval
comma
op_amp
id|nmaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|nmaps
suffix:semicolon
id|n
op_increment
)paren
(brace
id|d
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|mval
(braket
id|n
)braket
dot
id|br_startblock
)paren
suffix:semicolon
id|byte_cnt
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|mval
(braket
id|n
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_buf_read
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|BTOBB
c_func
(paren
id|byte_cnt
)paren
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xfs_readlink&quot;
comma
id|ip-&gt;i_mount
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pathlen
OL
id|byte_cnt
)paren
id|byte_cnt
op_assign
id|pathlen
suffix:semicolon
id|pathlen
op_sub_assign
id|byte_cnt
suffix:semicolon
id|error
op_assign
id|uio_read
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
id|byte_cnt
comma
id|uiop
)paren
suffix:semicolon
id|xfs_buf_relse
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
id|error_return
suffix:colon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_fsync&n; *&n; * This is called to sync the inode and its data out to disk.&n; * We need to hold the I/O lock while flushing the data, and&n; * the inode lock while flushing the inode.  The inode lock CANNOT&n; * be held while flushing the data, so acquire after we&squot;re done&n; * with that.&n; */
id|STATIC
r_int
DECL|function|xfs_fsync
id|xfs_fsync
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|flag
comma
id|cred_t
op_star
id|credp
comma
id|xfs_off_t
id|start
comma
id|xfs_off_t
id|stop
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|start
op_ge
l_int|0
op_logical_and
id|stop
op_ge
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We always need to make sure that the required inode state&n;&t; * is safe on disk.  The vnode might be clean but because&n;&t; * of committed transactions that haven&squot;t hit the disk yet.&n;&t; * Likewise, there could be unflushed non-transactional&n;&t; * changes to the inode core that have to go to disk.&n;&t; *&n;&t; * The following code depends on one assumption:  that&n;&t; * any transaction that changes an inode logs the core&n;&t; * because it has to change some field in the inode core&n;&t; * (typically nextents or nblocks).  That assumption&n;&t; * implies that any transactions against an inode will&n;&t; * catch any non-transactional updates.  If inode-altering&n;&t; * transactions exist that violate this assumption, the&n;&t; * code breaks.  Right now, it figures that if the involved&n;&t; * update_* field is clear and the inode is unpinned, the&n;&t; * inode is clean.  Either it&squot;s been flushed or it&squot;s been&n;&t; * committed and the commit has hit the disk unpinning the inode.&n;&t; * (Note that xfs_inode_item_format() called at commit clears&n;&t; * the update_* fields.)&n;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
multiline_comment|/* If we are flushing data then we care about update_size&n;&t; * being set, otherwise we care about update_core&n;&t; */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FSYNC_DATA
)paren
ques
c_cond
(paren
id|ip-&gt;i_update_size
op_eq
l_int|0
)paren
suffix:colon
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Timestamps/size haven&squot;t changed since last inode&n;&t;&t; * flush or inode transaction commit.  That means&n;&t;&t; * either nothing got written or a transaction&n;&t;&t; * committed which caught the updates.&t;If the&n;&t;&t; * latter happened and the transaction hasn&squot;t&n;&t;&t; * hit the disk yet, the inode will be still&n;&t;&t; * be pinned.  If it is, force the log.&n;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
)paren
(brace
id|xfs_log_force
c_func
(paren
id|ip-&gt;i_mount
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
(paren
(paren
id|flag
op_amp
id|FSYNC_WAIT
)paren
ques
c_cond
id|XFS_LOG_SYNC
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Kick off a transaction to log the inode&n;&t;&t; * core to get the updates.  Make it&n;&t;&t; * sync if FSYNC_WAIT is passed in (which&n;&t;&t; * is done by everybody but specfs).  The&n;&t;&t; * sync transaction will also force the log.&n;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|ip-&gt;i_mount
comma
id|XFS_TRANS_FSYNC_TS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_FSYNC_TS_LOG_RES
c_func
(paren
id|ip-&gt;i_mount
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note - it&squot;s possible that we might have pushed&n;&t;&t; * ourselves out of the way during trans_reserve&n;&t;&t; * which would flush the inode.&t; But there&squot;s no&n;&t;&t; * guarantee that the inode buffer has actually&n;&t;&t; * gone out yet (it&squot;s delwri).&t;Plus the buffer&n;&t;&t; * could be pinned anyway if it&squot;s part of an&n;&t;&t; * inode in another recent transaction.&t; So we&n;&t;&t; * play it safe and fire off the transaction anyway.&n;&t;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|FSYNC_WAIT
)paren
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called by xfs_inactive to free any blocks beyond eof,&n; * when the link count isn&squot;t zero.&n; */
id|STATIC
r_int
DECL|function|xfs_inactive_free_eofblocks
id|xfs_inactive_free_eofblocks
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fileoff_t
id|end_fsb
suffix:semicolon
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_filblks_t
id|map_len
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out if there are any blocks beyond the end&n;&t; * of the file.  If not, then there is nothing to do.&n;&t; */
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
id|ip-&gt;i_d.di_size
)paren
)paren
suffix:semicolon
id|last_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|map_len
op_assign
id|last_fsb
op_minus
id|end_fsb
suffix:semicolon
r_if
c_cond
(paren
id|map_len
op_le
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|nimaps
op_assign
l_int|1
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|end_fsb
comma
id|map_len
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|nimaps
op_ne
l_int|0
)paren
op_logical_and
(paren
id|imap.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Attach the dquots to the inode up front.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|ip
comma
l_int|0
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There are blocks after the end of file.&n;&t;&t; * Free them up now by truncating the file to&n;&t;&t; * its current size.&n;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_INACTIVE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do the xfs_itruncate_start() call before&n;&t;&t; * reserving any log space because&n;&t;&t; * itruncate_start will call into the buffer&n;&t;&t; * cache and we can&squot;t&n;&t;&t; * do that within a transaction.&n;&t;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_itruncate_start
c_func
(paren
id|ip
comma
id|XFS_ITRUNC_DEFINITE
comma
id|ip-&gt;i_d.di_size
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_itruncate_finish
c_func
(paren
op_amp
id|tp
comma
id|ip
comma
id|ip-&gt;i_d.di_size
comma
id|XFS_DATA_FORK
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we get an error at this point we&n;&t;&t; * simply don&squot;t bother truncating the file.&n;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a symlink that has blocks associated with it.&n; */
id|STATIC
r_int
DECL|function|xfs_inactive_symlink_rmt
id|xfs_inactive_symlink_rmt
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_trans_t
op_star
op_star
id|tpp
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|committed
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_bmbt_irec_t
id|mval
(braket
id|SYMLINK_MAPS
)braket
suffix:semicolon
r_int
id|nmaps
suffix:semicolon
id|xfs_trans_t
op_star
id|ntp
suffix:semicolon
r_int
id|size
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|tp
op_assign
op_star
id|tpp
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_size
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;re freeing a symlink that has some&n;&t; * blocks allocated to it.  Free the&n;&t; * blocks here.  We know that we&squot;ve got&n;&t; * either 1 or 2 extents and that we can&n;&t; * free them all in one bunmapi call.&n;&t; */
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nextents
OG
l_int|0
op_logical_and
id|ip-&gt;i_d.di_nextents
op_le
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
op_star
id|tpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Lock the inode, fix the size, and join it to the transaction.&n;&t; * Hold it so in the normal path, we still have it locked for&n;&t; * the second transaction.  In the error paths we need it&n;&t; * held so the cancel won&squot;t rele it, see below.&n;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|size
op_assign
(paren
r_int
)paren
id|ip-&gt;i_d.di_size
suffix:semicolon
id|ip-&gt;i_d.di_size
op_assign
l_int|0
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the block(s) so we can inval and unmap them.&n;&t; */
id|done
op_assign
l_int|0
suffix:semicolon
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
id|nmaps
op_assign
r_sizeof
(paren
id|mval
)paren
op_div
r_sizeof
(paren
id|mval
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|ip
comma
l_int|0
comma
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|size
)paren
comma
id|XFS_BMAPI_METADATA
comma
op_amp
id|first_block
comma
l_int|0
comma
id|mval
comma
op_amp
id|nmaps
comma
op_amp
id|free_list
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
multiline_comment|/*&n;&t; * Invalidate the block(s).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nmaps
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|mval
(braket
id|i
)braket
dot
id|br_startblock
)paren
comma
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mval
(braket
id|i
)braket
dot
id|br_blockcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|xfs_trans_binval
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Unmap the dead block(s) to the free_list.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bunmapi
c_func
(paren
id|tp
comma
id|ip
comma
l_int|0
comma
id|size
comma
id|XFS_BMAPI_METADATA
comma
id|nmaps
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
op_amp
id|done
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|ASSERT
c_func
(paren
id|done
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the first transaction.  This logs the EFI and the inode.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
multiline_comment|/*&n;&t; * The transaction must have been committed, since there were&n;&t; * actually extents freed by xfs_bunmapi.  See xfs_bmap_finish.&n;&t; * The new tp has the extent freeing and EFDs.&n;&t; */
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first xact was committed, so add the inode to the new one.&n;&t; * Mark it dirty so it will be logged and moved forward in the log as&n;&t; * part of every commit.&n;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get a new, empty transaction to return to our caller.&n;&t; */
id|ntp
op_assign
id|xfs_trans_dup
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the transaction containing extent freeing and EFD&squot;s.&n;&t; * If we get an error on the commit here or on the reserve below,&n;&t; * we need to unlock the inode since the new transaction doesn&squot;t&n;&t; * have the inode attached.&n;&t; */
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|tp
op_assign
id|ntp
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove the memory for extent descriptions (just bookkeeping).&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_df.if_bytes
)paren
id|xfs_idata_realloc
c_func
(paren
id|ip
comma
op_minus
id|ip-&gt;i_df.if_bytes
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_bytes
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put an itruncate log reservation in the new transaction&n;&t; * for our caller.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return with the inode locked but not joined to the transaction.&n;&t; */
op_star
id|tpp
op_assign
id|tp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error1
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|error0
suffix:colon
multiline_comment|/*&n;&t; * Have to come here with the inode locked and either&n;&t; * (held and in the transaction) or (not in the transaction).&n;&t; * If the inode isn&squot;t held then cancel would iput it, but&n;&t; * that&squot;s wrong since this is inactive and the vnode ref&n;&t; * count is 0 already.&n;&t; * Cancel won&squot;t do anything to the inode if held, but it still&n;&t; * needs to be locked until the cancel is done, if it was&n;&t; * joined to the transaction.&n;&t; */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
op_star
id|tpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_inactive_symlink_local
id|xfs_inactive_symlink_local
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_trans_t
op_star
op_star
id|tpp
)paren
(brace
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_size
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;re freeing a symlink which fit into&n;&t; * the inode.  Just free the memory used&n;&t; * to hold the old symlink.&n;&t; */
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
op_star
id|tpp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|ip-&gt;i_mount
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
op_star
id|tpp
comma
l_int|0
)paren
suffix:semicolon
op_star
id|tpp
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Zero length symlinks _can_ exist.&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_df.if_bytes
OG
l_int|0
)paren
(brace
id|xfs_idata_realloc
c_func
(paren
id|ip
comma
op_minus
(paren
id|ip-&gt;i_df.if_bytes
)paren
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_bytes
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_inactive_attrs
id|xfs_inactive_attrs
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_trans_t
op_star
op_star
id|tpp
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|tp
op_assign
op_star
id|tpp
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_forkoff
op_ne
l_int|0
)paren
suffix:semicolon
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_inactive
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
op_star
id|tpp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/* goto out*/
)brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_INACTIVE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_IFREE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_INACTIVE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
op_star
id|tpp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
id|xfs_idestroy_fork
c_func
(paren
id|ip
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
suffix:semicolon
op_star
id|tpp
op_assign
id|tp
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_release
id|xfs_release
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vp-&gt;v_type
op_ne
id|VREG
)paren
op_logical_or
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If this is a read-only mount, don&squot;t do this (would generate I/O) */
r_if
c_cond
(paren
id|vp-&gt;v_vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef HAVE_REFCACHE
multiline_comment|/* If we are in the NFS reference cache then don&squot;t do this now */
r_if
c_cond
(paren
id|ip-&gt;i_refcache
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nlink
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFREG
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_d.di_size
OG
l_int|0
)paren
op_logical_or
(paren
id|VN_CACHED
c_func
(paren
id|vp
)paren
OG
l_int|0
)paren
)paren
op_logical_and
(paren
id|ip-&gt;i_df.if_flags
op_amp
id|XFS_IFEXTENTS
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|ip-&gt;i_d.di_flags
op_amp
(paren
id|XFS_DIFLAG_PREALLOC
op_or
id|XFS_DIFLAG_APPEND
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inactive_free_eofblocks
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/* Update linux inode block count after free above */
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
op_member_access_from_pointer
id|i_blocks
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|ip-&gt;i_d.di_nblocks
op_plus
id|ip-&gt;i_delayed_blks
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_inactive&n; *&n; * This is called when the vnode reference count for the vnode&n; * goes to zero.  If the file has been unlinked, then it must&n; * now be truncated.  Also, we clear all of the read-ahead state&n; * kept for the inode here since the file is now closed.&n; */
id|STATIC
r_int
DECL|function|xfs_inactive
id|xfs_inactive
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|truncate
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the inode is already free, then there can be nothing&n;&t; * to clean up here.&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
op_logical_or
id|VN_BAD
c_func
(paren
id|vp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_real_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_broot_bytes
op_eq
l_int|0
)paren
suffix:semicolon
r_return
id|VN_INACTIVE_CACHE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Only do a truncate if it&squot;s a regular file with&n;&t; * some actual space in it.  It&squot;s OK to look at the&n;&t; * inode&squot;s fields without the lock because we&squot;re the&n;&t; * only one with a reference to the inode.&n;&t; */
id|truncate
op_assign
(paren
(paren
id|ip-&gt;i_d.di_nlink
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_d.di_size
op_ne
l_int|0
)paren
op_logical_or
(paren
id|ip-&gt;i_d.di_nextents
OG
l_int|0
)paren
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFREG
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nlink
op_eq
l_int|0
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|ip
comma
id|DM_EVENT_DESTROY
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_DESTROY
c_func
(paren
id|mp
comma
id|vp
comma
id|DM_RIGHT_NULL
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this is a read-only mount, don&squot;t do this (would generate I/O) */
r_if
c_cond
(paren
id|vp-&gt;v_vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nlink
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFREG
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_d.di_size
OG
l_int|0
)paren
op_logical_or
(paren
id|VN_CACHED
c_func
(paren
id|vp
)paren
OG
l_int|0
)paren
)paren
op_logical_and
(paren
id|ip-&gt;i_df.if_flags
op_amp
id|XFS_IFEXTENTS
)paren
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|ip-&gt;i_d.di_flags
op_amp
(paren
id|XFS_DIFLAG_PREALLOC
op_or
id|XFS_DIFLAG_APPEND
)paren
)paren
op_logical_or
(paren
id|ip-&gt;i_delayed_blks
op_ne
l_int|0
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inactive_free_eofblocks
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
)paren
r_return
(paren
id|VN_INACTIVE_CACHE
)paren
suffix:semicolon
multiline_comment|/* Update linux inode block count after free above */
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
op_member_access_from_pointer
id|i_blocks
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|ip-&gt;i_d.di_nblocks
op_plus
id|ip-&gt;i_delayed_blks
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|ip
comma
l_int|0
)paren
)paren
)paren
r_return
(paren
id|VN_INACTIVE_CACHE
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_INACTIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|truncate
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do the xfs_itruncate_start() call before&n;&t;&t; * reserving any log space because itruncate_start&n;&t;&t; * will call into the buffer cache and we can&squot;t&n;&t;&t; * do that within a transaction.&n;&t;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_itruncate_start
c_func
(paren
id|ip
comma
id|XFS_ITRUNC_DEFINITE
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* Don&squot;t call itruncate_cleanup */
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|VN_INACTIVE_CACHE
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * normally, we have to run xfs_itruncate_finish sync.&n;&t;&t; * But if filesystem is wsync and we&squot;re in the inactive&n;&t;&t; * path, then we know that nlink == 0, and that the&n;&t;&t; * xaction that made nlink == 0 is permanently committed&n;&t;&t; * since xfs_remove runs as a synchronous transaction.&n;&t;&t; */
id|error
op_assign
id|xfs_itruncate_finish
c_func
(paren
op_amp
id|tp
comma
id|ip
comma
l_int|0
comma
id|XFS_DATA_FORK
comma
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|VN_INACTIVE_CACHE
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFLNK
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we get an error while cleaning up a&n;&t;&t; * symlink we bail out.&n;&t;&t; */
id|error
op_assign
(paren
id|ip-&gt;i_d.di_size
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
)paren
ques
c_cond
id|xfs_inactive_symlink_rmt
c_func
(paren
id|ip
comma
op_amp
id|tp
)paren
suffix:colon
id|xfs_inactive_symlink_local
c_func
(paren
id|ip
comma
op_amp
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|tp
op_eq
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|VN_INACTIVE_CACHE
)paren
suffix:semicolon
)brace
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_IFREE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_INACTIVE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|VN_INACTIVE_CACHE
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are attributes associated with the file&n;&t; * then blow them away now.  The code calls a routine&n;&t; * that recursively deconstructs the attribute fork.&n;&t; * We need to just commit the current transaction&n;&t; * because we can&squot;t use it for xfs_attr_inactive().&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_anextents
OG
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_inactive_attrs
c_func
(paren
id|ip
comma
op_amp
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we got an error, the transaction is already&n;&t;&t; * cancelled, and the inode is unlocked. Just get out.&n;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|VN_INACTIVE_CACHE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ip-&gt;i_afp
)paren
(brace
id|xfs_idestroy_fork
c_func
(paren
id|ip
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Free the inode.&n;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
id|error
op_assign
id|xfs_ifree
c_func
(paren
id|tp
comma
id|ip
comma
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we fail to free the inode, shut down.  The cancel&n;&t;&t; * might do that, we need to make sure.  Otherwise the&n;&t;&t; * inode might be lost for a long time or forever.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;xfs_inactive:&t;xfs_ifree() returned an error = %d on %s&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_METADATA_IO_ERROR
)paren
suffix:semicolon
)brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Credit the quota account(s). The inode is gone.&n;&t;&t; */
id|XFS_TRANS_MOD_DQUOT_BYINO
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|XFS_TRANS_DQ_ICOUNT
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Just ignore errors at this point.  There is&n;&t;&t; * nothing we can do except to try to keep going.&n;&t;&t; */
(paren
r_void
)paren
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release the dquots held by inode, if any.&n;&t; */
id|XFS_QM_DQDETACH
c_func
(paren
id|mp
comma
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|VN_INACTIVE_CACHE
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_lookup&n; */
id|STATIC
r_int
DECL|function|xfs_lookup
id|xfs_lookup
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|vname_t
op_star
id|dentry
comma
id|vnode_t
op_star
op_star
id|vpp
comma
r_int
id|flags
comma
id|vnode_t
op_star
id|rdir
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|dp
comma
op_star
id|ip
suffix:semicolon
id|xfs_ino_t
id|e_inum
suffix:semicolon
r_int
id|error
suffix:semicolon
id|uint
id|lock_mode
suffix:semicolon
id|vnode_t
op_star
id|dir_vp
suffix:semicolon
id|dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|lock_mode
op_assign
id|xfs_ilock_map_shared
c_func
(paren
id|dp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_dir_lookup_int
c_func
(paren
id|dir_bdp
comma
id|lock_mode
comma
id|dentry
comma
op_amp
id|e_inum
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
op_star
id|vpp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
id|ITRACE
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
id|xfs_iunlock_map_shared
c_func
(paren
id|dp
comma
id|lock_mode
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_create (create a new file).&n; */
id|STATIC
r_int
DECL|function|xfs_create
id|xfs_create
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|vname_t
op_star
id|dentry
comma
id|vattr_t
op_star
id|vap
comma
id|vnode_t
op_star
op_star
id|vpp
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_char
op_star
id|name
op_assign
id|VNAME
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|vnode_t
op_star
id|dir_vp
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
comma
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_dev_t
id|rdev
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
id|boolean_t
id|dp_joined_to_trans
suffix:semicolon
r_int
id|dm_event_sent
op_assign
l_int|0
suffix:semicolon
id|uint
id|cancel_flags
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|xfs_prid_t
id|prid
suffix:semicolon
r_struct
id|xfs_dquot
op_star
id|udqp
comma
op_star
id|gdqp
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_int
id|dm_di_mode
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
op_star
id|vpp
)paren
suffix:semicolon
id|dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|dm_di_mode
op_assign
id|vap-&gt;va_mode
op_or
id|VTTOIF
c_func
(paren
id|vap-&gt;va_type
)paren
suffix:semicolon
id|namelen
op_assign
id|VNAMELEN
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|dp
comma
id|DM_EVENT_CREATE
)paren
)paren
(brace
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_CREATE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|name
comma
l_int|NULL
comma
id|dm_di_mode
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dm_event_sent
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/* Return through std_return after this point. */
id|udqp
op_assign
id|gdqp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_mask
op_amp
id|XFS_AT_PROJID
)paren
id|prid
op_assign
(paren
id|xfs_prid_t
)paren
id|vap-&gt;va_projid
suffix:semicolon
r_else
id|prid
op_assign
(paren
id|xfs_prid_t
)paren
id|dfltprid
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that we have allocated dquot(s) on disk.&n;&t; */
id|error
op_assign
id|XFS_QM_DQVOPALLOC
c_func
(paren
id|mp
comma
id|dp
comma
id|current_fsuid
c_func
(paren
id|credp
)paren
comma
id|current_fsgid
c_func
(paren
id|credp
)paren
comma
id|XFS_QMOPT_QUOTALL
op_or
id|XFS_QMOPT_INHERIT
comma
op_amp
id|udqp
comma
op_amp
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|std_return
suffix:semicolon
id|ip
op_assign
l_int|NULL
suffix:semicolon
id|dp_joined_to_trans
op_assign
id|B_FALSE
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_CREATE
)paren
suffix:semicolon
id|cancel_flags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
id|resblks
op_assign
id|XFS_CREATE_SPACE_RES
c_func
(paren
id|mp
comma
id|namelen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initially assume that the file does not exist and&n;&t; * reserve the resources for that case.  If that is not&n;&t; * the case we&squot;ll drop the one we have and get a more&n;&t; * appropriate transaction later.&n;&t; */
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_CREATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_CREATE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
id|resblks
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_CREATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_CREATE_LOG_COUNT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|cancel_flags
op_assign
l_int|0
suffix:semicolon
id|dp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reserve disk quota and the inode.&n;&t; */
id|error
op_assign
id|XFS_TRANS_RESERVE_QUOTA
c_func
(paren
id|mp
comma
id|tp
comma
id|udqp
comma
id|gdqp
comma
id|resblks
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error_return
suffix:semicolon
r_if
c_cond
(paren
id|resblks
op_eq
l_int|0
op_logical_and
(paren
id|error
op_assign
id|XFS_DIR_CANENTER
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|name
comma
id|namelen
)paren
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|rdev
op_assign
(paren
id|vap-&gt;va_mask
op_amp
id|XFS_AT_RDEV
)paren
ques
c_cond
id|vap-&gt;va_rdev
suffix:colon
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_dir_ialloc
c_func
(paren
op_amp
id|tp
comma
id|dp
comma
id|MAKEIMODE
c_func
(paren
id|vap-&gt;va_type
comma
id|vap-&gt;va_mode
)paren
comma
l_int|1
comma
id|rdev
comma
id|credp
comma
id|prid
comma
id|resblks
OG
l_int|0
comma
op_amp
id|ip
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
r_goto
id|error_return
suffix:semicolon
r_goto
id|abort_return
suffix:semicolon
)brace
id|ITRACE
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we&squot;ve gotten a newly allocated inode.&n;&t; * It is locked (and joined to the transaction).&n;&t; */
id|ASSERT
c_func
(paren
id|ismrlocked
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now we join the directory inode to the transaction.&n;&t; * We do not do it earlier because xfs_dir_ialloc&n;&t; * might commit the previous transaction (and release&n;&t; * all the locks).&n;&t; */
id|VN_HOLD
c_func
(paren
id|dir_vp
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|dp_joined_to_trans
op_assign
id|B_TRUE
suffix:semicolon
id|error
op_assign
id|XFS_DIR_CREATENAME
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|name
comma
id|namelen
comma
id|ip-&gt;i_ino
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
id|resblks
ques
c_cond
id|resblks
op_minus
id|XFS_IALLOC_SPACE_RES
c_func
(paren
id|mp
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|abort_return
suffix:semicolon
)brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * create transaction goes to disk before returning to&n;&t; * the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|dp-&gt;i_gen
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the dquot(s) to the inodes and modify them incore.&n;&t; * These ids of the inode couldn&squot;t have changed since the new&n;&t; * inode has been locked ever since it was created.&n;&t; */
id|XFS_QM_DQVOPCREATE
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|udqp
comma
id|gdqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * xfs_trans_commit normally decrements the vnode ref count&n;&t; * when it unlocks the inode. Since we want to return the&n;&t; * vnode to the caller, we bump the vnode ref count now.&n;&t; */
id|IHOLD
c_func
(paren
id|ip
)paren
suffix:semicolon
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
r_goto
id|abort_rele
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
id|tp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Propogate the fact that the vnode changed after the&n;&t; * xfs_inode locks have been released.&n;&t; */
id|VOP_VNODE_CHANGE
c_func
(paren
id|vp
comma
id|VCHANGE_FLAGS_TRUNCATED
comma
l_int|3
)paren
suffix:semicolon
op_star
id|vpp
op_assign
id|vp
suffix:semicolon
multiline_comment|/* Fallthrough to std_return with error = 0  */
id|std_return
suffix:colon
r_if
c_cond
(paren
(paren
op_star
id|vpp
op_logical_or
(paren
id|error
op_ne
l_int|0
op_logical_and
id|dm_event_sent
op_ne
l_int|0
)paren
)paren
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
comma
id|DM_EVENT_POSTCREATE
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_POSTCREATE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
op_star
id|vpp
ques
c_cond
id|vp
suffix:colon
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|name
comma
l_int|NULL
comma
id|dm_di_mode
comma
id|error
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|abort_return
suffix:colon
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
id|error_return
suffix:colon
r_if
c_cond
(paren
id|tp
op_ne
l_int|NULL
)paren
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dp_joined_to_trans
op_logical_and
(paren
id|dp
op_ne
l_int|NULL
)paren
)paren
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
id|abort_rele
suffix:colon
multiline_comment|/*&n;&t; * Wait until after the current transaction is aborted to&n;&t; * release the inode.  This prevents recursive transactions&n;&t; * and deadlocks from xfs_inactive.&n;&t; */
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Some counters to see if (and how often) we are hitting some deadlock&n; * prevention code paths.&n; */
DECL|variable|xfs_rm_locks
r_int
id|xfs_rm_locks
suffix:semicolon
DECL|variable|xfs_rm_lock_delays
r_int
id|xfs_rm_lock_delays
suffix:semicolon
DECL|variable|xfs_rm_attempts
r_int
id|xfs_rm_attempts
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * The following routine will lock the inodes associated with the&n; * directory and the named entry in the directory. The locks are&n; * acquired in increasing inode number.&n; *&n; * If the entry is &quot;..&quot;, then only the directory is locked. The&n; * vnode ref count will still include that from the .. entry in&n; * this case.&n; *&n; * There is a deadlock we need to worry about. If the locked directory is&n; * in the AIL, it might be blocking up the log. The next inode we lock&n; * could be already locked by another thread waiting for log space (e.g&n; * a permanent log reservation with a long running transaction (see&n; * xfs_itruncate_finish)). To solve this, we must check if the directory&n; * is in the ail and use lock_nowait. If we can&squot;t lock, we need to&n; * drop the inode lock on the directory and try again. xfs_iunlock will&n; * potentially push the tail if we were holding up the log.&n; */
id|STATIC
r_int
DECL|function|xfs_lock_dir_and_entry
id|xfs_lock_dir_and_entry
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
id|vname_t
op_star
id|dentry
comma
id|xfs_inode_t
op_star
id|ip
)paren
multiline_comment|/* inode of entry &squot;name&squot; */
(brace
r_int
id|attempts
suffix:semicolon
id|xfs_ino_t
id|e_inum
suffix:semicolon
id|xfs_inode_t
op_star
id|ips
(braket
l_int|2
)braket
suffix:semicolon
id|xfs_log_item_t
op_star
id|lp
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_rm_locks
op_increment
suffix:semicolon
macro_line|#endif
id|attempts
op_assign
l_int|0
suffix:semicolon
id|again
suffix:colon
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|e_inum
op_assign
id|ip-&gt;i_ino
suffix:semicolon
id|ITRACE
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We want to lock in increasing inum. Since we&squot;ve already&n;&t; * acquired the lock on the directory, we may need to release&n;&t; * if if the inum of the entry turns out to be less.&n;&t; */
r_if
c_cond
(paren
id|e_inum
OG
id|dp-&gt;i_ino
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are already in the right order, so just&n;&t;&t; * lock on the inode of the entry.&n;&t;&t; * We need to use nowait if dp is in the AIL.&n;&t;&t; */
id|lp
op_assign
(paren
id|xfs_log_item_t
op_star
)paren
id|dp-&gt;i_itemp
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_logical_and
(paren
id|lp-&gt;li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
)paren
(brace
id|attempts
op_increment
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_rm_attempts
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t;&t; * Unlock dp and try again.&n;&t;&t;&t;&t; * xfs_iunlock will try to push the tail&n;&t;&t;&t;&t; * if the inode is in the AIL.&n;&t;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|attempts
op_mod
l_int|5
)paren
op_eq
l_int|0
)paren
(brace
id|delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t just spin the CPU */
macro_line|#ifdef DEBUG
id|xfs_rm_lock_delays
op_increment
suffix:semicolon
macro_line|#endif
)brace
r_goto
id|again
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|e_inum
OL
id|dp-&gt;i_ino
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|ips
(braket
l_int|0
)braket
op_assign
id|ip
suffix:semicolon
id|ips
(braket
l_int|1
)braket
op_assign
id|dp
suffix:semicolon
id|xfs_lock_inodes
c_func
(paren
id|ips
comma
l_int|2
comma
l_int|0
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
multiline_comment|/* else&t; e_inum == dp-&gt;i_ino */
multiline_comment|/*     This can happen if we&squot;re asked to lock /x/..&n;&t; *     the entry is &quot;..&quot;, which is also the parent directory.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
DECL|variable|xfs_locked_n
r_int
id|xfs_locked_n
suffix:semicolon
DECL|variable|xfs_small_retries
r_int
id|xfs_small_retries
suffix:semicolon
DECL|variable|xfs_middle_retries
r_int
id|xfs_middle_retries
suffix:semicolon
DECL|variable|xfs_lots_retries
r_int
id|xfs_lots_retries
suffix:semicolon
DECL|variable|xfs_lock_delays
r_int
id|xfs_lock_delays
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * The following routine will lock n inodes in exclusive mode.&n; * We assume the caller calls us with the inodes in i_ino order.&n; *&n; * We need to detect deadlock where an inode that we lock&n; * is in the AIL and we start waiting for another inode that is locked&n; * by a thread in a long running transaction (such as truncate). This can&n; * result in deadlock since the long running trans might need to wait&n; * for the inode we just locked in order to push the tail and free space&n; * in the log.&n; */
r_void
DECL|function|xfs_lock_inodes
id|xfs_lock_inodes
c_func
(paren
id|xfs_inode_t
op_star
op_star
id|ips
comma
r_int
id|inodes
comma
r_int
id|first_locked
comma
id|uint
id|lock_mode
)paren
(brace
r_int
id|attempts
op_assign
l_int|0
comma
id|i
comma
id|j
comma
id|try_lock
suffix:semicolon
id|xfs_log_item_t
op_star
id|lp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ips
op_logical_and
(paren
id|inodes
op_ge
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/* we need at least two */
r_if
c_cond
(paren
id|first_locked
)paren
(brace
id|try_lock
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|try_lock
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
id|again
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|inodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|ips
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
id|ips
(braket
id|i
)braket
op_eq
id|ips
(braket
id|i
op_minus
l_int|1
)braket
)paren
)paren
multiline_comment|/* Already locked */
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If try_lock is not set yet, make sure all locked inodes&n;&t;&t; * are not in the AIL.&n;&t;&t; * If any are, set try_lock to be used later.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|try_lock
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
(paren
id|i
op_minus
l_int|1
)paren
suffix:semicolon
id|j
op_ge
l_int|0
op_logical_and
op_logical_neg
id|try_lock
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|lp
op_assign
(paren
id|xfs_log_item_t
op_star
)paren
id|ips
(braket
id|j
)braket
op_member_access_from_pointer
id|i_itemp
suffix:semicolon
r_if
c_cond
(paren
id|lp
op_logical_and
(paren
id|lp-&gt;li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
)paren
(brace
id|try_lock
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * If any of the previous locks we have locked is in the AIL,&n;&t;&t; * we must TRY to get the second and subsequent locks. If&n;&t;&t; * we can&squot;t get any, we must release all we have&n;&t;&t; * and try again.&n;&t;&t; */
r_if
c_cond
(paren
id|try_lock
)paren
(brace
multiline_comment|/* try_lock must be 0 if i is 0. */
multiline_comment|/*&n;&t;&t;&t; * try_lock means we have an inode locked&n;&t;&t;&t; * that is in the AIL.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|i
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_ilock_nowait
c_func
(paren
id|ips
(braket
id|i
)braket
comma
id|lock_mode
)paren
)paren
(brace
id|attempts
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Unlock all previous guys and try again.&n;&t;&t;&t;&t; * xfs_iunlock will try to push the tail&n;&t;&t;&t;&t; * if the inode is in the AIL.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
id|i
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Check to see if we&squot;ve already&n;&t;&t;&t;&t;&t; * unlocked this one.&n;&t;&t;&t;&t;&t; * Not the first one going back,&n;&t;&t;&t;&t;&t; * and the inode ptr is the same.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|j
op_ne
(paren
id|i
op_minus
l_int|1
)paren
)paren
op_logical_and
id|ips
(braket
id|j
)braket
op_eq
id|ips
(braket
id|j
op_plus
l_int|1
)braket
)paren
r_continue
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ips
(braket
id|j
)braket
comma
id|lock_mode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|attempts
op_mod
l_int|5
)paren
op_eq
l_int|0
)paren
(brace
id|delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t just spin the CPU */
macro_line|#ifdef DEBUG
id|xfs_lock_delays
op_increment
suffix:semicolon
macro_line|#endif
)brace
id|i
op_assign
l_int|0
suffix:semicolon
id|try_lock
op_assign
l_int|0
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_ilock
c_func
(paren
id|ips
(braket
id|i
)braket
comma
id|lock_mode
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|attempts
)paren
(brace
r_if
c_cond
(paren
id|attempts
OL
l_int|5
)paren
id|xfs_small_retries
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|attempts
OL
l_int|100
)paren
id|xfs_middle_retries
op_increment
suffix:semicolon
r_else
id|xfs_lots_retries
op_increment
suffix:semicolon
)brace
r_else
(brace
id|xfs_locked_n
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#ifdef&t;DEBUG
DECL|macro|REMOVE_DEBUG_TRACE
mdefine_line|#define&t;REMOVE_DEBUG_TRACE(x)&t;{remove_which_error_return = (x);}
DECL|variable|remove_which_error_return
r_int
id|remove_which_error_return
op_assign
l_int|0
suffix:semicolon
macro_line|#else /* ! DEBUG */
DECL|macro|REMOVE_DEBUG_TRACE
mdefine_line|#define&t;REMOVE_DEBUG_TRACE(x)
macro_line|#endif&t;/* ! DEBUG */
multiline_comment|/*&n; * xfs_remove&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_remove
id|xfs_remove
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|vname_t
op_star
id|dentry
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|vnode_t
op_star
id|dir_vp
suffix:semicolon
r_char
op_star
id|name
op_assign
id|VNAME
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
comma
op_star
id|ip
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
r_int
id|cancel_flags
suffix:semicolon
r_int
id|committed
suffix:semicolon
r_int
id|dm_di_mode
op_assign
l_int|0
suffix:semicolon
r_int
id|link_zero
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|namelen
op_assign
id|VNAMELEN
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|dp
comma
id|DM_EVENT_REMOVE
)paren
)paren
(brace
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_REMOVE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|name
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* From this point on, return through std_return */
id|ip
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * We need to get a reference to ip before we get our log&n;&t; * reservation. The reason for this is that we cannot call&n;&t; * xfs_iget for an inode for which we do not have a reference&n;&t; * once we&squot;ve acquired a log reservation. This is because the&n;&t; * inode we are trying to get might be in xfs_inactive going&n;&t; * for a log reservation. Since we&squot;ll have to wait for the&n;&t; * inactive code to complete before returning from xfs_iget,&n;&t; * we need to make sure that we don&squot;t have log space reserved&n;&t; * when we call xfs_iget.  Instead we get an unlocked referece&n;&t; * to the inode before getting our log reservation.&n;&t; */
id|error
op_assign
id|xfs_get_dir_entry
c_func
(paren
id|dentry
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
id|dm_di_mode
op_assign
id|ip-&gt;i_d.di_mode
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ITRACE
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|dp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|dp
op_ne
id|ip
)paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_REMOVE
)paren
suffix:semicolon
id|cancel_flags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
multiline_comment|/*&n;&t; * We try to get the real space reservation first,&n;&t; * allowing for directory btree deletion(s) implying&n;&t; * possible bmap insert(s).  If we can&squot;t get the space&n;&t; * reservation then we use 0 instead, and avoid the bmap&n;&t; * btree insert(s) in the directory code by, if the bmap&n;&t; * insert tries to happen, instead trimming the LAST&n;&t; * block from the directory.&n;&t; */
id|resblks
op_assign
id|XFS_REMOVE_SPACE_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_REMOVE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_REMOVE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
id|resblks
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_REMOVE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_REMOVE_LOG_COUNT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
id|xfs_lock_dir_and_entry
c_func
(paren
id|dp
comma
id|dentry
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * At this point, we&squot;ve gotten both the directory and the entry&n;&t; * inodes locked.&n;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dp
op_ne
id|ip
)paren
(brace
multiline_comment|/*&n;&t;&t; * Increment vnode ref count only in this case since&n;&t;&t; * there&squot;s an extra vnode reference in the case where&n;&t;&t; * dp == ip.&n;&t;&t; */
id|IHOLD
c_func
(paren
id|dp
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Entry must exist since we did a lookup in xfs_lock_dir_and_entry.&n;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
id|error
op_assign
id|XFS_DIR_REMOVENAME
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|name
comma
id|namelen
comma
id|ip-&gt;i_ino
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOENT
)paren
suffix:semicolon
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|dp-&gt;i_gen
op_increment
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_droplink
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
multiline_comment|/* Determine if this is the last link while&n;&t; * we are in the transaction.&n;&t; */
id|link_zero
op_assign
(paren
id|ip
)paren
op_member_access_from_pointer
id|i_d.di_nlink
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Take an extra ref on the inode so that it doesn&squot;t&n;&t; * go to xfs_inactive() from within the commit.&n;&t; */
id|IHOLD
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * remove transaction goes to disk before returning to&n;&t; * the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
r_goto
id|error_rele
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Before we drop our extra reference to the inode, purge it&n;&t; * from the refcache if it is there.  By waiting until afterwards&n;&t; * to do the IRELE, we ensure that we won&squot;t go inactive in the&n;&t; * xfs_refcache_purge_ip routine (although that would be OK).&n;&t; */
id|xfs_refcache_purge_ip
c_func
(paren
id|ip
)paren
suffix:semicolon
id|vn_trace_exit
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let interposed file systems know about removed links.&n;&t; */
id|VOP_LINK_REMOVED
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|dir_vp
comma
id|link_zero
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&t;Fall through to std_return with error = 0 */
id|std_return
suffix:colon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|dp
comma
id|DM_EVENT_POSTREMOVE
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_POSTREMOVE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|name
comma
l_int|NULL
comma
id|dm_di_mode
comma
id|error
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|error1
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
id|error_rele
suffix:colon
multiline_comment|/*&n;&t; * In this case make sure to not release the inode until after&n;&t; * the current transaction is aborted.  Releasing it beforehand&n;&t; * can cause us to go to xfs_inactive and start a recursive&n;&t; * transaction which can easily deadlock with the current one.&n;&t; */
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Before we drop our extra reference to the inode, purge it&n;&t; * from the refcache if it is there.  By waiting until afterwards&n;&t; * to do the IRELE, we ensure that we won&squot;t go inactive in the&n;&t; * xfs_refcache_purge_ip routine (although that would be OK).&n;&t; */
id|xfs_refcache_purge_ip
c_func
(paren
id|ip
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_link&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_link
id|xfs_link
c_func
(paren
id|bhv_desc_t
op_star
id|target_dir_bdp
comma
id|vnode_t
op_star
id|src_vp
comma
id|vname_t
op_star
id|dentry
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|tdp
comma
op_star
id|sip
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_inode_t
op_star
id|ips
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
r_int
id|cancel_flags
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|vnode_t
op_star
id|target_dir_vp
suffix:semicolon
id|bhv_desc_t
op_star
id|src_bdp
suffix:semicolon
r_int
id|resblks
suffix:semicolon
r_char
op_star
id|target_name
op_assign
id|VNAME
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_int
id|target_namelen
suffix:semicolon
id|target_dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|target_dir_bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|target_dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|src_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|target_namelen
op_assign
id|VNAMELEN
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|src_vp-&gt;v_type
op_eq
id|VDIR
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * For now, manually find the XFS behavior descriptor for&n;&t; * the source vnode.  If it doesn&squot;t exist then something&n;&t; * is wrong and we should just return an error.&n;&t; * Eventually we need to figure out how link is going to&n;&t; * work in the face of stacked vnodes.&n;&t; */
id|src_bdp
op_assign
id|vn_bhv_lookup_unlocked
c_func
(paren
id|VN_BHV_HEAD
c_func
(paren
id|src_vp
)paren
comma
op_amp
id|xfs_vnodeops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|src_bdp
op_eq
l_int|NULL
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|EXDEV
)paren
suffix:semicolon
)brace
id|sip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|src_bdp
)paren
suffix:semicolon
id|tdp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|target_dir_bdp
)paren
suffix:semicolon
id|mp
op_assign
id|tdp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|src_vp-&gt;v_vfsp
comma
id|tdp
comma
id|DM_EVENT_LINK
)paren
)paren
(brace
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_LINK
comma
id|target_dir_vp
comma
id|DM_RIGHT_NULL
comma
id|src_vp
comma
id|DM_RIGHT_NULL
comma
id|target_name
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Return through std_return after this point. */
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|sip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|sip
op_ne
id|tdp
)paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|tdp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|std_return
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_LINK
)paren
suffix:semicolon
id|cancel_flags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
id|resblks
op_assign
id|XFS_LINK_SPACE_RES
c_func
(paren
id|mp
comma
id|target_namelen
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_LINK_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_LINK_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
id|resblks
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_LINK_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_LINK_LOG_COUNT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|cancel_flags
op_assign
l_int|0
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sip-&gt;i_ino
OL
id|tdp-&gt;i_ino
)paren
(brace
id|ips
(braket
l_int|0
)braket
op_assign
id|sip
suffix:semicolon
id|ips
(braket
l_int|1
)braket
op_assign
id|tdp
suffix:semicolon
)brace
r_else
(brace
id|ips
(braket
l_int|0
)braket
op_assign
id|tdp
suffix:semicolon
id|ips
(braket
l_int|1
)braket
op_assign
id|sip
suffix:semicolon
)brace
id|xfs_lock_inodes
c_func
(paren
id|ips
comma
l_int|2
comma
l_int|0
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Increment vnode ref counts since xfs_trans_commit &amp;&n;&t; * xfs_trans_cancel will both unlock the inodes and&n;&t; * decrement the associated ref counts.&n;&t; */
id|VN_HOLD
c_func
(paren
id|src_vp
)paren
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|target_dir_vp
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|sip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|tdp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the source has too many links, we can&squot;t make any more to it.&n;&t; */
r_if
c_cond
(paren
id|sip-&gt;i_d.di_nlink
op_ge
id|XFS_MAXLINK
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EMLINK
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|resblks
op_eq
l_int|0
op_logical_and
(paren
id|error
op_assign
id|XFS_DIR_CANENTER
c_func
(paren
id|mp
comma
id|tp
comma
id|tdp
comma
id|target_name
comma
id|target_namelen
)paren
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
id|error
op_assign
id|XFS_DIR_CREATENAME
c_func
(paren
id|mp
comma
id|tp
comma
id|tdp
comma
id|target_name
comma
id|target_namelen
comma
id|sip-&gt;i_ino
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
id|resblks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|abort_return
suffix:semicolon
id|xfs_ichgtime
c_func
(paren
id|tdp
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|tdp-&gt;i_gen
op_increment
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|tdp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bumplink
c_func
(paren
id|tp
comma
id|sip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|abort_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * link transaction goes to disk before returning to&n;&t; * the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|error
op_assign
id|xfs_bmap_finish
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
r_goto
id|abort_return
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/* Fall through to std_return with error = 0. */
id|std_return
suffix:colon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|src_vp-&gt;v_vfsp
comma
id|sip
comma
id|DM_EVENT_POSTLINK
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_POSTLINK
comma
id|target_dir_vp
comma
id|DM_RIGHT_NULL
comma
id|src_vp
comma
id|DM_RIGHT_NULL
comma
id|target_name
comma
l_int|NULL
comma
l_int|0
comma
id|error
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|abort_return
suffix:colon
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
id|error_return
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mkdir&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_mkdir
id|xfs_mkdir
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|vname_t
op_star
id|dentry
comma
id|vattr_t
op_star
id|vap
comma
id|vnode_t
op_star
op_star
id|vpp
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_char
op_star
id|dir_name
op_assign
id|VNAME
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_inode_t
op_star
id|cdp
suffix:semicolon
multiline_comment|/* inode of created dir */
id|vnode_t
op_star
id|cvp
suffix:semicolon
multiline_comment|/* vnode of created dir */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|cancel_flags
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
id|vnode_t
op_star
id|dir_vp
suffix:semicolon
id|boolean_t
id|dp_joined_to_trans
suffix:semicolon
id|boolean_t
id|created
op_assign
id|B_FALSE
suffix:semicolon
r_int
id|dm_event_sent
op_assign
l_int|0
suffix:semicolon
id|xfs_prid_t
id|prid
suffix:semicolon
r_struct
id|xfs_dquot
op_star
id|udqp
comma
op_star
id|gdqp
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_int
id|dm_di_mode
suffix:semicolon
r_int
id|dir_namelen
suffix:semicolon
id|dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|dir_namelen
op_assign
id|VNAMELEN
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|dp_joined_to_trans
op_assign
id|B_FALSE
suffix:semicolon
id|dm_di_mode
op_assign
id|vap-&gt;va_mode
op_or
id|VTTOIF
c_func
(paren
id|vap-&gt;va_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|dp
comma
id|DM_EVENT_CREATE
)paren
)paren
(brace
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_CREATE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|dir_name
comma
l_int|NULL
comma
id|dm_di_mode
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dm_event_sent
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Return through std_return after this point. */
id|vn_trace_entry
c_func
(paren
id|dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|udqp
op_assign
id|gdqp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_mask
op_amp
id|XFS_AT_PROJID
)paren
id|prid
op_assign
(paren
id|xfs_prid_t
)paren
id|vap-&gt;va_projid
suffix:semicolon
r_else
id|prid
op_assign
(paren
id|xfs_prid_t
)paren
id|dfltprid
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that we have allocated dquot(s) on disk.&n;&t; */
id|error
op_assign
id|XFS_QM_DQVOPALLOC
c_func
(paren
id|mp
comma
id|dp
comma
id|current_fsuid
c_func
(paren
id|credp
)paren
comma
id|current_fsgid
c_func
(paren
id|credp
)paren
comma
id|XFS_QMOPT_QUOTALL
op_or
id|XFS_QMOPT_INHERIT
comma
op_amp
id|udqp
comma
op_amp
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|std_return
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_MKDIR
)paren
suffix:semicolon
id|cancel_flags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
id|resblks
op_assign
id|XFS_MKDIR_SPACE_RES
c_func
(paren
id|mp
comma
id|dir_namelen
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_MKDIR_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_MKDIR_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
id|resblks
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_MKDIR_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_MKDIR_LOG_COUNT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|cancel_flags
op_assign
l_int|0
suffix:semicolon
id|dp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for directory link count overflow.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_nlink
op_ge
id|XFS_MAXLINK
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EMLINK
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reserve disk quota and the inode.&n;&t; */
id|error
op_assign
id|XFS_TRANS_RESERVE_QUOTA
c_func
(paren
id|mp
comma
id|tp
comma
id|udqp
comma
id|gdqp
comma
id|resblks
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error_return
suffix:semicolon
r_if
c_cond
(paren
id|resblks
op_eq
l_int|0
op_logical_and
(paren
id|error
op_assign
id|XFS_DIR_CANENTER
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|dir_name
comma
id|dir_namelen
)paren
)paren
)paren
r_goto
id|error_return
suffix:semicolon
multiline_comment|/*&n;&t; * create the directory inode.&n;&t; */
id|error
op_assign
id|xfs_dir_ialloc
c_func
(paren
op_amp
id|tp
comma
id|dp
comma
id|MAKEIMODE
c_func
(paren
id|vap-&gt;va_type
comma
id|vap-&gt;va_mode
)paren
comma
l_int|2
comma
l_int|0
comma
id|credp
comma
id|prid
comma
id|resblks
OG
l_int|0
comma
op_amp
id|cdp
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
r_goto
id|error_return
suffix:semicolon
r_goto
id|abort_return
suffix:semicolon
)brace
id|ITRACE
c_func
(paren
id|cdp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now we add the directory inode to the transaction.&n;&t; * We waited until now since xfs_dir_ialloc might start&n;&t; * a new transaction.  Had we joined the transaction&n;&t; * earlier, the locks might have gotten released.&n;&t; */
id|VN_HOLD
c_func
(paren
id|dir_vp
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|dp_joined_to_trans
op_assign
id|B_TRUE
suffix:semicolon
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
id|error
op_assign
id|XFS_DIR_CREATENAME
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|dir_name
comma
id|dir_namelen
comma
id|cdp-&gt;i_ino
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
id|resblks
ques
c_cond
id|resblks
op_minus
id|XFS_IALLOC_SPACE_RES
c_func
(paren
id|mp
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bump the in memory version number of the parent directory&n;&t; * so that other processes accessing it will recognize that&n;&t; * the directory has changed.&n;&t; */
id|dp-&gt;i_gen
op_increment
suffix:semicolon
id|error
op_assign
id|XFS_DIR_INIT
c_func
(paren
id|mp
comma
id|tp
comma
id|cdp
comma
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error2
suffix:semicolon
)brace
id|cdp-&gt;i_gen
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bumplink
c_func
(paren
id|tp
comma
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error2
suffix:semicolon
)brace
id|cvp
op_assign
id|XFS_ITOV
c_func
(paren
id|cdp
)paren
suffix:semicolon
id|created
op_assign
id|B_TRUE
suffix:semicolon
op_star
id|vpp
op_assign
id|cvp
suffix:semicolon
id|IHOLD
c_func
(paren
id|cdp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the dquots to the new inode and modify the icount incore.&n;&t; */
id|XFS_QM_DQVOPCREATE
c_func
(paren
id|mp
comma
id|tp
comma
id|cdp
comma
id|udqp
comma
id|gdqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * mkdir transaction goes to disk before returning to&n;&t; * the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall through to std_return with error = 0 or errno from&n;&t; * xfs_trans_commit. */
id|std_return
suffix:colon
r_if
c_cond
(paren
(paren
id|created
op_logical_or
(paren
id|error
op_ne
l_int|0
op_logical_and
id|dm_event_sent
op_ne
l_int|0
)paren
)paren
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
comma
id|DM_EVENT_POSTCREATE
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_POSTCREATE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
id|created
ques
c_cond
id|XFS_ITOV
c_func
(paren
id|cdp
)paren
suffix:colon
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|dir_name
comma
l_int|NULL
comma
id|dm_di_mode
comma
id|error
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|error2
suffix:colon
id|error1
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|abort_return
suffix:colon
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
id|error_return
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dp_joined_to_trans
op_logical_and
(paren
id|dp
op_ne
l_int|NULL
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_rmdir&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_rmdir
id|xfs_rmdir
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|vname_t
op_star
id|dentry
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_char
op_star
id|name
op_assign
id|VNAME
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_inode_t
op_star
id|cdp
suffix:semicolon
multiline_comment|/* child directory */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
r_int
id|cancel_flags
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|vnode_t
op_star
id|dir_vp
suffix:semicolon
r_int
id|dm_di_mode
op_assign
l_int|0
suffix:semicolon
r_int
id|last_cdp_link
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
id|dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
op_member_access_from_pointer
id|i_mount
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|namelen
op_assign
id|VNAMELEN
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|dp
comma
id|DM_EVENT_REMOVE
)paren
)paren
(brace
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_REMOVE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|name
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* Return through std_return after this point. */
id|cdp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * We need to get a reference to cdp before we get our log&n;&t; * reservation.  The reason for this is that we cannot call&n;&t; * xfs_iget for an inode for which we do not have a reference&n;&t; * once we&squot;ve acquired a log reservation.  This is because the&n;&t; * inode we are trying to get might be in xfs_inactive going&n;&t; * for a log reservation.  Since we&squot;ll have to wait for the&n;&t; * inactive code to complete before returning from xfs_iget,&n;&t; * we need to make sure that we don&squot;t have log space reserved&n;&t; * when we call xfs_iget.  Instead we get an unlocked referece&n;&t; * to the inode before getting our log reservation.&n;&t; */
id|error
op_assign
id|xfs_get_dir_entry
c_func
(paren
id|dentry
comma
op_amp
id|cdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|dm_di_mode
op_assign
id|cdp-&gt;i_d.di_mode
suffix:semicolon
multiline_comment|/*&n;&t; * Get the dquots for the inodes.&n;&t; */
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|dp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|dp
op_ne
id|cdp
)paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|cdp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
id|REMOVE_DEBUG_TRACE
c_func
(paren
id|__LINE__
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_RMDIR
)paren
suffix:semicolon
id|cancel_flags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
multiline_comment|/*&n;&t; * We try to get the real space reservation first,&n;&t; * allowing for directory btree deletion(s) implying&n;&t; * possible bmap insert(s).  If we can&squot;t get the space&n;&t; * reservation then we use 0 instead, and avoid the bmap&n;&t; * btree insert(s) in the directory code by, if the bmap&n;&t; * insert tries to happen, instead trimming the LAST&n;&t; * block from the directory.&n;&t; */
id|resblks
op_assign
id|XFS_REMOVE_SPACE_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_REMOVE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_DEFAULT_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
id|resblks
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_REMOVE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_DEFAULT_LOG_COUNT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
id|cancel_flags
op_assign
l_int|0
suffix:semicolon
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now lock the child directory inode and the parent directory&n;&t; * inode in the proper order.  This will take care of validating&n;&t; * that the directory entry for the child directory inode has&n;&t; * not changed while we were obtaining a log reservation.&n;&t; */
id|error
op_assign
id|xfs_lock_dir_and_entry
c_func
(paren
id|dp
comma
id|dentry
comma
id|cdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dp
op_ne
id|cdp
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only increment the parent directory vnode count if&n;&t;&t; * we didn&squot;t bump it in looking up cdp.  The only time&n;&t;&t; * we don&squot;t bump it is when we&squot;re looking up &quot;.&quot;.&n;&t;&t; */
id|VN_HOLD
c_func
(paren
id|dir_vp
)paren
suffix:semicolon
)brace
id|ITRACE
c_func
(paren
id|cdp
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|cdp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|cdp-&gt;i_d.di_nlink
op_ge
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cdp-&gt;i_d.di_nlink
op_ne
l_int|2
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOTEMPTY
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_DIR_ISEMPTY
c_func
(paren
id|mp
comma
id|cdp
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOTEMPTY
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|error
op_assign
id|XFS_DIR_REMOVENAME
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|name
comma
id|namelen
comma
id|cdp-&gt;i_ino
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
id|resblks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error1
suffix:semicolon
)brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bump the in memory generation count on the parent&n;&t; * directory so that other can know that it has changed.&n;&t; */
id|dp-&gt;i_gen
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Drop the link from cdp&squot;s &quot;..&quot;.&n;&t; */
id|error
op_assign
id|xfs_droplink
c_func
(paren
id|tp
comma
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Drop the link from dp to cdp.&n;&t; */
id|error
op_assign
id|xfs_droplink
c_func
(paren
id|tp
comma
id|cdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Drop the &quot;.&quot; link from cdp to self.&n;&t; */
id|error
op_assign
id|xfs_droplink
c_func
(paren
id|tp
comma
id|cdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error1
suffix:semicolon
)brace
multiline_comment|/* Determine these before committing transaction */
id|last_cdp_link
op_assign
(paren
id|cdp
)paren
op_member_access_from_pointer
id|i_d.di_nlink
op_eq
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Take an extra ref on the child vnode so that it&n;&t; * does not go to xfs_inactive() from within the commit.&n;&t; */
id|IHOLD
c_func
(paren
id|cdp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * rmdir transaction goes to disk before returning to&n;&t; * the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|error
op_assign
id|xfs_bmap_finish
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Let interposed file systems know about removed links.&n;&t; */
id|VOP_LINK_REMOVED
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|cdp
)paren
comma
id|dir_vp
comma
id|last_cdp_link
)paren
suffix:semicolon
id|IRELE
c_func
(paren
id|cdp
)paren
suffix:semicolon
multiline_comment|/* Fall through to std_return with error = 0 or the errno&n;&t; * from xfs_trans_commit. */
id|std_return
suffix:colon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|dp
comma
id|DM_EVENT_POSTREMOVE
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_POSTREMOVE
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|name
comma
l_int|NULL
comma
id|dm_di_mode
comma
id|error
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|error1
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
id|error_return
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_readdir&n; *&n; * Read dp&squot;s entries starting at uiop-&gt;uio_offset and translate them into&n; * bufsize bytes worth of struct dirents starting at bufbase.&n; */
id|STATIC
r_int
DECL|function|xfs_readdir
id|xfs_readdir
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|uio_t
op_star
id|uiop
comma
id|cred_t
op_star
id|credp
comma
r_int
op_star
id|eofp
)paren
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|uint
id|lock_mode
suffix:semicolon
id|xfs_off_t
id|start_offset
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|lock_mode
op_assign
id|xfs_ilock_map_shared
c_func
(paren
id|dp
)paren
suffix:semicolon
id|start_offset
op_assign
id|uiop-&gt;uio_offset
suffix:semicolon
id|error
op_assign
id|XFS_DIR_GETDENTS
c_func
(paren
id|dp-&gt;i_mount
comma
id|tp
comma
id|dp
comma
id|uiop
comma
id|eofp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_offset
op_ne
id|uiop-&gt;uio_offset
)paren
(brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_ACC
)paren
suffix:semicolon
)brace
id|xfs_iunlock_map_shared
c_func
(paren
id|dp
comma
id|lock_mode
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_symlink&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_symlink
id|xfs_symlink
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|vname_t
op_star
id|dentry
comma
id|vattr_t
op_star
id|vap
comma
r_char
op_star
id|target_path
comma
id|vnode_t
op_star
op_star
id|vpp
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|pathlen
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
id|boolean_t
id|dp_joined_to_trans
suffix:semicolon
id|vnode_t
op_star
id|dir_vp
suffix:semicolon
id|uint
id|cancel_flags
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|xfs_fileoff_t
id|first_fsb
suffix:semicolon
id|xfs_filblks_t
id|fs_blocks
suffix:semicolon
r_int
id|nmaps
suffix:semicolon
id|xfs_bmbt_irec_t
id|mval
(braket
id|SYMLINK_MAPS
)braket
suffix:semicolon
id|xfs_daddr_t
id|d
suffix:semicolon
r_char
op_star
id|cur_chunk
suffix:semicolon
r_int
id|byte_cnt
suffix:semicolon
r_int
id|n
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_prid_t
id|prid
suffix:semicolon
r_struct
id|xfs_dquot
op_star
id|udqp
comma
op_star
id|gdqp
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_char
op_star
id|link_name
op_assign
id|VNAME
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_int
id|link_namelen
suffix:semicolon
op_star
id|vpp
op_assign
l_int|NULL
suffix:semicolon
id|dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|dp_joined_to_trans
op_assign
id|B_FALSE
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|ip
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|link_namelen
op_assign
id|VNAMELEN
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check component lengths of the target path name.&n;&t; */
id|pathlen
op_assign
id|strlen
c_func
(paren
id|target_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pathlen
op_ge
id|MAXPATHLEN
)paren
multiline_comment|/* total string too long */
r_return
id|XFS_ERROR
c_func
(paren
id|ENAMETOOLONG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pathlen
op_ge
id|MAXNAMELEN
)paren
(brace
multiline_comment|/* is any component too long? */
r_int
id|len
comma
id|total
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
r_for
c_loop
(paren
id|total
op_assign
l_int|0
comma
id|path
op_assign
id|target_path
suffix:semicolon
id|total
OL
id|pathlen
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Skip any slashes.&n;&t;&t;&t; */
r_while
c_loop
(paren
op_star
id|path
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|total
op_increment
suffix:semicolon
id|path
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Count up to the next slash or end of path.&n;&t;&t;&t; * Error out if the component is bigger than MAXNAMELEN.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|len
op_assign
l_int|0
suffix:semicolon
op_star
id|path
op_ne
l_char|&squot;/&squot;
op_logical_and
id|total
OL
id|pathlen
suffix:semicolon
id|total
op_increment
comma
id|path
op_increment
)paren
(brace
r_if
c_cond
(paren
op_increment
id|len
op_ge
id|MAXNAMELEN
)paren
(brace
id|error
op_assign
id|ENAMETOOLONG
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|dp
comma
id|DM_EVENT_SYMLINK
)paren
)paren
(brace
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_SYMLINK
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
id|link_name
comma
id|target_path
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Return through std_return after this point. */
id|udqp
op_assign
id|gdqp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|vap-&gt;va_mask
op_amp
id|XFS_AT_PROJID
)paren
id|prid
op_assign
(paren
id|xfs_prid_t
)paren
id|vap-&gt;va_projid
suffix:semicolon
r_else
id|prid
op_assign
(paren
id|xfs_prid_t
)paren
id|dfltprid
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that we have allocated dquot(s) on disk.&n;&t; */
id|error
op_assign
id|XFS_QM_DQVOPALLOC
c_func
(paren
id|mp
comma
id|dp
comma
id|current_fsuid
c_func
(paren
id|credp
)paren
comma
id|current_fsgid
c_func
(paren
id|credp
)paren
comma
id|XFS_QMOPT_QUOTALL
op_or
id|XFS_QMOPT_INHERIT
comma
op_amp
id|udqp
comma
op_amp
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|std_return
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_SYMLINK
)paren
suffix:semicolon
id|cancel_flags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
multiline_comment|/*&n;&t; * The symlink will fit into the inode data fork?&n;&t; * There can&squot;t be any attributes so we get the whole variable part.&n;&t; */
r_if
c_cond
(paren
id|pathlen
op_le
id|XFS_LITINO
c_func
(paren
id|mp
)paren
)paren
id|fs_blocks
op_assign
l_int|0
suffix:semicolon
r_else
id|fs_blocks
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|pathlen
)paren
suffix:semicolon
id|resblks
op_assign
id|XFS_SYMLINK_SPACE_RES
c_func
(paren
id|mp
comma
id|link_namelen
comma
id|fs_blocks
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_SYMLINK_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_SYMLINK_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
op_logical_and
id|fs_blocks
op_eq
l_int|0
)paren
(brace
id|resblks
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_SYMLINK_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_SYMLINK_LOG_COUNT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|cancel_flags
op_assign
l_int|0
suffix:semicolon
id|dp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether the directory allows new symlinks or not.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_NOSYMLINKS
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reserve disk quota : blocks and inode.&n;&t; */
id|error
op_assign
id|XFS_TRANS_RESERVE_QUOTA
c_func
(paren
id|mp
comma
id|tp
comma
id|udqp
comma
id|gdqp
comma
id|resblks
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error_return
suffix:semicolon
multiline_comment|/*&n;&t; * Check for ability to enter directory entry, if no space reserved.&n;&t; */
r_if
c_cond
(paren
id|resblks
op_eq
l_int|0
op_logical_and
(paren
id|error
op_assign
id|XFS_DIR_CANENTER
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|link_name
comma
id|link_namelen
)paren
)paren
)paren
r_goto
id|error_return
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the bmap freelist prior to calling either&n;&t; * bmapi or the directory create code.&n;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate an inode for the symlink.&n;&t; */
id|error
op_assign
id|xfs_dir_ialloc
c_func
(paren
op_amp
id|tp
comma
id|dp
comma
id|S_IFLNK
op_or
(paren
id|vap-&gt;va_mode
op_amp
op_complement
id|S_IFMT
)paren
comma
l_int|1
comma
l_int|0
comma
id|credp
comma
id|prid
comma
id|resblks
OG
l_int|0
comma
op_amp
id|ip
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
r_goto
id|error_return
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|ITRACE
c_func
(paren
id|ip
)paren
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|dir_vp
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|dp_joined_to_trans
op_assign
id|B_TRUE
suffix:semicolon
multiline_comment|/*&n;&t; * Also attach the dquot(s) to it, if applicable.&n;&t; */
id|XFS_QM_DQVOPCREATE
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|udqp
comma
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resblks
)paren
id|resblks
op_sub_assign
id|XFS_IALLOC_SPACE_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the symlink will fit into the inode, write it inline.&n;&t; */
r_if
c_cond
(paren
id|pathlen
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
)paren
(brace
id|xfs_idata_realloc
c_func
(paren
id|ip
comma
id|pathlen
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ip-&gt;i_df.if_u1.if_data
comma
id|target_path
comma
id|pathlen
)paren
suffix:semicolon
id|ip-&gt;i_d.di_size
op_assign
id|pathlen
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The inode was initially created in extent format.&n;&t;&t; */
id|ip-&gt;i_df.if_flags
op_and_assign
op_complement
(paren
id|XFS_IFEXTENTS
op_or
id|XFS_IFBROOT
)paren
suffix:semicolon
id|ip-&gt;i_df.if_flags
op_or_assign
id|XFS_IFINLINE
suffix:semicolon
id|ip-&gt;i_d.di_format
op_assign
id|XFS_DINODE_FMT_LOCAL
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
r_else
(brace
id|first_fsb
op_assign
l_int|0
suffix:semicolon
id|nmaps
op_assign
id|SYMLINK_MAPS
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|ip
comma
id|first_fsb
comma
id|fs_blocks
comma
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_METADATA
comma
op_amp
id|first_block
comma
id|resblks
comma
id|mval
comma
op_amp
id|nmaps
comma
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|resblks
)paren
id|resblks
op_sub_assign
id|fs_blocks
suffix:semicolon
id|ip-&gt;i_d.di_size
op_assign
id|pathlen
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|cur_chunk
op_assign
id|target_path
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|nmaps
suffix:semicolon
id|n
op_increment
)paren
(brace
id|d
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|mval
(braket
id|n
)braket
dot
id|br_startblock
)paren
suffix:semicolon
id|byte_cnt
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|mval
(braket
id|n
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|BTOBB
c_func
(paren
id|byte_cnt
)paren
comma
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_logical_and
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pathlen
OL
id|byte_cnt
)paren
(brace
id|byte_cnt
op_assign
id|pathlen
suffix:semicolon
)brace
id|pathlen
op_sub_assign
id|byte_cnt
suffix:semicolon
id|memcpy
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
id|cur_chunk
comma
id|byte_cnt
)paren
suffix:semicolon
id|cur_chunk
op_add_assign
id|byte_cnt
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
l_int|0
comma
id|byte_cnt
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Create the directory entry for the symlink.&n;&t; */
id|error
op_assign
id|XFS_DIR_CREATENAME
c_func
(paren
id|mp
comma
id|tp
comma
id|dp
comma
id|link_name
comma
id|link_namelen
comma
id|ip-&gt;i_ino
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
id|resblks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error1
suffix:semicolon
)brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bump the in memory version number of the parent directory&n;&t; * so that other processes accessing it will recognize that&n;&t; * the directory has changed.&n;&t; */
id|dp-&gt;i_gen
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * symlink transaction goes to disk before returning to&n;&t; * the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * xfs_trans_commit normally decrements the vnode ref count&n;&t; * when it unlocks the inode. Since we want to return the&n;&t; * vnode to the caller, we bump the vnode ref count now.&n;&t; */
id|IHOLD
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error2
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
multiline_comment|/* Fall through to std_return with error = 0 or errno from&n;&t; * xfs_trans_commit&t;*/
id|std_return
suffix:colon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|dir_vp-&gt;v_vfsp
comma
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
comma
id|DM_EVENT_POSTSYMLINK
)paren
)paren
(brace
(paren
r_void
)paren
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_POSTSYMLINK
comma
id|dir_vp
comma
id|DM_RIGHT_NULL
comma
id|error
ques
c_cond
l_int|NULL
suffix:colon
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|DM_RIGHT_NULL
comma
id|link_name
comma
id|target_path
comma
l_int|0
comma
id|error
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|vnode_t
op_star
id|vp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip
)paren
suffix:semicolon
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
op_star
id|vpp
op_assign
id|vp
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|error2
suffix:colon
id|IRELE
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error1
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|cancel_flags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
id|error_return
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancel_flags
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|udqp
)paren
suffix:semicolon
id|XFS_QM_DQRELE
c_func
(paren
id|mp
comma
id|gdqp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dp_joined_to_trans
op_logical_and
(paren
id|dp
op_ne
l_int|NULL
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_goto
id|std_return
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_fid2&n; *&n; * A fid routine that takes a pointer to a previously allocated&n; * fid structure (like xfs_fast_fid) but uses a 64 bit inode number.&n; */
id|STATIC
r_int
DECL|function|xfs_fid2
id|xfs_fid2
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|fid_t
op_star
id|fidp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_fid2_t
op_star
id|xfid
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_sizeof
(paren
id|fid_t
)paren
op_ge
r_sizeof
(paren
id|xfs_fid2_t
)paren
)paren
suffix:semicolon
id|xfid
op_assign
(paren
id|xfs_fid2_t
op_star
)paren
id|fidp
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfid-&gt;fid_len
op_assign
r_sizeof
(paren
id|xfs_fid2_t
)paren
op_minus
r_sizeof
(paren
id|xfid-&gt;fid_len
)paren
suffix:semicolon
id|xfid-&gt;fid_pad
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * use memcpy because the inode is a long long and there&squot;s no&n;&t; * assurance that xfid-&gt;fid_ino is properly aligned.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|xfid-&gt;fid_ino
comma
op_amp
id|ip-&gt;i_ino
comma
r_sizeof
(paren
id|xfid-&gt;fid_ino
)paren
)paren
suffix:semicolon
id|xfid-&gt;fid_gen
op_assign
id|ip-&gt;i_d.di_gen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_rwlock&n; */
r_int
DECL|function|xfs_rwlock
id|xfs_rwlock
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vrwlock_t
id|locktype
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp-&gt;v_type
op_eq
id|VDIR
)paren
r_return
l_int|1
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|locktype
op_eq
id|VRWLOCK_WRITE
)paren
(brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|locktype
op_eq
id|VRWLOCK_TRY_READ
)paren
(brace
r_return
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|locktype
op_eq
id|VRWLOCK_TRY_WRITE
)paren
(brace
r_return
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
(paren
id|locktype
op_eq
id|VRWLOCK_READ
)paren
op_logical_or
(paren
id|locktype
op_eq
id|VRWLOCK_WRITE_DIRECT
)paren
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_rwunlock&n; */
r_void
DECL|function|xfs_rwunlock
id|xfs_rwunlock
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vrwlock_t
id|locktype
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp-&gt;v_type
op_eq
id|VDIR
)paren
r_return
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|locktype
op_eq
id|VRWLOCK_WRITE
)paren
(brace
multiline_comment|/*&n;&t;&t; * In the write case, we may have added a new entry to&n;&t;&t; * the reference cache.  This might store a pointer to&n;&t;&t; * an inode to be released in this inode.  If it is there,&n;&t;&t; * clear the pointer and release the inode after unlocking&n;&t;&t; * this one.&n;&t;&t; */
id|xfs_refcache_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
(paren
id|locktype
op_eq
id|VRWLOCK_READ
)paren
op_logical_or
(paren
id|locktype
op_eq
id|VRWLOCK_WRITE_DIRECT
)paren
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_inode_flush
id|xfs_inode_flush
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|flags
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/* Bypass inodes which have already been cleaned by&n;&t; * the inode flush clustering code inside xfs_iflush&n;&t; */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_itemp
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLUSH_LOG
)paren
(brace
id|xfs_inode_log_item_t
op_star
id|iip
op_assign
id|ip-&gt;i_itemp
suffix:semicolon
r_if
c_cond
(paren
id|iip
op_logical_and
id|iip-&gt;ili_last_lsn
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|xfs_lsn_t
id|sync_lsn
suffix:semicolon
r_int
id|s
comma
id|log_flags
op_assign
id|XFS_LOG_FORCE
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|sync_lsn
op_assign
id|log-&gt;l_last_sync_lsn
suffix:semicolon
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|XFS_LSN_CMP
c_func
(paren
id|iip-&gt;ili_last_lsn
comma
id|sync_lsn
)paren
op_le
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLUSH_SYNC
)paren
id|log_flags
op_or_assign
id|XFS_LOG_SYNC
suffix:semicolon
r_return
id|xfs_log_force
c_func
(paren
id|mp
comma
id|iip-&gt;ili_last_lsn
comma
id|log_flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We make this non-blocking if the inode is contended,&n;&t; * return EAGAIN to indicate to the caller that they&n;&t; * did not succeed. This prevents the flush path from&n;&t; * blocking on inodes inside another operation right&n;&t; * now, they get caught later by xfs_sync.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|FLUSH_INODE
)paren
(brace
r_int
id|flush_flags
suffix:semicolon
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
)paren
r_return
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FLUSH_SYNC
)paren
(brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_logical_or
op_logical_neg
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|EAGAIN
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|FLUSH_SYNC
)paren
id|flush_flags
op_assign
id|XFS_IFLUSH_SYNC
suffix:semicolon
r_else
id|flush_flags
op_assign
id|XFS_IFLUSH_ASYNC
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|flush_flags
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_int
DECL|function|xfs_set_dmattrs
id|xfs_set_dmattrs
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|u_int
id|evmask
comma
id|u_int16_t
id|state
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_SET_DMATTRS
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ICHANGE_LOG_RES
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|ip-&gt;i_iocore.io_dmevmask
op_assign
id|ip-&gt;i_d.di_dmevmask
op_assign
id|evmask
suffix:semicolon
id|ip-&gt;i_iocore.io_dmstate
op_assign
id|ip-&gt;i_d.di_dmstate
op_assign
id|state
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|IHOLD
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_reclaim&n; */
id|STATIC
r_int
DECL|function|xfs_reclaim
id|xfs_reclaim
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|VN_MAPPED
c_func
(paren
id|vp
)paren
)paren
suffix:semicolon
multiline_comment|/* bad inode, get out here ASAP */
r_if
c_cond
(paren
id|VN_BAD
c_func
(paren
id|vp
)paren
)paren
(brace
id|xfs_ireclaim
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFREG
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_size
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Flush and invalidate any data left around that is&n;&t;&t;&t; * a part of this file.&n;&t;&t;&t; *&n;&t;&t;&t; * Get the inode&squot;s i/o lock so that buffers are pushed&n;&t;&t;&t; * out while holding the proper lock.  We can&squot;t hold&n;&t;&t;&t; * the inode lock here since flushing out buffers may&n;&t;&t;&t; * cause us to try to get the lock in xfs_strategy().&n;&t;&t;&t; *&n;&t;&t;&t; * We don&squot;t have to call remapf() here, because there&n;&t;&t;&t; * cannot be any mapped file references to this vnode&n;&t;&t;&t; * since it is being reclaimed.&n;&t;&t;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we hit an IO error, we need to make sure that the&n;&t;&t;&t; * buffer and page caches of file data for&n;&t;&t;&t; * the file are tossed away. We don&squot;t want to use&n;&t;&t;&t; * VOP_FLUSHINVAL_PAGES here because we don&squot;t want dirty&n;&t;&t;&t; * pages to stay attached to the vnode, but be&n;&t;&t;&t; * marked P_BAD. pdflush/vnode_pagebad&n;&t;&t;&t; * hates that.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
(brace
id|VOP_FLUSHINVAL_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_NONE
)paren
suffix:semicolon
)brace
r_else
(brace
id|VOP_TOSS_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_NONE
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|VN_CACHED
c_func
(paren
id|vp
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
op_logical_or
id|ip-&gt;i_delayed_blks
op_eq
l_int|0
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * di_size field may not be quite accurate if we&squot;re&n;&t;&t;&t; * shutting down.&n;&t;&t;&t; */
id|VOP_TOSS_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_NONE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|VN_CACHED
c_func
(paren
id|vp
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If we have nothing to flush with this inode then complete the&n;&t; * teardown now, otherwise break the link between the xfs inode&n;&t; * and the linux inode and clean up the xfs inode later. This&n;&t; * avoids flushing the inode to disk during the delete operation&n;&t; * itself.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ip-&gt;i_update_core
op_logical_and
(paren
id|ip-&gt;i_itemp
op_eq
l_int|NULL
)paren
)paren
(brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
id|xfs_finish_reclaim
c_func
(paren
id|ip
comma
l_int|1
comma
id|XFS_IFLUSH_DELWRI_ELSE_SYNC
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_mount_t
op_star
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
multiline_comment|/* Protect sync from us */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|vn_bhv_remove
c_func
(paren
id|VN_BHV_HEAD
c_func
(paren
id|vp
)paren
comma
id|XFS_ITOBHV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|ip-&gt;i_reclaim
comma
op_amp
id|mp-&gt;m_del_inodes
)paren
suffix:semicolon
id|ip-&gt;i_flags
op_or_assign
id|XFS_IRECLAIMABLE
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xfs_finish_reclaim
id|xfs_finish_reclaim
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|locked
comma
r_int
id|sync_mode
)paren
(brace
id|xfs_ihash_t
op_star
id|ih
op_assign
id|ip-&gt;i_hash
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|vp
op_logical_and
id|VN_BAD
c_func
(paren
id|vp
)paren
)paren
r_goto
id|reclaim
suffix:semicolon
multiline_comment|/* The hash lock here protects a thread in xfs_iget_core from&n;&t; * racing with us on linking the inode back with a vnode.&n;&t; * Once we have the XFS_IRECLAIM flag set it will not touch&n;&t; * us.&n;&t; */
id|write_lock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_flags
op_amp
id|XFS_IRECLAIM
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|ip-&gt;i_flags
op_amp
id|XFS_IRECLAIMABLE
)paren
op_logical_and
id|vp
op_eq
l_int|NULL
)paren
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|locked
)paren
(brace
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|ip-&gt;i_flags
op_or_assign
id|XFS_IRECLAIM
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the inode is still dirty, then flush it out.  If the inode&n;&t; * is not in the AIL, then it will be OK to flush it delwri as&n;&t; * long as xfs_iflush() does not keep any references to the inode.&n;&t; * We leave that decision up to xfs_iflush() since it has the&n;&t; * knowledge of whether it&squot;s OK to simply do a delwri flush of&n;&t; * the inode or whether we need to wait until the inode is&n;&t; * pulled from the AIL.&n;&t; * We get the flush lock regardless, though, just to make sure&n;&t; * we don&squot;t free it while it is being flushed.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
(brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_update_core
op_logical_or
(paren
(paren
id|ip-&gt;i_itemp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
)paren
)paren
(brace
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|sync_mode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we hit an error, typically because of filesystem&n;&t;&t;&t; * shutdown, we don&squot;t need to let vn_reclaim to know&n;&t;&t;&t; * because we&squot;re gonna reclaim the inode anyway.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|reclaim
suffix:semicolon
)brace
id|xfs_iflock
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/* synchronize with xfs_iflush_done */
)brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_itemp
op_eq
l_int|NULL
op_logical_or
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_eq
l_int|0
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|locked
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are not interested in doing an iflush if we&squot;re&n;&t;&t; * in the process of shutting down the filesystem forcibly.&n;&t;&t; * So, just reclaim the inode.&n;&t;&t; */
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
id|reclaim
suffix:colon
id|xfs_ireclaim
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xfs_finish_reclaim_all
id|xfs_finish_reclaim_all
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|noblock
)paren
(brace
r_int
id|purged
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
comma
op_star
id|n
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
id|purged
op_assign
l_int|0
suffix:semicolon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|ip
comma
id|n
comma
op_amp
id|mp-&gt;m_del_inodes
comma
id|i_reclaim
)paren
(brace
r_if
c_cond
(paren
id|noblock
)paren
(brace
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_logical_or
op_logical_neg
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_finish_reclaim
c_func
(paren
id|ip
comma
id|noblock
comma
id|XFS_IFLUSH_DELWRI_ELSE_ASYNC
)paren
suffix:semicolon
id|purged
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|done
op_assign
op_logical_neg
id|purged
suffix:semicolon
)brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_alloc_file_space()&n; *      This routine allocates disk space for the given file.&n; *&n; *&t;If alloc_type == 0, this request is for an ALLOCSP type&n; *&t;request which will change the file size.  In this case, no&n; *&t;DMAPI event will be generated by the call.  A TRUNCATE event&n; *&t;will be generated later by xfs_setattr.&n; *&n; *&t;If alloc_type != 0, this request is for a RESVSP type&n; *&t;request, and a DMAPI DM_EVENT_WRITE will be generated if the&n; *&t;lower block boundary byte address is less than the file&squot;s&n; *&t;length.&n; *&n; * RETURNS:&n; *       0 on success&n; *      errno on error&n; *&n; */
r_int
DECL|function|xfs_alloc_file_space
id|xfs_alloc_file_space
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_off_t
id|offset
comma
id|xfs_off_t
id|len
comma
r_int
id|alloc_type
comma
r_int
id|attr_flags
)paren
(brace
id|xfs_filblks_t
id|allocated_fsb
suffix:semicolon
id|xfs_filblks_t
id|allocatesize_fsb
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|xfs_off_t
id|count
suffix:semicolon
id|xfs_filblks_t
id|datablocks
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fsblock_t
id|firstfsb
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_bmbt_irec_t
op_star
id|imapp
suffix:semicolon
id|xfs_bmbt_irec_t
id|imaps
(braket
l_int|1
)braket
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|numrtextents
suffix:semicolon
r_int
id|reccount
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_int
id|rt
suffix:semicolon
r_int
id|rtextsize
suffix:semicolon
id|xfs_fileoff_t
id|startoffset_fsb
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|xfs_bmapi_flags
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * determine if this is a realtime file&n;&t; */
r_if
c_cond
(paren
(paren
id|rt
op_assign
id|XFS_IS_REALTIME_INODE
c_func
(paren
id|ip
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_extsize
)paren
id|rtextsize
op_assign
id|ip-&gt;i_d.di_extsize
suffix:semicolon
r_else
id|rtextsize
op_assign
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
)brace
r_else
id|rtextsize
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|ip
comma
l_int|0
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
id|count
op_assign
id|len
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|imapp
op_assign
op_amp
id|imaps
(braket
l_int|0
)braket
suffix:semicolon
id|reccount
op_assign
l_int|1
suffix:semicolon
id|xfs_bmapi_flags
op_assign
id|XFS_BMAPI_WRITE
op_or
(paren
id|alloc_type
ques
c_cond
id|XFS_BMAPI_PREALLOC
suffix:colon
l_int|0
)paren
suffix:semicolon
id|startoffset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|allocatesize_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&t;Generate a DMAPI event if needed.&t;*/
r_if
c_cond
(paren
id|alloc_type
op_ne
l_int|0
op_logical_and
id|offset
OL
id|ip-&gt;i_d.di_size
op_logical_and
(paren
id|attr_flags
op_amp
id|ATTR_DMI
)paren
op_eq
l_int|0
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
comma
id|ip
comma
id|DM_EVENT_WRITE
)paren
)paren
(brace
id|xfs_off_t
id|end_dmi_offset
suffix:semicolon
id|end_dmi_offset
op_assign
id|offset
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|end_dmi_offset
OG
id|ip-&gt;i_d.di_size
)paren
id|end_dmi_offset
op_assign
id|ip-&gt;i_d.di_size
suffix:semicolon
id|error
op_assign
id|XFS_SEND_DATA
c_func
(paren
id|mp
comma
id|DM_EVENT_WRITE
comma
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|offset
comma
id|end_dmi_offset
op_minus
id|offset
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate file space until done or until there is an error&n;&t; */
id|retry
suffix:colon
r_while
c_loop
(paren
id|allocatesize_fsb
op_logical_and
op_logical_neg
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * determine if reserving space on&n;&t;&t; * the data or realtime partition.&n;&t;&t; */
r_if
c_cond
(paren
id|rt
)paren
(brace
id|xfs_fileoff_t
id|s
comma
id|e
suffix:semicolon
id|s
op_assign
id|startoffset_fsb
suffix:semicolon
id|do_div
c_func
(paren
id|s
comma
id|rtextsize
)paren
suffix:semicolon
id|s
op_mul_assign
id|rtextsize
suffix:semicolon
id|e
op_assign
id|roundup_64
c_func
(paren
id|startoffset_fsb
op_plus
id|allocatesize_fsb
comma
id|rtextsize
)paren
suffix:semicolon
id|numrtextents
op_assign
(paren
r_int
)paren
(paren
id|e
op_minus
id|s
)paren
op_div
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
id|datablocks
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|datablocks
op_assign
id|allocatesize_fsb
suffix:semicolon
id|numrtextents
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * allocate and setup the transaction&n;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_DIOSTRAT
)paren
suffix:semicolon
id|resblks
op_assign
id|XFS_DIOSTRAT_SPACE_RES
c_func
(paren
id|mp
comma
id|datablocks
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
id|numrtextents
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_WRITE_LOG_COUNT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for running out of space&n;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Free the transaction structure.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|error
op_eq
id|ENOSPC
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|XFS_TRANS_RESERVE_QUOTA_BYDQUOTS
c_func
(paren
id|mp
comma
id|tp
comma
id|ip-&gt;i_udquot
comma
id|ip-&gt;i_gdquot
comma
id|resblks
comma
l_int|0
comma
id|rt
ques
c_cond
id|XFS_QMOPT_RES_RTBLKS
suffix:colon
id|XFS_QMOPT_RES_REGBLKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error1
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * issue the bmapi() call to allocate the blocks&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|firstfsb
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|ip
comma
id|startoffset_fsb
comma
id|allocatesize_fsb
comma
id|xfs_bmapi_flags
comma
op_amp
id|firstfsb
comma
l_int|0
comma
id|imapp
comma
op_amp
id|reccount
comma
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * complete the transaction&n;&t;&t; */
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|firstfsb
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_break
suffix:semicolon
)brace
id|allocated_fsb
op_assign
id|imapp-&gt;br_blockcount
suffix:semicolon
r_if
c_cond
(paren
id|reccount
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|startoffset_fsb
op_add_assign
id|allocated_fsb
suffix:semicolon
id|allocatesize_fsb
op_sub_assign
id|allocated_fsb
suffix:semicolon
)brace
id|dmapi_enospc_check
suffix:colon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
op_logical_and
(paren
id|attr_flags
op_amp
id|ATTR_DMI
)paren
op_eq
l_int|0
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
comma
id|ip
comma
id|DM_EVENT_NOSPACE
)paren
)paren
(brace
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|mp
comma
id|DM_EVENT_NOSPACE
comma
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|DM_RIGHT_NULL
comma
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Delay flag intentionally unused */
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
r_goto
id|retry
suffix:semicolon
multiline_comment|/* Maybe DMAPI app. has made space */
multiline_comment|/* else fall through with error from XFS_SEND_DATA */
)brace
r_return
id|error
suffix:semicolon
id|error0
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|error1
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|dmapi_enospc_check
suffix:semicolon
)brace
multiline_comment|/*&n; * Zero file bytes between startoff and endoff inclusive.&n; * The iolock is held exclusive and no blocks are buffered.&n; */
id|STATIC
r_int
DECL|function|xfs_zero_remaining_bytes
id|xfs_zero_remaining_bytes
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_off_t
id|startoff
comma
id|xfs_off_t
id|endoff
)paren
(brace
id|xfs_bmbt_irec_t
id|imap
suffix:semicolon
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_off_t
id|lastoffset
suffix:semicolon
id|xfs_off_t
id|offset
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_int
id|nimap
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|bp
op_assign
id|xfs_buf_get_noaddr
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
ques
c_cond
id|mp-&gt;m_rtdev_targp
suffix:colon
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
id|startoff
suffix:semicolon
id|offset
op_le
id|endoff
suffix:semicolon
id|offset
op_assign
id|lastoffset
op_plus
l_int|1
)paren
(brace
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|nimap
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|offset_fsb
comma
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|nimap
OL
l_int|1
)paren
r_break
suffix:semicolon
id|ASSERT
c_func
(paren
id|imap.br_blockcount
op_ge
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|imap.br_startoff
op_eq
id|offset_fsb
)paren
suffix:semicolon
id|lastoffset
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap.br_startoff
op_plus
l_int|1
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lastoffset
OG
id|endoff
)paren
id|lastoffset
op_assign
id|endoff
suffix:semicolon
r_if
c_cond
(paren
id|imap.br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
r_continue
suffix:semicolon
id|ASSERT
c_func
(paren
id|imap.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap.br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
r_continue
suffix:semicolon
id|XFS_BUF_UNDONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_UNWRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_READ
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SET_ADDR
c_func
(paren
id|bp
comma
id|XFS_FSB_TO_DB
c_func
(paren
id|ip
comma
id|imap.br_startblock
)paren
)paren
suffix:semicolon
id|xfsbdstrat
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iowait
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xfs_zero_remaining_bytes(read)&quot;
comma
id|mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
op_plus
(paren
id|offset
op_minus
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap.br_startoff
)paren
)paren
comma
l_int|0
comma
id|lastoffset
op_minus
id|offset
op_plus
l_int|1
)paren
suffix:semicolon
id|XFS_BUF_UNDONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_UNREAD
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_WRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfsbdstrat
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iowait
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xfs_zero_remaining_bytes(write)&quot;
comma
id|mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|xfs_buf_free
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_free_file_space()&n; *      This routine frees disk space for the given file.&n; *&n; *&t;This routine is only called by xfs_change_file_space&n; *&t;for an UNRESVSP type call.&n; *&n; * RETURNS:&n; *       0 on success&n; *      errno on error&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_free_file_space
id|xfs_free_file_space
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_off_t
id|offset
comma
id|xfs_off_t
id|len
comma
r_int
id|attr_flags
)paren
(brace
r_int
id|committed
suffix:semicolon
r_int
id|done
suffix:semicolon
id|xfs_off_t
id|end_dmi_offset
suffix:semicolon
id|xfs_fileoff_t
id|endoffset_fsb
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fsblock_t
id|firstfsb
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_off_t
id|ilen
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
suffix:semicolon
id|xfs_off_t
id|ioffset
suffix:semicolon
id|xfs_extlen_t
id|mod
op_assign
l_int|0
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|nimap
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_int
id|rounding
suffix:semicolon
r_int
id|rt
suffix:semicolon
id|xfs_fileoff_t
id|startoffset_fsb
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|need_iolock
op_assign
(paren
id|attr_flags
op_amp
id|ATTR_DMI
)paren
op_eq
l_int|0
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|ip
comma
l_int|0
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
multiline_comment|/* if nothing being freed */
r_return
id|error
suffix:semicolon
id|rt
op_assign
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
suffix:semicolon
id|startoffset_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|end_dmi_offset
op_assign
id|offset
op_plus
id|len
suffix:semicolon
id|endoffset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|end_dmi_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|ip-&gt;i_d.di_size
op_logical_and
(paren
id|attr_flags
op_amp
id|ATTR_DMI
)paren
op_eq
l_int|0
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
comma
id|ip
comma
id|DM_EVENT_WRITE
)paren
)paren
(brace
r_if
c_cond
(paren
id|end_dmi_offset
OG
id|ip-&gt;i_d.di_size
)paren
id|end_dmi_offset
op_assign
id|ip-&gt;i_d.di_size
suffix:semicolon
id|error
op_assign
id|XFS_SEND_DATA
c_func
(paren
id|mp
comma
id|DM_EVENT_WRITE
comma
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
id|offset
comma
id|end_dmi_offset
op_minus
id|offset
comma
id|AT_DELAY_FLAG
c_func
(paren
id|attr_flags
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_iolock
)paren
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|rounding
op_assign
id|MAX
c_func
(paren
(paren
id|__uint8_t
)paren
(paren
l_int|1
op_lshift
id|mp-&gt;m_sb.sb_blocklog
)paren
comma
(paren
id|__uint8_t
)paren
id|NBPP
)paren
suffix:semicolon
id|ilen
op_assign
id|len
op_plus
(paren
id|offset
op_amp
(paren
id|rounding
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|ioffset
op_assign
id|offset
op_amp
op_complement
(paren
id|rounding
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ilen
op_amp
(paren
id|rounding
op_minus
l_int|1
)paren
)paren
id|ilen
op_assign
(paren
id|ilen
op_plus
id|rounding
)paren
op_amp
op_complement
(paren
id|rounding
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_inval_cached_pages
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
op_amp
(paren
id|ip-&gt;i_iocore
)paren
comma
id|ioffset
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to zero the stuff we&squot;re not freeing, on disk.&n;&t; * If its a realtime file &amp; can&squot;t use unwritten extents then we&n;&t; * actually need to zero the extent edges.  Otherwise xfs_bunmapi&n;&t; * will take care of it for us.&n;&t; */
r_if
c_cond
(paren
id|rt
op_logical_and
op_logical_neg
id|XFS_SB_VERSION_HASEXTFLGBIT
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|nimap
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|startoffset_fsb
comma
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_unlock_iolock
suffix:semicolon
id|ASSERT
c_func
(paren
id|nimap
op_eq
l_int|0
op_logical_or
id|nimap
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nimap
op_logical_and
id|imap.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
(brace
id|xfs_daddr_t
id|block
suffix:semicolon
id|ASSERT
c_func
(paren
id|imap.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
suffix:semicolon
id|block
op_assign
id|imap.br_startblock
suffix:semicolon
id|mod
op_assign
id|do_div
c_func
(paren
id|block
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod
)paren
id|startoffset_fsb
op_add_assign
id|mp-&gt;m_sb.sb_rextsize
op_minus
id|mod
suffix:semicolon
)brace
id|nimap
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|endoffset_fsb
op_minus
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_unlock_iolock
suffix:semicolon
id|ASSERT
c_func
(paren
id|nimap
op_eq
l_int|0
op_logical_or
id|nimap
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nimap
op_logical_and
id|imap.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
(brace
id|ASSERT
c_func
(paren
id|imap.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
suffix:semicolon
id|mod
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mod
op_logical_and
(paren
id|mod
op_ne
id|mp-&gt;m_sb.sb_rextsize
)paren
)paren
id|endoffset_fsb
op_sub_assign
id|mod
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|done
op_assign
(paren
id|endoffset_fsb
op_le
id|startoffset_fsb
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t; * One contiguous piece to clear&n;&t;&t; */
id|error
op_assign
id|xfs_zero_remaining_bytes
c_func
(paren
id|ip
comma
id|offset
comma
id|offset
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * Some full blocks, possibly two pieces to clear&n;&t;&t; */
r_if
c_cond
(paren
id|offset
OL
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|startoffset_fsb
)paren
)paren
id|error
op_assign
id|xfs_zero_remaining_bytes
c_func
(paren
id|ip
comma
id|offset
comma
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|startoffset_fsb
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|endoffset_fsb
)paren
OL
id|offset
op_plus
id|len
)paren
id|error
op_assign
id|xfs_zero_remaining_bytes
c_func
(paren
id|ip
comma
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|endoffset_fsb
)paren
comma
id|offset
op_plus
id|len
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * free file space until done or until there is an error&n;&t; */
id|resblks
op_assign
id|XFS_DIOSTRAT_SPACE_RES
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|error
op_logical_and
op_logical_neg
id|done
)paren
(brace
multiline_comment|/*&n;&t;&t; * allocate and setup the transaction&n;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_DIOSTRAT
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_WRITE_LOG_COUNT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check for running out of space&n;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Free the transaction structure.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|error
op_eq
id|ENOSPC
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|XFS_TRANS_RESERVE_QUOTA
c_func
(paren
id|mp
comma
id|tp
comma
id|ip-&gt;i_udquot
comma
id|ip-&gt;i_gdquot
comma
id|resblks
comma
l_int|0
comma
id|rt
ques
c_cond
id|XFS_QMOPT_RES_RTBLKS
suffix:colon
id|XFS_QMOPT_RES_REGBLKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error1
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * issue the bunmapi() call to free the blocks&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|firstfsb
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bunmapi
c_func
(paren
id|tp
comma
id|ip
comma
id|startoffset_fsb
comma
id|endoffset_fsb
op_minus
id|startoffset_fsb
comma
l_int|0
comma
l_int|2
comma
op_amp
id|firstfsb
comma
op_amp
id|free_list
comma
op_amp
id|done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * complete the transaction&n;&t;&t; */
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|firstfsb
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
id|out_unlock_iolock
suffix:colon
r_if
c_cond
(paren
id|need_iolock
)paren
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|error0
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|error1
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|need_iolock
ques
c_cond
(paren
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:colon
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_change_file_space()&n; *      This routine allocates or frees disk space for the given file.&n; *      The user specified parameters are checked for alignment and size&n; *      limitations.&n; *&n; * RETURNS:&n; *       0 on success&n; *      errno on error&n; *&n; */
r_int
DECL|function|xfs_change_file_space
id|xfs_change_file_space
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|cmd
comma
id|xfs_flock64_t
op_star
id|bf
comma
id|xfs_off_t
id|offset
comma
id|cred_t
op_star
id|credp
comma
r_int
id|attr_flags
)paren
(brace
r_int
id|clrprealloc
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fsize_t
id|fsize
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|setprealloc
suffix:semicolon
id|xfs_off_t
id|startoffset
suffix:semicolon
id|xfs_off_t
id|llen
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|vattr_t
id|va
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * must be a regular file and have write permission&n;&t; */
r_if
c_cond
(paren
id|vp-&gt;v_type
op_ne
id|VREG
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|ip
comma
id|S_IWUSR
comma
id|credp
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bf-&gt;l_whence
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*SEEK_SET*/
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*SEEK_CUR*/
id|bf-&gt;l_start
op_add_assign
id|offset
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*SEEK_END*/
id|bf-&gt;l_start
op_add_assign
id|ip-&gt;i_d.di_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|llen
op_assign
id|bf-&gt;l_len
OG
l_int|0
ques
c_cond
id|bf-&gt;l_len
op_minus
l_int|1
suffix:colon
id|bf-&gt;l_len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bf-&gt;l_start
OL
l_int|0
)paren
op_logical_or
(paren
id|bf-&gt;l_start
OG
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
)paren
op_logical_or
(paren
id|bf-&gt;l_start
op_plus
id|llen
OL
l_int|0
)paren
op_logical_or
(paren
id|bf-&gt;l_start
op_plus
id|llen
OG
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
id|bf-&gt;l_whence
op_assign
l_int|0
suffix:semicolon
id|startoffset
op_assign
id|bf-&gt;l_start
suffix:semicolon
id|fsize
op_assign
id|ip-&gt;i_d.di_size
suffix:semicolon
multiline_comment|/*&n;&t; * XFS_IOC_RESVSP and XFS_IOC_UNRESVSP will reserve or unreserve&n;&t; * file space.&n;&t; * These calls do NOT zero the data space allocated to the file,&n;&t; * nor do they change the file size.&n;&t; *&n;&t; * XFS_IOC_ALLOCSP and XFS_IOC_FREESP will allocate and free file&n;&t; * space.&n;&t; * These calls cause the new file data to be zeroed and the file&n;&t; * size to be changed.&n;&t; */
id|setprealloc
op_assign
id|clrprealloc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|XFS_IOC_RESVSP
suffix:colon
r_case
id|XFS_IOC_RESVSP64
suffix:colon
id|error
op_assign
id|xfs_alloc_file_space
c_func
(paren
id|ip
comma
id|startoffset
comma
id|bf-&gt;l_len
comma
l_int|1
comma
id|attr_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|setprealloc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_IOC_UNRESVSP
suffix:colon
r_case
id|XFS_IOC_UNRESVSP64
suffix:colon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_free_file_space
c_func
(paren
id|ip
comma
id|startoffset
comma
id|bf-&gt;l_len
comma
id|attr_flags
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_IOC_ALLOCSP
suffix:colon
r_case
id|XFS_IOC_ALLOCSP64
suffix:colon
r_case
id|XFS_IOC_FREESP
suffix:colon
r_case
id|XFS_IOC_FREESP64
suffix:colon
r_if
c_cond
(paren
id|startoffset
OG
id|fsize
)paren
(brace
id|error
op_assign
id|xfs_alloc_file_space
c_func
(paren
id|ip
comma
id|fsize
comma
id|startoffset
op_minus
id|fsize
comma
l_int|0
comma
id|attr_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
)brace
id|va.va_mask
op_assign
id|XFS_AT_SIZE
suffix:semicolon
id|va.va_size
op_assign
id|startoffset
suffix:semicolon
id|error
op_assign
id|xfs_setattr
c_func
(paren
id|bdp
comma
op_amp
id|va
comma
id|attr_flags
comma
id|credp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|clrprealloc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * update the inode timestamp, mode, and prealloc flag bits&n;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_WRITEID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_WRITEID_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* ASSERT(0); */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|attr_flags
op_amp
id|ATTR_DMI
)paren
op_eq
l_int|0
)paren
(brace
id|ip-&gt;i_d.di_mode
op_and_assign
op_complement
id|S_ISUID
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note that we don&squot;t have to worry about mandatory&n;&t;&t; * file locking being disabled here because we only&n;&t;&t; * clear the S_ISGID bit if the Group execute bit is&n;&t;&t; * on, but if it was on then mandatory locking wouldn&squot;t&n;&t;&t; * have been enabled.&n;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IXGRP
)paren
id|ip-&gt;i_d.di_mode
op_and_assign
op_complement
id|S_ISGID
suffix:semicolon
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|setprealloc
)paren
id|ip-&gt;i_d.di_flags
op_or_assign
id|XFS_DIFLAG_PREALLOC
suffix:semicolon
r_else
r_if
c_cond
(paren
id|clrprealloc
)paren
id|ip-&gt;i_d.di_flags
op_and_assign
op_complement
id|XFS_DIFLAG_PREALLOC
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|xfs_vnodeops
id|vnodeops_t
id|xfs_vnodeops
op_assign
(brace
id|BHV_IDENTITY_INIT
c_func
(paren
id|VN_BHV_XFS
comma
id|VNODE_POSITION_XFS
)paren
comma
dot
id|vop_open
op_assign
id|xfs_open
comma
dot
id|vop_read
op_assign
id|xfs_read
comma
macro_line|#ifdef HAVE_SENDFILE
dot
id|vop_sendfile
op_assign
id|xfs_sendfile
comma
macro_line|#endif
dot
id|vop_write
op_assign
id|xfs_write
comma
dot
id|vop_ioctl
op_assign
id|xfs_ioctl
comma
dot
id|vop_getattr
op_assign
id|xfs_getattr
comma
dot
id|vop_setattr
op_assign
id|xfs_setattr
comma
dot
id|vop_access
op_assign
id|xfs_access
comma
dot
id|vop_lookup
op_assign
id|xfs_lookup
comma
dot
id|vop_create
op_assign
id|xfs_create
comma
dot
id|vop_remove
op_assign
id|xfs_remove
comma
dot
id|vop_link
op_assign
id|xfs_link
comma
dot
id|vop_rename
op_assign
id|xfs_rename
comma
dot
id|vop_mkdir
op_assign
id|xfs_mkdir
comma
dot
id|vop_rmdir
op_assign
id|xfs_rmdir
comma
dot
id|vop_readdir
op_assign
id|xfs_readdir
comma
dot
id|vop_symlink
op_assign
id|xfs_symlink
comma
dot
id|vop_readlink
op_assign
id|xfs_readlink
comma
dot
id|vop_fsync
op_assign
id|xfs_fsync
comma
dot
id|vop_inactive
op_assign
id|xfs_inactive
comma
dot
id|vop_fid2
op_assign
id|xfs_fid2
comma
dot
id|vop_rwlock
op_assign
id|xfs_rwlock
comma
dot
id|vop_rwunlock
op_assign
id|xfs_rwunlock
comma
dot
id|vop_bmap
op_assign
id|xfs_bmap
comma
dot
id|vop_reclaim
op_assign
id|xfs_reclaim
comma
dot
id|vop_attr_get
op_assign
id|xfs_attr_get
comma
dot
id|vop_attr_set
op_assign
id|xfs_attr_set
comma
dot
id|vop_attr_remove
op_assign
id|xfs_attr_remove
comma
dot
id|vop_attr_list
op_assign
id|xfs_attr_list
comma
dot
id|vop_link_removed
op_assign
(paren
id|vop_link_removed_t
)paren
id|fs_noval
comma
dot
id|vop_vnode_change
op_assign
(paren
id|vop_vnode_change_t
)paren
id|fs_noval
comma
dot
id|vop_tosspages
op_assign
id|fs_tosspages
comma
dot
id|vop_flushinval_pages
op_assign
id|fs_flushinval_pages
comma
dot
id|vop_flush_pages
op_assign
id|fs_flush_pages
comma
dot
id|vop_release
op_assign
id|xfs_release
comma
dot
id|vop_iflush
op_assign
id|xfs_inode_flush
comma
)brace
suffix:semicolon
eof
