multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_trans_priv.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_trans_space.h&quot;
id|STATIC
r_void
id|xfs_trans_apply_sb_deltas
c_func
(paren
id|xfs_trans_t
op_star
)paren
suffix:semicolon
id|STATIC
id|uint
id|xfs_trans_count_vecs
c_func
(paren
id|xfs_trans_t
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_trans_fill_vecs
c_func
(paren
id|xfs_trans_t
op_star
comma
id|xfs_log_iovec_t
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_trans_uncommit
c_func
(paren
id|xfs_trans_t
op_star
comma
id|uint
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_trans_committed
c_func
(paren
id|xfs_trans_t
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_trans_chunk_committed
c_func
(paren
id|xfs_log_item_chunk_t
op_star
comma
id|xfs_lsn_t
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_trans_free
c_func
(paren
id|xfs_trans_t
op_star
)paren
suffix:semicolon
DECL|variable|xfs_trans_zone
id|kmem_zone_t
op_star
id|xfs_trans_zone
suffix:semicolon
multiline_comment|/*&n; * Initialize the precomputed transaction reservation values&n; * in the mount structure.&n; */
r_void
DECL|function|xfs_trans_init
id|xfs_trans_init
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_trans_reservations_t
op_star
id|resp
suffix:semicolon
id|resp
op_assign
op_amp
(paren
id|mp-&gt;m_reservations
)paren
suffix:semicolon
id|resp-&gt;tr_write
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_itruncate
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_rename
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_RENAME_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_link
op_assign
(paren
id|uint
)paren
id|XFS_CALC_LINK_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_remove
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_REMOVE_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_symlink
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_SYMLINK_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_create
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_CREATE_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_mkdir
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_MKDIR_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_ifree
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_IFREE_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_ichange
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_ICHANGE_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_growdata
op_assign
(paren
id|uint
)paren
id|XFS_CALC_GROWDATA_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_swrite
op_assign
(paren
id|uint
)paren
id|XFS_CALC_SWRITE_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_writeid
op_assign
(paren
id|uint
)paren
id|XFS_CALC_WRITEID_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_addafork
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_ADDAFORK_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_attrinval
op_assign
(paren
id|uint
)paren
id|XFS_CALC_ATTRINVAL_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_attrset
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_ATTRSET_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_attrrm
op_assign
(paren
id|uint
)paren
(paren
id|XFS_CALC_ATTRRM_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|XFS_DQUOT_LOGRES
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|resp-&gt;tr_clearagi
op_assign
(paren
id|uint
)paren
id|XFS_CALC_CLEAR_AGI_BUCKET_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_growrtalloc
op_assign
(paren
id|uint
)paren
id|XFS_CALC_GROWRTALLOC_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_growrtzero
op_assign
(paren
id|uint
)paren
id|XFS_CALC_GROWRTZERO_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|resp-&gt;tr_growrtfree
op_assign
(paren
id|uint
)paren
id|XFS_CALC_GROWRTFREE_LOG_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to allocate a transaction structure.&n; * The type parameter indicates the type of the transaction.  These&n; * are enumerated in xfs_trans.h.&n; *&n; * Dynamically allocate the transaction structure from the transaction&n; * zone, initialize it, and return it to the caller.&n; */
id|xfs_trans_t
op_star
DECL|function|xfs_trans_alloc
id|xfs_trans_alloc
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|type
)paren
(brace
id|xfs_check_frozen
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|XFS_FREEZE_TRANS
)paren
suffix:semicolon
r_return
(paren
id|_xfs_trans_alloc
c_func
(paren
id|mp
comma
id|type
)paren
)paren
suffix:semicolon
)brace
id|xfs_trans_t
op_star
DECL|function|_xfs_trans_alloc
id|_xfs_trans_alloc
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|type
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_trans_zone
op_ne
l_int|NULL
)paren
suffix:semicolon
id|tp
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_trans_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|tp-&gt;t_dqinfo
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the transaction structure.&n;&t; */
id|tp-&gt;t_magic
op_assign
id|XFS_TRANS_MAGIC
suffix:semicolon
id|tp-&gt;t_type
op_assign
id|type
suffix:semicolon
id|tp-&gt;t_mountp
op_assign
id|mp
suffix:semicolon
id|tp-&gt;t_items_free
op_assign
id|XFS_LIC_NUM_SLOTS
suffix:semicolon
id|tp-&gt;t_busy_free
op_assign
id|XFS_LBC_NUM_SLOTS
suffix:semicolon
id|XFS_LIC_INIT
c_func
(paren
op_amp
(paren
id|tp-&gt;t_items
)paren
)paren
suffix:semicolon
id|XFS_LBC_INIT
c_func
(paren
op_amp
(paren
id|tp-&gt;t_busy
)paren
)paren
suffix:semicolon
r_return
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to create a new transaction which will share the&n; * permanent log reservation of the given transaction.  The remaining&n; * unused block and rt extent reservations are also inherited.  This&n; * implies that the original transaction is no longer allowed to allocate&n; * blocks.  Locks and log items, however, are no inherited.  They must&n; * be added to the new transaction explicitly.&n; */
id|xfs_trans_t
op_star
DECL|function|xfs_trans_dup
id|xfs_trans_dup
c_func
(paren
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_trans_t
op_star
id|ntp
suffix:semicolon
id|ntp
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_trans_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the new transaction structure.&n;&t; */
id|ntp-&gt;t_magic
op_assign
id|XFS_TRANS_MAGIC
suffix:semicolon
id|ntp-&gt;t_type
op_assign
id|tp-&gt;t_type
suffix:semicolon
id|ntp-&gt;t_mountp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|ntp-&gt;t_items_free
op_assign
id|XFS_LIC_NUM_SLOTS
suffix:semicolon
id|ntp-&gt;t_busy_free
op_assign
id|XFS_LBC_NUM_SLOTS
suffix:semicolon
id|XFS_LIC_INIT
c_func
(paren
op_amp
(paren
id|ntp-&gt;t_items
)paren
)paren
suffix:semicolon
id|XFS_LBC_INIT
c_func
(paren
op_amp
(paren
id|ntp-&gt;t_busy
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
suffix:semicolon
macro_line|#if defined(XLOG_NOLOG) || defined(DEBUG)
id|ASSERT
c_func
(paren
op_logical_neg
id|xlog_debug
op_logical_or
id|tp-&gt;t_ticket
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
id|ASSERT
c_func
(paren
id|tp-&gt;t_ticket
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|ntp-&gt;t_flags
op_assign
id|XFS_TRANS_PERM_LOG_RES
op_or
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_RESERVE
)paren
suffix:semicolon
id|ntp-&gt;t_ticket
op_assign
id|tp-&gt;t_ticket
suffix:semicolon
id|ntp-&gt;t_blk_res
op_assign
id|tp-&gt;t_blk_res
op_minus
id|tp-&gt;t_blk_res_used
suffix:semicolon
id|tp-&gt;t_blk_res
op_assign
id|tp-&gt;t_blk_res_used
suffix:semicolon
id|ntp-&gt;t_rtx_res
op_assign
id|tp-&gt;t_rtx_res
op_minus
id|tp-&gt;t_rtx_res_used
suffix:semicolon
id|tp-&gt;t_rtx_res
op_assign
id|tp-&gt;t_rtx_res_used
suffix:semicolon
id|PFLAGS_DUP
c_func
(paren
op_amp
id|tp-&gt;t_pflags
comma
op_amp
id|ntp-&gt;t_pflags
)paren
suffix:semicolon
id|XFS_TRANS_DUP_DQINFO
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp
comma
id|ntp
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tp-&gt;t_mountp-&gt;m_active_trans
)paren
suffix:semicolon
r_return
id|ntp
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to reserve free disk blocks and log space for the&n; * given transaction.  This must be done before allocating any resources&n; * within the transaction.&n; *&n; * This will return ENOSPC if there are not enough blocks available.&n; * It will sleep waiting for available log space.&n; * The only valid value for the flags parameter is XFS_RES_LOG_PERM, which&n; * is used by long running transactions.  If any one of the reservations&n; * fails then they will all be backed out.&n; *&n; * This does not do quota reservations. That typically is done by the&n; * caller afterwards.&n; */
r_int
DECL|function|xfs_trans_reserve
id|xfs_trans_reserve
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|uint
id|blocks
comma
id|uint
id|logspace
comma
id|uint
id|rtextents
comma
id|uint
id|flags
comma
id|uint
id|logcount
)paren
(brace
r_int
id|log_flags
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|rsvd
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|rsvd
op_assign
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_RESERVE
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/* Mark this thread as being in a transaction */
id|PFLAGS_SET_FSTRANS
c_func
(paren
op_amp
id|tp-&gt;t_pflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attempt to reserve the needed disk blocks by decrementing&n;&t; * the number needed from the number available.  This will&n;&t; * fail if the count would go below zero.&n;&t; */
r_if
c_cond
(paren
id|blocks
OG
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_mod_incore_sb
c_func
(paren
id|tp-&gt;t_mountp
comma
id|XFS_SBS_FDBLOCKS
comma
op_minus
id|blocks
comma
id|rsvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|PFLAGS_RESTORE
c_func
(paren
op_amp
id|tp-&gt;t_pflags
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
)paren
suffix:semicolon
)brace
id|tp-&gt;t_blk_res
op_add_assign
id|blocks
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reserve the log space needed for this transaction.&n;&t; */
r_if
c_cond
(paren
id|logspace
OG
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|tp-&gt;t_log_res
op_eq
l_int|0
)paren
op_logical_or
(paren
id|tp-&gt;t_log_res
op_eq
id|logspace
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|tp-&gt;t_log_count
op_eq
l_int|0
)paren
op_logical_or
(paren
id|tp-&gt;t_log_count
op_eq
id|logcount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
(brace
id|log_flags
op_assign
id|XFS_LOG_PERM_RESERV
suffix:semicolon
id|tp-&gt;t_flags
op_or_assign
id|XFS_TRANS_PERM_LOG_RES
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|tp-&gt;t_ticket
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
)paren
suffix:semicolon
id|log_flags
op_assign
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_log_reserve
c_func
(paren
id|tp-&gt;t_mountp
comma
id|logspace
comma
id|logcount
comma
op_amp
id|tp-&gt;t_ticket
comma
id|XFS_TRANSACTION
comma
id|log_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|undo_blocks
suffix:semicolon
)brace
id|tp-&gt;t_log_res
op_assign
id|logspace
suffix:semicolon
id|tp-&gt;t_log_count
op_assign
id|logcount
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attempt to reserve the needed realtime extents by decrementing&n;&t; * the number needed from the number available.  This will&n;&t; * fail if the count would go below zero.&n;&t; */
r_if
c_cond
(paren
id|rtextents
OG
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_mod_incore_sb
c_func
(paren
id|tp-&gt;t_mountp
comma
id|XFS_SBS_FREXTENTS
comma
op_minus
id|rtextents
comma
id|rsvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|undo_log
suffix:semicolon
)brace
id|tp-&gt;t_rtx_res
op_add_assign
id|rtextents
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Error cases jump to one of these labels to undo any&n;&t; * reservations which have already been performed.&n;&t; */
id|undo_log
suffix:colon
r_if
c_cond
(paren
id|logspace
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
(brace
id|log_flags
op_assign
id|XFS_LOG_REL_PERM_RESERV
suffix:semicolon
)brace
r_else
(brace
id|log_flags
op_assign
l_int|0
suffix:semicolon
)brace
id|xfs_log_done
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp-&gt;t_ticket
comma
l_int|NULL
comma
id|log_flags
)paren
suffix:semicolon
id|tp-&gt;t_ticket
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;t_log_res
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;t_flags
op_and_assign
op_complement
id|XFS_TRANS_PERM_LOG_RES
suffix:semicolon
)brace
id|undo_blocks
suffix:colon
r_if
c_cond
(paren
id|blocks
OG
l_int|0
)paren
(brace
(paren
r_void
)paren
id|xfs_mod_incore_sb
c_func
(paren
id|tp-&gt;t_mountp
comma
id|XFS_SBS_FDBLOCKS
comma
id|blocks
comma
id|rsvd
)paren
suffix:semicolon
id|tp-&gt;t_blk_res
op_assign
l_int|0
suffix:semicolon
)brace
id|PFLAGS_RESTORE
c_func
(paren
op_amp
id|tp-&gt;t_pflags
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to set the a callback to be called when the given&n; * transaction is committed to disk.  The transaction pointer and the&n; * argument pointer will be passed to the callback routine.&n; *&n; * Only one callback can be associated with any single transaction.&n; */
r_void
DECL|function|xfs_trans_callback
id|xfs_trans_callback
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_trans_callback_t
id|callback
comma
r_void
op_star
id|arg
)paren
(brace
id|ASSERT
c_func
(paren
id|tp-&gt;t_callback
op_eq
l_int|NULL
)paren
suffix:semicolon
id|tp-&gt;t_callback
op_assign
id|callback
suffix:semicolon
id|tp-&gt;t_callarg
op_assign
id|arg
suffix:semicolon
)brace
multiline_comment|/*&n; * Record the indicated change to the given field for application&n; * to the file system&squot;s superblock when the transaction commits.&n; * For now, just store the change in the transaction structure.&n; *&n; * Mark the transaction structure to indicate that the superblock&n; * needs to be updated before committing.&n; */
r_void
DECL|function|xfs_trans_mod_sb
id|xfs_trans_mod_sb
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|uint
id|field
comma
r_int
id|delta
)paren
(brace
r_switch
c_cond
(paren
id|field
)paren
(brace
r_case
id|XFS_TRANS_SB_ICOUNT
suffix:colon
id|ASSERT
c_func
(paren
id|delta
OG
l_int|0
)paren
suffix:semicolon
id|tp-&gt;t_icount_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_IFREE
suffix:colon
id|tp-&gt;t_ifree_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_FDBLOCKS
suffix:colon
multiline_comment|/*&n;&t;&t; * Track the number of blocks allocated in the&n;&t;&t; * transaction.  Make sure it does not exceed the&n;&t;&t; * number reserved.&n;&t;&t; */
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
(brace
id|tp-&gt;t_blk_res_used
op_add_assign
(paren
id|uint
)paren
op_minus
id|delta
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp-&gt;t_blk_res_used
op_le
id|tp-&gt;t_blk_res
)paren
suffix:semicolon
)brace
id|tp-&gt;t_fdblocks_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_RES_FDBLOCKS
suffix:colon
multiline_comment|/*&n;&t;&t; * The allocation has already been applied to the&n;&t;&t; * in-core superblock&squot;s counter.  This should only&n;&t;&t; * be applied to the on-disk superblock.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|delta
OL
l_int|0
)paren
suffix:semicolon
id|tp-&gt;t_res_fdblocks_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_FREXTENTS
suffix:colon
multiline_comment|/*&n;&t;&t; * Track the number of blocks allocated in the&n;&t;&t; * transaction.  Make sure it does not exceed the&n;&t;&t; * number reserved.&n;&t;&t; */
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
(brace
id|tp-&gt;t_rtx_res_used
op_add_assign
(paren
id|uint
)paren
op_minus
id|delta
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp-&gt;t_rtx_res_used
op_le
id|tp-&gt;t_rtx_res
)paren
suffix:semicolon
)brace
id|tp-&gt;t_frextents_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_RES_FREXTENTS
suffix:colon
multiline_comment|/*&n;&t;&t; * The allocation has already been applied to the&n;&t;&t; * in-core superblocks&squot;s counter.  This should only&n;&t;&t; * be applied to the on-disk superblock.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|delta
OL
l_int|0
)paren
suffix:semicolon
id|tp-&gt;t_res_frextents_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_DBLOCKS
suffix:colon
id|ASSERT
c_func
(paren
id|delta
OG
l_int|0
)paren
suffix:semicolon
id|tp-&gt;t_dblocks_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_AGCOUNT
suffix:colon
id|ASSERT
c_func
(paren
id|delta
OG
l_int|0
)paren
suffix:semicolon
id|tp-&gt;t_agcount_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_IMAXPCT
suffix:colon
id|tp-&gt;t_imaxpct_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_REXTSIZE
suffix:colon
id|tp-&gt;t_rextsize_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_RBMBLOCKS
suffix:colon
id|tp-&gt;t_rbmblocks_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_RBLOCKS
suffix:colon
id|tp-&gt;t_rblocks_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_REXTENTS
suffix:colon
id|tp-&gt;t_rextents_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_TRANS_SB_REXTSLOG
suffix:colon
id|tp-&gt;t_rextslog_delta
op_add_assign
id|delta
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tp-&gt;t_flags
op_or_assign
(paren
id|XFS_TRANS_SB_DIRTY
op_or
id|XFS_TRANS_DIRTY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_trans_apply_sb_deltas() is called from the commit code&n; * to bring the superblock buffer into the current transaction&n; * and modify it as requested by earlier calls to xfs_trans_mod_sb().&n; *&n; * For now we just look at each field allowed to change and change&n; * it if necessary.&n; */
id|STATIC
r_void
DECL|function|xfs_trans_apply_sb_deltas
id|xfs_trans_apply_sb_deltas
c_func
(paren
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|whole
op_assign
l_int|0
suffix:semicolon
id|bp
op_assign
id|xfs_trans_getsb
c_func
(paren
id|tp
comma
id|tp-&gt;t_mountp
comma
l_int|0
)paren
suffix:semicolon
id|sbp
op_assign
id|XFS_BUF_TO_SBP
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check that superblock mods match the mods made to AGF counters.&n;&t; */
id|ASSERT
c_func
(paren
(paren
id|tp-&gt;t_fdblocks_delta
op_plus
id|tp-&gt;t_res_fdblocks_delta
)paren
op_eq
(paren
id|tp-&gt;t_ag_freeblks_delta
op_plus
id|tp-&gt;t_ag_flist_delta
op_plus
id|tp-&gt;t_ag_btree_delta
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;t_icount_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_icount
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_icount_delta
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_ifree_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_ifree
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_ifree_delta
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_fdblocks_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_fdblocks
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_fdblocks_delta
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_res_fdblocks_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_fdblocks
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_res_fdblocks_delta
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_frextents_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_frextents
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_frextents_delta
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_dblocks_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_dblocks
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_dblocks_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_agcount_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_agcount
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_agcount_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_imaxpct_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_imax_pct
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_imaxpct_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rextsize_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_rextsize
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_rextsize_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rbmblocks_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_rbmblocks
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_rbmblocks_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rblocks_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_rblocks
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_rblocks_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rextents_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_rextents
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_rextents_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rextslog_delta
op_ne
l_int|0
)paren
(brace
id|INT_MOD
c_func
(paren
id|sbp-&gt;sb_rextslog
comma
id|ARCH_CONVERT
comma
id|tp-&gt;t_rextslog_delta
)paren
suffix:semicolon
id|whole
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|whole
)paren
multiline_comment|/*&n;&t;&t; * Log the whole thing, the fields are discontiguous.&n;&t;&t; */
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_sb_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t; * Since all the modifiable fields are contiguous, we&n;&t;&t; * can get away with this.&n;&t;&t; */
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_icount
)paren
comma
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_frextents
)paren
op_plus
r_sizeof
(paren
id|sbp-&gt;sb_frextents
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|XFS_MTOVFS
c_func
(paren
id|tp-&gt;t_mountp
)paren
op_member_access_from_pointer
id|vfs_super-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_trans_unreserve_and_mod_sb() is called to release unused&n; * reservations and apply superblock counter changes to the in-core&n; * superblock.&n; *&n; * This is done efficiently with a single call to xfs_mod_incore_sb_batch().&n; */
r_void
DECL|function|xfs_trans_unreserve_and_mod_sb
id|xfs_trans_unreserve_and_mod_sb
c_func
(paren
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_mod_sb_t
id|msb
(braket
l_int|14
)braket
suffix:semicolon
multiline_comment|/* If you add cases, add entries */
id|xfs_mod_sb_t
op_star
id|msbp
suffix:semicolon
multiline_comment|/* REFERENCED */
r_int
id|error
suffix:semicolon
r_int
id|rsvd
suffix:semicolon
id|msbp
op_assign
id|msb
suffix:semicolon
id|rsvd
op_assign
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_RESERVE
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Release any reserved blocks.  Any that were allocated&n;&t; * will be taken back again by fdblocks_delta below.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_blk_res
OG
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_FDBLOCKS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
id|tp-&gt;t_blk_res
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release any reserved real time extents .  Any that were&n;&t; * allocated will be taken back again by frextents_delta below.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_rtx_res
OG
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_FREXTENTS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
id|tp-&gt;t_rtx_res
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Apply any superblock modifications to the in-core version.&n;&t; * The t_res_fdblocks_delta and t_res_frextents_delta fields are&n;&t; * explicity NOT applied to the in-core superblock.&n;&t; * The idea is that that has already been done.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_SB_DIRTY
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;t_icount_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_ICOUNT
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_icount_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_ifree_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_IFREE
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_ifree_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_fdblocks_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_FDBLOCKS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_fdblocks_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_frextents_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_FREXTENTS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_frextents_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_dblocks_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_DBLOCKS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_dblocks_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_agcount_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_AGCOUNT
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_agcount_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_imaxpct_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_IMAX_PCT
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_imaxpct_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rextsize_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_REXTSIZE
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_rextsize_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rbmblocks_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_RBMBLOCKS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_rbmblocks_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rblocks_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_RBLOCKS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_rblocks_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rextents_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_REXTENTS
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_rextents_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;t_rextslog_delta
op_ne
l_int|0
)paren
(brace
id|msbp-&gt;msb_field
op_assign
id|XFS_SBS_REXTSLOG
suffix:semicolon
id|msbp-&gt;msb_delta
op_assign
(paren
r_int
)paren
id|tp-&gt;t_rextslog_delta
suffix:semicolon
id|msbp
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we need to change anything, do it.&n;&t; */
r_if
c_cond
(paren
id|msbp
OG
id|msb
)paren
(brace
id|error
op_assign
id|xfs_mod_incore_sb_batch
c_func
(paren
id|tp-&gt;t_mountp
comma
id|msb
comma
(paren
id|uint
)paren
(paren
id|msbp
op_minus
id|msb
)paren
comma
id|rsvd
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_eq
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * xfs_trans_commit&n; *&n; * Commit the given transaction to the log a/synchronously.&n; *&n; * XFS disk error handling mechanism is not based on a typical&n; * transaction abort mechanism. Logically after the filesystem&n; * gets marked &squot;SHUTDOWN&squot;, we can&squot;t let any new transactions&n; * be durable - ie. committed to disk - because some metadata might&n; * be inconsistent. In such cases, this returns an error, and the&n; * caller may assume that all locked objects joined to the transaction&n; * have already been unlocked as if the commit had succeeded.&n; * It&squot;s illegal to reference the transaction structure after this call.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|xfs_trans_commit
id|xfs_trans_commit
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|uint
id|flags
comma
id|xfs_lsn_t
op_star
id|commit_lsn_p
)paren
(brace
id|xfs_log_iovec_t
op_star
id|log_vector
suffix:semicolon
r_int
id|nvec
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_lsn_t
id|commit_lsn
suffix:semicolon
multiline_comment|/* REFERENCED */
r_int
id|error
suffix:semicolon
r_int
id|log_flags
suffix:semicolon
r_int
id|sync
suffix:semicolon
DECL|macro|XFS_TRANS_LOGVEC_COUNT
mdefine_line|#define&t;XFS_TRANS_LOGVEC_COUNT&t;16
id|xfs_log_iovec_t
id|log_vector_fast
(braket
id|XFS_TRANS_LOGVEC_COUNT
)braket
suffix:semicolon
macro_line|#if defined(XLOG_NOLOG) || defined(DEBUG)
r_static
id|xfs_lsn_t
id|trans_lsn
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_void
op_star
id|commit_iclog
suffix:semicolon
r_int
id|shutdown
suffix:semicolon
id|commit_lsn
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Determine whether this commit is releasing a permanent&n;&t; * log reservation or not.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_TRANS_RELEASE_LOG_RES
)paren
(brace
id|ASSERT
c_func
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
suffix:semicolon
id|log_flags
op_assign
id|XFS_LOG_REL_PERM_RESERV
suffix:semicolon
)brace
r_else
(brace
id|log_flags
op_assign
l_int|0
suffix:semicolon
)brace
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * If there is nothing to be logged by the transaction,&n;&t; * then unlock all of the items associated with the&n;&t; * transaction and free the transaction structure.&n;&t; * Also make sure to return any reserved blocks to&n;&t; * the free pool.&n;&t; */
id|shut_us_down
suffix:colon
id|shutdown
op_assign
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
ques
c_cond
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DIRTY
)paren
op_logical_or
id|shutdown
)paren
(brace
id|xfs_trans_unreserve_and_mod_sb
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * It is indeed possible for the transaction to be&n;&t;&t; * not dirty but the dqinfo portion to be. All that&n;&t;&t; * means is that we have some (non-persistent) quota&n;&t;&t; * reservations that need to be unreserved.&n;&t;&t; */
id|XFS_TRANS_UNRESERVE_AND_MOD_DQUOTS
c_func
(paren
id|mp
comma
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;t_ticket
)paren
(brace
id|commit_lsn
op_assign
id|xfs_log_done
c_func
(paren
id|mp
comma
id|tp-&gt;t_ticket
comma
l_int|NULL
comma
id|log_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_lsn
op_eq
op_minus
l_int|1
op_logical_and
op_logical_neg
id|shutdown
)paren
id|shutdown
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|PFLAGS_RESTORE
c_func
(paren
op_amp
id|tp-&gt;t_pflags
)paren
suffix:semicolon
id|xfs_trans_free_items
c_func
(paren
id|tp
comma
id|shutdown
ques
c_cond
id|XFS_TRANS_ABORT
suffix:colon
l_int|0
)paren
suffix:semicolon
id|xfs_trans_free_busy
c_func
(paren
id|tp
)paren
suffix:semicolon
id|xfs_trans_free
c_func
(paren
id|tp
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_trans_empty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_lsn_p
)paren
op_star
id|commit_lsn_p
op_assign
id|commit_lsn
suffix:semicolon
r_return
(paren
id|shutdown
)paren
suffix:semicolon
)brace
macro_line|#if defined(XLOG_NOLOG) || defined(DEBUG)
id|ASSERT
c_func
(paren
op_logical_neg
id|xlog_debug
op_logical_or
id|tp-&gt;t_ticket
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#else
id|ASSERT
c_func
(paren
id|tp-&gt;t_ticket
op_ne
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If we need to update the superblock, then do it now.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_SB_DIRTY
)paren
(brace
id|xfs_trans_apply_sb_deltas
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|XFS_TRANS_APPLY_DQUOT_DELTAS
c_func
(paren
id|mp
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ask each log item how many log_vector entries it will&n;&t; * need so we can figure out how many to allocate.&n;&t; * Try to avoid the kmem_alloc() call in the common case&n;&t; * by using a vector from the stack when it fits.&n;&t; */
id|nvec
op_assign
id|xfs_trans_count_vecs
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nvec
op_eq
l_int|0
)paren
(brace
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_LOG_IO_ERROR
)paren
suffix:semicolon
r_goto
id|shut_us_down
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nvec
op_le
id|XFS_TRANS_LOGVEC_COUNT
)paren
(brace
id|log_vector
op_assign
id|log_vector_fast
suffix:semicolon
)brace
r_else
(brace
id|log_vector
op_assign
(paren
id|xfs_log_iovec_t
op_star
)paren
id|kmem_alloc
c_func
(paren
id|nvec
op_star
r_sizeof
(paren
id|xfs_log_iovec_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the log_vector and pin the logged items, and&n;&t; * then write the transaction to the log.&n;&t; */
id|xfs_trans_fill_vecs
c_func
(paren
id|tp
comma
id|log_vector
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Ignore errors here. xfs_log_done would do the right thing.&n;&t; * We need to put the ticket, etc. away.&n;&t; */
id|error
op_assign
id|xfs_log_write
c_func
(paren
id|mp
comma
id|log_vector
comma
id|nvec
comma
id|tp-&gt;t_ticket
comma
op_amp
(paren
id|tp-&gt;t_lsn
)paren
)paren
suffix:semicolon
macro_line|#if defined(XLOG_NOLOG) || defined(DEBUG)
r_if
c_cond
(paren
id|xlog_debug
)paren
(brace
id|commit_lsn
op_assign
id|xfs_log_done
c_func
(paren
id|mp
comma
id|tp-&gt;t_ticket
comma
op_amp
id|commit_iclog
comma
id|log_flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|commit_lsn
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;t_lsn
op_assign
id|trans_lsn
op_increment
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n;&t; * This is the regular case.  At this point (after the call finishes),&n;&t; * the transaction is committed incore and could go out to disk at&n;&t; * any time.  However, all the items associated with the transaction&n;&t; * are still locked and pinned in memory.&n;&t; */
id|commit_lsn
op_assign
id|xfs_log_done
c_func
(paren
id|mp
comma
id|tp-&gt;t_ticket
comma
op_amp
id|commit_iclog
comma
id|log_flags
)paren
suffix:semicolon
macro_line|#endif
id|tp-&gt;t_commit_lsn
op_assign
id|commit_lsn
suffix:semicolon
r_if
c_cond
(paren
id|nvec
OG
id|XFS_TRANS_LOGVEC_COUNT
)paren
(brace
id|kmem_free
c_func
(paren
id|log_vector
comma
id|nvec
op_star
r_sizeof
(paren
id|xfs_log_iovec_t
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|commit_lsn_p
)paren
op_star
id|commit_lsn_p
op_assign
id|commit_lsn
suffix:semicolon
multiline_comment|/*&n;&t; * If we got a log write error. Unpin the logitems that we&n;&t; * had pinned, clean up, free trans structure, and return error.&n;&t; */
r_if
c_cond
(paren
id|error
op_logical_or
id|commit_lsn
op_eq
op_minus
l_int|1
)paren
(brace
id|PFLAGS_RESTORE
c_func
(paren
op_amp
id|tp-&gt;t_pflags
)paren
suffix:semicolon
id|xfs_trans_uncommit
c_func
(paren
id|tp
comma
id|flags
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Once the transaction has committed, unused&n;&t; * reservations need to be released and changes to&n;&t; * the superblock need to be reflected in the in-core&n;&t; * version.  Do that now.&n;&t; */
id|xfs_trans_unreserve_and_mod_sb
c_func
(paren
id|tp
)paren
suffix:semicolon
id|sync
op_assign
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_SYNC
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the LM to call the transaction completion routine&n;&t; * when the log write with LSN commit_lsn completes (e.g.&n;&t; * when the transaction commit really hits the on-disk log).&n;&t; * After this call we cannot reference tp, because the call&n;&t; * can happen at any time and the call will free the transaction&n;&t; * structure pointed to by tp.  The only case where we call&n;&t; * the completion routine (xfs_trans_committed) directly is&n;&t; * if the log is turned off on a debug kernel or we&squot;re&n;&t; * running in simulation mode (the log is explicitly turned&n;&t; * off).&n;&t; */
id|tp-&gt;t_logcb.cb_func
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
comma
r_int
)paren
)paren
id|xfs_trans_committed
suffix:semicolon
id|tp-&gt;t_logcb.cb_arg
op_assign
id|tp
suffix:semicolon
multiline_comment|/* We need to pass the iclog buffer which was used for the&n;&t; * transaction commit record into this function, and attach&n;&t; * the callback to it. The callback must be attached before&n;&t; * the items are unlocked to avoid racing with other threads&n;&t; * waiting for an item to unlock.&n;&t; */
id|error
op_assign
id|xfs_log_notify
c_func
(paren
id|mp
comma
id|commit_iclog
comma
op_amp
(paren
id|tp-&gt;t_logcb
)paren
)paren
suffix:semicolon
multiline_comment|/* mark this thread as no longer being in a transaction */
id|PFLAGS_RESTORE
c_func
(paren
op_amp
id|tp-&gt;t_pflags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Once all the items of the transaction have been copied&n;&t; * to the in core log and the callback is attached, the&n;&t; * items can be unlocked.&n;&t; *&n;&t; * This will free descriptors pointing to items which were&n;&t; * not logged since there is nothing more to do with them.&n;&t; * For items which were logged, we will keep pointers to them&n;&t; * so they can be unpinned after the transaction commits to disk.&n;&t; * This will also stamp each modified meta-data item with&n;&t; * the commit lsn of this transaction for dependency tracking&n;&t; * purposes.&n;&t; */
id|xfs_trans_unlock_items
c_func
(paren
id|tp
comma
id|commit_lsn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that the xfs_trans_committed callback has been attached,&n;&t; * and the items are released we can finally allow the iclog to&n;&t; * go to disk.&n;&t; */
id|error
op_assign
id|xfs_log_release_iclog
c_func
(paren
id|mp
comma
id|commit_iclog
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the transaction needs to be synchronous, then force the&n;&t; * log out now and wait for it.&n;&t; */
r_if
c_cond
(paren
id|sync
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|xfs_log_force
c_func
(paren
id|mp
comma
id|commit_lsn
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_trans_sync
)paren
suffix:semicolon
)brace
r_else
(brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_trans_async
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Total up the number of log iovecs needed to commit this&n; * transaction.  The transaction itself needs one for the&n; * transaction header.  Ask each dirty item in turn how many&n; * it needs to get the total.&n; */
id|STATIC
id|uint
DECL|function|xfs_trans_count_vecs
id|xfs_trans_count_vecs
c_func
(paren
id|xfs_trans_t
op_star
id|tp
)paren
(brace
r_int
id|nvecs
suffix:semicolon
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|nvecs
op_assign
l_int|1
suffix:semicolon
id|lidp
op_assign
id|xfs_trans_first_item
c_func
(paren
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lidp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* In the non-debug case we need to start bailing out if we&n;&t; * didn&squot;t find a log_item here, return zero and let trans_commit&n;&t; * deal with it.&n;&t; */
r_if
c_cond
(paren
id|lidp
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|lidp
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip items which aren&squot;t dirty in this transaction.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_DIRTY
)paren
)paren
(brace
id|lidp
op_assign
id|xfs_trans_next_item
c_func
(paren
id|tp
comma
id|lidp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|lidp-&gt;lid_size
op_assign
id|IOP_SIZE
c_func
(paren
id|lidp-&gt;lid_item
)paren
suffix:semicolon
id|nvecs
op_add_assign
id|lidp-&gt;lid_size
suffix:semicolon
id|lidp
op_assign
id|xfs_trans_next_item
c_func
(paren
id|tp
comma
id|lidp
)paren
suffix:semicolon
)brace
r_return
id|nvecs
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from the trans_commit code when we notice that&n; * the filesystem is in the middle of a forced shutdown.&n; */
id|STATIC
r_void
DECL|function|xfs_trans_uncommit
id|xfs_trans_uncommit
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|uint
id|flags
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
r_for
c_loop
(paren
id|lidp
op_assign
id|xfs_trans_first_item
c_func
(paren
id|tp
)paren
suffix:semicolon
id|lidp
op_ne
l_int|NULL
suffix:semicolon
id|lidp
op_assign
id|xfs_trans_next_item
c_func
(paren
id|tp
comma
id|lidp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Unpin all but those that aren&squot;t dirty.&n;&t;&t; */
r_if
c_cond
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_DIRTY
)paren
id|IOP_UNPIN_REMOVE
c_func
(paren
id|lidp-&gt;lid_item
comma
id|tp
)paren
suffix:semicolon
)brace
id|xfs_trans_unreserve_and_mod_sb
c_func
(paren
id|tp
)paren
suffix:semicolon
id|XFS_TRANS_UNRESERVE_AND_MOD_DQUOTS
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp
)paren
suffix:semicolon
id|xfs_trans_free_items
c_func
(paren
id|tp
comma
id|flags
)paren
suffix:semicolon
id|xfs_trans_free_busy
c_func
(paren
id|tp
)paren
suffix:semicolon
id|xfs_trans_free
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fill in the vector with pointers to data to be logged&n; * by this transaction.  The transaction header takes&n; * the first vector, and then each dirty item takes the&n; * number of vectors it indicated it needed in xfs_trans_count_vecs().&n; *&n; * As each item fills in the entries it needs, also pin the item&n; * so that it cannot be flushed out until the log write completes.&n; */
id|STATIC
r_void
DECL|function|xfs_trans_fill_vecs
id|xfs_trans_fill_vecs
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_log_iovec_t
op_star
id|log_vector
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_log_iovec_t
op_star
id|vecp
suffix:semicolon
id|uint
id|nitems
suffix:semicolon
multiline_comment|/*&n;&t; * Skip over the entry for the transaction header, we&squot;ll&n;&t; * fill that in at the end.&n;&t; */
id|vecp
op_assign
id|log_vector
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* pointer arithmetic */
id|nitems
op_assign
l_int|0
suffix:semicolon
id|lidp
op_assign
id|xfs_trans_first_item
c_func
(paren
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lidp
op_ne
l_int|NULL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lidp
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip items which aren&squot;t dirty in this transaction.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_DIRTY
)paren
)paren
(brace
id|lidp
op_assign
id|xfs_trans_next_item
c_func
(paren
id|tp
comma
id|lidp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The item may be marked dirty but not log anything.&n;&t;&t; * This can be used to get called when a transaction&n;&t;&t; * is committed.&n;&t;&t; */
r_if
c_cond
(paren
id|lidp-&gt;lid_size
)paren
(brace
id|nitems
op_increment
suffix:semicolon
)brace
id|IOP_FORMAT
c_func
(paren
id|lidp-&gt;lid_item
comma
id|vecp
)paren
suffix:semicolon
id|vecp
op_add_assign
id|lidp-&gt;lid_size
suffix:semicolon
multiline_comment|/* pointer arithmetic */
id|IOP_PIN
c_func
(paren
id|lidp-&gt;lid_item
)paren
suffix:semicolon
id|lidp
op_assign
id|xfs_trans_next_item
c_func
(paren
id|tp
comma
id|lidp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now that we&squot;ve counted the number of items in this&n;&t; * transaction, fill in the transaction header.&n;&t; */
id|tp-&gt;t_header.th_magic
op_assign
id|XFS_TRANS_HEADER_MAGIC
suffix:semicolon
id|tp-&gt;t_header.th_type
op_assign
id|tp-&gt;t_type
suffix:semicolon
id|tp-&gt;t_header.th_num_items
op_assign
id|nitems
suffix:semicolon
id|log_vector-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
op_amp
id|tp-&gt;t_header
suffix:semicolon
id|log_vector-&gt;i_len
op_assign
r_sizeof
(paren
id|xfs_trans_header_t
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlock all of the transaction&squot;s items and free the transaction.&n; * The transaction must not have modified any of its items, because&n; * there is no way to restore them to their previous state.&n; *&n; * If the transaction has made a log reservation, make sure to release&n; * it as well.&n; */
r_void
DECL|function|xfs_trans_cancel
id|xfs_trans_cancel
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
r_int
id|flags
)paren
(brace
r_int
id|log_flags
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * See if the caller is being too lazy to figure out if&n;&t; * the transaction really needs an abort.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_TRANS_ABORT
)paren
op_logical_and
op_logical_neg
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DIRTY
)paren
)paren
id|flags
op_and_assign
op_complement
id|XFS_TRANS_ABORT
suffix:semicolon
multiline_comment|/*&n;&t; * See if the caller is relying on us to shut down the&n;&t; * filesystem.  This happens in paths where we detect&n;&t; * corruption and decide to give up.&n;&t; */
r_if
c_cond
(paren
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DIRTY
)paren
op_logical_and
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|tp-&gt;t_mountp
)paren
)paren
id|xfs_force_shutdown
c_func
(paren
id|tp-&gt;t_mountp
comma
id|XFS_CORRUPT_INCORE
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_TRANS_ABORT
)paren
)paren
(brace
id|licp
op_assign
op_amp
(paren
id|tp-&gt;t_items
)paren
suffix:semicolon
r_while
c_loop
(paren
id|licp
op_ne
l_int|NULL
)paren
(brace
id|lidp
op_assign
id|licp-&gt;lic_descs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
comma
id|lidp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|lip
op_assign
id|lidp-&gt;lid_item
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|tp-&gt;t_mountp
)paren
)paren
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lip-&gt;li_type
op_eq
id|XFS_LI_EFD
)paren
)paren
suffix:semicolon
)brace
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
)brace
)brace
macro_line|#endif
id|xfs_trans_unreserve_and_mod_sb
c_func
(paren
id|tp
)paren
suffix:semicolon
id|XFS_TRANS_UNRESERVE_AND_MOD_DQUOTS
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;t_ticket
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_TRANS_RELEASE_LOG_RES
)paren
(brace
id|ASSERT
c_func
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
suffix:semicolon
id|log_flags
op_assign
id|XFS_LOG_REL_PERM_RESERV
suffix:semicolon
)brace
r_else
(brace
id|log_flags
op_assign
l_int|0
suffix:semicolon
)brace
id|xfs_log_done
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp-&gt;t_ticket
comma
l_int|NULL
comma
id|log_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* mark this thread as no longer being in a transaction */
id|PFLAGS_RESTORE
c_func
(paren
op_amp
id|tp-&gt;t_pflags
)paren
suffix:semicolon
id|xfs_trans_free_items
c_func
(paren
id|tp
comma
id|flags
)paren
suffix:semicolon
id|xfs_trans_free_busy
c_func
(paren
id|tp
)paren
suffix:semicolon
id|xfs_trans_free
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the transaction structure.  If there is more clean up&n; * to do when the structure is freed, add it here.&n; */
id|STATIC
r_void
DECL|function|xfs_trans_free
id|xfs_trans_free
c_func
(paren
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|tp-&gt;t_mountp-&gt;m_active_trans
)paren
suffix:semicolon
id|XFS_TRANS_FREE_DQINFO
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp
)paren
suffix:semicolon
id|kmem_zone_free
c_func
(paren
id|xfs_trans_zone
comma
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * THIS SHOULD BE REWRITTEN TO USE xfs_trans_next_item().&n; *&n; * This is typically called by the LM when a transaction has been fully&n; * committed to disk.  It needs to unpin the items which have&n; * been logged by the transaction and update their positions&n; * in the AIL if necessary.&n; * This also gets called when the transactions didn&squot;t get written out&n; * because of an I/O error. Abortflag &amp; XFS_LI_ABORTED is set then.&n; *&n; * Call xfs_trans_chunk_committed() to process the items in&n; * each chunk.&n; */
id|STATIC
r_void
DECL|function|xfs_trans_committed
id|xfs_trans_committed
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
r_int
id|abortflag
)paren
(brace
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_log_item_chunk_t
op_star
id|next_licp
suffix:semicolon
id|xfs_log_busy_chunk_t
op_star
id|lbcp
suffix:semicolon
id|xfs_log_busy_slot_t
op_star
id|lbsp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Call the transaction&squot;s completion callback if there&n;&t; * is one.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_callback
op_ne
l_int|NULL
)paren
(brace
id|tp
op_member_access_from_pointer
id|t_callback
c_func
(paren
id|tp
comma
id|tp-&gt;t_callarg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Special case the chunk embedded in the transaction.&n;&t; */
id|licp
op_assign
op_amp
(paren
id|tp-&gt;t_items
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
)paren
(brace
id|xfs_trans_chunk_committed
c_func
(paren
id|licp
comma
id|tp-&gt;t_lsn
comma
id|abortflag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Process the items in each chunk in turn.&n;&t; */
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
r_while
c_loop
(paren
id|licp
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
suffix:semicolon
id|xfs_trans_chunk_committed
c_func
(paren
id|licp
comma
id|tp-&gt;t_lsn
comma
id|abortflag
)paren
suffix:semicolon
id|next_licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
id|kmem_free
c_func
(paren
id|licp
comma
r_sizeof
(paren
id|xfs_log_item_chunk_t
)paren
)paren
suffix:semicolon
id|licp
op_assign
id|next_licp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear all the per-AG busy list items listed in this transaction&n;&t; */
id|lbcp
op_assign
op_amp
id|tp-&gt;t_busy
suffix:semicolon
r_while
c_loop
(paren
id|lbcp
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|lbsp
op_assign
id|lbcp-&gt;lbc_busy
suffix:semicolon
id|i
OL
id|lbcp-&gt;lbc_unused
suffix:semicolon
id|i
op_increment
comma
id|lbsp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_LBC_ISFREE
c_func
(paren
id|lbcp
comma
id|i
)paren
)paren
(brace
id|xfs_alloc_clear_busy
c_func
(paren
id|tp
comma
id|lbsp-&gt;lbc_ag
comma
id|lbsp-&gt;lbc_idx
)paren
suffix:semicolon
)brace
)brace
id|lbcp
op_assign
id|lbcp-&gt;lbc_next
suffix:semicolon
)brace
id|xfs_trans_free_busy
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * That&squot;s it for the transaction structure.  Free it.&n;&t; */
id|xfs_trans_free
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to perform the commit processing for each&n; * item described by the given chunk.&n; *&n; * The commit processing consists of unlocking items which were&n; * held locked with the SYNC_UNLOCK attribute, calling the committed&n; * routine of each logged item, updating the item&squot;s position in the AIL&n; * if necessary, and unpinning each item.  If the committed routine&n; * returns -1, then do nothing further with the item because it&n; * may have been freed.&n; *&n; * Since items are unlocked when they are copied to the incore&n; * log, it is possible for two transactions to be completing&n; * and manipulating the same item simultaneously.  The AIL lock&n; * will protect the lsn field of each item.  The value of this&n; * field can never go backwards.&n; *&n; * We unpin the items after repositioning them in the AIL, because&n; * otherwise they could be immediately flushed and we&squot;d have to race&n; * with the flusher trying to pull the item from the AIL as we add it.&n; */
id|STATIC
r_void
DECL|function|xfs_trans_chunk_committed
id|xfs_trans_chunk_committed
c_func
(paren
id|xfs_log_item_chunk_t
op_star
id|licp
comma
id|xfs_lsn_t
id|lsn
comma
r_int
id|aborted
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
id|xfs_lsn_t
id|item_lsn
suffix:semicolon
r_struct
id|xfs_mount
op_star
id|mp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|lidp
op_assign
id|licp-&gt;lic_descs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
comma
id|lidp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|lip
op_assign
id|lidp-&gt;lid_item
suffix:semicolon
r_if
c_cond
(paren
id|aborted
)paren
id|lip-&gt;li_flags
op_or_assign
id|XFS_LI_ABORTED
suffix:semicolon
r_if
c_cond
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_SYNC_UNLOCK
)paren
(brace
id|IOP_UNLOCK
c_func
(paren
id|lip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Send in the ABORTED flag to the COMMITTED routine&n;&t;&t; * so that it knows whether the transaction was aborted&n;&t;&t; * or not.&n;&t;&t; */
id|item_lsn
op_assign
id|IOP_COMMITTED
c_func
(paren
id|lip
comma
id|lsn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the committed routine returns -1, make&n;&t;&t; * no more references to the item.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_LSN_CMP
c_func
(paren
id|item_lsn
comma
(paren
id|xfs_lsn_t
)paren
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the returned lsn is greater than what it&n;&t;&t; * contained before, update the location of the&n;&t;&t; * item in the AIL.  If it is not, then do nothing.&n;&t;&t; * Items can never move backwards in the AIL.&n;&t;&t; *&n;&t;&t; * While the new lsn should usually be greater, it&n;&t;&t; * is possible that a later transaction completing&n;&t;&t; * simultaneously with an earlier one using the&n;&t;&t; * same item could complete first with a higher lsn.&n;&t;&t; * This would cause the earlier transaction to fail&n;&t;&t; * the test below.&n;&t;&t; */
id|mp
op_assign
id|lip-&gt;li_mountp
suffix:semicolon
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_LSN_CMP
c_func
(paren
id|item_lsn
comma
id|lip-&gt;li_lsn
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This will set the item&squot;s lsn to item_lsn&n;&t;&t;&t; * and update the position of the item in&n;&t;&t;&t; * the AIL.&n;&t;&t;&t; *&n;&t;&t;&t; * xfs_trans_update_ail() drops the AIL lock.&n;&t;&t;&t; */
id|xfs_trans_update_ail
c_func
(paren
id|mp
comma
id|lip
comma
id|item_lsn
comma
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
id|AIL_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now that we&squot;ve repositioned the item in the AIL,&n;&t;&t; * unpin it so it can be flushed. Pass information&n;&t;&t; * about buffer stale state down from the log item&n;&t;&t; * flags, if anyone else stales the buffer we do not&n;&t;&t; * want to pay any attention to it.&n;&t;&t; */
id|IOP_UNPIN
c_func
(paren
id|lip
comma
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_BUF_STALE
)paren
suffix:semicolon
)brace
)brace
eof
