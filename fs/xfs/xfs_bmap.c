multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_itable.h&quot;
macro_line|#include &quot;xfs_extfree_item.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_rtalloc.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_dir_leaf.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_trans_space.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#ifdef DEBUG
DECL|variable|xfs_bmap_trace_buf
id|ktrace_t
op_star
id|xfs_bmap_trace_buf
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFSDEBUG
id|STATIC
r_void
id|xfs_bmap_check_leaf_extents
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|whichfork
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|xfs_bmap_free_item_zone
id|kmem_zone_t
op_star
id|xfs_bmap_free_item_zone
suffix:semicolon
multiline_comment|/*&n; * Prototypes for internal bmap routines.&n; */
multiline_comment|/*&n; * Called from xfs_bmap_add_attrfork to handle extents format files.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_add_attrfork_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first block allocated */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* blocks to free at commit */
r_int
op_star
id|flags
)paren
suffix:semicolon
multiline_comment|/* inode logging flags */
multiline_comment|/*&n; * Called from xfs_bmap_add_attrfork to handle local format files.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_add_attrfork_local
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first block allocated */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* blocks to free at commit */
r_int
op_star
id|flags
)paren
suffix:semicolon
multiline_comment|/* inode logging flags */
multiline_comment|/*&n; * Called by xfs_bmapi to update extent list structure and the btree&n; * after allocating space (or doing a delayed allocation).&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_add_extent
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* if *curp is null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
id|xfs_fsblock_t
op_star
id|first
comma
multiline_comment|/* pointer to firstblock variable */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* list of extents to be freed */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
r_int
id|rsvd
)paren
suffix:semicolon
multiline_comment|/* OK to allocate reserved blocks */
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting a delayed&n; * allocation to a real allocation.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_add_extent_delay_real
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* if *curp is null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
id|xfs_filblks_t
op_star
id|dnew
comma
multiline_comment|/* new delayed-alloc indirect blocks */
id|xfs_fsblock_t
op_star
id|first
comma
multiline_comment|/* pointer to firstblock variable */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* list of extents to be freed */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|rsvd
)paren
suffix:semicolon
multiline_comment|/* OK to allocate reserved blocks */
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting a hole&n; * to a delayed allocation.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_add_extent_hole_delay
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* if null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|rsvd
)paren
suffix:semicolon
multiline_comment|/* OK to allocate reserved blocks */
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting a hole&n; * to a real allocation.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_add_extent_hole_real
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* if null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting an unwritten&n; * allocation to a real allocation or vice versa.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_add_extent_unwritten_real
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* if *curp is null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
r_int
op_star
id|logflagsp
)paren
suffix:semicolon
multiline_comment|/* inode logging flags */
multiline_comment|/*&n; * xfs_bmap_alloc is called by xfs_bmapi to allocate an extent for a file.&n; * It figures out where to ask the underlying allocator to put the new extent.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_alloc
c_func
(paren
id|xfs_bmalloca_t
op_star
id|ap
)paren
suffix:semicolon
multiline_comment|/* bmap alloc argument struct */
multiline_comment|/*&n; * Transform a btree format file with only one leaf node, where the&n; * extents list will fit in the inode, into an extents format file.&n; * Since the extent list is already in-core, all we have to do is&n; * give up the space for the btree root and pitch the leaf block.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_btree_to_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
macro_line|#ifdef XFSDEBUG
multiline_comment|/*&n; * Check that the extents list for the inode ip is in the right order.&n; */
id|STATIC
r_void
id|xfs_bmap_check_extents
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
macro_line|#else
DECL|macro|xfs_bmap_check_extents
mdefine_line|#define&t;xfs_bmap_check_extents(ip,w)
macro_line|#endif
multiline_comment|/*&n; * Called by xfs_bmapi to update extent list structure and the btree&n; * after removing space (or undoing a delayed allocation).&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_del_extent
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* current trans pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* list of extents to be freed */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* if null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
r_int
id|rsvd
)paren
suffix:semicolon
multiline_comment|/* OK to allocate reserved blocks */
multiline_comment|/*&n; * Remove the entry &quot;free&quot; from the free item list.  Prev points to the&n; * previous entry, unless &quot;free&quot; is the head of the list.&n; */
id|STATIC
r_void
id|xfs_bmap_del_free
c_func
(paren
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* free item list header */
id|xfs_bmap_free_item_t
op_star
id|prev
comma
multiline_comment|/* previous item on list, if any */
id|xfs_bmap_free_item_t
op_star
id|free
)paren
suffix:semicolon
multiline_comment|/* list item to be freed */
multiline_comment|/*&n; * Remove count entries from the extents array for inode &quot;ip&quot;, starting&n; * at index &quot;idx&quot;.  Copies the remaining items down over the deleted ones,&n; * and gives back the excess memory.&n; */
id|STATIC
r_void
id|xfs_bmap_delete_exlist
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incode inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* starting delete index */
id|xfs_extnum_t
id|count
comma
multiline_comment|/* count of items to delete */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Convert an extents-format file into a btree-format file.&n; * The new file will have a root block (in the inode) and a single child block.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_extents_to_btree
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first-block-allocated */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* blocks freed in xaction */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* cursor returned to caller */
r_int
id|wasdel
comma
multiline_comment|/* converting a delayed alloc */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Insert new item(s) in the extent list for inode &quot;ip&quot;.&n; * Count new items are inserted at offset idx.&n; */
id|STATIC
r_void
id|xfs_bmap_insert_exlist
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* starting index of new items */
id|xfs_extnum_t
id|count
comma
multiline_comment|/* number of inserted items */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* items to insert */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Convert a local file to an extents file.&n; * This code is sort of bogus, since the file data needs to get&n; * logged so it won&squot;t be lost.  The bmap-level manipulations are ok, though.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_bmap_local_to_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first block allocated in xaction */
id|xfs_extlen_t
id|total
comma
multiline_comment|/* total blocks needed by transaction */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Search the extents list for the inode, for the extent containing bno.&n; * If bno lies in a hole, point to the next entry.  If bno lies past eof,&n; * *eofp will be set, and *prevp will contain the last entry (null if none).&n; * Else, *lastxp will be set to the index of the found&n; * entry; *gotp will contain the entry.&n; */
id|STATIC
id|xfs_bmbt_rec_t
op_star
multiline_comment|/* pointer to found extent entry */
id|xfs_bmap_search_extents
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fileoff_t
id|bno
comma
multiline_comment|/* block number searched for */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
r_int
op_star
id|eofp
comma
multiline_comment|/* out: end of file found */
id|xfs_extnum_t
op_star
id|lastxp
comma
multiline_comment|/* out: last extent index */
id|xfs_bmbt_irec_t
op_star
id|gotp
comma
multiline_comment|/* out: extent entry found */
id|xfs_bmbt_irec_t
op_star
id|prevp
)paren
suffix:semicolon
multiline_comment|/* out: previous extent entry found */
macro_line|#ifdef XFS_BMAP_TRACE
multiline_comment|/*&n; * Add a bmap trace buffer entry.  Base routine for the others.&n; */
id|STATIC
r_void
id|xfs_bmap_trace_addentry
c_func
(paren
r_int
id|opcode
comma
multiline_comment|/* operation */
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry(ies) */
id|xfs_extnum_t
id|cnt
comma
multiline_comment|/* count of entries, 1 or 2 */
id|xfs_bmbt_rec_t
op_star
id|r1
comma
multiline_comment|/* first record */
id|xfs_bmbt_rec_t
op_star
id|r2
comma
multiline_comment|/* second record or null */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Add bmap trace entry prior to a call to xfs_bmap_delete_exlist.&n; */
id|STATIC
r_void
id|xfs_bmap_trace_delete
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry(entries) deleted */
id|xfs_extnum_t
id|cnt
comma
multiline_comment|/* count of entries deleted, 1 or 2 */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Add bmap trace entry prior to a call to xfs_bmap_insert_exlist, or&n; * reading in the extents list from the disk (in the btree).&n; */
id|STATIC
r_void
id|xfs_bmap_trace_insert
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry(entries) inserted */
id|xfs_extnum_t
id|cnt
comma
multiline_comment|/* count of entries inserted, 1 or 2 */
id|xfs_bmbt_irec_t
op_star
id|r1
comma
multiline_comment|/* inserted record 1 */
id|xfs_bmbt_irec_t
op_star
id|r2
comma
multiline_comment|/* inserted record 2 or null */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Add bmap trace entry after updating an extent list entry in place.&n; */
id|STATIC
r_void
id|xfs_bmap_trace_post_update
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry updated */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
multiline_comment|/*&n; * Add bmap trace entry prior to updating an extent list entry in place.&n; */
id|STATIC
r_void
id|xfs_bmap_trace_pre_update
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry to be updated */
r_int
id|whichfork
)paren
suffix:semicolon
multiline_comment|/* data or attr fork */
macro_line|#else
DECL|macro|xfs_bmap_trace_delete
mdefine_line|#define&t;xfs_bmap_trace_delete(f,d,ip,i,c,w)
DECL|macro|xfs_bmap_trace_insert
mdefine_line|#define&t;xfs_bmap_trace_insert(f,d,ip,i,c,r1,r2,w)
DECL|macro|xfs_bmap_trace_post_update
mdefine_line|#define&t;xfs_bmap_trace_post_update(f,d,ip,i,w)
DECL|macro|xfs_bmap_trace_pre_update
mdefine_line|#define&t;xfs_bmap_trace_pre_update(f,d,ip,i,w)
macro_line|#endif&t;/* XFS_BMAP_TRACE */
multiline_comment|/*&n; * Compute the worst-case number of indirect blocks that will be used&n; * for ip&squot;s delayed extent of length &quot;len&quot;.&n; */
id|STATIC
id|xfs_filblks_t
id|xfs_bmap_worst_indlen
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_filblks_t
id|len
)paren
suffix:semicolon
multiline_comment|/* delayed extent length */
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Perform various validation checks on the values being returned&n; * from xfs_bmapi().&n; */
id|STATIC
r_void
id|xfs_bmap_validate_ret
c_func
(paren
id|xfs_fileoff_t
id|bno
comma
id|xfs_filblks_t
id|len
comma
r_int
id|flags
comma
id|xfs_bmbt_irec_t
op_star
id|mval
comma
r_int
id|nmap
comma
r_int
id|ret_nmap
)paren
suffix:semicolon
macro_line|#else
DECL|macro|xfs_bmap_validate_ret
mdefine_line|#define&t;xfs_bmap_validate_ret(bno,len,flags,mval,onmap,nmap)
macro_line|#endif /* DEBUG */
macro_line|#if defined(DEBUG) &amp;&amp; defined(XFS_RW_TRACE)
id|STATIC
r_void
id|xfs_bunmap_trace
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_fileoff_t
id|bno
comma
id|xfs_filblks_t
id|len
comma
r_int
id|flags
comma
id|inst_t
op_star
id|ra
)paren
suffix:semicolon
macro_line|#else
DECL|macro|xfs_bunmap_trace
mdefine_line|#define&t;xfs_bunmap_trace(ip, bno, len, flags, ra)
macro_line|#endif&t;/* DEBUG &amp;&amp; XFS_RW_TRACE */
id|STATIC
r_int
id|xfs_bmap_count_tree
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_fsblock_t
id|blockno
comma
r_int
id|levelin
comma
r_int
op_star
id|count
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_bmap_count_leaves
c_func
(paren
id|xfs_bmbt_rec_t
op_star
id|frp
comma
r_int
id|numrecs
comma
r_int
op_star
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * Bmap internal routines.&n; */
multiline_comment|/*&n; * Called from xfs_bmap_add_attrfork to handle btree format files.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_attrfork_btree
id|xfs_bmap_add_attrfork_btree
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first block allocated */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* blocks to free at commit */
r_int
op_star
id|flags
)paren
multiline_comment|/* inode logging flags */
(brace
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* btree cursor */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount struct */
r_int
id|stat
suffix:semicolon
multiline_comment|/* newroot status */
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_df.if_broot_bytes
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
)paren
op_star
id|flags
op_or_assign
id|XFS_ILOG_DBROOT
suffix:semicolon
r_else
(brace
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
l_int|NULL
comma
l_int|0
comma
id|XFS_BTNUM_BMAP
comma
id|ip
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|cur-&gt;bc_private.b.flist
op_assign
id|flist
suffix:semicolon
id|cur-&gt;bc_private.b.firstblock
op_assign
op_star
id|firstblock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_ge
c_func
(paren
id|cur
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|ASSERT
c_func
(paren
id|stat
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/* must be at least one entry */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_newroot
c_func
(paren
id|cur
comma
id|flags
comma
op_amp
id|stat
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
op_star
id|firstblock
op_assign
id|cur-&gt;bc_private.b.firstblock
suffix:semicolon
id|cur-&gt;bc_private.b.allocated
op_assign
l_int|0
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from xfs_bmap_add_attrfork to handle extents format files.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_attrfork_extents
id|xfs_bmap_add_attrfork_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first block allocated */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* blocks to free at commit */
r_int
op_star
id|flags
)paren
multiline_comment|/* inode logging flags */
(brace
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* bmap btree cursor */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nextents
op_star
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cur
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|xfs_bmap_extents_to_btree
c_func
(paren
id|tp
comma
id|ip
comma
id|firstblock
comma
id|flist
comma
op_amp
id|cur
comma
l_int|0
comma
id|flags
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
(brace
id|cur-&gt;bc_private.b.allocated
op_assign
l_int|0
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|error
ques
c_cond
id|XFS_BTREE_ERROR
suffix:colon
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from xfs_bmap_add_attrfork to handle local format files.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_attrfork_local
id|xfs_bmap_add_attrfork_local
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first block allocated */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* blocks to free at commit */
r_int
op_star
id|flags
)paren
multiline_comment|/* inode logging flags */
(brace
id|xfs_da_args_t
id|dargs
suffix:semicolon
multiline_comment|/* args for dir/attr code */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure pointer */
r_if
c_cond
(paren
id|ip-&gt;i_df.if_bytes
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
(brace
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dargs
comma
l_int|0
comma
r_sizeof
(paren
id|dargs
)paren
)paren
suffix:semicolon
id|dargs.dp
op_assign
id|ip
suffix:semicolon
id|dargs.firstblock
op_assign
id|firstblock
suffix:semicolon
id|dargs.flist
op_assign
id|flist
suffix:semicolon
id|dargs.total
op_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
id|dargs.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|dargs.trans
op_assign
id|tp
suffix:semicolon
id|error
op_assign
id|XFS_DIR_SHORTFORM_TO_SINGLE
c_func
(paren
id|mp
comma
op_amp
id|dargs
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
id|xfs_bmap_local_to_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|firstblock
comma
l_int|1
comma
id|flags
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by xfs_bmapi to update extent list structure and the btree&n; * after allocating space (or doing a delayed allocation).&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_extent
id|xfs_bmap_add_extent
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* if *curp is null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
id|xfs_fsblock_t
op_star
id|first
comma
multiline_comment|/* pointer to firstblock variable */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* list of extents to be freed */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
r_int
id|rsvd
)paren
multiline_comment|/* OK to use reserved data blocks */
(brace
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* btree cursor or null */
id|xfs_filblks_t
id|da_new
suffix:semicolon
multiline_comment|/* new count del alloc blocks used */
id|xfs_filblks_t
id|da_old
suffix:semicolon
multiline_comment|/* old count del alloc blocks used */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_add_extent&quot;
suffix:semicolon
macro_line|#endif
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork ptr */
r_int
id|logflags
suffix:semicolon
multiline_comment|/* returned value */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extents in file now */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_add_exlist
)paren
suffix:semicolon
id|cur
op_assign
op_star
id|curp
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idx
op_le
id|nextents
)paren
suffix:semicolon
id|da_old
op_assign
id|da_new
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This is the first extent added to a new/empty file.&n;&t; * Special case this one, so other routines get to assume there are&n;&t; * already extents in the list.&n;&t; */
r_if
c_cond
(paren
id|nextents
op_eq
l_int|0
)paren
(brace
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;insert empty&quot;
comma
id|ip
comma
l_int|0
comma
l_int|1
comma
r_new
comma
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
l_int|0
comma
l_int|1
comma
r_new
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|cur
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
r_new
op_member_access_from_pointer
id|br_startblock
)paren
)paren
(brace
id|XFS_IFORK_NEXT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
l_int|1
)paren
suffix:semicolon
id|logflags
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
)brace
r_else
id|logflags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Any kind of new delayed allocation goes here.&n;&t; */
r_else
r_if
c_cond
(paren
id|ISNULLSTARTBLOCK
c_func
(paren
r_new
op_member_access_from_pointer
id|br_startblock
)paren
)paren
(brace
r_if
c_cond
(paren
id|cur
)paren
id|ASSERT
c_func
(paren
(paren
id|cur-&gt;bc_private.b.flags
op_amp
id|XFS_BTCUR_BPRV_WASDEL
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_add_extent_hole_delay
c_func
(paren
id|ip
comma
id|idx
comma
id|cur
comma
r_new
comma
op_amp
id|logflags
comma
id|rsvd
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Real allocation off the end of the file.&n;&t; */
r_else
r_if
c_cond
(paren
id|idx
op_eq
id|nextents
)paren
(brace
r_if
c_cond
(paren
id|cur
)paren
id|ASSERT
c_func
(paren
(paren
id|cur-&gt;bc_private.b.flags
op_amp
id|XFS_BTCUR_BPRV_WASDEL
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_add_extent_hole_real
c_func
(paren
id|ip
comma
id|idx
comma
id|cur
comma
r_new
comma
op_amp
id|logflags
comma
id|whichfork
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
id|xfs_bmbt_irec_t
id|prev
suffix:semicolon
multiline_comment|/* old extent at offset idx */
multiline_comment|/*&n;&t;&t; * Get the record referred to by idx.&n;&t;&t; */
id|xfs_bmbt_get_all
c_func
(paren
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|idx
)braket
comma
op_amp
id|prev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s a real allocation record, and the new allocation ends&n;&t;&t; * after the start of the referred to record, then we&squot;re filling&n;&t;&t; * in a delayed or unwritten allocation with a real one, or&n;&t;&t; * converting real back to unwritten.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
r_new
op_member_access_from_pointer
id|br_startblock
)paren
op_logical_and
r_new
op_member_access_from_pointer
id|br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
OG
id|prev.br_startoff
)paren
(brace
r_if
c_cond
(paren
id|prev.br_state
op_ne
id|XFS_EXT_UNWRITTEN
op_logical_and
id|ISNULLSTARTBLOCK
c_func
(paren
id|prev.br_startblock
)paren
)paren
(brace
id|da_old
op_assign
id|STARTBLOCKVAL
c_func
(paren
id|prev.br_startblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
id|ASSERT
c_func
(paren
id|cur-&gt;bc_private.b.flags
op_amp
id|XFS_BTCUR_BPRV_WASDEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_add_extent_delay_real
c_func
(paren
id|ip
comma
id|idx
comma
op_amp
id|cur
comma
r_new
comma
op_amp
id|da_new
comma
id|first
comma
id|flist
comma
op_amp
id|logflags
comma
id|rsvd
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|br_state
op_eq
id|XFS_EXT_NORM
)paren
(brace
id|ASSERT
c_func
(paren
r_new
op_member_access_from_pointer
id|br_state
op_eq
id|XFS_EXT_NORM
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_add_extent_unwritten_real
c_func
(paren
id|ip
comma
id|idx
comma
op_amp
id|cur
comma
r_new
comma
op_amp
id|logflags
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
r_new
op_member_access_from_pointer
id|br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_add_extent_unwritten_real
c_func
(paren
id|ip
comma
id|idx
comma
op_amp
id|cur
comma
r_new
comma
op_amp
id|logflags
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_star
id|curp
op_eq
id|cur
op_logical_or
op_star
id|curp
op_eq
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Otherwise we&squot;re filling in a hole with an allocation.&n;&t;&t; */
r_else
(brace
r_if
c_cond
(paren
id|cur
)paren
id|ASSERT
c_func
(paren
(paren
id|cur-&gt;bc_private.b.flags
op_amp
id|XFS_BTCUR_BPRV_WASDEL
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_add_extent_hole_real
c_func
(paren
id|ip
comma
id|idx
comma
id|cur
comma
r_new
comma
op_amp
id|logflags
comma
id|whichfork
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
op_star
id|curp
op_eq
id|cur
op_logical_or
op_star
id|curp
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert to a btree if necessary.&n;&t; */
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
OG
id|ifp-&gt;if_ext_max
)paren
(brace
r_int
id|tmp_logflags
suffix:semicolon
multiline_comment|/* partial log flag return val */
id|ASSERT
c_func
(paren
id|cur
op_eq
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmap_extents_to_btree
c_func
(paren
id|ip-&gt;i_transp
comma
id|ip
comma
id|first
comma
id|flist
comma
op_amp
id|cur
comma
id|da_old
OG
l_int|0
comma
op_amp
id|tmp_logflags
comma
id|whichfork
)paren
suffix:semicolon
id|logflags
op_or_assign
id|tmp_logflags
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Adjust for changes in reserved delayed indirect blocks.&n;&t; * Nothing to do for disk quotas here.&n;&t; */
r_if
c_cond
(paren
id|da_old
op_logical_or
id|da_new
)paren
(brace
id|xfs_filblks_t
id|nblks
suffix:semicolon
id|nblks
op_assign
id|da_new
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
id|nblks
op_add_assign
id|cur-&gt;bc_private.b.allocated
suffix:semicolon
id|ASSERT
c_func
(paren
id|nblks
op_le
id|da_old
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblks
OL
id|da_old
)paren
id|xfs_mod_incore_sb
c_func
(paren
id|ip-&gt;i_mount
comma
id|XFS_SBS_FDBLOCKS
comma
(paren
r_int
)paren
(paren
id|da_old
op_minus
id|nblks
)paren
comma
id|rsvd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear out the allocated field, done with it now in any case.&n;&t; */
r_if
c_cond
(paren
id|cur
)paren
(brace
id|cur-&gt;bc_private.b.allocated
op_assign
l_int|0
suffix:semicolon
op_star
id|curp
op_assign
id|cur
suffix:semicolon
)brace
id|done
suffix:colon
macro_line|#ifdef XFSDEBUG
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|xfs_bmap_check_leaf_extents
c_func
(paren
op_star
id|curp
comma
id|ip
comma
id|whichfork
)paren
suffix:semicolon
macro_line|#endif
op_star
id|logflagsp
op_assign
id|logflags
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting a delayed&n; * allocation to a real allocation.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_extent_delay_real
id|xfs_bmap_add_extent_delay_real
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* if *curp is null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
id|xfs_filblks_t
op_star
id|dnew
comma
multiline_comment|/* new delayed-alloc indirect blocks */
id|xfs_fsblock_t
op_star
id|first
comma
multiline_comment|/* pointer to firstblock variable */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* list of extents to be freed */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|rsvd
)paren
multiline_comment|/* OK to use reserved data block allocation */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent entry list */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* btree cursor */
r_int
id|diff
suffix:semicolon
multiline_comment|/* temp value */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent entry for idx */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_add_extent_delay_real&quot;
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
multiline_comment|/* temp state */
id|xfs_fileoff_t
id|new_endoff
suffix:semicolon
multiline_comment|/* end offset of new entry */
id|xfs_bmbt_irec_t
id|r
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* neighbor extent entries */
multiline_comment|/* left is 0, right is 1, prev is 2 */
r_int
id|rval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return value (logging flags) */
r_int
id|state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* state bits, accessed thru macros */
id|xfs_filblks_t
id|temp
suffix:semicolon
multiline_comment|/* value for dnew calculations */
id|xfs_filblks_t
id|temp2
suffix:semicolon
multiline_comment|/* value for dnew calculations */
r_int
id|tmp_rval
suffix:semicolon
multiline_comment|/* partial logging flags */
r_enum
(brace
multiline_comment|/* bit number definitions for state */
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
comma
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|LEFT_DELAY
comma
id|RIGHT_DELAY
comma
id|LEFT_VALID
comma
id|RIGHT_VALID
)brace
suffix:semicolon
DECL|macro|LEFT
mdefine_line|#define&t;LEFT&t;&t;r[0]
DECL|macro|RIGHT
mdefine_line|#define&t;RIGHT&t;&t;r[1]
DECL|macro|PREV
mdefine_line|#define&t;PREV&t;&t;r[2]
DECL|macro|MASK
mdefine_line|#define&t;MASK(b)&t;&t;(1 &lt;&lt; (b))
DECL|macro|MASK2
mdefine_line|#define&t;MASK2(a,b)&t;(MASK(a) | MASK(b))
DECL|macro|MASK3
mdefine_line|#define&t;MASK3(a,b,c)&t;(MASK2(a,b) | MASK(c))
DECL|macro|MASK4
mdefine_line|#define&t;MASK4(a,b,c,d)&t;(MASK3(a,b,c) | MASK(d))
DECL|macro|STATE_SET
mdefine_line|#define&t;STATE_SET(b,v)&t;((v) ? (state |= MASK(b)) : (state &amp;= ~MASK(b)))
DECL|macro|STATE_TEST
mdefine_line|#define&t;STATE_TEST(b)&t;(state &amp; MASK(b))
DECL|macro|STATE_SET_TEST
mdefine_line|#define&t;STATE_SET_TEST(b,v)&t;((v) ? ((state |= MASK(b)), 1) : &bslash;&n;&t;&t;&t;&t;       ((state &amp;= ~MASK(b)), 0))
DECL|macro|SWITCH_STATE
mdefine_line|#define&t;SWITCH_STATE&t;&t;&bslash;&n;&t;(state &amp; MASK4(LEFT_FILLING, RIGHT_FILLING, LEFT_CONTIG, RIGHT_CONTIG))
multiline_comment|/*&n;&t; * Set up a bunch of variables to make the tests simpler.&n;&t; */
id|cur
op_assign
op_star
id|curp
suffix:semicolon
id|base
op_assign
id|ip-&gt;i_df.if_u1.if_extents
suffix:semicolon
id|ep
op_assign
op_amp
id|base
(braket
id|idx
)braket
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|PREV
)paren
suffix:semicolon
id|new_endoff
op_assign
r_new
op_member_access_from_pointer
id|br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|PREV.br_startoff
op_le
r_new
op_member_access_from_pointer
id|br_startoff
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|PREV.br_startoff
op_plus
id|PREV.br_blockcount
op_ge
id|new_endoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set flags determining what part of the previous delayed allocation&n;&t; * extent is being replaced by a real allocation.&n;&t; */
id|STATE_SET
c_func
(paren
id|LEFT_FILLING
comma
id|PREV.br_startoff
op_eq
r_new
op_member_access_from_pointer
id|br_startoff
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_FILLING
comma
id|PREV.br_startoff
op_plus
id|PREV.br_blockcount
op_eq
id|new_endoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check and set flags if this segment has a left neighbor.&n;&t; * Don&squot;t set contiguous if the combined extent would be too large.&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|LEFT_VALID
comma
id|idx
OG
l_int|0
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_minus
l_int|1
comma
op_amp
id|LEFT
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|LEFT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|LEFT.br_startblock
)paren
)paren
suffix:semicolon
)brace
id|STATE_SET
c_func
(paren
id|LEFT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|LEFT_VALID
)paren
op_logical_and
op_logical_neg
id|STATE_TEST
c_func
(paren
id|LEFT_DELAY
)paren
op_logical_and
id|LEFT.br_startoff
op_plus
id|LEFT.br_blockcount
op_eq
r_new
op_member_access_from_pointer
id|br_startoff
op_logical_and
id|LEFT.br_startblock
op_plus
id|LEFT.br_blockcount
op_eq
r_new
op_member_access_from_pointer
id|br_startblock
op_logical_and
id|LEFT.br_state
op_eq
r_new
op_member_access_from_pointer
id|br_state
op_logical_and
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_le
id|MAXEXTLEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check and set flags if this segment has a right neighbor.&n;&t; * Don&squot;t set contiguous if the combined extent would be too large.&n;&t; * Also check for all-three-contiguous being too large.&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|RIGHT_VALID
comma
id|idx
OL
id|ip-&gt;i_df.if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_plus
l_int|1
comma
op_amp
id|RIGHT
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|RIGHT.br_startblock
)paren
)paren
suffix:semicolon
)brace
id|STATE_SET
c_func
(paren
id|RIGHT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|RIGHT_VALID
)paren
op_logical_and
op_logical_neg
id|STATE_TEST
c_func
(paren
id|RIGHT_DELAY
)paren
op_logical_and
id|new_endoff
op_eq
id|RIGHT.br_startoff
op_logical_and
r_new
op_member_access_from_pointer
id|br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_eq
id|RIGHT.br_startblock
op_logical_and
r_new
op_member_access_from_pointer
id|br_state
op_eq
id|RIGHT.br_state
op_logical_and
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
op_le
id|MAXEXTLEN
op_logical_and
(paren
(paren
id|state
op_amp
id|MASK3
c_func
(paren
id|LEFT_CONTIG
comma
id|LEFT_FILLING
comma
id|RIGHT_FILLING
)paren
)paren
op_ne
id|MASK3
c_func
(paren
id|LEFT_CONTIG
comma
id|LEFT_FILLING
comma
id|RIGHT_FILLING
)paren
op_logical_or
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
op_le
id|MAXEXTLEN
)paren
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Switch out based on the FILLING and CONTIG state bits.&n;&t; */
r_switch
c_cond
(paren
id|SWITCH_STATE
)paren
(brace
r_case
id|MASK4
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in all of a previously delayed allocation extent.&n;&t;&t; * The left and right neighbors are both contiguous with new.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
op_plus
id|RIGHT.br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC|RC&quot;
comma
id|ip
comma
id|idx
comma
l_int|2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|RIGHT.br_startoff
comma
id|RIGHT.br_startblock
comma
id|RIGHT.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_decrement
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|LEFT.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
op_star
id|dnew
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK3
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in all of a previously delayed allocation extent.&n;&t;&t; * The left neighbor is contiguous, the right is not.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
comma
id|LEFT.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
op_star
id|dnew
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK3
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in all of a previously delayed allocation extent.&n;&t;&t; * The right neighbor is contiguous, the left is not.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
r_new
op_member_access_from_pointer
id|br_startblock
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|PREV.br_blockcount
op_plus
id|RIGHT.br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|RC&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|RIGHT.br_startoff
comma
id|RIGHT.br_startblock
comma
id|RIGHT.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
id|PREV.br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|PREV.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
op_star
id|dnew
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK2
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in all of a previously delayed allocation extent.&n;&t;&t; * Neither the left nor right neighbors are contiguous with&n;&t;&t; * the new one.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
r_new
op_member_access_from_pointer
id|br_startblock
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|cur-&gt;bc_rec.b.br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
op_star
id|dnew
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK2
c_func
(paren
id|LEFT_FILLING
comma
id|LEFT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in the first part of a previous delayed allocation.&n;&t;&t; * The left neighbor is contiguous.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmbt_set_startoff
c_func
(paren
id|ep
comma
id|PREV.br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|temp
op_assign
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|LEFT.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
id|temp
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
comma
id|STARTBLOCKVAL
c_func
(paren
id|PREV.br_startblock
)paren
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
op_star
id|dnew
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|LEFT_FILLING
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in the first part of a previous delayed allocation.&n;&t;&t; * The left neighbor is not contiguous.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_startoff
c_func
(paren
id|ep
comma
id|new_endoff
)paren
suffix:semicolon
id|temp
op_assign
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;LF&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
l_int|NULL
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|cur-&gt;bc_rec.b.br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|ip-&gt;i_d.di_nextents
OG
id|ip-&gt;i_df.if_ext_max
)paren
(brace
id|error
op_assign
id|xfs_bmap_extents_to_btree
c_func
(paren
id|ip-&gt;i_transp
comma
id|ip
comma
id|first
comma
id|flist
comma
op_amp
id|cur
comma
l_int|1
comma
op_amp
id|tmp_rval
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|rval
op_or_assign
id|tmp_rval
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|done
suffix:semicolon
)brace
id|temp
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
comma
id|STARTBLOCKVAL
c_func
(paren
id|PREV.br_startblock
)paren
op_minus
(paren
id|cur
ques
c_cond
id|cur-&gt;bc_private.b.allocated
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|base
op_assign
id|ip-&gt;i_df.if_u1.if_extents
suffix:semicolon
id|ep
op_assign
op_amp
id|base
(braket
id|idx
op_plus
l_int|1
)braket
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
op_star
id|dnew
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK2
c_func
(paren
id|RIGHT_FILLING
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in the last part of a previous delayed allocation.&n;&t;&t; * The right neighbor is contiguous with the new allocation.&n;&t;&t; */
id|temp
op_assign
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
id|xfs_bmbt_set_allf
c_func
(paren
id|ep
op_plus
l_int|1
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|RIGHT.br_state
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|RIGHT.br_startoff
comma
id|RIGHT.br_startblock
comma
id|RIGHT.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|RIGHT.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
id|temp
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
comma
id|STARTBLOCKVAL
c_func
(paren
id|PREV.br_startblock
)paren
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
op_star
id|dnew
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|RIGHT_FILLING
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in the last part of a previous delayed allocation.&n;&t;&t; * The right neighbor is not contiguous.&n;&t;&t; */
id|temp
op_assign
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;RF&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
r_new
comma
l_int|NULL
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
r_new
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_plus
l_int|1
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|cur-&gt;bc_rec.b.br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|ip-&gt;i_d.di_nextents
OG
id|ip-&gt;i_df.if_ext_max
)paren
(brace
id|error
op_assign
id|xfs_bmap_extents_to_btree
c_func
(paren
id|ip-&gt;i_transp
comma
id|ip
comma
id|first
comma
id|flist
comma
op_amp
id|cur
comma
l_int|1
comma
op_amp
id|tmp_rval
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|rval
op_or_assign
id|tmp_rval
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|done
suffix:semicolon
)brace
id|temp
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
comma
id|STARTBLOCKVAL
c_func
(paren
id|PREV.br_startblock
)paren
op_minus
(paren
id|cur
ques
c_cond
id|cur-&gt;bc_private.b.allocated
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|base
op_assign
id|ip-&gt;i_df.if_u1.if_extents
suffix:semicolon
id|ep
op_assign
op_amp
id|base
(braket
id|idx
)braket
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
op_star
id|dnew
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t; * Filling in the middle part of a previous delayed allocation.&n;&t;&t; * Contiguity is impossible here.&n;&t;&t; * This case is avoided almost all the time.&n;&t;&t; */
id|temp
op_assign
r_new
op_member_access_from_pointer
id|br_startoff
op_minus
id|PREV.br_startoff
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
id|r
(braket
l_int|0
)braket
op_assign
op_star
r_new
suffix:semicolon
id|r
(braket
l_int|1
)braket
dot
id|br_startoff
op_assign
id|new_endoff
suffix:semicolon
id|temp2
op_assign
id|PREV.br_startoff
op_plus
id|PREV.br_blockcount
op_minus
id|new_endoff
suffix:semicolon
id|r
(braket
l_int|1
)braket
dot
id|br_blockcount
op_assign
id|temp2
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|2
comma
op_amp
id|r
(braket
l_int|0
)braket
comma
op_amp
id|r
(braket
l_int|1
)braket
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|2
comma
op_amp
id|r
(braket
l_int|0
)braket
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_plus
l_int|1
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|cur-&gt;bc_rec.b.br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|ip-&gt;i_d.di_nextents
OG
id|ip-&gt;i_df.if_ext_max
)paren
(brace
id|error
op_assign
id|xfs_bmap_extents_to_btree
c_func
(paren
id|ip-&gt;i_transp
comma
id|ip
comma
id|first
comma
id|flist
comma
op_amp
id|cur
comma
l_int|1
comma
op_amp
id|tmp_rval
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|rval
op_or_assign
id|tmp_rval
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|done
suffix:semicolon
)brace
id|temp
op_assign
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
suffix:semicolon
id|temp2
op_assign
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp2
)paren
suffix:semicolon
id|diff
op_assign
(paren
r_int
)paren
(paren
id|temp
op_plus
id|temp2
op_minus
id|STARTBLOCKVAL
c_func
(paren
id|PREV.br_startblock
)paren
op_minus
(paren
id|cur
ques
c_cond
id|cur-&gt;bc_private.b.allocated
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|diff
OG
l_int|0
op_logical_and
id|xfs_mod_incore_sb
c_func
(paren
id|ip-&gt;i_mount
comma
id|XFS_SBS_FDBLOCKS
comma
op_minus
id|diff
comma
id|rsvd
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Ick gross gag me with a spoon.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* want to see if this ever happens! */
r_while
c_loop
(paren
id|diff
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
(brace
id|temp
op_decrement
suffix:semicolon
id|diff
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
op_logical_or
op_logical_neg
id|xfs_mod_incore_sb
c_func
(paren
id|ip-&gt;i_mount
comma
id|XFS_SBS_FDBLOCKS
comma
op_minus
id|diff
comma
id|rsvd
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp2
)paren
(brace
id|temp2
op_decrement
suffix:semicolon
id|diff
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
op_logical_or
op_logical_neg
id|xfs_mod_incore_sb
c_func
(paren
id|ip-&gt;i_mount
comma
id|XFS_SBS_FDBLOCKS
comma
op_minus
id|diff
comma
id|rsvd
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
id|base
op_assign
id|ip-&gt;i_df.if_u1.if_extents
suffix:semicolon
id|ep
op_assign
op_amp
id|base
(braket
id|idx
)braket
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
op_plus
l_int|2
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp2
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
op_star
id|dnew
op_assign
id|temp
op_plus
id|temp2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK3
c_func
(paren
id|LEFT_FILLING
comma
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK3
c_func
(paren
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK2
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK2
c_func
(paren
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
)paren
suffix:colon
r_case
id|MASK2
c_func
(paren
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK
c_func
(paren
id|LEFT_CONTIG
)paren
suffix:colon
r_case
id|MASK
c_func
(paren
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * These cases are all impossible.&n;&t;&t; */
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
op_star
id|curp
op_assign
id|cur
suffix:semicolon
id|done
suffix:colon
op_star
id|logflagsp
op_assign
id|rval
suffix:semicolon
r_return
id|error
suffix:semicolon
DECL|macro|LEFT
macro_line|#undef&t;LEFT
DECL|macro|RIGHT
macro_line|#undef&t;RIGHT
DECL|macro|PREV
macro_line|#undef&t;PREV
DECL|macro|MASK
macro_line|#undef&t;MASK
DECL|macro|MASK2
macro_line|#undef&t;MASK2
DECL|macro|MASK3
macro_line|#undef&t;MASK3
DECL|macro|MASK4
macro_line|#undef&t;MASK4
DECL|macro|STATE_SET
macro_line|#undef&t;STATE_SET
DECL|macro|STATE_TEST
macro_line|#undef&t;STATE_TEST
DECL|macro|STATE_SET_TEST
macro_line|#undef&t;STATE_SET_TEST
DECL|macro|SWITCH_STATE
macro_line|#undef&t;SWITCH_STATE
)brace
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting an unwritten&n; * allocation to a real allocation or vice versa.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_extent_unwritten_real
id|xfs_bmap_add_extent_unwritten_real
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* if *curp is null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
r_int
op_star
id|logflagsp
)paren
multiline_comment|/* inode logging flags */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent entry list */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* btree cursor */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent entry for idx */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_add_extent_unwritten_real&quot;
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
multiline_comment|/* temp state */
id|xfs_fileoff_t
id|new_endoff
suffix:semicolon
multiline_comment|/* end offset of new entry */
id|xfs_exntst_t
id|newext
suffix:semicolon
multiline_comment|/* new extent state */
id|xfs_exntst_t
id|oldext
suffix:semicolon
multiline_comment|/* old extent state */
id|xfs_bmbt_irec_t
id|r
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* neighbor extent entries */
multiline_comment|/* left is 0, right is 1, prev is 2 */
r_int
id|rval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return value (logging flags) */
r_int
id|state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* state bits, accessed thru macros */
r_enum
(brace
multiline_comment|/* bit number definitions for state */
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
comma
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|LEFT_DELAY
comma
id|RIGHT_DELAY
comma
id|LEFT_VALID
comma
id|RIGHT_VALID
)brace
suffix:semicolon
DECL|macro|LEFT
mdefine_line|#define&t;LEFT&t;&t;r[0]
DECL|macro|RIGHT
mdefine_line|#define&t;RIGHT&t;&t;r[1]
DECL|macro|PREV
mdefine_line|#define&t;PREV&t;&t;r[2]
DECL|macro|MASK
mdefine_line|#define&t;MASK(b)&t;&t;(1 &lt;&lt; (b))
DECL|macro|MASK2
mdefine_line|#define&t;MASK2(a,b)&t;(MASK(a) | MASK(b))
DECL|macro|MASK3
mdefine_line|#define&t;MASK3(a,b,c)&t;(MASK2(a,b) | MASK(c))
DECL|macro|MASK4
mdefine_line|#define&t;MASK4(a,b,c,d)&t;(MASK3(a,b,c) | MASK(d))
DECL|macro|STATE_SET
mdefine_line|#define&t;STATE_SET(b,v)&t;((v) ? (state |= MASK(b)) : (state &amp;= ~MASK(b)))
DECL|macro|STATE_TEST
mdefine_line|#define&t;STATE_TEST(b)&t;(state &amp; MASK(b))
DECL|macro|STATE_SET_TEST
mdefine_line|#define&t;STATE_SET_TEST(b,v)&t;((v) ? ((state |= MASK(b)), 1) : &bslash;&n;&t;&t;&t;&t;       ((state &amp;= ~MASK(b)), 0))
DECL|macro|SWITCH_STATE
mdefine_line|#define&t;SWITCH_STATE&t;&t;&bslash;&n;&t;(state &amp; MASK4(LEFT_FILLING, RIGHT_FILLING, LEFT_CONTIG, RIGHT_CONTIG))
multiline_comment|/*&n;&t; * Set up a bunch of variables to make the tests simpler.&n;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
id|cur
op_assign
op_star
id|curp
suffix:semicolon
id|base
op_assign
id|ip-&gt;i_df.if_u1.if_extents
suffix:semicolon
id|ep
op_assign
op_amp
id|base
(braket
id|idx
)braket
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|PREV
)paren
suffix:semicolon
id|newext
op_assign
r_new
op_member_access_from_pointer
id|br_state
suffix:semicolon
id|oldext
op_assign
(paren
id|newext
op_eq
id|XFS_EXT_UNWRITTEN
)paren
ques
c_cond
id|XFS_EXT_NORM
suffix:colon
id|XFS_EXT_UNWRITTEN
suffix:semicolon
id|ASSERT
c_func
(paren
id|PREV.br_state
op_eq
id|oldext
)paren
suffix:semicolon
id|new_endoff
op_assign
r_new
op_member_access_from_pointer
id|br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|PREV.br_startoff
op_le
r_new
op_member_access_from_pointer
id|br_startoff
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|PREV.br_startoff
op_plus
id|PREV.br_blockcount
op_ge
id|new_endoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set flags determining what part of the previous oldext allocation&n;&t; * extent is being replaced by a newext allocation.&n;&t; */
id|STATE_SET
c_func
(paren
id|LEFT_FILLING
comma
id|PREV.br_startoff
op_eq
r_new
op_member_access_from_pointer
id|br_startoff
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_FILLING
comma
id|PREV.br_startoff
op_plus
id|PREV.br_blockcount
op_eq
id|new_endoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check and set flags if this segment has a left neighbor.&n;&t; * Don&squot;t set contiguous if the combined extent would be too large.&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|LEFT_VALID
comma
id|idx
OG
l_int|0
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_minus
l_int|1
comma
op_amp
id|LEFT
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|LEFT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|LEFT.br_startblock
)paren
)paren
suffix:semicolon
)brace
id|STATE_SET
c_func
(paren
id|LEFT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|LEFT_VALID
)paren
op_logical_and
op_logical_neg
id|STATE_TEST
c_func
(paren
id|LEFT_DELAY
)paren
op_logical_and
id|LEFT.br_startoff
op_plus
id|LEFT.br_blockcount
op_eq
r_new
op_member_access_from_pointer
id|br_startoff
op_logical_and
id|LEFT.br_startblock
op_plus
id|LEFT.br_blockcount
op_eq
r_new
op_member_access_from_pointer
id|br_startblock
op_logical_and
id|LEFT.br_state
op_eq
id|newext
op_logical_and
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_le
id|MAXEXTLEN
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check and set flags if this segment has a right neighbor.&n;&t; * Don&squot;t set contiguous if the combined extent would be too large.&n;&t; * Also check for all-three-contiguous being too large.&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|RIGHT_VALID
comma
id|idx
OL
id|ip-&gt;i_df.if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_plus
l_int|1
comma
op_amp
id|RIGHT
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|RIGHT.br_startblock
)paren
)paren
suffix:semicolon
)brace
id|STATE_SET
c_func
(paren
id|RIGHT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|RIGHT_VALID
)paren
op_logical_and
op_logical_neg
id|STATE_TEST
c_func
(paren
id|RIGHT_DELAY
)paren
op_logical_and
id|new_endoff
op_eq
id|RIGHT.br_startoff
op_logical_and
r_new
op_member_access_from_pointer
id|br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_eq
id|RIGHT.br_startblock
op_logical_and
id|newext
op_eq
id|RIGHT.br_state
op_logical_and
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
op_le
id|MAXEXTLEN
op_logical_and
(paren
(paren
id|state
op_amp
id|MASK3
c_func
(paren
id|LEFT_CONTIG
comma
id|LEFT_FILLING
comma
id|RIGHT_FILLING
)paren
)paren
op_ne
id|MASK3
c_func
(paren
id|LEFT_CONTIG
comma
id|LEFT_FILLING
comma
id|RIGHT_FILLING
)paren
op_logical_or
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
op_le
id|MAXEXTLEN
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Switch out based on the FILLING and CONTIG state bits.&n;&t; */
r_switch
c_cond
(paren
id|SWITCH_STATE
)paren
(brace
r_case
id|MASK4
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting all of a previous oldext extent to newext.&n;&t;&t; * The left and right neighbors are both contiguous with new.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
op_plus
id|RIGHT.br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC|RC&quot;
comma
id|ip
comma
id|idx
comma
l_int|2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_sub_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|RIGHT.br_startoff
comma
id|RIGHT.br_startblock
comma
id|RIGHT.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_decrement
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_decrement
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|LEFT.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK3
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting all of a previous oldext extent to newext.&n;&t;&t; * The left neighbor is contiguous, the right is not.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|LC&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_decrement
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
op_plus
id|PREV.br_blockcount
comma
id|LEFT.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK3
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting all of a previous oldext extent to newext.&n;&t;&t; * The right neighbor is contiguous, the left is not.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|PREV.br_blockcount
op_plus
id|RIGHT.br_blockcount
)paren
suffix:semicolon
id|xfs_bmbt_set_state
c_func
(paren
id|ep
comma
id|newext
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF|RC&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|RIGHT.br_startoff
comma
id|RIGHT.br_startblock
comma
id|RIGHT.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_decrement
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|newext
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK2
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_FILLING
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting all of a previous oldext extent to newext.&n;&t;&t; * Neither the left nor right neighbors are contiguous with&n;&t;&t; * the new one.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_state
c_func
(paren
id|ep
comma
id|newext
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|newext
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK2
c_func
(paren
id|LEFT_FILLING
comma
id|LEFT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting the first part of a previous oldext extent to newext.&n;&t;&t; * The left neighbor is contiguous.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmbt_set_startoff
c_func
(paren
id|ep
comma
id|PREV.br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
r_new
op_member_access_from_pointer
id|br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF|LC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|PREV.br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|PREV.br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|oldext
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_decrement
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|LEFT.br_startoff
comma
id|LEFT.br_startblock
comma
id|LEFT.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|LEFT.br_state
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|LEFT_FILLING
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting the first part of a previous oldext extent to newext.&n;&t;&t; * The left neighbor is not contiguous.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ep
op_logical_and
id|xfs_bmbt_get_state
c_func
(paren
id|ep
)paren
op_eq
id|oldext
)paren
suffix:semicolon
id|xfs_bmbt_set_startoff
c_func
(paren
id|ep
comma
id|new_endoff
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
r_new
op_member_access_from_pointer
id|br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;LF&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
l_int|NULL
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|PREV.br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|PREV.br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|oldext
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|cur-&gt;bc_rec.b
op_assign
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK2
c_func
(paren
id|RIGHT_FILLING
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting the last part of a previous oldext extent to newext.&n;&t;&t; * The right neighbor is contiguous with the new allocation.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_allf
c_func
(paren
id|ep
op_plus
l_int|1
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|newext
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RF|RC&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|oldext
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|RIGHT.br_blockcount
comma
id|newext
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|RIGHT_FILLING
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting the last part of a previous oldext extent to newext.&n;&t;&t; * The right neighbor is not contiguous.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RF&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;RF&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
r_new
comma
l_int|NULL
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
r_new
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_plus
l_int|1
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
op_minus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|oldext
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|cur-&gt;bc_rec.b.br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t; * Setting the middle part of a previous oldext extent to&n;&t;&t; * newext.  Contiguity is impossible here.&n;&t;&t; * One extent becomes three extents.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
r_new
op_member_access_from_pointer
id|br_startoff
op_minus
id|PREV.br_startoff
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|r
(braket
l_int|0
)braket
op_assign
op_star
r_new
suffix:semicolon
id|r
(braket
l_int|1
)braket
dot
id|br_startoff
op_assign
id|new_endoff
suffix:semicolon
id|r
(braket
l_int|1
)braket
dot
id|br_blockcount
op_assign
id|PREV.br_startoff
op_plus
id|PREV.br_blockcount
op_minus
id|new_endoff
suffix:semicolon
id|r
(braket
l_int|1
)braket
dot
id|br_startblock
op_assign
r_new
op_member_access_from_pointer
id|br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|r
(braket
l_int|1
)braket
dot
id|br_state
op_assign
id|oldext
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|2
comma
op_amp
id|r
(braket
l_int|0
)braket
comma
op_amp
id|r
(braket
l_int|1
)braket
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|2
comma
op_amp
id|r
(braket
l_int|0
)braket
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_plus
l_int|1
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
id|rval
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DEXT
suffix:semicolon
r_else
(brace
id|rval
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|PREV.br_startoff
comma
id|PREV.br_startblock
comma
id|PREV.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/* new right extent - oldext */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|r
(braket
l_int|1
)braket
dot
id|br_startoff
comma
id|r
(braket
l_int|1
)braket
dot
id|br_startblock
comma
id|r
(braket
l_int|1
)braket
dot
id|br_blockcount
comma
id|r
(braket
l_int|1
)braket
dot
id|br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* new left extent - oldext */
id|PREV.br_blockcount
op_assign
r_new
op_member_access_from_pointer
id|br_startoff
op_minus
id|PREV.br_startoff
suffix:semicolon
id|cur-&gt;bc_rec.b
op_assign
id|PREV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/* new middle extent - newext */
id|cur-&gt;bc_rec.b
op_assign
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MASK3
c_func
(paren
id|LEFT_FILLING
comma
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK3
c_func
(paren
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK2
c_func
(paren
id|LEFT_FILLING
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK2
c_func
(paren
id|RIGHT_FILLING
comma
id|LEFT_CONTIG
)paren
suffix:colon
r_case
id|MASK2
c_func
(paren
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
r_case
id|MASK
c_func
(paren
id|LEFT_CONTIG
)paren
suffix:colon
r_case
id|MASK
c_func
(paren
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * These cases are all impossible.&n;&t;&t; */
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
op_star
id|curp
op_assign
id|cur
suffix:semicolon
id|done
suffix:colon
op_star
id|logflagsp
op_assign
id|rval
suffix:semicolon
r_return
id|error
suffix:semicolon
DECL|macro|LEFT
macro_line|#undef&t;LEFT
DECL|macro|RIGHT
macro_line|#undef&t;RIGHT
DECL|macro|PREV
macro_line|#undef&t;PREV
DECL|macro|MASK
macro_line|#undef&t;MASK
DECL|macro|MASK2
macro_line|#undef&t;MASK2
DECL|macro|MASK3
macro_line|#undef&t;MASK3
DECL|macro|MASK4
macro_line|#undef&t;MASK4
DECL|macro|STATE_SET
macro_line|#undef&t;STATE_SET
DECL|macro|STATE_TEST
macro_line|#undef&t;STATE_TEST
DECL|macro|STATE_SET_TEST
macro_line|#undef&t;STATE_SET_TEST
DECL|macro|SWITCH_STATE
macro_line|#undef&t;SWITCH_STATE
)brace
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting a hole&n; * to a delayed allocation.&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_extent_hole_delay
id|xfs_bmap_add_extent_hole_delay
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* if null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|rsvd
)paren
multiline_comment|/* OK to allocate reserved blocks */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent entry list */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent list entry for idx */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_add_extent_hole_delay&quot;
suffix:semicolon
macro_line|#endif
id|xfs_bmbt_irec_t
id|left
suffix:semicolon
multiline_comment|/* left neighbor extent entry */
id|xfs_filblks_t
id|newlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* new indirect size */
id|xfs_filblks_t
id|oldlen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* old indirect size */
id|xfs_bmbt_irec_t
id|right
suffix:semicolon
multiline_comment|/* right neighbor extent entry */
r_int
id|state
suffix:semicolon
multiline_comment|/* state bits, accessed thru macros */
id|xfs_filblks_t
id|temp
suffix:semicolon
multiline_comment|/* temp for indirect calculations */
r_enum
(brace
multiline_comment|/* bit number definitions for state */
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
comma
id|LEFT_DELAY
comma
id|RIGHT_DELAY
comma
id|LEFT_VALID
comma
id|RIGHT_VALID
)brace
suffix:semicolon
DECL|macro|MASK
mdefine_line|#define&t;MASK(b)&t;&t;&t;(1 &lt;&lt; (b))
DECL|macro|MASK2
mdefine_line|#define&t;MASK2(a,b)&t;&t;(MASK(a) | MASK(b))
DECL|macro|STATE_SET
mdefine_line|#define&t;STATE_SET(b,v)&t;&t;((v) ? (state |= MASK(b)) : (state &amp;= ~MASK(b)))
DECL|macro|STATE_TEST
mdefine_line|#define&t;STATE_TEST(b)&t;&t;(state &amp; MASK(b))
DECL|macro|STATE_SET_TEST
mdefine_line|#define&t;STATE_SET_TEST(b,v)&t;((v) ? ((state |= MASK(b)), 1) : &bslash;&n;&t;&t;&t;&t;       ((state &amp;= ~MASK(b)), 0))
DECL|macro|SWITCH_STATE
mdefine_line|#define&t;SWITCH_STATE&t;&t;(state &amp; MASK2(LEFT_CONTIG, RIGHT_CONTIG))
id|base
op_assign
id|ip-&gt;i_df.if_u1.if_extents
suffix:semicolon
id|ep
op_assign
op_amp
id|base
(braket
id|idx
)braket
suffix:semicolon
id|state
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|ISNULLSTARTBLOCK
c_func
(paren
r_new
op_member_access_from_pointer
id|br_startblock
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check and set flags if this segment has a left neighbor&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|LEFT_VALID
comma
id|idx
OG
l_int|0
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_minus
l_int|1
comma
op_amp
id|left
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|LEFT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|left.br_startblock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check and set flags if the current (right) segment exists.&n;&t; * If it doesn&squot;t exist, we&squot;re converting the hole at end-of-file.&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|RIGHT_VALID
comma
id|idx
OL
id|ip-&gt;i_df.if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|right
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|right.br_startblock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set contiguity flags on the left and right neighbors.&n;&t; * Don&squot;t let extents get too large, even if the pieces are contiguous.&n;&t; */
id|STATE_SET
c_func
(paren
id|LEFT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|LEFT_VALID
)paren
op_logical_and
id|STATE_TEST
c_func
(paren
id|LEFT_DELAY
)paren
op_logical_and
id|left.br_startoff
op_plus
id|left.br_blockcount
op_eq
r_new
op_member_access_from_pointer
id|br_startoff
op_logical_and
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_le
id|MAXEXTLEN
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|RIGHT_VALID
)paren
op_logical_and
id|STATE_TEST
c_func
(paren
id|RIGHT_DELAY
)paren
op_logical_and
r_new
op_member_access_from_pointer
id|br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_eq
id|right.br_startoff
op_logical_and
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
op_le
id|MAXEXTLEN
op_logical_and
(paren
op_logical_neg
id|STATE_TEST
c_func
(paren
id|LEFT_CONTIG
)paren
op_logical_or
(paren
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
op_le
id|MAXEXTLEN
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Switch out based on the contiguity flags.&n;&t; */
r_switch
c_cond
(paren
id|SWITCH_STATE
)paren
(brace
r_case
id|MASK2
c_func
(paren
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is contiguous with delayed allocations&n;&t;&t; * on the left and on the right.&n;&t;&t; * Merge all three into a single extent list entry.&n;&t;&t; */
id|temp
op_assign
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|temp
)paren
suffix:semicolon
id|oldlen
op_assign
id|STARTBLOCKVAL
c_func
(paren
id|left.br_startblock
)paren
op_plus
id|STARTBLOCKVAL
c_func
(paren
r_new
op_member_access_from_pointer
id|br_startblock
)paren
op_plus
id|STARTBLOCKVAL
c_func
(paren
id|right.br_startblock
)paren
suffix:semicolon
id|newlen
op_assign
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|newlen
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LC|RC&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|LEFT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is contiguous with a delayed allocation&n;&t;&t; * on the left.&n;&t;&t; * Merge the new allocation with the left neighbor.&n;&t;&t; */
id|temp
op_assign
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|temp
)paren
suffix:semicolon
id|oldlen
op_assign
id|STARTBLOCKVAL
c_func
(paren
id|left.br_startblock
)paren
op_plus
id|STARTBLOCKVAL
c_func
(paren
r_new
op_member_access_from_pointer
id|br_startblock
)paren
suffix:semicolon
id|newlen
op_assign
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|newlen
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is contiguous with a delayed allocation&n;&t;&t; * on the right.&n;&t;&t; * Merge the new allocation with the right neighbor.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|temp
op_assign
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
suffix:semicolon
id|oldlen
op_assign
id|STARTBLOCKVAL
c_func
(paren
r_new
op_member_access_from_pointer
id|br_startblock
)paren
op_plus
id|STARTBLOCKVAL
c_func
(paren
id|right.br_startblock
)paren
suffix:semicolon
id|newlen
op_assign
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
suffix:semicolon
id|xfs_bmbt_set_allf
c_func
(paren
id|ep
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|newlen
)paren
comma
id|temp
comma
id|right.br_state
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RC&quot;
comma
id|ip
comma
id|idx
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is not contiguous with another&n;&t;&t; * delayed allocation.&n;&t;&t; * Insert a new entry.&n;&t;&t; */
id|oldlen
op_assign
id|newlen
op_assign
l_int|0
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
l_int|NULL
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ip-&gt;i_df.if_lastex
op_assign
id|idx
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldlen
op_ne
id|newlen
)paren
(brace
id|ASSERT
c_func
(paren
id|oldlen
OG
id|newlen
)paren
suffix:semicolon
id|xfs_mod_incore_sb
c_func
(paren
id|ip-&gt;i_mount
comma
id|XFS_SBS_FDBLOCKS
comma
(paren
r_int
)paren
(paren
id|oldlen
op_minus
id|newlen
)paren
comma
id|rsvd
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Nothing to do for disk quota accounting here.&n;&t;&t; */
)brace
op_star
id|logflagsp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
DECL|macro|MASK
macro_line|#undef&t;MASK
DECL|macro|MASK2
macro_line|#undef&t;MASK2
DECL|macro|STATE_SET
macro_line|#undef&t;STATE_SET
DECL|macro|STATE_TEST
macro_line|#undef&t;STATE_TEST
DECL|macro|STATE_SET_TEST
macro_line|#undef&t;STATE_SET_TEST
DECL|macro|SWITCH_STATE
macro_line|#undef&t;SWITCH_STATE
)brace
multiline_comment|/*&n; * Called by xfs_bmap_add_extent to handle cases converting a hole&n; * to a real allocation.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_add_extent_hole_real
id|xfs_bmap_add_extent_hole_real
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/insert */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* if null, not a btree */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* new data to put in extent list */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* pointer to extent entry ins. point */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_add_extent_hole_real&quot;
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
multiline_comment|/* temp state */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_bmbt_irec_t
id|left
suffix:semicolon
multiline_comment|/* left neighbor extent entry */
id|xfs_bmbt_irec_t
id|right
suffix:semicolon
multiline_comment|/* right neighbor extent entry */
r_int
id|state
suffix:semicolon
multiline_comment|/* state bits, accessed thru macros */
r_enum
(brace
multiline_comment|/* bit number definitions for state */
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
comma
id|LEFT_DELAY
comma
id|RIGHT_DELAY
comma
id|LEFT_VALID
comma
id|RIGHT_VALID
)brace
suffix:semicolon
DECL|macro|MASK
mdefine_line|#define&t;MASK(b)&t;&t;&t;(1 &lt;&lt; (b))
DECL|macro|MASK2
mdefine_line|#define&t;MASK2(a,b)&t;&t;(MASK(a) | MASK(b))
DECL|macro|STATE_SET
mdefine_line|#define&t;STATE_SET(b,v)&t;&t;((v) ? (state |= MASK(b)) : (state &amp;= ~MASK(b)))
DECL|macro|STATE_TEST
mdefine_line|#define&t;STATE_TEST(b)&t;&t;(state &amp; MASK(b))
DECL|macro|STATE_SET_TEST
mdefine_line|#define&t;STATE_SET_TEST(b,v)&t;((v) ? ((state |= MASK(b)), 1) : &bslash;&n;&t;&t;&t;&t;       ((state &amp;= ~MASK(b)), 0))
DECL|macro|SWITCH_STATE
mdefine_line|#define&t;SWITCH_STATE&t;&t;(state &amp; MASK2(LEFT_CONTIG, RIGHT_CONTIG))
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idx
op_le
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
id|ep
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|idx
)braket
suffix:semicolon
id|state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Check and set flags if this segment has a left neighbor.&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|LEFT_VALID
comma
id|idx
OG
l_int|0
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_minus
l_int|1
comma
op_amp
id|left
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|LEFT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|left.br_startblock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check and set flags if this segment has a current value.&n;&t; * Not true if we&squot;re inserting into the &quot;hole&quot; at eof.&n;&t; */
r_if
c_cond
(paren
id|STATE_SET_TEST
c_func
(paren
id|RIGHT_VALID
comma
id|idx
OL
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|right
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_DELAY
comma
id|ISNULLSTARTBLOCK
c_func
(paren
id|right.br_startblock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We&squot;re inserting a real allocation between &quot;left&quot; and &quot;right&quot;.&n;&t; * Set the contiguity flags.  Don&squot;t let extents get too large.&n;&t; */
id|STATE_SET
c_func
(paren
id|LEFT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|LEFT_VALID
)paren
op_logical_and
op_logical_neg
id|STATE_TEST
c_func
(paren
id|LEFT_DELAY
)paren
op_logical_and
id|left.br_startoff
op_plus
id|left.br_blockcount
op_eq
r_new
op_member_access_from_pointer
id|br_startoff
op_logical_and
id|left.br_startblock
op_plus
id|left.br_blockcount
op_eq
r_new
op_member_access_from_pointer
id|br_startblock
op_logical_and
id|left.br_state
op_eq
r_new
op_member_access_from_pointer
id|br_state
op_logical_and
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_le
id|MAXEXTLEN
)paren
suffix:semicolon
id|STATE_SET
c_func
(paren
id|RIGHT_CONTIG
comma
id|STATE_TEST
c_func
(paren
id|RIGHT_VALID
)paren
op_logical_and
op_logical_neg
id|STATE_TEST
c_func
(paren
id|RIGHT_DELAY
)paren
op_logical_and
r_new
op_member_access_from_pointer
id|br_startoff
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_eq
id|right.br_startoff
op_logical_and
r_new
op_member_access_from_pointer
id|br_startblock
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_eq
id|right.br_startblock
op_logical_and
r_new
op_member_access_from_pointer
id|br_state
op_eq
id|right.br_state
op_logical_and
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
op_le
id|MAXEXTLEN
op_logical_and
(paren
op_logical_neg
id|STATE_TEST
c_func
(paren
id|LEFT_CONTIG
)paren
op_logical_or
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
op_le
id|MAXEXTLEN
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Select which case we&squot;re in here, and implement it.&n;&t; */
r_switch
c_cond
(paren
id|SWITCH_STATE
)paren
(brace
r_case
id|MASK2
c_func
(paren
id|LEFT_CONTIG
comma
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is contiguous with real allocations on the&n;&t;&t; * left and on the right.&n;&t;&t; * Merge all three into a single extent list entry.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LC|RC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;LC|RC&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
id|XFS_IFORK_NEXT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
(brace
op_star
id|logflagsp
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|logflagsp
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|right.br_startoff
comma
id|right.br_startblock
comma
id|right.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_decrement
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|left.br_startoff
comma
id|left.br_startblock
comma
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
comma
id|left.br_state
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|LEFT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is contiguous with a real allocation&n;&t;&t; * on the left.&n;&t;&t; * Merge the new allocation with the left neighbor.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;LC&quot;
comma
id|ip
comma
id|idx
op_minus
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
(brace
op_star
id|logflagsp
op_assign
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|logflagsp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|left.br_startoff
comma
id|left.br_startblock
comma
id|left.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|left.br_startoff
comma
id|left.br_startblock
comma
id|left.br_blockcount
op_plus
r_new
op_member_access_from_pointer
id|br_blockcount
comma
id|left.br_state
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
r_case
id|MASK
c_func
(paren
id|RIGHT_CONTIG
)paren
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is contiguous with a real allocation&n;&t;&t; * on the right.&n;&t;&t; * Merge the new allocation with the right neighbor.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;RC&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmbt_set_allf
c_func
(paren
id|ep
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
comma
id|right.br_state
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;RC&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
(brace
op_star
id|logflagsp
op_assign
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|logflagsp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|right.br_startoff
comma
id|right.br_startblock
comma
id|right.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
op_plus
id|right.br_blockcount
comma
id|right.br_state
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t; * New allocation is not contiguous with another&n;&t;&t; * real allocation.&n;&t;&t; * Insert a new entry.&n;&t;&t; */
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
r_new
comma
id|whichfork
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
suffix:semicolon
id|XFS_IFORK_NEXT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
l_int|NULL
)paren
(brace
op_star
id|logflagsp
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|logflagsp
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
r_new
op_member_access_from_pointer
id|br_startoff
comma
r_new
op_member_access_from_pointer
id|br_startblock
comma
r_new
op_member_access_from_pointer
id|br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|cur-&gt;bc_rec.b.br_state
op_assign
r_new
op_member_access_from_pointer
id|br_state
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|MASK
macro_line|#undef&t;MASK
DECL|macro|MASK2
macro_line|#undef&t;MASK2
DECL|macro|STATE_SET
macro_line|#undef&t;STATE_SET
DECL|macro|STATE_TEST
macro_line|#undef&t;STATE_TEST
DECL|macro|STATE_SET_TEST
macro_line|#undef&t;STATE_SET_TEST
DECL|macro|SWITCH_STATE
macro_line|#undef&t;SWITCH_STATE
multiline_comment|/* NOTREACHED */
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* keep gcc quite */
)brace
DECL|macro|XFS_ALLOC_GAP_UNITS
mdefine_line|#define XFS_ALLOC_GAP_UNITS&t;4
multiline_comment|/*&n; * xfs_bmap_alloc is called by xfs_bmapi to allocate an extent for a file.&n; * It figures out where to ask the underlying allocator to put the new extent.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_alloc
id|xfs_bmap_alloc
c_func
(paren
id|xfs_bmalloca_t
op_star
id|ap
)paren
multiline_comment|/* bmap alloc argument struct */
(brace
id|xfs_fsblock_t
id|adjust
suffix:semicolon
multiline_comment|/* adjustment to block numbers */
id|xfs_alloctype_t
id|atype
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* type for allocation routines */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_agnumber_t
id|fb_agno
suffix:semicolon
multiline_comment|/* ag number of ap-&gt;firstblock */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount point structure */
r_int
id|nullfb
suffix:semicolon
multiline_comment|/* true if ap-&gt;firstblock isn&squot;t set */
r_int
id|rt
suffix:semicolon
multiline_comment|/* true if inode is realtime */
macro_line|#ifdef __KERNEL__
id|xfs_extlen_t
id|prod
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* product factor for allocators */
id|xfs_extlen_t
id|ralen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* realtime allocation length */
macro_line|#endif
DECL|macro|ISVALID
mdefine_line|#define&t;ISVALID(x,y)&t;&bslash;&n;&t;(rt ? &bslash;&n;&t;&t;(x) &lt; mp-&gt;m_sb.sb_rblocks : &bslash;&n;&t;&t;XFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) &amp;&amp; &bslash;&n;&t;&t;XFS_FSB_TO_AGNO(mp, x) &lt; mp-&gt;m_sb.sb_agcount &amp;&amp; &bslash;&n;&t;&t;XFS_FSB_TO_AGBNO(mp, x) &lt; mp-&gt;m_sb.sb_agblocks)
multiline_comment|/*&n;&t; * Set up variables.&n;&t; */
id|mp
op_assign
id|ap-&gt;ip-&gt;i_mount
suffix:semicolon
id|nullfb
op_assign
id|ap-&gt;firstblock
op_eq
id|NULLFSBLOCK
suffix:semicolon
id|rt
op_assign
id|XFS_IS_REALTIME_INODE
c_func
(paren
id|ap-&gt;ip
)paren
op_logical_and
id|ap-&gt;userdata
suffix:semicolon
id|fb_agno
op_assign
id|nullfb
ques
c_cond
id|NULLAGNUMBER
suffix:colon
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|ap-&gt;firstblock
)paren
suffix:semicolon
macro_line|#ifdef __KERNEL__
r_if
c_cond
(paren
id|rt
)paren
(brace
id|xfs_extlen_t
id|extsz
suffix:semicolon
multiline_comment|/* file extent size for rt */
id|xfs_fileoff_t
id|nexto
suffix:semicolon
multiline_comment|/* next file offset */
id|xfs_extlen_t
id|orig_alen
suffix:semicolon
multiline_comment|/* original ap-&gt;alen */
id|xfs_fileoff_t
id|orig_end
suffix:semicolon
multiline_comment|/* original off+len */
id|xfs_fileoff_t
id|orig_off
suffix:semicolon
multiline_comment|/* original ap-&gt;off */
id|xfs_extlen_t
id|mod_off
suffix:semicolon
multiline_comment|/* modulus calculations */
id|xfs_fileoff_t
id|prevo
suffix:semicolon
multiline_comment|/* previous file offset */
id|xfs_rtblock_t
id|rtx
suffix:semicolon
multiline_comment|/* realtime extent number */
id|xfs_extlen_t
id|temp
suffix:semicolon
multiline_comment|/* temp for rt calculations */
multiline_comment|/*&n;&t;&t; * Set prod to match the realtime extent size.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|extsz
op_assign
id|ap-&gt;ip-&gt;i_d.di_extsize
)paren
)paren
id|extsz
op_assign
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
id|prod
op_assign
id|extsz
op_div
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
id|orig_off
op_assign
id|ap-&gt;off
suffix:semicolon
id|orig_alen
op_assign
id|ap-&gt;alen
suffix:semicolon
id|orig_end
op_assign
id|orig_off
op_plus
id|orig_alen
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the file offset is unaligned vs. the extent size&n;&t;&t; * we need to align it.  This will be possible unless&n;&t;&t; * the file was previously written with a kernel that didn&squot;t&n;&t;&t; * perform this alignment.&n;&t;&t; */
id|mod_off
op_assign
id|do_mod
c_func
(paren
id|orig_off
comma
id|extsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod_off
)paren
(brace
id|ap-&gt;alen
op_add_assign
id|mod_off
suffix:semicolon
id|ap-&gt;off
op_sub_assign
id|mod_off
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Same adjustment for the end of the requested area.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|temp
op_assign
(paren
id|ap-&gt;alen
op_mod
id|extsz
)paren
)paren
)paren
id|ap-&gt;alen
op_add_assign
id|extsz
op_minus
id|temp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the previous block overlaps with this proposed allocation&n;&t;&t; * then move the start forward without adjusting the length.&n;&t;&t; */
id|prevo
op_assign
id|ap-&gt;prevp-&gt;br_startoff
op_eq
id|NULLFILEOFF
ques
c_cond
l_int|0
suffix:colon
(paren
id|ap-&gt;prevp-&gt;br_startoff
op_plus
id|ap-&gt;prevp-&gt;br_blockcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;off
op_ne
id|orig_off
op_logical_and
id|ap-&gt;off
OL
id|prevo
)paren
id|ap-&gt;off
op_assign
id|prevo
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the next block overlaps with this proposed allocation&n;&t;&t; * then move the start back without adjusting the length,&n;&t;&t; * but not before offset 0.&n;&t;&t; * This may of course make the start overlap previous block,&n;&t;&t; * and if we hit the offset 0 limit then the next block&n;&t;&t; * can still overlap too.&n;&t;&t; */
id|nexto
op_assign
(paren
id|ap-&gt;eof
op_logical_or
id|ap-&gt;gotp-&gt;br_startoff
op_eq
id|NULLFILEOFF
)paren
ques
c_cond
id|NULLFILEOFF
suffix:colon
id|ap-&gt;gotp-&gt;br_startoff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;eof
op_logical_and
id|ap-&gt;off
op_plus
id|ap-&gt;alen
op_ne
id|orig_end
op_logical_and
id|ap-&gt;off
op_plus
id|ap-&gt;alen
OG
id|nexto
)paren
id|ap-&gt;off
op_assign
id|nexto
OG
id|ap-&gt;alen
ques
c_cond
id|nexto
op_minus
id|ap-&gt;alen
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re now overlapping the next or previous extent that&n;&t;&t; * means we can&squot;t fit an extsz piece in this hole.  Just move&n;&t;&t; * the start forward to the first valid spot and set&n;&t;&t; * the length so we hit the end.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ap-&gt;off
op_ne
id|orig_off
op_logical_and
id|ap-&gt;off
OL
id|prevo
)paren
op_logical_or
(paren
id|ap-&gt;off
op_plus
id|ap-&gt;alen
op_ne
id|orig_end
op_logical_and
id|ap-&gt;off
op_plus
id|ap-&gt;alen
OG
id|nexto
)paren
)paren
(brace
id|ap-&gt;off
op_assign
id|prevo
suffix:semicolon
id|ap-&gt;alen
op_assign
id|nexto
op_minus
id|prevo
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the result isn&squot;t a multiple of rtextents we need to&n;&t;&t; * remove blocks until it is.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|temp
op_assign
(paren
id|ap-&gt;alen
op_mod
id|mp-&gt;m_sb.sb_rextsize
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We&squot;re not covering the original request, or&n;&t;&t;&t; * we won&squot;t be able to once we fix the length.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|orig_off
template_param
id|ap-&gt;off
op_plus
id|ap-&gt;alen
op_logical_or
id|ap-&gt;alen
op_minus
id|temp
OL
id|orig_alen
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Try to fix it by moving the start up.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ap-&gt;off
op_plus
id|temp
op_le
id|orig_off
)paren
(brace
id|ap-&gt;alen
op_sub_assign
id|temp
suffix:semicolon
id|ap-&gt;off
op_add_assign
id|temp
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Try to fix it by moving the end in.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|ap-&gt;off
op_plus
id|ap-&gt;alen
op_minus
id|temp
op_ge
id|orig_end
)paren
id|ap-&gt;alen
op_sub_assign
id|temp
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set the start to the minimum then trim the length.&n;&t;&t;&t; */
r_else
(brace
id|ap-&gt;alen
op_sub_assign
id|orig_off
op_minus
id|ap-&gt;off
suffix:semicolon
id|ap-&gt;off
op_assign
id|orig_off
suffix:semicolon
id|ap-&gt;alen
op_sub_assign
id|ap-&gt;alen
op_mod
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Result doesn&squot;t cover the request, fail it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|orig_off
template_param
id|ap-&gt;off
op_plus
id|ap-&gt;alen
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ap-&gt;alen
op_mod
id|mp-&gt;m_sb.sb_rextsize
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the offset &amp; length are not perfectly aligned&n;&t;&t; * then kill prod, it will just get us in trouble.&n;&t;&t; */
r_if
c_cond
(paren
id|do_mod
c_func
(paren
id|ap-&gt;off
comma
id|extsz
)paren
op_logical_or
id|ap-&gt;alen
op_mod
id|extsz
)paren
id|prod
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set ralen to be the actual requested length in rtextents.&n;&t;&t; */
id|ralen
op_assign
id|ap-&gt;alen
op_div
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the old value was close enough to MAXEXTLEN that&n;&t;&t; * we rounded up to it, cut it back so it&squot;s valid again.&n;&t;&t; * Note that if it&squot;s a really large request (bigger than&n;&t;&t; * MAXEXTLEN), we don&squot;t hear about that number, and can&squot;t&n;&t;&t; * adjust the starting point to match it.&n;&t;&t; */
r_if
c_cond
(paren
id|ralen
op_star
id|mp-&gt;m_sb.sb_rextsize
op_ge
id|MAXEXTLEN
)paren
id|ralen
op_assign
id|MAXEXTLEN
op_div
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s an allocation to an empty file at offset 0,&n;&t;&t; * pick an extent that will space things out in the rt area.&n;&t;&t; */
r_if
c_cond
(paren
id|ap-&gt;eof
op_logical_and
id|ap-&gt;off
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_rtpick_extent
c_func
(paren
id|mp
comma
id|ap-&gt;tp
comma
id|ralen
comma
op_amp
id|rtx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ap-&gt;rval
op_assign
id|rtx
op_star
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
)brace
r_else
id|ap-&gt;rval
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|rt
)paren
id|ap-&gt;rval
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;/* __KERNEL__ */
r_else
r_if
c_cond
(paren
id|nullfb
)paren
id|ap-&gt;rval
op_assign
id|XFS_INO_TO_FSB
c_func
(paren
id|mp
comma
id|ap-&gt;ip-&gt;i_ino
)paren
suffix:semicolon
r_else
id|ap-&gt;rval
op_assign
id|ap-&gt;firstblock
suffix:semicolon
multiline_comment|/*&n;&t; * If allocating at eof, and there&squot;s a previous real block,&n;&t; * try to use it&squot;s last block as our starting point.&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;eof
op_logical_and
id|ap-&gt;prevp-&gt;br_startoff
op_ne
id|NULLFILEOFF
op_logical_and
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|ap-&gt;prevp-&gt;br_startblock
)paren
op_logical_and
id|ISVALID
c_func
(paren
id|ap-&gt;prevp-&gt;br_startblock
op_plus
id|ap-&gt;prevp-&gt;br_blockcount
comma
id|ap-&gt;prevp-&gt;br_startblock
)paren
)paren
(brace
id|ap-&gt;rval
op_assign
id|ap-&gt;prevp-&gt;br_startblock
op_plus
id|ap-&gt;prevp-&gt;br_blockcount
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Adjust for the gap between prevp and us.&n;&t;&t; */
id|adjust
op_assign
id|ap-&gt;off
op_minus
(paren
id|ap-&gt;prevp-&gt;br_startoff
op_plus
id|ap-&gt;prevp-&gt;br_blockcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adjust
op_logical_and
id|ISVALID
c_func
(paren
id|ap-&gt;rval
op_plus
id|adjust
comma
id|ap-&gt;prevp-&gt;br_startblock
)paren
)paren
id|ap-&gt;rval
op_add_assign
id|adjust
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If not at eof, then compare the two neighbor blocks.&n;&t; * Figure out whether either one gives us a good starting point,&n;&t; * and pick the better one.&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;eof
)paren
(brace
id|xfs_fsblock_t
id|gotbno
suffix:semicolon
multiline_comment|/* right side block number */
id|xfs_fsblock_t
id|gotdiff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* right side difference */
id|xfs_fsblock_t
id|prevbno
suffix:semicolon
multiline_comment|/* left side block number */
id|xfs_fsblock_t
id|prevdiff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* left side difference */
multiline_comment|/*&n;&t;&t; * If there&squot;s a previous (left) block, select a requested&n;&t;&t; * start block based on it.&n;&t;&t; */
r_if
c_cond
(paren
id|ap-&gt;prevp-&gt;br_startoff
op_ne
id|NULLFILEOFF
op_logical_and
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|ap-&gt;prevp-&gt;br_startblock
)paren
op_logical_and
(paren
id|prevbno
op_assign
id|ap-&gt;prevp-&gt;br_startblock
op_plus
id|ap-&gt;prevp-&gt;br_blockcount
)paren
op_logical_and
id|ISVALID
c_func
(paren
id|prevbno
comma
id|ap-&gt;prevp-&gt;br_startblock
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Calculate gap to end of previous block.&n;&t;&t;&t; */
id|adjust
op_assign
id|prevdiff
op_assign
id|ap-&gt;off
op_minus
(paren
id|ap-&gt;prevp-&gt;br_startoff
op_plus
id|ap-&gt;prevp-&gt;br_blockcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Figure the startblock based on the previous block&squot;s&n;&t;&t;&t; * end and the gap size.&n;&t;&t;&t; * Heuristic!&n;&t;&t;&t; * If the gap is large relative to the piece we&squot;re&n;&t;&t;&t; * allocating, or using it gives us an invalid block&n;&t;&t;&t; * number, then just use the end of the previous block.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|prevdiff
op_le
id|XFS_ALLOC_GAP_UNITS
op_star
id|ap-&gt;alen
op_logical_and
id|ISVALID
c_func
(paren
id|prevbno
op_plus
id|prevdiff
comma
id|ap-&gt;prevp-&gt;br_startblock
)paren
)paren
id|prevbno
op_add_assign
id|adjust
suffix:semicolon
r_else
id|prevdiff
op_add_assign
id|adjust
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the firstblock forbids it, can&squot;t use it,&n;&t;&t;&t; * must use default.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rt
op_logical_and
op_logical_neg
id|nullfb
op_logical_and
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|prevbno
)paren
op_ne
id|fb_agno
)paren
id|prevbno
op_assign
id|NULLFSBLOCK
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No previous block or can&squot;t follow it, just default.&n;&t;&t; */
r_else
id|prevbno
op_assign
id|NULLFSBLOCK
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there&squot;s a following (right) block, select a requested&n;&t;&t; * start block based on it.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|ap-&gt;gotp-&gt;br_startblock
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Calculate gap to start of next block.&n;&t;&t;&t; */
id|adjust
op_assign
id|gotdiff
op_assign
id|ap-&gt;gotp-&gt;br_startoff
op_minus
id|ap-&gt;off
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Figure the startblock based on the next block&squot;s&n;&t;&t;&t; * start and the gap size.&n;&t;&t;&t; */
id|gotbno
op_assign
id|ap-&gt;gotp-&gt;br_startblock
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Heuristic!&n;&t;&t;&t; * If the gap is large relative to the piece we&squot;re&n;&t;&t;&t; * allocating, or using it gives us an invalid block&n;&t;&t;&t; * number, then just use the start of the next block&n;&t;&t;&t; * offset by our length.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|gotdiff
op_le
id|XFS_ALLOC_GAP_UNITS
op_star
id|ap-&gt;alen
op_logical_and
id|ISVALID
c_func
(paren
id|gotbno
op_minus
id|gotdiff
comma
id|gotbno
)paren
)paren
id|gotbno
op_sub_assign
id|adjust
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ISVALID
c_func
(paren
id|gotbno
op_minus
id|ap-&gt;alen
comma
id|gotbno
)paren
)paren
(brace
id|gotbno
op_sub_assign
id|ap-&gt;alen
suffix:semicolon
id|gotdiff
op_add_assign
id|adjust
op_minus
id|ap-&gt;alen
suffix:semicolon
)brace
r_else
id|gotdiff
op_add_assign
id|adjust
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the firstblock forbids it, can&squot;t use it,&n;&t;&t;&t; * must use default.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rt
op_logical_and
op_logical_neg
id|nullfb
op_logical_and
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|gotbno
)paren
op_ne
id|fb_agno
)paren
id|gotbno
op_assign
id|NULLFSBLOCK
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No next block, just default.&n;&t;&t; */
r_else
id|gotbno
op_assign
id|NULLFSBLOCK
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If both valid, pick the better one, else the only good&n;&t;&t; * one, else ap-&gt;rval is already set (to 0 or the inode block).&n;&t;&t; */
r_if
c_cond
(paren
id|prevbno
op_ne
id|NULLFSBLOCK
op_logical_and
id|gotbno
op_ne
id|NULLFSBLOCK
)paren
id|ap-&gt;rval
op_assign
id|prevdiff
op_le
id|gotdiff
ques
c_cond
id|prevbno
suffix:colon
id|gotbno
suffix:semicolon
r_else
r_if
c_cond
(paren
id|prevbno
op_ne
id|NULLFSBLOCK
)paren
id|ap-&gt;rval
op_assign
id|prevbno
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gotbno
op_ne
id|NULLFSBLOCK
)paren
id|ap-&gt;rval
op_assign
id|gotbno
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If allowed, use ap-&gt;rval; otherwise must use firstblock since&n;&t; * it&squot;s in the right allocation group.&n;&t; */
r_if
c_cond
(paren
id|nullfb
op_logical_or
id|rt
op_logical_or
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|ap-&gt;rval
)paren
op_eq
id|fb_agno
)paren
suffix:semicolon
r_else
id|ap-&gt;rval
op_assign
id|ap-&gt;firstblock
suffix:semicolon
multiline_comment|/*&n;&t; * Realtime allocation, done through xfs_rtallocate_extent.&n;&t; */
r_if
c_cond
(paren
id|rt
)paren
(brace
macro_line|#ifndef __KERNEL__
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|xfs_rtblock_t
id|rtb
suffix:semicolon
id|atype
op_assign
id|ap-&gt;rval
op_eq
l_int|0
ques
c_cond
id|XFS_ALLOCTYPE_ANY_AG
suffix:colon
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
id|do_div
c_func
(paren
id|ap-&gt;rval
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
suffix:semicolon
id|rtb
op_assign
id|ap-&gt;rval
suffix:semicolon
id|ap-&gt;alen
op_assign
id|ralen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_rtallocate_extent
c_func
(paren
id|ap-&gt;tp
comma
id|ap-&gt;rval
comma
l_int|1
comma
id|ap-&gt;alen
comma
op_amp
id|ralen
comma
id|atype
comma
id|ap-&gt;wasdel
comma
id|prod
comma
op_amp
id|rtb
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|rtb
op_eq
id|NULLFSBLOCK
op_logical_and
id|prod
OG
l_int|1
op_logical_and
(paren
id|error
op_assign
id|xfs_rtallocate_extent
c_func
(paren
id|ap-&gt;tp
comma
id|ap-&gt;rval
comma
l_int|1
comma
id|ap-&gt;alen
comma
op_amp
id|ralen
comma
id|atype
comma
id|ap-&gt;wasdel
comma
l_int|1
comma
op_amp
id|rtb
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ap-&gt;rval
op_assign
id|rtb
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;rval
op_ne
id|NULLFSBLOCK
)paren
(brace
id|ap-&gt;rval
op_mul_assign
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
id|ralen
op_mul_assign
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
id|ap-&gt;alen
op_assign
id|ralen
suffix:semicolon
id|ap-&gt;ip-&gt;i_d.di_nblocks
op_add_assign
id|ralen
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|ap-&gt;tp
comma
id|ap-&gt;ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;wasdel
)paren
id|ap-&gt;ip-&gt;i_delayed_blks
op_sub_assign
id|ralen
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adjust the disk quota also. This was reserved&n;&t;&t;&t; * earlier.&n;&t;&t;&t; */
id|XFS_TRANS_MOD_DQUOT_BYINO
c_func
(paren
id|mp
comma
id|ap-&gt;tp
comma
id|ap-&gt;ip
comma
id|ap-&gt;wasdel
ques
c_cond
id|XFS_TRANS_DQ_DELRTBCOUNT
suffix:colon
id|XFS_TRANS_DQ_RTBCOUNT
comma
(paren
r_int
)paren
id|ralen
)paren
suffix:semicolon
)brace
r_else
id|ap-&gt;alen
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;/* __KERNEL__ */
)brace
multiline_comment|/*&n;&t; * Normal allocation, done through xfs_alloc_vextent.&n;&t; */
r_else
(brace
id|xfs_agnumber_t
id|ag
suffix:semicolon
id|xfs_alloc_arg_t
id|args
suffix:semicolon
id|xfs_extlen_t
id|blen
suffix:semicolon
id|xfs_extlen_t
id|delta
suffix:semicolon
r_int
id|isaligned
suffix:semicolon
id|xfs_extlen_t
id|longest
suffix:semicolon
id|xfs_extlen_t
id|need
suffix:semicolon
id|xfs_extlen_t
id|nextminlen
op_assign
l_int|0
suffix:semicolon
r_int
id|notinit
suffix:semicolon
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
id|xfs_agnumber_t
id|startag
suffix:semicolon
r_int
id|tryagain
suffix:semicolon
id|tryagain
op_assign
id|isaligned
op_assign
l_int|0
suffix:semicolon
id|args.tp
op_assign
id|ap-&gt;tp
suffix:semicolon
id|args.mp
op_assign
id|mp
suffix:semicolon
id|args.fsbno
op_assign
id|ap-&gt;rval
suffix:semicolon
id|args.maxlen
op_assign
id|MIN
c_func
(paren
id|ap-&gt;alen
comma
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
id|blen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nullfb
)paren
(brace
id|args.type
op_assign
id|XFS_ALLOCTYPE_START_BNO
suffix:semicolon
id|args.total
op_assign
id|ap-&gt;total
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Find the longest available space.&n;&t;&t;&t; * We&squot;re going to try for the whole allocation at once.&n;&t;&t;&t; */
id|startag
op_assign
id|ag
op_assign
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|args.fsbno
)paren
suffix:semicolon
id|notinit
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_while
c_loop
(paren
id|blen
OL
id|ap-&gt;alen
)paren
(brace
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|ag
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pag-&gt;pagf_init
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_pagf_init
c_func
(paren
id|mp
comma
id|args.tp
comma
id|ag
comma
id|XFS_ALLOC_FLAG_TRYLOCK
)paren
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * See xfs_alloc_fix_freelist...&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|pag-&gt;pagf_init
)paren
(brace
id|need
op_assign
id|XFS_MIN_FREELIST_PAG
c_func
(paren
id|pag
comma
id|mp
)paren
suffix:semicolon
id|delta
op_assign
id|need
OG
id|pag-&gt;pagf_flcount
ques
c_cond
id|need
op_minus
id|pag-&gt;pagf_flcount
suffix:colon
l_int|0
suffix:semicolon
id|longest
op_assign
(paren
id|pag-&gt;pagf_longest
OG
id|delta
)paren
ques
c_cond
(paren
id|pag-&gt;pagf_longest
op_minus
id|delta
)paren
suffix:colon
(paren
id|pag-&gt;pagf_flcount
OG
l_int|0
op_logical_or
id|pag-&gt;pagf_longest
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blen
OL
id|longest
)paren
id|blen
op_assign
id|longest
suffix:semicolon
)brace
r_else
id|notinit
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ag
op_eq
id|mp-&gt;m_sb.sb_agcount
)paren
id|ag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ag
op_eq
id|startag
)paren
r_break
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since the above loop did a BUF_TRYLOCK, it is&n;&t;&t;&t; * possible that there is space for this request.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|notinit
op_logical_or
id|blen
OL
id|ap-&gt;minlen
)paren
id|args.minlen
op_assign
id|ap-&gt;minlen
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the best seen length is less than the request&n;&t;&t;&t; * length, use the best as the minimum.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|blen
OL
id|ap-&gt;alen
)paren
id|args.minlen
op_assign
id|blen
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Otherwise we&squot;ve seen an extent as big as alen,&n;&t;&t;&t; * use that as the minimum.&n;&t;&t;&t; */
r_else
id|args.minlen
op_assign
id|ap-&gt;alen
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;low
)paren
(brace
id|args.type
op_assign
id|XFS_ALLOCTYPE_FIRST_AG
suffix:semicolon
id|args.total
op_assign
id|args.minlen
op_assign
id|ap-&gt;minlen
suffix:semicolon
)brace
r_else
(brace
id|args.type
op_assign
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
id|args.total
op_assign
id|ap-&gt;total
suffix:semicolon
id|args.minlen
op_assign
id|ap-&gt;minlen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;ip-&gt;i_d.di_extsize
)paren
(brace
id|args.prod
op_assign
id|ap-&gt;ip-&gt;i_d.di_extsize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|args.mod
op_assign
(paren
id|xfs_extlen_t
)paren
id|do_mod
c_func
(paren
id|ap-&gt;off
comma
id|args.prod
)paren
)paren
)paren
id|args.mod
op_assign
(paren
id|xfs_extlen_t
)paren
(paren
id|args.prod
op_minus
id|args.mod
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mp-&gt;m_sb.sb_blocksize
op_ge
id|NBPP
)paren
(brace
id|args.prod
op_assign
l_int|1
suffix:semicolon
id|args.mod
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|args.prod
op_assign
id|NBPP
op_rshift
id|mp-&gt;m_sb.sb_blocklog
suffix:semicolon
r_if
c_cond
(paren
(paren
id|args.mod
op_assign
(paren
id|xfs_extlen_t
)paren
(paren
id|do_mod
c_func
(paren
id|ap-&gt;off
comma
id|args.prod
)paren
)paren
)paren
)paren
id|args.mod
op_assign
(paren
id|xfs_extlen_t
)paren
(paren
id|args.prod
op_minus
id|args.mod
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we are not low on available data blocks, and the&n;&t;&t; * underlying logical volume manager is a stripe, and&n;&t;&t; * the file offset is zero then try to allocate data&n;&t;&t; * blocks on stripe unit boundary.&n;&t;&t; * NOTE: ap-&gt;aeof is only set if the allocation length&n;&t;&t; * is &gt;= the stripe unit and the allocation offset is&n;&t;&t; * at the end of file.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;low
op_logical_and
id|ap-&gt;aeof
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ap-&gt;off
)paren
(brace
id|args.alignment
op_assign
id|mp-&gt;m_dalign
suffix:semicolon
id|atype
op_assign
id|args.type
suffix:semicolon
id|isaligned
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Adjust for alignment&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|blen
OG
id|args.alignment
op_logical_and
id|blen
op_le
id|ap-&gt;alen
)paren
id|args.minlen
op_assign
id|blen
op_minus
id|args.alignment
suffix:semicolon
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * First try an exact bno allocation.&n;&t;&t;&t;&t; * If it fails then do a near or start bno&n;&t;&t;&t;&t; * allocation with alignment turned on.&n;&t;&t;&t;&t; */
id|atype
op_assign
id|args.type
suffix:semicolon
id|tryagain
op_assign
l_int|1
suffix:semicolon
id|args.type
op_assign
id|XFS_ALLOCTYPE_THIS_BNO
suffix:semicolon
id|args.alignment
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Compute the minlen+alignment for the&n;&t;&t;&t;&t; * next case.  Set slop so that the value&n;&t;&t;&t;&t; * of minlen+alignment+slop doesn&squot;t go up&n;&t;&t;&t;&t; * between the calls.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|blen
OG
id|mp-&gt;m_dalign
op_logical_and
id|blen
op_le
id|ap-&gt;alen
)paren
id|nextminlen
op_assign
id|blen
op_minus
id|mp-&gt;m_dalign
suffix:semicolon
r_else
id|nextminlen
op_assign
id|args.minlen
suffix:semicolon
r_if
c_cond
(paren
id|nextminlen
op_plus
id|mp-&gt;m_dalign
OG
id|args.minlen
op_plus
l_int|1
)paren
id|args.minalignslop
op_assign
id|nextminlen
op_plus
id|mp-&gt;m_dalign
op_minus
id|args.minlen
op_minus
l_int|1
suffix:semicolon
r_else
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|args.alignment
op_assign
l_int|1
suffix:semicolon
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
)brace
id|args.minleft
op_assign
id|ap-&gt;minleft
suffix:semicolon
id|args.wasdel
op_assign
id|ap-&gt;wasdel
suffix:semicolon
id|args.isfl
op_assign
l_int|0
suffix:semicolon
id|args.userdata
op_assign
id|ap-&gt;userdata
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|tryagain
op_logical_and
id|args.fsbno
op_eq
id|NULLFSBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Exact allocation failed. Now try with alignment&n;&t;&t;&t; * turned on.&n;&t;&t;&t; */
id|args.type
op_assign
id|atype
suffix:semicolon
id|args.fsbno
op_assign
id|ap-&gt;rval
suffix:semicolon
id|args.alignment
op_assign
id|mp-&gt;m_dalign
suffix:semicolon
id|args.minlen
op_assign
id|nextminlen
suffix:semicolon
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
id|isaligned
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isaligned
op_logical_and
id|args.fsbno
op_eq
id|NULLFSBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * allocation failed, so turn off alignment and&n;&t;&t;&t; * try again.&n;&t;&t;&t; */
id|args.type
op_assign
id|atype
suffix:semicolon
id|args.fsbno
op_assign
id|ap-&gt;rval
suffix:semicolon
id|args.alignment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.fsbno
op_eq
id|NULLFSBLOCK
op_logical_and
id|nullfb
op_logical_and
id|args.minlen
OG
id|ap-&gt;minlen
)paren
(brace
id|args.minlen
op_assign
id|ap-&gt;minlen
suffix:semicolon
id|args.type
op_assign
id|XFS_ALLOCTYPE_START_BNO
suffix:semicolon
id|args.fsbno
op_assign
id|ap-&gt;rval
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.fsbno
op_eq
id|NULLFSBLOCK
op_logical_and
id|nullfb
)paren
(brace
id|args.fsbno
op_assign
l_int|0
suffix:semicolon
id|args.type
op_assign
id|XFS_ALLOCTYPE_FIRST_AG
suffix:semicolon
id|args.total
op_assign
id|ap-&gt;minlen
suffix:semicolon
id|args.minleft
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|ap-&gt;low
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.fsbno
op_ne
id|NULLFSBLOCK
)paren
(brace
id|ap-&gt;firstblock
op_assign
id|ap-&gt;rval
op_assign
id|args.fsbno
suffix:semicolon
id|ASSERT
c_func
(paren
id|nullfb
op_logical_or
id|fb_agno
op_eq
id|args.agno
op_logical_or
(paren
id|ap-&gt;low
op_logical_and
id|fb_agno
OL
id|args.agno
)paren
)paren
suffix:semicolon
id|ap-&gt;alen
op_assign
id|args.len
suffix:semicolon
id|ap-&gt;ip-&gt;i_d.di_nblocks
op_add_assign
id|args.len
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|ap-&gt;tp
comma
id|ap-&gt;ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;wasdel
)paren
id|ap-&gt;ip-&gt;i_delayed_blks
op_sub_assign
id|args.len
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Adjust the disk quota also. This was reserved&n;&t;&t;&t; * earlier.&n;&t;&t;&t; */
id|XFS_TRANS_MOD_DQUOT_BYINO
c_func
(paren
id|mp
comma
id|ap-&gt;tp
comma
id|ap-&gt;ip
comma
id|ap-&gt;wasdel
ques
c_cond
id|XFS_TRANS_DQ_DELBCOUNT
suffix:colon
id|XFS_TRANS_DQ_BCOUNT
comma
(paren
r_int
)paren
id|args.len
)paren
suffix:semicolon
)brace
r_else
(brace
id|ap-&gt;rval
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|ap-&gt;alen
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
DECL|macro|ISVALID
macro_line|#undef&t;ISVALID
)brace
multiline_comment|/*&n; * Transform a btree format file with only one leaf node, where the&n; * extents list will fit in the inode, into an extents format file.&n; * Since the extent list is already in-core, all we have to do is&n; * give up the space for the btree root and pitch the leaf block.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_btree_to_extents
id|xfs_bmap_btree_to_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
multiline_comment|/* REFERENCED */
id|xfs_bmbt_block_t
op_star
id|cblock
suffix:semicolon
multiline_comment|/* child btree block */
id|xfs_fsblock_t
id|cbno
suffix:semicolon
multiline_comment|/* child block number */
id|xfs_buf_t
op_star
id|cbp
suffix:semicolon
multiline_comment|/* child block&squot;s buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork data */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount point structure */
id|xfs_bmbt_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* ptr to block address */
id|xfs_bmbt_block_t
op_star
id|rblock
suffix:semicolon
multiline_comment|/* root btree block */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_BTREE
)paren
suffix:semicolon
id|rblock
op_assign
id|ifp-&gt;if_broot
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|rblock-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|rblock-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BMAP_BROOT_MAXRECS
c_func
(paren
id|ifp-&gt;if_broot_bytes
)paren
op_eq
l_int|1
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|pp
op_assign
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|rblock
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
op_star
id|logflagsp
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_lptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
comma
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
id|cbno
op_assign
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
id|tp
comma
id|cbno
comma
l_int|0
comma
op_amp
id|cbp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|cblock
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|cbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_lblock
c_func
(paren
id|cur
comma
id|cblock
comma
l_int|0
comma
id|cbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|xfs_bmap_add_free
c_func
(paren
id|cbno
comma
l_int|1
comma
id|cur-&gt;bc_private.b.flist
comma
id|mp
)paren
suffix:semicolon
id|ip-&gt;i_d.di_nblocks
op_decrement
suffix:semicolon
id|XFS_TRANS_MOD_DQUOT_BYINO
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|XFS_TRANS_DQ_BCOUNT
comma
op_minus
l_int|1L
)paren
suffix:semicolon
id|xfs_trans_binval
c_func
(paren
id|tp
comma
id|cbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur-&gt;bc_bufs
(braket
l_int|0
)braket
op_eq
id|cbp
)paren
id|cur-&gt;bc_bufs
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|xfs_iroot_realloc
c_func
(paren
id|ip
comma
op_minus
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_broot
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFBROOT
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|XFS_IFORK_FMT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
id|XFS_DINODE_FMT_EXTENTS
)paren
suffix:semicolon
op_star
id|logflagsp
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by xfs_bmapi to update extent list structure and the btree&n; * after removing space (or undoing a delayed allocation).&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_del_extent
id|xfs_bmap_del_extent
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* current transaction pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* extent number to update/delete */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* list of extents to be freed */
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* if null, not a btree */
id|xfs_bmbt_irec_t
op_star
id|del
comma
multiline_comment|/* data to remove from extent list */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
r_int
id|rsvd
)paren
multiline_comment|/* OK to allocate reserved blocks */
(brace
id|xfs_filblks_t
id|da_new
suffix:semicolon
multiline_comment|/* new delay-alloc indirect blocks */
id|xfs_filblks_t
id|da_old
suffix:semicolon
multiline_comment|/* old delay-alloc indirect blocks */
id|xfs_fsblock_t
id|del_endblock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first block past del */
id|xfs_fileoff_t
id|del_endoff
suffix:semicolon
multiline_comment|/* first offset past del */
r_int
id|delay
suffix:semicolon
multiline_comment|/* current block is delayed allocated */
r_int
id|do_fx
suffix:semicolon
multiline_comment|/* free extent at end of routine */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* current extent entry pointer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|flags
suffix:semicolon
multiline_comment|/* inode logging flags */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_del_extent&quot;
suffix:semicolon
macro_line|#endif
id|xfs_bmbt_irec_t
id|got
suffix:semicolon
multiline_comment|/* current extent entry */
id|xfs_fileoff_t
id|got_endoff
suffix:semicolon
multiline_comment|/* first offset past got */
r_int
id|i
suffix:semicolon
multiline_comment|/* temp state */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
id|xfs_filblks_t
id|nblks
suffix:semicolon
multiline_comment|/* quota/sb block count */
id|xfs_bmbt_irec_t
r_new
suffix:semicolon
multiline_comment|/* new record to be inserted */
multiline_comment|/* REFERENCED */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extents in list */
id|uint
id|qfield
suffix:semicolon
multiline_comment|/* quota field to update */
id|xfs_filblks_t
id|temp
suffix:semicolon
multiline_comment|/* for indirect length calculations */
id|xfs_filblks_t
id|temp2
suffix:semicolon
multiline_comment|/* for indirect length calculations */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_del_exlist
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|idx
op_ge
l_int|0
op_logical_and
id|idx
OL
id|nextents
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|del-&gt;br_blockcount
OG
l_int|0
)paren
suffix:semicolon
id|ep
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|idx
)braket
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|got.br_startoff
op_le
id|del-&gt;br_startoff
)paren
suffix:semicolon
id|del_endoff
op_assign
id|del-&gt;br_startoff
op_plus
id|del-&gt;br_blockcount
suffix:semicolon
id|got_endoff
op_assign
id|got.br_startoff
op_plus
id|got.br_blockcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|got_endoff
op_ge
id|del_endoff
)paren
suffix:semicolon
id|delay
op_assign
id|ISNULLSTARTBLOCK
c_func
(paren
id|got.br_startblock
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ISNULLSTARTBLOCK
c_func
(paren
id|del-&gt;br_startblock
)paren
op_eq
id|delay
)paren
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
id|qfield
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If deleting a real allocation, must free up the disk space.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|delay
)paren
(brace
id|flags
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Realtime allocation.  Free it and record di_nblocks update.&n;&t;&t; */
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
op_logical_and
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
)paren
(brace
id|xfs_fsblock_t
id|bno
suffix:semicolon
id|xfs_filblks_t
id|len
suffix:semicolon
id|ASSERT
c_func
(paren
id|do_mod
c_func
(paren
id|del-&gt;br_blockcount
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|do_mod
c_func
(paren
id|del-&gt;br_startblock
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|bno
op_assign
id|del-&gt;br_startblock
suffix:semicolon
id|len
op_assign
id|del-&gt;br_blockcount
suffix:semicolon
id|do_div
c_func
(paren
id|bno
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|len
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_rtfree_extent
c_func
(paren
id|ip-&gt;i_transp
comma
id|bno
comma
(paren
id|xfs_extlen_t
)paren
id|len
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|do_fx
op_assign
l_int|0
suffix:semicolon
id|nblks
op_assign
id|len
op_star
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
id|qfield
op_assign
id|XFS_TRANS_DQ_RTBCOUNT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Ordinary allocation.&n;&t;&t; */
r_else
(brace
id|do_fx
op_assign
l_int|1
suffix:semicolon
id|nblks
op_assign
id|del-&gt;br_blockcount
suffix:semicolon
id|qfield
op_assign
id|XFS_TRANS_DQ_BCOUNT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set up del_endblock and cur for later.&n;&t;&t; */
id|del_endblock
op_assign
id|del-&gt;br_startblock
op_plus
id|del-&gt;br_blockcount
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|got.br_startoff
comma
id|got.br_startblock
comma
id|got.br_blockcount
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
id|da_old
op_assign
id|da_new
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|da_old
op_assign
id|STARTBLOCKVAL
c_func
(paren
id|got.br_startblock
)paren
suffix:semicolon
id|da_new
op_assign
l_int|0
suffix:semicolon
id|nblks
op_assign
l_int|0
suffix:semicolon
id|do_fx
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set flag value to use in switch statement.&n;&t; * Left-contig is 2, right-contig is 1.&n;&t; */
r_switch
c_cond
(paren
(paren
(paren
id|got.br_startoff
op_eq
id|del-&gt;br_startoff
)paren
op_lshift
l_int|1
)paren
op_or
(paren
id|got_endoff
op_eq
id|del_endoff
)paren
)paren
(brace
r_case
l_int|3
suffix:colon
multiline_comment|/*&n;&t;&t; * Matches the whole extent.  Delete the entry.&n;&t;&t; */
id|xfs_bmap_trace_delete
c_func
(paren
id|fname
comma
l_string|&quot;3&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_delete_exlist
c_func
(paren
id|ip
comma
id|idx
comma
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|delay
)paren
r_break
suffix:semicolon
id|XFS_IFORK_NEXT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|flags
op_or_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur
)paren
(brace
id|flags
op_or_assign
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*&n;&t;&t; * Deleting the first part of the extent.&n;&t;&t; */
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;2&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmbt_set_startoff
c_func
(paren
id|ep
comma
id|del_endoff
)paren
suffix:semicolon
id|temp
op_assign
id|got.br_blockcount
op_minus
id|del-&gt;br_blockcount
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|delay
)paren
(brace
id|temp
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
comma
id|da_old
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;2&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|da_new
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|del_endblock
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;2&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur
)paren
(brace
id|flags
op_or_assign
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|del_endoff
comma
id|del_endblock
comma
id|got.br_blockcount
op_minus
id|del-&gt;br_blockcount
comma
id|got.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*&n;&t;&t; * Deleting the last part of the extent.&n;&t;&t; */
id|temp
op_assign
id|got.br_blockcount
op_minus
id|del-&gt;br_blockcount
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;1&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
suffix:semicolon
r_if
c_cond
(paren
id|delay
)paren
(brace
id|temp
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
comma
id|da_old
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;1&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|da_new
op_assign
id|temp
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;1&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur
)paren
(brace
id|flags
op_or_assign
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|got.br_startoff
comma
id|got.br_startblock
comma
id|got.br_blockcount
op_minus
id|del-&gt;br_blockcount
comma
id|got.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;&t;&t; * Deleting the middle of the extent.&n;&t;&t; */
id|temp
op_assign
id|del-&gt;br_startoff
op_minus
id|got.br_startoff
suffix:semicolon
id|xfs_bmap_trace_pre_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|temp
)paren
suffix:semicolon
r_new
dot
id|br_startoff
op_assign
id|del_endoff
suffix:semicolon
id|temp2
op_assign
id|got_endoff
op_minus
id|del_endoff
suffix:semicolon
r_new
dot
id|br_blockcount
op_assign
id|temp2
suffix:semicolon
r_new
dot
id|br_state
op_assign
id|got.br_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delay
)paren
(brace
r_new
dot
id|br_startblock
op_assign
id|del_endblock
suffix:semicolon
id|flags
op_or_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|got.br_startoff
comma
id|got.br_startblock
comma
id|temp
comma
id|got.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|cur-&gt;bc_rec.b
op_assign
r_new
suffix:semicolon
id|error
op_assign
id|xfs_bmbt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_and
id|error
op_ne
id|ENOSPC
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If get no-space back from btree insert,&n;&t;&t;&t;&t; * it tried a split, and we have a zero&n;&t;&t;&t;&t; * block reservation.&n;&t;&t;&t;&t; * Fix up our state and return the error.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Reset the cursor, don&squot;t trust&n;&t;&t;&t;&t;&t; * it after any insert operation.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_lookup_eq
c_func
(paren
id|cur
comma
id|got.br_startoff
comma
id|got.br_startblock
comma
id|temp
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Update the btree record back&n;&t;&t;&t;&t;&t; * to the original value.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmbt_update
c_func
(paren
id|cur
comma
id|got.br_startoff
comma
id|got.br_startblock
comma
id|got.br_blockcount
comma
id|got.br_state
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Reset the extent record back&n;&t;&t;&t;&t;&t; * to the original value.&n;&t;&t;&t;&t;&t; */
id|xfs_bmbt_set_blockcount
c_func
(paren
id|ep
comma
id|got.br_blockcount
)paren
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|flags
op_or_assign
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
id|XFS_IFORK_NEXT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|temp
op_assign
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp
)paren
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
id|temp2
op_assign
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|temp2
)paren
suffix:semicolon
r_new
dot
id|br_startblock
op_assign
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp2
)paren
suffix:semicolon
id|da_new
op_assign
id|temp
op_plus
id|temp2
suffix:semicolon
r_while
c_loop
(paren
id|da_new
OG
id|da_old
)paren
(brace
r_if
c_cond
(paren
id|temp
)paren
(brace
id|temp
op_decrement
suffix:semicolon
id|da_new
op_decrement
suffix:semicolon
id|xfs_bmbt_set_startblock
c_func
(paren
id|ep
comma
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|da_new
op_eq
id|da_old
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|temp2
)paren
(brace
id|temp2
op_decrement
suffix:semicolon
id|da_new
op_decrement
suffix:semicolon
r_new
dot
id|br_startblock
op_assign
id|NULLSTARTBLOCK
c_func
(paren
(paren
r_int
)paren
id|temp2
)paren
suffix:semicolon
)brace
)brace
)brace
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;0&quot;
comma
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
op_amp
r_new
comma
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_insert_exlist
c_func
(paren
id|ip
comma
id|idx
op_plus
l_int|1
comma
l_int|1
comma
op_amp
r_new
comma
id|whichfork
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|idx
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we need to, add to list of extents to delete.&n;&t; */
r_if
c_cond
(paren
id|do_fx
)paren
id|xfs_bmap_add_free
c_func
(paren
id|del-&gt;br_startblock
comma
id|del-&gt;br_blockcount
comma
id|flist
comma
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust inode # blocks in the file.&n;&t; */
r_if
c_cond
(paren
id|nblks
)paren
id|ip-&gt;i_d.di_nblocks
op_sub_assign
id|nblks
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust quota data.&n;&t; */
r_if
c_cond
(paren
id|qfield
)paren
id|XFS_TRANS_MOD_DQUOT_BYINO
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|qfield
comma
(paren
r_int
)paren
op_minus
id|nblks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Account for change in delayed indirect blocks.&n;&t; * Nothing to do for disk quota accounting here.&n;&t; */
id|ASSERT
c_func
(paren
id|da_old
op_ge
id|da_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|da_old
OG
id|da_new
)paren
id|xfs_mod_incore_sb
c_func
(paren
id|mp
comma
id|XFS_SBS_FDBLOCKS
comma
(paren
r_int
)paren
(paren
id|da_old
op_minus
id|da_new
)paren
comma
id|rsvd
)paren
suffix:semicolon
id|done
suffix:colon
op_star
id|logflagsp
op_assign
id|flags
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove the entry &quot;free&quot; from the free item list.  Prev points to the&n; * previous entry, unless &quot;free&quot; is the head of the list.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_del_free
id|xfs_bmap_del_free
c_func
(paren
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* free item list header */
id|xfs_bmap_free_item_t
op_star
id|prev
comma
multiline_comment|/* previous item on list, if any */
id|xfs_bmap_free_item_t
op_star
id|free
)paren
multiline_comment|/* list item to be freed */
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;xbfi_next
op_assign
id|free-&gt;xbfi_next
suffix:semicolon
r_else
id|flist-&gt;xbf_first
op_assign
id|free-&gt;xbfi_next
suffix:semicolon
id|flist-&gt;xbf_count
op_decrement
suffix:semicolon
id|kmem_zone_free
c_func
(paren
id|xfs_bmap_free_item_zone
comma
id|free
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove count entries from the extents array for inode &quot;ip&quot;, starting&n; * at index &quot;idx&quot;.  Copies the remaining items down over the deleted ones,&n; * and gives back the excess memory.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_delete_exlist
id|xfs_bmap_delete_exlist
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* starting delete index */
id|xfs_extnum_t
id|count
comma
multiline_comment|/* count of items to delete */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent list */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extents in list after */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
suffix:semicolon
id|base
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
op_minus
id|count
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|base
(braket
id|idx
)braket
comma
op_amp
id|base
(braket
id|idx
op_plus
id|count
)braket
comma
(paren
id|nextents
op_minus
id|idx
)paren
op_star
r_sizeof
(paren
op_star
id|base
)paren
)paren
suffix:semicolon
id|xfs_iext_realloc
c_func
(paren
id|ip
comma
op_minus
id|count
comma
id|whichfork
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an extents-format file into a btree-format file.&n; * The new file will have a root block (in the inode) and a single child block.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_extents_to_btree
id|xfs_bmap_extents_to_btree
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first-block-allocated */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* blocks freed in xaction */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* cursor returned to caller */
r_int
id|wasdel
comma
multiline_comment|/* converting a delayed alloc */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_block_t
op_star
id|ablock
suffix:semicolon
multiline_comment|/* allocated (child) bt block */
id|xfs_buf_t
op_star
id|abp
suffix:semicolon
multiline_comment|/* buffer for ablock */
id|xfs_alloc_arg_t
id|args
suffix:semicolon
multiline_comment|/* allocation arguments */
id|xfs_bmbt_rec_t
op_star
id|arp
suffix:semicolon
multiline_comment|/* child record pointer */
id|xfs_bmbt_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree root block */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* bmap btree cursor */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent list pointer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_extnum_t
id|i
comma
id|cnt
suffix:semicolon
multiline_comment|/* extent list index */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_bmbt_key_t
op_star
id|kp
suffix:semicolon
multiline_comment|/* root block key pointer */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* extent list size */
id|xfs_bmbt_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* root block address pointer */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_ext_max
op_eq
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make space in the inode incore.&n;&t; */
id|xfs_iroot_realloc
c_func
(paren
id|ip
comma
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|ifp-&gt;if_flags
op_or_assign
id|XFS_IFBROOT
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the root.&n;&t; */
id|block
op_assign
id|ifp-&gt;if_broot
suffix:semicolon
id|INT_SET
c_func
(paren
id|block-&gt;bb_magic
comma
id|ARCH_CONVERT
comma
id|XFS_BMAP_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
comma
id|NULLDFSBNO
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
comma
id|NULLDFSBNO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need a cursor.  Can&squot;t allocate until bb_level is filled in.&n;&t; */
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
l_int|NULL
comma
l_int|0
comma
id|XFS_BTNUM_BMAP
comma
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|cur-&gt;bc_private.b.firstblock
op_assign
op_star
id|firstblock
suffix:semicolon
id|cur-&gt;bc_private.b.flist
op_assign
id|flist
suffix:semicolon
id|cur-&gt;bc_private.b.flags
op_assign
id|wasdel
ques
c_cond
id|XFS_BTCUR_BPRV_WASDEL
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Convert to a btree with two levels, one record in root.&n;&t; */
id|XFS_IFORK_FMT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
id|XFS_DINODE_FMT_BTREE
)paren
suffix:semicolon
id|args.tp
op_assign
id|tp
suffix:semicolon
id|args.mp
op_assign
id|mp
suffix:semicolon
r_if
c_cond
(paren
op_star
id|firstblock
op_eq
id|NULLFSBLOCK
)paren
(brace
id|args.type
op_assign
id|XFS_ALLOCTYPE_START_BNO
suffix:semicolon
id|args.fsbno
op_assign
id|XFS_INO_TO_FSB
c_func
(paren
id|mp
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flist-&gt;xbf_low
)paren
(brace
id|args.type
op_assign
id|XFS_ALLOCTYPE_START_BNO
suffix:semicolon
id|args.fsbno
op_assign
op_star
id|firstblock
suffix:semicolon
)brace
r_else
(brace
id|args.type
op_assign
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
id|args.fsbno
op_assign
op_star
id|firstblock
suffix:semicolon
)brace
id|args.minlen
op_assign
id|args.maxlen
op_assign
id|args.prod
op_assign
l_int|1
suffix:semicolon
id|args.total
op_assign
id|args.minleft
op_assign
id|args.alignment
op_assign
id|args.mod
op_assign
id|args.isfl
op_assign
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
id|args.wasdel
op_assign
id|wasdel
suffix:semicolon
op_star
id|logflagsp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
(brace
id|xfs_iroot_realloc
c_func
(paren
id|ip
comma
op_minus
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocation can&squot;t fail, the space was reserved.&n;&t; */
id|ASSERT
c_func
(paren
id|args.fsbno
op_ne
id|NULLFSBLOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|firstblock
op_eq
id|NULLFSBLOCK
op_logical_or
id|args.agno
op_eq
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
op_star
id|firstblock
)paren
op_logical_or
(paren
id|flist-&gt;xbf_low
op_logical_and
id|args.agno
OG
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
op_star
id|firstblock
)paren
)paren
)paren
suffix:semicolon
op_star
id|firstblock
op_assign
id|cur-&gt;bc_private.b.firstblock
op_assign
id|args.fsbno
suffix:semicolon
id|cur-&gt;bc_private.b.allocated
op_increment
suffix:semicolon
id|ip-&gt;i_d.di_nblocks
op_increment
suffix:semicolon
id|XFS_TRANS_MOD_DQUOT_BYINO
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|XFS_TRANS_DQ_BCOUNT
comma
l_int|1L
)paren
suffix:semicolon
id|abp
op_assign
id|xfs_btree_get_bufl
c_func
(paren
id|mp
comma
id|tp
comma
id|args.fsbno
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the child block.&n;&t; */
id|ablock
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|abp
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ablock-&gt;bb_magic
comma
id|ARCH_CONVERT
comma
id|XFS_BMAP_MAGIC
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|ablock-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ablock-&gt;bb_leftsib
comma
id|ARCH_CONVERT
comma
id|NULLDFSBNO
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ablock-&gt;bb_rightsib
comma
id|ARCH_CONVERT
comma
id|NULLDFSBNO
)paren
suffix:semicolon
id|arp
op_assign
id|XFS_BMAP_REC_IADDR
c_func
(paren
id|ablock
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ep
op_assign
id|ifp-&gt;if_u1.if_extents
comma
id|cnt
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nextents
suffix:semicolon
id|i
op_increment
comma
id|ep
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|xfs_bmbt_get_startblock
c_func
(paren
id|ep
)paren
)paren
)paren
(brace
id|arp-&gt;l0
op_assign
id|INT_GET
c_func
(paren
id|ep-&gt;l0
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|arp-&gt;l1
op_assign
id|INT_GET
c_func
(paren
id|ep-&gt;l1
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|arp
op_increment
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
)brace
id|INT_SET
c_func
(paren
id|ablock-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
id|cnt
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|ablock-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the root key and pointer.&n;&t; */
id|kp
op_assign
id|XFS_BMAP_KEY_IADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|arp
op_assign
id|XFS_BMAP_REC_IADDR
c_func
(paren
id|ablock
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|kp-&gt;br_startoff
comma
id|ARCH_CONVERT
comma
id|xfs_bmbt_disk_get_startoff
c_func
(paren
id|arp
)paren
)paren
suffix:semicolon
id|pp
op_assign
id|XFS_BMAP_PTR_IADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
comma
id|args.fsbno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do all this logging at the end so that&n;&t; * the root is at the right level.&n;&t; */
id|xfs_bmbt_log_block
c_func
(paren
id|cur
comma
id|abp
comma
id|XFS_BB_ALL_BITS
)paren
suffix:semicolon
id|xfs_bmbt_log_recs
c_func
(paren
id|cur
comma
id|abp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|ablock-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|curp
op_eq
l_int|NULL
)paren
suffix:semicolon
op_star
id|curp
op_assign
id|cur
suffix:semicolon
op_star
id|logflagsp
op_assign
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_FBROOT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert new item(s) in the extent list for inode &quot;ip&quot;.&n; * Count new items are inserted at offset idx.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_insert_exlist
id|xfs_bmap_insert_exlist
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* starting index of new items */
id|xfs_extnum_t
id|count
comma
multiline_comment|/* number of inserted items */
id|xfs_bmbt_irec_t
op_star
r_new
comma
multiline_comment|/* items to insert */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* extent list base */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* extent list size */
id|xfs_extnum_t
id|to
suffix:semicolon
multiline_comment|/* extent list index */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
suffix:semicolon
id|xfs_iext_realloc
c_func
(paren
id|ip
comma
id|count
comma
id|whichfork
)paren
suffix:semicolon
id|base
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|base
(braket
id|idx
op_plus
id|count
)braket
comma
op_amp
id|base
(braket
id|idx
)braket
comma
(paren
id|nextents
op_minus
(paren
id|idx
op_plus
id|count
)paren
)paren
op_star
r_sizeof
(paren
op_star
id|base
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|to
op_assign
id|idx
suffix:semicolon
id|to
OL
id|idx
op_plus
id|count
suffix:semicolon
id|to
op_increment
comma
r_new
op_increment
)paren
id|xfs_bmbt_set_all
c_func
(paren
op_amp
id|base
(braket
id|to
)braket
comma
r_new
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a local file to an extents file.&n; * This code is out of bounds for data forks of regular files,&n; * since the file data needs to get logged so things will stay consistent.&n; * (The bmap-level manipulations are ok, though).&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_local_to_extents
id|xfs_bmap_local_to_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first block allocated in xaction */
id|xfs_extlen_t
id|total
comma
multiline_comment|/* total blocks needed by transaction */
r_int
op_star
id|logflagsp
comma
multiline_comment|/* inode logging flags */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|flags
suffix:semicolon
multiline_comment|/* logging flags returned */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_local_to_extents&quot;
suffix:semicolon
macro_line|#endif
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
multiline_comment|/*&n;&t; * We don&squot;t want to deal with the case of keeping inode data inline yet.&n;&t; * So sending the data fork of a regular inode is invalid.&n;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFREG
op_logical_and
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
)paren
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ifp-&gt;if_bytes
)paren
(brace
id|xfs_alloc_arg_t
id|args
suffix:semicolon
multiline_comment|/* allocation arguments */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for extent list block */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent list pointer */
id|args.tp
op_assign
id|tp
suffix:semicolon
id|args.mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate a block.  We know we need only one, since the&n;&t;&t; * file currently fits in an inode.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|firstblock
op_eq
id|NULLFSBLOCK
)paren
(brace
id|args.fsbno
op_assign
id|XFS_INO_TO_FSB
c_func
(paren
id|args.mp
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|args.type
op_assign
id|XFS_ALLOCTYPE_START_BNO
suffix:semicolon
)brace
r_else
(brace
id|args.fsbno
op_assign
op_star
id|firstblock
suffix:semicolon
id|args.type
op_assign
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
)brace
id|args.total
op_assign
id|total
suffix:semicolon
id|args.mod
op_assign
id|args.minleft
op_assign
id|args.alignment
op_assign
id|args.wasdel
op_assign
id|args.isfl
op_assign
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
id|args.minlen
op_assign
id|args.maxlen
op_assign
id|args.prod
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Can&squot;t fail, the space was reserved.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|args.fsbno
op_ne
id|NULLFSBLOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args.len
op_eq
l_int|1
)paren
suffix:semicolon
op_star
id|firstblock
op_assign
id|args.fsbno
suffix:semicolon
id|bp
op_assign
id|xfs_btree_get_bufl
c_func
(paren
id|args.mp
comma
id|tp
comma
id|args.fsbno
comma
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
id|ifp-&gt;if_u1.if_data
comma
id|ifp-&gt;if_bytes
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
l_int|0
comma
id|ifp-&gt;if_bytes
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|ip
comma
op_minus
id|ifp-&gt;if_bytes
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_iext_realloc
c_func
(paren
id|ip
comma
l_int|1
comma
id|whichfork
)paren
suffix:semicolon
id|ep
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
id|xfs_bmbt_set_allf
c_func
(paren
id|ep
comma
l_int|0
comma
id|args.fsbno
comma
l_int|1
comma
id|XFS_EXT_NORM
)paren
suffix:semicolon
id|xfs_bmap_trace_post_update
c_func
(paren
id|fname
comma
l_string|&quot;new&quot;
comma
id|ip
comma
l_int|0
comma
id|whichfork
)paren
suffix:semicolon
id|XFS_IFORK_NEXT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
l_int|1
)paren
suffix:semicolon
id|ip-&gt;i_d.di_nblocks
op_assign
l_int|1
suffix:semicolon
id|XFS_TRANS_MOD_DQUOT_BYINO
c_func
(paren
id|args.mp
comma
id|tp
comma
id|ip
comma
id|XFS_TRANS_DQ_BCOUNT
comma
l_int|1L
)paren
suffix:semicolon
id|flags
op_or_assign
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
)brace
r_else
id|ASSERT
c_func
(paren
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ifp-&gt;if_flags
op_and_assign
op_complement
id|XFS_IFINLINE
suffix:semicolon
id|ifp-&gt;if_flags
op_or_assign
id|XFS_IFEXTENTS
suffix:semicolon
id|XFS_IFORK_FMT_SET
c_func
(paren
id|ip
comma
id|whichfork
comma
id|XFS_DINODE_FMT_EXTENTS
)paren
suffix:semicolon
id|flags
op_or_assign
id|XFS_ILOG_CORE
suffix:semicolon
id|done
suffix:colon
op_star
id|logflagsp
op_assign
id|flags
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_bmbt_rec_t
op_star
multiline_comment|/* pointer to found extent entry */
DECL|function|xfs_bmap_do_search_extents
id|xfs_bmap_do_search_extents
c_func
(paren
id|xfs_bmbt_rec_t
op_star
id|base
comma
multiline_comment|/* base of extent list */
id|xfs_extnum_t
id|lastx
comma
multiline_comment|/* last extent index used */
id|xfs_extnum_t
id|nextents
comma
multiline_comment|/* extent list size */
id|xfs_fileoff_t
id|bno
comma
multiline_comment|/* block number searched for */
r_int
op_star
id|eofp
comma
multiline_comment|/* out: end of file found */
id|xfs_extnum_t
op_star
id|lastxp
comma
multiline_comment|/* out: last extent index */
id|xfs_bmbt_irec_t
op_star
id|gotp
comma
multiline_comment|/* out: extent entry found */
id|xfs_bmbt_irec_t
op_star
id|prevp
)paren
multiline_comment|/* out: previous extent entry found */
(brace
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent list entry pointer */
id|xfs_bmbt_irec_t
id|got
suffix:semicolon
multiline_comment|/* extent list entry, decoded */
r_int
id|high
suffix:semicolon
multiline_comment|/* high index of binary search */
r_int
id|low
suffix:semicolon
multiline_comment|/* low index of binary search */
r_if
c_cond
(paren
id|lastx
op_ne
id|NULLEXTNUM
op_logical_and
id|lastx
OL
id|nextents
)paren
id|ep
op_assign
id|base
op_plus
id|lastx
suffix:semicolon
r_else
id|ep
op_assign
l_int|NULL
suffix:semicolon
id|prevp-&gt;br_startoff
op_assign
id|NULLFILEOFF
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_logical_and
id|bno
op_ge
(paren
id|got.br_startoff
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
)paren
)paren
op_logical_and
id|bno
OL
id|got.br_startoff
op_plus
(paren
id|got.br_blockcount
op_assign
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
)paren
)paren
)paren
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ep
op_logical_and
id|lastx
OL
id|nextents
op_minus
l_int|1
op_logical_and
id|bno
op_ge
(paren
id|got.br_startoff
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
op_plus
l_int|1
)paren
)paren
op_logical_and
id|bno
OL
id|got.br_startoff
op_plus
(paren
id|got.br_blockcount
op_assign
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|lastx
op_increment
suffix:semicolon
id|ep
op_increment
suffix:semicolon
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nextents
op_eq
l_int|0
)paren
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bno
op_eq
l_int|0
op_logical_and
(paren
id|got.br_startoff
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|base
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ep
op_assign
id|base
suffix:semicolon
id|lastx
op_assign
l_int|0
suffix:semicolon
id|got.br_blockcount
op_assign
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
)paren
suffix:semicolon
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* binary search the extents array */
id|low
op_assign
l_int|0
suffix:semicolon
id|high
op_assign
id|nextents
op_minus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|low
op_le
id|high
)paren
(brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_cmp_exlist
)paren
suffix:semicolon
id|lastx
op_assign
(paren
id|low
op_plus
id|high
)paren
op_rshift
l_int|1
suffix:semicolon
id|ep
op_assign
id|base
op_plus
id|lastx
suffix:semicolon
id|got.br_startoff
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
)paren
suffix:semicolon
id|got.br_blockcount
op_assign
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bno
OL
id|got.br_startoff
)paren
id|high
op_assign
id|lastx
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bno
op_ge
id|got.br_startoff
op_plus
id|got.br_blockcount
)paren
id|low
op_assign
id|lastx
op_plus
l_int|1
suffix:semicolon
r_else
(brace
id|got.br_startblock
op_assign
id|xfs_bmbt_get_startblock
c_func
(paren
id|ep
)paren
suffix:semicolon
id|got.br_state
op_assign
id|xfs_bmbt_get_state
c_func
(paren
id|ep
)paren
suffix:semicolon
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
op_star
id|lastxp
op_assign
id|lastx
suffix:semicolon
op_star
id|gotp
op_assign
id|got
suffix:semicolon
r_return
id|ep
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bno
op_ge
id|got.br_startoff
op_plus
id|got.br_blockcount
)paren
(brace
id|lastx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lastx
op_eq
id|nextents
)paren
(brace
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
id|got.br_startblock
op_assign
id|xfs_bmbt_get_startblock
c_func
(paren
id|ep
)paren
suffix:semicolon
id|got.br_state
op_assign
id|xfs_bmbt_get_state
c_func
(paren
id|ep
)paren
suffix:semicolon
op_star
id|prevp
op_assign
id|got
suffix:semicolon
id|ep
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
id|prevp
)paren
suffix:semicolon
id|ep
op_increment
suffix:semicolon
id|got.br_startoff
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
)paren
suffix:semicolon
id|got.br_blockcount
op_assign
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ep
OG
id|base
)paren
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_minus
l_int|1
comma
id|prevp
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ep
)paren
(brace
id|got.br_startblock
op_assign
id|xfs_bmbt_get_startblock
c_func
(paren
id|ep
)paren
suffix:semicolon
id|got.br_state
op_assign
id|xfs_bmbt_get_state
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
op_star
id|lastxp
op_assign
id|lastx
suffix:semicolon
op_star
id|gotp
op_assign
id|got
suffix:semicolon
r_return
id|ep
suffix:semicolon
)brace
multiline_comment|/*&n; * Search the extents list for the inode, for the extent containing bno.&n; * If bno lies in a hole, point to the next entry.  If bno lies past eof,&n; * *eofp will be set, and *prevp will contain the last entry (null if none).&n; * Else, *lastxp will be set to the index of the found&n; * entry; *gotp will contain the entry.&n; */
id|STATIC
id|xfs_bmbt_rec_t
op_star
multiline_comment|/* pointer to found extent entry */
DECL|function|xfs_bmap_search_extents
id|xfs_bmap_search_extents
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fileoff_t
id|bno
comma
multiline_comment|/* block number searched for */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
r_int
op_star
id|eofp
comma
multiline_comment|/* out: end of file found */
id|xfs_extnum_t
op_star
id|lastxp
comma
multiline_comment|/* out: last extent index */
id|xfs_bmbt_irec_t
op_star
id|gotp
comma
multiline_comment|/* out: extent entry found */
id|xfs_bmbt_irec_t
op_star
id|prevp
)paren
multiline_comment|/* out: previous extent entry found */
(brace
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent list */
id|xfs_extnum_t
id|lastx
suffix:semicolon
multiline_comment|/* last extent index used */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* extent list size */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_look_exlist
)paren
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|lastx
op_assign
id|ifp-&gt;if_lastex
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|base
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
l_int|0
)braket
suffix:semicolon
r_return
id|xfs_bmap_do_search_extents
c_func
(paren
id|base
comma
id|lastx
comma
id|nextents
comma
id|bno
comma
id|eofp
comma
id|lastxp
comma
id|gotp
comma
id|prevp
)paren
suffix:semicolon
)brace
macro_line|#ifdef XFS_BMAP_TRACE
multiline_comment|/*&n; * Add a bmap trace buffer entry.  Base routine for the others.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_trace_addentry
id|xfs_bmap_trace_addentry
c_func
(paren
r_int
id|opcode
comma
multiline_comment|/* operation */
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry(ies) */
id|xfs_extnum_t
id|cnt
comma
multiline_comment|/* count of entries, 1 or 2 */
id|xfs_bmbt_rec_t
op_star
id|r1
comma
multiline_comment|/* first record */
id|xfs_bmbt_rec_t
op_star
id|r2
comma
multiline_comment|/* second record or null */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
id|tr2
suffix:semicolon
id|ASSERT
c_func
(paren
id|cnt
op_eq
l_int|1
op_logical_or
id|cnt
op_eq
l_int|2
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|r1
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|1
)paren
(brace
id|ASSERT
c_func
(paren
id|r2
op_eq
l_int|NULL
)paren
suffix:semicolon
id|r2
op_assign
op_amp
id|tr2
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tr2
comma
l_int|0
comma
r_sizeof
(paren
id|tr2
)paren
)paren
suffix:semicolon
)brace
r_else
id|ASSERT
c_func
(paren
id|r2
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|xfs_bmap_trace_buf
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|opcode
op_or
(paren
id|whichfork
op_lshift
l_int|16
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|fname
comma
(paren
r_void
op_star
)paren
id|desc
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|idx
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|cnt
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|ip-&gt;i_ino
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
id|ip-&gt;i_ino
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l0
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l0
comma
id|ARCH_CONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l1
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l1
comma
id|ARCH_CONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l0
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l0
comma
id|ARCH_CONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l1
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l1
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_xtrace
)paren
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|ip-&gt;i_xtrace
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|opcode
op_or
(paren
id|whichfork
op_lshift
l_int|16
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|fname
comma
(paren
r_void
op_star
)paren
id|desc
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|idx
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|cnt
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|ip-&gt;i_ino
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
id|ip-&gt;i_ino
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l0
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l0
comma
id|ARCH_CONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l1
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;l1
comma
id|ARCH_CONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l0
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l0
comma
id|ARCH_CONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l1
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|32
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|r2-&gt;l1
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add bmap trace entry prior to a call to xfs_bmap_delete_exlist.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_trace_delete
id|xfs_bmap_trace_delete
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry(entries) deleted */
id|xfs_extnum_t
id|cnt
comma
multiline_comment|/* count of entries deleted, 1 or 2 */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_trace_addentry
c_func
(paren
id|XFS_BMAP_KTRACE_DELETE
comma
id|fname
comma
id|desc
comma
id|ip
comma
id|idx
comma
id|cnt
comma
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|idx
)braket
comma
id|cnt
op_eq
l_int|2
ques
c_cond
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|idx
op_plus
l_int|1
)braket
suffix:colon
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add bmap trace entry prior to a call to xfs_bmap_insert_exlist, or&n; * reading in the extents list from the disk (in the btree).&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_trace_insert
id|xfs_bmap_trace_insert
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry(entries) inserted */
id|xfs_extnum_t
id|cnt
comma
multiline_comment|/* count of entries inserted, 1 or 2 */
id|xfs_bmbt_irec_t
op_star
id|r1
comma
multiline_comment|/* inserted record 1 */
id|xfs_bmbt_irec_t
op_star
id|r2
comma
multiline_comment|/* inserted record 2 or null */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
id|tr1
suffix:semicolon
multiline_comment|/* compressed record 1 */
id|xfs_bmbt_rec_t
id|tr2
suffix:semicolon
multiline_comment|/* compressed record 2 if needed */
id|xfs_bmbt_set_all
c_func
(paren
op_amp
id|tr1
comma
id|r1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|2
)paren
(brace
id|ASSERT
c_func
(paren
id|r2
op_ne
l_int|NULL
)paren
suffix:semicolon
id|xfs_bmbt_set_all
c_func
(paren
op_amp
id|tr2
comma
id|r2
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|cnt
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|r2
op_eq
l_int|NULL
)paren
suffix:semicolon
)brace
id|xfs_bmap_trace_addentry
c_func
(paren
id|XFS_BMAP_KTRACE_INSERT
comma
id|fname
comma
id|desc
comma
id|ip
comma
id|idx
comma
id|cnt
comma
op_amp
id|tr1
comma
id|cnt
op_eq
l_int|2
ques
c_cond
op_amp
id|tr2
suffix:colon
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add bmap trace entry after updating an extent list entry in place.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_trace_post_update
id|xfs_bmap_trace_post_update
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry updated */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_trace_addentry
c_func
(paren
id|XFS_BMAP_KTRACE_POST_UP
comma
id|fname
comma
id|desc
comma
id|ip
comma
id|idx
comma
l_int|1
comma
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|idx
)braket
comma
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add bmap trace entry prior to updating an extent list entry in place.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_trace_pre_update
id|xfs_bmap_trace_pre_update
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
r_char
op_star
id|desc
comma
multiline_comment|/* operation description */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|idx
comma
multiline_comment|/* index of entry to be updated */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|xfs_bmap_trace_addentry
c_func
(paren
id|XFS_BMAP_KTRACE_PRE_UP
comma
id|fname
comma
id|desc
comma
id|ip
comma
id|idx
comma
l_int|1
comma
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|idx
)braket
comma
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* XFS_BMAP_TRACE */
multiline_comment|/*&n; * Compute the worst-case number of indirect blocks that will be used&n; * for ip&squot;s delayed extent of length &quot;len&quot;.&n; */
id|STATIC
id|xfs_filblks_t
DECL|function|xfs_bmap_worst_indlen
id|xfs_bmap_worst_indlen
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_filblks_t
id|len
)paren
multiline_comment|/* delayed extent length */
(brace
r_int
id|level
suffix:semicolon
multiline_comment|/* btree level number */
r_int
id|maxrecs
suffix:semicolon
multiline_comment|/* maximum record count at this level */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
id|xfs_filblks_t
id|rval
suffix:semicolon
multiline_comment|/* return value */
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|maxrecs
op_assign
id|mp-&gt;m_bmap_dmxr
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|0
comma
id|rval
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|XFS_BM_MAXLEVELS
c_func
(paren
id|mp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|level
op_increment
)paren
(brace
id|len
op_add_assign
id|maxrecs
op_minus
l_int|1
suffix:semicolon
id|do_div
c_func
(paren
id|len
comma
id|maxrecs
)paren
suffix:semicolon
id|rval
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|1
)paren
r_return
id|rval
op_plus
id|XFS_BM_MAXLEVELS
c_func
(paren
id|mp
comma
id|XFS_DATA_FORK
)paren
op_minus
id|level
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|0
)paren
id|maxrecs
op_assign
id|mp-&gt;m_bmap_dmxr
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
macro_line|#if defined(DEBUG) &amp;&amp; defined(XFS_RW_TRACE)
id|STATIC
r_void
DECL|function|xfs_bunmap_trace
id|xfs_bunmap_trace
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_fileoff_t
id|bno
comma
id|xfs_filblks_t
id|len
comma
r_int
id|flags
comma
id|inst_t
op_star
id|ra
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_rwtrace
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|ip-&gt;i_rwtrace
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|XFS_BUNMAPI
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
(paren
id|ip-&gt;i_d.di_size
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|ip-&gt;i_d.di_size
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
(paren
(paren
id|xfs_dfiloff_t
)paren
id|bno
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
(paren
id|xfs_dfiloff_t
)paren
id|bno
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|len
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|flags
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
r_private
dot
id|p_cpuid
comma
(paren
r_void
op_star
)paren
id|ra
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Convert inode from non-attributed to attributed.&n; * Must not be in a transaction, ip must not be locked.&n; */
r_int
multiline_comment|/* error code */
DECL|function|xfs_bmap_add_attrfork
id|xfs_bmap_add_attrfork
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
r_int
id|rsvd
)paren
multiline_comment|/* OK to allocated reserved blocks in trans */
(brace
r_int
id|blks
suffix:semicolon
multiline_comment|/* space reservation */
r_int
id|committed
suffix:semicolon
multiline_comment|/* xaction was committed */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_fsblock_t
id|firstblock
suffix:semicolon
multiline_comment|/* 1st block/ag allocated */
id|xfs_bmap_free_t
id|flist
suffix:semicolon
multiline_comment|/* freed extent list */
r_int
id|logflags
suffix:semicolon
multiline_comment|/* logging flags */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
r_int
r_int
id|s
suffix:semicolon
multiline_comment|/* spinlock spl value */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_ext_max
op_eq
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_NOT_DQATTACHED
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_ADDAFORK
)paren
suffix:semicolon
id|blks
op_assign
id|XFS_ADDAFORK_SPACE_RES
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rsvd
)paren
id|tp-&gt;t_flags
op_or_assign
id|XFS_TRANS_RESERVE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|blks
comma
id|XFS_ADDAFORK_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ADDAFORK_LOG_COUNT
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|XFS_TRANS_RESERVE_QUOTA_NBLKS
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
id|blks
comma
l_int|0
comma
id|rsvd
ques
c_cond
id|XFS_QMOPT_RES_REGBLKS
op_or
id|XFS_QMOPT_FORCE_RES
suffix:colon
id|XFS_QMOPT_RES_REGBLKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
)paren
r_goto
id|error1
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_aformat
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
(brace
multiline_comment|/*&n;&t;&t; * For inodes coming from pre-6.2 filesystems.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_aformat
op_eq
l_int|0
)paren
suffix:semicolon
id|ip-&gt;i_d.di_aformat
op_assign
id|XFS_DINODE_FMT_EXTENTS
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_format
)paren
(brace
r_case
id|XFS_DINODE_FMT_DEV
suffix:colon
id|ip-&gt;i_d.di_forkoff
op_assign
id|roundup
c_func
(paren
r_sizeof
(paren
id|xfs_dev_t
)paren
comma
l_int|8
)paren
op_rshift
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_UUID
suffix:colon
id|ip-&gt;i_d.di_forkoff
op_assign
id|roundup
c_func
(paren
r_sizeof
(paren
id|uuid_t
)paren
comma
l_int|8
)paren
op_rshift
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|ip-&gt;i_d.di_forkoff
op_assign
id|mp-&gt;m_attroffset
op_rshift
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|ip-&gt;i_df.if_ext_max
op_assign
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip-&gt;i_afp
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_ifork_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ip-&gt;i_afp-&gt;if_ext_max
op_assign
id|XFS_IFORK_ASIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|ip-&gt;i_afp-&gt;if_flags
op_assign
id|XFS_IFEXTENTS
suffix:semicolon
id|logflags
op_assign
l_int|0
suffix:semicolon
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|flist
comma
op_amp
id|firstblock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_format
)paren
(brace
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
id|error
op_assign
id|xfs_bmap_add_attrfork_local
c_func
(paren
id|tp
comma
id|ip
comma
op_amp
id|firstblock
comma
op_amp
id|flist
comma
op_amp
id|logflags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|error
op_assign
id|xfs_bmap_add_attrfork_extents
c_func
(paren
id|tp
comma
id|ip
comma
op_amp
id|firstblock
comma
op_amp
id|flist
comma
op_amp
id|logflags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|error
op_assign
id|xfs_bmap_add_attrfork_btree
c_func
(paren
id|tp
comma
id|ip
comma
op_amp
id|firstblock
comma
op_amp
id|flist
comma
op_amp
id|logflags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logflags
)paren
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|logflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASATTR
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASATTR
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|XFS_SB_VERSION_ADDATTR
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|xfs_mod_sb
c_func
(paren
id|tp
comma
id|XFS_SB_VERSIONNUM
)paren
suffix:semicolon
)brace
r_else
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|flist
comma
id|firstblock
comma
op_amp
id|committed
)paren
)paren
)paren
r_goto
id|error2
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_PERM_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_ext_max
op_eq
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|error2
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|flist
)paren
suffix:semicolon
id|error1
suffix:colon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error0
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_ext_max
op_eq
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the extent to the list of extents to be free at transaction end.&n; * The list is maintained sorted (by block number).&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_bmap_add_free
id|xfs_bmap_add_free
c_func
(paren
id|xfs_fsblock_t
id|bno
comma
multiline_comment|/* fs block number of extent */
id|xfs_filblks_t
id|len
comma
multiline_comment|/* length of extent */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* list of extents */
id|xfs_mount_t
op_star
id|mp
)paren
multiline_comment|/* mount point structure */
(brace
id|xfs_bmap_free_item_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* current (next) element */
id|xfs_bmap_free_item_t
op_star
r_new
suffix:semicolon
multiline_comment|/* new element */
id|xfs_bmap_free_item_t
op_star
id|prev
suffix:semicolon
multiline_comment|/* previous element */
macro_line|#ifdef DEBUG
id|xfs_agnumber_t
id|agno
suffix:semicolon
id|xfs_agblock_t
id|agbno
suffix:semicolon
id|ASSERT
c_func
(paren
id|bno
op_ne
id|NULLFSBLOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
op_le
id|MAXEXTLEN
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|bno
)paren
)paren
suffix:semicolon
id|agno
op_assign
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|bno
)paren
suffix:semicolon
id|agbno
op_assign
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|bno
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agno
OL
id|mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agbno
OL
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
OL
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agbno
op_plus
id|len
op_le
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|xfs_bmap_free_item_zone
op_ne
l_int|NULL
)paren
suffix:semicolon
r_new
op_assign
id|kmem_zone_alloc
c_func
(paren
id|xfs_bmap_free_item_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|xbfi_startblock
op_assign
id|bno
suffix:semicolon
r_new
op_member_access_from_pointer
id|xbfi_blockcount
op_assign
(paren
id|xfs_extlen_t
)paren
id|len
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
l_int|NULL
comma
id|cur
op_assign
id|flist-&gt;xbf_first
suffix:semicolon
id|cur
op_ne
l_int|NULL
suffix:semicolon
id|prev
op_assign
id|cur
comma
id|cur
op_assign
id|cur-&gt;xbfi_next
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;xbfi_startblock
op_ge
id|bno
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;xbfi_next
op_assign
r_new
suffix:semicolon
r_else
id|flist-&gt;xbf_first
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|xbfi_next
op_assign
id|cur
suffix:semicolon
id|flist-&gt;xbf_count
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Compute and fill in the value of the maximum depth of a bmap btree&n; * in this filesystem.  Done once, during mount.&n; */
r_void
DECL|function|xfs_bmap_compute_maxlevels
id|xfs_bmap_compute_maxlevels
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
r_int
id|level
suffix:semicolon
multiline_comment|/* btree level */
id|uint
id|maxblocks
suffix:semicolon
multiline_comment|/* max blocks at this level */
id|uint
id|maxleafents
suffix:semicolon
multiline_comment|/* max leaf entries possible */
r_int
id|maxrootrecs
suffix:semicolon
multiline_comment|/* max records in root block */
r_int
id|minleafrecs
suffix:semicolon
multiline_comment|/* min records in leaf block */
r_int
id|minnoderecs
suffix:semicolon
multiline_comment|/* min records in node block */
r_int
id|sz
suffix:semicolon
multiline_comment|/* root block size */
multiline_comment|/*&n;&t; * The maximum number of extents in a file, hence the maximum&n;&t; * number of leaf entries, is controlled by the type of di_nextents&n;&t; * (a signed 32-bit number, xfs_extnum_t), or by di_anextents&n;&t; * (a signed 16-bit number, xfs_aextnum_t).&n;&t; */
id|maxleafents
op_assign
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
ques
c_cond
id|MAXEXTNUM
suffix:colon
id|MAXAEXTNUM
suffix:semicolon
id|minleafrecs
op_assign
id|mp-&gt;m_bmap_dmnr
(braket
l_int|0
)braket
suffix:semicolon
id|minnoderecs
op_assign
id|mp-&gt;m_bmap_dmnr
(braket
l_int|1
)braket
suffix:semicolon
id|sz
op_assign
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
ques
c_cond
id|mp-&gt;m_attroffset
suffix:colon
id|mp-&gt;m_sb.sb_inodesize
op_minus
id|mp-&gt;m_attroffset
suffix:semicolon
id|maxrootrecs
op_assign
(paren
r_int
)paren
id|XFS_BTREE_BLOCK_MAXRECS
c_func
(paren
id|sz
comma
id|xfs_bmdr
comma
l_int|0
)paren
suffix:semicolon
id|maxblocks
op_assign
(paren
id|maxleafents
op_plus
id|minleafrecs
op_minus
l_int|1
)paren
op_div
id|minleafrecs
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|1
suffix:semicolon
id|maxblocks
OG
l_int|1
suffix:semicolon
id|level
op_increment
)paren
(brace
r_if
c_cond
(paren
id|maxblocks
op_le
id|maxrootrecs
)paren
id|maxblocks
op_assign
l_int|1
suffix:semicolon
r_else
id|maxblocks
op_assign
(paren
id|maxblocks
op_plus
id|minnoderecs
op_minus
l_int|1
)paren
op_div
id|minnoderecs
suffix:semicolon
)brace
id|mp-&gt;m_bm_maxlevels
(braket
id|whichfork
)braket
op_assign
id|level
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine to be called at transaction&squot;s end by xfs_bmapi, xfs_bunmapi&n; * caller.  Frees all the extents that need freeing, which must be done&n; * last due to locking considerations.  We never free any extents in&n; * the first transaction.  This is to allow the caller to make the first&n; * transaction a synchronous one so that the pointers to the data being&n; * broken in this transaction will be permanent before the data is actually&n; * freed.  This is necessary to prevent blocks from being reallocated&n; * and written to before the free and reallocation are actually permanent.&n; * We do not just make the first transaction synchronous here, because&n; * there are more efficient ways to gain the same protection in some cases&n; * (see the file truncation code).&n; *&n; * Return 1 if the given transaction was committed and a new one&n; * started, and 0 otherwise in the committed parameter.&n; */
multiline_comment|/*ARGSUSED*/
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_finish
id|xfs_bmap_finish
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|tp
comma
multiline_comment|/* transaction pointer addr */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* i/o: list extents to free */
id|xfs_fsblock_t
id|firstblock
comma
multiline_comment|/* controlled ag for allocs */
r_int
op_star
id|committed
)paren
multiline_comment|/* xact committed or not */
(brace
id|xfs_efd_log_item_t
op_star
id|efd
suffix:semicolon
multiline_comment|/* extent free data */
id|xfs_efi_log_item_t
op_star
id|efi
suffix:semicolon
multiline_comment|/* extent free intention */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_bmap_free_item_t
op_star
id|free
suffix:semicolon
multiline_comment|/* free extent list item */
r_int
r_int
id|logres
suffix:semicolon
multiline_comment|/* new log reservation */
r_int
r_int
id|logcount
suffix:semicolon
multiline_comment|/* new log count */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount structure */
id|xfs_bmap_free_item_t
op_star
id|next
suffix:semicolon
multiline_comment|/* next item on free list */
id|xfs_trans_t
op_star
id|ntp
suffix:semicolon
multiline_comment|/* new transaction pointer */
id|ASSERT
c_func
(paren
(paren
op_star
id|tp
)paren
op_member_access_from_pointer
id|t_flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flist-&gt;xbf_count
op_eq
l_int|0
)paren
(brace
op_star
id|committed
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ntp
op_assign
op_star
id|tp
suffix:semicolon
id|efi
op_assign
id|xfs_trans_get_efi
c_func
(paren
id|ntp
comma
id|flist-&gt;xbf_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|free
op_assign
id|flist-&gt;xbf_first
suffix:semicolon
id|free
suffix:semicolon
id|free
op_assign
id|free-&gt;xbfi_next
)paren
id|xfs_trans_log_efi_extent
c_func
(paren
id|ntp
comma
id|efi
comma
id|free-&gt;xbfi_startblock
comma
id|free-&gt;xbfi_blockcount
)paren
suffix:semicolon
id|logres
op_assign
id|ntp-&gt;t_log_res
suffix:semicolon
id|logcount
op_assign
id|ntp-&gt;t_log_count
suffix:semicolon
id|ntp
op_assign
id|xfs_trans_dup
c_func
(paren
op_star
id|tp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
op_star
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
op_star
id|tp
op_assign
id|ntp
suffix:semicolon
op_star
id|committed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * We have a new transaction, so we should return committed=1,&n;&t; * even though we&squot;re returning an error.&n;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|ntp
comma
l_int|0
comma
id|logres
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|logcount
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|efd
op_assign
id|xfs_trans_get_efd
c_func
(paren
id|ntp
comma
id|efi
comma
id|flist-&gt;xbf_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|free
op_assign
id|flist-&gt;xbf_first
suffix:semicolon
id|free
op_ne
l_int|NULL
suffix:semicolon
id|free
op_assign
id|next
)paren
(brace
id|next
op_assign
id|free-&gt;xbfi_next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_free_extent
c_func
(paren
id|ntp
comma
id|free-&gt;xbfi_startblock
comma
id|free-&gt;xbfi_blockcount
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The bmap free list will be cleaned up at a&n;&t;&t;&t; * higher level.  The EFI will be canceled when&n;&t;&t;&t; * this transaction is aborted.&n;&t;&t;&t; * Need to force shutdown here to make sure it&n;&t;&t;&t; * happens, since this transaction may not be&n;&t;&t;&t; * dirty yet.&n;&t;&t;&t; */
id|mp
op_assign
id|ntp-&gt;t_mountp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
ques
c_cond
id|XFS_CORRUPT_INCORE
suffix:colon
id|XFS_METADATA_IO_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_trans_log_efd_extent
c_func
(paren
id|ntp
comma
id|efd
comma
id|free-&gt;xbfi_startblock
comma
id|free-&gt;xbfi_blockcount
)paren
suffix:semicolon
id|xfs_bmap_del_free
c_func
(paren
id|flist
comma
l_int|NULL
comma
id|free
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Free up any items left in the list.&n; */
r_void
DECL|function|xfs_bmap_cancel
id|xfs_bmap_cancel
c_func
(paren
id|xfs_bmap_free_t
op_star
id|flist
)paren
multiline_comment|/* list of bmap_free_items */
(brace
id|xfs_bmap_free_item_t
op_star
id|free
suffix:semicolon
multiline_comment|/* free list item */
id|xfs_bmap_free_item_t
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
id|flist-&gt;xbf_count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|ASSERT
c_func
(paren
id|flist-&gt;xbf_first
op_ne
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|free
op_assign
id|flist-&gt;xbf_first
suffix:semicolon
id|free
suffix:semicolon
id|free
op_assign
id|next
)paren
(brace
id|next
op_assign
id|free-&gt;xbfi_next
suffix:semicolon
id|xfs_bmap_del_free
c_func
(paren
id|flist
comma
l_int|NULL
comma
id|free
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|flist-&gt;xbf_count
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns EINVAL if the specified file is not swappable.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_check_swappable
id|xfs_bmap_check_swappable
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
multiline_comment|/* incore inode */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent array */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* pointer to an extent entry */
id|xfs_fileoff_t
id|end_fsb
suffix:semicolon
multiline_comment|/* last block of file within size */
id|xfs_bmbt_irec_t
id|ext
suffix:semicolon
multiline_comment|/* extent list entry, decoded */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_fileoff_t
id|lastaddr
suffix:semicolon
multiline_comment|/* last block number seen */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extent entries */
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return value */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for a zero length file.&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_size
op_eq
l_int|0
)paren
r_goto
id|check_done
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|XFS_DATA_FORK
)paren
op_eq
id|XFS_DINODE_FMT_BTREE
op_logical_or
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|XFS_DATA_FORK
)paren
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
suffix:semicolon
id|ifp
op_assign
op_amp
id|ip-&gt;i_df
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|retval
op_assign
id|xfs_iread_extents
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
r_goto
id|check_done
suffix:semicolon
multiline_comment|/*&n;&t; * Scan extents until the file size is reached. Look for&n;&t; * holes or unwritten extents, since I/O to these would cause&n;&t; * a transaction.&n;&t; */
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|ip-&gt;i_mount
comma
id|ip-&gt;i_d.di_size
)paren
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|base
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lastaddr
op_assign
l_int|0
comma
id|ep
op_assign
id|base
suffix:semicolon
id|ep
OL
op_amp
id|base
(braket
id|nextents
)braket
suffix:semicolon
id|ep
op_increment
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|ext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lastaddr
OL
id|ext.br_startoff
op_logical_or
id|ext.br_state
op_ne
id|XFS_EXT_NORM
)paren
(brace
r_goto
id|error_done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end_fsb
op_le
(paren
id|lastaddr
op_assign
id|ext.br_startoff
op_plus
id|ext.br_blockcount
)paren
)paren
r_goto
id|check_done
suffix:semicolon
)brace
id|error_done
suffix:colon
id|retval
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
id|check_done
suffix:colon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the file-relative block number of the first unused block(s)&n; * in the file with at least &quot;len&quot; logically contiguous blocks free.&n; * This is the lowest-address hole if the file has holes, else the first block&n; * past the end of file.&n; * Return 0 if the file is currently local (in-inode).&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_first_unused
id|xfs_bmap_first_unused
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* size of hole to find */
id|xfs_fileoff_t
op_star
id|first_unused
comma
multiline_comment|/* unused block */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent array */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* pointer to an extent entry */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_fileoff_t
id|lastaddr
suffix:semicolon
multiline_comment|/* last block number seen */
id|xfs_fileoff_t
id|lowest
suffix:semicolon
multiline_comment|/* lowest useful block */
id|xfs_fileoff_t
id|max
suffix:semicolon
multiline_comment|/* starting useful block */
id|xfs_fileoff_t
id|off
suffix:semicolon
multiline_comment|/* offset for this block */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extent entries */
id|ASSERT
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_BTREE
op_logical_or
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_or
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
op_star
id|first_unused
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|lowest
op_assign
op_star
id|first_unused
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|base
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|lastaddr
op_assign
l_int|0
comma
id|max
op_assign
id|lowest
comma
id|ep
op_assign
id|base
suffix:semicolon
id|ep
OL
op_amp
id|base
(braket
id|nextents
)braket
suffix:semicolon
id|ep
op_increment
)paren
(brace
id|off
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * See if the hole before this extent will work.&n;&t;&t; */
r_if
c_cond
(paren
id|off
op_ge
id|lowest
op_plus
id|len
op_logical_and
id|off
op_minus
id|max
op_ge
id|len
)paren
(brace
op_star
id|first_unused
op_assign
id|max
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|lastaddr
op_assign
id|off
op_plus
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
)paren
suffix:semicolon
id|max
op_assign
id|XFS_FILEOFF_MAX
c_func
(paren
id|lastaddr
comma
id|lowest
)paren
suffix:semicolon
)brace
op_star
id|first_unused
op_assign
id|max
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the file-relative block number of the last block + 1 before&n; * last_block (input value) in the file.&n; * This is not based on i_size, it is based on the extent list.&n; * Returns 0 for local files, as they do not have an extent list.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_last_before
id|xfs_bmap_last_before
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
id|xfs_fileoff_t
op_star
id|last_block
comma
multiline_comment|/* last block */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_fileoff_t
id|bno
suffix:semicolon
multiline_comment|/* input file offset */
r_int
id|eof
suffix:semicolon
multiline_comment|/* hit end of file */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* pointer to last extent */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_bmbt_irec_t
id|got
suffix:semicolon
multiline_comment|/* current extent value */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extnum_t
id|lastx
suffix:semicolon
multiline_comment|/* last extent used */
id|xfs_bmbt_irec_t
id|prev
suffix:semicolon
multiline_comment|/* previous extent value */
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
op_star
id|last_block
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|bno
op_assign
op_star
id|last_block
op_minus
l_int|1
suffix:semicolon
id|ep
op_assign
id|xfs_bmap_search_extents
c_func
(paren
id|ip
comma
id|bno
comma
id|whichfork
comma
op_amp
id|eof
comma
op_amp
id|lastx
comma
op_amp
id|got
comma
op_amp
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eof
op_logical_or
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
)paren
OG
id|bno
)paren
(brace
r_if
c_cond
(paren
id|prev.br_startoff
op_eq
id|NULLFILEOFF
)paren
op_star
id|last_block
op_assign
l_int|0
suffix:semicolon
r_else
op_star
id|last_block
op_assign
id|prev.br_startoff
op_plus
id|prev.br_blockcount
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Otherwise *last_block is already the right answer.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the file-relative block number of the first block past eof in&n; * the file.  This is not based on i_size, it is based on the extent list.&n; * Returns 0 for local files, as they do not have an extent list.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_last_offset
id|xfs_bmap_last_offset
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
id|xfs_fileoff_t
op_star
id|last_block
comma
multiline_comment|/* last block */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent array */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* pointer to last extent */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extent entries */
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
op_star
id|last_block
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nextents
)paren
(brace
op_star
id|last_block
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|base
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
l_int|0
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|base
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ep
op_assign
op_amp
id|base
(braket
id|nextents
op_minus
l_int|1
)braket
suffix:semicolon
op_star
id|last_block
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
)paren
op_plus
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns whether the selected fork of the inode has exactly one&n; * block or not.  For the data fork we check this matches di_size,&n; * implying the file&squot;s range is 0..bsize-1.&n; */
r_int
multiline_comment|/* 1=&gt;1 block, 0=&gt;otherwise */
DECL|function|xfs_bmap_one_block
id|xfs_bmap_one_block
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* ptr to fork&squot;s extent */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
id|xfs_bmbt_irec_t
id|s
suffix:semicolon
multiline_comment|/* internal version of extent */
macro_line|#ifndef DEBUG
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
r_return
id|ip-&gt;i_d.di_size
op_eq
id|ip-&gt;i_mount-&gt;m_sb.sb_blocksize
suffix:semicolon
macro_line|#endif&t;/* !DEBUG */
r_if
c_cond
(paren
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
r_return
l_int|0
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
suffix:semicolon
id|ep
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|s
)paren
suffix:semicolon
id|rval
op_assign
id|s.br_startoff
op_eq
l_int|0
op_logical_and
id|s.br_blockcount
op_eq
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_logical_and
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_size
op_eq
id|ip-&gt;i_mount-&gt;m_sb.sb_blocksize
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in the extents to if_extents.&n; * All inode fields are set up by caller, we just traverse the btree&n; * and copy the records in. If the file system cannot contain unwritten&n; * extents, the records are checked for no &quot;state&quot; flags.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_read_extents
id|xfs_bmap_read_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* current btree block */
id|xfs_fsblock_t
id|bno
suffix:semicolon
multiline_comment|/* block # of &quot;block&quot; */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for &quot;block&quot; */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_exntfmt_t
id|exntf
suffix:semicolon
multiline_comment|/* XFS_EXTFMT_NOSTATE, if checking */
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_bmap_read_extents&quot;
suffix:semicolon
macro_line|#endif
id|xfs_extnum_t
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* index into the extents list */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* fork structure */
r_int
id|level
suffix:semicolon
multiline_comment|/* btree level, for checking */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount structure */
id|xfs_bmbt_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* pointer to block address */
multiline_comment|/* REFERENCED */
id|xfs_extnum_t
id|room
suffix:semicolon
multiline_comment|/* number of entries there&squot;s room for */
id|xfs_bmbt_rec_t
op_star
id|trp
suffix:semicolon
multiline_comment|/* target record pointer */
id|bno
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|exntf
op_assign
(paren
id|whichfork
op_ne
id|XFS_DATA_FORK
)paren
ques
c_cond
id|XFS_EXTFMT_NOSTATE
suffix:colon
id|XFS_EXTFMT_INODE
c_func
(paren
id|ip
)paren
suffix:semicolon
id|block
op_assign
id|ifp-&gt;if_broot
suffix:semicolon
multiline_comment|/*&n;&t; * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.&n;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
id|level
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pp
op_assign
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDFSBNO
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
OL
id|mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
OL
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
id|bno
op_assign
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go down the tree until leaf level is reached, following the first&n;&t; * pointer (leftmost) at each level.&n;&t; */
r_while
c_loop
(paren
id|level
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|XFS_BMAP_SANITY_CHECK
c_func
(paren
id|mp
comma
id|block
comma
id|level
)paren
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|pp
op_assign
id|XFS_BTREE_PTR_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
l_int|1
comma
id|mp-&gt;m_bmap_dmxr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|XFS_FSB_SANITY_CHECK
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
comma
id|error0
)paren
suffix:semicolon
id|bno
op_assign
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Here with bp and block set to the leftmost leaf node in the tree.&n;&t; */
id|room
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|trp
)paren
suffix:semicolon
id|trp
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over all leaf nodes.  Copy information to the extent list.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|xfs_bmbt_rec_t
op_star
id|frp
comma
op_star
id|temp
suffix:semicolon
id|xfs_fsblock_t
id|nextbno
suffix:semicolon
id|xfs_extnum_t
id|num_recs
suffix:semicolon
id|num_recs
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|i
op_plus
id|num_recs
OG
id|room
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|i
op_plus
id|num_recs
op_le
id|room
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt dinode %Lu, (btree extents).  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmap_read_extents(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|XFS_BMAP_SANITY_CHECK
c_func
(paren
id|mp
comma
id|block
comma
l_int|0
)paren
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read-ahead the next leaf block, if any.&n;&t;&t; */
id|nextbno
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextbno
op_ne
id|NULLFSBLOCK
)paren
id|xfs_btree_reada_bufl
c_func
(paren
id|mp
comma
id|nextbno
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Copy records into the extent list.&n;&t;&t; */
id|frp
op_assign
id|XFS_BTREE_REC_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
l_int|1
comma
id|mp-&gt;m_bmap_dmxr
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|temp
op_assign
id|trp
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|num_recs
suffix:semicolon
id|j
op_increment
comma
id|frp
op_increment
comma
id|trp
op_increment
)paren
(brace
id|trp-&gt;l0
op_assign
id|INT_GET
c_func
(paren
id|frp-&gt;l0
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|trp-&gt;l1
op_assign
id|INT_GET
c_func
(paren
id|frp-&gt;l1
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exntf
op_eq
id|XFS_EXTFMT_NOSTATE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Check all attribute bmap btree records and&n;&t;&t;&t; * any &quot;older&quot; data bmap btree records for a&n;&t;&t;&t; * set bit in the &quot;extent flag&quot; position.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfs_check_nostate_extents
c_func
(paren
id|temp
comma
id|num_recs
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmap_read_extents(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
)brace
id|i
op_add_assign
id|num_recs
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|bno
op_assign
id|nextbno
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;ve reached the end, stop.&n;&t;&t; */
r_if
c_cond
(paren
id|bno
op_eq
id|NULLFSBLOCK
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_eq
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|trp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
)paren
suffix:semicolon
id|xfs_bmap_trace_exlist
c_func
(paren
id|fname
comma
id|ip
comma
id|i
comma
id|whichfork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
macro_line|#ifdef XFS_BMAP_TRACE
multiline_comment|/*&n; * Add bmap trace insert entries for all the contents of the extent list.&n; */
r_void
DECL|function|xfs_bmap_trace_exlist
id|xfs_bmap_trace_exlist
c_func
(paren
r_char
op_star
id|fname
comma
multiline_comment|/* function name */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_extnum_t
id|cnt
comma
multiline_comment|/* count of entries in the list */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent list */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* current entry in extent list */
id|xfs_extnum_t
id|idx
suffix:semicolon
multiline_comment|/* extent list entry number */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_bmbt_irec_t
id|s
suffix:semicolon
multiline_comment|/* extent list record */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|cnt
op_eq
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|base
)paren
)paren
suffix:semicolon
id|base
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
comma
id|ep
op_assign
id|base
suffix:semicolon
id|idx
OL
id|cnt
suffix:semicolon
id|idx
op_increment
comma
id|ep
op_increment
)paren
(brace
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|s
)paren
suffix:semicolon
id|xfs_bmap_trace_insert
c_func
(paren
id|fname
comma
l_string|&quot;exlist&quot;
comma
id|ip
comma
id|idx
comma
l_int|1
comma
op_amp
id|s
comma
l_int|NULL
comma
id|whichfork
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Validate that the bmbt_irecs being returned from bmapi are valid&n; * given the callers original parameters.  Specifically check the&n; * ranges of the returned irecs to ensure that they only extent beyond&n; * the given parameters if the XFS_BMAPI_ENTIRE flag was set.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_validate_ret
id|xfs_bmap_validate_ret
c_func
(paren
id|xfs_fileoff_t
id|bno
comma
id|xfs_filblks_t
id|len
comma
r_int
id|flags
comma
id|xfs_bmbt_irec_t
op_star
id|mval
comma
r_int
id|nmap
comma
r_int
id|ret_nmap
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* index to map values */
id|ASSERT
c_func
(paren
id|ret_nmap
op_le
id|nmap
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ret_nmap
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_blockcount
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BMAPI_ENTIRE
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_startoff
op_ge
id|bno
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_blockcount
op_le
id|len
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_startoff
op_plus
id|mval
(braket
id|i
)braket
dot
id|br_blockcount
op_le
id|bno
op_plus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_startoff
OL
id|bno
op_plus
id|len
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_startoff
op_plus
id|mval
(braket
id|i
)braket
dot
id|br_blockcount
OG
id|bno
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
op_logical_or
id|mval
(braket
id|i
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|mval
(braket
id|i
op_minus
l_int|1
)braket
dot
id|br_blockcount
op_eq
id|mval
(braket
id|i
)braket
dot
id|br_startoff
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_BMAPI_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BMAPI_DELAY
)paren
)paren
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_startblock
op_ne
id|DELAYSTARTBLOCK
op_logical_and
id|mval
(braket
id|i
)braket
dot
id|br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mval
(braket
id|i
)braket
dot
id|br_state
op_eq
id|XFS_EXT_NORM
op_logical_or
id|mval
(braket
id|i
)braket
dot
id|br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* DEBUG */
multiline_comment|/*&n; * Map file blocks to filesystem blocks.&n; * File range is given by the bno/len pair.&n; * Adds blocks to file if a write (&quot;flags &amp; XFS_BMAPI_WRITE&quot; set)&n; * into a hole or past eof.&n; * Only allocates blocks from a single allocation group,&n; * to avoid locking problems.&n; * The returned value in &quot;firstblock&quot; from the first call in a transaction&n; * must be remembered and presented to subsequent calls in &quot;firstblock&quot;.&n; * An upper bound for the number of blocks to be allocated is supplied to&n; * the first call in &quot;total&quot;; if no allocation group has that many free&n; * blocks then the call will fail (return NULLFSBLOCK in &quot;firstblock&quot;).&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmapi
id|xfs_bmapi
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
id|xfs_fileoff_t
id|bno
comma
multiline_comment|/* starting file offs. mapped */
id|xfs_filblks_t
id|len
comma
multiline_comment|/* length to map in file */
r_int
id|flags
comma
multiline_comment|/* XFS_BMAPI_... */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first allocated block&n;&t;&t;&t;&t;&t;   controls a.g. for allocs */
id|xfs_extlen_t
id|total
comma
multiline_comment|/* total blocks needed */
id|xfs_bmbt_irec_t
op_star
id|mval
comma
multiline_comment|/* output: map values */
r_int
op_star
id|nmap
comma
multiline_comment|/* i/o: mval size/count */
id|xfs_bmap_free_t
op_star
id|flist
)paren
multiline_comment|/* i/o: list extents to free */
(brace
id|xfs_fsblock_t
id|abno
suffix:semicolon
multiline_comment|/* allocated block number */
id|xfs_extlen_t
id|alen
suffix:semicolon
multiline_comment|/* allocated extent length */
id|xfs_fileoff_t
id|aoff
suffix:semicolon
multiline_comment|/* allocated file offset */
id|xfs_bmalloca_t
id|bma
suffix:semicolon
multiline_comment|/* args for xfs_bmap_alloc */
r_char
id|contig
suffix:semicolon
multiline_comment|/* allocation must be one extent */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* bmap btree cursor */
r_char
id|delay
suffix:semicolon
multiline_comment|/* this request is for delayed alloc */
id|xfs_fileoff_t
id|end
suffix:semicolon
multiline_comment|/* end of mapped file region */
r_int
id|eof
suffix:semicolon
multiline_comment|/* we&squot;ve hit the end of extent list */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent list entry pointer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return */
r_char
id|exact
suffix:semicolon
multiline_comment|/* don&squot;t do all of wasdelayed extent */
id|xfs_bmbt_irec_t
id|got
suffix:semicolon
multiline_comment|/* current extent list record */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extlen_t
id|indlen
suffix:semicolon
multiline_comment|/* indirect blocks length */
r_char
id|inhole
suffix:semicolon
multiline_comment|/* current location is hole in file */
id|xfs_extnum_t
id|lastx
suffix:semicolon
multiline_comment|/* last useful extent number */
r_int
id|logflags
suffix:semicolon
multiline_comment|/* flags for transaction logging */
id|xfs_extlen_t
id|minleft
suffix:semicolon
multiline_comment|/* min blocks left after allocation */
id|xfs_extlen_t
id|minlen
suffix:semicolon
multiline_comment|/* min allocation size */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* xfs mount structure */
r_int
id|n
suffix:semicolon
multiline_comment|/* current extent index */
r_int
id|nallocs
suffix:semicolon
multiline_comment|/* number of extents alloc&bslash;&squot;d */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extents in file */
id|xfs_fileoff_t
id|obno
suffix:semicolon
multiline_comment|/* old block number (offset) */
id|xfs_bmbt_irec_t
id|prev
suffix:semicolon
multiline_comment|/* previous extent list record */
r_char
id|stateless
suffix:semicolon
multiline_comment|/* ignore state flag set */
r_int
id|tmp_logflags
suffix:semicolon
multiline_comment|/* temp flags holder */
r_char
id|trim
suffix:semicolon
multiline_comment|/* output trimmed to match range */
r_char
id|userdata
suffix:semicolon
multiline_comment|/* allocating non-metadata */
r_char
id|wasdelay
suffix:semicolon
multiline_comment|/* old extent was delayed */
r_int
id|whichfork
suffix:semicolon
multiline_comment|/* data or attr fork */
r_char
id|wr
suffix:semicolon
multiline_comment|/* this is a write request */
r_char
id|rsvd
suffix:semicolon
multiline_comment|/* OK to allocate reserved blocks */
macro_line|#ifdef DEBUG
id|xfs_fileoff_t
id|orig_bno
suffix:semicolon
multiline_comment|/* original block number value */
r_int
id|orig_flags
suffix:semicolon
multiline_comment|/* original flags arg value */
id|xfs_filblks_t
id|orig_len
suffix:semicolon
multiline_comment|/* original value of len arg */
id|xfs_bmbt_irec_t
op_star
id|orig_mval
suffix:semicolon
multiline_comment|/* original value of mval */
r_int
id|orig_nmap
suffix:semicolon
multiline_comment|/* original value of *nmap */
id|orig_bno
op_assign
id|bno
suffix:semicolon
id|orig_len
op_assign
id|len
suffix:semicolon
id|orig_flags
op_assign
id|flags
suffix:semicolon
id|orig_mval
op_assign
id|mval
suffix:semicolon
id|orig_nmap
op_assign
op_star
id|nmap
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
op_star
id|nmap
op_ge
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|nmap
op_le
id|XFS_BMAP_MAX_NMAP
op_logical_or
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BMAPI_WRITE
)paren
)paren
suffix:semicolon
id|whichfork
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_ATTRFORK
)paren
ques
c_cond
id|XFS_ATTR_FORK
suffix:colon
id|XFS_DATA_FORK
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
comma
id|mp
comma
id|XFS_ERRTAG_BMAPIFORMAT
comma
id|XFS_RANDOM_BMAPIFORMAT
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmapi&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_ext_max
op_eq
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wr
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_WRITE
)paren
)paren
op_ne
l_int|0
)paren
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_blk_mapw
)paren
suffix:semicolon
r_else
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_blk_mapr
)paren
suffix:semicolon
id|delay
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_DELAY
)paren
op_ne
l_int|0
suffix:semicolon
id|trim
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_ENTIRE
)paren
op_eq
l_int|0
suffix:semicolon
id|userdata
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_METADATA
)paren
op_eq
l_int|0
suffix:semicolon
id|exact
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_EXACT
)paren
op_ne
l_int|0
suffix:semicolon
id|rsvd
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_RSVBLOCKS
)paren
op_ne
l_int|0
suffix:semicolon
id|contig
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_CONTIG
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * stateless is used to combine extents which&n;&t; * differ only due to the state of the extents.&n;&t; * This technique is used from xfs_getbmap()&n;&t; * when the caller does not wish to see the&n;&t; * separation (which is the default).&n;&t; *&n;&t; * This technique is also used when writing a&n;&t; * buffer which has been partially written,&n;&t; * (usually by being flushed during a chunkread),&n;&t; * to ensure one write takes place. This also&n;&t; * prevents a change in the xfs inode extents at&n;&t; * this time, intentionally. This change occurs&n;&t; * on completion of the write operation, in&n;&t; * xfs_strat_comp(), where the xfs_bmapi() call&n;&t; * is transactioned, and the extents combined.&n;&t; */
id|stateless
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_IGSTATE
)paren
op_ne
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stateless
op_logical_and
id|wr
)paren
multiline_comment|/* if writing unwritten space, no */
id|wr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* allocations are allowed */
id|ASSERT
c_func
(paren
id|wr
op_logical_or
op_logical_neg
id|delay
)paren
suffix:semicolon
id|logflags
op_assign
l_int|0
suffix:semicolon
id|nallocs
op_assign
l_int|0
suffix:semicolon
id|cur
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|ASSERT
c_func
(paren
id|wr
op_logical_and
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_local_to_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|firstblock
comma
id|total
comma
op_amp
id|logflags
comma
id|whichfork
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wr
op_logical_and
op_star
id|firstblock
op_eq
id|NULLFSBLOCK
)paren
(brace
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_BTREE
)paren
id|minleft
op_assign
id|INT_GET
c_func
(paren
id|ifp-&gt;if_broot-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
suffix:semicolon
r_else
id|minleft
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|minleft
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|ep
op_assign
id|xfs_bmap_search_extents
c_func
(paren
id|ip
comma
id|bno
comma
id|whichfork
comma
op_amp
id|eof
comma
op_amp
id|lastx
comma
op_amp
id|got
comma
op_amp
id|prev
)paren
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
id|end
op_assign
id|bno
op_plus
id|len
suffix:semicolon
id|obno
op_assign
id|bno
suffix:semicolon
id|bma.ip
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|bno
OL
id|end
op_logical_and
id|n
OL
op_star
id|nmap
)paren
(brace
multiline_comment|/*&n;&t;&t; * Reading past eof, act as though there&squot;s a hole&n;&t;&t; * up to end.&n;&t;&t; */
r_if
c_cond
(paren
id|eof
op_logical_and
op_logical_neg
id|wr
)paren
id|got.br_startoff
op_assign
id|end
suffix:semicolon
id|inhole
op_assign
id|eof
op_logical_or
id|got.br_startoff
OG
id|bno
suffix:semicolon
id|wasdelay
op_assign
id|wr
op_logical_and
op_logical_neg
id|inhole
op_logical_and
op_logical_neg
id|delay
op_logical_and
id|ISNULLSTARTBLOCK
c_func
(paren
id|got.br_startblock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * First, deal with the hole before the allocated space&n;&t;&t; * that we found, if any.&n;&t;&t; */
r_if
c_cond
(paren
id|wr
op_logical_and
(paren
id|inhole
op_logical_or
id|wasdelay
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For the wasdelay case, we could also just&n;&t;&t;&t; * allocate the stuff asked for in this bmap call&n;&t;&t;&t; * but that wouldn&squot;t be as good.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|wasdelay
op_logical_and
op_logical_neg
id|exact
)paren
(brace
id|alen
op_assign
(paren
id|xfs_extlen_t
)paren
id|got.br_blockcount
suffix:semicolon
id|aoff
op_assign
id|got.br_startoff
suffix:semicolon
r_if
c_cond
(paren
id|lastx
op_ne
id|NULLEXTNUM
op_logical_and
id|lastx
)paren
(brace
id|ep
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|lastx
op_minus
l_int|1
)braket
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|prev
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|wasdelay
)paren
(brace
id|alen
op_assign
(paren
id|xfs_extlen_t
)paren
id|XFS_FILBLKS_MIN
c_func
(paren
id|len
comma
(paren
id|got.br_startoff
op_plus
id|got.br_blockcount
)paren
op_minus
id|bno
)paren
suffix:semicolon
id|aoff
op_assign
id|bno
suffix:semicolon
)brace
r_else
(brace
id|alen
op_assign
(paren
id|xfs_extlen_t
)paren
id|XFS_FILBLKS_MIN
c_func
(paren
id|len
comma
id|MAXEXTLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eof
)paren
id|alen
op_assign
(paren
id|xfs_extlen_t
)paren
id|XFS_FILBLKS_MIN
c_func
(paren
id|alen
comma
id|got.br_startoff
op_minus
id|bno
)paren
suffix:semicolon
id|aoff
op_assign
id|bno
suffix:semicolon
)brace
id|minlen
op_assign
id|contig
ques
c_cond
id|alen
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|delay
)paren
(brace
id|indlen
op_assign
(paren
id|xfs_extlen_t
)paren
id|xfs_bmap_worst_indlen
c_func
(paren
id|ip
comma
id|alen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|indlen
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Make a transaction-less quota reservation for&n;&t;&t;&t;&t; * delayed allocation blocks. This number gets&n;&t;&t;&t;&t; * adjusted later.&n;&t;&t;&t;&t; * We return EDQUOT if we haven&squot;t allocated&n;&t;&t;&t;&t; * blks already inside this loop;&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_TRANS_RESERVE_BLKQUOTA
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
(paren
r_int
)paren
id|alen
)paren
)paren
(brace
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
(brace
op_star
id|nmap
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|cur
op_eq
l_int|NULL
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EDQUOT
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfs_mod_incore_sb
c_func
(paren
id|mp
comma
id|XFS_SBS_FDBLOCKS
comma
op_minus
(paren
id|alen
op_plus
id|indlen
)paren
comma
id|rsvd
)paren
)paren
(brace
id|XFS_TRANS_UNRESERVE_BLKQUOTA
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
(paren
r_int
)paren
id|alen
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ip-&gt;i_delayed_blks
op_add_assign
id|alen
suffix:semicolon
id|abno
op_assign
id|NULLSTARTBLOCK
c_func
(paren
id|indlen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If first time, allocate and fill in&n;&t;&t;&t;&t; * once-only bma fields.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bma.ip
op_eq
l_int|NULL
)paren
(brace
id|bma.tp
op_assign
id|tp
suffix:semicolon
id|bma.ip
op_assign
id|ip
suffix:semicolon
id|bma.prevp
op_assign
op_amp
id|prev
suffix:semicolon
id|bma.gotp
op_assign
op_amp
id|got
suffix:semicolon
id|bma.total
op_assign
id|total
suffix:semicolon
id|bma.userdata
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Indicate if this is the first user data&n;&t;&t;&t;&t; * in the file, or just any user data.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|userdata
)paren
(brace
id|bma.userdata
op_assign
(paren
id|aoff
op_eq
l_int|0
)paren
ques
c_cond
id|XFS_ALLOC_INITIAL_USER_DATA
suffix:colon
id|XFS_ALLOC_USERDATA
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Fill in changeable bma fields.&n;&t;&t;&t;&t; */
id|bma.eof
op_assign
id|eof
suffix:semicolon
id|bma.firstblock
op_assign
op_star
id|firstblock
suffix:semicolon
id|bma.alen
op_assign
id|alen
suffix:semicolon
id|bma.off
op_assign
id|aoff
suffix:semicolon
id|bma.wasdel
op_assign
id|wasdelay
suffix:semicolon
id|bma.minlen
op_assign
id|minlen
suffix:semicolon
id|bma.low
op_assign
id|flist-&gt;xbf_low
suffix:semicolon
id|bma.minleft
op_assign
id|minleft
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Only want to do the alignment at the&n;&t;&t;&t;&t; * eof if it is userdata and allocation length&n;&t;&t;&t;&t; * is larger than a stripe unit.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_dalign
op_logical_and
id|alen
op_ge
id|mp-&gt;m_dalign
op_logical_and
id|userdata
op_logical_and
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_isaeof
c_func
(paren
id|ip
comma
id|aoff
comma
id|whichfork
comma
op_amp
id|bma.aeof
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
r_else
id|bma.aeof
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Call allocator.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_alloc
c_func
(paren
op_amp
id|bma
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Copy out result fields.&n;&t;&t;&t;&t; */
id|abno
op_assign
id|bma.rval
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flist-&gt;xbf_low
op_assign
id|bma.low
)paren
)paren
id|minleft
op_assign
l_int|0
suffix:semicolon
id|alen
op_assign
id|bma.alen
suffix:semicolon
id|aoff
op_assign
id|bma.off
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|firstblock
op_eq
id|NULLFSBLOCK
op_logical_or
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
op_star
id|firstblock
)paren
op_eq
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|bma.firstblock
)paren
op_logical_or
(paren
id|flist-&gt;xbf_low
op_logical_and
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
op_star
id|firstblock
)paren
OL
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|bma.firstblock
)paren
)paren
)paren
suffix:semicolon
op_star
id|firstblock
op_assign
id|bma.firstblock
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
id|cur-&gt;bc_private.b.firstblock
op_assign
op_star
id|firstblock
suffix:semicolon
r_if
c_cond
(paren
id|abno
op_eq
id|NULLFSBLOCK
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFBROOT
)paren
op_logical_and
op_logical_neg
id|cur
)paren
(brace
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
l_int|NULL
comma
l_int|0
comma
id|XFS_BTNUM_BMAP
comma
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|cur-&gt;bc_private.b.firstblock
op_assign
op_star
id|firstblock
suffix:semicolon
id|cur-&gt;bc_private.b.flist
op_assign
id|flist
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Bump the number of extents we&squot;ve allocated&n;&t;&t;&t;&t; * in this call.&n;&t;&t;&t;&t; */
id|nallocs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur
)paren
id|cur-&gt;bc_private.b.flags
op_assign
id|wasdelay
ques
c_cond
id|XFS_BTCUR_BPRV_WASDEL
suffix:colon
l_int|0
suffix:semicolon
id|got.br_startoff
op_assign
id|aoff
suffix:semicolon
id|got.br_startblock
op_assign
id|abno
suffix:semicolon
id|got.br_blockcount
op_assign
id|alen
suffix:semicolon
id|got.br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
multiline_comment|/* assume normal */
multiline_comment|/*&n;&t;&t;&t; * Determine state of extent, and the filesystem.&n;&t;&t;&t; * A wasdelay extent has been initialized, so&n;&t;&t;&t; * shouldn&squot;t be flagged as unwritten.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|wr
op_logical_and
id|XFS_SB_VERSION_HASEXTFLGBIT
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|wasdelay
op_logical_and
(paren
id|flags
op_amp
id|XFS_BMAPI_PREALLOC
)paren
)paren
id|got.br_state
op_assign
id|XFS_EXT_UNWRITTEN
suffix:semicolon
)brace
id|error
op_assign
id|xfs_bmap_add_extent
c_func
(paren
id|ip
comma
id|lastx
comma
op_amp
id|cur
comma
op_amp
id|got
comma
id|firstblock
comma
id|flist
comma
op_amp
id|tmp_logflags
comma
id|whichfork
comma
id|rsvd
)paren
suffix:semicolon
id|logflags
op_or_assign
id|tmp_logflags
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
id|lastx
op_assign
id|ifp-&gt;if_lastex
suffix:semicolon
id|ep
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|lastx
)braket
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|got.br_startoff
op_le
id|aoff
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|got.br_startoff
op_plus
id|got.br_blockcount
op_ge
id|aoff
op_plus
id|alen
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|delay
)paren
(brace
id|ASSERT
c_func
(paren
id|ISNULLSTARTBLOCK
c_func
(paren
id|got.br_startblock
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|STARTBLOCKVAL
c_func
(paren
id|got.br_startblock
)paren
OG
l_int|0
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|got.br_state
op_eq
id|XFS_EXT_NORM
op_logical_or
id|got.br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * Fall down into the found allocated space case.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|inhole
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Reading in a hole.&n;&t;&t;&t; */
id|mval-&gt;br_startoff
op_assign
id|bno
suffix:semicolon
id|mval-&gt;br_startblock
op_assign
id|HOLESTARTBLOCK
suffix:semicolon
id|mval-&gt;br_blockcount
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|len
comma
id|got.br_startoff
op_minus
id|bno
)paren
suffix:semicolon
id|mval-&gt;br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
id|bno
op_add_assign
id|mval-&gt;br_blockcount
suffix:semicolon
id|len
op_sub_assign
id|mval-&gt;br_blockcount
suffix:semicolon
id|mval
op_increment
suffix:semicolon
id|n
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Then deal with the allocated space we found.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|ep
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trim
op_logical_and
(paren
id|got.br_startoff
op_plus
id|got.br_blockcount
OG
id|obno
)paren
)paren
(brace
r_if
c_cond
(paren
id|obno
OG
id|bno
)paren
id|bno
op_assign
id|obno
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|bno
op_ge
id|obno
)paren
op_logical_or
(paren
id|n
op_eq
l_int|0
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bno
OL
id|end
)paren
suffix:semicolon
id|mval-&gt;br_startoff
op_assign
id|bno
suffix:semicolon
r_if
c_cond
(paren
id|ISNULLSTARTBLOCK
c_func
(paren
id|got.br_startblock
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|wr
op_logical_or
id|delay
)paren
suffix:semicolon
id|mval-&gt;br_startblock
op_assign
id|DELAYSTARTBLOCK
suffix:semicolon
)brace
r_else
id|mval-&gt;br_startblock
op_assign
id|got.br_startblock
op_plus
(paren
id|bno
op_minus
id|got.br_startoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Return the minimum of what we got and what we&n;&t;&t;&t; * asked for for the length.  We can use the len&n;&t;&t;&t; * variable here because it is modified below&n;&t;&t;&t; * and we could have been there before coming&n;&t;&t;&t; * here if the first part of the allocation&n;&t;&t;&t; * didn&squot;t overlap what was asked for.&n;&t;&t;&t; */
id|mval-&gt;br_blockcount
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|end
op_minus
id|bno
comma
id|got.br_blockcount
op_minus
(paren
id|bno
op_minus
id|got.br_startoff
)paren
)paren
suffix:semicolon
id|mval-&gt;br_state
op_assign
id|got.br_state
suffix:semicolon
id|ASSERT
c_func
(paren
id|mval-&gt;br_blockcount
op_le
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|mval
op_assign
id|got
suffix:semicolon
r_if
c_cond
(paren
id|ISNULLSTARTBLOCK
c_func
(paren
id|mval-&gt;br_startblock
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|wr
op_logical_or
id|delay
)paren
suffix:semicolon
id|mval-&gt;br_startblock
op_assign
id|DELAYSTARTBLOCK
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Check if writing previously allocated but&n;&t;&t; * unwritten extents.&n;&t;&t; */
r_if
c_cond
(paren
id|wr
op_logical_and
id|mval-&gt;br_state
op_eq
id|XFS_EXT_UNWRITTEN
op_logical_and
(paren
(paren
id|flags
op_amp
(paren
id|XFS_BMAPI_PREALLOC
op_or
id|XFS_BMAPI_DELAY
)paren
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Modify (by adding) the state flag, if writing.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|mval-&gt;br_blockcount
op_le
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFBROOT
)paren
op_logical_and
op_logical_neg
id|cur
)paren
(brace
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
l_int|NULL
comma
l_int|0
comma
id|XFS_BTNUM_BMAP
comma
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|cur-&gt;bc_private.b.firstblock
op_assign
op_star
id|firstblock
suffix:semicolon
id|cur-&gt;bc_private.b.flist
op_assign
id|flist
suffix:semicolon
)brace
id|mval-&gt;br_state
op_assign
id|XFS_EXT_NORM
suffix:semicolon
id|error
op_assign
id|xfs_bmap_add_extent
c_func
(paren
id|ip
comma
id|lastx
comma
op_amp
id|cur
comma
id|mval
comma
id|firstblock
comma
id|flist
comma
op_amp
id|tmp_logflags
comma
id|whichfork
comma
id|rsvd
)paren
suffix:semicolon
id|logflags
op_or_assign
id|tmp_logflags
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
id|lastx
op_assign
id|ifp-&gt;if_lastex
suffix:semicolon
id|ep
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|lastx
)braket
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We may have combined previously unwritten&n;&t;&t;&t; * space with written space, so generate&n;&t;&t;&t; * another request.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mval-&gt;br_blockcount
OL
id|len
)paren
r_continue
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|trim
op_logical_or
(paren
(paren
id|mval-&gt;br_startoff
op_plus
id|mval-&gt;br_blockcount
)paren
op_le
id|end
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|trim
op_logical_or
(paren
id|mval-&gt;br_blockcount
op_le
id|len
)paren
op_logical_or
(paren
id|mval-&gt;br_startoff
OL
id|obno
)paren
)paren
suffix:semicolon
id|bno
op_assign
id|mval-&gt;br_startoff
op_plus
id|mval-&gt;br_blockcount
suffix:semicolon
id|len
op_assign
id|end
op_minus
id|bno
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|0
op_logical_and
id|mval-&gt;br_startoff
op_eq
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startoff
)paren
(brace
id|ASSERT
c_func
(paren
id|mval-&gt;br_startblock
op_eq
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startblock
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mval-&gt;br_blockcount
OG
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mval-&gt;br_state
op_eq
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_state
)paren
suffix:semicolon
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_blockcount
op_assign
id|mval-&gt;br_blockcount
suffix:semicolon
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_state
op_assign
id|mval-&gt;br_state
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
OG
l_int|0
op_logical_and
id|mval-&gt;br_startblock
op_ne
id|DELAYSTARTBLOCK
op_logical_and
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startblock
op_ne
id|DELAYSTARTBLOCK
op_logical_and
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startblock
op_ne
id|HOLESTARTBLOCK
op_logical_and
id|mval-&gt;br_startblock
op_eq
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startblock
op_plus
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_blockcount
op_logical_and
(paren
id|stateless
op_logical_or
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_state
op_eq
id|mval-&gt;br_state
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|mval-&gt;br_startoff
op_eq
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_blockcount
op_add_assign
id|mval-&gt;br_blockcount
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n
OG
l_int|0
op_logical_and
id|mval-&gt;br_startblock
op_eq
id|DELAYSTARTBLOCK
op_logical_and
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startblock
op_eq
id|DELAYSTARTBLOCK
op_logical_and
id|mval-&gt;br_startoff
op_eq
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_blockcount
)paren
(brace
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_blockcount
op_add_assign
id|mval-&gt;br_blockcount
suffix:semicolon
id|mval
(braket
op_minus
l_int|1
)braket
dot
id|br_state
op_assign
id|mval-&gt;br_state
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|n
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|mval-&gt;br_startoff
op_plus
id|mval-&gt;br_blockcount
)paren
op_le
id|obno
)paren
)paren
)paren
(brace
id|mval
op_increment
suffix:semicolon
id|n
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we&squot;re done, stop now.  Stop when we&squot;ve allocated&n;&t;&t; * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise&n;&t;&t; * the transaction may get too big.&n;&t;&t; */
r_if
c_cond
(paren
id|bno
op_ge
id|end
op_logical_or
id|n
op_ge
op_star
id|nmap
op_logical_or
id|nallocs
op_ge
op_star
id|nmap
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Else go on to the next record.&n;&t;&t; */
id|ep
op_increment
suffix:semicolon
id|lastx
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lastx
op_ge
id|nextents
)paren
(brace
id|eof
op_assign
l_int|1
suffix:semicolon
id|prev
op_assign
id|got
suffix:semicolon
)brace
r_else
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
)brace
id|ifp-&gt;if_lastex
op_assign
id|lastx
suffix:semicolon
op_star
id|nmap
op_assign
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * Transform from btree to extents, give it cur.&n;&t; */
r_if
c_cond
(paren
id|tp
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_le
id|ifp-&gt;if_ext_max
)paren
(brace
id|ASSERT
c_func
(paren
id|wr
op_logical_and
id|cur
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmap_btree_to_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|cur
comma
op_amp
id|tmp_logflags
comma
id|whichfork
)paren
suffix:semicolon
id|logflags
op_or_assign
id|tmp_logflags
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_ext_max
op_eq
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_or
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
OG
id|ifp-&gt;if_ext_max
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|error0
suffix:colon
multiline_comment|/*&n;&t; * Log everything.  Do this after conversion, there&squot;s no point in&n;&t; * logging the extent list if we&squot;ve converted to btree format.&n;&t; */
r_if
c_cond
(paren
(paren
id|logflags
op_amp
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
)paren
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
id|logflags
op_and_assign
op_complement
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|logflags
op_amp
id|XFS_ILOG_FBROOT
c_func
(paren
id|whichfork
)paren
)paren
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
id|logflags
op_and_assign
op_complement
id|XFS_ILOG_FBROOT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log whatever the flags say, even if error.  Otherwise we might miss&n;&t; * detecting a case where the data is changed, there&squot;s an error,&n;&t; * and it&squot;s not logged so we don&squot;t shutdown when we should.&n;&t; */
r_if
c_cond
(paren
id|logflags
)paren
(brace
id|ASSERT
c_func
(paren
id|tp
op_logical_and
id|wr
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|logflags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|ASSERT
c_func
(paren
op_star
id|firstblock
op_eq
id|NULLFSBLOCK
op_logical_or
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
op_star
id|firstblock
)paren
op_eq
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|cur-&gt;bc_private.b.firstblock
)paren
op_logical_or
(paren
id|flist-&gt;xbf_low
op_logical_and
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
op_star
id|firstblock
)paren
OL
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|cur-&gt;bc_private.b.firstblock
)paren
)paren
)paren
suffix:semicolon
op_star
id|firstblock
op_assign
id|cur-&gt;bc_private.b.firstblock
suffix:semicolon
)brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|error
ques
c_cond
id|XFS_BTREE_ERROR
suffix:colon
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|xfs_bmap_validate_ret
c_func
(paren
id|orig_bno
comma
id|orig_len
comma
id|orig_flags
comma
id|orig_mval
comma
id|orig_nmap
comma
op_star
id|nmap
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Map file blocks to filesystem blocks, simple version.&n; * One block (extent) only, read-only.&n; * For flags, only the XFS_BMAPI_ATTRFORK flag is examined.&n; * For the other flag values, the effect is as if XFS_BMAPI_METADATA&n; * was set and all the others were clear.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmapi_single
id|xfs_bmapi_single
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
id|xfs_fsblock_t
op_star
id|fsb
comma
multiline_comment|/* output: mapped block */
id|xfs_fileoff_t
id|bno
)paren
multiline_comment|/* starting file offs. mapped */
(brace
r_int
id|eof
suffix:semicolon
multiline_comment|/* we&squot;ve hit the end of extent list */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return */
id|xfs_bmbt_irec_t
id|got
suffix:semicolon
multiline_comment|/* current extent list record */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extnum_t
id|lastx
suffix:semicolon
multiline_comment|/* last useful extent number */
id|xfs_bmbt_irec_t
id|prev
suffix:semicolon
multiline_comment|/* previous extent list record */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmapi_single&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_blk_mapr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
(paren
r_void
)paren
id|xfs_bmap_search_extents
c_func
(paren
id|ip
comma
id|bno
comma
id|whichfork
comma
op_amp
id|eof
comma
op_amp
id|lastx
comma
op_amp
id|got
comma
op_amp
id|prev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reading past eof, act as though there&squot;s a hole&n;&t; * up to end.&n;&t; */
r_if
c_cond
(paren
id|eof
op_logical_or
id|got.br_startoff
OG
id|bno
)paren
(brace
op_star
id|fsb
op_assign
id|NULLFSBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|got.br_startblock
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bno
OL
id|got.br_startoff
op_plus
id|got.br_blockcount
)paren
suffix:semicolon
op_star
id|fsb
op_assign
id|got.br_startblock
op_plus
(paren
id|bno
op_minus
id|got.br_startoff
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|lastx
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unmap (remove) blocks from a file.&n; * If nexts is nonzero then the number of extents to remove is limited to&n; * that value.  If not all extents in the block range can be removed then&n; * *done is set.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bunmapi
id|xfs_bunmapi
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
r_struct
id|xfs_inode
op_star
id|ip
comma
multiline_comment|/* incore inode */
id|xfs_fileoff_t
id|bno
comma
multiline_comment|/* starting offset to unmap */
id|xfs_filblks_t
id|len
comma
multiline_comment|/* length to unmap in file */
r_int
id|flags
comma
multiline_comment|/* misc flags */
id|xfs_extnum_t
id|nexts
comma
multiline_comment|/* number of extents max */
id|xfs_fsblock_t
op_star
id|firstblock
comma
multiline_comment|/* first allocated block&n;&t;&t;&t;&t;&t;&t;   controls a.g. for allocs */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* i/o: list extents to free */
r_int
op_star
id|done
)paren
multiline_comment|/* set if not done yet */
(brace
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* bmap btree cursor */
id|xfs_bmbt_irec_t
id|del
suffix:semicolon
multiline_comment|/* extent being deleted */
r_int
id|eof
suffix:semicolon
multiline_comment|/* is deleting at eof */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* extent list entry pointer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_extnum_t
id|extno
suffix:semicolon
multiline_comment|/* extent number in list */
id|xfs_bmbt_irec_t
id|got
suffix:semicolon
multiline_comment|/* current extent list entry */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
r_int
id|isrt
suffix:semicolon
multiline_comment|/* freeing in rt area */
id|xfs_extnum_t
id|lastx
suffix:semicolon
multiline_comment|/* last extent index used */
r_int
id|logflags
suffix:semicolon
multiline_comment|/* transaction logging flags */
id|xfs_extlen_t
id|mod
suffix:semicolon
multiline_comment|/* rt extent offset */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* size of extent list */
id|xfs_bmbt_irec_t
id|prev
suffix:semicolon
multiline_comment|/* previous extent list entry */
id|xfs_fileoff_t
id|start
suffix:semicolon
multiline_comment|/* first file offset deleted */
r_int
id|tmp_logflags
suffix:semicolon
multiline_comment|/* partial logging flags */
r_int
id|wasdel
suffix:semicolon
multiline_comment|/* was a delayed alloc extent */
r_int
id|whichfork
suffix:semicolon
multiline_comment|/* data or attribute fork */
r_int
id|rsvd
suffix:semicolon
multiline_comment|/* OK to allocate reserved blocks */
id|xfs_fsblock_t
id|sum
suffix:semicolon
id|xfs_bunmap_trace
c_func
(paren
id|ip
comma
id|bno
comma
id|len
comma
id|flags
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|whichfork
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_ATTRFORK
)paren
ques
c_cond
id|XFS_ATTR_FORK
suffix:colon
id|XFS_DATA_FORK
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bunmapi&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|rsvd
op_assign
(paren
id|flags
op_amp
id|XFS_BMAPI_RSVBLOCKS
)paren
op_ne
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nexts
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_ext_max
op_eq
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextents
op_eq
l_int|0
)paren
(brace
op_star
id|done
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_blk_unmap
)paren
suffix:semicolon
id|isrt
op_assign
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
suffix:semicolon
id|start
op_assign
id|bno
suffix:semicolon
id|bno
op_assign
id|start
op_plus
id|len
op_minus
l_int|1
suffix:semicolon
id|ep
op_assign
id|xfs_bmap_search_extents
c_func
(paren
id|ip
comma
id|bno
comma
id|whichfork
comma
op_amp
id|eof
comma
op_amp
id|lastx
comma
op_amp
id|got
comma
op_amp
id|prev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if the given block number is past the end of the&n;&t; * file, back up to the last block if so...&n;&t; */
r_if
c_cond
(paren
id|eof
)paren
(brace
id|ep
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
op_decrement
id|lastx
)braket
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
id|bno
op_assign
id|got.br_startoff
op_plus
id|got.br_blockcount
op_minus
l_int|1
suffix:semicolon
)brace
id|logflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFBROOT
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_BTREE
)paren
suffix:semicolon
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
l_int|NULL
comma
l_int|0
comma
id|XFS_BTNUM_BMAP
comma
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|cur-&gt;bc_private.b.firstblock
op_assign
op_star
id|firstblock
suffix:semicolon
id|cur-&gt;bc_private.b.flist
op_assign
id|flist
suffix:semicolon
id|cur-&gt;bc_private.b.flags
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|cur
op_assign
l_int|NULL
suffix:semicolon
id|extno
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|bno
op_ne
(paren
id|xfs_fileoff_t
)paren
op_minus
l_int|1
op_logical_and
id|bno
op_ge
id|start
op_logical_and
id|lastx
op_ge
l_int|0
op_logical_and
(paren
id|nexts
op_eq
l_int|0
op_logical_or
id|extno
OL
id|nexts
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Is the found extent after a hole in which bno lives?&n;&t;&t; * Just back up to the previous extent, if so.&n;&t;&t; */
r_if
c_cond
(paren
id|got.br_startoff
OG
id|bno
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|lastx
OL
l_int|0
)paren
r_break
suffix:semicolon
id|ep
op_decrement
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Is the last block of this extent before the range&n;&t;&t; * we&squot;re supposed to delete?  If so, we&squot;re done.&n;&t;&t; */
id|bno
op_assign
id|XFS_FILEOFF_MIN
c_func
(paren
id|bno
comma
id|got.br_startoff
op_plus
id|got.br_blockcount
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bno
OL
id|start
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Then deal with the (possibly delayed) allocated space&n;&t;&t; * we found.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|ep
op_ne
l_int|NULL
)paren
suffix:semicolon
id|del
op_assign
id|got
suffix:semicolon
id|wasdel
op_assign
id|ISNULLSTARTBLOCK
c_func
(paren
id|del.br_startblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|got.br_startoff
OL
id|start
)paren
(brace
id|del.br_startoff
op_assign
id|start
suffix:semicolon
id|del.br_blockcount
op_sub_assign
id|start
op_minus
id|got.br_startoff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wasdel
)paren
id|del.br_startblock
op_add_assign
id|start
op_minus
id|got.br_startoff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|del.br_startoff
op_plus
id|del.br_blockcount
OG
id|bno
op_plus
l_int|1
)paren
id|del.br_blockcount
op_assign
id|bno
op_plus
l_int|1
op_minus
id|del.br_startoff
suffix:semicolon
id|sum
op_assign
id|del.br_startblock
op_plus
id|del.br_blockcount
suffix:semicolon
r_if
c_cond
(paren
id|isrt
op_logical_and
(paren
id|mod
op_assign
id|do_mod
c_func
(paren
id|sum
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Realtime extent not lined up at the end.&n;&t;&t;&t; * The extent could have been split into written&n;&t;&t;&t; * and unwritten pieces, or we could just be&n;&t;&t;&t; * unmapping part of it.  But we can&squot;t really&n;&t;&t;&t; * get rid of part of a realtime extent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|del.br_state
op_eq
id|XFS_EXT_UNWRITTEN
op_logical_or
op_logical_neg
id|XFS_SB_VERSION_HASEXTFLGBIT
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This piece is unwritten, or we&squot;re not&n;&t;&t;&t;&t; * using unwritten extents.  Skip over it.&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|bno
op_ge
id|mod
)paren
suffix:semicolon
id|bno
op_sub_assign
id|mod
OG
id|del.br_blockcount
ques
c_cond
id|del.br_blockcount
suffix:colon
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|bno
OL
id|got.br_startoff
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|lastx
op_ge
l_int|0
)paren
id|xfs_bmbt_get_all
c_func
(paren
op_decrement
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * It&squot;s written, turn it unwritten.&n;&t;&t;&t; * This is better than zeroing it.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|del.br_state
op_eq
id|XFS_EXT_NORM
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_trans_get_block_res
c_func
(paren
id|tp
)paren
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this spans a realtime extent boundary,&n;&t;&t;&t; * chop it back to the start of the one we end at.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|del.br_blockcount
OG
id|mod
)paren
(brace
id|del.br_startoff
op_add_assign
id|del.br_blockcount
op_minus
id|mod
suffix:semicolon
id|del.br_startblock
op_add_assign
id|del.br_blockcount
op_minus
id|mod
suffix:semicolon
id|del.br_blockcount
op_assign
id|mod
suffix:semicolon
)brace
id|del.br_state
op_assign
id|XFS_EXT_UNWRITTEN
suffix:semicolon
id|error
op_assign
id|xfs_bmap_add_extent
c_func
(paren
id|ip
comma
id|lastx
comma
op_amp
id|cur
comma
op_amp
id|del
comma
id|firstblock
comma
id|flist
comma
op_amp
id|logflags
comma
id|XFS_DATA_FORK
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
r_goto
id|nodelete
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isrt
op_logical_and
(paren
id|mod
op_assign
id|do_mod
c_func
(paren
id|del.br_startblock
comma
id|mp-&gt;m_sb.sb_rextsize
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Realtime extent is lined up at the end but not&n;&t;&t;&t; * at the front.  We&squot;ll get rid of full extents if&n;&t;&t;&t; * we can.&n;&t;&t;&t; */
id|mod
op_assign
id|mp-&gt;m_sb.sb_rextsize
op_minus
id|mod
suffix:semicolon
r_if
c_cond
(paren
id|del.br_blockcount
OG
id|mod
)paren
(brace
id|del.br_blockcount
op_sub_assign
id|mod
suffix:semicolon
id|del.br_startoff
op_add_assign
id|mod
suffix:semicolon
id|del.br_startblock
op_add_assign
id|mod
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|del.br_startoff
op_eq
id|start
op_logical_and
(paren
id|del.br_state
op_eq
id|XFS_EXT_UNWRITTEN
op_logical_or
id|xfs_trans_get_block_res
c_func
(paren
id|tp
)paren
op_eq
l_int|0
)paren
)paren
op_logical_or
op_logical_neg
id|XFS_SB_VERSION_HASEXTFLGBIT
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Can&squot;t make it unwritten.  There isn&squot;t&n;&t;&t;&t;&t; * a full extent here so just skip it.&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|bno
op_ge
id|del.br_blockcount
)paren
suffix:semicolon
id|bno
op_sub_assign
id|del.br_blockcount
suffix:semicolon
r_if
c_cond
(paren
id|bno
OL
id|got.br_startoff
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|lastx
op_ge
l_int|0
)paren
id|xfs_bmbt_get_all
c_func
(paren
op_decrement
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|del.br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This one is already unwritten.&n;&t;&t;&t;&t; * It must have a written left neighbor.&n;&t;&t;&t;&t; * Unwrite the killed part of that one and&n;&t;&t;&t;&t; * try again.&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|lastx
OG
l_int|0
)paren
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|ep
op_minus
l_int|1
comma
op_amp
id|prev
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|prev.br_state
op_eq
id|XFS_EXT_NORM
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|prev.br_startblock
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|del.br_startblock
op_eq
id|prev.br_startblock
op_plus
id|prev.br_blockcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev.br_startoff
OL
id|start
)paren
(brace
id|mod
op_assign
id|start
op_minus
id|prev.br_startoff
suffix:semicolon
id|prev.br_blockcount
op_sub_assign
id|mod
suffix:semicolon
id|prev.br_startblock
op_add_assign
id|mod
suffix:semicolon
id|prev.br_startoff
op_assign
id|start
suffix:semicolon
)brace
id|prev.br_state
op_assign
id|XFS_EXT_UNWRITTEN
suffix:semicolon
id|error
op_assign
id|xfs_bmap_add_extent
c_func
(paren
id|ip
comma
id|lastx
op_minus
l_int|1
comma
op_amp
id|cur
comma
op_amp
id|prev
comma
id|firstblock
comma
id|flist
comma
op_amp
id|logflags
comma
id|XFS_DATA_FORK
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
r_goto
id|nodelete
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|del.br_state
op_eq
id|XFS_EXT_NORM
)paren
suffix:semicolon
id|del.br_state
op_assign
id|XFS_EXT_UNWRITTEN
suffix:semicolon
id|error
op_assign
id|xfs_bmap_add_extent
c_func
(paren
id|ip
comma
id|lastx
comma
op_amp
id|cur
comma
op_amp
id|del
comma
id|firstblock
comma
id|flist
comma
op_amp
id|logflags
comma
id|XFS_DATA_FORK
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
r_goto
id|nodelete
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wasdel
)paren
(brace
id|ASSERT
c_func
(paren
id|STARTBLOCKVAL
c_func
(paren
id|del.br_startblock
)paren
OG
l_int|0
)paren
suffix:semicolon
id|xfs_mod_incore_sb
c_func
(paren
id|mp
comma
id|XFS_SBS_FDBLOCKS
comma
(paren
r_int
)paren
id|del.br_blockcount
comma
id|rsvd
)paren
suffix:semicolon
multiline_comment|/* Unreserve our quota space */
id|XFS_TRANS_RESERVE_QUOTA_NBLKS
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
op_minus
(paren
(paren
r_int
)paren
id|del.br_blockcount
)paren
comma
l_int|0
comma
id|isrt
ques
c_cond
id|XFS_QMOPT_RES_RTBLKS
suffix:colon
id|XFS_QMOPT_RES_REGBLKS
)paren
suffix:semicolon
id|ip-&gt;i_delayed_blks
op_sub_assign
id|del.br_blockcount
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
id|cur-&gt;bc_private.b.flags
op_or_assign
id|XFS_BTCUR_BPRV_WASDEL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cur
)paren
id|cur-&gt;bc_private.b.flags
op_and_assign
op_complement
id|XFS_BTCUR_BPRV_WASDEL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s the case where the directory code is running&n;&t;&t; * with no block reservation, and the deleted block is in&n;&t;&t; * the middle of its extent, and the resulting insert&n;&t;&t; * of an extent would cause transformation to btree format,&n;&t;&t; * then reject it.  The calling code will then swap&n;&t;&t; * blocks around instead.&n;&t;&t; * We have to do this now, rather than waiting for the&n;&t;&t; * conversion to btree format, since the transaction&n;&t;&t; * will be dirty.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|wasdel
op_logical_and
id|xfs_trans_get_block_res
c_func
(paren
id|tp
)paren
op_eq
l_int|0
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ge
id|ifp-&gt;if_ext_max
op_logical_and
id|del.br_startoff
OG
id|got.br_startoff
op_logical_and
id|del.br_startoff
op_plus
id|del.br_blockcount
OL
id|got.br_startoff
op_plus
id|got.br_blockcount
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_bmap_del_extent
c_func
(paren
id|ip
comma
id|tp
comma
id|lastx
comma
id|flist
comma
id|cur
comma
op_amp
id|del
comma
op_amp
id|tmp_logflags
comma
id|whichfork
comma
id|rsvd
)paren
suffix:semicolon
id|logflags
op_or_assign
id|tmp_logflags
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
id|bno
op_assign
id|del.br_startoff
op_minus
l_int|1
suffix:semicolon
id|nodelete
suffix:colon
id|lastx
op_assign
id|ifp-&gt;if_lastex
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If not done go on to the next (previous) record.&n;&t;&t; * Reset ep in case the extents array was re-alloced.&n;&t;&t; */
id|ep
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|lastx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bno
op_ne
(paren
id|xfs_fileoff_t
)paren
op_minus
l_int|1
op_logical_and
id|bno
op_ge
id|start
)paren
(brace
r_if
c_cond
(paren
id|lastx
op_ge
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_logical_or
id|xfs_bmbt_get_startoff
c_func
(paren
id|ep
)paren
OG
id|bno
)paren
(brace
id|lastx
op_decrement
suffix:semicolon
id|ep
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lastx
op_ge
l_int|0
)paren
id|xfs_bmbt_get_all
c_func
(paren
id|ep
comma
op_amp
id|got
)paren
suffix:semicolon
id|extno
op_increment
suffix:semicolon
)brace
)brace
id|ifp-&gt;if_lastex
op_assign
id|lastx
suffix:semicolon
op_star
id|done
op_assign
id|bno
op_eq
(paren
id|xfs_fileoff_t
)paren
op_minus
l_int|1
op_logical_or
id|bno
OL
id|start
op_logical_or
id|lastx
OL
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_ext_max
op_eq
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert to a btree if necessary.&n;&t; */
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
OG
id|ifp-&gt;if_ext_max
)paren
(brace
id|ASSERT
c_func
(paren
id|cur
op_eq
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmap_extents_to_btree
c_func
(paren
id|tp
comma
id|ip
comma
id|firstblock
comma
id|flist
comma
op_amp
id|cur
comma
l_int|0
comma
op_amp
id|tmp_logflags
comma
id|whichfork
)paren
suffix:semicolon
id|logflags
op_or_assign
id|tmp_logflags
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * transform from btree to extents, give it cur&n;&t; */
r_else
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_le
id|ifp-&gt;if_ext_max
)paren
(brace
id|ASSERT
c_func
(paren
id|cur
op_ne
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmap_btree_to_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|cur
comma
op_amp
id|tmp_logflags
comma
id|whichfork
)paren
suffix:semicolon
id|logflags
op_or_assign
id|tmp_logflags
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * transform from extents to local?&n;&t; */
id|ASSERT
c_func
(paren
id|ifp-&gt;if_ext_max
op_eq
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|error0
suffix:colon
multiline_comment|/*&n;&t; * Log everything.  Do this after conversion, there&squot;s no point in&n;&t; * logging the extent list if we&squot;ve converted to btree format.&n;&t; */
r_if
c_cond
(paren
(paren
id|logflags
op_amp
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
)paren
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
id|logflags
op_and_assign
op_complement
id|XFS_ILOG_FEXT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|logflags
op_amp
id|XFS_ILOG_FBROOT
c_func
(paren
id|whichfork
)paren
)paren
op_logical_and
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
id|logflags
op_and_assign
op_complement
id|XFS_ILOG_FBROOT
c_func
(paren
id|whichfork
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log inode even in the error case, if the transaction&n;&t; * is dirty we&squot;ll need to shut down the filesystem.&n;&t; */
r_if
c_cond
(paren
id|logflags
)paren
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|logflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
op_star
id|firstblock
op_assign
id|cur-&gt;bc_private.b.firstblock
suffix:semicolon
id|cur-&gt;bc_private.b.allocated
op_assign
l_int|0
suffix:semicolon
)brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|error
ques
c_cond
id|XFS_BTREE_ERROR
suffix:colon
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Fcntl interface to xfs_bmapi.&n; */
r_int
multiline_comment|/* error code */
DECL|function|xfs_getbmap
id|xfs_getbmap
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
multiline_comment|/* XFS behavior descriptor*/
r_struct
id|getbmap
op_star
id|bmv
comma
multiline_comment|/* user bmap structure */
r_void
op_star
id|ap
comma
multiline_comment|/* pointer to user&squot;s array */
r_int
id|interface
)paren
multiline_comment|/* interface flags */
(brace
id|__int64_t
id|bmvend
suffix:semicolon
multiline_comment|/* last block requested */
r_int
id|error
suffix:semicolon
multiline_comment|/* return value */
id|__int64_t
id|fixlen
suffix:semicolon
multiline_comment|/* length for -1 case */
r_int
id|i
suffix:semicolon
multiline_comment|/* extent number */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* xfs incore inode pointer */
id|vnode_t
op_star
id|vp
suffix:semicolon
multiline_comment|/* corresponding vnode */
r_int
id|lock
suffix:semicolon
multiline_comment|/* lock state */
id|xfs_bmbt_irec_t
op_star
id|map
suffix:semicolon
multiline_comment|/* buffer for user&squot;s data */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount point */
r_int
id|nex
suffix:semicolon
multiline_comment|/* # of user extents can do */
r_int
id|nexleft
suffix:semicolon
multiline_comment|/* # of user extents left */
r_int
id|subnex
suffix:semicolon
multiline_comment|/* # of bmapi&squot;s can do */
r_int
id|nmap
suffix:semicolon
multiline_comment|/* number of map entries */
r_struct
id|getbmap
id|out
suffix:semicolon
multiline_comment|/* output structure */
r_int
id|whichfork
suffix:semicolon
multiline_comment|/* data or attr fork */
r_int
id|prealloced
suffix:semicolon
multiline_comment|/* this is a file with&n;&t;&t;&t;&t;&t;&t; * preallocated data space */
r_int
id|sh_unwritten
suffix:semicolon
multiline_comment|/* true, if unwritten */
multiline_comment|/* extents listed separately */
r_int
id|bmapi_flags
suffix:semicolon
multiline_comment|/* flags for xfs_bmapi */
id|__int32_t
id|oflags
suffix:semicolon
multiline_comment|/* getbmapx bmv_oflags field */
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|whichfork
op_assign
id|interface
op_amp
id|BMV_IF_ATTRFORK
ques
c_cond
id|XFS_ATTR_FORK
suffix:colon
id|XFS_DATA_FORK
suffix:semicolon
id|sh_unwritten
op_assign
(paren
id|interface
op_amp
id|BMV_IF_PREALLOC
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/*&t;If the BMV_IF_NO_DMAPI_READ interface bit specified, do not&n;&t; *&t;generate a DMAPI read event.  Otherwise, if the DM_EVENT_READ&n;&t; *&t;bit is set for the file, generate a read event in order&n;&t; *&t;that the DMAPI application may do its thing before we return&n;&t; *&t;the extents.  Usually this means restoring user file data to&n;&t; *&t;regions of the file that look like holes.&n;&t; *&n;&t; *&t;The &quot;old behavior&quot; (from XFS_IOC_GETBMAP) is to not specify&n;&t; *&t;BMV_IF_NO_DMAPI_READ so that read events are generated.&n;&t; *&t;If this were not true, callers of ioctl( XFS_IOC_GETBMAP )&n;&t; *&t;could misinterpret holes in a DMAPI file as true holes,&n;&t; *&t;when in fact they may represent offline user data.&n;&t; */
r_if
c_cond
(paren
(paren
id|interface
op_amp
id|BMV_IF_NO_DMAPI_READ
)paren
op_eq
l_int|0
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|ip
comma
id|DM_EVENT_READ
)paren
op_logical_and
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
(brace
id|error
op_assign
id|XFS_SEND_DATA
c_func
(paren
id|mp
comma
id|DM_EVENT_READ
comma
id|bdp
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_ATTR_FORK
)paren
(brace
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_aformat
op_ne
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|ip-&gt;i_d.di_aformat
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|ip-&gt;i_d.di_aformat
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|ip-&gt;i_d.di_aformat
op_ne
l_int|0
op_logical_and
id|ip-&gt;i_d.di_aformat
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_getbmap&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_and
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_PREALLOC
)paren
(brace
id|prealloced
op_assign
l_int|1
suffix:semicolon
id|fixlen
op_assign
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|prealloced
op_assign
l_int|0
suffix:semicolon
id|fixlen
op_assign
id|ip-&gt;i_d.di_size
suffix:semicolon
)brace
)brace
r_else
(brace
id|prealloced
op_assign
l_int|0
suffix:semicolon
id|fixlen
op_assign
l_int|1LL
op_lshift
l_int|32
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bmv-&gt;bmv_length
op_eq
op_minus
l_int|1
)paren
(brace
id|fixlen
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|fixlen
)paren
)paren
suffix:semicolon
id|bmv-&gt;bmv_length
op_assign
id|MAX
c_func
(paren
(paren
id|__int64_t
)paren
(paren
id|fixlen
op_minus
id|bmv-&gt;bmv_offset
)paren
comma
(paren
id|__int64_t
)paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bmv-&gt;bmv_length
OL
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmv-&gt;bmv_length
op_eq
l_int|0
)paren
(brace
id|bmv-&gt;bmv_entries
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nex
op_assign
id|bmv-&gt;bmv_count
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nex
op_le
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
id|bmvend
op_assign
id|bmv-&gt;bmv_offset
op_plus
id|bmv-&gt;bmv_length
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
op_logical_and
id|ip-&gt;i_delayed_blks
)paren
(brace
multiline_comment|/* xfs_fsize_t last_byte = xfs_file_last_byte(ip); */
id|VOP_FLUSH_PAGES
c_func
(paren
id|vp
comma
(paren
id|xfs_off_t
)paren
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
id|FI_REMAPF
comma
id|error
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|whichfork
op_eq
id|XFS_ATTR_FORK
op_logical_or
id|ip-&gt;i_delayed_blks
op_eq
l_int|0
)paren
suffix:semicolon
id|lock
op_assign
id|xfs_ilock_map_shared
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t let nex be bigger than the number of extents&n;&t; * we can have assuming alternating holes and real extents.&n;&t; */
r_if
c_cond
(paren
id|nex
OG
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_star
l_int|2
op_plus
l_int|1
)paren
id|nex
op_assign
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_star
l_int|2
op_plus
l_int|1
suffix:semicolon
id|bmapi_flags
op_assign
id|XFS_BMAPI_AFLAG
c_func
(paren
id|whichfork
)paren
op_or
(paren
(paren
id|sh_unwritten
)paren
ques
c_cond
l_int|0
suffix:colon
id|XFS_BMAPI_IGSTATE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate enough space to handle &quot;subnex&quot; maps at a time.&n;&t; */
id|subnex
op_assign
l_int|16
suffix:semicolon
id|map
op_assign
id|kmem_alloc
c_func
(paren
id|subnex
op_star
r_sizeof
(paren
op_star
id|map
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|bmv-&gt;bmv_entries
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
l_int|0
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|unlock_and_return
suffix:semicolon
)brace
id|nexleft
op_assign
id|nex
suffix:semicolon
r_do
(brace
id|nmap
op_assign
(paren
id|nexleft
OG
id|subnex
)paren
ques
c_cond
id|subnex
suffix:colon
id|nexleft
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|XFS_BB_TO_FSBT
c_func
(paren
id|mp
comma
id|bmv-&gt;bmv_offset
)paren
comma
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|bmv-&gt;bmv_length
)paren
comma
id|bmapi_flags
comma
l_int|NULL
comma
l_int|0
comma
id|map
comma
op_amp
id|nmap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|unlock_and_return
suffix:semicolon
id|ASSERT
c_func
(paren
id|nmap
op_le
id|subnex
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nmap
op_logical_and
id|nexleft
op_logical_and
id|bmv-&gt;bmv_length
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nexleft
op_decrement
suffix:semicolon
id|oflags
op_assign
(paren
id|map
(braket
id|i
)braket
dot
id|br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
ques
c_cond
id|BMV_OF_PREALLOC
suffix:colon
l_int|0
suffix:semicolon
id|out.bmv_offset
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|map
(braket
id|i
)braket
dot
id|br_startoff
)paren
suffix:semicolon
id|out.bmv_length
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|map
(braket
id|i
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prealloced
op_logical_and
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_eq
id|HOLESTARTBLOCK
op_logical_and
id|out.bmv_offset
op_plus
id|out.bmv_length
op_eq
id|bmvend
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * came to hole at end of file&n;&t;&t;&t;&t; */
r_goto
id|unlock_and_return
suffix:semicolon
)brace
r_else
(brace
id|out.bmv_block
op_assign
(paren
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
id|XFS_FSB_TO_DB
c_func
(paren
id|ip
comma
id|map
(braket
id|i
)braket
dot
id|br_startblock
)paren
suffix:semicolon
multiline_comment|/* return either getbmap/getbmapx structure. */
r_if
c_cond
(paren
id|interface
op_amp
id|BMV_IF_EXTENDED
)paren
(brace
r_struct
id|getbmapx
id|outx
suffix:semicolon
id|GETBMAP_CONVERT
c_func
(paren
id|out
comma
id|outx
)paren
suffix:semicolon
id|outx.bmv_oflags
op_assign
id|oflags
suffix:semicolon
id|outx.bmv_unused1
op_assign
id|outx.bmv_unused2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ap
comma
op_amp
id|outx
comma
r_sizeof
(paren
id|outx
)paren
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:semicolon
r_goto
id|unlock_and_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ap
comma
op_amp
id|out
comma
r_sizeof
(paren
id|out
)paren
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:semicolon
r_goto
id|unlock_and_return
suffix:semicolon
)brace
)brace
id|bmv-&gt;bmv_offset
op_assign
id|out.bmv_offset
op_plus
id|out.bmv_length
suffix:semicolon
id|bmv-&gt;bmv_length
op_assign
id|MAX
c_func
(paren
(paren
id|__int64_t
)paren
l_int|0
comma
(paren
id|__int64_t
)paren
(paren
id|bmvend
op_minus
id|bmv-&gt;bmv_offset
)paren
)paren
suffix:semicolon
id|bmv-&gt;bmv_entries
op_increment
suffix:semicolon
id|ap
op_assign
(paren
id|interface
op_amp
id|BMV_IF_EXTENDED
)paren
ques
c_cond
(paren
r_void
op_star
)paren
(paren
(paren
r_struct
id|getbmapx
op_star
)paren
id|ap
op_plus
l_int|1
)paren
suffix:colon
(paren
r_void
op_star
)paren
(paren
(paren
r_struct
id|getbmap
op_star
)paren
id|ap
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|nmap
op_logical_and
id|nexleft
op_logical_and
id|bmv-&gt;bmv_length
)paren
suffix:semicolon
id|unlock_and_return
suffix:colon
id|xfs_iunlock_map_shared
c_func
(paren
id|ip
comma
id|lock
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|map
comma
id|subnex
op_star
r_sizeof
(paren
op_star
id|map
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Check the last inode extent to determine whether this allocation will result&n; * in blocks being allocated at the end of the file. When we allocate new data&n; * blocks at the end of the file which do not start at the previous data block,&n; * we will try to align the new blocks at stripe unit boundaries.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_isaeof
id|xfs_bmap_isaeof
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fileoff_t
id|off
comma
multiline_comment|/* file offset in fsblocks */
r_int
id|whichfork
comma
multiline_comment|/* data or attribute fork */
r_char
op_star
id|aeof
)paren
multiline_comment|/* return value */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_bmbt_rec_t
op_star
id|lastrec
suffix:semicolon
multiline_comment|/* extent list entry pointer */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* size of extent list */
id|xfs_bmbt_irec_t
id|s
suffix:semicolon
multiline_comment|/* expanded extent list entry */
id|ASSERT
c_func
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextents
op_eq
l_int|0
)paren
(brace
op_star
id|aeof
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go to the last extent&n;&t; */
id|lastrec
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|nextents
op_minus
l_int|1
)braket
suffix:semicolon
id|xfs_bmbt_get_all
c_func
(paren
id|lastrec
comma
op_amp
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check we are allocating in the last extent (for delayed allocations)&n;&t; * or past the last extent for non-delayed allocations.&n;&t; */
op_star
id|aeof
op_assign
(paren
id|off
op_ge
id|s.br_startoff
op_logical_and
id|off
OL
id|s.br_startoff
op_plus
id|s.br_blockcount
op_logical_and
id|ISNULLSTARTBLOCK
c_func
(paren
id|s.br_startblock
)paren
)paren
op_logical_or
id|off
op_ge
id|s.br_startoff
op_plus
id|s.br_blockcount
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if the endoff is outside the last extent. If so the caller will grow&n; * the allocation to a stripe unit boundary.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_eof
id|xfs_bmap_eof
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
id|xfs_fileoff_t
id|endoff
comma
multiline_comment|/* file offset in fsblocks */
r_int
id|whichfork
comma
multiline_comment|/* data or attribute fork */
r_int
op_star
id|eof
)paren
multiline_comment|/* result value */
(brace
id|xfs_fsblock_t
id|blockcount
suffix:semicolon
multiline_comment|/* extent block count */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_bmbt_rec_t
op_star
id|lastrec
suffix:semicolon
multiline_comment|/* extent list entry pointer */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* size of extent list */
id|xfs_fileoff_t
id|startoff
suffix:semicolon
multiline_comment|/* extent starting file offset */
id|ASSERT
c_func
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|whichfork
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextents
op_eq
l_int|0
)paren
(brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Go to the last extent&n;&t; */
id|lastrec
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
id|nextents
op_minus
l_int|1
)braket
suffix:semicolon
id|startoff
op_assign
id|xfs_bmbt_get_startoff
c_func
(paren
id|lastrec
)paren
suffix:semicolon
id|blockcount
op_assign
id|xfs_bmbt_get_blockcount
c_func
(paren
id|lastrec
)paren
suffix:semicolon
op_star
id|eof
op_assign
id|endoff
op_ge
id|startoff
op_plus
id|blockcount
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef XFSDEBUG
multiline_comment|/*&n; * Check that the extents list for the inode ip is in the right order.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_check_extents
id|xfs_bmap_check_extents
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extents list */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* current extent entry */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extents in list */
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
suffix:semicolon
id|base
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ep
op_assign
id|base
suffix:semicolon
id|ep
OL
op_amp
id|base
(braket
id|nextents
op_minus
l_int|1
)braket
suffix:semicolon
id|ep
op_increment
)paren
(brace
id|xfs_btree_check_rec
c_func
(paren
id|XFS_BTNUM_BMAP
comma
(paren
r_void
op_star
)paren
id|ep
comma
(paren
r_void
op_star
)paren
(paren
id|ep
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
id|STATIC
id|xfs_buf_t
op_star
DECL|function|xfs_bmap_get_bp
id|xfs_bmap_get_bp
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
id|xfs_fsblock_t
id|bno
)paren
(brace
r_int
id|i
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur
)paren
r_return
l_int|NULL
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFS_BTREE_MAXLEVELS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_eq
id|bno
)paren
r_break
suffix:semicolon
multiline_comment|/* Found it */
)brace
r_if
c_cond
(paren
id|i
op_eq
id|XFS_BTREE_MAXLEVELS
)paren
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
multiline_comment|/* Chase down all the log items to see if the bp is there */
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|tp
op_assign
id|cur-&gt;bc_tp
suffix:semicolon
id|licp
op_assign
op_amp
id|tp-&gt;t_items
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|bp
op_logical_and
id|licp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
(brace
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|xfs_buf_t
op_star
id|lbp
suffix:semicolon
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|lidp
op_assign
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
suffix:semicolon
id|lip
op_assign
id|lidp-&gt;lid_item
suffix:semicolon
r_if
c_cond
(paren
id|lip-&gt;li_type
op_ne
id|XFS_LI_BUF
)paren
r_continue
suffix:semicolon
id|bip
op_assign
(paren
id|xfs_buf_log_item_t
op_star
)paren
id|lip
suffix:semicolon
id|lbp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|lbp
)paren
op_eq
id|bno
)paren
(brace
id|bp
op_assign
id|lbp
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Found it */
)brace
)brace
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
)brace
)brace
r_return
id|bp
suffix:semicolon
)brace
r_void
DECL|function|xfs_check_block
id|xfs_check_block
c_func
(paren
id|xfs_bmbt_block_t
op_star
id|block
comma
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|root
comma
r_int
id|sz
)paren
(brace
r_int
id|i
comma
id|j
comma
id|dmxr
suffix:semicolon
id|xfs_bmbt_ptr_t
op_star
id|pp
comma
op_star
id|thispa
suffix:semicolon
multiline_comment|/* pointer to block address */
id|xfs_bmbt_key_t
op_star
id|prevp
comma
op_star
id|keyp
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dmxr
op_assign
id|mp-&gt;m_bmap_dmxr
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|root
)paren
(brace
id|keyp
op_assign
id|XFS_BMAP_BROOT_KEY_ADDR
c_func
(paren
id|block
comma
id|i
comma
id|sz
)paren
suffix:semicolon
)brace
r_else
(brace
id|keyp
op_assign
id|XFS_BTREE_KEY_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
id|i
comma
id|dmxr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|prevp
)paren
(brace
id|xfs_btree_check_key
c_func
(paren
id|XFS_BTNUM_BMAP
comma
id|prevp
comma
id|keyp
)paren
suffix:semicolon
)brace
id|prevp
op_assign
id|keyp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compare the block numbers to see if there are dups.&n;&t;&t; */
r_if
c_cond
(paren
id|root
)paren
(brace
id|pp
op_assign
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|block
comma
id|i
comma
id|sz
)paren
suffix:semicolon
)brace
r_else
(brace
id|pp
op_assign
id|XFS_BTREE_PTR_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
id|i
comma
id|dmxr
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
op_le
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|root
)paren
(brace
id|thispa
op_assign
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|block
comma
id|j
comma
id|sz
)paren
suffix:semicolon
)brace
r_else
(brace
id|thispa
op_assign
id|XFS_BTREE_PTR_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
id|j
comma
id|dmxr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
op_star
id|thispa
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;%s: thispa(%d) == pp(%d) %Ld&quot;
comma
id|__FUNCTION__
comma
id|j
comma
id|i
comma
id|INT_GET
c_func
(paren
op_star
id|thispa
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;%s: ptrs are equal in node&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Check that the extents for the inode ip are in the right order in all&n; * btree leaves.&n; */
id|STATIC
r_void
DECL|function|xfs_bmap_check_leaf_extents
id|xfs_bmap_check_leaf_extents
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor or null */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode pointer */
r_int
id|whichfork
)paren
multiline_comment|/* data or attr fork */
(brace
id|xfs_bmbt_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* current btree block */
id|xfs_fsblock_t
id|bno
suffix:semicolon
multiline_comment|/* block # of &quot;block&quot; */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for &quot;block&quot; */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_extnum_t
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index into the extents list */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* fork structure */
r_int
id|level
suffix:semicolon
multiline_comment|/* btree level, for checking */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount structure */
id|xfs_bmbt_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* pointer to block address */
id|xfs_bmbt_rec_t
op_star
id|ep
comma
op_star
id|lastp
suffix:semicolon
multiline_comment|/* extent pointers in block entry */
r_int
id|bp_release
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
(brace
r_return
suffix:semicolon
)brace
id|bno
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|block
op_assign
id|ifp-&gt;if_broot
suffix:semicolon
multiline_comment|/*&n;&t; * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.&n;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
id|level
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_check_block
c_func
(paren
id|block
comma
id|mp
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|pp
op_assign
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDFSBNO
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
OL
id|mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
OL
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
id|bno
op_assign
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go down the tree until leaf level is reached, following the first&n;&t; * pointer (leftmost) at each level.&n;&t; */
r_while
c_loop
(paren
id|level
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/* See if buf is in cur first */
id|bp
op_assign
id|xfs_bmap_get_bp
c_func
(paren
id|cur
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|bno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|bp_release
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|bp_release
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bp
op_logical_and
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|bno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_goto
id|error_norelse
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|XFS_BMAP_SANITY_CHECK
c_func
(paren
id|mp
comma
id|block
comma
id|level
)paren
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check this block for basic sanity (increasing keys and&n;&t;&t; * no duplicate blocks).&n;&t;&t; */
id|xfs_check_block
c_func
(paren
id|block
comma
id|mp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|pp
op_assign
id|XFS_BTREE_PTR_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
l_int|1
comma
id|mp-&gt;m_bmap_dmxr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|XFS_FSB_SANITY_CHECK
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
comma
id|error0
)paren
suffix:semicolon
id|bno
op_assign
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_release
)paren
(brace
id|bp_release
op_assign
l_int|0
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Here with bp and block set to the leftmost leaf node in the tree.&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over all leaf nodes checking that all extents are in the right order.&n;&t; */
id|lastp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|xfs_bmbt_rec_t
op_star
id|frp
suffix:semicolon
id|xfs_fsblock_t
id|nextbno
suffix:semicolon
id|xfs_extnum_t
id|num_recs
suffix:semicolon
id|num_recs
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read-ahead the next leaf block, if any.&n;&t;&t; */
id|nextbno
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check all the extents to make sure they are OK.&n;&t;&t; * If we had a previous block, the last entry should&n;&t;&t; * conform with the first entry in this one.&n;&t;&t; */
id|frp
op_assign
id|XFS_BTREE_REC_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
l_int|1
comma
id|mp-&gt;m_bmap_dmxr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ep
op_assign
id|frp
suffix:semicolon
id|ep
OL
id|frp
op_plus
(paren
id|num_recs
op_minus
l_int|1
)paren
suffix:semicolon
id|ep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lastp
)paren
(brace
id|xfs_btree_check_rec
c_func
(paren
id|XFS_BTNUM_BMAP
comma
(paren
r_void
op_star
)paren
id|lastp
comma
(paren
r_void
op_star
)paren
id|ep
)paren
suffix:semicolon
)brace
id|xfs_btree_check_rec
c_func
(paren
id|XFS_BTNUM_BMAP
comma
(paren
r_void
op_star
)paren
id|ep
comma
(paren
r_void
op_star
)paren
(paren
id|ep
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
id|lastp
op_assign
id|frp
op_plus
id|num_recs
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* For the next iteration */
id|i
op_add_assign
id|num_recs
suffix:semicolon
r_if
c_cond
(paren
id|bp_release
)paren
(brace
id|bp_release
op_assign
l_int|0
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
)brace
id|bno
op_assign
id|nextbno
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;ve reached the end, stop.&n;&t;&t; */
r_if
c_cond
(paren
id|bno
op_eq
id|NULLFSBLOCK
)paren
r_break
suffix:semicolon
id|bp
op_assign
id|xfs_bmap_get_bp
c_func
(paren
id|cur
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|bno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|bp_release
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|bp_release
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bp
op_logical_and
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|bno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_goto
id|error_norelse
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp_release
)paren
(brace
id|bp_release
op_assign
l_int|0
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|error0
suffix:colon
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;%s: at error0&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_release
)paren
id|xfs_trans_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
id|error_norelse
suffix:colon
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;%s: BAD after btree leaves for %d extents&quot;
comma
id|i
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;%s: CORRUPTED BTREE OR SOMETHING&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Count fsblocks of the given fork.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_count_blocks
id|xfs_bmap_count_blocks
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* incore inode */
r_int
id|whichfork
comma
multiline_comment|/* data or attr fork */
r_int
op_star
id|count
)paren
multiline_comment|/* out: count of blocks */
(brace
id|xfs_bmbt_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* current btree block */
id|xfs_fsblock_t
id|bno
suffix:semicolon
multiline_comment|/* block # of &quot;block&quot; */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* fork structure */
r_int
id|level
suffix:semicolon
multiline_comment|/* btree level, for checking */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount structure */
id|xfs_bmbt_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* pointer to block address */
id|bno
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfs_bmap_count_leaves
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
comma
id|count
)paren
OL
l_int|0
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmap_count_blocks(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.&n;&t; */
id|block
op_assign
id|ifp-&gt;if_broot
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
id|level
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pp
op_assign
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDFSBNO
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
OL
id|mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
)paren
OL
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
id|bno
op_assign
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfs_bmap_count_tree
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|level
comma
id|count
)paren
OL
l_int|0
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmap_count_blocks(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Recursively walks each level of a btree&n; * to count total fsblocks is use.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_bmap_count_tree
id|xfs_bmap_count_tree
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_fsblock_t
id|blockno
comma
multiline_comment|/* file system block number */
r_int
id|levelin
comma
multiline_comment|/* level in btree */
r_int
op_star
id|count
)paren
multiline_comment|/* Count of blocks */
(brace
r_int
id|error
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
comma
op_star
id|nbp
suffix:semicolon
r_int
id|level
op_assign
id|levelin
suffix:semicolon
id|xfs_bmbt_ptr_t
op_star
id|pp
suffix:semicolon
id|xfs_fsblock_t
id|bno
op_assign
id|blockno
suffix:semicolon
id|xfs_fsblock_t
id|nextbno
suffix:semicolon
id|xfs_bmbt_block_t
op_star
id|block
comma
op_star
id|nextblock
suffix:semicolon
r_int
id|numrecs
suffix:semicolon
id|xfs_bmbt_rec_t
op_star
id|frp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|count
op_add_assign
l_int|1
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|level
)paren
(brace
multiline_comment|/* Not at node above leafs, count this level of nodes */
id|nextbno
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nextbno
op_ne
id|NULLFSBLOCK
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
id|tp
comma
id|nextbno
comma
l_int|0
comma
op_amp
id|nbp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|count
op_add_assign
l_int|1
suffix:semicolon
id|nextblock
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|nbp
)paren
suffix:semicolon
id|nextbno
op_assign
id|INT_GET
c_func
(paren
id|nextblock-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|nbp
)paren
suffix:semicolon
)brace
multiline_comment|/* Dive to the next level */
id|pp
op_assign
id|XFS_BTREE_PTR_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
l_int|1
comma
id|mp-&gt;m_bmap_dmxr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|bno
op_assign
id|INT_GET
c_func
(paren
op_star
id|pp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|error
op_assign
id|xfs_bmap_count_tree
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|level
comma
id|count
)paren
)paren
OL
l_int|0
)paren
)paren
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmap_count_tree(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* count all level 1 nodes and their leaves */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|nextbno
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|numrecs
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|frp
op_assign
id|XFS_BTREE_REC_ADDR
c_func
(paren
id|mp-&gt;m_sb.sb_blocksize
comma
id|xfs_bmbt
comma
id|block
comma
l_int|1
comma
id|mp-&gt;m_bmap_dmxr
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfs_bmap_count_leaves
c_func
(paren
id|frp
comma
id|numrecs
comma
id|count
)paren
OL
l_int|0
)paren
)paren
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_bmap_count_tree(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nextbno
op_eq
id|NULLFSBLOCK
)paren
r_break
suffix:semicolon
id|bno
op_assign
id|nextbno
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufl
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_BMAP_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|count
op_add_assign
l_int|1
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Count leaf blocks given a pointer to an extent list.&n; */
r_int
DECL|function|xfs_bmap_count_leaves
id|xfs_bmap_count_leaves
c_func
(paren
id|xfs_bmbt_rec_t
op_star
id|frp
comma
r_int
id|numrecs
comma
r_int
op_star
id|count
)paren
(brace
r_int
id|b
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
l_int|1
suffix:semicolon
id|b
op_le
id|numrecs
suffix:semicolon
id|b
op_increment
comma
id|frp
op_increment
)paren
op_star
id|count
op_add_assign
id|xfs_bmbt_disk_get_blockcount
c_func
(paren
id|frp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
