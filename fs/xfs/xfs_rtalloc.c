multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * Free realtime space allocation for XFS.&n; */
macro_line|#include &lt;xfs.h&gt;
multiline_comment|/*&n; * Prototypes for internal functions.&n; */
id|STATIC
r_int
id|xfs_rtallocate_range
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
id|xfs_rtblock_t
comma
id|xfs_extlen_t
comma
id|xfs_buf_t
op_star
op_star
comma
id|xfs_fsblock_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_rtany_summary
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
r_int
comma
r_int
comma
id|xfs_rtblock_t
comma
id|xfs_buf_t
op_star
op_star
comma
id|xfs_fsblock_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_rtcheck_range
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
id|xfs_rtblock_t
comma
id|xfs_extlen_t
comma
r_int
comma
id|xfs_rtblock_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_rtfind_back
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
id|xfs_rtblock_t
comma
id|xfs_rtblock_t
comma
id|xfs_rtblock_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_rtfind_forw
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
id|xfs_rtblock_t
comma
id|xfs_rtblock_t
comma
id|xfs_rtblock_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_rtget_summary
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
r_int
comma
id|xfs_rtblock_t
comma
id|xfs_buf_t
op_star
op_star
comma
id|xfs_fsblock_t
op_star
comma
id|xfs_suminfo_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_rtmodify_range
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
id|xfs_rtblock_t
comma
id|xfs_extlen_t
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_rtmodify_summary
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_trans_t
op_star
comma
r_int
comma
id|xfs_rtblock_t
comma
r_int
comma
id|xfs_buf_t
op_star
op_star
comma
id|xfs_fsblock_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal functions.&n; */
multiline_comment|/*&n; * xfs_lowbit32: get low bit set out of 32-bit argument, -1 if none set.&n; */
id|STATIC
r_int
DECL|function|xfs_lowbit32
id|xfs_lowbit32
c_func
(paren
id|__uint32_t
id|v
)paren
(brace
r_return
id|ffs
c_func
(paren
id|v
)paren
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space to the bitmap or summary file, and zero it, for growfs.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_growfs_rt_alloc
id|xfs_growfs_rt_alloc
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_extlen_t
id|oblocks
comma
multiline_comment|/* old count of blocks */
id|xfs_extlen_t
id|nblocks
comma
multiline_comment|/* new count of blocks */
id|xfs_ino_t
id|ino
)paren
multiline_comment|/* inode number (bitmap/summary) */
(brace
id|xfs_fileoff_t
id|bno
suffix:semicolon
multiline_comment|/* block number in file */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* temporary buffer for zeroing */
r_int
id|cancelflags
suffix:semicolon
multiline_comment|/* flags for xfs_trans_cancel */
r_int
id|committed
suffix:semicolon
multiline_comment|/* transaction committed flag */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* disk block address */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_fsblock_t
id|firstblock
suffix:semicolon
multiline_comment|/* first block allocated in xaction */
id|xfs_bmap_free_t
id|flist
suffix:semicolon
multiline_comment|/* list of freed blocks */
id|xfs_fsblock_t
id|fsbno
suffix:semicolon
multiline_comment|/* filesystem block for bno */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* pointer to incore inode */
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
multiline_comment|/* block map output */
r_int
id|nmap
suffix:semicolon
multiline_comment|/* number of block maps */
r_int
id|resblks
suffix:semicolon
multiline_comment|/* space reservation */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
multiline_comment|/*&n;&t; * Allocate space to the file, as necessary.&n;&t; */
r_while
c_loop
(paren
id|oblocks
OL
id|nblocks
)paren
(brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_GROWFSRT_ALLOC
)paren
suffix:semicolon
id|resblks
op_assign
id|XFS_GROWFSRT_SPACE_RES
c_func
(paren
id|mp
comma
id|nblocks
op_minus
id|oblocks
)paren
suffix:semicolon
id|cancelflags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reserve space &amp; log for one extent added to the file.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_GROWRTALLOC_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_DEFAULT_PERM_LOG_COUNT
)paren
)paren
)paren
r_goto
id|error_exit
suffix:semicolon
id|cancelflags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Lock the inode.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|mp
comma
id|tp
comma
id|ino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
)paren
)paren
r_goto
id|error_exit
suffix:semicolon
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|flist
comma
op_amp
id|firstblock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate blocks to the bitmap file.&n;&t;&t; */
id|nmap
op_assign
l_int|1
suffix:semicolon
id|cancelflags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|ip
comma
id|oblocks
comma
id|nblocks
op_minus
id|oblocks
comma
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_METADATA
comma
op_amp
id|firstblock
comma
id|resblks
comma
op_amp
id|map
comma
op_amp
id|nmap
comma
op_amp
id|flist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|nmap
OL
l_int|1
)paren
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free any blocks freed up in the transaction, then commit.&n;&t;&t; */
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|flist
comma
id|firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error_exit
suffix:semicolon
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now we need to clear the allocated blocks.&n;&t;&t; * Do this one block per transaction, to keep it simple.&n;&t;&t; */
id|cancelflags
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|bno
op_assign
id|map.br_startoff
comma
id|fsbno
op_assign
id|map.br_startblock
suffix:semicolon
id|bno
OL
id|map.br_startoff
op_plus
id|map.br_blockcount
suffix:semicolon
id|bno
op_increment
comma
id|fsbno
op_increment
)paren
(brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_GROWFSRT_ZERO
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Reserve log for one block zeroing.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_GROWRTZERO_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
r_goto
id|error_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Lock the bitmap inode.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|mp
comma
id|tp
comma
id|ino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
)paren
)paren
r_goto
id|error_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Get a buffer for the block.&n;&t;&t;&t; */
id|d
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|fsbno
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_goto
id|error_exit
suffix:semicolon
)brace
id|memset
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
l_int|0
comma
id|mp-&gt;m_sb.sb_blocksize
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
l_int|0
comma
id|mp-&gt;m_sb.sb_blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Commit the transaction.&n;&t;&t;&t; */
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Go on to the next extent, if any.&n;&t;&t; */
id|oblocks
op_assign
id|map.br_startoff
op_plus
id|map.br_blockcount
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|error_exit
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancelflags
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Attempt to allocate an extent minlen&lt;=len&lt;=maxlen starting from&n; * bitmap block bbno.  If we don&squot;t get maxlen then use prod to trim&n; * the length, if given.  Returns error; returns starting block in *rtblock.&n; * The lengths are all in rtextents.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtallocate_extent_block
id|xfs_rtallocate_extent_block
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|bbno
comma
multiline_comment|/* bitmap block number */
id|xfs_extlen_t
id|minlen
comma
multiline_comment|/* minimum length to allocate */
id|xfs_extlen_t
id|maxlen
comma
multiline_comment|/* maximum length to allocate */
id|xfs_extlen_t
op_star
id|len
comma
multiline_comment|/* out: actual length allocated */
id|xfs_rtblock_t
op_star
id|nextp
comma
multiline_comment|/* out: next block to try */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
comma
multiline_comment|/* in/out: summary block number */
id|xfs_extlen_t
id|prod
comma
multiline_comment|/* extent product factor */
id|xfs_rtblock_t
op_star
id|rtblock
)paren
multiline_comment|/* out: start block allocated */
(brace
id|xfs_rtblock_t
id|besti
suffix:semicolon
multiline_comment|/* best rtblock found so far */
id|xfs_rtblock_t
id|bestlen
suffix:semicolon
multiline_comment|/* best length found so far */
id|xfs_rtblock_t
id|end
suffix:semicolon
multiline_comment|/* last rtblock in chunk */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtblock_t
id|i
suffix:semicolon
multiline_comment|/* current rtblock trying */
id|xfs_rtblock_t
id|next
suffix:semicolon
multiline_comment|/* next rtblock to try */
r_int
id|stat
suffix:semicolon
multiline_comment|/* status from internal calls */
multiline_comment|/*&n;&t; * Loop over all the extents starting in this bitmap block,&n;&t; * looking for one that&squot;s long enough.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|XFS_BLOCKTOBIT
c_func
(paren
id|mp
comma
id|bbno
)paren
comma
id|besti
op_assign
op_minus
l_int|1
comma
id|bestlen
op_assign
l_int|0
comma
id|end
op_assign
id|XFS_BLOCKTOBIT
c_func
(paren
id|mp
comma
id|bbno
op_plus
l_int|1
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_le
id|end
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * See if there&squot;s a free extent of maxlen starting at i.&n;&t;&t; * If it&squot;s not so then next will contain the first non-free.&n;&t;&t; */
id|error
op_assign
id|xfs_rtcheck_range
c_func
(paren
id|mp
comma
id|tp
comma
id|i
comma
id|maxlen
comma
l_int|1
comma
op_amp
id|next
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * i for maxlen is all free, allocate and return that.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_rtallocate_range
c_func
(paren
id|mp
comma
id|tp
comma
id|i
comma
id|maxlen
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_star
id|len
op_assign
id|maxlen
suffix:semicolon
op_star
id|rtblock
op_assign
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * In the case where we have a variable-sized allocation&n;&t;&t; * request, figure out how big this free piece is,&n;&t;&t; * and if it&squot;s big enough for the minimum, and the best&n;&t;&t; * so far, remember it.&n;&t;&t; */
r_if
c_cond
(paren
id|minlen
OL
id|maxlen
)paren
(brace
id|xfs_rtblock_t
id|thislen
suffix:semicolon
multiline_comment|/* this extent size */
id|thislen
op_assign
id|next
op_minus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|thislen
op_ge
id|minlen
op_logical_and
id|thislen
OG
id|bestlen
)paren
(brace
id|besti
op_assign
id|i
suffix:semicolon
id|bestlen
op_assign
id|thislen
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If not done yet, find the start of the next free space.&n;&t;&t; */
r_if
c_cond
(paren
id|next
OL
id|end
)paren
(brace
id|error
op_assign
id|xfs_rtfind_forw
c_func
(paren
id|mp
comma
id|tp
comma
id|next
comma
id|end
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Searched the whole thing &amp; didn&squot;t find a maxlen free extent.&n;&t; */
r_if
c_cond
(paren
id|minlen
OL
id|maxlen
op_logical_and
id|besti
op_ne
op_minus
l_int|1
)paren
(brace
id|xfs_extlen_t
id|p
suffix:semicolon
multiline_comment|/* amount to trim length by */
multiline_comment|/*&n;&t;&t; * If size should be a multiple of prod, make that so.&n;&t;&t; */
r_if
c_cond
(paren
id|prod
OG
l_int|1
op_logical_and
(paren
id|p
op_assign
id|do_mod
c_func
(paren
id|bestlen
comma
id|prod
)paren
)paren
)paren
id|bestlen
op_sub_assign
id|p
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate besti for bestlen &amp; return that.&n;&t;&t; */
id|error
op_assign
id|xfs_rtallocate_range
c_func
(paren
id|mp
comma
id|tp
comma
id|besti
comma
id|bestlen
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_star
id|len
op_assign
id|bestlen
suffix:semicolon
op_star
id|rtblock
op_assign
id|besti
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocation failed.  Set *nextp to the next block to try.&n;&t; */
op_star
id|nextp
op_assign
id|next
suffix:semicolon
op_star
id|rtblock
op_assign
id|NULLRTBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate an extent of length minlen&lt;=len&lt;=maxlen, starting at block&n; * bno.&t; If we don&squot;t get maxlen then use prod to trim the length, if given.&n; * Returns error; returns starting block in *rtblock.&n; * The lengths are all in rtextents.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtallocate_extent_exact
id|xfs_rtallocate_extent_exact
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|bno
comma
multiline_comment|/* starting block number to allocate */
id|xfs_extlen_t
id|minlen
comma
multiline_comment|/* minimum length to allocate */
id|xfs_extlen_t
id|maxlen
comma
multiline_comment|/* maximum length to allocate */
id|xfs_extlen_t
op_star
id|len
comma
multiline_comment|/* out: actual length allocated */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
comma
multiline_comment|/* in/out: summary block number */
id|xfs_extlen_t
id|prod
comma
multiline_comment|/* extent product factor */
id|xfs_rtblock_t
op_star
id|rtblock
)paren
multiline_comment|/* out: start block allocated */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_extlen_t
id|i
suffix:semicolon
multiline_comment|/* extent length trimmed due to prod */
r_int
id|isfree
suffix:semicolon
multiline_comment|/* extent is free */
id|xfs_rtblock_t
id|next
suffix:semicolon
multiline_comment|/* next block to try (dummy) */
id|ASSERT
c_func
(paren
id|minlen
op_mod
id|prod
op_eq
l_int|0
op_logical_and
id|maxlen
op_mod
id|prod
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if the range in question (for maxlen) is free.&n;&t; */
id|error
op_assign
id|xfs_rtcheck_range
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|maxlen
comma
l_int|1
comma
op_amp
id|next
comma
op_amp
id|isfree
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|isfree
)paren
(brace
multiline_comment|/*&n;&t;&t; * If it is, allocate it and return success.&n;&t;&t; */
id|error
op_assign
id|xfs_rtallocate_range
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|maxlen
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_star
id|len
op_assign
id|maxlen
suffix:semicolon
op_star
id|rtblock
op_assign
id|bno
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If not, allocate what there is, if it&squot;s at least minlen.&n;&t; */
id|maxlen
op_assign
id|next
op_minus
id|bno
suffix:semicolon
r_if
c_cond
(paren
id|maxlen
OL
id|minlen
)paren
(brace
multiline_comment|/*&n;&t;&t; * Failed, return failure status.&n;&t;&t; */
op_star
id|rtblock
op_assign
id|NULLRTBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Trim off tail of extent, if prod is specified.&n;&t; */
r_if
c_cond
(paren
id|prod
OG
l_int|1
op_logical_and
(paren
id|i
op_assign
id|maxlen
op_mod
id|prod
)paren
)paren
(brace
id|maxlen
op_sub_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|maxlen
OL
id|minlen
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Now we can&squot;t do it, return failure status.&n;&t;&t;&t; */
op_star
id|rtblock
op_assign
id|NULLRTBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allocate what we can and return it.&n;&t; */
id|error
op_assign
id|xfs_rtallocate_range
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|maxlen
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_star
id|len
op_assign
id|maxlen
suffix:semicolon
op_star
id|rtblock
op_assign
id|bno
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate an extent of length minlen&lt;=len&lt;=maxlen, starting as near&n; * to bno as possible.&t;If we don&squot;t get maxlen then use prod to trim&n; * the length, if given.  The lengths are all in rtextents.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtallocate_extent_near
id|xfs_rtallocate_extent_near
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|bno
comma
multiline_comment|/* starting block number to allocate */
id|xfs_extlen_t
id|minlen
comma
multiline_comment|/* minimum length to allocate */
id|xfs_extlen_t
id|maxlen
comma
multiline_comment|/* maximum length to allocate */
id|xfs_extlen_t
op_star
id|len
comma
multiline_comment|/* out: actual length allocated */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
comma
multiline_comment|/* in/out: summary block number */
id|xfs_extlen_t
id|prod
comma
multiline_comment|/* extent product factor */
id|xfs_rtblock_t
op_star
id|rtblock
)paren
multiline_comment|/* out: start block allocated */
(brace
r_int
id|any
suffix:semicolon
multiline_comment|/* any useful extents from summary */
id|xfs_rtblock_t
id|bbno
suffix:semicolon
multiline_comment|/* bitmap block number */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
r_int
id|i
suffix:semicolon
multiline_comment|/* bitmap block offset (loop control) */
r_int
id|j
suffix:semicolon
multiline_comment|/* secondary loop control */
r_int
id|log2len
suffix:semicolon
multiline_comment|/* log2 of minlen */
id|xfs_rtblock_t
id|n
suffix:semicolon
multiline_comment|/* next block to try */
id|xfs_rtblock_t
id|r
suffix:semicolon
multiline_comment|/* result block */
id|ASSERT
c_func
(paren
id|minlen
op_mod
id|prod
op_eq
l_int|0
op_logical_and
id|maxlen
op_mod
id|prod
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the block number given is off the end, silently set it to&n;&t; * the last block.&n;&t; */
r_if
c_cond
(paren
id|bno
op_ge
id|mp-&gt;m_sb.sb_rextents
)paren
id|bno
op_assign
id|mp-&gt;m_sb.sb_rextents
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Try the exact allocation first.&n;&t; */
id|error
op_assign
id|xfs_rtallocate_extent_exact
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|minlen
comma
id|maxlen
comma
id|len
comma
id|rbpp
comma
id|rsb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the exact allocation worked, return that.&n;&t; */
r_if
c_cond
(paren
id|r
op_ne
id|NULLRTBLOCK
)paren
(brace
op_star
id|rtblock
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bbno
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|bno
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|log2len
op_assign
id|xfs_highbit32
c_func
(paren
id|minlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over all bitmap blocks (bbno + i is current block).&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get summary information of extents of all useful levels&n;&t;&t; * starting in this bitmap block.&n;&t;&t; */
id|error
op_assign
id|xfs_rtany_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|log2len
comma
id|mp-&gt;m_rsumlevels
op_minus
l_int|1
comma
id|bbno
op_plus
id|i
comma
id|rbpp
comma
id|rsb
comma
op_amp
id|any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If there are any useful extents starting here, try&n;&t;&t; * allocating one.&n;&t;&t; */
r_if
c_cond
(paren
id|any
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * On the positive side of the starting location.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|i
op_ge
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Try to allocate an extent starting in&n;&t;&t;&t;&t; * this block.&n;&t;&t;&t;&t; */
id|error
op_assign
id|xfs_rtallocate_extent_block
c_func
(paren
id|mp
comma
id|tp
comma
id|bbno
op_plus
id|i
comma
id|minlen
comma
id|maxlen
comma
id|len
comma
op_amp
id|n
comma
id|rbpp
comma
id|rsb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If it worked, return it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|r
op_ne
id|NULLRTBLOCK
)paren
(brace
op_star
id|rtblock
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * On the negative side of the starting location.&n;&t;&t;&t; */
r_else
(brace
multiline_comment|/* i &lt; 0 */
multiline_comment|/*&n;&t;&t;&t;&t; * Loop backwards through the bitmap blocks from&n;&t;&t;&t;&t; * the starting point-1 up to where we are now.&n;&t;&t;&t;&t; * There should be an extent which ends in this&n;&t;&t;&t;&t; * bitmap block and is long enough.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
op_minus
l_int|1
suffix:semicolon
id|j
OG
id|i
suffix:semicolon
id|j
op_decrement
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Grab the summary information for&n;&t;&t;&t;&t;&t; * this bitmap block.&n;&t;&t;&t;&t;&t; */
id|error
op_assign
id|xfs_rtany_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|log2len
comma
id|mp-&gt;m_rsumlevels
op_minus
l_int|1
comma
id|bbno
op_plus
id|j
comma
id|rbpp
comma
id|rsb
comma
op_amp
id|any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If there&squot;s no extent given in the&n;&t;&t;&t;&t;&t; * summary that means the extent we&n;&t;&t;&t;&t;&t; * found must carry over from an&n;&t;&t;&t;&t;&t; * earlier block.  If there is an&n;&t;&t;&t;&t;&t; * extent given, we&squot;ve already tried&n;&t;&t;&t;&t;&t; * that allocation, don&squot;t do it again.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|any
)paren
r_continue
suffix:semicolon
id|error
op_assign
id|xfs_rtallocate_extent_block
c_func
(paren
id|mp
comma
id|tp
comma
id|bbno
op_plus
id|j
comma
id|minlen
comma
id|maxlen
comma
id|len
comma
op_amp
id|n
comma
id|rbpp
comma
id|rsb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If it works, return the extent.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|r
op_ne
id|NULLRTBLOCK
)paren
(brace
op_star
id|rtblock
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * There weren&squot;t intervening bitmap blocks&n;&t;&t;&t;&t; * with a long enough extent, or the&n;&t;&t;&t;&t; * allocation didn&squot;t work for some reason&n;&t;&t;&t;&t; * (i.e. it&squot;s a little * too short).&n;&t;&t;&t;&t; * Try to allocate from the summary block&n;&t;&t;&t;&t; * that we found.&n;&t;&t;&t;&t; */
id|error
op_assign
id|xfs_rtallocate_extent_block
c_func
(paren
id|mp
comma
id|tp
comma
id|bbno
op_plus
id|i
comma
id|minlen
comma
id|maxlen
comma
id|len
comma
op_amp
id|n
comma
id|rbpp
comma
id|rsb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If it works, return the extent.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|r
op_ne
id|NULLRTBLOCK
)paren
(brace
op_star
id|rtblock
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Loop control.  If we were on the positive side, and there&squot;s&n;&t;&t; * still more blocks on the negative side, go there.&n;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_and
(paren
r_int
)paren
id|bbno
op_minus
id|i
op_ge
l_int|0
)paren
id|i
op_assign
op_minus
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If positive, and no more negative, but there are more&n;&t;&t; * positive, go there.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_and
(paren
r_int
)paren
id|bbno
op_plus
id|i
OL
id|mp-&gt;m_sb.sb_rbmblocks
op_minus
l_int|1
)paren
id|i
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If negative or 0 (just started), and there are positive&n;&t;&t; * blocks to go, go there.  The 0 case moves to block 1.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|i
op_le
l_int|0
op_logical_and
(paren
r_int
)paren
id|bbno
op_minus
id|i
OL
id|mp-&gt;m_sb.sb_rbmblocks
op_minus
l_int|1
)paren
id|i
op_assign
l_int|1
op_minus
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If negative or 0 and there are more negative blocks,&n;&t;&t; * go there.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|i
op_le
l_int|0
op_logical_and
(paren
r_int
)paren
id|bbno
op_plus
id|i
OG
l_int|0
)paren
id|i
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Must be done.  Return failure.&n;&t;&t; */
r_else
r_break
suffix:semicolon
)brace
op_star
id|rtblock
op_assign
id|NULLRTBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate an extent of length minlen&lt;=len&lt;=maxlen, with no position&n; * specified.  If we don&squot;t get maxlen then use prod to trim&n; * the length, if given.  The lengths are all in rtextents.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtallocate_extent_size
id|xfs_rtallocate_extent_size
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_extlen_t
id|minlen
comma
multiline_comment|/* minimum length to allocate */
id|xfs_extlen_t
id|maxlen
comma
multiline_comment|/* maximum length to allocate */
id|xfs_extlen_t
op_star
id|len
comma
multiline_comment|/* out: actual length allocated */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
comma
multiline_comment|/* in/out: summary block number */
id|xfs_extlen_t
id|prod
comma
multiline_comment|/* extent product factor */
id|xfs_rtblock_t
op_star
id|rtblock
)paren
multiline_comment|/* out: start block allocated */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
r_int
id|i
suffix:semicolon
multiline_comment|/* bitmap block number */
r_int
id|l
suffix:semicolon
multiline_comment|/* level number (loop control) */
id|xfs_rtblock_t
id|n
suffix:semicolon
multiline_comment|/* next block to be tried */
id|xfs_rtblock_t
id|r
suffix:semicolon
multiline_comment|/* result block number */
id|xfs_suminfo_t
id|sum
suffix:semicolon
multiline_comment|/* summary information for extents */
id|ASSERT
c_func
(paren
id|minlen
op_mod
id|prod
op_eq
l_int|0
op_logical_and
id|maxlen
op_mod
id|prod
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over all the levels starting with maxlen.&n;&t; * At each level, look at all the bitmap blocks, to see if there&n;&t; * are extents starting there that are long enough (&gt;= maxlen).&n;&t; * Note, only on the initial level can the allocation fail if&n;&t; * the summary says there&squot;s an extent.&n;&t; */
r_for
c_loop
(paren
id|l
op_assign
id|xfs_highbit32
c_func
(paren
id|maxlen
)paren
suffix:semicolon
id|l
OL
id|mp-&gt;m_rsumlevels
suffix:semicolon
id|l
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Loop over all the bitmap blocks.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;m_sb.sb_rbmblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Get the summary for this level/block.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_rtget_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|l
comma
id|i
comma
id|rbpp
comma
id|rsb
comma
op_amp
id|sum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Nothing there, on to the next block.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sum
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Try allocating the extent.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_rtallocate_extent_block
c_func
(paren
id|mp
comma
id|tp
comma
id|i
comma
id|maxlen
comma
id|maxlen
comma
id|len
comma
op_amp
id|n
comma
id|rbpp
comma
id|rsb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If it worked, return that.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|r
op_ne
id|NULLRTBLOCK
)paren
(brace
op_star
id|rtblock
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If the &quot;next block to try&quot; returned from the&n;&t;&t;&t; * allocator is beyond the next bitmap block,&n;&t;&t;&t; * skip to that bitmap block.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|n
)paren
OG
id|i
op_plus
l_int|1
)paren
id|i
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|n
)paren
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find any maxlen blocks.  Try smaller ones, unless&n;&t; * we&squot;re asking for a fixed size extent.&n;&t; */
r_if
c_cond
(paren
id|minlen
OG
op_decrement
id|maxlen
)paren
(brace
op_star
id|rtblock
op_assign
id|NULLRTBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop over sizes, from maxlen down to minlen.&n;&t; * This time, when we do the allocations, allow smaller ones&n;&t; * to succeed.&n;&t; */
r_for
c_loop
(paren
id|l
op_assign
id|xfs_highbit32
c_func
(paren
id|maxlen
)paren
suffix:semicolon
id|l
op_ge
id|xfs_highbit32
c_func
(paren
id|minlen
)paren
suffix:semicolon
id|l
op_decrement
)paren
(brace
multiline_comment|/*&n;&t;&t; * Loop over all the bitmap blocks, try an allocation&n;&t;&t; * starting in that block.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;m_sb.sb_rbmblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Get the summary information for this level/block.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_rtget_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|l
comma
id|i
comma
id|rbpp
comma
id|rsb
comma
op_amp
id|sum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If nothing there, go on to next.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sum
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Try the allocation.&t;Make sure the specified&n;&t;&t;&t; * minlen/maxlen are in the possible range for&n;&t;&t;&t; * this summary level.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_rtallocate_extent_block
c_func
(paren
id|mp
comma
id|tp
comma
id|i
comma
id|XFS_RTMAX
c_func
(paren
id|minlen
comma
l_int|1
op_lshift
id|l
)paren
comma
id|XFS_RTMIN
c_func
(paren
id|maxlen
comma
(paren
l_int|1
op_lshift
(paren
id|l
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
)paren
comma
id|len
comma
op_amp
id|n
comma
id|rbpp
comma
id|rsb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If it worked, return that extent.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|r
op_ne
id|NULLRTBLOCK
)paren
(brace
op_star
id|rtblock
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If the &quot;next block to try&quot; returned from the&n;&t;&t;&t; * allocator is beyond the next bitmap block,&n;&t;&t;&t; * skip to that bitmap block.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|n
)paren
OG
id|i
op_plus
l_int|1
)paren
id|i
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|n
)paren
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Got nothing, return failure.&n;&t; */
op_star
id|rtblock
op_assign
id|NULLRTBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Mark an extent specified by start and len allocated.&n; * Updates all the summary information as well as the bitmap.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtallocate_range
id|xfs_rtallocate_range
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* start block to allocate */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length to allocate */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
)paren
multiline_comment|/* in/out: summary block number */
(brace
id|xfs_rtblock_t
id|end
suffix:semicolon
multiline_comment|/* end of the allocated extent */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtblock_t
id|postblock
suffix:semicolon
multiline_comment|/* first block allocated &gt; end */
id|xfs_rtblock_t
id|preblock
suffix:semicolon
multiline_comment|/* first block allocated &lt; start */
id|end
op_assign
id|start
op_plus
id|len
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Assume we&squot;re allocating out of the middle of a free extent.&n;&t; * We need to find the beginning and end of the extent so we can&n;&t; * properly update the summary.&n;&t; */
id|error
op_assign
id|xfs_rtfind_back
c_func
(paren
id|mp
comma
id|tp
comma
id|start
comma
l_int|0
comma
op_amp
id|preblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the next allocated block (end of free extent).&n;&t; */
id|error
op_assign
id|xfs_rtfind_forw
c_func
(paren
id|mp
comma
id|tp
comma
id|end
comma
id|mp-&gt;m_sb.sb_rextents
op_minus
l_int|1
comma
op_amp
id|postblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decrement the summary information corresponding to the entire&n;&t; * (old) free extent.&n;&t; */
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|XFS_RTBLOCKLOG
c_func
(paren
id|postblock
op_plus
l_int|1
op_minus
id|preblock
)paren
comma
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|preblock
)paren
comma
op_minus
l_int|1
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are blocks not being allocated at the front of the&n;&t; * old extent, add summary data for them to be free.&n;&t; */
r_if
c_cond
(paren
id|preblock
OL
id|start
)paren
(brace
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|XFS_RTBLOCKLOG
c_func
(paren
id|start
op_minus
id|preblock
)paren
comma
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|preblock
)paren
comma
l_int|1
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If there are blocks not being allocated at the end of the&n;&t; * old extent, add summary data for them to be free.&n;&t; */
r_if
c_cond
(paren
id|postblock
OG
id|end
)paren
(brace
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|XFS_RTBLOCKLOG
c_func
(paren
id|postblock
op_minus
id|end
)paren
comma
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|end
op_plus
l_int|1
)paren
comma
l_int|1
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Modify the bitmap to mark this extent allocated.&n;&t; */
id|error
op_assign
id|xfs_rtmodify_range
c_func
(paren
id|mp
comma
id|tp
comma
id|start
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Return whether there are any free extents in the size range given&n; * by low and high, for the bitmap block bbno.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtany_summary
id|xfs_rtany_summary
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
r_int
id|low
comma
multiline_comment|/* low log2 extent size */
r_int
id|high
comma
multiline_comment|/* high log2 extent size */
id|xfs_rtblock_t
id|bbno
comma
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
comma
multiline_comment|/* in/out: summary block number */
r_int
op_star
id|stat
)paren
multiline_comment|/* out: any good extents here? */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
r_int
id|log
suffix:semicolon
multiline_comment|/* loop counter, log2 of ext. size */
id|xfs_suminfo_t
id|sum
suffix:semicolon
multiline_comment|/* summary data */
multiline_comment|/*&n;&t; * Loop over logs of extent sizes.  Order is irrelevant.&n;&t; */
r_for
c_loop
(paren
id|log
op_assign
id|low
suffix:semicolon
id|log
op_le
id|high
suffix:semicolon
id|log
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get one summary datum.&n;&t;&t; */
id|error
op_assign
id|xfs_rtget_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|log
comma
id|bbno
comma
id|rbpp
comma
id|rsb
comma
op_amp
id|sum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If there are any, return success.&n;&t;&t; */
r_if
c_cond
(paren
id|sum
)paren
(brace
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Found nothing, return failure.&n;&t; */
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a buffer for the bitmap or summary file block specified.&n; * The buffer is returned read and locked.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtbuf_get
id|xfs_rtbuf_get
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|block
comma
multiline_comment|/* block number in bitmap or summary */
r_int
id|issum
comma
multiline_comment|/* is summary not bitmap */
id|xfs_buf_t
op_star
op_star
id|bpp
)paren
multiline_comment|/* output: buffer for the block */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* block buffer, result */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* disk addr of block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_fsblock_t
id|fsb
suffix:semicolon
multiline_comment|/* fs block number for block */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* bitmap or summary inode */
id|ip
op_assign
id|issum
ques
c_cond
id|mp-&gt;m_rsumip
suffix:colon
id|mp-&gt;m_rbmip
suffix:semicolon
multiline_comment|/*&n;&t; * Map from the file offset (block) and inode number to the&n;&t; * file system block.&n;&t; */
id|error
op_assign
id|xfs_bmapi_single
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_DATA_FORK
comma
op_amp
id|fsb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|fsb
op_ne
id|NULLFSBLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert to disk address for buffer cache.&n;&t; */
id|d
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|fsb
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the buffer.&n;&t; */
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_logical_and
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Check that the given extent (block range) is allocated already.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtcheck_alloc_range
id|xfs_rtcheck_alloc_range
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|bno
comma
multiline_comment|/* starting block number of extent */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
op_star
id|stat
)paren
multiline_comment|/* out: 1 for allocated, 0 for not */
(brace
id|xfs_rtblock_t
r_new
suffix:semicolon
multiline_comment|/* dummy for xfs_rtcheck_range */
r_return
id|xfs_rtcheck_range
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|len
comma
l_int|0
comma
op_amp
r_new
comma
id|stat
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Check whether the given block in the bitmap has the given value.&n; */
id|STATIC
r_int
multiline_comment|/* 1 for matches, 0 for not */
DECL|function|xfs_rtcheck_bit
id|xfs_rtcheck_bit
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* bit (block) to check */
r_int
id|val
)paren
multiline_comment|/* 1 for free, 0 for allocated */
(brace
r_int
id|bit
suffix:semicolon
multiline_comment|/* bit number in the word */
id|xfs_rtblock_t
id|block
suffix:semicolon
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buf for the block */
id|xfs_rtword_t
op_star
id|bufp
suffix:semicolon
multiline_comment|/* pointer into the buffer */
multiline_comment|/* REFERENCED */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtword_t
id|wdiff
suffix:semicolon
multiline_comment|/* difference between bit &amp; expected */
r_int
id|word
suffix:semicolon
multiline_comment|/* word number in the buffer */
id|xfs_rtword_t
id|wval
suffix:semicolon
multiline_comment|/* word value from buffer */
id|block
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
id|XFS_BITTOWORD
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|bit
op_assign
(paren
r_int
)paren
(paren
id|start
op_amp
(paren
id|XFS_NBWORD
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|wval
op_assign
id|bufp
(braket
id|word
)braket
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|wdiff
op_assign
(paren
id|wval
op_xor
op_minus
id|val
)paren
op_amp
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
id|bit
)paren
suffix:semicolon
r_return
op_logical_neg
id|wdiff
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
macro_line|#if 0
multiline_comment|/*&n; * Check that the given extent (block range) is free already.&n; */
id|STATIC
r_int
multiline_comment|/* error */
id|xfs_rtcheck_free_range
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|bno
comma
multiline_comment|/* starting block number of extent */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
op_star
id|stat
)paren
multiline_comment|/* out: 1 for free, 0 for not */
(brace
id|xfs_rtblock_t
r_new
suffix:semicolon
multiline_comment|/* dummy for xfs_rtcheck_range */
r_return
id|xfs_rtcheck_range
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|len
comma
l_int|1
comma
op_amp
r_new
comma
id|stat
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Check that the given range is either all allocated (val = 0) or&n; * all free (val = 1).&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtcheck_range
id|xfs_rtcheck_range
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* starting block number of extent */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
id|val
comma
multiline_comment|/* 1 for free, 0 for allocated */
id|xfs_rtblock_t
op_star
r_new
comma
multiline_comment|/* out: first block not matching */
r_int
op_star
id|stat
)paren
multiline_comment|/* out: 1 for matches, 0 for not */
(brace
id|xfs_rtword_t
op_star
id|b
suffix:semicolon
multiline_comment|/* current word in buffer */
r_int
id|bit
suffix:semicolon
multiline_comment|/* bit number in the word */
id|xfs_rtblock_t
id|block
suffix:semicolon
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buf for the block */
id|xfs_rtword_t
op_star
id|bufp
suffix:semicolon
multiline_comment|/* starting word in buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtblock_t
id|i
suffix:semicolon
multiline_comment|/* current bit number rel. to start */
id|xfs_rtblock_t
id|lastbit
suffix:semicolon
multiline_comment|/* last useful bit in word */
id|xfs_rtword_t
id|mask
suffix:semicolon
multiline_comment|/* mask of relevant bits for value */
id|xfs_rtword_t
id|wdiff
suffix:semicolon
multiline_comment|/* difference from wanted value */
r_int
id|word
suffix:semicolon
multiline_comment|/* word number in the buffer */
multiline_comment|/*&n;&t; * Compute starting bitmap block number&n;&t; */
id|block
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the bitmap block.&n;&t; */
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the starting word&squot;s address, and starting bit.&n;&t; */
id|word
op_assign
id|XFS_BITTOWORD
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|b
op_assign
op_amp
id|bufp
(braket
id|word
)braket
suffix:semicolon
id|bit
op_assign
(paren
r_int
)paren
(paren
id|start
op_amp
(paren
id|XFS_NBWORD
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * 0 (allocated) =&gt; all zero&squot;s; 1 (free) =&gt; all one&squot;s.&n;&t; */
id|val
op_assign
op_minus
id|val
suffix:semicolon
multiline_comment|/*&n;&t; * If not starting on a word boundary, deal with the first&n;&t; * (partial) word.&n;&t; */
r_if
c_cond
(paren
id|bit
)paren
(brace
multiline_comment|/*&n;&t;&t; * Compute first bit not examined.&n;&t;&t; */
id|lastbit
op_assign
id|XFS_RTMIN
c_func
(paren
id|bit
op_plus
id|len
comma
id|XFS_NBWORD
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mask of relevant bits.&n;&t;&t; */
id|mask
op_assign
(paren
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
(paren
id|lastbit
op_minus
id|bit
)paren
)paren
op_minus
l_int|1
)paren
op_lshift
id|bit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute difference between actual and desired value.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
(paren
op_star
id|b
op_xor
id|val
)paren
op_amp
id|mask
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different, compute first wrong bit and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_assign
id|XFS_RTLOBIT
c_func
(paren
id|wdiff
)paren
op_minus
id|bit
suffix:semicolon
op_star
r_new
op_assign
id|start
op_plus
id|i
suffix:semicolon
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_assign
id|lastbit
op_minus
id|bit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to next block if that&squot;s where the next word is&n;&t;&t; * and we need the next word.&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|word
op_eq
id|XFS_BLOCKWSIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If done with this block, get the next one.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_increment
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|b
op_assign
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the next word in the buffer.&n;&t;&t;&t; */
id|b
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Starting on a word boundary, no partial word.&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop over whole words in buffers.  When we use up one buffer&n;&t; * we move on to the next one.&n;&t; */
r_while
c_loop
(paren
id|len
op_minus
id|i
op_ge
id|XFS_NBWORD
)paren
(brace
multiline_comment|/*&n;&t;&t; * Compute difference between actual and desired value.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
op_star
id|b
op_xor
id|val
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different, compute first wrong bit and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_add_assign
id|XFS_RTLOBIT
c_func
(paren
id|wdiff
)paren
suffix:semicolon
op_star
r_new
op_assign
id|start
op_plus
id|i
suffix:semicolon
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_add_assign
id|XFS_NBWORD
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to next block if that&squot;s where the next word is&n;&t;&t; * and we need the next word.&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|word
op_eq
id|XFS_BLOCKWSIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If done with this block, get the next one.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_increment
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|b
op_assign
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the next word in the buffer.&n;&t;&t;&t; */
id|b
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If not ending on a word boundary, deal with the last&n;&t; * (partial) word.&n;&t; */
r_if
c_cond
(paren
(paren
id|lastbit
op_assign
id|len
op_minus
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mask of relevant bits.&n;&t;&t; */
id|mask
op_assign
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
id|lastbit
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute difference between actual and desired value.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
(paren
op_star
id|b
op_xor
id|val
)paren
op_amp
id|mask
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different, compute first wrong bit and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_add_assign
id|XFS_RTLOBIT
c_func
(paren
id|wdiff
)paren
suffix:semicolon
op_star
r_new
op_assign
id|start
op_plus
id|i
suffix:semicolon
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|i
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Successful, return.&n;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
op_star
r_new
op_assign
id|start
op_plus
id|i
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy and transform the summary file, given the old and new&n; * parameters in the mount structures.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtcopy_summary
id|xfs_rtcopy_summary
c_func
(paren
id|xfs_mount_t
op_star
id|omp
comma
multiline_comment|/* old file system mount point */
id|xfs_mount_t
op_star
id|nmp
comma
multiline_comment|/* new file system mount point */
id|xfs_trans_t
op_star
id|tp
)paren
multiline_comment|/* transaction pointer */
(brace
id|xfs_rtblock_t
id|bbno
suffix:semicolon
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* summary buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|log
suffix:semicolon
multiline_comment|/* summary level number (log length) */
id|xfs_suminfo_t
id|sum
suffix:semicolon
multiline_comment|/* summary data */
id|xfs_fsblock_t
id|sumbno
suffix:semicolon
multiline_comment|/* summary block number */
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|log
op_assign
id|omp-&gt;m_rsumlevels
op_minus
l_int|1
suffix:semicolon
id|log
op_ge
l_int|0
suffix:semicolon
id|log
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|bbno
op_assign
id|omp-&gt;m_sb.sb_rbmblocks
op_minus
l_int|1
suffix:semicolon
(paren
id|xfs_srtblock_t
)paren
id|bbno
op_ge
l_int|0
suffix:semicolon
id|bbno
op_decrement
)paren
(brace
id|error
op_assign
id|xfs_rtget_summary
c_func
(paren
id|omp
comma
id|tp
comma
id|log
comma
id|bbno
comma
op_amp
id|bp
comma
op_amp
id|sumbno
comma
op_amp
id|sum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|sum
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|omp
comma
id|tp
comma
id|log
comma
id|bbno
comma
op_minus
id|sum
comma
op_amp
id|bp
comma
op_amp
id|sumbno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|nmp
comma
id|tp
comma
id|log
comma
id|bbno
comma
id|sum
comma
op_amp
id|bp
comma
op_amp
id|sumbno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|sum
OG
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Searching backward from start to limit, find the first block whose&n; * allocated/free state is different from start&squot;s.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtfind_back
id|xfs_rtfind_back
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* starting block to look at */
id|xfs_rtblock_t
id|limit
comma
multiline_comment|/* last block to look at */
id|xfs_rtblock_t
op_star
id|rtblock
)paren
multiline_comment|/* out: start block found */
(brace
id|xfs_rtword_t
op_star
id|b
suffix:semicolon
multiline_comment|/* current word in buffer */
r_int
id|bit
suffix:semicolon
multiline_comment|/* bit number in the word */
id|xfs_rtblock_t
id|block
suffix:semicolon
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buf for the block */
id|xfs_rtword_t
op_star
id|bufp
suffix:semicolon
multiline_comment|/* starting word in buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtblock_t
id|firstbit
suffix:semicolon
multiline_comment|/* first useful bit in the word */
id|xfs_rtblock_t
id|i
suffix:semicolon
multiline_comment|/* current bit number rel. to start */
id|xfs_rtblock_t
id|len
suffix:semicolon
multiline_comment|/* length of inspected area */
id|xfs_rtword_t
id|mask
suffix:semicolon
multiline_comment|/* mask of relevant bits for value */
id|xfs_rtword_t
id|want
suffix:semicolon
multiline_comment|/* mask for &quot;good&quot; values */
id|xfs_rtword_t
id|wdiff
suffix:semicolon
multiline_comment|/* difference from wanted value */
r_int
id|word
suffix:semicolon
multiline_comment|/* word number in the buffer */
multiline_comment|/*&n;&t; * Compute and read in starting bitmap block for starting block.&n;&t; */
id|block
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the first word&squot;s index &amp; point to it.&n;&t; */
id|word
op_assign
id|XFS_BITTOWORD
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|b
op_assign
op_amp
id|bufp
(braket
id|word
)braket
suffix:semicolon
id|bit
op_assign
(paren
r_int
)paren
(paren
id|start
op_amp
(paren
id|XFS_NBWORD
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|len
op_assign
id|start
op_minus
id|limit
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Compute match value, based on the bit at start: if 1 (free)&n;&t; * then all-ones, else all-zeroes.&n;&t; */
id|want
op_assign
(paren
op_star
id|b
op_amp
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
id|bit
)paren
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the starting position is not word-aligned, deal with the&n;&t; * partial word.&n;&t; */
r_if
c_cond
(paren
id|bit
OL
id|XFS_NBWORD
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Calculate first (leftmost) bit number to look at,&n;&t;&t; * and mask for all the relevant bits in this word.&n;&t;&t; */
id|firstbit
op_assign
id|XFS_RTMAX
c_func
(paren
(paren
id|xfs_srtblock_t
)paren
(paren
id|bit
op_minus
id|len
op_plus
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
id|mask
op_assign
(paren
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
(paren
id|bit
op_minus
id|firstbit
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
)paren
op_lshift
id|firstbit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate the difference between the value there&n;&t;&t; * and what we&squot;re looking for.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
(paren
op_star
id|b
op_xor
id|want
)paren
op_amp
id|mask
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different.  Mark where we are and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_assign
id|bit
op_minus
id|XFS_RTHIBIT
c_func
(paren
id|wdiff
)paren
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_minus
id|i
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_assign
id|bit
op_minus
id|firstbit
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to previous block if that&squot;s where the previous word is&n;&t;&t; * and we need the previous word.&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|word
op_eq
op_minus
l_int|1
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If done with this block, get the previous one.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_decrement
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
id|XFS_BLOCKWMASK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|b
op_assign
op_amp
id|bufp
(braket
id|word
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the previous word in the buffer.&n;&t;&t;&t; */
id|b
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Starting on a word boundary, no partial word.&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop over whole words in buffers.  When we use up one buffer&n;&t; * we move on to the previous one.&n;&t; */
r_while
c_loop
(paren
id|len
op_minus
id|i
op_ge
id|XFS_NBWORD
)paren
(brace
multiline_comment|/*&n;&t;&t; * Compute difference between actual and desired value.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
op_star
id|b
op_xor
id|want
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different, mark where we are and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_add_assign
id|XFS_NBWORD
op_minus
l_int|1
op_minus
id|XFS_RTHIBIT
c_func
(paren
id|wdiff
)paren
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_minus
id|i
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_add_assign
id|XFS_NBWORD
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to previous block if that&squot;s where the previous word is&n;&t;&t; * and we need the previous word.&n;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|word
op_eq
op_minus
l_int|1
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If done with this block, get the previous one.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_decrement
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
id|XFS_BLOCKWMASK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|b
op_assign
op_amp
id|bufp
(braket
id|word
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the previous word in the buffer.&n;&t;&t;&t; */
id|b
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If not ending on a word boundary, deal with the last&n;&t; * (partial) word.&n;&t; */
r_if
c_cond
(paren
id|len
op_minus
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; * Calculate first (leftmost) bit number to look at,&n;&t;&t; * and mask for all the relevant bits in this word.&n;&t;&t; */
id|firstbit
op_assign
id|XFS_NBWORD
op_minus
(paren
id|len
op_minus
id|i
)paren
suffix:semicolon
id|mask
op_assign
(paren
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
(paren
id|len
op_minus
id|i
)paren
)paren
op_minus
l_int|1
)paren
op_lshift
id|firstbit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute difference between actual and desired value.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
(paren
op_star
id|b
op_xor
id|want
)paren
op_amp
id|mask
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different, mark where we are and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_add_assign
id|XFS_NBWORD
op_minus
l_int|1
op_minus
id|XFS_RTHIBIT
c_func
(paren
id|wdiff
)paren
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_minus
id|i
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|i
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No match, return that we scanned the whole area.&n;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_minus
id|i
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Searching forward from start to limit, find the first block whose&n; * allocated/free state is different from start&squot;s.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtfind_forw
id|xfs_rtfind_forw
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* starting block to look at */
id|xfs_rtblock_t
id|limit
comma
multiline_comment|/* last block to look at */
id|xfs_rtblock_t
op_star
id|rtblock
)paren
multiline_comment|/* out: start block found */
(brace
id|xfs_rtword_t
op_star
id|b
suffix:semicolon
multiline_comment|/* current word in buffer */
r_int
id|bit
suffix:semicolon
multiline_comment|/* bit number in the word */
id|xfs_rtblock_t
id|block
suffix:semicolon
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buf for the block */
id|xfs_rtword_t
op_star
id|bufp
suffix:semicolon
multiline_comment|/* starting word in buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtblock_t
id|i
suffix:semicolon
multiline_comment|/* current bit number rel. to start */
id|xfs_rtblock_t
id|lastbit
suffix:semicolon
multiline_comment|/* last useful bit in the word */
id|xfs_rtblock_t
id|len
suffix:semicolon
multiline_comment|/* length of inspected area */
id|xfs_rtword_t
id|mask
suffix:semicolon
multiline_comment|/* mask of relevant bits for value */
id|xfs_rtword_t
id|want
suffix:semicolon
multiline_comment|/* mask for &quot;good&quot; values */
id|xfs_rtword_t
id|wdiff
suffix:semicolon
multiline_comment|/* difference from wanted value */
r_int
id|word
suffix:semicolon
multiline_comment|/* word number in the buffer */
multiline_comment|/*&n;&t; * Compute and read in starting bitmap block for starting block.&n;&t; */
id|block
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the first word&squot;s index &amp; point to it.&n;&t; */
id|word
op_assign
id|XFS_BITTOWORD
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|b
op_assign
op_amp
id|bufp
(braket
id|word
)braket
suffix:semicolon
id|bit
op_assign
(paren
r_int
)paren
(paren
id|start
op_amp
(paren
id|XFS_NBWORD
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|len
op_assign
id|limit
op_minus
id|start
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Compute match value, based on the bit at start: if 1 (free)&n;&t; * then all-ones, else all-zeroes.&n;&t; */
id|want
op_assign
(paren
op_star
id|b
op_amp
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
id|bit
)paren
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the starting position is not word-aligned, deal with the&n;&t; * partial word.&n;&t; */
r_if
c_cond
(paren
id|bit
)paren
(brace
multiline_comment|/*&n;&t;&t; * Calculate last (rightmost) bit number to look at,&n;&t;&t; * and mask for all the relevant bits in this word.&n;&t;&t; */
id|lastbit
op_assign
id|XFS_RTMIN
c_func
(paren
id|bit
op_plus
id|len
comma
id|XFS_NBWORD
)paren
suffix:semicolon
id|mask
op_assign
(paren
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
(paren
id|lastbit
op_minus
id|bit
)paren
)paren
op_minus
l_int|1
)paren
op_lshift
id|bit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate the difference between the value there&n;&t;&t; * and what we&squot;re looking for.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
(paren
op_star
id|b
op_xor
id|want
)paren
op_amp
id|mask
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different.  Mark where we are and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_assign
id|XFS_RTLOBIT
c_func
(paren
id|wdiff
)paren
op_minus
id|bit
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_plus
id|i
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_assign
id|lastbit
op_minus
id|bit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to next block if that&squot;s where the next word is&n;&t;&t; * and we need the next word.&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|word
op_eq
id|XFS_BLOCKWSIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If done with this block, get the previous one.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_increment
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|b
op_assign
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the previous word in the buffer.&n;&t;&t;&t; */
id|b
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Starting on a word boundary, no partial word.&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop over whole words in buffers.  When we use up one buffer&n;&t; * we move on to the next one.&n;&t; */
r_while
c_loop
(paren
id|len
op_minus
id|i
op_ge
id|XFS_NBWORD
)paren
(brace
multiline_comment|/*&n;&t;&t; * Compute difference between actual and desired value.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
op_star
id|b
op_xor
id|want
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different, mark where we are and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_add_assign
id|XFS_RTLOBIT
c_func
(paren
id|wdiff
)paren
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_plus
id|i
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|i
op_add_assign
id|XFS_NBWORD
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to next block if that&squot;s where the next word is&n;&t;&t; * and we need the next word.&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|word
op_eq
id|XFS_BLOCKWSIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If done with this block, get the next one.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_increment
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|b
op_assign
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the next word in the buffer.&n;&t;&t;&t; */
id|b
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If not ending on a word boundary, deal with the last&n;&t; * (partial) word.&n;&t; */
r_if
c_cond
(paren
(paren
id|lastbit
op_assign
id|len
op_minus
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Calculate mask for all the relevant bits in this word.&n;&t;&t; */
id|mask
op_assign
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
id|lastbit
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute difference between actual and desired value.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|wdiff
op_assign
(paren
op_star
id|b
op_xor
id|want
)paren
op_amp
id|mask
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Different, mark where we are and return.&n;&t;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|i
op_add_assign
id|XFS_RTLOBIT
c_func
(paren
id|wdiff
)paren
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_plus
id|i
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
id|i
op_assign
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No match, return that we scanned the whole area.&n;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
op_star
id|rtblock
op_assign
id|start
op_plus
id|i
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Mark an extent specified by start and len freed.&n; * Updates all the summary information as well as the bitmap.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtfree_range
id|xfs_rtfree_range
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* starting block to free */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length to free */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
)paren
multiline_comment|/* in/out: summary block number */
(brace
id|xfs_rtblock_t
id|end
suffix:semicolon
multiline_comment|/* end of the freed extent */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtblock_t
id|postblock
suffix:semicolon
multiline_comment|/* first block freed &gt; end */
id|xfs_rtblock_t
id|preblock
suffix:semicolon
multiline_comment|/* first block freed &lt; start */
id|end
op_assign
id|start
op_plus
id|len
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Modify the bitmap to mark this extent freed.&n;&t; */
id|error
op_assign
id|xfs_rtmodify_range
c_func
(paren
id|mp
comma
id|tp
comma
id|start
comma
id|len
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Assume we&squot;re freeing out of the middle of an allocated extent.&n;&t; * We need to find the beginning and end of the extent so we can&n;&t; * properly update the summary.&n;&t; */
id|error
op_assign
id|xfs_rtfind_back
c_func
(paren
id|mp
comma
id|tp
comma
id|start
comma
l_int|0
comma
op_amp
id|preblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the next allocated block (end of allocated extent).&n;&t; */
id|error
op_assign
id|xfs_rtfind_forw
c_func
(paren
id|mp
comma
id|tp
comma
id|end
comma
id|mp-&gt;m_sb.sb_rextents
op_minus
l_int|1
comma
op_amp
id|postblock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there are blocks not being freed at the front of the&n;&t; * old extent, add summary data for them to be allocated.&n;&t; */
r_if
c_cond
(paren
id|preblock
OL
id|start
)paren
(brace
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|XFS_RTBLOCKLOG
c_func
(paren
id|start
op_minus
id|preblock
)paren
comma
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|preblock
)paren
comma
op_minus
l_int|1
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If there are blocks not being freed at the end of the&n;&t; * old extent, add summary data for them to be allocated.&n;&t; */
r_if
c_cond
(paren
id|postblock
OG
id|end
)paren
(brace
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|XFS_RTBLOCKLOG
c_func
(paren
id|postblock
op_minus
id|end
)paren
comma
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|end
op_plus
l_int|1
)paren
comma
op_minus
l_int|1
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Increment the summary information corresponding to the entire&n;&t; * (new) free extent.&n;&t; */
id|error
op_assign
id|xfs_rtmodify_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|XFS_RTBLOCKLOG
c_func
(paren
id|postblock
op_plus
l_int|1
op_minus
id|preblock
)paren
comma
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|preblock
)paren
comma
l_int|1
comma
id|rbpp
comma
id|rsb
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Read and return the summary information for a given extent size,&n; * bitmap block combination.&n; * Keeps track of a current summary block, so we don&squot;t keep reading&n; * it from the buffer cache.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtget_summary
id|xfs_rtget_summary
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
r_int
id|log
comma
multiline_comment|/* log2 of extent size */
id|xfs_rtblock_t
id|bbno
comma
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
comma
multiline_comment|/* in/out: summary block number */
id|xfs_suminfo_t
op_star
id|sum
)paren
multiline_comment|/* out: summary info for this block */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for summary block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_fsblock_t
id|sb
suffix:semicolon
multiline_comment|/* summary fsblock */
r_int
id|so
suffix:semicolon
multiline_comment|/* index into the summary file */
id|xfs_suminfo_t
op_star
id|sp
suffix:semicolon
multiline_comment|/* pointer to returned data */
multiline_comment|/*&n;&t; * Compute entry number in the summary file.&n;&t; */
id|so
op_assign
id|XFS_SUMOFFS
c_func
(paren
id|mp
comma
id|log
comma
id|bbno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the block number in the summary file.&n;&t; */
id|sb
op_assign
id|XFS_SUMOFFSTOBLOCK
c_func
(paren
id|mp
comma
id|so
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have an old buffer, and the block number matches, use that.&n;&t; */
r_if
c_cond
(paren
id|rbpp
op_logical_and
op_star
id|rbpp
op_logical_and
op_star
id|rsb
op_eq
id|sb
)paren
id|bp
op_assign
op_star
id|rbpp
suffix:semicolon
multiline_comment|/*&n;&t; * Otherwise we have to get the buffer.&n;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t; * If there was an old one, get rid of it first.&n;&t;&t; */
r_if
c_cond
(paren
id|rbpp
op_logical_and
op_star
id|rbpp
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
op_star
id|rbpp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
id|sb
comma
l_int|1
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Remember this buffer and block for the next call.&n;&t;&t; */
r_if
c_cond
(paren
id|rbpp
)paren
(brace
op_star
id|rbpp
op_assign
id|bp
suffix:semicolon
op_star
id|rsb
op_assign
id|sb
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Point to the summary information &amp; copy it out.&n;&t; */
id|sp
op_assign
id|XFS_SUMPTR
c_func
(paren
id|mp
comma
id|bp
comma
id|so
)paren
suffix:semicolon
op_star
id|sum
op_assign
op_star
id|sp
suffix:semicolon
multiline_comment|/*&n;&t; * Drop the buffer if we&squot;re not asked to remember it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rbpp
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the given range of bitmap bits to the given value.&n; * Do whatever I/O and logging is required.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtmodify_range
id|xfs_rtmodify_range
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* starting block to modify */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent to modify */
r_int
id|val
)paren
multiline_comment|/* 1 for free, 0 for allocated */
(brace
id|xfs_rtword_t
op_star
id|b
suffix:semicolon
multiline_comment|/* current word in buffer */
r_int
id|bit
suffix:semicolon
multiline_comment|/* bit number in the word */
id|xfs_rtblock_t
id|block
suffix:semicolon
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buf for the block */
id|xfs_rtword_t
op_star
id|bufp
suffix:semicolon
multiline_comment|/* starting word in buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_rtword_t
op_star
id|first
suffix:semicolon
multiline_comment|/* first used word in the buffer */
r_int
id|i
suffix:semicolon
multiline_comment|/* current bit number rel. to start */
r_int
id|lastbit
suffix:semicolon
multiline_comment|/* last useful bit in word */
id|xfs_rtword_t
id|mask
suffix:semicolon
multiline_comment|/* mask o frelevant bits for value */
r_int
id|word
suffix:semicolon
multiline_comment|/* word number in the buffer */
multiline_comment|/*&n;&t; * Compute starting bitmap block number.&n;&t; */
id|block
op_assign
id|XFS_BITTOBLOCK
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the bitmap block, and point to its data.&n;&t; */
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the starting word&squot;s address, and starting bit.&n;&t; */
id|word
op_assign
id|XFS_BITTOWORD
c_func
(paren
id|mp
comma
id|start
)paren
suffix:semicolon
id|first
op_assign
id|b
op_assign
op_amp
id|bufp
(braket
id|word
)braket
suffix:semicolon
id|bit
op_assign
(paren
r_int
)paren
(paren
id|start
op_amp
(paren
id|XFS_NBWORD
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * 0 (allocated) =&gt; all zeroes; 1 (free) =&gt; all ones.&n;&t; */
id|val
op_assign
op_minus
id|val
suffix:semicolon
multiline_comment|/*&n;&t; * If not starting on a word boundary, deal with the first&n;&t; * (partial) word.&n;&t; */
r_if
c_cond
(paren
id|bit
)paren
(brace
multiline_comment|/*&n;&t;&t; * Compute first bit not changed and mask of relevant bits.&n;&t;&t; */
id|lastbit
op_assign
id|XFS_RTMIN
c_func
(paren
id|bit
op_plus
id|len
comma
id|XFS_NBWORD
)paren
suffix:semicolon
id|mask
op_assign
(paren
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
(paren
id|lastbit
op_minus
id|bit
)paren
)paren
op_minus
l_int|1
)paren
op_lshift
id|bit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set/clear the active bits.&n;&t;&t; */
r_if
c_cond
(paren
id|val
)paren
op_star
id|b
op_or_assign
id|mask
suffix:semicolon
r_else
op_star
id|b
op_and_assign
op_complement
id|mask
suffix:semicolon
id|i
op_assign
id|lastbit
op_minus
id|bit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to the next block if that&squot;s where the next word is&n;&t;&t; * and we need the next word.&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|word
op_eq
id|XFS_BLOCKWSIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Log the changed part of this block.&n;&t;&t;&t; * Get the next one.&n;&t;&t;&t; */
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|first
op_minus
(paren
r_char
op_star
)paren
id|bufp
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|b
op_minus
(paren
r_char
op_star
)paren
id|bufp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_increment
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|first
op_assign
id|b
op_assign
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the next word in the buffer&n;&t;&t;&t; */
id|b
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Starting on a word boundary, no partial word.&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop over whole words in buffers.  When we use up one buffer&n;&t; * we move on to the next one.&n;&t; */
r_while
c_loop
(paren
id|len
op_minus
id|i
op_ge
id|XFS_NBWORD
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set the word value correctly.&n;&t;&t; */
op_star
id|b
op_assign
id|val
suffix:semicolon
id|i
op_add_assign
id|XFS_NBWORD
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to the next block if that&squot;s where the next word is&n;&t;&t; * and we need the next word.&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|word
op_eq
id|XFS_BLOCKWSIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|i
OL
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Log the changed part of this block.&n;&t;&t;&t; * Get the next one.&n;&t;&t;&t; */
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|first
op_minus
(paren
r_char
op_star
)paren
id|bufp
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|b
op_minus
(paren
r_char
op_star
)paren
id|bufp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
op_increment
id|block
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|first
op_assign
id|b
op_assign
id|bufp
op_assign
(paren
id|xfs_rtword_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|word
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Go on to the next word in the buffer&n;&t;&t;&t; */
id|b
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If not ending on a word boundary, deal with the last&n;&t; * (partial) word.&n;&t; */
r_if
c_cond
(paren
(paren
id|lastbit
op_assign
id|len
op_minus
id|i
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Compute a mask of relevant bits.&n;&t;&t; */
id|bit
op_assign
l_int|0
suffix:semicolon
id|mask
op_assign
(paren
(paren
id|xfs_rtword_t
)paren
l_int|1
op_lshift
id|lastbit
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set/clear the active bits.&n;&t;&t; */
r_if
c_cond
(paren
id|val
)paren
op_star
id|b
op_or_assign
id|mask
suffix:semicolon
r_else
op_star
id|b
op_and_assign
op_complement
id|mask
suffix:semicolon
id|b
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Log any remaining changed bytes.&n;&t; */
r_if
c_cond
(paren
id|b
OG
id|first
)paren
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|first
op_minus
(paren
r_char
op_star
)paren
id|bufp
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|b
op_minus
(paren
r_char
op_star
)paren
id|bufp
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read and modify the summary information for a given extent size,&n; * bitmap block combination.&n; * Keeps track of a current summary block, so we don&squot;t keep reading&n; * it from the buffer cache.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_rtmodify_summary
id|xfs_rtmodify_summary
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
r_int
id|log
comma
multiline_comment|/* log2 of extent size */
id|xfs_rtblock_t
id|bbno
comma
multiline_comment|/* bitmap block number */
r_int
id|delta
comma
multiline_comment|/* change to make to summary info */
id|xfs_buf_t
op_star
op_star
id|rbpp
comma
multiline_comment|/* in/out: summary block buffer */
id|xfs_fsblock_t
op_star
id|rsb
)paren
multiline_comment|/* in/out: summary block number */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for the summary block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_fsblock_t
id|sb
suffix:semicolon
multiline_comment|/* summary fsblock */
r_int
id|so
suffix:semicolon
multiline_comment|/* index into the summary file */
id|xfs_suminfo_t
op_star
id|sp
suffix:semicolon
multiline_comment|/* pointer to returned data */
multiline_comment|/*&n;&t; * Compute entry number in the summary file.&n;&t; */
id|so
op_assign
id|XFS_SUMOFFS
c_func
(paren
id|mp
comma
id|log
comma
id|bbno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the block number in the summary file.&n;&t; */
id|sb
op_assign
id|XFS_SUMOFFSTOBLOCK
c_func
(paren
id|mp
comma
id|so
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have an old buffer, and the block number matches, use that.&n;&t; */
r_if
c_cond
(paren
id|rbpp
op_logical_and
op_star
id|rbpp
op_logical_and
op_star
id|rsb
op_eq
id|sb
)paren
id|bp
op_assign
op_star
id|rbpp
suffix:semicolon
multiline_comment|/*&n;&t; * Otherwise we have to get the buffer.&n;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t; * If there was an old one, get rid of it first.&n;&t;&t; */
r_if
c_cond
(paren
id|rbpp
op_logical_and
op_star
id|rbpp
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
op_star
id|rbpp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_rtbuf_get
c_func
(paren
id|mp
comma
id|tp
comma
id|sb
comma
l_int|1
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Remember this buffer and block for the next call.&n;&t;&t; */
r_if
c_cond
(paren
id|rbpp
)paren
(brace
op_star
id|rbpp
op_assign
id|bp
suffix:semicolon
op_star
id|rsb
op_assign
id|sb
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Point to the summary information, modify and log it.&n;&t; */
id|sp
op_assign
id|XFS_SUMPTR
c_func
(paren
id|mp
comma
id|bp
comma
id|so
)paren
suffix:semicolon
op_star
id|sp
op_add_assign
id|delta
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|sp
op_minus
(paren
r_char
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|sp
op_minus
(paren
r_char
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
op_plus
r_sizeof
(paren
op_star
id|sp
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Visible (exported) functions.&n; */
multiline_comment|/*&n; * Grow the realtime area of the filesystem.&n; */
r_int
DECL|function|xfs_growfs_rt
id|xfs_growfs_rt
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point for filesystem */
id|xfs_growfs_rt_t
op_star
id|in
)paren
multiline_comment|/* growfs rt input struct */
(brace
id|xfs_rtblock_t
id|bmbno
suffix:semicolon
multiline_comment|/* bitmap block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* temporary buffer */
r_int
id|cancelflags
suffix:semicolon
multiline_comment|/* flags for xfs_trans_cancel */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* bitmap inode, used as lock */
id|xfs_mount_t
op_star
id|nmp
suffix:semicolon
multiline_comment|/* new (fake) mount structure */
id|xfs_drfsbno_t
id|nrblocks
suffix:semicolon
multiline_comment|/* new number of realtime blocks */
id|xfs_extlen_t
id|nrbmblocks
suffix:semicolon
multiline_comment|/* new number of rt bitmap blocks */
id|xfs_drtbno_t
id|nrextents
suffix:semicolon
multiline_comment|/* new number of realtime extents */
r_uint8
id|nrextslog
suffix:semicolon
multiline_comment|/* new log2 of sb_rextents */
id|xfs_extlen_t
id|nrsumblocks
suffix:semicolon
multiline_comment|/* new number of summary blocks */
id|uint
id|nrsumlevels
suffix:semicolon
multiline_comment|/* new rt summary levels */
id|uint
id|nrsumsize
suffix:semicolon
multiline_comment|/* new size of rt summary, bytes */
id|xfs_sb_t
op_star
id|nsbp
suffix:semicolon
multiline_comment|/* new superblock */
id|xfs_extlen_t
id|rbmblocks
suffix:semicolon
multiline_comment|/* current number of rt bitmap blocks */
id|xfs_extlen_t
id|rsumblocks
suffix:semicolon
multiline_comment|/* current number of rt summary blks */
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
multiline_comment|/* old superblock */
id|xfs_fsblock_t
id|sumbno
suffix:semicolon
multiline_comment|/* summary block number */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|sbp
op_assign
op_amp
id|mp-&gt;m_sb
suffix:semicolon
multiline_comment|/*&n;&t; * Initial error checking.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_rtdev_targp
op_logical_or
id|mp-&gt;m_rbmip
op_eq
l_int|NULL
op_logical_or
(paren
id|nrblocks
op_assign
id|in-&gt;newblocks
)paren
op_le
id|sbp-&gt;sb_rblocks
op_logical_or
(paren
id|sbp-&gt;sb_rblocks
op_logical_and
(paren
id|in-&gt;extsize
op_ne
id|sbp-&gt;sb_rextsize
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read in the last block of the device, make sure it exists.&n;&t; */
id|error
op_assign
id|xfs_read_buf
c_func
(paren
id|mp
comma
id|mp-&gt;m_rtdev_targp
comma
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|in-&gt;newblocks
)paren
op_minus
l_int|1
comma
l_int|1
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate new parameters.  These are the final values to be reached.&n;&t; */
id|nrextents
op_assign
id|do_div
c_func
(paren
id|nrblocks
comma
id|in-&gt;extsize
)paren
suffix:semicolon
id|nrbmblocks
op_assign
id|roundup_64
c_func
(paren
id|nrextents
comma
id|NBBY
op_star
id|sbp-&gt;sb_blocksize
)paren
suffix:semicolon
id|nrextslog
op_assign
id|xfs_highbit32
c_func
(paren
id|nrextents
)paren
suffix:semicolon
id|nrsumlevels
op_assign
id|nrextslog
op_plus
l_int|1
suffix:semicolon
id|nrsumsize
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_suminfo_t
)paren
op_star
id|nrsumlevels
op_star
id|nrbmblocks
suffix:semicolon
id|nrsumblocks
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|nrsumsize
)paren
suffix:semicolon
id|nrsumsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|nrsumblocks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * New summary size can&squot;t be more than half the size of&n;&t; * the log.  This prevents us from getting a log overflow,&n;&t; * since we&squot;ll log basically the whole summary file at once.&n;&t; */
r_if
c_cond
(paren
id|nrsumblocks
OG
(paren
id|mp-&gt;m_sb.sb_logblocks
op_rshift
l_int|1
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the old block counts for bitmap and summary inodes.&n;&t; * These can&squot;t change since other growfs callers are locked out.&n;&t; */
id|rbmblocks
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|mp-&gt;m_rbmip-&gt;i_d.di_size
)paren
suffix:semicolon
id|rsumblocks
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|mp-&gt;m_rsumip-&gt;i_d.di_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space to the bitmap and summary files, as necessary.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_growfs_rt_alloc
c_func
(paren
id|mp
comma
id|rbmblocks
comma
id|nrbmblocks
comma
id|mp-&gt;m_sb.sb_rbmino
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_growfs_rt_alloc
c_func
(paren
id|mp
comma
id|rsumblocks
comma
id|nrsumblocks
comma
id|mp-&gt;m_sb.sb_rsumino
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|nmp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the bitmap blocks.&n;&t; * We will do everything one bitmap block at a time.&n;&t; * Skip the current block if it is exactly full.&n;&t; * This also deals with the case where there were no rtextents before.&n;&t; */
r_for
c_loop
(paren
id|bmbno
op_assign
id|sbp-&gt;sb_rbmblocks
op_minus
(paren
(paren
id|sbp-&gt;sb_rextents
op_amp
(paren
(paren
l_int|1
op_lshift
id|mp-&gt;m_blkbit_log
)paren
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|bmbno
OL
id|nrbmblocks
suffix:semicolon
id|bmbno
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Allocate a new (fake) mount/sb.&n;&t;&t; */
id|nmp
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|nmp
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
op_star
id|nmp
op_assign
op_star
id|mp
suffix:semicolon
id|nsbp
op_assign
op_amp
id|nmp-&gt;m_sb
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate new sb and mount fields for this round.&n;&t;&t; */
id|nsbp-&gt;sb_rextsize
op_assign
id|in-&gt;extsize
suffix:semicolon
id|nsbp-&gt;sb_rbmblocks
op_assign
id|bmbno
op_plus
l_int|1
suffix:semicolon
id|nsbp-&gt;sb_rblocks
op_assign
id|XFS_RTMIN
c_func
(paren
id|nrblocks
comma
id|nsbp-&gt;sb_rbmblocks
op_star
id|NBBY
op_star
id|nsbp-&gt;sb_blocksize
op_star
id|nsbp-&gt;sb_rextsize
)paren
suffix:semicolon
id|nsbp-&gt;sb_rextents
op_assign
id|do_div
c_func
(paren
id|nsbp-&gt;sb_rblocks
comma
id|nsbp-&gt;sb_rextsize
)paren
suffix:semicolon
id|nsbp-&gt;sb_rextslog
op_assign
id|xfs_highbit32
c_func
(paren
id|nsbp-&gt;sb_rextents
)paren
suffix:semicolon
id|nrsumlevels
op_assign
id|nmp-&gt;m_rsumlevels
op_assign
id|nsbp-&gt;sb_rextslog
op_plus
l_int|1
suffix:semicolon
id|nrsumsize
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_suminfo_t
)paren
op_star
id|nrsumlevels
op_star
id|nsbp-&gt;sb_rbmblocks
suffix:semicolon
id|nrsumblocks
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|nrsumsize
)paren
suffix:semicolon
id|nmp-&gt;m_rsumsize
op_assign
id|nrsumsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|nrsumblocks
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Start a transaction, get the log reservation.&n;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_GROWFSRT_FREE
)paren
suffix:semicolon
id|cancelflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_GROWRTFREE_LOG_RES
c_func
(paren
id|nmp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
r_goto
id|error_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Lock out other callers by grabbing the bitmap inode lock.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_sb.sb_rbmino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
)paren
)paren
r_goto
id|error_exit
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip
op_eq
id|mp-&gt;m_rbmip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the bitmap inode&squot;s size.&n;&t;&t; */
id|mp-&gt;m_rbmip-&gt;i_d.di_size
op_assign
id|nsbp-&gt;sb_rbmblocks
op_star
id|nsbp-&gt;sb_blocksize
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|mp-&gt;m_rbmip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|cancelflags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the summary inode into the transaction.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_sb.sb_rsumino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
)paren
)paren
r_goto
id|error_exit
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip
op_eq
id|mp-&gt;m_rsumip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the summary inode&squot;s size.&n;&t;&t; */
id|mp-&gt;m_rsumip-&gt;i_d.di_size
op_assign
id|nmp-&gt;m_rsumsize
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|mp-&gt;m_rsumip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Copy summary data from old to new sizes.&n;&t;&t; * Do this when the real size (not block-aligned) changes.&n;&t;&t; */
r_if
c_cond
(paren
id|sbp-&gt;sb_rbmblocks
op_ne
id|nsbp-&gt;sb_rbmblocks
op_logical_or
id|mp-&gt;m_rsumlevels
op_ne
id|nmp-&gt;m_rsumlevels
)paren
(brace
id|error
op_assign
id|xfs_rtcopy_summary
c_func
(paren
id|mp
comma
id|nmp
comma
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update superblock fields.&n;&t;&t; */
r_if
c_cond
(paren
id|nsbp-&gt;sb_rextsize
op_ne
id|sbp-&gt;sb_rextsize
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_REXTSIZE
comma
id|nsbp-&gt;sb_rextsize
op_minus
id|sbp-&gt;sb_rextsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsbp-&gt;sb_rbmblocks
op_ne
id|sbp-&gt;sb_rbmblocks
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_RBMBLOCKS
comma
id|nsbp-&gt;sb_rbmblocks
op_minus
id|sbp-&gt;sb_rbmblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsbp-&gt;sb_rblocks
op_ne
id|sbp-&gt;sb_rblocks
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_RBLOCKS
comma
id|nsbp-&gt;sb_rblocks
op_minus
id|sbp-&gt;sb_rblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsbp-&gt;sb_rextents
op_ne
id|sbp-&gt;sb_rextents
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_REXTENTS
comma
id|nsbp-&gt;sb_rextents
op_minus
id|sbp-&gt;sb_rextents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nsbp-&gt;sb_rextslog
op_ne
id|sbp-&gt;sb_rextslog
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_REXTSLOG
comma
id|nsbp-&gt;sb_rextslog
op_minus
id|sbp-&gt;sb_rextslog
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free new extent.&n;&t;&t; */
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|xfs_rtfree_range
c_func
(paren
id|nmp
comma
id|tp
comma
id|sbp-&gt;sb_rextents
comma
id|nsbp-&gt;sb_rextents
op_minus
id|sbp-&gt;sb_rextents
comma
op_amp
id|bp
comma
op_amp
id|sumbno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark more blocks free in the superblock.&n;&t;&t; */
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_FREXTENTS
comma
id|nsbp-&gt;sb_rextents
op_minus
id|sbp-&gt;sb_rextents
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free the fake mp structure.&n;&t;&t; */
id|kmem_free
c_func
(paren
id|nmp
comma
r_sizeof
(paren
op_star
id|nmp
)paren
)paren
suffix:semicolon
id|nmp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update mp values into the real mp structure.&n;&t;&t; */
id|mp-&gt;m_rsumlevels
op_assign
id|nrsumlevels
suffix:semicolon
id|mp-&gt;m_rsumsize
op_assign
id|nrsumsize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Commit the transaction.&n;&t;&t; */
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Error paths come here.&n;&t; */
id|error_exit
suffix:colon
r_if
c_cond
(paren
id|nmp
)paren
id|kmem_free
c_func
(paren
id|nmp
comma
r_sizeof
(paren
op_star
id|nmp
)paren
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancelflags
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate an extent in the realtime subvolume, with the usual allocation&n; * parameters.&t;The length units are all in realtime extents, as is the&n; * result block number.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_rtallocate_extent
id|xfs_rtallocate_extent
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|bno
comma
multiline_comment|/* starting block number to allocate */
id|xfs_extlen_t
id|minlen
comma
multiline_comment|/* minimum length to allocate */
id|xfs_extlen_t
id|maxlen
comma
multiline_comment|/* maximum length to allocate */
id|xfs_extlen_t
op_star
id|len
comma
multiline_comment|/* out: actual length allocated */
id|xfs_alloctype_t
id|type
comma
multiline_comment|/* allocation type XFS_ALLOCTYPE... */
r_int
id|wasdel
comma
multiline_comment|/* was a delayed allocation extent */
id|xfs_extlen_t
id|prod
comma
multiline_comment|/* extent product factor */
id|xfs_rtblock_t
op_star
id|rtblock
)paren
multiline_comment|/* out: start block allocated */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* inode for bitmap file */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount structure */
id|xfs_rtblock_t
id|r
suffix:semicolon
multiline_comment|/* result allocated block */
id|xfs_fsblock_t
id|sb
suffix:semicolon
multiline_comment|/* summary file block number */
id|xfs_buf_t
op_star
id|sumbp
suffix:semicolon
multiline_comment|/* summary file block buffer */
id|ASSERT
c_func
(paren
id|minlen
OG
l_int|0
op_logical_and
id|minlen
op_le
id|maxlen
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * If prod is set then figure out what to do to minlen and maxlen.&n;&t; */
r_if
c_cond
(paren
id|prod
OG
l_int|1
)paren
(brace
id|xfs_extlen_t
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|maxlen
op_mod
id|prod
)paren
)paren
id|maxlen
op_sub_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|minlen
op_mod
id|prod
)paren
)paren
id|minlen
op_add_assign
id|prod
op_minus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|maxlen
OL
id|minlen
)paren
(brace
op_star
id|rtblock
op_assign
id|NULLRTBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Lock out other callers by grabbing the bitmap inode lock.&n;&t; */
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_sb.sb_rbmino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|sumbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate by size, or near another block, or exactly at some block.&n;&t; */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|XFS_ALLOCTYPE_ANY_AG
suffix:colon
id|error
op_assign
id|xfs_rtallocate_extent_size
c_func
(paren
id|mp
comma
id|tp
comma
id|minlen
comma
id|maxlen
comma
id|len
comma
op_amp
id|sumbp
comma
op_amp
id|sb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:colon
id|error
op_assign
id|xfs_rtallocate_extent_near
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|minlen
comma
id|maxlen
comma
id|len
comma
op_amp
id|sumbp
comma
op_amp
id|sb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ALLOCTYPE_THIS_BNO
suffix:colon
id|error
op_assign
id|xfs_rtallocate_extent_exact
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|minlen
comma
id|maxlen
comma
id|len
comma
op_amp
id|sumbp
comma
op_amp
id|sb
comma
id|prod
comma
op_amp
id|r
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If it worked, update the superblock.&n;&t; */
r_if
c_cond
(paren
id|r
op_ne
id|NULLRTBLOCK
)paren
(brace
r_int
id|slen
op_assign
(paren
r_int
)paren
op_star
id|len
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|len
op_ge
id|minlen
op_logical_and
op_star
id|len
op_le
id|maxlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wasdel
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_RES_FREXTENTS
comma
op_minus
id|slen
)paren
suffix:semicolon
r_else
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_FREXTENTS
comma
op_minus
id|slen
)paren
suffix:semicolon
)brace
op_star
id|rtblock
op_assign
id|r
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Free an extent in the realtime subvolume.  Length is expressed in&n; * realtime extents, as is the block number.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_rtfree_extent
id|xfs_rtfree_extent
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|bno
comma
multiline_comment|/* starting block number to free */
id|xfs_extlen_t
id|len
)paren
multiline_comment|/* length of extent freed */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* bitmap file inode */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount structure */
id|xfs_fsblock_t
id|sb
suffix:semicolon
multiline_comment|/* summary file block number */
id|xfs_buf_t
op_star
id|sumbp
suffix:semicolon
multiline_comment|/* summary file block buffer */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * Synchronize by locking the bitmap inode.&n;&t; */
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_sb.sb_rbmino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#if defined(__KERNEL__) &amp;&amp; defined(DEBUG)
multiline_comment|/*&n;&t; * Check to see that this whole range is currently allocated.&n;&t; */
(brace
r_int
id|stat
suffix:semicolon
multiline_comment|/* result from checking range */
id|error
op_assign
id|xfs_rtcheck_alloc_range
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|len
comma
op_amp
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|stat
)paren
suffix:semicolon
)brace
macro_line|#endif
id|sumbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Free the range of realtime blocks.&n;&t; */
id|error
op_assign
id|xfs_rtfree_range
c_func
(paren
id|mp
comma
id|tp
comma
id|bno
comma
id|len
comma
op_amp
id|sumbp
comma
op_amp
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Mark more blocks free in the superblock.&n;&t; */
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_FREXTENTS
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;ve now freed all the blocks, reset the file sequence&n;&t; * number to 0.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_frextents_delta
op_plus
id|mp-&gt;m_sb.sb_frextents
op_eq
id|mp-&gt;m_sb.sb_rextents
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_NEWRTBM
)paren
)paren
id|ip-&gt;i_d.di_flags
op_or_assign
id|XFS_DIFLAG_NEWRTBM
suffix:semicolon
op_star
(paren
id|__uint64_t
op_star
)paren
op_amp
id|ip-&gt;i_d.di_atime
op_assign
l_int|0
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize realtime fields in the mount structure.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_rtmount_init
id|xfs_rtmount_init
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
multiline_comment|/* file system mount structure */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for last block of subvolume */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* address of last block of subvolume */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
multiline_comment|/* filesystem superblock copy in mount */
id|sbp
op_assign
op_amp
id|mp-&gt;m_sb
suffix:semicolon
r_if
c_cond
(paren
id|sbp-&gt;sb_rblocks
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rtdev_targp
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;XFS: This FS has an RT subvol - specify -o rtdev on mount&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENODEV
)paren
suffix:semicolon
)brace
id|mp-&gt;m_rsumlevels
op_assign
id|sbp-&gt;sb_rextslog
op_plus
l_int|1
suffix:semicolon
id|mp-&gt;m_rsumsize
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_suminfo_t
)paren
op_star
id|mp-&gt;m_rsumlevels
op_star
id|sbp-&gt;sb_rbmblocks
suffix:semicolon
id|mp-&gt;m_rsumsize
op_assign
id|roundup
c_func
(paren
id|mp-&gt;m_rsumsize
comma
id|sbp-&gt;sb_blocksize
)paren
suffix:semicolon
id|mp-&gt;m_rbmip
op_assign
id|mp-&gt;m_rsumip
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Check that the realtime section is an ok size.&n;&t; */
id|d
op_assign
(paren
id|xfs_daddr_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_sb.sb_rblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|d
)paren
op_ne
id|mp-&gt;m_sb.sb_rblocks
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;XFS: RT mount - %llu != %llu&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|d
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_rblocks
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|E2BIG
)paren
suffix:semicolon
)brace
id|error
op_assign
id|xfs_read_buf
c_func
(paren
id|mp
comma
id|mp-&gt;m_rtdev_targp
comma
id|d
op_minus
l_int|1
comma
l_int|1
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;XFS: RT mount - xfs_read_buf returned %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|E2BIG
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the bitmap and summary inodes into the mount structure&n; * at mount time.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_rtmount_inodes
id|xfs_rtmount_inodes
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
multiline_comment|/* file system mount structure */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
id|sbp
op_assign
op_amp
id|mp-&gt;m_sb
suffix:semicolon
r_if
c_cond
(paren
id|sbp-&gt;sb_rbmino
op_eq
id|NULLFSINO
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|sbp-&gt;sb_rbmino
comma
l_int|0
comma
op_amp
id|mp-&gt;m_rbmip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_rbmip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|sbp-&gt;sb_rsumino
op_ne
id|NULLFSINO
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|sbp-&gt;sb_rsumino
comma
l_int|0
comma
op_amp
id|mp-&gt;m_rsumip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|vnode_t
op_star
id|rbmvp
suffix:semicolon
multiline_comment|/* vnode for bitmap file */
id|vmap_t
id|vmap
suffix:semicolon
multiline_comment|/* vmap to delete vnode */
id|rbmvp
op_assign
id|XFS_ITOV
c_func
(paren
id|mp-&gt;m_rbmip
)paren
suffix:semicolon
id|VMAP
c_func
(paren
id|rbmvp
comma
id|mp-&gt;m_rbmip
comma
id|vmap
)paren
suffix:semicolon
id|VN_RELE
c_func
(paren
id|rbmvp
)paren
suffix:semicolon
id|vn_purge
c_func
(paren
id|rbmvp
comma
op_amp
id|vmap
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|mp-&gt;m_rsumip
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick an extent for allocation at the start of a new realtime file.&n; * Use the sequence number stored in the atime field of the bitmap inode.&n; * Translate this to a fraction of the rtextents, and return the product&n; * of rtextents and the fraction.&n; * The fraction sequence is 0, 1/2, 1/4, 3/4, 1/8, ..., 7/8, 1/16, ...&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_rtpick_extent
id|xfs_rtpick_extent
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* allocation length (rtextents) */
id|xfs_rtblock_t
op_star
id|pick
)paren
multiline_comment|/* result rt extent */
(brace
id|xfs_rtblock_t
id|b
suffix:semicolon
multiline_comment|/* result block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* bitmap incore inode */
r_int
id|log2
suffix:semicolon
multiline_comment|/* log of sequence number */
id|__uint64_t
id|resid
suffix:semicolon
multiline_comment|/* residual after log removed */
id|__uint64_t
id|seq
suffix:semicolon
multiline_comment|/* sequence number of file creation */
id|__uint64_t
op_star
id|seqp
suffix:semicolon
multiline_comment|/* pointer to seqno in inode */
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_sb.sb_rbmino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip
op_eq
id|mp-&gt;m_rbmip
)paren
suffix:semicolon
id|seqp
op_assign
(paren
id|__uint64_t
op_star
)paren
op_amp
id|ip-&gt;i_d.di_atime
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_NEWRTBM
)paren
)paren
(brace
id|ip-&gt;i_d.di_flags
op_or_assign
id|XFS_DIFLAG_NEWRTBM
suffix:semicolon
op_star
id|seqp
op_assign
l_int|0
suffix:semicolon
)brace
id|seq
op_assign
op_star
id|seqp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|log2
op_assign
id|xfs_highbit64
c_func
(paren
id|seq
)paren
)paren
op_eq
op_minus
l_int|1
)paren
id|b
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|resid
op_assign
id|seq
op_minus
(paren
l_int|1ULL
op_lshift
id|log2
)paren
suffix:semicolon
id|b
op_assign
(paren
id|mp-&gt;m_sb.sb_rextents
op_star
(paren
(paren
id|resid
op_lshift
l_int|1
)paren
op_plus
l_int|1ULL
)paren
)paren
op_rshift
(paren
id|log2
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_ge
id|mp-&gt;m_sb.sb_rextents
)paren
id|b
op_assign
id|do_mod
c_func
(paren
id|b
comma
id|mp-&gt;m_sb.sb_rextents
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_plus
id|len
OG
id|mp-&gt;m_sb.sb_rextents
)paren
id|b
op_assign
id|mp-&gt;m_sb.sb_rextents
op_minus
id|len
suffix:semicolon
)brace
op_star
id|seqp
op_assign
id|seq
op_plus
l_int|1
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
op_star
id|pick
op_assign
id|b
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Debug code: print out the value of a range in the bitmap.&n; */
r_void
DECL|function|xfs_rtprint_range
id|xfs_rtprint_range
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_rtblock_t
id|start
comma
multiline_comment|/* starting block to print */
id|xfs_extlen_t
id|len
)paren
multiline_comment|/* length to print */
(brace
id|xfs_extlen_t
id|i
suffix:semicolon
multiline_comment|/* block number in the extent */
id|printk
c_func
(paren
l_string|&quot;%Ld: &quot;
comma
(paren
r_int
r_int
)paren
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%d&quot;
comma
id|xfs_rtcheck_bit
c_func
(paren
id|mp
comma
id|tp
comma
id|start
op_plus
id|i
comma
l_int|1
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Debug code: print the summary file.&n; */
r_void
DECL|function|xfs_rtprint_summary
id|xfs_rtprint_summary
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
)paren
multiline_comment|/* transaction pointer */
(brace
id|xfs_suminfo_t
id|c
suffix:semicolon
multiline_comment|/* summary data */
id|xfs_rtblock_t
id|i
suffix:semicolon
multiline_comment|/* bitmap block number */
r_int
id|l
suffix:semicolon
multiline_comment|/* summary information level */
r_int
id|p
suffix:semicolon
multiline_comment|/* flag for printed anything */
id|xfs_fsblock_t
id|sb
suffix:semicolon
multiline_comment|/* summary block number */
id|xfs_buf_t
op_star
id|sumbp
suffix:semicolon
multiline_comment|/* summary block buffer */
id|sumbp
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|mp-&gt;m_rsumlevels
suffix:semicolon
id|l
op_increment
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;m_sb.sb_rbmblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
r_void
)paren
id|xfs_rtget_summary
c_func
(paren
id|mp
comma
id|tp
comma
id|l
comma
id|i
comma
op_amp
id|sumbp
comma
op_amp
id|sb
comma
op_amp
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%Ld-%Ld:&quot;
comma
l_int|1LL
op_lshift
id|l
comma
id|XFS_RTMIN
c_func
(paren
(paren
l_int|1LL
op_lshift
id|l
)paren
op_plus
(paren
(paren
l_int|1LL
op_lshift
id|l
)paren
op_minus
l_int|1LL
)paren
comma
id|mp-&gt;m_sb.sb_rextents
)paren
)paren
suffix:semicolon
id|p
op_assign
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %Ld:%d&quot;
comma
(paren
r_int
r_int
)paren
id|i
comma
id|c
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sumbp
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|sumbp
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
eof
