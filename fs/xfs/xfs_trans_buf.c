multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &lt;xfs.h&gt;
id|STATIC
id|xfs_buf_t
op_star
id|xfs_trans_buf_item_match
c_func
(paren
id|xfs_trans_t
op_star
comma
id|xfs_buftarg_t
op_star
comma
id|xfs_daddr_t
comma
r_int
)paren
suffix:semicolon
id|STATIC
id|xfs_buf_t
op_star
id|xfs_trans_buf_item_match_all
c_func
(paren
id|xfs_trans_t
op_star
comma
id|xfs_buftarg_t
op_star
comma
id|xfs_daddr_t
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Get and lock the buffer for the caller if it is not already&n; * locked within the given transaction.&t; If it is already locked&n; * within the transaction, just increment its lock recursion count&n; * and return a pointer to it.&n; *&n; * Use the fast path function xfs_trans_buf_item_match() or the buffer&n; * cache routine incore_match() to find the buffer&n; * if it is already owned by this transaction.&n; *&n; * If we don&squot;t already own the buffer, use get_buf() to get it.&n; * If it doesn&squot;t yet have an associated xfs_buf_log_item structure,&n; * then allocate one and add the item to this transaction.&n; *&n; * If the transaction pointer is NULL, make this just a normal&n; * get_buf() call.&n; */
id|xfs_buf_t
op_star
DECL|function|xfs_trans_get_buf
id|xfs_trans_get_buf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buftarg_t
op_star
id|target_dev
comma
id|xfs_daddr_t
id|blkno
comma
r_int
id|len
comma
id|uint
id|flags
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
)paren
id|flags
op_assign
id|XFS_BUF_LOCK
op_or
id|XFS_BUF_MAPPED
suffix:semicolon
multiline_comment|/*&n;&t; * Default to a normal get_buf() call if the tp is NULL.&n;&t; */
r_if
c_cond
(paren
id|tp
op_eq
l_int|NULL
)paren
(brace
id|bp
op_assign
id|xfs_buf_get_flags
c_func
(paren
id|target_dev
comma
id|blkno
comma
id|len
comma
id|flags
op_or
id|BUF_BUSY
)paren
suffix:semicolon
r_return
id|bp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we find the buffer in the cache with this transaction&n;&t; * pointer in its b_fsprivate2 field, then we know we already&n;&t; * have it locked.  In this case we just increment the lock&n;&t; * recursion count and return the buffer to the caller.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_items.lic_next
op_eq
l_int|NULL
)paren
(brace
id|bp
op_assign
id|xfs_trans_buf_item_match
c_func
(paren
id|tp
comma
id|target_dev
comma
id|blkno
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
id|xfs_trans_buf_item_match_all
c_func
(paren
id|tp
comma
id|target_dev
comma
id|blkno
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|tp-&gt;t_mountp
)paren
)paren
(brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;TRANS GET RECUR SHUT&quot;
comma
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SUPER_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the buffer is stale then it was binval&squot;ed&n;&t;&t; * since last read.  This doesn&squot;t matter since the&n;&t;&t; * caller isn&squot;t allowed to use the data anyway.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|XFS_BUF_ISSTALE
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;TRANS GET RECUR STALE&quot;
comma
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|bip-&gt;bli_recur
op_increment
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;TRANS GET RECUR&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;GET RECUR&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We always specify the BUF_BUSY flag within a transaction so&n;&t; * that get_buf does not try to push out a delayed write buffer&n;&t; * which might cause another transaction to take place (if the&n;&t; * buffer was delayed alloc).  Such recursive transactions can&n;&t; * easily deadlock with our current transaction as well as cause&n;&t; * us to run out of stack space.&n;&t; */
id|bp
op_assign
id|xfs_buf_get_flags
c_func
(paren
id|target_dev
comma
id|blkno
comma
id|len
comma
id|flags
op_or
id|BUF_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The xfs_buf_log_item pointer is stored in b_fsprivate.  If&n;&t; * it doesn&squot;t have one yet, then allocate one and initialize it.&n;&t; * The checks to see if one is there are in xfs_buf_item_init().&n;&t; */
id|xfs_buf_item_init
c_func
(paren
id|bp
comma
id|tp-&gt;t_mountp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the recursion count for the buffer within this transaction&n;&t; * to 0.&n;&t; */
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_recur
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Take a reference for this transaction on the buf item.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get a log_item_desc to point at the new item.&n;&t; */
(paren
r_void
)paren
id|xfs_trans_add_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize b_fsprivate2 so we can find it with incore_match()&n;&t; * above.&n;&t; */
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
id|tp
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;TRANS GET&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;GET&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get and lock the superblock buffer of this file system for the&n; * given transaction.&n; *&n; * We don&squot;t need to use incore_match() here, because the superblock&n; * buffer is a private buffer which we keep a pointer to in the&n; * mount structure.&n; */
id|xfs_buf_t
op_star
DECL|function|xfs_trans_getsb
id|xfs_trans_getsb
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
r_struct
id|xfs_mount
op_star
id|mp
comma
r_int
id|flags
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
multiline_comment|/*&n;&t; * Default to just trying to lock the superblock buffer&n;&t; * if tp is NULL.&n;&t; */
r_if
c_cond
(paren
id|tp
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
id|xfs_getsb
c_func
(paren
id|mp
comma
id|flags
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the superblock buffer already has this transaction&n;&t; * pointer in its b_fsprivate2 field, then we know we already&n;&t; * have it locked.  In this case we just increment the lock&n;&t; * recursion count and return the buffer to the caller.&n;&t; */
id|bp
op_assign
id|mp-&gt;m_sb_bp
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
(brace
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|bip-&gt;bli_recur
op_increment
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;GETSB RECUR&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
id|bp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The xfs_buf_log_item pointer is stored in b_fsprivate.  If&n;&t; * it doesn&squot;t have one yet, then allocate one and initialize it.&n;&t; * The checks to see if one is there are in xfs_buf_item_init().&n;&t; */
id|xfs_buf_item_init
c_func
(paren
id|bp
comma
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the recursion count for the buffer within this transaction&n;&t; * to 0.&n;&t; */
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_recur
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Take a reference for this transaction on the buf item.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get a log_item_desc to point at the new item.&n;&t; */
(paren
r_void
)paren
id|xfs_trans_add_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize b_fsprivate2 so we can find it with incore_match()&n;&t; * above.&n;&t; */
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
id|tp
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;GETSB&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
DECL|variable|xfs_error_dev
id|dev_t
id|xfs_error_dev
op_assign
l_int|0
suffix:semicolon
DECL|variable|xfs_do_error
r_int
id|xfs_do_error
suffix:semicolon
DECL|variable|xfs_req_num
r_int
id|xfs_req_num
suffix:semicolon
DECL|variable|xfs_error_mod
r_int
id|xfs_error_mod
op_assign
l_int|33
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Get and lock the buffer for the caller if it is not already&n; * locked within the given transaction.&t; If it has not yet been&n; * read in, read it from disk. If it is already locked&n; * within the transaction and already read in, just increment its&n; * lock recursion count and return a pointer to it.&n; *&n; * Use the fast path function xfs_trans_buf_item_match() or the buffer&n; * cache routine incore_match() to find the buffer&n; * if it is already owned by this transaction.&n; *&n; * If we don&squot;t already own the buffer, use read_buf() to get it.&n; * If it doesn&squot;t yet have an associated xfs_buf_log_item structure,&n; * then allocate one and add the item to this transaction.&n; *&n; * If the transaction pointer is NULL, make this just a normal&n; * read_buf() call.&n; */
r_int
DECL|function|xfs_trans_read_buf
id|xfs_trans_read_buf
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buftarg_t
op_star
id|target
comma
id|xfs_daddr_t
id|blkno
comma
r_int
id|len
comma
id|uint
id|flags
comma
id|xfs_buf_t
op_star
op_star
id|bpp
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
)paren
id|flags
op_assign
id|XFS_BUF_LOCK
op_or
id|XFS_BUF_MAPPED
suffix:semicolon
multiline_comment|/*&n;&t; * Default to a normal get_buf() call if the tp is NULL.&n;&t; */
r_if
c_cond
(paren
id|tp
op_eq
l_int|NULL
)paren
(brace
id|bp
op_assign
id|xfs_buf_read_flags
c_func
(paren
id|target
comma
id|blkno
comma
id|len
comma
id|flags
op_or
id|BUF_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xfs_trans_read_buf&quot;
comma
id|mp
comma
id|bp
comma
id|blkno
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|xfs_do_error
op_logical_and
(paren
id|bp
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_error_dev
op_eq
id|target-&gt;pbr_dev
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|xfs_req_num
op_increment
)paren
op_mod
id|xfs_error_mod
)paren
op_eq
l_int|0
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Returning error!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_goto
id|shutdown_abort
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we find the buffer in the cache with this transaction&n;&t; * pointer in its b_fsprivate2 field, then we know we already&n;&t; * have it locked.  If it is already read in we just increment&n;&t; * the lock recursion count and return the buffer to the caller.&n;&t; * If the buffer is not yet read in, then we read it in, increment&n;&t; * the lock recursion count, and return it to the caller.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_items.lic_next
op_eq
l_int|NULL
)paren
(brace
id|bp
op_assign
id|xfs_trans_buf_item_match
c_func
(paren
id|tp
comma
id|target
comma
id|blkno
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
id|xfs_trans_buf_item_match_all
c_func
(paren
id|tp
comma
id|target
comma
id|blkno
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|XFS_BUF_ISERROR
c_func
(paren
id|bp
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_BUF_ISDONE
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;READ_BUF_INCORE !DONE&quot;
comma
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_ISASYNC
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|XFS_BUF_READ
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfsbdstrat
c_func
(paren
id|tp-&gt;t_mountp
comma
id|bp
)paren
suffix:semicolon
id|xfs_iowait
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
op_ne
l_int|0
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xfs_trans_read_buf&quot;
comma
id|mp
comma
id|bp
comma
id|blkno
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We can gracefully recover from most&n;&t;&t;&t;&t; * read errors. Ones we can&squot;t are those&n;&t;&t;&t;&t; * that happen after the transaction&squot;s&n;&t;&t;&t;&t; * already dirty.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DIRTY
)paren
id|xfs_force_shutdown
c_func
(paren
id|tp-&gt;t_mountp
comma
id|XFS_METADATA_IO_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * We never locked this buf ourselves, so we shouldn&squot;t&n;&t;&t; * brelse it either. Just get out.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;READ_BUF_INCORE XFSSHUTDN&quot;
comma
id|bp
)paren
suffix:semicolon
op_star
id|bpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|bip-&gt;bli_recur
op_increment
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;READ RECUR&quot;
comma
id|bip
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We always specify the BUF_BUSY flag within a transaction so&n;&t; * that get_buf does not try to push out a delayed write buffer&n;&t; * which might cause another transaction to take place (if the&n;&t; * buffer was delayed alloc).  Such recursive transactions can&n;&t; * easily deadlock with our current transaction as well as cause&n;&t; * us to run out of stack space.&n;&t; */
id|bp
op_assign
id|xfs_buf_read_flags
c_func
(paren
id|target
comma
id|blkno
comma
id|len
comma
id|flags
op_or
id|BUF_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
(brace
op_star
id|bpp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
op_ne
l_int|0
)paren
(brace
id|XFS_BUF_SUPER_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;READ ERROR&quot;
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xfs_trans_read_buf&quot;
comma
id|mp
comma
id|bp
comma
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DIRTY
)paren
id|xfs_force_shutdown
c_func
(paren
id|tp-&gt;t_mountp
comma
id|XFS_METADATA_IO_ERROR
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|xfs_do_error
op_logical_and
op_logical_neg
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DIRTY
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_error_dev
op_eq
id|target-&gt;pbr_dev
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|xfs_req_num
op_increment
)paren
op_mod
id|xfs_error_mod
)paren
op_eq
l_int|0
)paren
(brace
id|xfs_force_shutdown
c_func
(paren
id|tp-&gt;t_mountp
comma
id|XFS_METADATA_IO_ERROR
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Returning error in trans!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_goto
id|shutdown_abort
suffix:semicolon
multiline_comment|/*&n;&t; * The xfs_buf_log_item pointer is stored in b_fsprivate.  If&n;&t; * it doesn&squot;t have one yet, then allocate one and initialize it.&n;&t; * The checks to see if one is there are in xfs_buf_item_init().&n;&t; */
id|xfs_buf_item_init
c_func
(paren
id|bp
comma
id|tp-&gt;t_mountp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the recursion count for the buffer within this transaction&n;&t; * to 0.&n;&t; */
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_recur
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Take a reference for this transaction on the buf item.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get a log_item_desc to point at the new item.&n;&t; */
(paren
r_void
)paren
id|xfs_trans_add_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize b_fsprivate2 so we can find it with incore_match()&n;&t; * above.&n;&t; */
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
id|tp
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;TRANS READ&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;READ&quot;
comma
id|bip
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|shutdown_abort
suffix:colon
multiline_comment|/*&n;&t; * the theory here is that buffer is good but we&squot;re&n;&t; * bailing out because the filesystem is being forcibly&n;&t; * shut down.  So we should leave the b_flags alone since&n;&t; * the buffer&squot;s not staled and just get out.&n;&t; */
macro_line|#if defined(DEBUG)
r_if
c_cond
(paren
id|XFS_BUF_ISSTALE
c_func
(paren
id|bp
)paren
op_logical_and
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;about to pop assert, bp == 0x%p&quot;
comma
id|bp
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
(paren
id|XFS_BUF_BFLAGS
c_func
(paren
id|bp
)paren
op_amp
(paren
id|XFS_B_STALE
op_or
id|XFS_B_DELWRI
)paren
)paren
op_ne
(paren
id|XFS_B_STALE
op_or
id|XFS_B_DELWRI
)paren
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;READ_BUF XFSSHUTDN&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
op_star
id|bpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the buffer bp which was previously acquired with one of the&n; * xfs_trans_... buffer allocation routines if the buffer has not&n; * been modified within this transaction.  If the buffer is modified&n; * within this transaction, do decrement the recursion count but do&n; * not release the buffer even if the count goes to 0.&t;If the buffer is not&n; * modified within the transaction, decrement the recursion count and&n; * release the buffer if the recursion count goes to 0.&n; *&n; * If the buffer is to be released and it was not modified before&n; * this transaction began, then free the buf_log_item associated with it.&n; *&n; * If the transaction pointer is NULL, make this just a normal&n; * brelse() call.&n; */
r_void
DECL|function|xfs_trans_brelse
id|xfs_trans_brelse
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
multiline_comment|/*&n;&t; * Default to a normal brelse() call if the tp is NULL.&n;&t; */
r_if
c_cond
(paren
id|tp
op_eq
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there&squot;s a buf log item attached to the buffer,&n;&t;&t; * then let the AIL know that the buffer is being&n;&t;&t; * unlocked.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
(brace
id|lip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_log_item_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lip-&gt;li_type
op_eq
id|XFS_LI_BUF
)paren
(brace
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|xfs_trans_unlocked_item
c_func
(paren
id|bip-&gt;bli_item.li_mountp
comma
id|lip
)paren
suffix:semicolon
)brace
)brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_item.li_type
op_eq
id|XFS_LI_BUF
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the item descriptor pointing to this buffer&squot;s&n;&t; * log item.  It must be there.&n;&t; */
id|lidp
op_assign
id|xfs_trans_find_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lidp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the release is just for a recursive lock,&n;&t; * then decrement the count and return.&n;&t; */
r_if
c_cond
(paren
id|bip-&gt;bli_recur
OG
l_int|0
)paren
(brace
id|bip-&gt;bli_recur
op_decrement
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;RELSE RECUR&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the buffer is dirty within this transaction, we can&squot;t&n;&t; * release it until we commit.&n;&t; */
r_if
c_cond
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_DIRTY
)paren
(brace
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;RELSE DIRTY&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the buffer has been invalidated, then we can&squot;t release&n;&t; * it until the transaction commits to disk unless it is re-dirtied&n;&t; * as part of this transaction.&t; This prevents us from pulling&n;&t; * the item from the AIL before we should.&n;&t; */
r_if
c_cond
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
(brace
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;RELSE STALE&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;RELSE&quot;
comma
id|bip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free up the log item descriptor tracking the released item.&n;&t; */
id|xfs_trans_free_item
c_func
(paren
id|tp
comma
id|lidp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the hold flag in the buf log item if it is set.&n;&t; * We wouldn&squot;t want the next user of the buffer to&n;&t; * get confused.&n;&t; */
r_if
c_cond
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_HOLD
)paren
(brace
id|bip-&gt;bli_flags
op_and_assign
op_complement
id|XFS_BLI_HOLD
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Drop our reference to the buf log item.&n;&t; */
id|atomic_dec
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the buf item is not tracking data in the log, then&n;&t; * we must free it before releasing the buffer back to the&n;&t; * free pool.  Before releasing the buffer to the free pool,&n;&t; * clear the transaction pointer in b_fsprivate2 to dissolve&n;&t; * its relation to this transaction.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_buf_item_dirty
c_func
(paren
id|bip
)paren
)paren
(brace
multiline_comment|/***&n;&t;&t;ASSERT(bp-&gt;b_pincount == 0);&n;***/
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_INODE_ALLOC_BUF
)paren
)paren
suffix:semicolon
id|xfs_buf_item_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|bip
op_assign
l_int|NULL
suffix:semicolon
)brace
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;ve still got a buf log item on the buffer, then&n;&t; * tell the AIL that the buffer is being unlocked.&n;&t; */
r_if
c_cond
(paren
id|bip
op_ne
l_int|NULL
)paren
(brace
id|xfs_trans_unlocked_item
c_func
(paren
id|bip-&gt;bli_item.li_mountp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
)brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the locked buffer to the transaction.&n; * The buffer must be locked, and it cannot be associated with any&n; * transaction.&n; *&n; * If the buffer does not yet have a buf log item associated with it,&n; * then allocate one for it.  Then add the buf item to the transaction.&n; */
r_void
DECL|function|xfs_trans_bjoin
id|xfs_trans_bjoin
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The xfs_buf_log_item pointer is stored in b_fsprivate.  If&n;&t; * it doesn&squot;t have one yet, then allocate one and initialize it.&n;&t; * The checks to see if one is there are in xfs_buf_item_init().&n;&t; */
id|xfs_buf_item_init
c_func
(paren
id|bp
comma
id|tp-&gt;t_mountp
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Take a reference for this transaction on the buf item.&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get a log_item_desc to point at the new item.&n;&t; */
(paren
r_void
)paren
id|xfs_trans_add_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize b_fsprivate2 so we can find it with incore_match()&n;&t; * in xfs_trans_get_buf() and friends above.&n;&t; */
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
id|tp
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;BJOIN&quot;
comma
id|bip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mark the buffer as not needing to be unlocked when the buf item&squot;s&n; * IOP_UNLOCK() routine is called.  The buffer must already be locked&n; * and associated with the given transaction.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_trans_bhold
id|xfs_trans_bhold
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|bip-&gt;bli_flags
op_or_assign
id|XFS_BLI_HOLD
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;BHOLD&quot;
comma
id|bip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is used to indicate that the buffer should not be&n; * unlocked until the transaction is committed to disk.&t; Since we&n; * are going to keep the lock held, make the transaction synchronous&n; * so that the lock is not held too long.&n; *&n; * It uses the log item descriptor flag XFS_LID_SYNC_UNLOCK to&n; * delay the buf items&squot;s unlock call until the transaction is&n; * committed to disk or aborted.&n; */
r_void
DECL|function|xfs_trans_bhold_until_committed
id|xfs_trans_bhold_until_committed
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|lidp
op_assign
id|xfs_trans_find_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lidp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|lidp-&gt;lid_flags
op_or_assign
id|XFS_LID_SYNC_UNLOCK
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;BHOLD UNTIL COMMIT&quot;
comma
id|bip
)paren
suffix:semicolon
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to mark bytes first through last inclusive of the given&n; * buffer as needing to be logged when the transaction is committed.&n; * The buffer must already be associated with the given transaction.&n; *&n; * First and last are numbers relative to the beginning of this buffer,&n; * so the first byte in the buffer is numbered 0 regardless of the&n; * value of b_blkno.&n; */
r_void
DECL|function|xfs_trans_log_buf
id|xfs_trans_log_buf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
comma
id|uint
id|first
comma
id|uint
id|last
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|first
op_le
id|last
)paren
op_logical_and
(paren
id|last
OL
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_eq
id|xfs_buf_iodone_callbacks
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the buffer as needing to be written out eventually,&n;&t; * and set its iodone function to remove the buffer&squot;s buf log&n;&t; * item from the AIL and free it when the buffer is flushed&n;&t; * to disk.  See xfs_buf_attach_iodone() for more details&n;&t; * on li_cb and xfs_buf_iodone_callbacks().&n;&t; * If we end up aborting this transaction, we trap this buffer&n;&t; * inside the b_bdstrat callback so that this won&squot;t get written to&n;&t; * disk.&n;&t; */
id|XFS_BUF_DELAYWRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_DONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|bp
comma
id|xfs_buf_iodone_callbacks
)paren
suffix:semicolon
id|bip-&gt;bli_item.li_cb
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_buf_t
op_star
comma
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_buf_iodone
suffix:semicolon
multiline_comment|/*&n;&t; * If we invalidated the buffer within this transaction, then&n;&t; * cancel the invalidation now that we&squot;re dirtying the buffer&n;&t; * again.  There are no races with the code in xfs_buf_item_unpin(),&n;&t; * because we have a reference to the buffer this entire time.&n;&t; */
r_if
c_cond
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
(brace
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;BLOG UNSTALE&quot;
comma
id|bip
)paren
suffix:semicolon
id|bip-&gt;bli_flags
op_and_assign
op_complement
id|XFS_BLI_STALE
suffix:semicolon
multiline_comment|/* note this will have to change for page_buf interface... unstale isn&squot;t really an option RMC */
id|ASSERT
c_func
(paren
id|XFS_BUF_ISSTALE
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|XFS_BUF_UNSTALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|bip-&gt;bli_format.blf_flags
op_and_assign
op_complement
id|XFS_BLI_CANCEL
suffix:semicolon
)brace
id|lidp
op_assign
id|xfs_trans_find_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lidp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|tp-&gt;t_flags
op_or_assign
id|XFS_TRANS_DIRTY
suffix:semicolon
id|lidp-&gt;lid_flags
op_or_assign
id|XFS_LID_DIRTY
suffix:semicolon
id|lidp-&gt;lid_flags
op_and_assign
op_complement
id|XFS_LID_BUF_STALE
suffix:semicolon
id|bip-&gt;bli_flags
op_or_assign
id|XFS_BLI_LOGGED
suffix:semicolon
id|xfs_buf_item_log
c_func
(paren
id|bip
comma
id|first
comma
id|last
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;BLOG&quot;
comma
id|bip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This called to invalidate a buffer that is being used within&n; * a transaction.  Typically this is because the blocks in the&n; * buffer are being freed, so we need to prevent it from being&n; * written out when we&squot;re done.&t; Allowing it to be written again&n; * might overwrite data in the free blocks if they are reallocated&n; * to a file.&n; *&n; * We prevent the buffer from being written out by clearing the&n; * B_DELWRI flag.  We can&squot;t always&n; * get rid of the buf log item at this point, though, because&n; * the buffer may still be pinned by another transaction.  If that&n; * is the case, then we&squot;ll wait until the buffer is committed to&n; * disk for the last time (we can tell by the ref count) and&n; * free it in xfs_buf_item_unpin().  Until it is cleaned up we&n; * will keep the buffer locked so that the buffer and buf log item&n; * are not reused.&n; */
r_void
DECL|function|xfs_trans_binval
id|xfs_trans_binval
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|lidp
op_assign
id|xfs_trans_find_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lidp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the buffer is already invalidated, then&n;&t;&t; * just return.&n;&t;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISSTALE
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
(paren
id|XFS_BLI_LOGGED
op_or
id|XFS_BLI_DIRTY
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_INODE_BUF
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_DIRTY
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DIRTY
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_BINVAL RECUR&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;BINVAL RECUR&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clear the dirty bit in the buffer and set the STALE flag&n;&t; * in the buf log item.&t; The STALE flag will be used in&n;&t; * xfs_buf_item_unpin() to determine if it should clean up&n;&t; * when the last reference to the buf item is given up.&n;&t; * We set the XFS_BLI_CANCEL flag in the buf log format structure&n;&t; * and log the buf item.  This will be used at recovery time&n;&t; * to determine that copies of the buffer in the log before&n;&t; * this should not be replayed.&n;&t; * We mark the item descriptor and the transaction dirty so&n;&t; * that we&squot;ll hold the buffer until after the commit.&n;&t; *&n;&t; * Since we&squot;re invalidating the buffer, we also clear the state&n;&t; * about which parts of the buffer have been logged.  We also&n;&t; * clear the flag indicating that this is an inode buffer since&n;&t; * the data in the buffer will no longer be valid.&n;&t; *&n;&t; * We set the stale bit in the buffer as well since we&squot;re getting&n;&t; * rid of it.&n;&t; */
id|XFS_BUF_UNDELAYWRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|bip-&gt;bli_flags
op_or_assign
id|XFS_BLI_STALE
suffix:semicolon
id|bip-&gt;bli_flags
op_and_assign
op_complement
(paren
id|XFS_BLI_LOGGED
op_or
id|XFS_BLI_DIRTY
)paren
suffix:semicolon
id|bip-&gt;bli_format.blf_flags
op_and_assign
op_complement
id|XFS_BLI_INODE_BUF
suffix:semicolon
id|bip-&gt;bli_format.blf_flags
op_or_assign
id|XFS_BLI_CANCEL
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|bip-&gt;bli_format.blf_data_map
)paren
comma
l_int|0
comma
(paren
id|bip-&gt;bli_format.blf_map_size
op_star
r_sizeof
(paren
id|uint
)paren
)paren
)paren
suffix:semicolon
id|lidp-&gt;lid_flags
op_or_assign
id|XFS_LID_DIRTY
op_or
id|XFS_LID_BUF_STALE
suffix:semicolon
id|tp-&gt;t_flags
op_or_assign
id|XFS_TRANS_DIRTY
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_BINVAL&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;BINVAL&quot;
comma
id|bip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This call is used to indicate that the buffer contains on-disk&n; * inodes which must be handled specially during recovery.  They&n; * require special handling because only the di_next_unlinked from&n; * the inodes in the buffer should be recovered.  The rest of the&n; * data in the buffer is logged via the inodes themselves.&n; *&n; * All we do is set the XFS_BLI_INODE_BUF flag in the buffer&squot;s log&n; * format structure so that we&squot;ll know what to do at recovery time.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_trans_inode_buf
id|xfs_trans_inode_buf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|bip-&gt;bli_format.blf_flags
op_or_assign
id|XFS_BLI_INODE_BUF
suffix:semicolon
)brace
multiline_comment|/*&n; * Mark the buffer as being one which contains newly allocated&n; * inodes.  We need to make sure that even if this buffer is&n; * relogged as an &squot;inode buf&squot; we still recover all of the inode&n; * images in the face of a crash.  This works in coordination with&n; * xfs_buf_item_committed() to ensure that the buffer remains in the&n; * AIL at its original location even after it has been relogged.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_trans_inode_alloc_buf
id|xfs_trans_inode_alloc_buf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_INODE_ALLOC_BUF
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_flags
op_or_assign
id|XFS_BLI_INODE_ALLOC_BUF
suffix:semicolon
)brace
multiline_comment|/*&n; * Similar to xfs_trans_inode_buf(), this marks the buffer as a cluster of&n; * dquots. However, unlike in inode buffer recovery, dquot buffers get&n; * recovered in their entirety. (Hence, no XFS_BLI_DQUOT_ALLOC_BUF flag).&n; * The only thing that makes dquot buffers different from regular&n; * buffers is that we must not replay dquot bufs when recovering&n; * if a _corresponding_ quotaoff has happened. We also have to distinguish&n; * between usr dquot bufs and grp dquot bufs, because usr and grp quotas&n; * can be turned off independently.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_trans_dquot_buf
id|xfs_trans_dquot_buf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buf_t
op_star
id|bp
comma
id|uint
id|type
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
id|xfs_trans_t
op_star
)paren
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|type
op_eq
id|XFS_BLI_UDQUOT_BUF
op_logical_or
id|type
op_eq
id|XFS_BLI_GDQUOT_BUF
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|bip-&gt;bli_format.blf_flags
op_or_assign
id|type
suffix:semicolon
)brace
multiline_comment|/*&n; * Check to see if a buffer matching the given parameters is already&n; * a part of the given transaction.  Only check the first, embedded&n; * chunk, since we don&squot;t want to spend all day scanning large transactions.&n; */
id|STATIC
id|xfs_buf_t
op_star
DECL|function|xfs_trans_buf_item_match
id|xfs_trans_buf_item_match
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buftarg_t
op_star
id|target
comma
id|xfs_daddr_t
id|blkno
comma
r_int
id|len
)paren
(brace
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|blip
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|len
op_assign
id|BBTOB
c_func
(paren
id|len
)paren
suffix:semicolon
id|licp
op_assign
op_amp
id|tp-&gt;t_items
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Skip unoccupied slots.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|lidp
op_assign
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
suffix:semicolon
id|blip
op_assign
(paren
id|xfs_buf_log_item_t
op_star
)paren
id|lidp-&gt;lid_item
suffix:semicolon
r_if
c_cond
(paren
id|blip-&gt;bli_item.li_type
op_ne
id|XFS_LI_BUF
)paren
(brace
r_continue
suffix:semicolon
)brace
id|bp
op_assign
id|blip-&gt;bli_buf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|XFS_BUF_TARGET
c_func
(paren
id|bp
)paren
op_eq
id|target
)paren
op_logical_and
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_eq
id|blkno
)paren
op_logical_and
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_eq
id|len
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We found it.&t; Break out and&n;&t;&t;&t;&t; * return the pointer to the buffer.&n;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_return
id|bp
suffix:semicolon
)brace
multiline_comment|/*&n; * Check to see if a buffer matching the given parameters is already&n; * a part of the given transaction.  Check all the chunks, we&n; * want to be thorough.&n; */
id|STATIC
id|xfs_buf_t
op_star
DECL|function|xfs_trans_buf_item_match_all
id|xfs_trans_buf_item_match_all
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_buftarg_t
op_star
id|target
comma
id|xfs_daddr_t
id|blkno
comma
r_int
id|len
)paren
(brace
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|blip
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|len
op_assign
id|BBTOB
c_func
(paren
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|licp
op_assign
op_amp
id|tp-&gt;t_items
suffix:semicolon
id|licp
op_ne
l_int|NULL
suffix:semicolon
id|licp
op_assign
id|licp-&gt;lic_next
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|licp
op_eq
op_amp
id|tp-&gt;t_items
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|licp-&gt;lic_next
op_eq
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Skip unoccupied slots.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|lidp
op_assign
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
suffix:semicolon
id|blip
op_assign
(paren
id|xfs_buf_log_item_t
op_star
)paren
id|lidp-&gt;lid_item
suffix:semicolon
r_if
c_cond
(paren
id|blip-&gt;bli_item.li_type
op_ne
id|XFS_LI_BUF
)paren
(brace
r_continue
suffix:semicolon
)brace
id|bp
op_assign
id|blip-&gt;bli_buf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|XFS_BUF_TARGET
c_func
(paren
id|bp
)paren
op_eq
id|target
)paren
op_logical_and
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_eq
id|blkno
)paren
op_logical_and
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_eq
id|len
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We found it.&t; Break out and&n;&t;&t;&t;&t; * return the pointer to the buffer.&n;&t;&t;&t;&t; */
r_return
id|bp
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
eof
