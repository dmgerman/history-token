multiline_comment|/*&n; * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; *&t;The xfs_buf.c code provides an abstract buffer cache model on top&n; *&t;of the Linux page cache.  Cached metadata blocks for a file system&n; *&t;are hashed to the inode for the block device.  xfs_buf.c assembles&n; *&t;buffers (xfs_buf_t) on demand to aggregate such cached pages for I/O.&n; *&n; *      Written by Steve Lord, Jim Mostek, Russell Cattelan&n; *&t;&t;    and Rajagopal Ananthanarayanan (&quot;ananth&quot;) at SGI.&n; *&n; */
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/percpu.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
macro_line|#include &quot;xfs_linux.h&quot;
multiline_comment|/*&n; * File wide globals&n; */
DECL|variable|pagebuf_cache
id|STATIC
id|kmem_cache_t
op_star
id|pagebuf_cache
suffix:semicolon
DECL|variable|pagebuf_shake
id|STATIC
id|kmem_shaker_t
id|pagebuf_shake
suffix:semicolon
id|STATIC
r_int
id|pagebuf_daemon_wakeup
c_func
(paren
r_int
comma
r_int
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|pagebuf_delwri_queue
c_func
(paren
id|xfs_buf_t
op_star
comma
r_int
)paren
suffix:semicolon
DECL|variable|pagebuf_logio_workqueue
id|STATIC
r_struct
id|workqueue_struct
op_star
id|pagebuf_logio_workqueue
suffix:semicolon
DECL|variable|pagebuf_dataio_workqueue
id|STATIC
r_struct
id|workqueue_struct
op_star
id|pagebuf_dataio_workqueue
suffix:semicolon
multiline_comment|/*&n; * Pagebuf debugging&n; */
macro_line|#ifdef PAGEBUF_TRACE
r_void
DECL|function|pagebuf_trace
id|pagebuf_trace
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
r_char
op_star
id|id
comma
r_void
op_star
id|data
comma
r_void
op_star
id|ra
)paren
(brace
id|ktrace_enter
c_func
(paren
id|pagebuf_trace_buf
comma
id|pb
comma
id|id
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|pb-&gt;pb_flags
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|pb-&gt;pb_hold.counter
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|pb-&gt;pb_sema.count.counter
comma
(paren
r_void
op_star
)paren
id|current
comma
id|data
comma
id|ra
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
(paren
(paren
id|pb-&gt;pb_file_offset
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
(paren
id|pb-&gt;pb_file_offset
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|pb-&gt;pb_buffer_length
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|variable|pagebuf_trace_buf
id|ktrace_t
op_star
id|pagebuf_trace_buf
suffix:semicolon
DECL|macro|PAGEBUF_TRACE_SIZE
mdefine_line|#define PAGEBUF_TRACE_SIZE&t;4096
DECL|macro|PB_TRACE
mdefine_line|#define PB_TRACE(pb, id, data)&t;&bslash;&n;&t;pagebuf_trace(pb, id, (void *)data, (void *)__builtin_return_address(0))
macro_line|#else
DECL|macro|PB_TRACE
mdefine_line|#define PB_TRACE(pb, id, data)&t;do { } while (0)
macro_line|#endif
macro_line|#ifdef PAGEBUF_LOCK_TRACKING
DECL|macro|PB_SET_OWNER
macro_line|# define PB_SET_OWNER(pb)&t;((pb)-&gt;pb_last_holder = current-&gt;pid)
DECL|macro|PB_CLEAR_OWNER
macro_line|# define PB_CLEAR_OWNER(pb)&t;((pb)-&gt;pb_last_holder = -1)
DECL|macro|PB_GET_OWNER
macro_line|# define PB_GET_OWNER(pb)&t;((pb)-&gt;pb_last_holder)
macro_line|#else
DECL|macro|PB_SET_OWNER
macro_line|# define PB_SET_OWNER(pb)&t;do { } while (0)
DECL|macro|PB_CLEAR_OWNER
macro_line|# define PB_CLEAR_OWNER(pb)&t;do { } while (0)
DECL|macro|PB_GET_OWNER
macro_line|# define PB_GET_OWNER(pb)&t;do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * Pagebuf allocation / freeing.&n; */
DECL|macro|pb_to_gfp
mdefine_line|#define pb_to_gfp(flags) &bslash;&n;&t;((((flags) &amp; PBF_READ_AHEAD) ? __GFP_NORETRY : &bslash;&n;&t;  ((flags) &amp; PBF_DONT_BLOCK) ? GFP_NOFS : GFP_KERNEL) | __GFP_NOWARN)
DECL|macro|pb_to_km
mdefine_line|#define pb_to_km(flags) &bslash;&n;&t; (((flags) &amp; PBF_DONT_BLOCK) ? KM_NOFS : KM_SLEEP)
DECL|macro|pagebuf_allocate
mdefine_line|#define pagebuf_allocate(flags) &bslash;&n;&t;kmem_zone_alloc(pagebuf_cache, pb_to_km(flags))
DECL|macro|pagebuf_deallocate
mdefine_line|#define pagebuf_deallocate(pb) &bslash;&n;&t;kmem_zone_free(pagebuf_cache, (pb));
multiline_comment|/*&n; * Page Region interfaces.&n; *&n; * For pages in filesystems where the blocksize is smaller than the&n; * pagesize, we use the page-&gt;private field (long) to hold a bitmap&n; * of uptodate regions within the page.&n; *&n; * Each such region is &quot;bytes per page / bits per long&quot; bytes long.&n; *&n; * NBPPR == number-of-bytes-per-page-region&n; * BTOPR == bytes-to-page-region (rounded up)&n; * BTOPRT == bytes-to-page-region-truncated (rounded down)&n; */
macro_line|#if (BITS_PER_LONG == 32)
DECL|macro|PRSHIFT
mdefine_line|#define PRSHIFT&t;&t;(PAGE_CACHE_SHIFT - 5)&t;/* (32 == 1&lt;&lt;5) */
macro_line|#elif (BITS_PER_LONG == 64)
DECL|macro|PRSHIFT
mdefine_line|#define PRSHIFT&t;&t;(PAGE_CACHE_SHIFT - 6)&t;/* (64 == 1&lt;&lt;6) */
macro_line|#else
macro_line|#error BITS_PER_LONG must be 32 or 64
macro_line|#endif
DECL|macro|NBPPR
mdefine_line|#define NBPPR&t;&t;(PAGE_CACHE_SIZE/BITS_PER_LONG)
DECL|macro|BTOPR
mdefine_line|#define BTOPR(b)&t;(((unsigned int)(b) + (NBPPR - 1)) &gt;&gt; PRSHIFT)
DECL|macro|BTOPRT
mdefine_line|#define BTOPRT(b)&t;(((unsigned int)(b) &gt;&gt; PRSHIFT))
id|STATIC
r_int
r_int
DECL|function|page_region_mask
id|page_region_mask
c_func
(paren
r_int
id|offset
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_int
id|first
comma
id|final
suffix:semicolon
id|first
op_assign
id|BTOPR
c_func
(paren
id|offset
)paren
suffix:semicolon
id|final
op_assign
id|BTOPRT
c_func
(paren
id|offset
op_plus
id|length
op_minus
l_int|1
)paren
suffix:semicolon
id|first
op_assign
id|min
c_func
(paren
id|first
comma
id|final
)paren
suffix:semicolon
id|mask
op_assign
op_complement
l_int|0UL
suffix:semicolon
id|mask
op_lshift_assign
id|BITS_PER_LONG
op_minus
(paren
id|final
op_minus
id|first
)paren
suffix:semicolon
id|mask
op_rshift_assign
id|BITS_PER_LONG
op_minus
(paren
id|final
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
op_plus
id|length
op_le
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|final
op_minus
id|first
)paren
OL
id|BITS_PER_LONG
op_logical_and
(paren
id|final
op_minus
id|first
)paren
op_ge
l_int|0
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
id|STATIC
r_inline
r_void
DECL|function|set_page_region
id|set_page_region
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|length
)paren
(brace
id|page
op_member_access_from_pointer
r_private
op_or_assign
id|page_region_mask
c_func
(paren
id|offset
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_member_access_from_pointer
r_private
op_eq
op_complement
l_int|0UL
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|STATIC
r_inline
r_int
DECL|function|test_page_region
id|test_page_region
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|mask
op_assign
id|page_region_mask
c_func
(paren
id|offset
comma
id|length
)paren
suffix:semicolon
r_return
(paren
id|mask
op_logical_and
(paren
id|page
op_member_access_from_pointer
r_private
op_amp
id|mask
)paren
op_eq
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mapping of multi-page buffers into contiguous virtual space&n; */
DECL|struct|a_list
r_typedef
r_struct
id|a_list
(brace
DECL|member|vm_addr
r_void
op_star
id|vm_addr
suffix:semicolon
DECL|member|next
r_struct
id|a_list
op_star
id|next
suffix:semicolon
DECL|typedef|a_list_t
)brace
id|a_list_t
suffix:semicolon
DECL|variable|as_free_head
id|STATIC
id|a_list_t
op_star
id|as_free_head
suffix:semicolon
DECL|variable|as_list_len
id|STATIC
r_int
id|as_list_len
suffix:semicolon
id|STATIC
id|DEFINE_SPINLOCK
c_func
(paren
id|as_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * Try to batch vunmaps because they are costly.&n; */
id|STATIC
r_void
DECL|function|free_address
id|free_address
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|a_list_t
op_star
id|aentry
suffix:semicolon
id|aentry
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|a_list_t
)paren
comma
id|GFP_ATOMIC
op_amp
op_complement
id|__GFP_HIGH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|aentry
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
id|aentry-&gt;next
op_assign
id|as_free_head
suffix:semicolon
id|aentry-&gt;vm_addr
op_assign
id|addr
suffix:semicolon
id|as_free_head
op_assign
id|aentry
suffix:semicolon
id|as_list_len
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|vunmap
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
)brace
id|STATIC
r_void
DECL|function|purge_addresses
id|purge_addresses
c_func
(paren
r_void
)paren
(brace
id|a_list_t
op_star
id|aentry
comma
op_star
id|old
suffix:semicolon
r_if
c_cond
(paren
id|as_free_head
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
id|aentry
op_assign
id|as_free_head
suffix:semicolon
id|as_free_head
op_assign
l_int|NULL
suffix:semicolon
id|as_list_len
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|old
op_assign
id|aentry
)paren
op_ne
l_int|NULL
)paren
(brace
id|vunmap
c_func
(paren
id|aentry-&gt;vm_addr
)paren
suffix:semicolon
id|aentry
op_assign
id|aentry-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Internal pagebuf object manipulation&n; */
id|STATIC
r_void
DECL|function|_pagebuf_initialize
id|_pagebuf_initialize
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
id|xfs_buftarg_t
op_star
id|target
comma
id|loff_t
id|range_base
comma
r_int
id|range_length
comma
id|page_buf_flags_t
id|flags
)paren
(brace
multiline_comment|/*&n;&t; * We don&squot;t want certain flags to appear in pb-&gt;pb_flags.&n;&t; */
id|flags
op_and_assign
op_complement
(paren
id|PBF_LOCK
op_or
id|PBF_MAPPED
op_or
id|PBF_DONT_BLOCK
op_or
id|PBF_READ_AHEAD
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pb
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_buf_t
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pb-&gt;pb_hold
comma
l_int|1
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|pb-&gt;pb_iodonesema
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
suffix:semicolon
multiline_comment|/* held, no waiters */
id|PB_SET_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;pb_target
op_assign
id|target
suffix:semicolon
id|pb-&gt;pb_file_offset
op_assign
id|range_base
suffix:semicolon
multiline_comment|/*&n;&t; * Set buffer_length and count_desired to the same value initially.&n;&t; * I/O routines should use count_desired, which will be the same in&n;&t; * most cases but may be reset (e.g. XFS recovery).&n;&t; */
id|pb-&gt;pb_buffer_length
op_assign
id|pb-&gt;pb_count_desired
op_assign
id|range_length
suffix:semicolon
id|pb-&gt;pb_flags
op_assign
id|flags
op_or
id|PBF_NONE
suffix:semicolon
id|pb-&gt;pb_bn
op_assign
id|XFS_BUF_DADDR_NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|pb_create
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;initialize&quot;
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a page array capable of holding a specified number&n; * of pages, and point the page buf at it.&n; */
id|STATIC
r_int
DECL|function|_pagebuf_get_pages
id|_pagebuf_get_pages
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
r_int
id|page_count
comma
id|page_buf_flags_t
id|flags
)paren
(brace
multiline_comment|/* Make sure that we have a page list */
r_if
c_cond
(paren
id|pb-&gt;pb_pages
op_eq
l_int|NULL
)paren
(brace
id|pb-&gt;pb_offset
op_assign
id|page_buf_poff
c_func
(paren
id|pb-&gt;pb_file_offset
)paren
suffix:semicolon
id|pb-&gt;pb_page_count
op_assign
id|page_count
suffix:semicolon
r_if
c_cond
(paren
id|page_count
op_le
id|PB_PAGES
)paren
(brace
id|pb-&gt;pb_pages
op_assign
id|pb-&gt;pb_page_array
suffix:semicolon
)brace
r_else
(brace
id|pb-&gt;pb_pages
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|page_count
comma
id|pb_to_km
c_func
(paren
id|flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_pages
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pb-&gt;pb_pages
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|page_count
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Frees pb_pages if it was malloced.&n; */
id|STATIC
r_void
DECL|function|_pagebuf_free_pages
id|_pagebuf_free_pages
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;pb_pages
op_ne
id|bp-&gt;pb_page_array
)paren
(brace
id|kmem_free
c_func
(paren
id|bp-&gt;pb_pages
comma
id|bp-&gt;pb_page_count
op_star
r_sizeof
(paren
r_struct
id|page
op_star
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Releases the specified buffer.&n; *&n; * &t;The modification state of any associated pages is left unchanged.&n; * &t;The buffer most not be on any hash - use pagebuf_rele instead for&n; * &t;hashed and refcounted buffers&n; */
r_void
DECL|function|pagebuf_free
id|pagebuf_free
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|PB_TRACE
c_func
(paren
id|bp
comma
l_string|&quot;free&quot;
comma
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|list_empty
c_func
(paren
op_amp
id|bp-&gt;pb_hash_list
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;pb_flags
op_amp
id|_PBF_PAGE_CACHE
)paren
(brace
id|uint
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bp-&gt;pb_flags
op_amp
id|PBF_MAPPED
)paren
op_logical_and
(paren
id|bp-&gt;pb_page_count
OG
l_int|1
)paren
)paren
id|free_address
c_func
(paren
id|bp-&gt;pb_addr
op_minus
id|bp-&gt;pb_offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bp-&gt;pb_page_count
suffix:semicolon
id|i
op_increment
)paren
id|page_cache_release
c_func
(paren
id|bp-&gt;pb_pages
(braket
id|i
)braket
)paren
suffix:semicolon
id|_pagebuf_free_pages
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bp-&gt;pb_flags
op_amp
id|_PBF_KMEM_ALLOC
)paren
(brace
multiline_comment|/*&n;&t;&t;  * XXX(hch): bp-&gt;pb_count_desired might be incorrect (see&n;&t;&t;  * pagebuf_associate_memory for details), but fortunately&n;&t;&t;  * the Linux version of kmem_free ignores the len argument..&n;&t;&t;  */
id|kmem_free
c_func
(paren
id|bp-&gt;pb_addr
comma
id|bp-&gt;pb_count_desired
)paren
suffix:semicolon
id|_pagebuf_free_pages
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|pagebuf_deallocate
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Finds all pages for buffer in question and builds it&squot;s page list.&n; */
id|STATIC
r_int
DECL|function|_pagebuf_lookup_pages
id|_pagebuf_lookup_pages
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|uint
id|flags
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|bp-&gt;pb_target-&gt;pbr_mapping
suffix:semicolon
r_int
id|blocksize
op_assign
id|bp-&gt;pb_target-&gt;pbr_bsize
suffix:semicolon
r_int
id|size
op_assign
id|bp-&gt;pb_count_desired
suffix:semicolon
r_int
id|nbytes
comma
id|offset
suffix:semicolon
r_int
id|gfp_mask
op_assign
id|pb_to_gfp
c_func
(paren
id|flags
)paren
suffix:semicolon
r_int
r_int
id|page_count
comma
id|i
suffix:semicolon
id|pgoff_t
id|first
suffix:semicolon
id|loff_t
id|end
suffix:semicolon
r_int
id|error
suffix:semicolon
id|end
op_assign
id|bp-&gt;pb_file_offset
op_plus
id|bp-&gt;pb_buffer_length
suffix:semicolon
id|page_count
op_assign
id|page_buf_btoc
c_func
(paren
id|end
)paren
op_minus
id|page_buf_btoct
c_func
(paren
id|bp-&gt;pb_file_offset
)paren
suffix:semicolon
id|error
op_assign
id|_pagebuf_get_pages
c_func
(paren
id|bp
comma
id|page_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
)paren
)paren
r_return
id|error
suffix:semicolon
id|bp-&gt;pb_flags
op_or_assign
id|_PBF_PAGE_CACHE
suffix:semicolon
id|offset
op_assign
id|bp-&gt;pb_offset
suffix:semicolon
id|first
op_assign
id|bp-&gt;pb_file_offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bp-&gt;pb_page_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|uint
id|retries
op_assign
l_int|0
suffix:semicolon
id|retry
suffix:colon
id|page
op_assign
id|find_or_create_page
c_func
(paren
id|mapping
comma
id|first
op_plus
id|i
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|page
op_eq
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_READ_AHEAD
)paren
(brace
id|bp-&gt;pb_page_count
op_assign
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bp-&gt;pb_page_count
suffix:semicolon
id|i
op_increment
)paren
id|unlock_page
c_func
(paren
id|bp-&gt;pb_pages
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This could deadlock.&n;&t;&t;&t; *&n;&t;&t;&t; * But until all the XFS lowlevel code is revamped to&n;&t;&t;&t; * handle buffer allocation failures we can&squot;t do much.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_increment
id|retries
op_mod
l_int|100
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;XFS: possible memory allocation &quot;
l_string|&quot;deadlock in %s (mode:0x%x)&bslash;n&quot;
comma
id|__FUNCTION__
comma
id|gfp_mask
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|pb_page_retries
)paren
suffix:semicolon
id|pagebuf_daemon_wakeup
c_func
(paren
l_int|0
comma
id|gfp_mask
)paren
suffix:semicolon
id|blk_congestion_wait
c_func
(paren
id|WRITE
comma
id|HZ
op_div
l_int|50
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|XFS_STATS_INC
c_func
(paren
id|pb_page_found
)paren
suffix:semicolon
id|nbytes
op_assign
id|min_t
c_func
(paren
r_int
comma
id|size
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|size
op_sub_assign
id|nbytes
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|page_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|blocksize
op_ge
id|PAGE_CACHE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_READ
)paren
id|bp-&gt;pb_locked
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|test_page_region
c_func
(paren
id|page
comma
id|offset
comma
id|nbytes
)paren
)paren
id|page_count
op_increment
suffix:semicolon
)brace
)brace
id|bp-&gt;pb_pages
(braket
id|i
)braket
op_assign
id|page
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bp-&gt;pb_locked
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bp-&gt;pb_page_count
suffix:semicolon
id|i
op_increment
)paren
id|unlock_page
c_func
(paren
id|bp-&gt;pb_pages
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page_count
)paren
(brace
multiline_comment|/* if we have any uptodate pages, mark that in the buffer */
id|bp-&gt;pb_flags
op_and_assign
op_complement
id|PBF_NONE
suffix:semicolon
multiline_comment|/* if some pages aren&squot;t uptodate, mark that in the buffer */
r_if
c_cond
(paren
id|page_count
op_ne
id|bp-&gt;pb_page_count
)paren
id|bp-&gt;pb_flags
op_or_assign
id|PBF_PARTIAL
suffix:semicolon
)brace
id|PB_TRACE
c_func
(paren
id|bp
comma
l_string|&quot;lookup_pages&quot;
comma
(paren
r_int
)paren
id|page_count
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Map buffer into kernel address-space if nessecary.&n; */
id|STATIC
r_int
DECL|function|_pagebuf_map_pages
id|_pagebuf_map_pages
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|uint
id|flags
)paren
(brace
multiline_comment|/* A single page buffer is always mappable */
r_if
c_cond
(paren
id|bp-&gt;pb_page_count
op_eq
l_int|1
)paren
(brace
id|bp-&gt;pb_addr
op_assign
id|page_address
c_func
(paren
id|bp-&gt;pb_pages
(braket
l_int|0
)braket
)paren
op_plus
id|bp-&gt;pb_offset
suffix:semicolon
id|bp-&gt;pb_flags
op_or_assign
id|PBF_MAPPED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_MAPPED
)paren
(brace
r_if
c_cond
(paren
id|as_list_len
OG
l_int|64
)paren
id|purge_addresses
c_func
(paren
)paren
suffix:semicolon
id|bp-&gt;pb_addr
op_assign
id|vmap
c_func
(paren
id|bp-&gt;pb_pages
comma
id|bp-&gt;pb_page_count
comma
id|VM_MAP
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bp-&gt;pb_addr
op_eq
l_int|NULL
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|bp-&gt;pb_addr
op_add_assign
id|bp-&gt;pb_offset
suffix:semicolon
id|bp-&gt;pb_flags
op_or_assign
id|PBF_MAPPED
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Finding and Reading Buffers&n; */
multiline_comment|/*&n; *&t;_pagebuf_find&n; *&n; *&t;Looks up, and creates if absent, a lockable buffer for&n; *&t;a given range of an inode.  The buffer is returned&n; *&t;locked.&t; If other overlapping buffers exist, they are&n; *&t;released before the new buffer is created and locked,&n; *&t;which may imply that this call will block until those buffers&n; *&t;are unlocked.  No I/O is implied by this call.&n; */
id|xfs_buf_t
op_star
DECL|function|_pagebuf_find
id|_pagebuf_find
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
multiline_comment|/* block device target&t;&t;*/
id|loff_t
id|ioff
comma
multiline_comment|/* starting offset of range&t;*/
r_int
id|isize
comma
multiline_comment|/* length of range&t;&t;*/
id|page_buf_flags_t
id|flags
comma
multiline_comment|/* PBF_TRYLOCK&t;&t;&t;*/
id|xfs_buf_t
op_star
id|new_pb
)paren
multiline_comment|/* newly allocated buffer&t;*/
(brace
id|loff_t
id|range_base
suffix:semicolon
r_int
id|range_length
suffix:semicolon
id|xfs_bufhash_t
op_star
id|hash
suffix:semicolon
id|xfs_buf_t
op_star
id|pb
comma
op_star
id|n
suffix:semicolon
id|range_base
op_assign
(paren
id|ioff
op_lshift
id|BBSHIFT
)paren
suffix:semicolon
id|range_length
op_assign
(paren
id|isize
op_lshift
id|BBSHIFT
)paren
suffix:semicolon
multiline_comment|/* Check for IOs smaller than the sector size / not sector aligned */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|range_length
OL
(paren
l_int|1
op_lshift
id|btp-&gt;pbr_sshift
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|range_base
op_amp
(paren
id|loff_t
)paren
id|btp-&gt;pbr_smask
)paren
)paren
suffix:semicolon
id|hash
op_assign
op_amp
id|btp-&gt;bt_hash
(braket
id|hash_long
c_func
(paren
(paren
r_int
r_int
)paren
id|ioff
comma
id|btp-&gt;bt_hashshift
)paren
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|pb
comma
id|n
comma
op_amp
id|hash-&gt;bh_list
comma
id|pb_hash_list
)paren
(brace
id|ASSERT
c_func
(paren
id|btp
op_eq
id|pb-&gt;pb_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_file_offset
op_eq
id|range_base
op_logical_and
id|pb-&gt;pb_buffer_length
op_eq
id|range_length
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we look at something bring it to the&n;&t;&t;&t; * front of the list for next time.&n;&t;&t;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
comma
op_amp
id|hash-&gt;bh_list
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
)brace
multiline_comment|/* No match found */
r_if
c_cond
(paren
id|new_pb
)paren
(brace
id|_pagebuf_initialize
c_func
(paren
id|new_pb
comma
id|btp
comma
id|range_base
comma
id|range_length
comma
id|flags
)paren
suffix:semicolon
id|new_pb-&gt;pb_hash
op_assign
id|hash
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_pb-&gt;pb_hash_list
comma
op_amp
id|hash-&gt;bh_list
)paren
suffix:semicolon
)brace
r_else
(brace
id|XFS_STATS_INC
c_func
(paren
id|pb_miss_locked
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
r_return
id|new_pb
suffix:semicolon
id|found
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
multiline_comment|/* Attempt to get the semaphore without sleeping,&n;&t; * if this does not work then we need to drop the&n;&t; * spinlock and do a hard attempt on the semaphore.&n;&t; */
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PBF_TRYLOCK
)paren
)paren
(brace
multiline_comment|/* wait for buffer ownership */
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;get_lock&quot;
comma
l_int|0
)paren
suffix:semicolon
id|pagebuf_lock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|pb_get_locked_waited
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We asked for a trylock and failed, no need&n;&t;&t;&t; * to look at file offset and length here, we&n;&t;&t;&t; * know that this pagebuf at least overlaps our&n;&t;&t;&t; * pagebuf and is locked, therefore our buffer&n;&t;&t;&t; * either does not exist, or is this buffer&n;&t;&t;&t; */
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|pb_busy_locked
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* trylock worked */
id|PB_SET_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_STALE
)paren
id|pb-&gt;pb_flags
op_and_assign
id|PBF_MAPPED
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;got_lock&quot;
comma
l_int|0
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|pb_get_locked
)paren
suffix:semicolon
r_return
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;xfs_buf_get_flags assembles a buffer covering the specified range.&n; *&n; *&t;Storage in memory for all portions of the buffer will be allocated,&n; *&t;although backing storage may not be.&n; */
id|xfs_buf_t
op_star
DECL|function|xfs_buf_get_flags
id|xfs_buf_get_flags
c_func
(paren
multiline_comment|/* allocate a buffer&t;&t;*/
id|xfs_buftarg_t
op_star
id|target
comma
multiline_comment|/* target for buffer&t;&t;*/
id|loff_t
id|ioff
comma
multiline_comment|/* starting offset of range&t;*/
r_int
id|isize
comma
multiline_comment|/* length of range&t;&t;*/
id|page_buf_flags_t
id|flags
)paren
multiline_comment|/* PBF_TRYLOCK&t;&t;&t;*/
(brace
id|xfs_buf_t
op_star
id|pb
comma
op_star
id|new_pb
suffix:semicolon
r_int
id|error
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|new_pb
op_assign
id|pagebuf_allocate
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|new_pb
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|pb
op_assign
id|_pagebuf_find
c_func
(paren
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
comma
id|new_pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb
op_eq
id|new_pb
)paren
(brace
id|error
op_assign
id|_pagebuf_lookup_pages
c_func
(paren
id|pb
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|no_buffer
suffix:semicolon
)brace
r_else
(brace
id|pagebuf_deallocate
c_func
(paren
id|new_pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|pb
op_eq
l_int|NULL
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pb-&gt;pb_page_count
suffix:semicolon
id|i
op_increment
)paren
id|mark_page_accessed
c_func
(paren
id|pb-&gt;pb_pages
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_MAPPED
)paren
)paren
(brace
id|error
op_assign
id|_pagebuf_map_pages
c_func
(paren
id|pb
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: failed to map pages&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_goto
id|no_buffer
suffix:semicolon
)brace
)brace
id|XFS_STATS_INC
c_func
(paren
id|pb_get
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Always fill in the block number now, the mapped cases can do&n;&t; * their own overlay of this later.&n;&t; */
id|pb-&gt;pb_bn
op_assign
id|ioff
suffix:semicolon
id|pb-&gt;pb_count_desired
op_assign
id|pb-&gt;pb_buffer_length
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;get&quot;
comma
(paren
r_int
r_int
)paren
id|flags
)paren
suffix:semicolon
r_return
id|pb
suffix:semicolon
id|no_buffer
suffix:colon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|PBF_LOCK
op_or
id|PBF_TRYLOCK
)paren
)paren
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|xfs_buf_t
op_star
DECL|function|xfs_buf_read_flags
id|xfs_buf_read_flags
c_func
(paren
id|xfs_buftarg_t
op_star
id|target
comma
id|loff_t
id|ioff
comma
r_int
id|isize
comma
id|page_buf_flags_t
id|flags
)paren
(brace
id|xfs_buf_t
op_star
id|pb
suffix:semicolon
id|flags
op_or_assign
id|PBF_READ
suffix:semicolon
id|pb
op_assign
id|xfs_buf_get_flags
c_func
(paren
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb
)paren
(brace
r_if
c_cond
(paren
id|PBF_NOT_DONE
c_func
(paren
id|pb
)paren
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;read&quot;
comma
(paren
r_int
r_int
)paren
id|flags
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|pb_get_read
)paren
suffix:semicolon
id|pagebuf_iostart
c_func
(paren
id|pb
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_ASYNC
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;read_async&quot;
comma
(paren
r_int
r_int
)paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Read ahead call which is already satisfied,&n;&t;&t;&t; * drop the buffer&n;&t;&t;&t; */
r_goto
id|no_buffer
suffix:semicolon
)brace
r_else
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;read_done&quot;
comma
(paren
r_int
r_int
)paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* We do not want read in the flags */
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_READ
suffix:semicolon
)brace
)brace
r_return
id|pb
suffix:semicolon
id|no_buffer
suffix:colon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|PBF_LOCK
op_or
id|PBF_TRYLOCK
)paren
)paren
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a skeletal pagebuf (no pages associated with it).&n; */
id|xfs_buf_t
op_star
DECL|function|pagebuf_lookup
id|pagebuf_lookup
c_func
(paren
id|xfs_buftarg_t
op_star
id|target
comma
id|loff_t
id|ioff
comma
r_int
id|isize
comma
id|page_buf_flags_t
id|flags
)paren
(brace
id|xfs_buf_t
op_star
id|pb
suffix:semicolon
id|pb
op_assign
id|pagebuf_allocate
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb
)paren
(brace
id|_pagebuf_initialize
c_func
(paren
id|pb
comma
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|pb
suffix:semicolon
)brace
multiline_comment|/*&n; * If we are not low on memory then do the readahead in a deadlock&n; * safe manner.&n; */
r_void
DECL|function|pagebuf_readahead
id|pagebuf_readahead
c_func
(paren
id|xfs_buftarg_t
op_star
id|target
comma
id|loff_t
id|ioff
comma
r_int
id|isize
comma
id|page_buf_flags_t
id|flags
)paren
(brace
r_struct
id|backing_dev_info
op_star
id|bdi
suffix:semicolon
id|bdi
op_assign
id|target-&gt;pbr_mapping-&gt;backing_dev_info
suffix:semicolon
r_if
c_cond
(paren
id|bdi_read_congested
c_func
(paren
id|bdi
)paren
)paren
r_return
suffix:semicolon
id|flags
op_or_assign
(paren
id|PBF_TRYLOCK
op_or
id|PBF_ASYNC
op_or
id|PBF_READ_AHEAD
)paren
suffix:semicolon
id|xfs_buf_read_flags
c_func
(paren
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
)paren
suffix:semicolon
)brace
id|xfs_buf_t
op_star
DECL|function|pagebuf_get_empty
id|pagebuf_get_empty
c_func
(paren
r_int
id|len
comma
id|xfs_buftarg_t
op_star
id|target
)paren
(brace
id|xfs_buf_t
op_star
id|pb
suffix:semicolon
id|pb
op_assign
id|pagebuf_allocate
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb
)paren
id|_pagebuf_initialize
c_func
(paren
id|pb
comma
id|target
comma
l_int|0
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_return
id|pb
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|page
op_star
DECL|function|mem_to_page
id|mem_to_page
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|addr
OL
id|VMALLOC_START
)paren
op_logical_or
(paren
(paren
r_int
r_int
)paren
id|addr
op_ge
id|VMALLOC_END
)paren
)paren
(brace
r_return
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|vmalloc_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|pagebuf_associate_memory
id|pagebuf_associate_memory
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
r_void
op_star
id|mem
comma
r_int
id|len
)paren
(brace
r_int
id|rval
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|ptr
suffix:semicolon
r_int
id|end
comma
id|end_cur
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_int
id|page_count
suffix:semicolon
id|page_count
op_assign
id|PAGE_CACHE_ALIGN
c_func
(paren
id|len
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_assign
(paren
id|off_t
)paren
id|mem
op_minus
(paren
(paren
id|off_t
)paren
id|mem
op_amp
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_logical_and
(paren
id|len
OG
id|PAGE_CACHE_SIZE
)paren
)paren
id|page_count
op_increment
suffix:semicolon
multiline_comment|/* Free any previous set of page pointers */
r_if
c_cond
(paren
id|pb-&gt;pb_pages
)paren
id|_pagebuf_free_pages
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;pb_pages
op_assign
l_int|NULL
suffix:semicolon
id|pb-&gt;pb_addr
op_assign
id|mem
suffix:semicolon
id|rval
op_assign
id|_pagebuf_get_pages
c_func
(paren
id|pb
comma
id|page_count
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
id|pb-&gt;pb_offset
op_assign
id|offset
suffix:semicolon
id|ptr
op_assign
(paren
r_int
)paren
id|mem
op_amp
id|PAGE_CACHE_MASK
suffix:semicolon
id|end
op_assign
id|PAGE_CACHE_ALIGN
c_func
(paren
(paren
r_int
)paren
id|mem
op_plus
id|len
)paren
suffix:semicolon
id|end_cur
op_assign
id|end
suffix:semicolon
multiline_comment|/* set up first page */
id|pb-&gt;pb_pages
(braket
l_int|0
)braket
op_assign
id|mem_to_page
c_func
(paren
id|mem
)paren
suffix:semicolon
id|ptr
op_add_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|pb-&gt;pb_page_count
op_assign
op_increment
id|i
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
)paren
(brace
id|pb-&gt;pb_pages
(braket
id|i
)braket
op_assign
id|mem_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|ptr
)paren
suffix:semicolon
id|pb-&gt;pb_page_count
op_assign
op_increment
id|i
suffix:semicolon
id|ptr
op_add_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
)brace
id|pb-&gt;pb_locked
op_assign
l_int|0
suffix:semicolon
id|pb-&gt;pb_count_desired
op_assign
id|pb-&gt;pb_buffer_length
op_assign
id|len
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_MAPPED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_buf_t
op_star
DECL|function|pagebuf_get_no_daddr
id|pagebuf_get_no_daddr
c_func
(paren
r_int
id|len
comma
id|xfs_buftarg_t
op_star
id|target
)paren
(brace
r_int
id|malloc_len
op_assign
id|len
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
r_int
id|error
suffix:semicolon
id|bp
op_assign
id|pagebuf_allocate
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bp
op_eq
l_int|NULL
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|_pagebuf_initialize
c_func
(paren
id|bp
comma
id|target
comma
l_int|0
comma
id|len
comma
id|PBF_FORCEIO
)paren
suffix:semicolon
id|try_again
suffix:colon
id|data
op_assign
id|kmem_alloc
c_func
(paren
id|malloc_len
comma
id|KM_SLEEP
op_or
id|KM_MAYFAIL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|data
op_eq
l_int|NULL
)paren
)paren
r_goto
id|fail_free_buf
suffix:semicolon
multiline_comment|/* check whether alignment matches.. */
r_if
c_cond
(paren
(paren
id|__psunsigned_t
)paren
id|data
op_ne
(paren
(paren
id|__psunsigned_t
)paren
id|data
op_amp
op_complement
id|target-&gt;pbr_smask
)paren
)paren
(brace
multiline_comment|/* .. else double the size and try again */
id|kmem_free
c_func
(paren
id|data
comma
id|malloc_len
)paren
suffix:semicolon
id|malloc_len
op_lshift_assign
l_int|1
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
id|error
op_assign
id|pagebuf_associate_memory
c_func
(paren
id|bp
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|fail_free_mem
suffix:semicolon
id|bp-&gt;pb_flags
op_or_assign
id|_PBF_KMEM_ALLOC
suffix:semicolon
id|pagebuf_unlock
c_func
(paren
id|bp
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|bp
comma
l_string|&quot;no_daddr&quot;
comma
id|data
)paren
suffix:semicolon
r_return
id|bp
suffix:semicolon
id|fail_free_mem
suffix:colon
id|kmem_free
c_func
(paren
id|data
comma
id|malloc_len
)paren
suffix:semicolon
id|fail_free_buf
suffix:colon
id|pagebuf_free
c_func
(paren
id|bp
)paren
suffix:semicolon
id|fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_hold&n; *&n; *&t;Increment reference count on buffer, to hold the buffer concurrently&n; *&t;with another thread which may release (free) the buffer asynchronously.&n; *&n; *&t;Must hold the buffer already to call this function.&n; */
r_void
DECL|function|pagebuf_hold
id|pagebuf_hold
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;hold&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_rele&n; *&n; *&t;pagebuf_rele releases a hold on the specified buffer.  If the&n; *&t;the hold count is 1, pagebuf_rele calls pagebuf_free.&n; */
r_void
DECL|function|pagebuf_rele
id|pagebuf_rele
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
id|xfs_bufhash_t
op_star
id|hash
op_assign
id|pb-&gt;pb_hash
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;rele&quot;
comma
id|pb-&gt;pb_relse
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * pagebuf_lookup buffers are not hashed, not delayed write,&n;&t; * and don&squot;t have their own release routines.  Special case.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|hash
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|pb-&gt;pb_relse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
)paren
id|xfs_buf_free
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_dec_and_lock
c_func
(paren
op_amp
id|pb-&gt;pb_hold
comma
op_amp
id|hash-&gt;bh_lock
)paren
)paren
(brace
r_int
id|do_free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_relse
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
(paren
op_star
(paren
id|pb-&gt;pb_relse
)paren
)paren
(paren
id|pb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
id|do_free
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
(brace
id|pb-&gt;pb_flags
op_or_assign
id|PBF_ASYNC
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
id|pagebuf_delwri_queue
c_func
(paren
id|pb
comma
l_int|0
)paren
suffix:semicolon
id|do_free
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_FS_MANAGED
)paren
(brace
id|do_free
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_free
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
id|pagebuf_free
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; *&t;Mutual exclusion on buffers.  Locking model:&n; *&n; *&t;Buffers associated with inodes for which buffer locking&n; *&t;is not enabled are not protected by semaphores, and are&n; *&t;assumed to be exclusively owned by the caller.  There is a&n; *&t;spinlock in the buffer, used by the caller when concurrent&n; *&t;access is possible.&n; */
multiline_comment|/*&n; *&t;pagebuf_cond_lock&n; *&n; *&t;pagebuf_cond_lock locks a buffer object, if it is not already locked.&n; *&t;Note that this in no way&n; *&t;locks the underlying pages, so it is only useful for synchronizing&n; *&t;concurrent use of page buffer objects, not for synchronizing independent&n; *&t;access to the underlying pages.&n; */
r_int
DECL|function|pagebuf_cond_lock
id|pagebuf_cond_lock
c_func
(paren
multiline_comment|/* lock buffer, if not locked&t;*/
multiline_comment|/* returns -EBUSY if locked)&t;*/
id|xfs_buf_t
op_star
id|pb
)paren
(brace
r_int
id|locked
suffix:semicolon
id|locked
op_assign
id|down_trylock
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
op_eq
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|locked
)paren
(brace
id|PB_SET_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;cond_lock&quot;
comma
(paren
r_int
)paren
id|locked
)paren
suffix:semicolon
r_return
id|locked
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; *&t;pagebuf_lock_value&n; *&n; *&t;Return lock value for a pagebuf&n; */
r_int
DECL|function|pagebuf_lock_value
id|pagebuf_lock_value
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_sema.count
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;pagebuf_lock&n; *&n; *&t;pagebuf_lock locks a buffer object.  Note that this in no way&n; *&t;locks the underlying pages, so it is only useful for synchronizing&n; *&t;concurrent use of page buffer objects, not for synchronizing independent&n; *&t;access to the underlying pages.&n; */
r_int
DECL|function|pagebuf_lock
id|pagebuf_lock
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;lock&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
)paren
id|blk_run_address_space
c_func
(paren
id|pb-&gt;pb_target-&gt;pbr_mapping
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
suffix:semicolon
id|PB_SET_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;locked&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_unlock&n; *&n; *&t;pagebuf_unlock releases the lock on the buffer object created by&n; *&t;pagebuf_lock or pagebuf_cond_lock (not any&n; *&t;pinning of underlying pages created by pagebuf_pin).&n; */
r_void
DECL|function|pagebuf_unlock
id|pagebuf_unlock
c_func
(paren
multiline_comment|/* unlock buffer&t;&t;*/
id|xfs_buf_t
op_star
id|pb
)paren
multiline_comment|/* buffer to unlock&t;&t;*/
(brace
id|PB_CLEAR_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;unlock&quot;
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Pinning Buffer Storage in Memory&n; */
multiline_comment|/*&n; *&t;pagebuf_pin&n; *&n; *&t;pagebuf_pin locks all of the memory represented by a buffer in&n; *&t;memory.  Multiple calls to pagebuf_pin and pagebuf_unpin, for&n; *&t;the same or different buffers affecting a given page, will&n; *&t;properly count the number of outstanding &quot;pin&quot; requests.  The&n; *&t;buffer may be released after the pagebuf_pin and a different&n; *&t;buffer used when calling pagebuf_unpin, if desired.&n; *&t;pagebuf_pin should be used by the file system when it wants be&n; *&t;assured that no attempt will be made to force the affected&n; *&t;memory to disk.&t; It does not assure that a given logical page&n; *&t;will not be moved to a different physical page.&n; */
r_void
DECL|function|pagebuf_pin
id|pagebuf_pin
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;pin&quot;
comma
(paren
r_int
)paren
id|pb-&gt;pb_pin_count.counter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_unpin&n; *&n; *&t;pagebuf_unpin reverses the locking of memory performed by&n; *&t;pagebuf_pin.  Note that both functions affected the logical&n; *&t;pages associated with the buffer, not the buffer itself.&n; */
r_void
DECL|function|pagebuf_unpin
id|pagebuf_unpin
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
)paren
(brace
id|wake_up_all
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
)paren
suffix:semicolon
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;unpin&quot;
comma
(paren
r_int
)paren
id|pb-&gt;pb_pin_count.counter
)paren
suffix:semicolon
)brace
r_int
DECL|function|pagebuf_ispin
id|pagebuf_ispin
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_wait_unpin&n; *&n; *&t;pagebuf_wait_unpin waits until all of the memory associated&n; *&t;with the buffer is not longer locked in memory.  It returns&n; *&t;immediately if none of the affected pages are locked.&n; */
r_static
r_inline
r_void
DECL|function|_pagebuf_wait_unpin
id|_pagebuf_wait_unpin
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
)paren
id|blk_run_address_space
c_func
(paren
id|pb-&gt;pb_target-&gt;pbr_mapping
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Buffer Utility Routines&n; */
multiline_comment|/*&n; *&t;pagebuf_iodone&n; *&n; *&t;pagebuf_iodone marks a buffer for which I/O is in progress&n; *&t;done with respect to that I/O.&t;The pb_iodone routine, if&n; *&t;present, will be called as a side-effect.&n; */
id|STATIC
r_void
DECL|function|pagebuf_iodone_work
id|pagebuf_iodone_work
c_func
(paren
r_void
op_star
id|v
)paren
(brace
id|xfs_buf_t
op_star
id|bp
op_assign
(paren
id|xfs_buf_t
op_star
)paren
id|v
suffix:semicolon
r_if
c_cond
(paren
id|bp-&gt;pb_iodone
)paren
(paren
op_star
(paren
id|bp-&gt;pb_iodone
)paren
)paren
(paren
id|bp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bp-&gt;pb_flags
op_amp
id|PBF_ASYNC
)paren
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_void
DECL|function|pagebuf_iodone
id|pagebuf_iodone
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
r_int
id|dataio
comma
r_int
id|schedule
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_READ
op_or
id|PBF_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_error
op_eq
l_int|0
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_PARTIAL
op_or
id|PBF_NONE
)paren
suffix:semicolon
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;iodone&quot;
comma
id|pb-&gt;pb_iodone
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_iodone
)paren
op_logical_or
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_ASYNC
)paren
)paren
(brace
r_if
c_cond
(paren
id|schedule
)paren
(brace
id|INIT_WORK
c_func
(paren
op_amp
id|pb-&gt;pb_iodone_work
comma
id|pagebuf_iodone_work
comma
id|pb
)paren
suffix:semicolon
id|queue_work
c_func
(paren
id|dataio
ques
c_cond
id|pagebuf_dataio_workqueue
suffix:colon
id|pagebuf_logio_workqueue
comma
op_amp
id|pb-&gt;pb_iodone_work
)paren
suffix:semicolon
)brace
r_else
(brace
id|pagebuf_iodone_work
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|up
c_func
(paren
op_amp
id|pb-&gt;pb_iodonesema
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;pagebuf_ioerror&n; *&n; *&t;pagebuf_ioerror sets the error code for a buffer.&n; */
r_void
DECL|function|pagebuf_ioerror
id|pagebuf_ioerror
c_func
(paren
multiline_comment|/* mark/clear buffer error flag */
id|xfs_buf_t
op_star
id|pb
comma
multiline_comment|/* buffer to mark&t;&t;*/
r_int
id|error
)paren
multiline_comment|/* error to store (0 if none)&t;*/
(brace
id|ASSERT
c_func
(paren
id|error
op_ge
l_int|0
op_logical_and
id|error
op_le
l_int|0xffff
)paren
suffix:semicolon
id|pb-&gt;pb_error
op_assign
(paren
r_int
r_int
)paren
id|error
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;ioerror&quot;
comma
(paren
r_int
r_int
)paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_iostart&n; *&n; *&t;pagebuf_iostart initiates I/O on a buffer, based on the flags supplied.&n; *&t;If necessary, it will arrange for any disk space allocation required,&n; *&t;and it will break up the request if the block mappings require it.&n; *&t;The pb_iodone routine in the buffer supplied will only be called&n; *&t;when all of the subsidiary I/O requests, if any, have been completed.&n; *&t;pagebuf_iostart calls the pagebuf_ioinitiate routine or&n; *&t;pagebuf_iorequest, if the former routine is not defined, to start&n; *&t;the I/O on a given low-level request.&n; */
r_int
DECL|function|pagebuf_iostart
id|pagebuf_iostart
c_func
(paren
multiline_comment|/* start I/O on a buffer&t;  */
id|xfs_buf_t
op_star
id|pb
comma
multiline_comment|/* buffer to start&t;&t;  */
id|page_buf_flags_t
id|flags
)paren
multiline_comment|/* PBF_LOCK, PBF_ASYNC, PBF_READ, */
multiline_comment|/* PBF_WRITE, PBF_DELWRI,&t;  */
multiline_comment|/* PBF_DONT_BLOCK&t;&t;  */
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;iostart&quot;
comma
(paren
r_int
r_int
)paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_DELWRI
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_READ
op_or
id|PBF_WRITE
op_or
id|PBF_ASYNC
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|flags
op_amp
(paren
id|PBF_DELWRI
op_or
id|PBF_ASYNC
)paren
suffix:semicolon
id|pagebuf_delwri_queue
c_func
(paren
id|pb
comma
l_int|1
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_READ
op_or
id|PBF_WRITE
op_or
id|PBF_ASYNC
op_or
id|PBF_DELWRI
op_or
"&bslash;"
id|PBF_READ_AHEAD
op_or
id|_PBF_RUN_QUEUES
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|flags
op_amp
(paren
id|PBF_READ
op_or
id|PBF_WRITE
op_or
id|PBF_ASYNC
op_or
"&bslash;"
id|PBF_READ_AHEAD
op_or
id|_PBF_RUN_QUEUES
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pb-&gt;pb_bn
op_eq
id|XFS_BUF_DADDR_NULL
)paren
suffix:semicolon
multiline_comment|/* For writes allow an alternate strategy routine to precede&n;&t; * the actual I/O request (which may not be issued at all in&n;&t; * a shutdown situation, for example).&n;&t; */
id|status
op_assign
(paren
id|flags
op_amp
id|PBF_WRITE
)paren
ques
c_cond
id|pagebuf_iostrategy
c_func
(paren
id|pb
)paren
suffix:colon
id|pagebuf_iorequest
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Wait for I/O if we are not an async request.&n;&t; * Note: async I/O request completion will release the buffer,&n;&t; * and that can already be done by this point.  So using the&n;&t; * buffer pointer from here on, after async I/O, is invalid.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|status
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|PBF_ASYNC
)paren
)paren
id|status
op_assign
id|pagebuf_iowait
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper routine for pagebuf_iorequest&n; */
id|STATIC
id|__inline__
r_int
DECL|function|_pagebuf_iolocked
id|_pagebuf_iolocked
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
id|ASSERT
c_func
(paren
id|pb-&gt;pb_flags
op_amp
(paren
id|PBF_READ
op_or
id|PBF_WRITE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_READ
)paren
r_return
id|pb-&gt;pb_locked
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
id|__inline__
r_void
DECL|function|_pagebuf_iodone
id|_pagebuf_iodone
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
r_int
id|schedule
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
op_eq
l_int|1
)paren
(brace
id|pb-&gt;pb_locked
op_assign
l_int|0
suffix:semicolon
id|pagebuf_iodone
c_func
(paren
id|pb
comma
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_FS_DATAIOD
)paren
comma
id|schedule
)paren
suffix:semicolon
)brace
)brace
id|STATIC
r_int
DECL|function|bio_end_io_pagebuf
id|bio_end_io_pagebuf
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
id|xfs_buf_t
op_star
id|pb
op_assign
(paren
id|xfs_buf_t
op_star
)paren
id|bio-&gt;bi_private
suffix:semicolon
r_int
r_int
id|i
comma
id|blocksize
op_assign
id|pb-&gt;pb_target-&gt;pbr_bsize
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
)paren
id|pb-&gt;pb_error
op_assign
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bio-&gt;bi_vcnt
suffix:semicolon
id|i
op_increment
comma
id|bvec
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec-&gt;bv_page
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_error
)paren
(brace
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|blocksize
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|PagePrivate
c_func
(paren
id|page
)paren
op_logical_and
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_PAGE_CACHE
)paren
)paren
(brace
id|set_page_region
c_func
(paren
id|page
comma
id|bvec-&gt;bv_offset
comma
id|bvec-&gt;bv_len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_pagebuf_iolocked
c_func
(paren
id|pb
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|_pagebuf_iodone
c_func
(paren
id|pb
comma
l_int|1
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|_pagebuf_ioapply
id|_pagebuf_ioapply
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
r_int
id|i
comma
id|map_i
comma
id|total_nr_pages
comma
id|nr_pages
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|offset
op_assign
id|pb-&gt;pb_offset
suffix:semicolon
r_int
id|size
op_assign
id|pb-&gt;pb_count_desired
suffix:semicolon
id|sector_t
id|sector
op_assign
id|pb-&gt;pb_bn
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|pb-&gt;pb_target-&gt;pbr_bsize
suffix:semicolon
r_int
id|locking
op_assign
id|_pagebuf_iolocked
c_func
(paren
id|pb
)paren
suffix:semicolon
id|total_nr_pages
op_assign
id|pb-&gt;pb_page_count
suffix:semicolon
id|map_i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special code path for reading a sub page size pagebuf in --&n;&t; * we populate up the whole page, and hence the other metadata&n;&t; * in the same page.  This optimization is only valid when the&n;&t; * filesystem block size and the page size are equal.&n;&t; */
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_buffer_length
OL
id|PAGE_CACHE_SIZE
)paren
op_logical_and
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_READ
)paren
op_logical_and
id|locking
op_logical_and
(paren
id|blocksize
op_eq
id|PAGE_CACHE_SIZE
)paren
)paren
(brace
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|pb-&gt;pb_target-&gt;pbr_bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|sector
op_minus
(paren
id|offset
op_rshift
id|BBSHIFT
)paren
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bio_end_io_pagebuf
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|pb
suffix:semicolon
id|bio_add_page
c_func
(paren
id|bio
comma
id|pb-&gt;pb_pages
(braket
l_int|0
)braket
comma
id|PAGE_CACHE_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
suffix:semicolon
r_goto
id|submit_io
suffix:semicolon
)brace
multiline_comment|/* Lock down the pages which we need to for the request */
r_if
c_cond
(paren
id|locking
op_logical_and
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_WRITE
)paren
op_logical_and
(paren
id|pb-&gt;pb_locked
op_eq
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|nbytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OG
id|size
)paren
id|nbytes
op_assign
id|size
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|size
op_sub_assign
id|nbytes
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
id|offset
op_assign
id|pb-&gt;pb_offset
suffix:semicolon
id|size
op_assign
id|pb-&gt;pb_count_desired
suffix:semicolon
)brace
id|next_chunk
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
suffix:semicolon
id|nr_pages
op_assign
id|BIO_MAX_SECTORS
op_rshift
(paren
id|PAGE_SHIFT
op_minus
id|BBSHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
OG
id|total_nr_pages
)paren
id|nr_pages
op_assign
id|total_nr_pages
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
id|nr_pages
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|pb-&gt;pb_target-&gt;pbr_bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|sector
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bio_end_io_pagebuf
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|pb
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|size
op_logical_and
id|nr_pages
suffix:semicolon
id|nr_pages
op_decrement
comma
id|map_i
op_increment
)paren
(brace
r_int
id|nbytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OG
id|size
)paren
id|nbytes
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|pb-&gt;pb_pages
(braket
id|map_i
)braket
comma
id|nbytes
comma
id|offset
)paren
OL
id|nbytes
)paren
r_break
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|sector
op_add_assign
id|nbytes
op_rshift
id|BBSHIFT
suffix:semicolon
id|size
op_sub_assign
id|nbytes
suffix:semicolon
id|total_nr_pages
op_decrement
suffix:semicolon
)brace
id|submit_io
suffix:colon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|bio-&gt;bi_size
)paren
)paren
(brace
id|submit_bio
c_func
(paren
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_READ
)paren
ques
c_cond
id|READ
suffix:colon
id|WRITE
comma
id|bio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
r_goto
id|next_chunk
suffix:semicolon
)brace
r_else
(brace
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
id|pagebuf_ioerror
c_func
(paren
id|pb
comma
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_RUN_QUEUES
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|_PBF_RUN_QUEUES
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
OG
l_int|1
)paren
id|blk_run_address_space
c_func
(paren
id|pb-&gt;pb_target-&gt;pbr_mapping
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;pagebuf_iorequest -- the core I/O request routine.&n; */
r_int
DECL|function|pagebuf_iorequest
id|pagebuf_iorequest
c_func
(paren
multiline_comment|/* start real I/O&t;&t;*/
id|xfs_buf_t
op_star
id|pb
)paren
multiline_comment|/* buffer to convey to device&t;*/
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;iorequest&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
(brace
id|pagebuf_delwri_queue
c_func
(paren
id|pb
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_WRITE
)paren
(brace
id|_pagebuf_wait_unpin
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
id|pagebuf_hold
c_func
(paren
id|pb
)paren
suffix:semicolon
multiline_comment|/* Set the count to 1 initially, this will stop an I/O&n;&t; * completion callout which happens before we have started&n;&t; * all the I/O from calling pagebuf_iodone too early.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
comma
l_int|1
)paren
suffix:semicolon
id|_pagebuf_ioapply
c_func
(paren
id|pb
)paren
suffix:semicolon
id|_pagebuf_iodone
c_func
(paren
id|pb
comma
l_int|0
)paren
suffix:semicolon
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_iowait&n; *&n; *&t;pagebuf_iowait waits for I/O to complete on the buffer supplied.&n; *&t;It returns immediately if no I/O is pending.  In any case, it returns&n; *&t;the error code, if any, or 0 if there is no error.&n; */
r_int
DECL|function|pagebuf_iowait
id|pagebuf_iowait
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;iowait&quot;
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
)paren
id|blk_run_address_space
c_func
(paren
id|pb-&gt;pb_target-&gt;pbr_mapping
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|pb-&gt;pb_iodonesema
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;iowaited&quot;
comma
(paren
r_int
)paren
id|pb-&gt;pb_error
)paren
suffix:semicolon
r_return
id|pb-&gt;pb_error
suffix:semicolon
)brace
id|caddr_t
DECL|function|pagebuf_offset
id|pagebuf_offset
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
r_int
id|offset
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|offset
op_add_assign
id|pb-&gt;pb_offset
suffix:semicolon
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
)braket
suffix:semicolon
r_return
(paren
id|caddr_t
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
(paren
id|offset
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_iomove&n; *&n; *&t;Move data into or out of a buffer.&n; */
r_void
DECL|function|pagebuf_iomove
id|pagebuf_iomove
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
multiline_comment|/* buffer to process&t;&t;*/
r_int
id|boff
comma
multiline_comment|/* starting buffer offset&t;*/
r_int
id|bsize
comma
multiline_comment|/* length to copy&t;&t;*/
id|caddr_t
id|data
comma
multiline_comment|/* data address&t;&t;&t;*/
id|page_buf_rw_t
id|mode
)paren
multiline_comment|/* read/write flag&t;&t;*/
(brace
r_int
id|bend
comma
id|cpoff
comma
id|csize
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|bend
op_assign
id|boff
op_plus
id|bsize
suffix:semicolon
r_while
c_loop
(paren
id|boff
OL
id|bend
)paren
(brace
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|page_buf_btoct
c_func
(paren
id|boff
op_plus
id|pb-&gt;pb_offset
)paren
)braket
suffix:semicolon
id|cpoff
op_assign
id|page_buf_poff
c_func
(paren
id|boff
op_plus
id|pb-&gt;pb_offset
)paren
suffix:semicolon
id|csize
op_assign
id|min_t
c_func
(paren
r_int
comma
id|PAGE_CACHE_SIZE
op_minus
id|cpoff
comma
id|pb-&gt;pb_count_desired
op_minus
id|boff
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|csize
op_plus
id|cpoff
)paren
op_le
id|PAGE_CACHE_SIZE
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|PBRW_ZERO
suffix:colon
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cpoff
comma
l_int|0
comma
id|csize
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PBRW_READ
suffix:colon
id|memcpy
c_func
(paren
id|data
comma
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cpoff
comma
id|csize
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PBRW_WRITE
suffix:colon
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cpoff
comma
id|data
comma
id|csize
)paren
suffix:semicolon
)brace
id|boff
op_add_assign
id|csize
suffix:semicolon
id|data
op_add_assign
id|csize
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Handling of buftargs.&n; */
multiline_comment|/*&n; * Wait for any bufs with callbacks that have been submitted but&n; * have not yet returned... walk the hash list for the target.&n; */
r_void
DECL|function|xfs_wait_buftarg
id|xfs_wait_buftarg
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
)paren
(brace
id|xfs_buf_t
op_star
id|bp
comma
op_star
id|n
suffix:semicolon
id|xfs_bufhash_t
op_star
id|hash
suffix:semicolon
id|uint
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|btp-&gt;bt_hashshift
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hash
op_assign
op_amp
id|btp-&gt;bt_hash
(braket
id|i
)braket
suffix:semicolon
id|again
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|bp
comma
id|n
comma
op_amp
id|hash-&gt;bh_list
comma
id|pb_hash_list
)paren
(brace
id|ASSERT
c_func
(paren
id|btp
op_eq
id|bp-&gt;pb_target
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bp-&gt;pb_flags
op_amp
id|PBF_FS_MANAGED
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
id|delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;bh_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Allocate buffer hash table for a given target.&n; * For devices containing metadata (i.e. not the log/realtime devices)&n; * we need to allocate a much larger hash table.&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_bufhash
id|xfs_alloc_bufhash
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
r_int
id|external
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|btp-&gt;bt_hashshift
op_assign
id|external
ques
c_cond
l_int|3
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* 8 or 256 buckets */
id|btp-&gt;bt_hashmask
op_assign
(paren
l_int|1
op_lshift
id|btp-&gt;bt_hashshift
)paren
op_minus
l_int|1
suffix:semicolon
id|btp-&gt;bt_hash
op_assign
id|kmem_zalloc
c_func
(paren
(paren
l_int|1
op_lshift
id|btp-&gt;bt_hashshift
)paren
op_star
r_sizeof
(paren
id|xfs_bufhash_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|btp-&gt;bt_hashshift
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|btp-&gt;bt_hash
(braket
id|i
)braket
dot
id|bh_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|btp-&gt;bt_hash
(braket
id|i
)braket
dot
id|bh_list
)paren
suffix:semicolon
)brace
)brace
id|STATIC
r_void
DECL|function|xfs_free_bufhash
id|xfs_free_bufhash
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
)paren
(brace
id|kmem_free
c_func
(paren
id|btp-&gt;bt_hash
comma
(paren
l_int|1
op_lshift
id|btp-&gt;bt_hashshift
)paren
op_star
r_sizeof
(paren
id|xfs_bufhash_t
)paren
)paren
suffix:semicolon
id|btp-&gt;bt_hash
op_assign
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|xfs_free_buftarg
id|xfs_free_buftarg
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
r_int
id|external
)paren
(brace
id|xfs_flush_buftarg
c_func
(paren
id|btp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|external
)paren
id|xfs_blkdev_put
c_func
(paren
id|btp-&gt;pbr_bdev
)paren
suffix:semicolon
id|xfs_free_bufhash
c_func
(paren
id|btp
)paren
suffix:semicolon
id|iput
c_func
(paren
id|btp-&gt;pbr_mapping-&gt;host
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|btp
comma
r_sizeof
(paren
op_star
id|btp
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_incore_relse
id|xfs_incore_relse
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
r_int
id|delwri_only
comma
r_int
id|wait
)paren
(brace
id|invalidate_bdev
c_func
(paren
id|btp-&gt;pbr_bdev
comma
l_int|1
)paren
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
id|btp-&gt;pbr_mapping
comma
l_int|0LL
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_setsize_buftarg_flags
id|xfs_setsize_buftarg_flags
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
r_int
r_int
id|blocksize
comma
r_int
r_int
id|sectorsize
comma
r_int
id|verbose
)paren
(brace
id|btp-&gt;pbr_bsize
op_assign
id|blocksize
suffix:semicolon
id|btp-&gt;pbr_sshift
op_assign
id|ffs
c_func
(paren
id|sectorsize
)paren
op_minus
l_int|1
suffix:semicolon
id|btp-&gt;pbr_smask
op_assign
id|sectorsize
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|set_blocksize
c_func
(paren
id|btp-&gt;pbr_bdev
comma
id|sectorsize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;XFS: Cannot set_blocksize to %u on device %s&bslash;n&quot;
comma
id|sectorsize
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|btp
)paren
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbose
op_logical_and
(paren
id|PAGE_CACHE_SIZE
op_div
id|BITS_PER_LONG
)paren
OG
id|sectorsize
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;XFS: %u byte sectors in use on device %s.  &quot;
l_string|&quot;This is suboptimal; %u or greater is ideal.&bslash;n&quot;
comma
id|sectorsize
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|btp
)paren
comma
(paren
r_int
r_int
)paren
id|PAGE_CACHE_SIZE
op_div
id|BITS_PER_LONG
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;* When allocating the initial buffer target we have not yet&n;* read in the superblock, so don&squot;t know what sized sectors&n;* are being used is at this early stage.  Play safe.&n;*/
id|STATIC
r_int
DECL|function|xfs_setsize_buftarg_early
id|xfs_setsize_buftarg_early
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_return
id|xfs_setsize_buftarg_flags
c_func
(paren
id|btp
comma
id|PAGE_CACHE_SIZE
comma
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_setsize_buftarg
id|xfs_setsize_buftarg
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
r_int
r_int
id|blocksize
comma
r_int
r_int
id|sectorsize
)paren
(brace
r_return
id|xfs_setsize_buftarg_flags
c_func
(paren
id|btp
comma
id|blocksize
comma
id|sectorsize
comma
l_int|1
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_mapping_buftarg
id|xfs_mapping_buftarg
c_func
(paren
id|xfs_buftarg_t
op_star
id|btp
comma
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_struct
id|backing_dev_info
op_star
id|bdi
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_static
r_struct
id|address_space_operations
id|mapping_aops
op_assign
(brace
dot
id|sync_page
op_assign
id|block_sync_page
comma
)brace
suffix:semicolon
id|inode
op_assign
id|new_inode
c_func
(paren
id|bdev-&gt;bd_inode-&gt;i_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;XFS: Cannot allocate mapping inode for device %s&bslash;n&quot;
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|btp
)paren
)paren
suffix:semicolon
r_return
id|ENOMEM
suffix:semicolon
)brace
id|inode-&gt;i_mode
op_assign
id|S_IFBLK
suffix:semicolon
id|inode-&gt;i_bdev
op_assign
id|bdev
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|bdev-&gt;bd_dev
suffix:semicolon
id|bdi
op_assign
id|blk_get_backing_dev_info
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdi
)paren
id|bdi
op_assign
op_amp
id|default_backing_dev_info
suffix:semicolon
id|mapping
op_assign
op_amp
id|inode-&gt;i_data
suffix:semicolon
id|mapping-&gt;a_ops
op_assign
op_amp
id|mapping_aops
suffix:semicolon
id|mapping-&gt;backing_dev_info
op_assign
id|bdi
suffix:semicolon
id|mapping_set_gfp_mask
c_func
(paren
id|mapping
comma
id|GFP_NOFS
)paren
suffix:semicolon
id|btp-&gt;pbr_mapping
op_assign
id|mapping
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_buftarg_t
op_star
DECL|function|xfs_alloc_buftarg
id|xfs_alloc_buftarg
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|external
)paren
(brace
id|xfs_buftarg_t
op_star
id|btp
suffix:semicolon
id|btp
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
op_star
id|btp
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|btp-&gt;pbr_dev
op_assign
id|bdev-&gt;bd_dev
suffix:semicolon
id|btp-&gt;pbr_bdev
op_assign
id|bdev
suffix:semicolon
r_if
c_cond
(paren
id|xfs_setsize_buftarg_early
c_func
(paren
id|btp
comma
id|bdev
)paren
)paren
r_goto
id|error
suffix:semicolon
r_if
c_cond
(paren
id|xfs_mapping_buftarg
c_func
(paren
id|btp
comma
id|bdev
)paren
)paren
r_goto
id|error
suffix:semicolon
id|xfs_alloc_bufhash
c_func
(paren
id|btp
comma
id|external
)paren
suffix:semicolon
r_return
id|btp
suffix:semicolon
id|error
suffix:colon
id|kmem_free
c_func
(paren
id|btp
comma
r_sizeof
(paren
op_star
id|btp
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Pagebuf delayed write buffer handling&n; */
id|STATIC
id|LIST_HEAD
c_func
(paren
id|pbd_delwrite_queue
)paren
suffix:semicolon
id|STATIC
id|DEFINE_SPINLOCK
c_func
(paren
id|pbd_delwrite_lock
)paren
suffix:semicolon
id|STATIC
r_void
DECL|function|pagebuf_delwri_queue
id|pagebuf_delwri_queue
c_func
(paren
id|xfs_buf_t
op_star
id|pb
comma
r_int
id|unlock
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;delwri_q&quot;
comma
(paren
r_int
)paren
id|unlock
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
multiline_comment|/* If already in the queue, dequeue and place at tail */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlock
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|pb-&gt;pb_list
comma
op_amp
id|pbd_delwrite_queue
)paren
suffix:semicolon
id|pb-&gt;pb_queuetime
op_assign
id|jiffies
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlock
)paren
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_void
DECL|function|pagebuf_delwri_dequeue
id|pagebuf_delwri_dequeue
c_func
(paren
id|xfs_buf_t
op_star
id|pb
)paren
(brace
r_int
id|dequeued
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|dequeued
op_assign
l_int|1
suffix:semicolon
)brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_DELWRI
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dequeued
)paren
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;delwri_dq&quot;
comma
(paren
r_int
)paren
id|dequeued
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|pagebuf_runall_queues
id|pagebuf_runall_queues
c_func
(paren
r_struct
id|workqueue_struct
op_star
id|queue
)paren
(brace
id|flush_workqueue
c_func
(paren
id|queue
)paren
suffix:semicolon
)brace
multiline_comment|/* Defines for pagebuf daemon */
id|STATIC
id|DECLARE_COMPLETION
c_func
(paren
id|pagebuf_daemon_done
)paren
suffix:semicolon
DECL|variable|pagebuf_daemon_task
id|STATIC
r_struct
id|task_struct
op_star
id|pagebuf_daemon_task
suffix:semicolon
DECL|variable|pagebuf_daemon_active
id|STATIC
r_int
id|pagebuf_daemon_active
suffix:semicolon
DECL|variable|force_flush
id|STATIC
r_int
id|force_flush
suffix:semicolon
id|STATIC
r_int
DECL|function|pagebuf_daemon_wakeup
id|pagebuf_daemon_wakeup
c_func
(paren
r_int
id|priority
comma
r_int
r_int
id|mask
)paren
(brace
id|force_flush
op_assign
l_int|1
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|wake_up_process
c_func
(paren
id|pagebuf_daemon_task
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|pagebuf_daemon
id|pagebuf_daemon
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|list_head
id|tmp
suffix:semicolon
r_int
r_int
id|age
suffix:semicolon
id|xfs_buftarg_t
op_star
id|target
suffix:semicolon
id|xfs_buf_t
op_star
id|pb
comma
op_star
id|n
suffix:semicolon
multiline_comment|/*  Set up the thread  */
id|daemonize
c_func
(paren
l_string|&quot;xfsbufd&quot;
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
id|pagebuf_daemon_task
op_assign
id|current
suffix:semicolon
id|pagebuf_daemon_active
op_assign
l_int|1
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_do
(brace
id|try_to_freeze
c_func
(paren
id|PF_FREEZE
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
(paren
id|xfs_buf_timer_centisecs
op_star
id|HZ
)paren
op_div
l_int|100
)paren
suffix:semicolon
id|age
op_assign
(paren
id|xfs_buf_age_centisecs
op_star
id|HZ
)paren
op_div
l_int|100
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|pb
comma
id|n
comma
op_amp
id|pbd_delwrite_queue
comma
id|pb_list
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;walkq1&quot;
comma
(paren
r_int
)paren
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
op_logical_and
op_logical_neg
id|pagebuf_cond_lock
c_func
(paren
id|pb
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|force_flush
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|pb-&gt;pb_queuetime
op_plus
id|age
)paren
)paren
(brace
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_DELWRI
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_WRITE
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|pb-&gt;pb_list
comma
op_amp
id|tmp
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tmp
)paren
)paren
(brace
id|pb
op_assign
id|list_entry
c_func
(paren
id|tmp.next
comma
id|xfs_buf_t
comma
id|pb_list
)paren
suffix:semicolon
id|target
op_assign
id|pb-&gt;pb_target
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|pagebuf_iostrategy
c_func
(paren
id|pb
)paren
suffix:semicolon
id|blk_run_address_space
c_func
(paren
id|target-&gt;pbr_mapping
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|as_list_len
OG
l_int|0
)paren
id|purge_addresses
c_func
(paren
)paren
suffix:semicolon
id|force_flush
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pagebuf_daemon_active
)paren
suffix:semicolon
id|complete_and_exit
c_func
(paren
op_amp
id|pagebuf_daemon_done
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Go through all incore buffers, and release buffers if they belong to&n; * the given device. This is used in filesystem error handling to&n; * preserve the consistency of its metadata.&n; */
r_int
DECL|function|xfs_flush_buftarg
id|xfs_flush_buftarg
c_func
(paren
id|xfs_buftarg_t
op_star
id|target
comma
r_int
id|wait
)paren
(brace
r_struct
id|list_head
id|tmp
suffix:semicolon
id|xfs_buf_t
op_star
id|pb
comma
op_star
id|n
suffix:semicolon
r_int
id|pincount
op_assign
l_int|0
suffix:semicolon
id|pagebuf_runall_queues
c_func
(paren
id|pagebuf_dataio_workqueue
)paren
suffix:semicolon
id|pagebuf_runall_queues
c_func
(paren
id|pagebuf_logio_workqueue
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
id|list_for_each_entry_safe
c_func
(paren
id|pb
comma
id|n
comma
op_amp
id|pbd_delwrite_queue
comma
id|pb_list
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_target
op_ne
id|target
)paren
r_continue
suffix:semicolon
id|ASSERT
c_func
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
l_string|&quot;walkq2&quot;
comma
(paren
r_int
)paren
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
)paren
(brace
id|pincount
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_DELWRI
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_WRITE
suffix:semicolon
id|list_move
c_func
(paren
op_amp
id|pb-&gt;pb_list
comma
op_amp
id|tmp
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Dropped the delayed write list lock, now walk the temporary list&n;&t; */
id|list_for_each_entry_safe
c_func
(paren
id|pb
comma
id|n
comma
op_amp
id|tmp
comma
id|pb_list
)paren
(brace
r_if
c_cond
(paren
id|wait
)paren
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_ASYNC
suffix:semicolon
r_else
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|pagebuf_lock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pagebuf_iostrategy
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remaining list items must be flushed before returning&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tmp
)paren
)paren
(brace
id|pb
op_assign
id|list_entry
c_func
(paren
id|tmp.next
comma
id|xfs_buf_t
comma
id|pb_list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|xfs_iowait
c_func
(paren
id|pb
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait
)paren
id|blk_run_address_space
c_func
(paren
id|target-&gt;pbr_mapping
)paren
suffix:semicolon
r_return
id|pincount
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|pagebuf_daemon_start
id|pagebuf_daemon_start
c_func
(paren
r_void
)paren
(brace
r_int
id|rval
suffix:semicolon
id|pagebuf_logio_workqueue
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;xfslogd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagebuf_logio_workqueue
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pagebuf_dataio_workqueue
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;xfsdatad&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagebuf_dataio_workqueue
)paren
(brace
id|destroy_workqueue
c_func
(paren
id|pagebuf_logio_workqueue
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|rval
op_assign
id|kernel_thread
c_func
(paren
id|pagebuf_daemon
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
OL
l_int|0
)paren
(brace
id|destroy_workqueue
c_func
(paren
id|pagebuf_logio_workqueue
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|pagebuf_dataio_workqueue
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * pagebuf_daemon_stop&n; *&n; * Note: do not mark as __exit, it is called from pagebuf_terminate.&n; */
id|STATIC
r_void
DECL|function|pagebuf_daemon_stop
id|pagebuf_daemon_stop
c_func
(paren
r_void
)paren
(brace
id|pagebuf_daemon_active
op_assign
l_int|0
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|wait_for_completion
c_func
(paren
op_amp
id|pagebuf_daemon_done
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|pagebuf_logio_workqueue
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|pagebuf_dataio_workqueue
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Initialization and Termination&n; */
r_int
id|__init
DECL|function|pagebuf_init
id|pagebuf_init
c_func
(paren
r_void
)paren
(brace
id|pagebuf_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;xfs_buf_t&quot;
comma
r_sizeof
(paren
id|xfs_buf_t
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagebuf_cache
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: couldn&squot;t init xfs_buf_t cache&bslash;n&quot;
)paren
suffix:semicolon
id|pagebuf_terminate
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#ifdef PAGEBUF_TRACE
id|pagebuf_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|PAGEBUF_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
id|pagebuf_daemon_start
c_func
(paren
)paren
suffix:semicolon
id|pagebuf_shake
op_assign
id|kmem_shake_register
c_func
(paren
id|pagebuf_daemon_wakeup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagebuf_shake
op_eq
l_int|NULL
)paren
(brace
id|pagebuf_terminate
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_terminate.&n; *&n; *&t;Note: do not mark as __exit, this is also called from the __init code.&n; */
r_void
DECL|function|pagebuf_terminate
id|pagebuf_terminate
c_func
(paren
r_void
)paren
(brace
id|pagebuf_daemon_stop
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef PAGEBUF_TRACE
id|ktrace_free
c_func
(paren
id|pagebuf_trace_buf
)paren
suffix:semicolon
macro_line|#endif
id|kmem_zone_destroy
c_func
(paren
id|pagebuf_cache
)paren
suffix:semicolon
id|kmem_shake_deregister
c_func
(paren
id|pagebuf_shake
)paren
suffix:semicolon
)brace
eof
