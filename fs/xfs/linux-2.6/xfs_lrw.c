multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; *  fs/xfs/linux/xfs_lrw.c (Linux Read Write stuff)&n; *&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_fs.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rtalloc.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_itable.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_acl.h&quot;
macro_line|#include &quot;xfs_cap.h&quot;
macro_line|#include &quot;xfs_mac.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_utils.h&quot;
macro_line|#include &quot;xfs_iomap.h&quot;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#if defined(XFS_RW_TRACE)
r_void
DECL|function|xfs_rw_enter_trace
id|xfs_rw_enter_trace
c_func
(paren
r_int
id|tag
comma
id|xfs_iocore_t
op_star
id|io
comma
r_void
op_star
id|data
comma
r_int
id|segs
comma
id|loff_t
id|offset
comma
r_int
id|ioflags
)paren
(brace
id|xfs_inode_t
op_star
id|ip
op_assign
id|XFS_IO_INODE
c_func
(paren
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_rwtrace
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|ip-&gt;i_rwtrace
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|tag
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|ip-&gt;i_d.di_size
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|ip-&gt;i_d.di_size
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|data
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|segs
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|offset
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|offset
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|ioflags
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|io-&gt;io_new_size
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|io-&gt;io_new_size
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_inval_cached_trace
id|xfs_inval_cached_trace
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
id|xfs_off_t
id|len
comma
id|xfs_off_t
id|first
comma
id|xfs_off_t
id|last
)paren
(brace
id|xfs_inode_t
op_star
id|ip
op_assign
id|XFS_IO_INODE
c_func
(paren
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_rwtrace
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|ip-&gt;i_rwtrace
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|XFS_INVAL_CACHED
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|offset
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|offset
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|len
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|len
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|first
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|first
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|last
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|last
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;xfs_iozero&n; *&n; *&t;xfs_iozero clears the specified range of buffer supplied,&n; *&t;and marks all the affected blocks as valid and modified.  If&n; *&t;an affected block is not allocated, it will be allocated.  If&n; *&t;an affected block is not completely overwritten, and is not&n; *&t;valid before the operation, it will be read from disk before&n; *&t;being partially zeroed.&n; */
id|STATIC
r_int
DECL|function|xfs_iozero
id|xfs_iozero
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
multiline_comment|/* inode&t;&t;&t;*/
id|loff_t
id|pos
comma
multiline_comment|/* offset in file&t;&t;*/
r_int
id|count
comma
multiline_comment|/* size of data to zero&t;&t;*/
id|loff_t
id|end_size
)paren
multiline_comment|/* max file size to set */
(brace
r_int
id|bytes
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|status
suffix:semicolon
id|mapping
op_assign
id|ip-&gt;i_mapping
suffix:semicolon
r_do
(brace
r_int
r_int
id|index
comma
id|offset
suffix:semicolon
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Within page */
id|index
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|bytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|count
)paren
id|bytes
op_assign
id|count
suffix:semicolon
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|status
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|prepare_write
c_func
(paren
l_int|NULL
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_goto
id|unlock
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|kaddr
op_plus
id|offset
)paren
comma
l_int|0
comma
id|bytes
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|status
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|commit_write
c_func
(paren
l_int|NULL
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|pos
op_add_assign
id|bytes
suffix:semicolon
id|count
op_sub_assign
id|bytes
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|i_size_read
c_func
(paren
id|ip
)paren
)paren
id|i_size_write
c_func
(paren
id|ip
comma
id|pos
OL
id|end_size
ques
c_cond
id|pos
suffix:colon
id|end_size
)paren
suffix:semicolon
)brace
id|unlock
suffix:colon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
r_return
(paren
op_minus
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_inval_cached_pages&n; * &n; * This routine is responsible for keeping direct I/O and buffered I/O&n; * somewhat coherent.  From here we make sure that we&squot;re at least&n; * temporarily holding the inode I/O lock exclusively and then call&n; * the page cache to flush and invalidate any cached pages.  If there&n; * are no cached pages this routine will be very quick.&n; */
r_void
DECL|function|xfs_inval_cached_pages
id|xfs_inval_cached_pages
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
r_int
id|write
comma
r_int
id|relock
)paren
(brace
r_if
c_cond
(paren
id|VN_CACHED
c_func
(paren
id|vp
)paren
)paren
(brace
id|xfs_inval_cached_trace
c_func
(paren
id|io
comma
id|offset
comma
op_minus
l_int|1
comma
id|ctooff
c_func
(paren
id|offtoct
c_func
(paren
id|offset
)paren
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|VOP_FLUSHINVAL_PAGES
c_func
(paren
id|vp
comma
id|ctooff
c_func
(paren
id|offtoct
c_func
(paren
id|offset
)paren
)paren
comma
op_minus
l_int|1
comma
id|FI_REMAPF_LOCKED
)paren
suffix:semicolon
)brace
)brace
id|ssize_t
multiline_comment|/* bytes read, or (-)  error */
DECL|function|xfs_read
id|xfs_read
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_struct
id|iovec
op_star
id|iovp
comma
r_int
r_int
id|segs
comma
id|loff_t
op_star
id|offset
comma
r_int
id|ioflags
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|xfs_fsize_t
id|n
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
r_int
r_int
id|seg
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_read_calls
)paren
suffix:semicolon
multiline_comment|/* START copy &amp; waste from filemap.c */
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
r_const
r_struct
id|iovec
op_star
id|iv
op_assign
op_amp
id|iovp
(braket
id|seg
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If any segment has a negative length, or the cumulative&n;&t;&t; * length ever wraps negative then return -EINVAL.&n;&t;&t; */
id|size
op_add_assign
id|iv-&gt;iov_len
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|ssize_t
)paren
(paren
id|size
op_or
id|iv-&gt;iov_len
)paren
OL
l_int|0
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* END copy &amp; waste from filemap.c */
r_if
c_cond
(paren
id|ioflags
op_amp
id|IO_ISDIRECT
)paren
(brace
id|xfs_buftarg_t
op_star
id|target
op_assign
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
ques
c_cond
id|mp-&gt;m_rtdev_targp
suffix:colon
id|mp-&gt;m_ddev_targp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|offset
op_amp
id|target-&gt;pbr_smask
)paren
op_logical_or
(paren
id|size
op_amp
id|target-&gt;pbr_smask
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|offset
op_eq
id|ip-&gt;i_d.di_size
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
id|n
op_assign
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
op_minus
op_star
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_le
l_int|0
)paren
op_logical_or
(paren
id|size
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
id|size
)paren
id|size
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* OK so we are holding the I/O lock for the duration&n;&t; * of the submission, then what happens if the I/O&n;&t; * does not really happen here, but is scheduled &n;&t; * later?&n;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|ip
comma
id|DM_EVENT_READ
)paren
op_logical_and
op_logical_neg
(paren
id|ioflags
op_amp
id|IO_INVIS
)paren
)paren
(brace
id|vrwlock_t
id|locktype
op_assign
id|VRWLOCK_READ
suffix:semicolon
id|ret
op_assign
id|XFS_SEND_DATA
c_func
(paren
id|mp
comma
id|DM_EVENT_READ
comma
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
op_star
id|offset
comma
id|size
comma
id|FILP_DELAY_FLAG
c_func
(paren
id|file
)paren
comma
op_amp
id|locktype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_return
op_minus
id|ret
suffix:semicolon
)brace
)brace
id|xfs_rw_enter_trace
c_func
(paren
id|XFS_READ_ENTER
comma
op_amp
id|ip-&gt;i_iocore
comma
(paren
r_void
op_star
)paren
id|iovp
comma
id|segs
comma
op_star
id|offset
comma
id|ioflags
)paren
suffix:semicolon
id|ret
op_assign
id|__generic_file_aio_read
c_func
(paren
id|iocb
comma
id|iovp
comma
id|segs
comma
id|offset
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OG
l_int|0
)paren
id|XFS_STATS_ADD
c_func
(paren
id|xs_read_bytes
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
(paren
id|ioflags
op_amp
id|IO_INVIS
)paren
)paren
)paren
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_ACC
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ssize_t
DECL|function|xfs_sendfile
id|xfs_sendfile
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_struct
id|file
op_star
id|filp
comma
id|loff_t
op_star
id|offset
comma
r_int
id|ioflags
comma
r_int
id|count
comma
id|read_actor_t
id|actor
comma
r_void
op_star
id|target
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|ssize_t
id|ret
suffix:semicolon
id|xfs_fsize_t
id|n
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_read_calls
)paren
suffix:semicolon
id|n
op_assign
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
op_minus
op_star
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_le
l_int|0
)paren
op_logical_or
(paren
id|count
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
id|count
)paren
id|count
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|ip
comma
id|DM_EVENT_READ
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|ioflags
op_amp
id|IO_INVIS
)paren
)paren
)paren
(brace
id|vrwlock_t
id|locktype
op_assign
id|VRWLOCK_READ
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|XFS_SEND_DATA
c_func
(paren
id|mp
comma
id|DM_EVENT_READ
comma
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
op_star
id|offset
comma
id|count
comma
id|FILP_DELAY_FLAG
c_func
(paren
id|filp
)paren
comma
op_amp
id|locktype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
)brace
id|xfs_rw_enter_trace
c_func
(paren
id|XFS_SENDFILE_ENTER
comma
op_amp
id|ip-&gt;i_iocore
comma
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|target
comma
id|count
comma
op_star
id|offset
comma
id|ioflags
)paren
suffix:semicolon
id|ret
op_assign
id|generic_file_sendfile
c_func
(paren
id|filp
comma
id|offset
comma
id|count
comma
id|actor
comma
id|target
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
id|XFS_STATS_ADD
c_func
(paren
id|xs_read_bytes
comma
id|ret
)paren
suffix:semicolon
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_ACC
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to handle zeroing any space in the last&n; * block of the file that is beyond the EOF.  We do this since the&n; * size is being increased without writing anything to that block&n; * and we don&squot;t want anyone to read the garbage on the disk.&n; */
id|STATIC
r_int
multiline_comment|/* error (positive) */
DECL|function|xfs_zero_last_block
id|xfs_zero_last_block
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
id|xfs_fsize_t
id|isize
comma
id|xfs_fsize_t
id|end_size
)paren
(brace
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|zero_offset
suffix:semicolon
r_int
id|zero_len
suffix:semicolon
r_int
id|isize_fsb_offset
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
suffix:semicolon
id|loff_t
id|loff
suffix:semicolon
r_int
id|lsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
OG
id|isize
)paren
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|isize_fsb_offset
op_assign
id|XFS_B_FSB_OFFSET
c_func
(paren
id|mp
comma
id|isize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isize_fsb_offset
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * There are no extra bytes in the last block on disk to&n;&t;&t; * zero, so return.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|last_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|isize
)paren
suffix:semicolon
id|nimaps
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|last_fsb
comma
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nimaps
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the block underlying isize is just a hole, then there&n;&t; * is nothing to zero.&n;&t; */
r_if
c_cond
(paren
id|imap.br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero the part of the last block beyond the EOF, and write it&n;&t; * out sync.  We need to drop the ilock while we do this so we&n;&t; * don&squot;t deadlock when the buffer cache calls back to us.&n;&t; */
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|loff
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|last_fsb
)paren
suffix:semicolon
id|lsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
l_int|1
)paren
suffix:semicolon
id|zero_offset
op_assign
id|isize_fsb_offset
suffix:semicolon
id|zero_len
op_assign
id|mp-&gt;m_sb.sb_blocksize
op_minus
id|isize_fsb_offset
suffix:semicolon
id|error
op_assign
id|xfs_iozero
c_func
(paren
id|ip
comma
id|loff
op_plus
id|zero_offset
comma
id|zero_len
comma
id|end_size
)paren
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ge
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Zero any on disk space between the current EOF and the new,&n; * larger EOF.  This handles the normal case of zeroing the remainder&n; * of the last block in the file and the unusual case of zeroing blocks&n; * out beyond the size of the file.  This second case only happens&n; * with fixed size extents and when the system crashes before the inode&n; * size was updated but after blocks were allocated.  If fill is set,&n; * then any holes in the range are filled and zeroed.  If not, the holes&n; * are left alone as holes.&n; */
r_int
multiline_comment|/* error (positive) */
DECL|function|xfs_zero_eof
id|xfs_zero_eof
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
multiline_comment|/* starting I/O offset */
id|xfs_fsize_t
id|isize
comma
multiline_comment|/* current inode size */
id|xfs_fsize_t
id|end_size
)paren
multiline_comment|/* terminal inode size */
(brace
r_struct
id|inode
op_star
id|ip
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
suffix:semicolon
id|xfs_fileoff_t
id|start_zero_fsb
suffix:semicolon
id|xfs_fileoff_t
id|end_zero_fsb
suffix:semicolon
id|xfs_fileoff_t
id|prev_zero_fsb
suffix:semicolon
id|xfs_fileoff_t
id|zero_count_fsb
suffix:semicolon
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_extlen_t
id|buf_len_fsb
suffix:semicolon
id|xfs_extlen_t
id|prev_zero_count
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
suffix:semicolon
id|loff_t
id|loff
suffix:semicolon
r_int
id|lsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
multiline_comment|/*&n;&t; * First handle zeroing the block on which isize resides.&n;&t; * We only zero a part of that block so it is handled specially.&n;&t; */
id|error
op_assign
id|xfs_zero_last_block
c_func
(paren
id|ip
comma
id|io
comma
id|offset
comma
id|isize
comma
id|end_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate the range between the new size and the old&n;&t; * where blocks needing to be zeroed may exist.  To get the&n;&t; * block where the last byte in the file currently resides,&n;&t; * we need to subtract one from the size and truncate back&n;&t; * to a block boundary.  We subtract 1 in case the size is&n;&t; * exactly on a block boundary.&n;&t; */
id|last_fsb
op_assign
id|isize
ques
c_cond
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|isize
op_minus
l_int|1
)paren
suffix:colon
(paren
id|xfs_fileoff_t
)paren
op_minus
l_int|1
suffix:semicolon
id|start_zero_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|isize
)paren
suffix:semicolon
id|end_zero_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
op_minus
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|xfs_sfiloff_t
)paren
id|last_fsb
OL
(paren
id|xfs_sfiloff_t
)paren
id|start_zero_fsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_fsb
op_eq
id|end_zero_fsb
)paren
(brace
multiline_comment|/*&n;&t;&t; * The size was only incremented on its last block.&n;&t;&t; * We took care of that above, so just return.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|start_zero_fsb
op_le
id|end_zero_fsb
)paren
suffix:semicolon
id|prev_zero_fsb
op_assign
id|NULLFILEOFF
suffix:semicolon
id|prev_zero_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|start_zero_fsb
op_le
id|end_zero_fsb
)paren
(brace
id|nimaps
op_assign
l_int|1
suffix:semicolon
id|zero_count_fsb
op_assign
id|end_zero_fsb
op_minus
id|start_zero_fsb
op_plus
l_int|1
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|start_zero_fsb
comma
id|zero_count_fsb
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nimaps
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap.br_state
op_eq
id|XFS_EXT_UNWRITTEN
op_logical_or
id|imap.br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This loop handles initializing pages that were&n;&t;&t;&t; * partially initialized by the code below this&n;&t;&t;&t; * loop. It basically zeroes the part of the page&n;&t;&t;&t; * that sits on a hole and sets the page as P_HOLE&n;&t;&t;&t; * and calls remapf if it is a mapped file.&n;&t;&t;&t; */
id|prev_zero_fsb
op_assign
id|NULLFILEOFF
suffix:semicolon
id|prev_zero_count
op_assign
l_int|0
suffix:semicolon
id|start_zero_fsb
op_assign
id|imap.br_startoff
op_plus
id|imap.br_blockcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_zero_fsb
op_le
(paren
id|end_zero_fsb
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * There are blocks in the range requested.&n;&t;&t; * Zero them a single write at a time.  We actually&n;&t;&t; * don&squot;t zero the entire range returned if it is&n;&t;&t; * too big and simply loop around to get the rest.&n;&t;&t; * That is not the most efficient thing to do, but it&n;&t;&t; * is simple and this path should not be exercised often.&n;&t;&t; */
id|buf_len_fsb
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|imap.br_blockcount
comma
id|mp-&gt;m_writeio_blocks
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Drop the inode lock while we&squot;re doing the I/O.&n;&t;&t; * We&squot;ll still have the iolock to protect us.&n;&t;&t; */
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|loff
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|start_zero_fsb
)paren
suffix:semicolon
id|lsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|buf_len_fsb
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iozero
c_func
(paren
id|ip
comma
id|loff
comma
id|lsize
comma
id|end_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out_lock
suffix:semicolon
)brace
id|prev_zero_fsb
op_assign
id|start_zero_fsb
suffix:semicolon
id|prev_zero_count
op_assign
id|buf_len_fsb
suffix:semicolon
id|start_zero_fsb
op_assign
id|imap.br_startoff
op_plus
id|buf_len_fsb
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_zero_fsb
op_le
(paren
id|end_zero_fsb
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out_lock
suffix:colon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ge
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ssize_t
multiline_comment|/* bytes written, or (-) error */
DECL|function|xfs_write
id|xfs_write
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_struct
id|iovec
op_star
id|iovp
comma
r_int
r_int
id|nsegs
comma
id|loff_t
op_star
id|offset
comma
r_int
id|ioflags
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|file-&gt;f_mapping
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_int
r_int
id|segs
op_assign
id|nsegs
suffix:semicolon
id|xfs_inode_t
op_star
id|xip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_fsize_t
id|isize
comma
id|new_size
suffix:semicolon
id|xfs_iocore_t
op_star
id|io
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
r_int
r_int
id|seg
suffix:semicolon
r_int
id|iolock
suffix:semicolon
r_int
id|eventsent
op_assign
l_int|0
suffix:semicolon
id|vrwlock_t
id|locktype
suffix:semicolon
r_int
id|ocount
op_assign
l_int|0
comma
id|count
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
r_int
id|need_isem
op_assign
l_int|1
comma
id|need_flush
op_assign
l_int|0
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_write_calls
)paren
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
r_const
r_struct
id|iovec
op_star
id|iv
op_assign
op_amp
id|iovp
(braket
id|seg
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If any segment has a negative length, or the cumulative&n;&t;&t; * length ever wraps negative then return -EINVAL.&n;&t;&t; */
id|ocount
op_add_assign
id|iv-&gt;iov_len
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|ssize_t
)paren
(paren
id|ocount
op_or
id|iv-&gt;iov_len
)paren
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|iv-&gt;iov_base
comma
id|iv-&gt;iov_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|seg
op_eq
l_int|0
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|segs
op_assign
id|seg
suffix:semicolon
id|ocount
op_sub_assign
id|iv-&gt;iov_len
suffix:semicolon
multiline_comment|/* This segment is no good */
r_break
suffix:semicolon
)brace
id|count
op_assign
id|ocount
suffix:semicolon
id|pos
op_assign
op_star
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|io
op_assign
op_amp
id|xip-&gt;i_iocore
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ioflags
op_amp
id|IO_ISDIRECT
)paren
(brace
id|xfs_buftarg_t
op_star
id|target
op_assign
(paren
id|xip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
ques
c_cond
id|mp-&gt;m_rtdev_targp
suffix:colon
id|mp-&gt;m_ddev_targp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pos
op_amp
id|target-&gt;pbr_smask
)paren
op_logical_or
(paren
id|count
op_amp
id|target-&gt;pbr_smask
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|VN_CACHED
c_func
(paren
id|vp
)paren
op_logical_and
id|pos
OL
id|i_size_read
c_func
(paren
id|inode
)paren
)paren
id|need_isem
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|VN_CACHED
c_func
(paren
id|vp
)paren
)paren
id|need_flush
op_assign
l_int|1
suffix:semicolon
)brace
id|relock
suffix:colon
r_if
c_cond
(paren
id|need_isem
)paren
(brace
id|iolock
op_assign
id|XFS_IOLOCK_EXCL
suffix:semicolon
id|locktype
op_assign
id|VRWLOCK_WRITE
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
)brace
r_else
(brace
id|iolock
op_assign
id|XFS_IOLOCK_SHARED
suffix:semicolon
id|locktype
op_assign
id|VRWLOCK_WRITE_DIRECT
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
op_or
id|iolock
)paren
suffix:semicolon
id|isize
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
op_star
id|offset
op_assign
id|isize
suffix:semicolon
id|start
suffix:colon
id|error
op_assign
op_minus
id|generic_write_checks
c_func
(paren
id|file
comma
op_amp
id|pos
comma
op_amp
id|count
comma
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
op_or
id|iolock
)paren
suffix:semicolon
r_goto
id|out_unlock_isem
suffix:semicolon
)brace
id|new_size
op_assign
id|pos
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|new_size
OG
id|isize
)paren
id|io-&gt;io_new_size
op_assign
id|new_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|xip
comma
id|DM_EVENT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|ioflags
op_amp
id|IO_INVIS
)paren
op_logical_and
op_logical_neg
id|eventsent
)paren
)paren
(brace
id|loff_t
id|savedsize
op_assign
id|pos
suffix:semicolon
r_int
id|dmflags
op_assign
id|FILP_DELAY_FLAG
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_isem
)paren
id|dmflags
op_or_assign
id|DM_FLAGS_ISEM
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|XFS_SEND_DATA
c_func
(paren
id|xip-&gt;i_mount
comma
id|DM_EVENT_WRITE
comma
id|vp
comma
id|pos
comma
id|count
comma
id|dmflags
comma
op_amp
id|locktype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|iolock
)paren
suffix:semicolon
r_goto
id|out_unlock_isem
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|eventsent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The iolock was dropped and reaquired in XFS_SEND_DATA&n;&t;&t; * so we have to recheck the size when appending.&n;&t;&t; * We will only &quot;goto start;&quot; once, since having sent the&n;&t;&t; * event prevents another call to XFS_SEND_DATA, which is&n;&t;&t; * what allows the size to change in the first place.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
op_logical_and
id|savedsize
op_ne
id|isize
)paren
(brace
id|pos
op_assign
id|isize
op_assign
id|xip-&gt;i_d.di_size
suffix:semicolon
r_goto
id|start
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * On Linux, generic_file_write updates the times even if&n;&t; * no data is copied in so long as the write had a size.&n;&t; *&n;&t; * We must update xfs&squot; times since revalidate will overcopy xfs.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ioflags
op_amp
id|IO_INVIS
)paren
)paren
(brace
id|xfs_ichgtime
c_func
(paren
id|xip
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|inode_update_time
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the offset is beyond the size of the file, we have a couple&n;&t; * of things to do. First, if there is already space allocated&n;&t; * we need to either create holes or zero the disk or ...&n;&t; *&n;&t; * If there is a page where the previous size lands, we need&n;&t; * to zero it out up to the new size.&n;&t; */
r_if
c_cond
(paren
id|pos
OG
id|isize
)paren
(brace
id|error
op_assign
id|xfs_zero_eof
c_func
(paren
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
id|io
comma
id|pos
comma
id|isize
comma
id|pos
op_plus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
op_or
id|iolock
)paren
suffix:semicolon
r_goto
id|out_unlock_isem
suffix:semicolon
)brace
)brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re writing the file then make sure to clear the&n;&t; * setuid and setgid bits if the process is not being run&n;&t; * by root.  This keeps people from modifying setuid and&n;&t; * setgid binaries.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|xip-&gt;i_d.di_mode
op_amp
id|S_ISUID
)paren
op_logical_or
(paren
(paren
id|xip-&gt;i_d.di_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FSETID
)paren
)paren
(brace
id|error
op_assign
id|xfs_write_clear_setuid
c_func
(paren
id|xip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|error
)paren
)paren
id|error
op_assign
op_minus
id|remove_suid
c_func
(paren
id|file-&gt;f_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|iolock
)paren
suffix:semicolon
r_goto
id|out_unlock_isem
suffix:semicolon
)brace
)brace
id|retry
suffix:colon
multiline_comment|/* We can write back this queue in page reclaim */
id|current-&gt;backing_dev_info
op_assign
id|mapping-&gt;backing_dev_info
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ioflags
op_amp
id|IO_ISDIRECT
)paren
)paren
(brace
r_if
c_cond
(paren
id|need_flush
)paren
(brace
id|xfs_inval_cached_trace
c_func
(paren
id|io
comma
id|pos
comma
op_minus
l_int|1
comma
id|ctooff
c_func
(paren
id|offtoct
c_func
(paren
id|pos
)paren
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|VOP_FLUSHINVAL_PAGES
c_func
(paren
id|vp
comma
id|ctooff
c_func
(paren
id|offtoct
c_func
(paren
id|pos
)paren
)paren
comma
op_minus
l_int|1
comma
id|FI_REMAPF_LOCKED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_isem
)paren
(brace
multiline_comment|/* demote the lock now the cached pages are gone */
id|XFS_ILOCK_DEMOTE
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|iolock
op_assign
id|XFS_IOLOCK_SHARED
suffix:semicolon
id|locktype
op_assign
id|VRWLOCK_WRITE_DIRECT
suffix:semicolon
id|need_isem
op_assign
l_int|0
suffix:semicolon
)brace
id|xfs_rw_enter_trace
c_func
(paren
id|XFS_DIOWR_ENTER
comma
id|io
comma
(paren
r_void
op_star
)paren
id|iovp
comma
id|segs
comma
op_star
id|offset
comma
id|ioflags
)paren
suffix:semicolon
id|ret
op_assign
id|generic_file_direct_write
c_func
(paren
id|iocb
comma
id|iovp
comma
op_amp
id|segs
comma
id|pos
comma
id|offset
comma
id|count
comma
id|ocount
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * direct-io write to a hole: fall through to buffered I/O&n;&t;&t; * for completing the rest of the request.&n;&t;&t; */
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
op_logical_and
id|ret
op_ne
id|count
)paren
(brace
id|XFS_STATS_ADD
c_func
(paren
id|xs_write_bytes
comma
id|ret
)paren
suffix:semicolon
id|pos
op_add_assign
id|ret
suffix:semicolon
id|count
op_sub_assign
id|ret
suffix:semicolon
id|need_isem
op_assign
l_int|1
suffix:semicolon
id|ioflags
op_and_assign
op_complement
id|IO_ISDIRECT
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|iolock
)paren
suffix:semicolon
r_goto
id|relock
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_rw_enter_trace
c_func
(paren
id|XFS_WRITE_ENTER
comma
id|io
comma
(paren
r_void
op_star
)paren
id|iovp
comma
id|segs
comma
op_star
id|offset
comma
id|ioflags
)paren
suffix:semicolon
id|ret
op_assign
id|generic_file_buffered_write
c_func
(paren
id|iocb
comma
id|iovp
comma
id|segs
comma
id|pos
comma
id|offset
comma
id|count
comma
id|ret
)paren
suffix:semicolon
)brace
id|current-&gt;backing_dev_info
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ENOSPC
)paren
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|xip
comma
id|DM_EVENT_NOSPACE
)paren
op_logical_and
op_logical_neg
(paren
id|ioflags
op_amp
id|IO_INVIS
)paren
)paren
(brace
id|xfs_rwunlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
id|error
op_assign
id|XFS_SEND_NAMESP
c_func
(paren
id|xip-&gt;i_mount
comma
id|DM_EVENT_NOSPACE
comma
id|vp
comma
id|DM_RIGHT_NULL
comma
id|vp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Delay flag intentionally  unused */
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_unlock_isem
suffix:semicolon
id|xfs_rwlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
id|pos
op_assign
id|xip-&gt;i_d.di_size
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|offset
OG
id|xip-&gt;i_d.di_size
)paren
(brace
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
OG
id|xip-&gt;i_d.di_size
)paren
(brace
id|xip-&gt;i_d.di_size
op_assign
op_star
id|offset
suffix:semicolon
id|i_size_write
c_func
(paren
id|inode
comma
op_star
id|offset
)paren
suffix:semicolon
id|xip-&gt;i_update_core
op_assign
l_int|1
suffix:semicolon
id|xip-&gt;i_update_size
op_assign
l_int|1
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_le
l_int|0
)paren
(brace
id|xfs_rwunlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ret
suffix:semicolon
r_goto
id|out_unlock_isem
suffix:semicolon
)brace
id|XFS_STATS_ADD
c_func
(paren
id|xs_write_bytes
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/* Handle various SYNC-type writes */
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_SYNC
)paren
op_logical_or
id|IS_SYNC
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we&squot;re treating this as O_DSYNC and we have not updated the&n;&t;&t; * size, force the log.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_OSYNCISOSYNC
)paren
op_logical_and
op_logical_neg
(paren
id|xip-&gt;i_update_size
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If an allocation transaction occurred&n;&t;&t;&t; * without extending the size, then we have to force&n;&t;&t;&t; * the log up the proper point to ensure that the&n;&t;&t;&t; * allocation is permanent.  We can&squot;t count on&n;&t;&t;&t; * the fact that buffered writes lock out direct I/O&n;&t;&t;&t; * writes - the direct I/O write could have extended&n;&t;&t;&t; * the size nontransactionally, then finished before&n;&t;&t;&t; * we started.  xfs_write_file will think that the file&n;&t;&t;&t; * didn&squot;t grow but the update isn&squot;t safe unless the&n;&t;&t;&t; * size change is logged.&n;&t;&t;&t; *&n;&t;&t;&t; * Force the log if we&squot;ve committed a transaction&n;&t;&t;&t; * against the inode or if someone else has and&n;&t;&t;&t; * the commit record hasn&squot;t gone to disk (e.g.&n;&t;&t;&t; * the inode is pinned).  This guarantees that&n;&t;&t;&t; * all changes affecting the inode are permanent&n;&t;&t;&t; * when we return.&n;&t;&t;&t; */
id|xfs_inode_log_item_t
op_star
id|iip
suffix:semicolon
id|xfs_lsn_t
id|lsn
suffix:semicolon
id|iip
op_assign
id|xip-&gt;i_itemp
suffix:semicolon
r_if
c_cond
(paren
id|iip
op_logical_and
id|iip-&gt;ili_last_lsn
)paren
(brace
id|lsn
op_assign
id|iip-&gt;ili_last_lsn
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
id|lsn
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|xip
)paren
OG
l_int|0
)paren
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * O_SYNC or O_DSYNC _with_ a size update are handled&n;&t;&t;&t; * the same way.&n;&t;&t;&t; *&n;&t;&t;&t; * If the write was synchronous then we need to make&n;&t;&t;&t; * sure that the inode modification time is permanent.&n;&t;&t;&t; * We&squot;ll have updated the timestamp above, so here&n;&t;&t;&t; * we use a synchronous transaction to log the inode.&n;&t;&t;&t; * It&squot;s not fast, but it&squot;s necessary.&n;&t;&t;&t; *&n;&t;&t;&t; * If this a dsync write and the size got changed&n;&t;&t;&t; * non-transactionally, then we need to ensure that&n;&t;&t;&t; * the size change gets logged in a synchronous&n;&t;&t;&t; * transaction.&n;&t;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_WRITE_SYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_SWRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* Transaction reserve failed */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transaction reserve successful */
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|xip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|xip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* (ioflags &amp; O_SYNC) */
id|xfs_rwunlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ret
suffix:semicolon
id|out_unlock_isem
suffix:colon
r_if
c_cond
(paren
id|need_isem
)paren
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * All xfs metadata buffers except log state machine buffers&n; * get this attached as their b_bdstrat callback function.&n; * This is so that we can catch a buffer&n; * after prematurely unpinning it to forcibly shutdown the filesystem.&n; */
r_int
DECL|function|xfs_bdstrat_cb
id|xfs_bdstrat_cb
c_func
(paren
r_struct
id|xfs_buf
op_star
id|bp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|XFS_BUF_FSPRIVATE3
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|pagebuf_iorequest
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS__BDSTRAT IOERROR&quot;
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Metadata write that didn&squot;t get logged but&n;&t;&t; * written delayed anyway. These aren&squot;t associated&n;&t;&t; * with a transaction, and can be ignored.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_eq
l_int|NULL
op_logical_and
(paren
id|XFS_BUF_ISREAD
c_func
(paren
id|bp
)paren
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|xfs_bioerror_relse
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_else
r_return
(paren
id|xfs_bioerror
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|xfs_bmap
id|xfs_bmap
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|xfs_off_t
id|offset
comma
id|ssize_t
id|count
comma
r_int
id|flags
comma
id|xfs_iomap_t
op_star
id|iomapp
comma
r_int
op_star
id|niomaps
)paren
(brace
id|xfs_inode_t
op_star
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_iocore_t
op_star
id|io
op_assign
op_amp
id|ip-&gt;i_iocore
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFREG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
l_int|0
)paren
op_eq
(paren
(paren
id|ip-&gt;i_iocore.io_flags
op_amp
id|XFS_IOCORE_RT
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|xfs_iomap
c_func
(paren
id|io
comma
id|offset
comma
id|count
comma
id|flags
comma
id|iomapp
comma
id|niomaps
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wrapper around bdstrat so that we can stop data&n; * from going to disk in case we are shutting down the filesystem.&n; * Typically user data goes thru this path; one of the exceptions&n; * is the superblock.&n; */
r_int
DECL|function|xfsbdstrat
id|xfsbdstrat
c_func
(paren
r_struct
id|xfs_mount
op_star
id|mp
comma
r_struct
id|xfs_buf
op_star
id|bp
)paren
(brace
id|ASSERT
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
multiline_comment|/* Grio redirection would go here&n;&t;&t; * if (XFS_BUF_IS_GRIO(bp)) {&n;&t;&t; */
id|pagebuf_iorequest
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFSBDSTRAT IOERROR&quot;
comma
id|bp
)paren
suffix:semicolon
r_return
(paren
id|xfs_bioerror_relse
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If the underlying (data/log/rt) device is readonly, there are some&n; * operations that cannot proceed.&n; */
r_int
DECL|function|xfs_dev_is_read_only
id|xfs_dev_is_read_only
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_char
op_star
id|message
)paren
(brace
r_if
c_cond
(paren
id|xfs_readonly_buftarg
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
op_logical_or
id|xfs_readonly_buftarg
c_func
(paren
id|mp-&gt;m_logdev_targp
)paren
op_logical_or
(paren
id|mp-&gt;m_rtdev_targp
op_logical_and
id|xfs_readonly_buftarg
c_func
(paren
id|mp-&gt;m_rtdev_targp
)paren
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;XFS: %s required on read-only device.&quot;
comma
id|message
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;XFS: write access unavailable, cannot proceed.&quot;
)paren
suffix:semicolon
r_return
id|EROFS
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
