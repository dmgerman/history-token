multiline_comment|/*&n; * Copyright (c) 2000-2005 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_iomap.h&quot;
macro_line|#include &lt;linux/mpage.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
id|STATIC
r_void
id|xfs_count_page_state
c_func
(paren
r_struct
id|page
op_star
comma
r_int
op_star
comma
r_int
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_convert_page
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|page
op_star
comma
id|xfs_iomap_t
op_star
comma
r_struct
id|writeback_control
op_star
id|wbc
comma
r_void
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#if defined(XFS_RW_TRACE)
r_void
DECL|function|xfs_page_trace
id|xfs_page_trace
c_func
(paren
r_int
id|tag
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|mask
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|bhv_desc_t
op_star
id|bdp
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
suffix:semicolon
id|loff_t
id|isize
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
id|loff_t
id|offset
op_assign
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|delalloc
op_assign
op_minus
l_int|1
comma
id|unmapped
op_assign
op_minus
l_int|1
comma
id|unwritten
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|xfs_count_page_state
c_func
(paren
id|page
comma
op_amp
id|delalloc
comma
op_amp
id|unmapped
comma
op_amp
id|unwritten
)paren
suffix:semicolon
id|bdp
op_assign
id|vn_bhv_lookup
c_func
(paren
id|VN_BHV_HEAD
c_func
(paren
id|vp
)paren
comma
op_amp
id|xfs_vnodeops
)paren
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip-&gt;i_rwtrace
)paren
r_return
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|ip-&gt;i_rwtrace
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|tag
)paren
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
id|inode
comma
(paren
r_void
op_star
)paren
id|page
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|mask
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|ip-&gt;i_d.di_size
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|ip-&gt;i_d.di_size
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|isize
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|isize
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
(paren
id|offset
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|offset
op_amp
l_int|0xffffffff
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|delalloc
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|unmapped
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|unwritten
)paren
comma
(paren
r_void
op_star
)paren
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|xfs_page_trace
mdefine_line|#define xfs_page_trace(tag, inode, page, mask)
macro_line|#endif
r_void
DECL|function|linvfs_unwritten_done
id|linvfs_unwritten_done
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
id|xfs_buf_t
op_star
id|pb
op_assign
(paren
id|xfs_buf_t
op_star
)paren
id|bh-&gt;b_private
suffix:semicolon
id|ASSERT
c_func
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
l_int|NULL
suffix:semicolon
id|clear_buffer_unwritten
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|pagebuf_ioerror
c_func
(paren
id|pb
comma
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
op_eq
l_int|1
)paren
(brace
id|pagebuf_iodone
c_func
(paren
id|pb
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
id|end_buffer_async_write
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue transactions to convert a buffer range from unwritten&n; * to written extents (buffered IO).&n; */
id|STATIC
r_void
DECL|function|linvfs_unwritten_convert
id|linvfs_unwritten_convert
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|vnode_t
op_star
id|vp
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|vnode_t
op_star
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bp-&gt;pb_hold
)paren
OL
l_int|1
)paren
suffix:semicolon
id|VOP_BMAP
c_func
(paren
id|vp
comma
id|XFS_BUF_OFFSET
c_func
(paren
id|bp
)paren
comma
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
comma
id|BMAPI_UNWRITTEN
comma
l_int|NULL
comma
l_int|NULL
comma
id|error
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_BUF_CLR_IODONE_FUNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_UNDATAIO
c_func
(paren
id|bp
)paren
suffix:semicolon
id|iput
c_func
(paren
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
)paren
suffix:semicolon
id|pagebuf_iodone
c_func
(paren
id|bp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue transactions to convert a buffer range from unwritten&n; * to written extents (direct IO).&n; */
id|STATIC
r_void
DECL|function|linvfs_unwritten_convert_direct
id|linvfs_unwritten_convert_direct
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|offset
comma
id|ssize_t
id|size
comma
r_void
op_star
r_private
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
r_private
op_logical_or
id|inode
op_eq
(paren
r_struct
id|inode
op_star
)paren
r_private
)paren
suffix:semicolon
multiline_comment|/* private indicates an unwritten extent lay beneath this IO */
r_if
c_cond
(paren
r_private
op_logical_and
id|size
OG
l_int|0
)paren
(brace
id|vnode_t
op_star
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|VOP_BMAP
c_func
(paren
id|vp
comma
id|offset
comma
id|size
comma
id|BMAPI_UNWRITTEN
comma
l_int|NULL
comma
l_int|NULL
comma
id|error
)paren
suffix:semicolon
)brace
)brace
id|STATIC
r_int
DECL|function|xfs_map_blocks
id|xfs_map_blocks
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|offset
comma
id|ssize_t
id|count
comma
id|xfs_iomap_t
op_star
id|mapp
comma
r_int
id|flags
)paren
(brace
id|vnode_t
op_star
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|error
comma
id|nmaps
op_assign
l_int|1
suffix:semicolon
id|VOP_BMAP
c_func
(paren
id|vp
comma
id|offset
comma
id|count
comma
id|flags
comma
id|mapp
comma
op_amp
id|nmaps
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|flags
op_amp
(paren
id|BMAPI_WRITE
op_or
id|BMAPI_ALLOCATE
)paren
)paren
)paren
id|VMODIFY
c_func
(paren
id|vp
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Finds the corresponding mapping in block @map array of the&n; * given @offset within a @page.&n; */
id|STATIC
id|xfs_iomap_t
op_star
DECL|function|xfs_offset_to_map
id|xfs_offset_to_map
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|xfs_iomap_t
op_star
id|iomapp
comma
r_int
r_int
id|offset
)paren
(brace
id|loff_t
id|full_offset
suffix:semicolon
multiline_comment|/* offset from start of file */
id|ASSERT
c_func
(paren
id|offset
OL
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|full_offset
op_assign
id|page-&gt;index
suffix:semicolon
multiline_comment|/* NB: using 64bit number */
id|full_offset
op_lshift_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* offset from file start */
id|full_offset
op_add_assign
id|offset
suffix:semicolon
multiline_comment|/* offset from page start */
r_if
c_cond
(paren
id|full_offset
OL
id|iomapp-&gt;iomap_offset
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|iomapp-&gt;iomap_offset
op_plus
(paren
id|iomapp-&gt;iomap_bsize
op_minus
l_int|1
)paren
op_ge
id|full_offset
)paren
r_return
id|iomapp
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_map_at_offset
id|xfs_map_at_offset
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
r_int
id|offset
comma
r_int
id|block_bits
comma
id|xfs_iomap_t
op_star
id|iomapp
)paren
(brace
id|xfs_daddr_t
id|bn
suffix:semicolon
id|loff_t
id|delta
suffix:semicolon
r_int
id|sector_shift
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iomapp-&gt;iomap_flags
op_amp
id|IOMAP_HOLE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iomapp-&gt;iomap_flags
op_amp
id|IOMAP_DELAY
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iomapp-&gt;iomap_bn
op_ne
id|IOMAP_DADDR_NULL
)paren
suffix:semicolon
id|delta
op_assign
id|page-&gt;index
suffix:semicolon
id|delta
op_lshift_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|delta
op_add_assign
id|offset
suffix:semicolon
id|delta
op_sub_assign
id|iomapp-&gt;iomap_offset
suffix:semicolon
id|delta
op_rshift_assign
id|block_bits
suffix:semicolon
id|sector_shift
op_assign
id|block_bits
op_minus
id|BBSHIFT
suffix:semicolon
id|bn
op_assign
id|iomapp-&gt;iomap_bn
op_rshift
id|sector_shift
suffix:semicolon
id|bn
op_add_assign
id|delta
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bn
op_logical_and
op_logical_neg
(paren
id|iomapp-&gt;iomap_flags
op_amp
id|IOMAP_REALTIME
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|bn
op_lshift
id|sector_shift
)paren
op_ge
id|iomapp-&gt;iomap_bn
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|bn
suffix:semicolon
id|bh-&gt;b_bdev
op_assign
id|iomapp-&gt;iomap_target-&gt;pbr_bdev
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_delay
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for a page at index which is unlocked and contains our&n; * unwritten extent flagged buffers at its head.  Returns page&n; * locked and with an extra reference count, and length of the&n; * unwritten extent component on this page that we can write,&n; * in units of filesystem blocks.&n; */
id|STATIC
r_struct
id|page
op_star
DECL|function|xfs_probe_unwritten_page
id|xfs_probe_unwritten_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|index
comma
id|xfs_iomap_t
op_star
id|iomapp
comma
id|xfs_buf_t
op_star
id|pb
comma
r_int
r_int
id|max_offset
comma
r_int
r_int
op_star
id|fsbs
comma
r_int
r_int
id|bbits
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|find_trylock_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_and
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|p_offset
op_assign
l_int|0
suffix:semicolon
op_star
id|fsbs
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_unwritten
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_offset_to_map
c_func
(paren
id|page
comma
id|iomapp
comma
id|p_offset
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p_offset
op_ge
id|max_offset
)paren
r_break
suffix:semicolon
id|xfs_map_at_offset
c_func
(paren
id|page
comma
id|bh
comma
id|p_offset
comma
id|bbits
comma
id|iomapp
)paren
suffix:semicolon
id|set_buffer_unwritten_io
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_private
op_assign
id|pb
suffix:semicolon
id|p_offset
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
(paren
op_star
id|fsbs
)paren
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p_offset
)paren
r_return
id|page
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for a page at index which is unlocked and not mapped&n; * yet - clustering for mmap write case.&n; */
id|STATIC
r_int
r_int
DECL|function|xfs_probe_unmapped_page
id|xfs_probe_unmapped_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|pgoff_t
id|index
comma
r_int
r_int
id|pg_offset
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|page
op_assign
id|find_trylock_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_and
id|PageDirty
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_break
suffix:semicolon
id|ret
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
id|pg_offset
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|STATIC
r_int
r_int
DECL|function|xfs_probe_unmapped_cluster
id|xfs_probe_unmapped_cluster
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|startpage
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|buffer_head
op_star
id|head
)paren
(brace
id|pgoff_t
id|tindex
comma
id|tlast
comma
id|tloff
suffix:semicolon
r_int
r_int
id|pg_offset
comma
id|len
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
multiline_comment|/* First sum forwards in this page */
r_do
(brace
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_break
suffix:semicolon
id|total
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* If we reached the end of the page, sum forwards in&n;&t; * following pages.&n;&t; */
r_if
c_cond
(paren
id|bh
op_eq
id|head
)paren
(brace
id|tlast
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Prune this back to avoid pathological behavior */
id|tloff
op_assign
id|min
c_func
(paren
id|tlast
comma
id|startpage-&gt;index
op_plus
l_int|64
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tindex
op_assign
id|startpage-&gt;index
op_plus
l_int|1
suffix:semicolon
id|tindex
OL
id|tloff
suffix:semicolon
id|tindex
op_increment
)paren
(brace
id|len
op_assign
id|xfs_probe_unmapped_page
c_func
(paren
id|mapping
comma
id|tindex
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|total
suffix:semicolon
id|total
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tindex
op_eq
id|tlast
op_logical_and
(paren
id|pg_offset
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|total
op_add_assign
id|xfs_probe_unmapped_page
c_func
(paren
id|mapping
comma
id|tindex
comma
id|pg_offset
)paren
suffix:semicolon
)brace
)brace
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe for a given page (index) in the inode and test if it is delayed&n; * and without unwritten buffers.  Returns page locked and with an extra&n; * reference count.&n; */
id|STATIC
r_struct
id|page
op_star
DECL|function|xfs_probe_delalloc_page
id|xfs_probe_delalloc_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|pgoff_t
id|index
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|find_trylock_page
c_func
(paren
id|inode-&gt;i_mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;mapping
op_logical_and
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
id|acceptable
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
)paren
(brace
id|acceptable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|buffer_delay
c_func
(paren
id|bh
)paren
)paren
(brace
id|acceptable
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acceptable
)paren
r_return
id|page
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_map_unwritten
id|xfs_map_unwritten
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|start_page
comma
r_struct
id|buffer_head
op_star
id|head
comma
r_struct
id|buffer_head
op_star
id|curr
comma
r_int
r_int
id|p_offset
comma
r_int
id|block_bits
comma
id|xfs_iomap_t
op_star
id|iomapp
comma
r_struct
id|writeback_control
op_star
id|wbc
comma
r_int
id|startio
comma
r_int
id|all_bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|curr
suffix:semicolon
id|xfs_iomap_t
op_star
id|tmp
suffix:semicolon
id|xfs_buf_t
op_star
id|pb
suffix:semicolon
id|loff_t
id|offset
comma
id|size
suffix:semicolon
r_int
r_int
id|nblocks
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
id|start_page-&gt;index
suffix:semicolon
id|offset
op_lshift_assign
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_add_assign
id|p_offset
suffix:semicolon
multiline_comment|/* get an &quot;empty&quot; pagebuf to manage IO completion&n;&t; * Proper values will be set before returning */
id|pb
op_assign
id|pagebuf_lookup
c_func
(paren
id|iomapp-&gt;iomap_target
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pb
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* Take a reference to the inode to prevent it from&n;&t; * being reclaimed while we have outstanding unwritten&n;&t; * extent IO on it.&n;&t; */
r_if
c_cond
(paren
(paren
id|igrab
c_func
(paren
id|inode
)paren
)paren
op_ne
id|inode
)paren
(brace
id|pagebuf_free
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Set the count to 1 initially, this will stop an I/O&n;&t; * completion callout which happens before we have started&n;&t; * all the I/O from calling pagebuf_iodone too early.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* First map forwards in the page consecutive buffers&n;&t; * covering this unwritten extent&n;&t; */
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_unwritten
c_func
(paren
id|bh
)paren
)paren
r_break
suffix:semicolon
id|tmp
op_assign
id|xfs_offset_to_map
c_func
(paren
id|start_page
comma
id|iomapp
comma
id|p_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_break
suffix:semicolon
id|xfs_map_at_offset
c_func
(paren
id|start_page
comma
id|bh
comma
id|p_offset
comma
id|block_bits
comma
id|iomapp
)paren
suffix:semicolon
id|set_buffer_unwritten_io
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_private
op_assign
id|pb
suffix:semicolon
id|p_offset
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|nblocks
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|nblocks
comma
op_amp
id|pb-&gt;pb_io_remaining
)paren
suffix:semicolon
multiline_comment|/* If we reached the end of the page, map forwards in any&n;&t; * following pages which are also covered by this extent.&n;&t; */
r_if
c_cond
(paren
id|bh
op_eq
id|head
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
id|pgoff_t
id|tindex
comma
id|tloff
comma
id|tlast
suffix:semicolon
r_int
r_int
id|bs
suffix:semicolon
r_int
r_int
id|pg_offset
comma
id|bbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|tlast
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|tloff
op_assign
(paren
id|iomapp-&gt;iomap_offset
op_plus
id|iomapp-&gt;iomap_bsize
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|tloff
op_assign
id|min
c_func
(paren
id|tlast
comma
id|tloff
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tindex
op_assign
id|start_page-&gt;index
op_plus
l_int|1
suffix:semicolon
id|tindex
OL
id|tloff
suffix:semicolon
id|tindex
op_increment
)paren
(brace
id|page
op_assign
id|xfs_probe_unwritten_page
c_func
(paren
id|mapping
comma
id|tindex
comma
id|iomapp
comma
id|pb
comma
id|PAGE_CACHE_SIZE
comma
op_amp
id|bs
comma
id|bbits
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|nblocks
op_add_assign
id|bs
suffix:semicolon
id|atomic_add
c_func
(paren
id|bs
comma
op_amp
id|pb-&gt;pb_io_remaining
)paren
suffix:semicolon
id|xfs_convert_page
c_func
(paren
id|inode
comma
id|page
comma
id|iomapp
comma
id|wbc
comma
id|pb
comma
id|startio
comma
id|all_bh
)paren
suffix:semicolon
multiline_comment|/* stop if converting the next page might add&n;&t;&t;&t; * enough blocks that the corresponding byte&n;&t;&t;&t; * count won&squot;t fit in our ulong page buf length */
r_if
c_cond
(paren
id|nblocks
op_ge
(paren
(paren
id|ULONG_MAX
op_minus
id|PAGE_SIZE
)paren
op_rshift
id|block_bits
)paren
)paren
r_goto
id|enough
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tindex
op_eq
id|tlast
op_logical_and
(paren
id|pg_offset
op_assign
(paren
id|i_size_read
c_func
(paren
id|inode
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
)paren
(brace
id|page
op_assign
id|xfs_probe_unwritten_page
c_func
(paren
id|mapping
comma
id|tindex
comma
id|iomapp
comma
id|pb
comma
id|pg_offset
comma
op_amp
id|bs
comma
id|bbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|nblocks
op_add_assign
id|bs
suffix:semicolon
id|atomic_add
c_func
(paren
id|bs
comma
op_amp
id|pb-&gt;pb_io_remaining
)paren
suffix:semicolon
id|xfs_convert_page
c_func
(paren
id|inode
comma
id|page
comma
id|iomapp
comma
id|wbc
comma
id|pb
comma
id|startio
comma
id|all_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
op_ge
(paren
(paren
id|ULONG_MAX
op_minus
id|PAGE_SIZE
)paren
op_rshift
id|block_bits
)paren
)paren
r_goto
id|enough
suffix:semicolon
)brace
)brace
)brace
id|enough
suffix:colon
id|size
op_assign
id|nblocks
suffix:semicolon
multiline_comment|/* NB: using 64bit number here */
id|size
op_lshift_assign
id|block_bits
suffix:semicolon
multiline_comment|/* convert fsb&squot;s to byte range */
id|XFS_BUF_DATAIO
c_func
(paren
id|pb
)paren
suffix:semicolon
id|XFS_BUF_ASYNC
c_func
(paren
id|pb
)paren
suffix:semicolon
id|XFS_BUF_SET_SIZE
c_func
(paren
id|pb
comma
id|size
)paren
suffix:semicolon
id|XFS_BUF_SET_COUNT
c_func
(paren
id|pb
comma
id|size
)paren
suffix:semicolon
id|XFS_BUF_SET_OFFSET
c_func
(paren
id|pb
comma
id|offset
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|pb
comma
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|pb
comma
id|linvfs_unwritten_convert
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
op_eq
l_int|1
)paren
(brace
id|pagebuf_iodone
c_func
(paren
id|pb
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_submit_page
id|xfs_submit_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
comma
r_struct
id|buffer_head
op_star
id|bh_arr
(braket
)braket
comma
r_int
id|bh_count
comma
r_int
id|probed_page
comma
r_int
id|clear_dirty
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|i
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clear_dirty
)paren
id|clear_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh_count
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bh_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|bh_arr
(braket
id|i
)braket
suffix:semicolon
id|mark_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
)paren
id|set_buffer_unwritten_io
c_func
(paren
id|bh
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bh_count
suffix:semicolon
id|i
op_increment
)paren
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh_arr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probed_page
op_logical_and
id|clear_dirty
)paren
id|wbc-&gt;nr_to_write
op_decrement
suffix:semicolon
multiline_comment|/* Wrote an &quot;extra&quot; page */
)brace
r_else
(brace
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|wbc-&gt;pages_skipped
op_increment
suffix:semicolon
multiline_comment|/* We didn&squot;t write this page */
)brace
)brace
multiline_comment|/*&n; * Allocate &amp; map buffers for page given the extent map. Write it out.&n; * except for the original page of a writepage, this is called on&n; * delalloc/unwritten pages only, for the original page it is possible&n; * that the page has no mapping at all.&n; */
id|STATIC
r_void
DECL|function|xfs_convert_page
id|xfs_convert_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
id|xfs_iomap_t
op_star
id|iomapp
comma
r_struct
id|writeback_control
op_star
id|wbc
comma
r_void
op_star
r_private
comma
r_int
id|startio
comma
r_int
id|all_bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh_arr
(braket
id|MAX_BUF_PER_PAGE
)braket
comma
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|xfs_iomap_t
op_star
id|mp
op_assign
id|iomapp
comma
op_star
id|tmp
suffix:semicolon
r_int
r_int
id|end
comma
id|offset
suffix:semicolon
id|pgoff_t
id|end_index
suffix:semicolon
r_int
id|i
op_assign
l_int|0
comma
id|index
op_assign
l_int|0
suffix:semicolon
r_int
id|bbits
op_assign
id|inode-&gt;i_blkbits
suffix:semicolon
id|end_index
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
OL
id|end_index
)paren
(brace
id|end
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
)brace
r_else
(brace
id|end
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
id|offset
op_assign
id|i
op_lshift
id|bbits
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|end
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
op_logical_or
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|all_bh
op_logical_and
op_logical_neg
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_delay
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|startio
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh_arr
(braket
id|index
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|tmp
op_assign
id|xfs_offset_to_map
c_func
(paren
id|page
comma
id|mp
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_continue
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|tmp-&gt;iomap_flags
op_amp
id|IOMAP_HOLE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|tmp-&gt;iomap_flags
op_amp
id|IOMAP_DELAY
)paren
)paren
suffix:semicolon
multiline_comment|/* If this is a new unwritten extent buffer (i.e. one&n;&t;&t; * that we haven&squot;t passed in private data for, we must&n;&t;&t; * now map this buffer too.&n;&t;&t; */
r_if
c_cond
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|bh-&gt;b_end_io
)paren
(brace
id|ASSERT
c_func
(paren
id|tmp-&gt;iomap_flags
op_amp
id|IOMAP_UNWRITTEN
)paren
suffix:semicolon
id|xfs_map_unwritten
c_func
(paren
id|inode
comma
id|page
comma
id|head
comma
id|bh
comma
id|offset
comma
id|bbits
comma
id|tmp
comma
id|wbc
comma
id|startio
comma
id|all_bh
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|xfs_map_at_offset
c_func
(paren
id|page
comma
id|bh
comma
id|offset
comma
id|bbits
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
)paren
(brace
id|set_buffer_unwritten_io
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_private
op_assign
r_private
suffix:semicolon
id|ASSERT
c_func
(paren
r_private
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|startio
)paren
(brace
id|bh_arr
(braket
id|index
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_else
(brace
id|set_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startio
)paren
(brace
id|xfs_submit_page
c_func
(paren
id|page
comma
id|wbc
comma
id|bh_arr
comma
id|index
comma
l_int|1
comma
id|index
op_eq
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Convert &amp; write out a cluster of pages in the same extent as defined&n; * by mp and following the start page.&n; */
id|STATIC
r_void
DECL|function|xfs_cluster_write
id|xfs_cluster_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|pgoff_t
id|tindex
comma
id|xfs_iomap_t
op_star
id|iomapp
comma
r_struct
id|writeback_control
op_star
id|wbc
comma
r_int
id|startio
comma
r_int
id|all_bh
comma
id|pgoff_t
id|tlast
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tindex
op_le
id|tlast
suffix:semicolon
id|tindex
op_increment
)paren
(brace
id|page
op_assign
id|xfs_probe_delalloc_page
c_func
(paren
id|inode
comma
id|tindex
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|xfs_convert_page
c_func
(paren
id|inode
comma
id|page
comma
id|iomapp
comma
id|wbc
comma
l_int|NULL
comma
id|startio
comma
id|all_bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Calling this without startio set means we are being asked to make a dirty&n; * page ready for freeing it&squot;s buffers.  When called with startio set then&n; * we are coming from writepage.&n; *&n; * When called with startio set it is important that we write the WHOLE&n; * page if possible.&n; * The bh-&gt;b_state&squot;s cannot know if any of the blocks or which block for&n; * that matter are dirty due to mmap writes, and therefore bh uptodate is&n; * only vaild if the page itself isn&squot;t completely uptodate.  Some layers&n; * may clear the page dirty flag prior to calling write page, under the&n; * assumption the entire page will be written out; by not writing out the&n; * whole page the page can be reused before all valid dirty data is&n; * written out.  Note: in the case of a page that has been dirty&squot;d by&n; * mapwrite and but partially setup by block_prepare_write the&n; * bh-&gt;b_states&squot;s will not agree and only ones setup by BPW/BCW will have&n; * valid state, thus the whole page must be written out thing.&n; */
id|STATIC
r_int
DECL|function|xfs_page_state_convert
id|xfs_page_state_convert
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
comma
r_int
id|startio
comma
r_int
id|unmapped
)paren
multiline_comment|/* also implies page uptodate */
(brace
r_struct
id|buffer_head
op_star
id|bh_arr
(braket
id|MAX_BUF_PER_PAGE
)braket
comma
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|xfs_iomap_t
op_star
id|iomp
comma
id|iomap
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
r_int
r_int
id|p_offset
op_assign
l_int|0
suffix:semicolon
id|__uint64_t
id|end_offset
suffix:semicolon
id|pgoff_t
id|end_index
comma
id|last_index
comma
id|tlast
suffix:semicolon
r_int
id|len
comma
id|err
comma
id|i
comma
id|cnt
op_assign
l_int|0
comma
id|uptodate
op_assign
l_int|1
suffix:semicolon
r_int
id|flags
op_assign
id|startio
ques
c_cond
l_int|0
suffix:colon
id|BMAPI_TRYLOCK
suffix:semicolon
r_int
id|page_dirty
comma
id|delalloc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is this page beyond the end of the file? */
id|offset
op_assign
id|i_size_read
c_func
(paren
id|inode
)paren
suffix:semicolon
id|end_index
op_assign
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|last_index
op_assign
(paren
id|offset
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
)paren
(brace
r_if
c_cond
(paren
(paren
id|page-&gt;index
op_ge
id|end_index
op_plus
l_int|1
)paren
op_logical_or
op_logical_neg
(paren
id|i_size_read
c_func
(paren
id|inode
)paren
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
)brace
id|offset
op_assign
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|end_offset
op_assign
id|min_t
c_func
(paren
r_int
r_int
r_int
comma
id|offset
op_plus
id|PAGE_CACHE_SIZE
comma
id|i_size_read
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|iomp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * page_dirty is initially a count of buffers on the page and&n;&t; * is decrememted as we move each into a cleanable state.&n;&t; */
id|len
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|page_dirty
op_assign
id|PAGE_CACHE_SIZE
op_div
id|len
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|offset
op_ge
id|end_offset
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|uptodate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
op_logical_or
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
op_logical_and
op_logical_neg
id|startio
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|iomp
)paren
(brace
id|iomp
op_assign
id|xfs_offset_to_map
c_func
(paren
id|page
comma
op_amp
id|iomap
comma
id|p_offset
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * First case, map an unwritten extent and prepare for&n;&t;&t; * extent state conversion transaction on completion.&n;&t;&t; */
r_if
c_cond
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|startio
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iomp
)paren
(brace
id|err
op_assign
id|xfs_map_blocks
c_func
(paren
id|inode
comma
id|offset
comma
id|len
comma
op_amp
id|iomap
comma
id|BMAPI_READ
op_or
id|BMAPI_IGNSTATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|iomp
op_assign
id|xfs_offset_to_map
c_func
(paren
id|page
comma
op_amp
id|iomap
comma
id|p_offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iomp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_end_io
)paren
(brace
id|err
op_assign
id|xfs_map_unwritten
c_func
(paren
id|inode
comma
id|page
comma
id|head
comma
id|bh
comma
id|p_offset
comma
id|inode-&gt;i_blkbits
comma
id|iomp
comma
id|wbc
comma
id|startio
comma
id|unmapped
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
id|set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|bh_arr
(braket
id|cnt
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|page_dirty
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Second case, allocate space for a delalloc buffer.&n;&t;&t; * We can return EAGAIN here in the release page case.&n;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|buffer_delay
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iomp
)paren
(brace
id|delalloc
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
id|xfs_map_blocks
c_func
(paren
id|inode
comma
id|offset
comma
id|len
comma
op_amp
id|iomap
comma
id|BMAPI_ALLOCATE
op_or
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|iomp
op_assign
id|xfs_offset_to_map
c_func
(paren
id|page
comma
op_amp
id|iomap
comma
id|p_offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iomp
)paren
(brace
id|xfs_map_at_offset
c_func
(paren
id|page
comma
id|bh
comma
id|p_offset
comma
id|inode-&gt;i_blkbits
comma
id|iomp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startio
)paren
(brace
id|bh_arr
(braket
id|cnt
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_else
(brace
id|set_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|page_dirty
op_decrement
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_or
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
op_logical_and
(paren
id|unmapped
op_logical_or
id|startio
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
r_int
id|size
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Getting here implies an unmapped buffer&n;&t;&t;&t;&t; * was found, and we are in a path where we&n;&t;&t;&t;&t; * need to write the whole page out.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|iomp
)paren
(brace
id|size
op_assign
id|xfs_probe_unmapped_cluster
c_func
(paren
id|inode
comma
id|page
comma
id|bh
comma
id|head
)paren
suffix:semicolon
id|err
op_assign
id|xfs_map_blocks
c_func
(paren
id|inode
comma
id|offset
comma
id|size
comma
op_amp
id|iomap
comma
id|BMAPI_WRITE
op_or
id|BMAPI_MMAP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
id|iomp
op_assign
id|xfs_offset_to_map
c_func
(paren
id|page
comma
op_amp
id|iomap
comma
id|p_offset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iomp
)paren
(brace
id|xfs_map_at_offset
c_func
(paren
id|page
comma
id|bh
comma
id|p_offset
comma
id|inode-&gt;i_blkbits
comma
id|iomp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startio
)paren
(brace
id|bh_arr
(braket
id|cnt
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_else
(brace
id|set_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|page_dirty
op_decrement
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|startio
)paren
(brace
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
(brace
id|bh_arr
(braket
id|cnt
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|page_dirty
op_decrement
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|offset
op_add_assign
id|len
comma
id|p_offset
op_add_assign
id|len
comma
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
op_logical_and
id|bh
op_eq
id|head
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|startio
)paren
id|xfs_submit_page
c_func
(paren
id|page
comma
id|wbc
comma
id|bh_arr
comma
id|cnt
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iomp
)paren
(brace
id|tlast
op_assign
(paren
id|iomp-&gt;iomap_offset
op_plus
id|iomp-&gt;iomap_bsize
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|delalloc
op_logical_and
(paren
id|tlast
OG
id|last_index
)paren
)paren
id|tlast
op_assign
id|last_index
suffix:semicolon
id|xfs_cluster_write
c_func
(paren
id|inode
comma
id|page-&gt;index
op_plus
l_int|1
comma
id|iomp
comma
id|wbc
comma
id|startio
comma
id|unmapped
comma
id|tlast
)paren
suffix:semicolon
)brace
r_return
id|page_dirty
suffix:semicolon
id|error
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unlock_buffer
c_func
(paren
id|bh_arr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If it&squot;s delalloc and we have nowhere to put it,&n;&t; * throw it away, unless the lower layers told&n;&t; * us to try again.&n;&t; */
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|unmapped
)paren
(brace
id|block_invalidatepage
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
)brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|__linvfs_get_block
id|__linvfs_get_block
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|iblock
comma
r_int
r_int
id|blocks
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
comma
r_int
id|direct
comma
id|bmapi_flags_t
id|flags
)paren
(brace
id|vnode_t
op_star
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
suffix:semicolon
id|xfs_iomap_t
id|iomap
suffix:semicolon
r_int
id|retpbbm
op_assign
l_int|1
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
id|loff_t
id|offset
op_assign
(paren
id|loff_t
)paren
id|iblock
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
r_if
c_cond
(paren
id|blocks
)paren
id|size
op_assign
id|blocks
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
r_else
id|size
op_assign
l_int|1
op_lshift
id|inode-&gt;i_blkbits
suffix:semicolon
id|VOP_BMAP
c_func
(paren
id|vp
comma
id|offset
comma
id|size
comma
id|create
ques
c_cond
id|flags
suffix:colon
id|BMAPI_READ
comma
op_amp
id|iomap
comma
op_amp
id|retpbbm
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
op_minus
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retpbbm
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iomap.iomap_bn
op_ne
id|IOMAP_DADDR_NULL
)paren
(brace
id|xfs_daddr_t
id|bn
suffix:semicolon
id|loff_t
id|delta
suffix:semicolon
multiline_comment|/* For unwritten extents do not report a disk address on&n;&t;&t; * the read case (treat as if we&squot;re reading into a hole).&n;&t;&t; */
r_if
c_cond
(paren
id|create
op_logical_or
op_logical_neg
(paren
id|iomap.iomap_flags
op_amp
id|IOMAP_UNWRITTEN
)paren
)paren
(brace
id|delta
op_assign
id|offset
op_minus
id|iomap.iomap_offset
suffix:semicolon
id|delta
op_rshift_assign
id|inode-&gt;i_blkbits
suffix:semicolon
id|bn
op_assign
id|iomap.iomap_bn
op_rshift
(paren
id|inode-&gt;i_blkbits
op_minus
id|BBSHIFT
)paren
suffix:semicolon
id|bn
op_add_assign
id|delta
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bn
op_logical_and
op_logical_neg
(paren
id|iomap.iomap_flags
op_amp
id|IOMAP_REALTIME
)paren
)paren
suffix:semicolon
id|bh_result-&gt;b_blocknr
op_assign
id|bn
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh_result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|create
op_logical_and
(paren
id|iomap.iomap_flags
op_amp
id|IOMAP_UNWRITTEN
)paren
)paren
(brace
r_if
c_cond
(paren
id|direct
)paren
id|bh_result-&gt;b_private
op_assign
id|inode
suffix:semicolon
id|set_buffer_unwritten
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|set_buffer_delay
c_func
(paren
id|bh_result
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If this is a realtime file, data might be on a new device */
id|bh_result-&gt;b_bdev
op_assign
id|iomap.iomap_target-&gt;pbr_bdev
suffix:semicolon
multiline_comment|/* If we previously allocated a block out beyond eof and&n;&t; * we are now coming back to use it then we will need to&n;&t; * flag it as new even if it has a disk address.&n;&t; */
r_if
c_cond
(paren
id|create
op_logical_and
(paren
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh_result
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh_result
)paren
)paren
op_logical_or
(paren
id|offset
op_ge
id|i_size_read
c_func
(paren
id|inode
)paren
)paren
op_logical_or
(paren
id|iomap.iomap_flags
op_amp
id|IOMAP_NEW
)paren
)paren
)paren
(brace
id|set_buffer_new
c_func
(paren
id|bh_result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iomap.iomap_flags
op_amp
id|IOMAP_DELAY
)paren
(brace
id|BUG_ON
c_func
(paren
id|direct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|create
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh_result
)paren
suffix:semicolon
id|set_buffer_delay
c_func
(paren
id|bh_result
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|blocks
)paren
(brace
id|bh_result-&gt;b_size
op_assign
(paren
id|ssize_t
)paren
id|min
c_func
(paren
(paren
id|loff_t
)paren
(paren
id|iomap.iomap_bsize
op_minus
id|iomap.iomap_delta
)paren
comma
(paren
id|loff_t
)paren
(paren
id|blocks
op_lshift
id|inode-&gt;i_blkbits
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|linvfs_get_block
id|linvfs_get_block
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|iblock
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_return
id|__linvfs_get_block
c_func
(paren
id|inode
comma
id|iblock
comma
l_int|0
comma
id|bh_result
comma
id|create
comma
l_int|0
comma
id|BMAPI_WRITE
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|linvfs_get_blocks_direct
id|linvfs_get_blocks_direct
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|sector_t
id|iblock
comma
r_int
r_int
id|max_blocks
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_return
id|__linvfs_get_block
c_func
(paren
id|inode
comma
id|iblock
comma
id|max_blocks
comma
id|bh_result
comma
id|create
comma
l_int|1
comma
id|BMAPI_WRITE
op_or
id|BMAPI_DIRECT
)paren
suffix:semicolon
)brace
id|STATIC
id|ssize_t
DECL|function|linvfs_direct_IO
id|linvfs_direct_IO
c_func
(paren
r_int
id|rw
comma
r_struct
id|kiocb
op_star
id|iocb
comma
r_const
r_struct
id|iovec
op_star
id|iov
comma
id|loff_t
id|offset
comma
r_int
r_int
id|nr_segs
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|iocb-&gt;ki_filp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_mapping-&gt;host
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
suffix:semicolon
id|xfs_iomap_t
id|iomap
suffix:semicolon
r_int
id|maps
op_assign
l_int|1
suffix:semicolon
r_int
id|error
suffix:semicolon
id|VOP_BMAP
c_func
(paren
id|vp
comma
id|offset
comma
l_int|0
comma
id|BMAPI_DEVICE
comma
op_amp
id|iomap
comma
op_amp
id|maps
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
op_minus
id|error
suffix:semicolon
r_return
id|blockdev_direct_IO_own_locking
c_func
(paren
id|rw
comma
id|iocb
comma
id|inode
comma
id|iomap.iomap_target-&gt;pbr_bdev
comma
id|iov
comma
id|offset
comma
id|nr_segs
comma
id|linvfs_get_blocks_direct
comma
id|linvfs_unwritten_convert_direct
)paren
suffix:semicolon
)brace
id|STATIC
id|sector_t
DECL|function|linvfs_bmap
id|linvfs_bmap
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|sector_t
id|block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
(paren
r_struct
id|inode
op_star
)paren
id|mapping-&gt;host
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
l_string|&quot;linvfs_bmap&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|VOP_RWLOCK
c_func
(paren
id|vp
comma
id|VRWLOCK_READ
)paren
suffix:semicolon
id|VOP_FLUSH_PAGES
c_func
(paren
id|vp
comma
(paren
id|xfs_off_t
)paren
l_int|0
comma
op_minus
l_int|1
comma
l_int|0
comma
id|FI_REMAPF
comma
id|error
)paren
suffix:semicolon
id|VOP_RWUNLOCK
c_func
(paren
id|vp
comma
id|VRWLOCK_READ
)paren
suffix:semicolon
r_return
id|generic_block_bmap
c_func
(paren
id|mapping
comma
id|block
comma
id|linvfs_get_block
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|linvfs_readpage
id|linvfs_readpage
c_func
(paren
r_struct
id|file
op_star
id|unused
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|mpage_readpage
c_func
(paren
id|page
comma
id|linvfs_get_block
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|linvfs_readpages
id|linvfs_readpages
c_func
(paren
r_struct
id|file
op_star
id|unused
comma
r_struct
id|address_space
op_star
id|mapping
comma
r_struct
id|list_head
op_star
id|pages
comma
r_int
id|nr_pages
)paren
(brace
r_return
id|mpage_readpages
c_func
(paren
id|mapping
comma
id|pages
comma
id|nr_pages
comma
id|linvfs_get_block
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_count_page_state
id|xfs_count_page_state
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
op_star
id|delalloc
comma
r_int
op_star
id|unmapped
comma
r_int
op_star
id|unwritten
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
op_star
id|delalloc
op_assign
op_star
id|unmapped
op_assign
op_star
id|unwritten
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(paren
op_star
id|unmapped
)paren
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_delay
c_func
(paren
id|bh
)paren
)paren
id|clear_buffer_unwritten
c_func
(paren
id|bh
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buffer_unwritten
c_func
(paren
id|bh
)paren
)paren
(paren
op_star
id|unwritten
)paren
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buffer_delay
c_func
(paren
id|bh
)paren
)paren
(paren
op_star
id|delalloc
)paren
op_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * writepage: Called from one of two places:&n; *&n; * 1. we are flushing a delalloc buffer head.&n; *&n; * 2. we are writing out a dirty page. Typically the page dirty&n; *    state is cleared before we get here. In this case is it&n; *    conceivable we have no buffer heads.&n; *&n; * For delalloc space on the page we need to allocate space and&n; * flush it. For unmapped buffer heads on the page we should&n; * allocate space if the page is uptodate. For any other dirty&n; * buffer heads on the page we should flush them.&n; *&n; * If we detect that a transaction would be required to flush&n; * the page, we have to check the process flags first, if we&n; * are already in a transaction or disk I/O during allocations&n; * is off, we need to fail the writepage and redirty the page.&n; */
id|STATIC
r_int
DECL|function|linvfs_writepage
id|linvfs_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|need_trans
suffix:semicolon
r_int
id|delalloc
comma
id|unmapped
comma
id|unwritten
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|xfs_page_trace
c_func
(paren
id|XFS_WRITEPAGE_ENTER
comma
id|inode
comma
id|page
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need a transaction if:&n;&t; *  1. There are delalloc buffers on the page&n;&t; *  2. The page is uptodate and we have unmapped buffers&n;&t; *  3. The page is uptodate and we have no buffers&n;&t; *  4. There are unwritten buffers on the page&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|unmapped
op_assign
l_int|1
suffix:semicolon
id|need_trans
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|xfs_count_page_state
c_func
(paren
id|page
comma
op_amp
id|delalloc
comma
op_amp
id|unmapped
comma
op_amp
id|unwritten
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
id|unmapped
op_assign
l_int|0
suffix:semicolon
id|need_trans
op_assign
id|delalloc
op_plus
id|unmapped
op_plus
id|unwritten
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we need a transaction and the process flags say&n;&t; * we are already in a transaction, or no IO is allowed&n;&t; * then mark the page dirty again and leave the page&n;&t; * as is.&n;&t; */
r_if
c_cond
(paren
id|PFLAGS_TEST_FSTRANS
c_func
(paren
)paren
op_logical_and
id|need_trans
)paren
r_goto
id|out_fail
suffix:semicolon
multiline_comment|/*&n;&t; * Delay hooking up buffer heads until we have&n;&t; * made our go/no-go decision.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
l_int|1
op_lshift
id|inode-&gt;i_blkbits
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert delayed allocate, unwritten or unmapped space&n;&t; * to real space and flush out to disk.&n;&t; */
id|error
op_assign
id|xfs_page_state_convert
c_func
(paren
id|inode
comma
id|page
comma
id|wbc
comma
l_int|1
comma
id|unmapped
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EAGAIN
)paren
r_goto
id|out_fail
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
OL
l_int|0
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_fail
suffix:colon
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_unlock
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called to move a page into cleanable state - and from there&n; * to be released. Possibly the page is already clean. We always&n; * have buffer heads in this call.&n; *&n; * Returns 0 if the page is ok to release, 1 otherwise.&n; *&n; * Possible scenarios are:&n; *&n; * 1. We are being called to release a page which has been written&n; *    to via regular I/O. buffer heads will be dirty and possibly&n; *    delalloc. If no delalloc buffer heads in this case then we&n; *    can just return zero.&n; *&n; * 2. We are called to release a page which has been written via&n; *    mmap, all we need to do is ensure there is no delalloc&n; *    state in the buffer heads, if not we can let the caller&n; *    free them and we should come back later via writepage.&n; */
id|STATIC
r_int
DECL|function|linvfs_release_page
id|linvfs_release_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
id|dirty
comma
id|delalloc
comma
id|unmapped
comma
id|unwritten
suffix:semicolon
r_struct
id|writeback_control
id|wbc
op_assign
(brace
dot
id|sync_mode
op_assign
id|WB_SYNC_ALL
comma
dot
id|nr_to_write
op_assign
l_int|1
comma
)brace
suffix:semicolon
id|xfs_page_trace
c_func
(paren
id|XFS_RELEASEPAGE_ENTER
comma
id|inode
comma
id|page
comma
id|gfp_mask
)paren
suffix:semicolon
id|xfs_count_page_state
c_func
(paren
id|page
comma
op_amp
id|delalloc
comma
op_amp
id|unmapped
comma
op_amp
id|unwritten
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|delalloc
op_logical_and
op_logical_neg
id|unwritten
)paren
r_goto
id|free_buffers
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gfp_mask
op_amp
id|__GFP_FS
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If we are already inside a transaction or the thread cannot&n;&t; * do I/O, we cannot release this page.&n;&t; */
r_if
c_cond
(paren
id|PFLAGS_TEST_FSTRANS
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Convert delalloc space to real space, do not flush the&n;&t; * data out to disk, that will be done by the caller.&n;&t; * Never need to allocate space here - we will always&n;&t; * come back to writepage in that case.&n;&t; */
id|dirty
op_assign
id|xfs_page_state_convert
c_func
(paren
id|inode
comma
id|page
comma
op_amp
id|wbc
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dirty
op_eq
l_int|0
op_logical_and
op_logical_neg
id|unwritten
)paren
r_goto
id|free_buffers
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free_buffers
suffix:colon
r_return
id|try_to_free_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|linvfs_prepare_write
id|linvfs_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|from
comma
r_int
r_int
id|to
)paren
(brace
r_return
id|block_prepare_write
c_func
(paren
id|page
comma
id|from
comma
id|to
comma
id|linvfs_get_block
)paren
suffix:semicolon
)brace
DECL|variable|linvfs_aops
r_struct
id|address_space_operations
id|linvfs_aops
op_assign
(brace
dot
id|readpage
op_assign
id|linvfs_readpage
comma
dot
id|readpages
op_assign
id|linvfs_readpages
comma
dot
id|writepage
op_assign
id|linvfs_writepage
comma
dot
id|sync_page
op_assign
id|block_sync_page
comma
dot
id|releasepage
op_assign
id|linvfs_release_page
comma
dot
id|prepare_write
op_assign
id|linvfs_prepare_write
comma
dot
id|commit_write
op_assign
id|generic_commit_write
comma
dot
id|bmap
op_assign
id|linvfs_bmap
comma
dot
id|direct_IO
op_assign
id|linvfs_direct_IO
comma
)brace
suffix:semicolon
eof
