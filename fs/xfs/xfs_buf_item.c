multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * This file contains the implementation of the xfs_buf_log_item.&n; * It contains the item operations used to manipulate the buf log&n; * items as well as utility routines used by the buffer specific&n; * transaction routines.&n; */
macro_line|#include &lt;xfs.h&gt;
DECL|macro|ROUNDUPNBWORD
mdefine_line|#define ROUNDUPNBWORD(x)&t;(((x) + (NBWORD - 1)) &amp; ~(NBWORD - 1))
DECL|variable|xfs_buf_item_zone
id|kmem_zone_t
op_star
id|xfs_buf_item_zone
suffix:semicolon
macro_line|#ifdef XFS_TRANS_DEBUG
multiline_comment|/*&n; * This function uses an alternate strategy for tracking the bytes&n; * that the user requests to be logged.&t; This can then be used&n; * in conjunction with the bli_orig array in the buf log item to&n; * catch bugs in our callers&squot; code.&n; *&n; * We also double check the bits set in xfs_buf_item_log using a&n; * simple algorithm to check that every byte is accounted for.&n; */
id|STATIC
r_void
DECL|function|xfs_buf_item_log_debug
id|xfs_buf_item_log_debug
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
comma
id|uint
id|first
comma
id|uint
id|last
)paren
(brace
id|uint
id|x
suffix:semicolon
id|uint
id|byte
suffix:semicolon
id|uint
id|nbytes
suffix:semicolon
id|uint
id|chunk_num
suffix:semicolon
id|uint
id|word_num
suffix:semicolon
id|uint
id|bit_num
suffix:semicolon
id|uint
id|bit_set
suffix:semicolon
id|uint
op_star
id|wordp
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_logged
op_ne
l_int|NULL
)paren
suffix:semicolon
id|byte
op_assign
id|first
suffix:semicolon
id|nbytes
op_assign
id|last
op_minus
id|first
op_plus
l_int|1
suffix:semicolon
id|bfset
c_func
(paren
id|bip-&gt;bli_logged
comma
id|first
comma
id|nbytes
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|nbytes
suffix:semicolon
id|x
op_increment
)paren
(brace
id|chunk_num
op_assign
id|byte
op_rshift
id|XFS_BLI_SHIFT
suffix:semicolon
id|word_num
op_assign
id|chunk_num
op_rshift
id|BIT_TO_WORD_SHIFT
suffix:semicolon
id|bit_num
op_assign
id|chunk_num
op_amp
(paren
id|NBWORD
op_minus
l_int|1
)paren
suffix:semicolon
id|wordp
op_assign
op_amp
(paren
id|bip-&gt;bli_format.blf_data_map
(braket
id|word_num
)braket
)paren
suffix:semicolon
id|bit_set
op_assign
op_star
id|wordp
op_amp
(paren
l_int|1
op_lshift
id|bit_num
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bit_set
)paren
suffix:semicolon
id|byte
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function is called when we flush something into a buffer without&n; * logging it.&t;This happens for things like inodes which are logged&n; * separately from the buffer.&n; */
r_void
DECL|function|xfs_buf_item_flush_log_debug
id|xfs_buf_item_flush_log_debug
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|uint
id|first
comma
id|uint
id|last
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|uint
id|nbytes
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bip
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|bip-&gt;bli_item.li_type
op_ne
id|XFS_LI_BUF
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bip-&gt;bli_logged
op_ne
l_int|NULL
)paren
suffix:semicolon
id|nbytes
op_assign
id|last
op_minus
id|first
op_plus
l_int|1
suffix:semicolon
id|bfset
c_func
(paren
id|bip-&gt;bli_logged
comma
id|first
comma
id|nbytes
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called to verify that our caller&squot;s have logged&n; * all the bytes that they changed.&n; *&n; * It does this by comparing the original copy of the buffer stored in&n; * the buf log item&squot;s bli_orig array to the current copy of the buffer&n; * and ensuring that all bytes which miscompare are set in the bli_logged&n; * array of the buf log item.&n; */
id|STATIC
r_void
DECL|function|xfs_buf_item_log_check
id|xfs_buf_item_log_check
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
r_char
op_star
id|orig
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_int
id|x
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_orig
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_logged
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|orig
op_assign
id|bip-&gt;bli_orig
suffix:semicolon
id|buffer
op_assign
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|x
op_increment
)paren
(brace
r_if
c_cond
(paren
id|orig
(braket
id|x
)braket
op_ne
id|buffer
(braket
id|x
)braket
op_logical_and
op_logical_neg
id|btst
c_func
(paren
id|bip-&gt;bli_logged
comma
id|x
)paren
)paren
id|cmn_err
c_func
(paren
id|CE_PANIC
comma
l_string|&quot;xfs_buf_item_log_check bip %x buffer %x orig %x index %d&quot;
comma
id|bip
comma
id|bp
comma
id|orig
comma
id|x
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|xfs_buf_item_log_debug
mdefine_line|#define&t;&t;xfs_buf_item_log_debug(x,y,z)
DECL|macro|xfs_buf_item_log_check
mdefine_line|#define&t;&t;xfs_buf_item_log_check(x)
macro_line|#endif
id|STATIC
r_void
id|xfs_buf_error_relse
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n; * This returns the number of log iovecs needed to log the&n; * given buf log item.&n; *&n; * It calculates this as 1 iovec for the buf log format structure&n; * and 1 for each stretch of non-contiguous chunks to be logged.&n; * Contiguous chunks are logged in a single iovec.&n; *&n; * If the XFS_BLI_STALE flag has been set, then log nothing.&n; */
id|uint
DECL|function|xfs_buf_item_size
id|xfs_buf_item_size
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
id|uint
id|nvecs
suffix:semicolon
r_int
id|next_bit
suffix:semicolon
r_int
id|last_bit
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
(brace
multiline_comment|/*&n;&t;&t; * The buffer is stale, so all we need to log&n;&t;&t; * is the buf log format structure with the&n;&t;&t; * cancel flag in it.&n;&t;&t; */
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;SIZE STALE&quot;
comma
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
suffix:semicolon
id|nvecs
op_assign
l_int|1
suffix:semicolon
id|last_bit
op_assign
id|xfs_next_bit
c_func
(paren
id|bip-&gt;bli_format.blf_data_map
comma
id|bip-&gt;bli_format.blf_map_size
comma
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|last_bit
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|last_bit
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * This takes the bit number to start looking from and&n;&t;&t; * returns the next set bit from there.&t; It returns -1&n;&t;&t; * if there are no more bits set or the start bit is&n;&t;&t; * beyond the end of the bitmap.&n;&t;&t; */
id|next_bit
op_assign
id|xfs_next_bit
c_func
(paren
id|bip-&gt;bli_format.blf_data_map
comma
id|bip-&gt;bli_format.blf_map_size
comma
id|last_bit
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we run out of bits, leave the loop,&n;&t;&t; * else if we find a new set of bits bump the number of vecs,&n;&t;&t; * else keep scanning the current set of bits.&n;&t;&t; */
r_if
c_cond
(paren
id|next_bit
op_eq
op_minus
l_int|1
)paren
(brace
id|last_bit
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|next_bit
op_ne
id|last_bit
op_plus
l_int|1
)paren
(brace
id|last_bit
op_assign
id|next_bit
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|next_bit
op_star
id|XFS_BLI_CHUNK
)paren
op_ne
(paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|last_bit
op_star
id|XFS_BLI_CHUNK
)paren
op_plus
id|XFS_BLI_CHUNK
)paren
)paren
(brace
id|last_bit
op_assign
id|next_bit
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|last_bit
op_increment
suffix:semicolon
)brace
)brace
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;SIZE NORM&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
id|nvecs
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to fill in the vector of log iovecs for the&n; * given log buf item.&t;It fills the first entry with a buf log&n; * format structure, and the rest point to contiguous chunks&n; * within the buffer.&n; */
r_void
DECL|function|xfs_buf_item_format
id|xfs_buf_item_format
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
comma
id|xfs_log_iovec_t
op_star
id|log_vector
)paren
(brace
id|uint
id|base_size
suffix:semicolon
id|uint
id|nvecs
suffix:semicolon
id|xfs_log_iovec_t
op_star
id|vecp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|first_bit
suffix:semicolon
r_int
id|last_bit
suffix:semicolon
r_int
id|next_bit
suffix:semicolon
id|uint
id|nbits
suffix:semicolon
id|uint
id|buffer_offset
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
op_logical_or
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_BP_ISMAPPED
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|vecp
op_assign
id|log_vector
suffix:semicolon
multiline_comment|/*&n;&t; * The size of the base structure is the size of the&n;&t; * declared structure plus the space for the extra words&n;&t; * of the bitmap.  We subtract one from the map size, because&n;&t; * the first element of the bitmap is accounted for in the&n;&t; * size of the base structure.&n;&t; */
id|base_size
op_assign
(paren
id|uint
)paren
(paren
r_sizeof
(paren
id|xfs_buf_log_format_t
)paren
op_plus
(paren
(paren
id|bip-&gt;bli_format.blf_map_size
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|uint
)paren
)paren
)paren
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
op_amp
id|bip-&gt;bli_format
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|base_size
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
(brace
multiline_comment|/*&n;&t;&t; * The buffer is stale, so all we need to log&n;&t;&t; * is the buf log format structure with the&n;&t;&t; * cancel flag in it.&n;&t;&t; */
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;FORMAT STALE&quot;
comma
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
suffix:semicolon
id|bip-&gt;bli_format.blf_size
op_assign
id|nvecs
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in an iovec for each set of contiguous chunks.&n;&t; */
id|first_bit
op_assign
id|xfs_next_bit
c_func
(paren
id|bip-&gt;bli_format.blf_data_map
comma
id|bip-&gt;bli_format.blf_map_size
comma
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|first_bit
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|last_bit
op_assign
id|first_bit
suffix:semicolon
id|nbits
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * This takes the bit number to start looking from and&n;&t;&t; * returns the next set bit from there.&t; It returns -1&n;&t;&t; * if there are no more bits set or the start bit is&n;&t;&t; * beyond the end of the bitmap.&n;&t;&t; */
id|next_bit
op_assign
id|xfs_next_bit
c_func
(paren
id|bip-&gt;bli_format.blf_data_map
comma
id|bip-&gt;bli_format.blf_map_size
comma
(paren
id|uint
)paren
id|last_bit
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we run out of bits fill in the last iovec and get&n;&t;&t; * out of the loop.&n;&t;&t; * Else if we start a new set of bits then fill in the&n;&t;&t; * iovec for the series we were looking at and start&n;&t;&t; * counting the bits in the new one.&n;&t;&t; * Else we&squot;re still in the same set of bits so just&n;&t;&t; * keep counting and scanning.&n;&t;&t; */
r_if
c_cond
(paren
id|next_bit
op_eq
op_minus
l_int|1
)paren
(brace
id|buffer_offset
op_assign
id|first_bit
op_star
id|XFS_BLI_CHUNK
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|buffer_offset
)paren
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|nbits
op_star
id|XFS_BLI_CHUNK
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|next_bit
op_ne
id|last_bit
op_plus
l_int|1
)paren
(brace
id|buffer_offset
op_assign
id|first_bit
op_star
id|XFS_BLI_CHUNK
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|buffer_offset
)paren
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|nbits
op_star
id|XFS_BLI_CHUNK
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|first_bit
op_assign
id|next_bit
suffix:semicolon
id|last_bit
op_assign
id|next_bit
suffix:semicolon
id|nbits
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|next_bit
op_lshift
id|XFS_BLI_SHIFT
)paren
op_ne
(paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|last_bit
op_lshift
id|XFS_BLI_SHIFT
)paren
op_plus
id|XFS_BLI_CHUNK
)paren
)paren
(brace
id|buffer_offset
op_assign
id|first_bit
op_star
id|XFS_BLI_CHUNK
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|buffer_offset
)paren
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|nbits
op_star
id|XFS_BLI_CHUNK
suffix:semicolon
multiline_comment|/* You would think we need to bump the nvecs here too, but we do not&n; * this number is used by recovery, and it gets confused by the boundary&n; * split here&n; *&t;&t;&t;nvecs++;&n; */
id|vecp
op_increment
suffix:semicolon
id|first_bit
op_assign
id|next_bit
suffix:semicolon
id|last_bit
op_assign
id|next_bit
suffix:semicolon
id|nbits
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|last_bit
op_increment
suffix:semicolon
id|nbits
op_increment
suffix:semicolon
)brace
)brace
id|bip-&gt;bli_format.blf_size
op_assign
id|nvecs
suffix:semicolon
multiline_comment|/*&n;&t; * Check to make sure everything is consistent.&n;&t; */
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;FORMAT NORM&quot;
comma
id|bip
)paren
suffix:semicolon
id|xfs_buf_item_log_check
c_func
(paren
id|bip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to pin the buffer associated with the buf log&n; * item in memory so it cannot be written out.&t;Simply call bpin()&n; * on the buffer to do this.&n; */
r_void
DECL|function|xfs_buf_item_pin
id|xfs_buf_item_pin
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
op_logical_or
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;PIN&quot;
comma
id|bip
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_PIN&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_bpin
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to unpin the buffer associated with the buf log&n; * item which was previously pinned with a call to xfs_buf_item_pin().&n; * Just call bunpin() on the buffer to do this.&n; *&n; * Also drop the reference to the buf item for the current transaction.&n; * If the XFS_BLI_STALE flag is set and we are the last reference,&n; * then free up the buf log item and unlock the buffer.&n; */
r_void
DECL|function|xfs_buf_item_unpin
id|xfs_buf_item_unpin
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
comma
r_int
id|stale
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|freed
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
op_eq
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
OG
l_int|0
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;UNPIN&quot;
comma
id|bip
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_UNPIN&quot;
comma
id|bp
)paren
suffix:semicolon
id|freed
op_assign
id|atomic_dec_and_test
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
suffix:semicolon
id|mp
op_assign
id|bip-&gt;bli_item.li_mountp
suffix:semicolon
id|xfs_bunpin
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|freed
op_logical_and
id|stale
)paren
(brace
id|ASSERT
c_func
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISSTALE
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
multiline_comment|/**&n;&t;&t;ASSERT(bp-&gt;b_pincount == 0);&n;**/
id|ASSERT
c_func
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;UNPIN STALE&quot;
comma
id|bip
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_UNPIN STALE&quot;
comma
id|bp
)paren
suffix:semicolon
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we get called here because of an IO error, we may&n;&t;&t; * or may not have the item on the AIL. xfs_trans_delete_ail()&n;&t;&t; * will take care of that situation.&n;&t;&t; * xfs_trans_delete_ail() drops the AIL lock.&n;&t;&t; */
id|xfs_trans_delete_ail
c_func
(paren
id|mp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
comma
id|s
)paren
suffix:semicolon
id|xfs_buf_item_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_eq
l_int|NULL
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * this is called from uncommit in the forced-shutdown path.&n; * we need to check to see if the reference count on the log item&n; * is going to drop to zero.  If so, unpin will free the log item&n; * so we need to free the item&squot;s descriptor (that points to the item)&n; * in the transaction.&n; */
r_void
DECL|function|xfs_buf_item_unpin_remove
id|xfs_buf_item_unpin_remove
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
comma
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
r_int
id|stale
op_assign
l_int|0
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
multiline_comment|/*&n;&t; * will xfs_buf_item_unpin() call xfs_buf_item_relse()?&n;&t; */
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
op_eq
l_int|1
)paren
op_logical_and
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bip-&gt;bli_buf
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;UNPIN REMOVE&quot;
comma
id|bip
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_UNPIN_REMOVE&quot;
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * yes -- clear the xaction descriptor in-use flag&n;&t;&t; * and free the chunk if required.  We can safely&n;&t;&t; * do some work here and then call buf_item_unpin&n;&t;&t; * to do the rest because if the if is true, then&n;&t;&t; * we are holding the buffer locked so no one else&n;&t;&t; * will be able to bump up the refcount.&n;&t;&t; */
id|lidp
op_assign
id|xfs_trans_find_item
c_func
(paren
id|tp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
)paren
suffix:semicolon
id|stale
op_assign
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_BUF_STALE
suffix:semicolon
id|xfs_trans_free_item
c_func
(paren
id|tp
comma
id|lidp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Since the transaction no longer refers to the buffer,&n;&t;&t; * the buffer should no longer refer to the transaction.&n;&t;&t; */
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|xfs_buf_item_unpin
c_func
(paren
id|bip
comma
id|stale
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to attempt to lock the buffer associated with this&n; * buf log item.  Don&squot;t sleep on the buffer lock.  If we can&squot;t get&n; * the lock right away, return 0.  If we can get the lock, pull the&n; * buffer from the free list, mark it busy, and return 1.&n; */
id|uint
DECL|function|xfs_buf_item_trylock
id|xfs_buf_item_trylock
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
(brace
r_return
id|XFS_ITEM_PINNED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_BUF_CPSEMA
c_func
(paren
id|bp
)paren
)paren
(brace
r_return
id|XFS_ITEM_LOCKED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove the buffer from the free list.  Only do this&n;&t; * if it&squot;s on the free list.  Private buffers like the&n;&t; * superblock buffer are not.&n;&t; */
id|XFS_BUF_HOLD
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;TRYLOCK SUCCESS&quot;
comma
id|bip
)paren
suffix:semicolon
r_return
id|XFS_ITEM_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the buffer associated with the buf log item.&n; * If there is no dirty logged data associated with the&n; * buffer recorded in the buf log item, then free the&n; * buf log item and remove the reference to it in the&n; * buffer.&n; *&n; * This call ignores the recursion count.  It is only called&n; * when the buffer should REALLY be unlocked, regardless&n; * of the recursion count.&n; *&n; * If the XFS_BLI_HOLD flag is set in the buf log item, then&n; * free the log item if necessary but do not unlock the buffer.&n; * This is for support of xfs_trans_bhold(). Make sure the&n; * XFS_BLI_HOLD field is cleared if we don&squot;t free the item.&n; */
r_void
DECL|function|xfs_buf_item_unlock
id|xfs_buf_item_unlock
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
r_int
id|aborted
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|uint
id|hold
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_UNLOCK&quot;
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the buffer&squot;s association with this transaction.&n;&t; */
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a transaction abort, don&squot;t return early.&n;&t; * Instead, allow the brelse to happen.&n;&t; * Normally it would be done for stale (cancelled) buffers&n;&t; * at unpin time, but we&squot;ll never go through the pin/unpin&n;&t; * cycle if we abort inside commit.&n;&t; */
id|aborted
op_assign
(paren
id|bip-&gt;bli_item.li_flags
op_amp
id|XFS_LI_ABORTED
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the buf item is marked stale, then don&squot;t do anything.&n;&t; * We&squot;ll unlock the buffer and free the buf item when the&n;&t; * buffer is unpinned for the last time.&n;&t; */
r_if
c_cond
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
(brace
id|bip-&gt;bli_flags
op_and_assign
op_complement
id|XFS_BLI_LOGGED
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;UNLOCK STALE&quot;
comma
id|bip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_format.blf_flags
op_amp
id|XFS_BLI_CANCEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aborted
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Drop the transaction&squot;s reference to the log item if&n;&t; * it was not logged as part of the transaction.  Otherwise&n;&t; * we&squot;ll drop the reference in xfs_buf_item_unpin() when&n;&t; * the transaction is really through with the buffer.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_LOGGED
)paren
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Clear the logged flag since this is per&n;&t;&t; * transaction state.&n;&t;&t; */
id|bip-&gt;bli_flags
op_and_assign
op_complement
id|XFS_BLI_LOGGED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Before possibly freeing the buf item, determine if we should&n;&t; * release the buffer at the end of this routine.&n;&t; */
id|hold
op_assign
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_HOLD
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;UNLOCK&quot;
comma
id|bip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the buf item isn&squot;t tracking any data, free it.&n;&t; * Otherwise, if XFS_BLI_HOLD is set clear it.&n;&t; */
r_if
c_cond
(paren
id|xfs_count_bits
c_func
(paren
id|bip-&gt;bli_format.blf_data_map
comma
id|bip-&gt;bli_format.blf_map_size
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
id|xfs_buf_item_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hold
)paren
(brace
id|bip-&gt;bli_flags
op_and_assign
op_complement
id|XFS_BLI_HOLD
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release the buffer if XFS_BLI_HOLD was not set.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hold
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called to find out where the oldest active copy of the&n; * buf log item in the on disk log resides now that the last log&n; * write of it completed at the given lsn.&n; * We always re-log all the dirty data in a buffer, so usually the&n; * latest copy in the on disk log is the only one that matters.&t; For&n; * those cases we simply return the given lsn.&n; *&n; * The one exception to this is for buffers full of newly allocated&n; * inodes.  These buffers are only relogged with the XFS_BLI_INODE_BUF&n; * flag set, indicating that only the di_next_unlinked fields from the&n; * inodes in the buffers will be replayed during recovery.  If the&n; * original newly allocated inode images have not yet been flushed&n; * when the buffer is so relogged, then we need to make sure that we&n; * keep the old images in the &squot;active&squot; portion of the log.  We do this&n; * by returning the original lsn of that transaction here rather than&n; * the current one.&n; */
id|xfs_lsn_t
DECL|function|xfs_buf_item_committed
id|xfs_buf_item_committed
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
comma
id|xfs_lsn_t
id|lsn
)paren
(brace
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;COMMITTED&quot;
comma
id|bip
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_INODE_ALLOC_BUF
)paren
op_logical_and
(paren
id|bip-&gt;bli_item.li_lsn
op_ne
l_int|0
)paren
)paren
(brace
r_return
id|bip-&gt;bli_item.li_lsn
suffix:semicolon
)brace
r_return
(paren
id|lsn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when the transaction holding the buffer is aborted.&n; * Just behave as if the transaction had been cancelled. If we&squot;re shutting down&n; * and have aborted this transaction, we&squot;ll trap this buffer when it tries to&n; * get written out.&n; */
r_void
DECL|function|xfs_buf_item_abort
id|xfs_buf_item_abort
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_ABORT&quot;
comma
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SUPER_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_item_unlock
c_func
(paren
id|bip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to asynchronously write the buffer associated with this&n; * buf log item out to disk. The buffer will already have been locked by&n; * a successful call to xfs_buf_item_trylock().&t; If the buffer still has&n; * B_DELWRI set, then get it going out to disk with a call to bawrite().&n; * If not, then just release the buffer.&n; */
r_void
DECL|function|xfs_buf_item_push
id|xfs_buf_item_push
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_STALE
)paren
)paren
suffix:semicolon
id|xfs_buf_item_trace
c_func
(paren
l_string|&quot;PUSH&quot;
comma
id|bip
)paren
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_bawrite
c_func
(paren
id|bip-&gt;bli_item.li_mountp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_buf_item_committing
id|xfs_buf_item_committing
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
comma
id|xfs_lsn_t
id|commit_lsn
)paren
(brace
)brace
multiline_comment|/*&n; * This is the ops vector shared by all buf log items.&n; */
DECL|variable|xfs_buf_item_ops
r_struct
id|xfs_item_ops
id|xfs_buf_item_ops
op_assign
(brace
dot
id|iop_size
op_assign
(paren
id|uint
c_func
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_buf_item_size
comma
dot
id|iop_format
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_log_iovec_t
op_star
)paren
)paren
id|xfs_buf_item_format
comma
dot
id|iop_pin
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_buf_item_pin
comma
dot
id|iop_unpin
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
r_int
)paren
)paren
id|xfs_buf_item_unpin
comma
dot
id|iop_unpin_remove
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_trans_t
op_star
)paren
)paren
id|xfs_buf_item_unpin_remove
comma
dot
id|iop_trylock
op_assign
(paren
id|uint
c_func
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_buf_item_trylock
comma
dot
id|iop_unlock
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_buf_item_unlock
comma
dot
id|iop_committed
op_assign
(paren
id|xfs_lsn_t
c_func
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_lsn_t
)paren
)paren
id|xfs_buf_item_committed
comma
dot
id|iop_push
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_buf_item_push
comma
dot
id|iop_abort
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_buf_item_abort
comma
dot
id|iop_pushbuf
op_assign
l_int|NULL
comma
dot
id|iop_committing
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_lsn_t
)paren
)paren
id|xfs_buf_item_committing
)brace
suffix:semicolon
multiline_comment|/*&n; * Allocate a new buf log item to go with the given buffer.&n; * Set the buffer&squot;s b_fsprivate field to point to the new&n; * buf log item.  If there are other item&squot;s attached to the&n; * buffer (see xfs_buf_attach_iodone() below), then put the&n; * buf log item at the front.&n; */
r_void
DECL|function|xfs_buf_item_init
id|xfs_buf_item_init
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
r_int
id|chunks
suffix:semicolon
r_int
id|map_size
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if there is already a buf log item for&n;&t; * this buffer.&t; If there is, it is guaranteed to be&n;&t; * the first.  If we do already have one, there is&n;&t; * nothing to do here so return.&n;&t; */
r_if
c_cond
(paren
id|XFS_BUF_FSPRIVATE3
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
op_ne
id|mp
)paren
id|XFS_BUF_SET_FSPRIVATE3
c_func
(paren
id|bp
comma
id|mp
)paren
suffix:semicolon
id|XFS_BUF_SET_BDSTRAT_FUNC
c_func
(paren
id|bp
comma
id|xfs_bdstrat_cb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
(brace
id|lip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_log_item_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lip-&gt;li_type
op_eq
id|XFS_LI_BUF
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * chunks is the number of XFS_BLI_CHUNK size pieces&n;&t; * the buffer can be divided into. Make sure not to&n;&t; * truncate any pieces.&t; map_size is the size of the&n;&t; * bitmap needed to describe the chunks of the buffer.&n;&t; */
id|chunks
op_assign
(paren
r_int
)paren
(paren
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_plus
(paren
id|XFS_BLI_CHUNK
op_minus
l_int|1
)paren
)paren
op_rshift
id|XFS_BLI_SHIFT
)paren
suffix:semicolon
id|map_size
op_assign
(paren
r_int
)paren
(paren
(paren
id|chunks
op_plus
id|NBWORD
)paren
op_rshift
id|BIT_TO_WORD_SHIFT
)paren
suffix:semicolon
id|bip
op_assign
(paren
id|xfs_buf_log_item_t
op_star
)paren
id|kmem_zone_zalloc
c_func
(paren
id|xfs_buf_item_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|bip-&gt;bli_item.li_type
op_assign
id|XFS_LI_BUF
suffix:semicolon
id|bip-&gt;bli_item.li_ops
op_assign
op_amp
id|xfs_buf_item_ops
suffix:semicolon
id|bip-&gt;bli_item.li_mountp
op_assign
id|mp
suffix:semicolon
id|bip-&gt;bli_buf
op_assign
id|bp
suffix:semicolon
id|bip-&gt;bli_format.blf_type
op_assign
id|XFS_LI_BUF
suffix:semicolon
id|bip-&gt;bli_format.blf_blkno
op_assign
(paren
id|__int64_t
)paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|bip-&gt;bli_format.blf_len
op_assign
(paren
id|ushort
)paren
id|BTOBB
c_func
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_format.blf_map_size
op_assign
id|map_size
suffix:semicolon
macro_line|#ifdef XFS_BLI_TRACE
id|bip-&gt;bli_trace
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_BLI_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_TRANS_DEBUG
multiline_comment|/*&n;&t; * Allocate the arrays for tracking what needs to be logged&n;&t; * and what our callers request to be logged.  bli_orig&n;&t; * holds a copy of the original, clean buffer for comparison&n;&t; * against, and bli_logged keeps a 1 bit flag per byte in&n;&t; * the buffer to indicate which bytes the callers have asked&n;&t; * to have logged.&n;&t; */
id|bip-&gt;bli_orig
op_assign
(paren
r_char
op_star
)paren
id|kmem_alloc
c_func
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bip-&gt;bli_orig
comma
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_logged
op_assign
(paren
r_char
op_star
)paren
id|kmem_zalloc
c_func
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_div
id|NBBY
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Put the buf item into the list of items attached to the&n;&t; * buffer at the front.&n;&t; */
r_if
c_cond
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
(brace
id|bip-&gt;bli_item.li_bio_list
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_log_item_t
op_star
)paren
suffix:semicolon
)brace
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|bip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Mark bytes first through last inclusive as dirty in the buf&n; * item&squot;s bitmap.&n; */
r_void
DECL|function|xfs_buf_item_log
id|xfs_buf_item_log
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
comma
id|uint
id|first
comma
id|uint
id|last
)paren
(brace
id|uint
id|first_bit
suffix:semicolon
id|uint
id|last_bit
suffix:semicolon
id|uint
id|bits_to_set
suffix:semicolon
id|uint
id|bits_set
suffix:semicolon
id|uint
id|word_num
suffix:semicolon
id|uint
op_star
id|wordp
suffix:semicolon
id|uint
id|bit
suffix:semicolon
id|uint
id|end_bit
suffix:semicolon
id|uint
id|mask
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the item as having some dirty data for&n;&t; * quick reference in xfs_buf_item_dirty.&n;&t; */
id|bip-&gt;bli_flags
op_or_assign
id|XFS_BLI_DIRTY
suffix:semicolon
multiline_comment|/*&n;&t; * Convert byte offsets to bit numbers.&n;&t; */
id|first_bit
op_assign
id|first
op_rshift
id|XFS_BLI_SHIFT
suffix:semicolon
id|last_bit
op_assign
id|last
op_rshift
id|XFS_BLI_SHIFT
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the total number of bits to be set.&n;&t; */
id|bits_to_set
op_assign
id|last_bit
op_minus
id|first_bit
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Get a pointer to the first word in the bitmap&n;&t; * to set a bit in.&n;&t; */
id|word_num
op_assign
id|first_bit
op_rshift
id|BIT_TO_WORD_SHIFT
suffix:semicolon
id|wordp
op_assign
op_amp
(paren
id|bip-&gt;bli_format.blf_data_map
(braket
id|word_num
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the starting bit in the first word.&n;&t; */
id|bit
op_assign
id|first_bit
op_amp
(paren
id|uint
)paren
(paren
id|NBWORD
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First set any bits in the first word of our range.&n;&t; * If it starts at bit 0 of the word, it will be&n;&t; * set below rather than here.&t;That is what the variable&n;&t; * bit tells us. The variable bits_set tracks the number&n;&t; * of bits that have been set so far.  End_bit is the number&n;&t; * of the last bit to be set in this word plus one.&n;&t; */
r_if
c_cond
(paren
id|bit
)paren
(brace
id|end_bit
op_assign
id|MIN
c_func
(paren
id|bit
op_plus
id|bits_to_set
comma
(paren
id|uint
)paren
id|NBWORD
)paren
suffix:semicolon
id|mask
op_assign
(paren
(paren
l_int|1
op_lshift
(paren
id|end_bit
op_minus
id|bit
)paren
)paren
op_minus
l_int|1
)paren
op_lshift
id|bit
suffix:semicolon
op_star
id|wordp
op_or_assign
id|mask
suffix:semicolon
id|wordp
op_increment
suffix:semicolon
id|bits_set
op_assign
id|end_bit
op_minus
id|bit
suffix:semicolon
)brace
r_else
(brace
id|bits_set
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now set bits a whole word at a time that are between&n;&t; * first_bit and last_bit.&n;&t; */
r_while
c_loop
(paren
(paren
id|bits_to_set
op_minus
id|bits_set
)paren
op_ge
id|NBWORD
)paren
(brace
op_star
id|wordp
op_or_assign
l_int|0xffffffff
suffix:semicolon
id|bits_set
op_add_assign
id|NBWORD
suffix:semicolon
id|wordp
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Finally, set any bits left to be set in one last partial word.&n;&t; */
id|end_bit
op_assign
id|bits_to_set
op_minus
id|bits_set
suffix:semicolon
r_if
c_cond
(paren
id|end_bit
)paren
(brace
id|mask
op_assign
(paren
l_int|1
op_lshift
id|end_bit
)paren
op_minus
l_int|1
suffix:semicolon
op_star
id|wordp
op_or_assign
id|mask
suffix:semicolon
)brace
id|xfs_buf_item_log_debug
c_func
(paren
id|bip
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 1 if the buffer has some data that has been logged (at any&n; * point, not just the current transaction) and 0 if not.&n; */
id|uint
DECL|function|xfs_buf_item_dirty
id|xfs_buf_item_dirty
c_func
(paren
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
r_return
(paren
id|bip-&gt;bli_flags
op_amp
id|XFS_BLI_DIRTY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when the buf log item is no longer needed.  It should&n; * free the buf log item associated with the given buffer and clear&n; * the buffer&squot;s pointer to the buf log item.  If there are no more&n; * items in the list, clear the b_iodone field of the buffer (see&n; * xfs_buf_attach_iodone() below).&n; */
r_void
DECL|function|xfs_buf_item_relse
id|xfs_buf_item_relse
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS_RELSE&quot;
comma
id|bp
)paren
suffix:semicolon
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|bip-&gt;bli_item.li_bio_list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_ne
l_int|NULL
)paren
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|XFS_BUF_ISUNINITIAL
c_func
(paren
id|bp
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|XFS_BUF_CLR_IODONE_FUNC
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
macro_line|#ifdef XFS_TRANS_DEBUG
id|kmem_free
c_func
(paren
id|bip-&gt;bli_orig
comma
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_orig
op_assign
l_int|NULL
suffix:semicolon
id|kmem_free
c_func
(paren
id|bip-&gt;bli_logged
comma
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_div
id|NBBY
)paren
suffix:semicolon
id|bip-&gt;bli_logged
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* XFS_TRANS_DEBUG */
macro_line|#ifdef XFS_BLI_TRACE
id|ktrace_free
c_func
(paren
id|bip-&gt;bli_trace
)paren
suffix:semicolon
macro_line|#endif
id|kmem_zone_free
c_func
(paren
id|xfs_buf_item_zone
comma
id|bip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the given log item with its callback to the list of callbacks&n; * to be called when the buffer&squot;s I/O completes.  If it is not set&n; * already, set the buffer&squot;s b_iodone() routine to be&n; * xfs_buf_iodone_callbacks() and link the log item into the list of&n; * items rooted at b_fsprivate.&t; Items are always added as the second&n; * entry in the list if there is a first, because the buf item code&n; * assumes that the buf log item is first.&n; */
r_void
DECL|function|xfs_buf_attach_iodone
id|xfs_buf_attach_iodone
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
r_void
(paren
op_star
id|cb
)paren
(paren
id|xfs_buf_t
op_star
comma
id|xfs_log_item_t
op_star
)paren
comma
id|xfs_log_item_t
op_star
id|lip
)paren
(brace
id|xfs_log_item_t
op_star
id|head_lip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|lip-&gt;li_cb
op_assign
id|cb
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
(brace
id|head_lip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_log_item_t
op_star
)paren
suffix:semicolon
id|lip-&gt;li_bio_list
op_assign
id|head_lip-&gt;li_bio_list
suffix:semicolon
id|head_lip-&gt;li_bio_list
op_assign
id|lip
suffix:semicolon
)brace
r_else
(brace
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|lip
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_eq
id|xfs_buf_iodone_callbacks
)paren
op_logical_or
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_eq
l_int|NULL
)paren
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|bp
comma
id|xfs_buf_iodone_callbacks
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_buf_do_callbacks
id|xfs_buf_do_callbacks
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_log_item_t
op_star
id|lip
)paren
(brace
id|xfs_log_item_t
op_star
id|nlip
suffix:semicolon
r_while
c_loop
(paren
id|lip
op_ne
l_int|NULL
)paren
(brace
id|nlip
op_assign
id|lip-&gt;li_bio_list
suffix:semicolon
id|ASSERT
c_func
(paren
id|lip-&gt;li_cb
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear the next pointer so we don&squot;t have any&n;&t;&t; * confusion if the item is added to another buf.&n;&t;&t; * Don&squot;t touch the log item after calling its&n;&t;&t; * callback, because it could have freed itself.&n;&t;&t; */
id|lip-&gt;li_bio_list
op_assign
l_int|NULL
suffix:semicolon
id|lip
op_member_access_from_pointer
id|li_cb
c_func
(paren
id|bp
comma
id|lip
)paren
suffix:semicolon
id|lip
op_assign
id|nlip
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is the iodone() function for buffers which have had callbacks&n; * attached to them by xfs_buf_attach_iodone().&t; It should remove each&n; * log item from the buffer&squot;s list and call the callback of each in turn.&n; * When done, the buffer&squot;s fsprivate field is set to NULL and the buffer&n; * is unlocked with a call to iodone().&n; */
r_void
DECL|function|xfs_buf_iodone_callbacks
id|xfs_buf_iodone_callbacks
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
r_static
id|time_t
id|lasttime
suffix:semicolon
r_static
id|dev_t
id|lastdev
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|lip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_log_item_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we&squot;ve already decided to shutdown the filesystem&n;&t;&t; * because of IO errors, there&squot;s no point in giving this&n;&t;&t; * a retry.&n;&t;&t; */
id|mp
op_assign
id|lip-&gt;li_mountp
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_BUF_TARGET
c_func
(paren
id|bp
)paren
op_eq
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|XFS_BUF_SUPER_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;BUF_IODONE_CB&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_do_callbacks
c_func
(paren
id|bp
comma
id|lip
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_BUF_CLR_IODONE_FUNC
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * XFS_SHUT flag gets set when we go thru the&n;&t;&t;&t; * entire buffer cache and deliberately start&n;&t;&t;&t; * throwing away delayed write buffers.&n;&t;&t;&t; * Since there&squot;s no biowait done on those,&n;&t;&t;&t; * we should just brelse them.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_BUF_ISSHUT
c_func
(paren
id|bp
)paren
)paren
(brace
id|XFS_BUF_UNSHUT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_biodone
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|XFS_BUF_TARGET_DEV
c_func
(paren
id|bp
)paren
op_ne
id|lastdev
)paren
op_logical_or
(paren
id|time_after
c_func
(paren
id|jiffies
comma
(paren
id|lasttime
op_plus
l_int|5
op_star
id|HZ
)paren
)paren
)paren
)paren
(brace
id|lasttime
op_assign
id|jiffies
suffix:semicolon
id|prdev
c_func
(paren
l_string|&quot;XFS write error in file system meta-data &quot;
l_string|&quot;block 0x%Lx in %s&quot;
comma
id|XFS_BUF_TARGET_DEV
c_func
(paren
id|bp
)paren
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
)brace
id|lastdev
op_assign
id|XFS_BUF_TARGET_DEV
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISASYNC
c_func
(paren
id|bp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the write was asynchronous then noone will be&n;&t;&t;&t; * looking for the error.  Clear the error state&n;&t;&t;&t; * and write the buffer out again delayed write.&n;&t;&t;&t; *&n;&t;&t;&t; * XXXsup This is OK, so long as we catch these&n;&t;&t;&t; * before we start the umount; we don&squot;t want these&n;&t;&t;&t; * DELWRI metadata bufs to be hanging around.&n;&t;&t;&t; */
id|XFS_BUF_ERROR
c_func
(paren
id|bp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* errno of 0 unsets the flag */
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_BUF_ISSTALE
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|XFS_BUF_DELAYWRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_DONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SET_START
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;BUF_IODONE ASYNC&quot;
comma
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If the write of the buffer was not asynchronous,&n;&t;&t;&t; * then we want to make sure to return the error&n;&t;&t;&t; * to the caller of bwrite().  Because of this we&n;&t;&t;&t; * cannot clear the B_ERROR state at this point.&n;&t;&t;&t; * Instead we install a callback function that&n;&t;&t;&t; * will be called when the buffer is released, and&n;&t;&t;&t; * that routine will clear the error state and&n;&t;&t;&t; * set the buffer to be written out again after&n;&t;&t;&t; * some delay.&n;&t;&t;&t; */
multiline_comment|/* We actually overwrite the existing b-relse&n;&t;&t;&t;   function at times, but we&squot;re gonna be shutting down&n;&t;&t;&t;   anyway. */
id|XFS_BUF_SET_BRELSE_FUNC
c_func
(paren
id|bp
comma
id|xfs_buf_error_relse
)paren
suffix:semicolon
id|XFS_BUF_DONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_V_IODONESEMA
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef XFSERRORDEBUG
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS BUFCB NOERR&quot;
comma
id|bp
)paren
suffix:semicolon
macro_line|#endif
id|xfs_buf_do_callbacks
c_func
(paren
id|bp
comma
id|lip
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_BUF_CLR_IODONE_FUNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_biodone
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a callback routine attached to a buffer which gets an error&n; * when being written out synchronously.&n; */
id|STATIC
r_void
DECL|function|xfs_buf_error_relse
id|xfs_buf_error_relse
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|lip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_log_item_t
op_star
)paren
suffix:semicolon
id|mp
op_assign
(paren
id|xfs_mount_t
op_star
)paren
id|lip-&gt;li_mountp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_TARGET
c_func
(paren
id|bp
)paren
op_eq
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_DONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_UNDELAYWRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_ERROR
c_func
(paren
id|bp
comma
l_int|0
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;BUF_ERROR_RELSE&quot;
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_METADATA_IO_ERROR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to unpin the pinned buffers so do the&n;&t; * callbacks.&n;&t; */
id|xfs_buf_do_callbacks
c_func
(paren
id|bp
comma
id|lip
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_BUF_CLR_IODONE_FUNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SET_BRELSE_FUNC
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the iodone() function for buffers which have been&n; * logged.  It is called when they are eventually flushed out.&n; * It should remove the buf item from the AIL, and free the buf item.&n; * It is called by xfs_buf_iodone_callbacks() above which will take&n; * care of cleaning up the buffer itself.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_buf_iodone
id|xfs_buf_iodone
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
r_struct
id|xfs_mount
op_star
id|mp
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_buf
op_eq
id|bp
)paren
suffix:semicolon
id|mp
op_assign
id|bip-&gt;bli_item.li_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * If we are forcibly shutting down, this may well be&n;&t; * off the AIL already. That&squot;s because we simulate the&n;&t; * log-committed callbacks to unpin these buffers. Or we may never&n;&t; * have put this item on AIL because of the transaction was&n;&t; * aborted forcibly. xfs_trans_delete_ail() takes care of these.&n;&t; *&n;&t; * Either way, AIL is useless if we&squot;re forcing a shutdown.&n;&t; */
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * xfs_trans_delete_ail() drops the AIL lock.&n;&t; */
id|xfs_trans_delete_ail
c_func
(paren
id|mp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|bip
comma
id|s
)paren
suffix:semicolon
macro_line|#ifdef XFS_TRANS_DEBUG
id|kmem_free
c_func
(paren
id|bip-&gt;bli_orig
comma
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|bip-&gt;bli_orig
op_assign
l_int|NULL
suffix:semicolon
id|kmem_free
c_func
(paren
id|bip-&gt;bli_logged
comma
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_div
id|NBBY
)paren
suffix:semicolon
id|bip-&gt;bli_logged
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* XFS_TRANS_DEBUG */
macro_line|#ifdef XFS_BLI_TRACE
id|ktrace_free
c_func
(paren
id|bip-&gt;bli_trace
)paren
suffix:semicolon
macro_line|#endif
id|kmem_zone_free
c_func
(paren
id|xfs_buf_item_zone
comma
id|bip
)paren
suffix:semicolon
)brace
macro_line|#if defined(XFS_BLI_TRACE)
r_void
DECL|function|xfs_buf_item_trace
id|xfs_buf_item_trace
c_func
(paren
r_char
op_star
id|id
comma
id|xfs_buf_log_item_t
op_star
id|bip
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|ASSERT
c_func
(paren
id|bip-&gt;bli_trace
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bp
op_assign
id|bip-&gt;bli_buf
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|bip-&gt;bli_trace
comma
(paren
r_void
op_star
)paren
id|id
comma
(paren
r_void
op_star
)paren
id|bip-&gt;bli_buf
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|bip-&gt;bli_flags
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|bip-&gt;bli_recur
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|bip-&gt;bli_refcount
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
l_int|0xFFFFFFFF
op_amp
(paren
id|XFS_BFLAGS
c_func
(paren
id|bp
)paren
op_rshift
l_int|32
)paren
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
l_int|0xFFFFFFFF
op_amp
id|XFS_BFLAGS
c_func
(paren
id|bp
)paren
)paren
)paren
comma
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
comma
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
r_void
op_star
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|bp-&gt;b_pincount
)paren
comma
(paren
r_void
op_star
)paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|bip-&gt;bli_item.li_desc
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|bip-&gt;bli_item.li_flags
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* XFS_BLI_TRACE */
eof
