multiline_comment|/*&n; * Copyright (c) 2001-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_acl.h&quot;
macro_line|#include &quot;xfs_mac.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &lt;linux/posix_acl_xattr.h&gt;
id|STATIC
r_int
id|xfs_acl_setmode
c_func
(paren
id|vnode_t
op_star
comma
id|xfs_acl_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_acl_filter_mode
c_func
(paren
id|mode_t
comma
id|xfs_acl_t
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_acl_get_endian
c_func
(paren
id|xfs_acl_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_acl_access
c_func
(paren
id|uid_t
comma
id|gid_t
comma
id|xfs_acl_t
op_star
comma
id|mode_t
comma
id|cred_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_acl_invalid
c_func
(paren
id|xfs_acl_t
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_acl_sync_mode
c_func
(paren
id|mode_t
comma
id|xfs_acl_t
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_acl_get_attr
c_func
(paren
id|vnode_t
op_star
comma
id|xfs_acl_t
op_star
comma
r_int
comma
r_int
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_acl_set_attr
c_func
(paren
id|vnode_t
op_star
comma
id|xfs_acl_t
op_star
comma
r_int
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_acl_allow_set
c_func
(paren
id|vnode_t
op_star
comma
r_int
)paren
suffix:semicolon
DECL|variable|xfs_acl_zone
id|kmem_zone_t
op_star
id|xfs_acl_zone
suffix:semicolon
multiline_comment|/*&n; * Test for existence of access ACL attribute as efficiently as possible.&n; */
r_int
DECL|function|xfs_acl_vhasacl_access
id|xfs_acl_vhasacl_access
c_func
(paren
id|vnode_t
op_star
id|vp
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_acl_get_attr
c_func
(paren
id|vp
comma
l_int|NULL
comma
id|_ACL_TYPE_ACCESS
comma
id|ATTR_KERNOVAL
comma
op_amp
id|error
)paren
suffix:semicolon
r_return
(paren
id|error
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Test for existence of default ACL attribute as efficiently as possible.&n; */
r_int
DECL|function|xfs_acl_vhasacl_default
id|xfs_acl_vhasacl_default
c_func
(paren
id|vnode_t
op_star
id|vp
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|vp-&gt;v_type
op_ne
id|VDIR
)paren
r_return
l_int|0
suffix:semicolon
id|xfs_acl_get_attr
c_func
(paren
id|vp
comma
l_int|NULL
comma
id|_ACL_TYPE_DEFAULT
comma
id|ATTR_KERNOVAL
comma
op_amp
id|error
)paren
suffix:semicolon
r_return
(paren
id|error
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from extended attribute representation to in-memory for XFS.&n; */
id|STATIC
r_int
DECL|function|posix_acl_xattr_to_xfs
id|posix_acl_xattr_to_xfs
c_func
(paren
id|posix_acl_xattr_header
op_star
id|src
comma
r_int
id|size
comma
id|xfs_acl_t
op_star
id|dest
)paren
(brace
id|posix_acl_xattr_entry
op_star
id|src_entry
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|dest_entry
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|src
op_logical_or
op_logical_neg
id|dest
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
id|posix_acl_xattr_header
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|src-&gt;a_version
op_ne
id|cpu_to_le32
c_func
(paren
id|POSIX_ACL_XATTR_VERSION
)paren
)paren
r_return
id|EOPNOTSUPP
suffix:semicolon
id|memset
c_func
(paren
id|dest
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_acl_t
)paren
)paren
suffix:semicolon
id|dest-&gt;acl_cnt
op_assign
id|posix_acl_xattr_count
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;acl_cnt
template_param
id|XFS_ACL_MAX_ENTRIES
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * acl_set_file(3) may request that we set default ACLs with&n;&t; * zero length -- defend (gracefully) against that here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dest-&gt;acl_cnt
)paren
r_return
l_int|0
suffix:semicolon
id|src_entry
op_assign
(paren
id|posix_acl_xattr_entry
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|src
op_plus
r_sizeof
(paren
op_star
id|src
)paren
)paren
suffix:semicolon
id|dest_entry
op_assign
op_amp
id|dest-&gt;acl_entry
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|dest-&gt;acl_cnt
suffix:semicolon
id|n
op_increment
comma
id|src_entry
op_increment
comma
id|dest_entry
op_increment
)paren
(brace
id|dest_entry-&gt;ae_perm
op_assign
id|le16_to_cpu
c_func
(paren
id|src_entry-&gt;e_perm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_ACL_PERM_INVALID
c_func
(paren
id|dest_entry-&gt;ae_perm
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
id|dest_entry-&gt;ae_tag
op_assign
id|le16_to_cpu
c_func
(paren
id|src_entry-&gt;e_tag
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dest_entry-&gt;ae_tag
)paren
(brace
r_case
id|ACL_USER
suffix:colon
r_case
id|ACL_GROUP
suffix:colon
id|dest_entry-&gt;ae_id
op_assign
id|le32_to_cpu
c_func
(paren
id|src_entry-&gt;e_id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_USER_OBJ
suffix:colon
r_case
id|ACL_GROUP_OBJ
suffix:colon
r_case
id|ACL_MASK
suffix:colon
r_case
id|ACL_OTHER
suffix:colon
id|dest_entry-&gt;ae_id
op_assign
id|ACL_UNDEFINED_ID
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|xfs_acl_invalid
c_func
(paren
id|dest
)paren
)paren
r_return
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Comparison function called from qsort().&n; * Primary key is ae_tag, secondary key is ae_id.&n; */
id|STATIC
r_int
DECL|function|xfs_acl_entry_compare
id|xfs_acl_entry_compare
c_func
(paren
r_const
r_void
op_star
id|va
comma
r_const
r_void
op_star
id|vb
)paren
(brace
id|xfs_acl_entry_t
op_star
id|a
op_assign
(paren
id|xfs_acl_entry_t
op_star
)paren
id|va
comma
op_star
id|b
op_assign
(paren
id|xfs_acl_entry_t
op_star
)paren
id|vb
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;ae_tag
op_eq
id|b-&gt;ae_tag
)paren
r_return
(paren
id|a-&gt;ae_id
op_minus
id|b-&gt;ae_id
)paren
suffix:semicolon
r_return
(paren
id|a-&gt;ae_tag
op_minus
id|b-&gt;ae_tag
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from in-memory XFS to extended attribute representation.&n; */
id|STATIC
r_int
DECL|function|posix_acl_xfs_to_xattr
id|posix_acl_xfs_to_xattr
c_func
(paren
id|xfs_acl_t
op_star
id|src
comma
id|posix_acl_xattr_header
op_star
id|dest
comma
r_int
id|size
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
id|new_size
op_assign
id|posix_acl_xattr_size
c_func
(paren
id|src-&gt;acl_cnt
)paren
suffix:semicolon
id|posix_acl_xattr_entry
op_star
id|dest_entry
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|src_entry
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|new_size
)paren
r_return
op_minus
id|ERANGE
suffix:semicolon
multiline_comment|/* Need to sort src XFS ACL by &lt;ae_tag,ae_id&gt; */
id|qsort
c_func
(paren
id|src-&gt;acl_entry
comma
id|src-&gt;acl_cnt
comma
r_sizeof
(paren
id|src-&gt;acl_entry
(braket
l_int|0
)braket
)paren
comma
id|xfs_acl_entry_compare
)paren
suffix:semicolon
id|dest-&gt;a_version
op_assign
id|cpu_to_le32
c_func
(paren
id|POSIX_ACL_XATTR_VERSION
)paren
suffix:semicolon
id|dest_entry
op_assign
op_amp
id|dest-&gt;a_entries
(braket
l_int|0
)braket
suffix:semicolon
id|src_entry
op_assign
op_amp
id|src-&gt;acl_entry
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|src-&gt;acl_cnt
suffix:semicolon
id|n
op_increment
comma
id|dest_entry
op_increment
comma
id|src_entry
op_increment
)paren
(brace
id|dest_entry-&gt;e_perm
op_assign
id|cpu_to_le16
c_func
(paren
id|src_entry-&gt;ae_perm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_ACL_PERM_INVALID
c_func
(paren
id|src_entry-&gt;ae_perm
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dest_entry-&gt;e_tag
op_assign
id|cpu_to_le16
c_func
(paren
id|src_entry-&gt;ae_tag
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|src_entry-&gt;ae_tag
)paren
(brace
r_case
id|ACL_USER
suffix:colon
r_case
id|ACL_GROUP
suffix:colon
id|dest_entry-&gt;e_id
op_assign
id|cpu_to_le32
c_func
(paren
id|src_entry-&gt;ae_id
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_USER_OBJ
suffix:colon
r_case
id|ACL_GROUP_OBJ
suffix:colon
r_case
id|ACL_MASK
suffix:colon
r_case
id|ACL_OTHER
suffix:colon
id|dest_entry-&gt;e_id
op_assign
id|cpu_to_le32
c_func
(paren
id|ACL_UNDEFINED_ID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_return
id|new_size
suffix:semicolon
)brace
r_int
DECL|function|xfs_acl_vget
id|xfs_acl_vget
c_func
(paren
id|vnode_t
op_star
id|vp
comma
r_void
op_star
id|acl
comma
r_int
id|size
comma
r_int
id|kind
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_acl_t
op_star
id|xfs_acl
op_assign
l_int|NULL
suffix:semicolon
id|posix_acl_xattr_header
op_star
id|ext_acl
op_assign
id|acl
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|vp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|_ACL_ALLOC
c_func
(paren
id|xfs_acl
)paren
)paren
)paren
(brace
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|xfs_acl
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_acl_t
)paren
)paren
suffix:semicolon
)brace
r_else
id|flags
op_assign
id|ATTR_KERNOVAL
suffix:semicolon
id|xfs_acl_get_attr
c_func
(paren
id|vp
comma
id|xfs_acl
comma
id|kind
comma
id|flags
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
(brace
id|error
op_assign
op_minus
id|posix_acl_xattr_size
c_func
(paren
id|XFS_ACL_MAX_ENTRIES
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|xfs_acl_invalid
c_func
(paren
id|xfs_acl
)paren
)paren
(brace
id|error
op_assign
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kind
op_eq
id|_ACL_TYPE_ACCESS
)paren
(brace
id|vattr_t
id|va
suffix:semicolon
id|va.va_mask
op_assign
id|XFS_AT_MODE
suffix:semicolon
id|VOP_GETATTR
c_func
(paren
id|vp
comma
op_amp
id|va
comma
l_int|0
comma
id|sys_cred
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|xfs_acl_sync_mode
c_func
(paren
id|va.va_mode
comma
id|xfs_acl
)paren
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|posix_acl_xfs_to_xattr
c_func
(paren
id|xfs_acl
comma
id|ext_acl
comma
id|size
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_acl
)paren
(brace
id|_ACL_FREE
c_func
(paren
id|xfs_acl
)paren
suffix:semicolon
)brace
r_return
op_minus
id|error
suffix:semicolon
)brace
r_int
DECL|function|xfs_acl_vremove
id|xfs_acl_vremove
c_func
(paren
id|vnode_t
op_star
id|vp
comma
r_int
id|kind
)paren
(brace
r_int
id|error
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|vp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_acl_allow_set
c_func
(paren
id|vp
comma
id|kind
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|VOP_ATTR_REMOVE
c_func
(paren
id|vp
comma
id|kind
op_eq
id|_ACL_TYPE_DEFAULT
ques
c_cond
id|SGI_ACL_DEFAULT
suffix:colon
id|SGI_ACL_FILE
comma
id|ATTR_ROOT
comma
id|sys_cred
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOATTR
)paren
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &squot;scool */
)brace
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
r_int
DECL|function|xfs_acl_vset
id|xfs_acl_vset
c_func
(paren
id|vnode_t
op_star
id|vp
comma
r_void
op_star
id|acl
comma
r_int
id|size
comma
r_int
id|kind
)paren
(brace
id|posix_acl_xattr_header
op_star
id|ext_acl
op_assign
id|acl
suffix:semicolon
id|xfs_acl_t
op_star
id|xfs_acl
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|basicperms
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* more than std unix perms? */
r_if
c_cond
(paren
op_logical_neg
id|acl
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|_ACL_ALLOC
c_func
(paren
id|xfs_acl
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|error
op_assign
id|posix_acl_xattr_to_xfs
c_func
(paren
id|ext_acl
comma
id|size
comma
id|xfs_acl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|_ACL_FREE
c_func
(paren
id|xfs_acl
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_acl-&gt;acl_cnt
)paren
(brace
id|_ACL_FREE
c_func
(paren
id|xfs_acl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|VN_HOLD
c_func
(paren
id|vp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_acl_allow_set
c_func
(paren
id|vp
comma
id|kind
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Incoming ACL exists, set file mode based on its value */
r_if
c_cond
(paren
id|kind
op_eq
id|_ACL_TYPE_ACCESS
)paren
id|xfs_acl_setmode
c_func
(paren
id|vp
comma
id|xfs_acl
comma
op_amp
id|basicperms
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have more than std unix permissions, set up the actual attr.&n;&t; * Otherwise, delete any existing attr.  This prevents us from&n;&t; * having actual attrs for permissions that can be stored in the&n;&t; * standard permission bits.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|basicperms
)paren
(brace
id|xfs_acl_set_attr
c_func
(paren
id|vp
comma
id|xfs_acl
comma
id|kind
comma
op_amp
id|error
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_acl_vremove
c_func
(paren
id|vp
comma
id|_ACL_TYPE_ACCESS
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
id|_ACL_FREE
c_func
(paren
id|xfs_acl
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
r_int
DECL|function|xfs_acl_iaccess
id|xfs_acl_iaccess
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|mode_t
id|mode
comma
id|cred_t
op_star
id|cr
)paren
(brace
id|xfs_acl_t
op_star
id|acl
suffix:semicolon
r_int
id|rval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|_ACL_ALLOC
c_func
(paren
id|acl
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* If the file has no ACL return -1. */
id|rval
op_assign
r_sizeof
(paren
id|xfs_acl_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_attr_fetch
c_func
(paren
id|ip
comma
id|SGI_ACL_FILE
comma
id|SGI_ACL_FILE_SIZE
comma
(paren
r_char
op_star
)paren
id|acl
comma
op_amp
id|rval
comma
id|ATTR_ROOT
op_or
id|ATTR_KERNACCESS
comma
id|cr
)paren
)paren
(brace
id|_ACL_FREE
c_func
(paren
id|acl
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|xfs_acl_get_endian
c_func
(paren
id|acl
)paren
suffix:semicolon
multiline_comment|/* If the file has an empty ACL return -1. */
r_if
c_cond
(paren
id|acl-&gt;acl_cnt
op_eq
id|XFS_ACL_NOT_PRESENT
)paren
(brace
id|_ACL_FREE
c_func
(paren
id|acl
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Synchronize ACL with mode bits */
id|xfs_acl_sync_mode
c_func
(paren
id|ip-&gt;i_d.di_mode
comma
id|acl
)paren
suffix:semicolon
id|rval
op_assign
id|xfs_acl_access
c_func
(paren
id|ip-&gt;i_d.di_uid
comma
id|ip-&gt;i_d.di_gid
comma
id|acl
comma
id|mode
comma
id|cr
)paren
suffix:semicolon
id|_ACL_FREE
c_func
(paren
id|acl
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_acl_allow_set
id|xfs_acl_allow_set
c_func
(paren
id|vnode_t
op_star
id|vp
comma
r_int
id|kind
)paren
(brace
id|vattr_t
id|va
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|vp-&gt;v_inode.i_flags
op_amp
(paren
id|S_IMMUTABLE
op_or
id|S_APPEND
)paren
)paren
r_return
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|kind
op_eq
id|_ACL_TYPE_DEFAULT
op_logical_and
id|vp-&gt;v_type
op_ne
id|VDIR
)paren
r_return
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|vp-&gt;v_vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|EROFS
suffix:semicolon
id|va.va_mask
op_assign
id|XFS_AT_UID
suffix:semicolon
id|VOP_GETATTR
c_func
(paren
id|vp
comma
op_amp
id|va
comma
l_int|0
comma
l_int|NULL
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|va.va_uid
op_ne
id|current-&gt;fsuid
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
)paren
r_return
id|EPERM
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The access control process to determine the access permission:&n; *&t;if uid == file owner id, use the file owner bits.&n; *&t;if gid == file owner group id, use the file group bits.&n; *&t;scan ACL for a maching user or group, and use matched entry&n; *&t;permission. Use total permissions of all matching group entries,&n; *&t;until all acl entries are exhausted. The final permission produced&n; *&t;by matching acl entry or entries needs to be &amp; with group permission.&n; *&t;if not owner, owning group, or matching entry in ACL, use file&n; *&t;other bits.  &n; */
id|STATIC
r_int
DECL|function|xfs_acl_capability_check
id|xfs_acl_capability_check
c_func
(paren
id|mode_t
id|mode
comma
id|cred_t
op_star
id|cr
)paren
(brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|ACL_READ
)paren
op_logical_and
op_logical_neg
id|capable_cred
c_func
(paren
id|cr
comma
id|CAP_DAC_READ_SEARCH
)paren
)paren
r_return
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|ACL_WRITE
)paren
op_logical_and
op_logical_neg
id|capable_cred
c_func
(paren
id|cr
comma
id|CAP_DAC_OVERRIDE
)paren
)paren
r_return
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|ACL_EXECUTE
)paren
op_logical_and
op_logical_neg
id|capable_cred
c_func
(paren
id|cr
comma
id|CAP_DAC_OVERRIDE
)paren
)paren
r_return
id|EACCES
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: cr is only used here for the capability check if the ACL test fails.&n; *       It is not used to find out the credentials uid or groups etc, as was&n; *       done in IRIX. It is assumed that the uid and groups for the current&n; *       thread are taken from &quot;current&quot; instead of the cr parameter.&n; */
id|STATIC
r_int
DECL|function|xfs_acl_access
id|xfs_acl_access
c_func
(paren
id|uid_t
id|fuid
comma
id|gid_t
id|fgid
comma
id|xfs_acl_t
op_star
id|fap
comma
id|mode_t
id|md
comma
id|cred_t
op_star
id|cr
)paren
(brace
id|xfs_acl_entry_t
id|matched
suffix:semicolon
r_int
id|i
comma
id|allows
suffix:semicolon
r_int
id|maskallows
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* true, but not 1, either */
r_int
id|seen_userobj
op_assign
l_int|0
suffix:semicolon
id|matched.ae_tag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Invalid type */
id|md
op_rshift_assign
l_int|6
suffix:semicolon
multiline_comment|/* Normalize the bits for comparison */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fap-&gt;acl_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Break out if we&squot;ve got a user_obj entry or&n;&t;&t; * a user entry and the mask (and have processed USER_OBJ)&n;&t;&t; */
r_if
c_cond
(paren
id|matched.ae_tag
op_eq
id|ACL_USER_OBJ
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|matched.ae_tag
op_eq
id|ACL_USER
)paren
(brace
r_if
c_cond
(paren
id|maskallows
op_ne
op_minus
l_int|1
op_logical_and
id|seen_userobj
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|fap-&gt;acl_entry
(braket
id|i
)braket
dot
id|ae_tag
op_ne
id|ACL_MASK
op_logical_and
id|fap-&gt;acl_entry
(braket
id|i
)braket
dot
id|ae_tag
op_ne
id|ACL_USER_OBJ
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/* True if this entry allows the requested access */
id|allows
op_assign
(paren
(paren
id|fap-&gt;acl_entry
(braket
id|i
)braket
dot
id|ae_perm
op_amp
id|md
)paren
op_eq
id|md
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|fap-&gt;acl_entry
(braket
id|i
)braket
dot
id|ae_tag
)paren
(brace
r_case
id|ACL_USER_OBJ
suffix:colon
id|seen_userobj
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fuid
op_ne
id|current-&gt;fsuid
)paren
r_continue
suffix:semicolon
id|matched.ae_tag
op_assign
id|ACL_USER_OBJ
suffix:semicolon
id|matched.ae_perm
op_assign
id|allows
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_USER
suffix:colon
r_if
c_cond
(paren
id|fap-&gt;acl_entry
(braket
id|i
)braket
dot
id|ae_id
op_ne
id|current-&gt;fsuid
)paren
r_continue
suffix:semicolon
id|matched.ae_tag
op_assign
id|ACL_USER
suffix:semicolon
id|matched.ae_perm
op_assign
id|allows
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_GROUP_OBJ
suffix:colon
r_if
c_cond
(paren
(paren
id|matched.ae_tag
op_eq
id|ACL_GROUP_OBJ
op_logical_or
id|matched.ae_tag
op_eq
id|ACL_GROUP
)paren
op_logical_and
op_logical_neg
id|allows
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_group_p
c_func
(paren
id|fgid
)paren
)paren
r_continue
suffix:semicolon
id|matched.ae_tag
op_assign
id|ACL_GROUP_OBJ
suffix:semicolon
id|matched.ae_perm
op_assign
id|allows
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_GROUP
suffix:colon
r_if
c_cond
(paren
(paren
id|matched.ae_tag
op_eq
id|ACL_GROUP_OBJ
op_logical_or
id|matched.ae_tag
op_eq
id|ACL_GROUP
)paren
op_logical_and
op_logical_neg
id|allows
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_group_p
c_func
(paren
id|fap-&gt;acl_entry
(braket
id|i
)braket
dot
id|ae_id
)paren
)paren
r_continue
suffix:semicolon
id|matched.ae_tag
op_assign
id|ACL_GROUP
suffix:semicolon
id|matched.ae_perm
op_assign
id|allows
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_MASK
suffix:colon
id|maskallows
op_assign
id|allows
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_OTHER
suffix:colon
r_if
c_cond
(paren
id|matched.ae_tag
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
id|matched.ae_tag
op_assign
id|ACL_OTHER
suffix:semicolon
id|matched.ae_perm
op_assign
id|allows
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * First possibility is that no matched entry allows access.&n;&t; * The capability to override DAC may exist, so check for it.&n;&t; */
r_switch
c_cond
(paren
id|matched.ae_tag
)paren
(brace
r_case
id|ACL_OTHER
suffix:colon
r_case
id|ACL_USER_OBJ
suffix:colon
r_if
c_cond
(paren
id|matched.ae_perm
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_USER
suffix:colon
r_case
id|ACL_GROUP_OBJ
suffix:colon
r_case
id|ACL_GROUP
suffix:colon
r_if
c_cond
(paren
id|maskallows
op_logical_and
id|matched.ae_perm
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|xfs_acl_capability_check
c_func
(paren
id|md
comma
id|cr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ACL validity checker.&n; *   This acl validation routine checks each ACL entry read in makes sense.&n; */
id|STATIC
r_int
DECL|function|xfs_acl_invalid
id|xfs_acl_invalid
c_func
(paren
id|xfs_acl_t
op_star
id|aclp
)paren
(brace
id|xfs_acl_entry_t
op_star
id|entry
comma
op_star
id|e
suffix:semicolon
r_int
id|user
op_assign
l_int|0
comma
id|group
op_assign
l_int|0
comma
id|other
op_assign
l_int|0
comma
id|mask
op_assign
l_int|0
suffix:semicolon
r_int
id|mask_required
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aclp
)paren
r_goto
id|acl_invalid
suffix:semicolon
r_if
c_cond
(paren
id|aclp-&gt;acl_cnt
OG
id|XFS_ACL_MAX_ENTRIES
)paren
r_goto
id|acl_invalid
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|aclp-&gt;acl_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|entry
op_assign
op_amp
id|aclp-&gt;acl_entry
(braket
id|i
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|entry-&gt;ae_tag
)paren
(brace
r_case
id|ACL_USER_OBJ
suffix:colon
r_if
c_cond
(paren
id|user
op_increment
)paren
r_goto
id|acl_invalid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_GROUP_OBJ
suffix:colon
r_if
c_cond
(paren
id|group
op_increment
)paren
r_goto
id|acl_invalid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_OTHER
suffix:colon
r_if
c_cond
(paren
id|other
op_increment
)paren
r_goto
id|acl_invalid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_USER
suffix:colon
r_case
id|ACL_GROUP
suffix:colon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|aclp-&gt;acl_cnt
suffix:semicolon
id|j
op_increment
)paren
(brace
id|e
op_assign
op_amp
id|aclp-&gt;acl_entry
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;ae_id
op_eq
id|entry-&gt;ae_id
op_logical_and
id|e-&gt;ae_tag
op_eq
id|entry-&gt;ae_tag
)paren
r_goto
id|acl_invalid
suffix:semicolon
)brace
id|mask_required
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_MASK
suffix:colon
r_if
c_cond
(paren
id|mask
op_increment
)paren
r_goto
id|acl_invalid
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|acl_invalid
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|user
op_logical_or
op_logical_neg
id|group
op_logical_or
op_logical_neg
id|other
op_logical_or
(paren
id|mask_required
op_logical_and
op_logical_neg
id|mask
)paren
)paren
r_goto
id|acl_invalid
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|acl_invalid
suffix:colon
r_return
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Do ACL endian conversion.&n; */
id|STATIC
r_void
DECL|function|xfs_acl_get_endian
id|xfs_acl_get_endian
c_func
(paren
id|xfs_acl_t
op_star
id|aclp
)paren
(brace
id|xfs_acl_entry_t
op_star
id|ace
comma
op_star
id|end
suffix:semicolon
id|INT_SET
c_func
(paren
id|aclp-&gt;acl_cnt
comma
id|ARCH_CONVERT
comma
id|aclp-&gt;acl_cnt
)paren
suffix:semicolon
id|end
op_assign
op_amp
id|aclp-&gt;acl_entry
(braket
l_int|0
)braket
op_plus
id|aclp-&gt;acl_cnt
suffix:semicolon
r_for
c_loop
(paren
id|ace
op_assign
op_amp
id|aclp-&gt;acl_entry
(braket
l_int|0
)braket
suffix:semicolon
id|ace
OL
id|end
suffix:semicolon
id|ace
op_increment
)paren
(brace
id|INT_SET
c_func
(paren
id|ace-&gt;ae_tag
comma
id|ARCH_CONVERT
comma
id|ace-&gt;ae_tag
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ace-&gt;ae_id
comma
id|ARCH_CONVERT
comma
id|ace-&gt;ae_id
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ace-&gt;ae_perm
comma
id|ARCH_CONVERT
comma
id|ace-&gt;ae_perm
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Get the ACL from the EA and do endian conversion.&n; */
id|STATIC
r_void
DECL|function|xfs_acl_get_attr
id|xfs_acl_get_attr
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_acl_t
op_star
id|aclp
comma
r_int
id|kind
comma
r_int
id|flags
comma
r_int
op_star
id|error
)paren
(brace
r_int
id|len
op_assign
r_sizeof
(paren
id|xfs_acl_t
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|ATTR_KERNOVAL
)paren
ques
c_cond
(paren
id|aclp
op_eq
l_int|NULL
)paren
suffix:colon
l_int|1
)paren
suffix:semicolon
id|flags
op_or_assign
id|ATTR_ROOT
suffix:semicolon
id|VOP_ATTR_GET
c_func
(paren
id|vp
comma
id|kind
op_eq
id|_ACL_TYPE_ACCESS
ques
c_cond
id|SGI_ACL_FILE
suffix:colon
id|SGI_ACL_DEFAULT
comma
(paren
r_char
op_star
)paren
id|aclp
comma
op_amp
id|len
comma
id|flags
comma
id|sys_cred
comma
op_star
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|error
op_logical_or
(paren
id|flags
op_amp
id|ATTR_KERNOVAL
)paren
)paren
r_return
suffix:semicolon
id|xfs_acl_get_endian
c_func
(paren
id|aclp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the EA with the ACL and do endian conversion.&n; */
id|STATIC
r_void
DECL|function|xfs_acl_set_attr
id|xfs_acl_set_attr
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_acl_t
op_star
id|aclp
comma
r_int
id|kind
comma
r_int
op_star
id|error
)paren
(brace
id|xfs_acl_entry_t
op_star
id|ace
comma
op_star
id|newace
comma
op_star
id|end
suffix:semicolon
id|xfs_acl_t
op_star
id|newacl
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|_ACL_ALLOC
c_func
(paren
id|newacl
)paren
)paren
)paren
(brace
op_star
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_return
suffix:semicolon
)brace
id|len
op_assign
r_sizeof
(paren
id|xfs_acl_t
)paren
op_minus
(paren
r_sizeof
(paren
id|xfs_acl_entry_t
)paren
op_star
(paren
id|XFS_ACL_MAX_ENTRIES
op_minus
id|aclp-&gt;acl_cnt
)paren
)paren
suffix:semicolon
id|end
op_assign
op_amp
id|aclp-&gt;acl_entry
(braket
l_int|0
)braket
op_plus
id|aclp-&gt;acl_cnt
suffix:semicolon
r_for
c_loop
(paren
id|ace
op_assign
op_amp
id|aclp-&gt;acl_entry
(braket
l_int|0
)braket
comma
id|newace
op_assign
op_amp
id|newacl-&gt;acl_entry
(braket
l_int|0
)braket
suffix:semicolon
id|ace
OL
id|end
suffix:semicolon
id|ace
op_increment
comma
id|newace
op_increment
)paren
(brace
id|INT_SET
c_func
(paren
id|newace-&gt;ae_tag
comma
id|ARCH_CONVERT
comma
id|ace-&gt;ae_tag
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newace-&gt;ae_id
comma
id|ARCH_CONVERT
comma
id|ace-&gt;ae_id
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|newace-&gt;ae_perm
comma
id|ARCH_CONVERT
comma
id|ace-&gt;ae_perm
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|newacl-&gt;acl_cnt
comma
id|ARCH_CONVERT
comma
id|aclp-&gt;acl_cnt
)paren
suffix:semicolon
id|VOP_ATTR_SET
c_func
(paren
id|vp
comma
id|kind
op_eq
id|_ACL_TYPE_ACCESS
ques
c_cond
id|SGI_ACL_FILE
suffix:colon
id|SGI_ACL_DEFAULT
comma
(paren
r_char
op_star
)paren
id|newacl
comma
id|len
comma
id|ATTR_ROOT
comma
id|sys_cred
comma
op_star
id|error
)paren
suffix:semicolon
id|_ACL_FREE
c_func
(paren
id|newacl
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_acl_vtoacl
id|xfs_acl_vtoacl
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_acl_t
op_star
id|access_acl
comma
id|xfs_acl_t
op_star
id|default_acl
)paren
(brace
id|vattr_t
id|va
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|access_acl
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get the Access ACL and the mode.  If either cannot&n;&t;&t; * be obtained for some reason, invalidate the access ACL.&n;&t;&t; */
id|xfs_acl_get_attr
c_func
(paren
id|vp
comma
id|access_acl
comma
id|_ACL_TYPE_ACCESS
comma
l_int|0
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/* Got the ACL, need the mode... */
id|va.va_mask
op_assign
id|XFS_AT_MODE
suffix:semicolon
id|VOP_GETATTR
c_func
(paren
id|vp
comma
op_amp
id|va
comma
l_int|0
comma
id|sys_cred
comma
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
id|access_acl-&gt;acl_cnt
op_assign
id|XFS_ACL_NOT_PRESENT
suffix:semicolon
r_else
multiline_comment|/* We have a good ACL and the file mode, synchronize. */
id|xfs_acl_sync_mode
c_func
(paren
id|va.va_mode
comma
id|access_acl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|default_acl
)paren
(brace
id|xfs_acl_get_attr
c_func
(paren
id|vp
comma
id|default_acl
comma
id|_ACL_TYPE_DEFAULT
comma
l_int|0
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|default_acl-&gt;acl_cnt
op_assign
id|XFS_ACL_NOT_PRESENT
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This function retrieves the parent directory&squot;s acl, processes it&n; * and lets the child inherit the acl(s) that it should.&n; */
r_int
DECL|function|xfs_acl_inherit
id|xfs_acl_inherit
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|vattr_t
op_star
id|vap
comma
id|xfs_acl_t
op_star
id|pdaclp
)paren
(brace
id|xfs_acl_t
op_star
id|cacl
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|basicperms
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the parent does not have a default ACL, or it&squot;s an&n;&t; * invalid ACL, we&squot;re done.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|vp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdaclp
op_logical_or
id|xfs_acl_invalid
c_func
(paren
id|pdaclp
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the default ACL of the containing directory to&n;&t; * the access ACL of the new file and use the mode that&n;&t; * was passed in to set up the correct initial values for&n;&t; * the u::,g::[m::], and o:: entries.  This is what makes&n;&t; * umask() &quot;work&quot; with ACL&squot;s.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|_ACL_ALLOC
c_func
(paren
id|cacl
)paren
)paren
)paren
r_return
id|ENOMEM
suffix:semicolon
id|memcpy
c_func
(paren
id|cacl
comma
id|pdaclp
comma
r_sizeof
(paren
id|xfs_acl_t
)paren
)paren
suffix:semicolon
id|xfs_acl_filter_mode
c_func
(paren
id|vap-&gt;va_mode
comma
id|cacl
)paren
suffix:semicolon
id|xfs_acl_setmode
c_func
(paren
id|vp
comma
id|cacl
comma
op_amp
id|basicperms
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the Default and Access ACL on the file.  The mode is already&n;&t; * set on the file, so we don&squot;t need to worry about that.&n;&t; *&n;&t; * If the new file is a directory, its default ACL is a copy of&n;&t; * the containing directory&squot;s default ACL.&n;&t; */
r_if
c_cond
(paren
id|vp-&gt;v_type
op_eq
id|VDIR
)paren
id|xfs_acl_set_attr
c_func
(paren
id|vp
comma
id|pdaclp
comma
id|_ACL_TYPE_DEFAULT
comma
op_amp
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
op_logical_neg
id|basicperms
)paren
id|xfs_acl_set_attr
c_func
(paren
id|vp
comma
id|cacl
comma
id|_ACL_TYPE_ACCESS
comma
op_amp
id|error
)paren
suffix:semicolon
id|_ACL_FREE
c_func
(paren
id|cacl
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the correct mode on the file based on the supplied ACL.  This&n; * makes sure that the mode on the file reflects the state of the&n; * u::,g::[m::], and o:: entries in the ACL.  Since the mode is where&n; * the ACL is going to get the permissions for these entries, we must&n; * synchronize the mode whenever we set the ACL on a file.&n; */
id|STATIC
r_int
DECL|function|xfs_acl_setmode
id|xfs_acl_setmode
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_acl_t
op_star
id|acl
comma
r_int
op_star
id|basicperms
)paren
(brace
id|vattr_t
id|va
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|ap
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|gap
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|error
comma
id|nomask
op_assign
l_int|1
suffix:semicolon
op_star
id|basicperms
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|acl-&gt;acl_cnt
op_eq
id|XFS_ACL_NOT_PRESENT
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the u::, g::, o::, and m:: bits from the ACL into the&n;&t; * mode.  The m:: bits take precedence over the g:: bits.&n;&t; */
id|va.va_mask
op_assign
id|XFS_AT_MODE
suffix:semicolon
id|VOP_GETATTR
c_func
(paren
id|vp
comma
op_amp
id|va
comma
l_int|0
comma
id|sys_cred
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|va.va_mask
op_assign
id|XFS_AT_MODE
suffix:semicolon
id|va.va_mode
op_and_assign
op_complement
(paren
id|S_IRWXU
op_or
id|S_IRWXG
op_or
id|S_IRWXO
)paren
suffix:semicolon
id|ap
op_assign
id|acl-&gt;acl_entry
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|acl-&gt;acl_cnt
suffix:semicolon
op_increment
id|i
)paren
(brace
r_switch
c_cond
(paren
id|ap-&gt;ae_tag
)paren
(brace
r_case
id|ACL_USER_OBJ
suffix:colon
id|va.va_mode
op_or_assign
id|ap-&gt;ae_perm
op_lshift
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_GROUP_OBJ
suffix:colon
id|gap
op_assign
id|ap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_MASK
suffix:colon
multiline_comment|/* more than just standard modes */
id|nomask
op_assign
l_int|0
suffix:semicolon
id|va.va_mode
op_or_assign
id|ap-&gt;ae_perm
op_lshift
l_int|3
suffix:semicolon
op_star
id|basicperms
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_OTHER
suffix:colon
id|va.va_mode
op_or_assign
id|ap-&gt;ae_perm
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* more than just standard modes */
op_star
id|basicperms
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ap
op_increment
suffix:semicolon
)brace
multiline_comment|/* Set the group bits from ACL_GROUP_OBJ if there&squot;s no ACL_MASK */
r_if
c_cond
(paren
id|gap
op_logical_and
id|nomask
)paren
id|va.va_mode
op_or_assign
id|gap-&gt;ae_perm
op_lshift
l_int|3
suffix:semicolon
id|VOP_SETATTR
c_func
(paren
id|vp
comma
op_amp
id|va
comma
l_int|0
comma
id|sys_cred
comma
id|error
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The permissions for the special ACL entries (u::, g::[m::], o::) are&n; * actually stored in the file mode (if there is both a group and a mask,&n; * the group is stored in the ACL entry and the mask is stored on the file).&n; * This allows the mode to remain automatically in sync with the ACL without&n; * the need for a call-back to the ACL system at every point where the mode&n; * could change.  This function takes the permissions from the specified mode&n; * and places it in the supplied ACL.&n; *&n; * This implementation draws its validity from the fact that, when the ACL&n; * was assigned, the mode was copied from the ACL.&n; * If the mode did not change, therefore, the mode remains exactly what was&n; * taken from the special ACL entries at assignment.&n; * If a subsequent chmod() was done, the POSIX spec says that the change in&n; * mode must cause an update to the ACL seen at user level and used for&n; * access checks.  Before and after a mode change, therefore, the file mode&n; * most accurately reflects what the special ACL entries should permit/deny.&n; *&n; * CAVEAT: If someone sets the SGI_ACL_FILE attribute directly,&n; *         the existing mode bits will override whatever is in the&n; *         ACL. Similarly, if there is a pre-existing ACL that was&n; *         never in sync with its mode (owing to a bug in 6.5 and&n; *         before), it will now magically (or mystically) be&n; *         synchronized.  This could cause slight astonishment, but&n; *         it is better than inconsistent permissions.&n; *&n; * The supplied ACL is a template that may contain any combination&n; * of special entries.  These are treated as place holders when we fill&n; * out the ACL.  This routine does not add or remove special entries, it&n; * simply unites each special entry with its associated set of permissions.&n; */
id|STATIC
r_void
DECL|function|xfs_acl_sync_mode
id|xfs_acl_sync_mode
c_func
(paren
id|mode_t
id|mode
comma
id|xfs_acl_t
op_star
id|acl
)paren
(brace
r_int
id|i
comma
id|nomask
op_assign
l_int|1
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|ap
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|gap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Set ACL entries. POSIX1003.1eD16 requires that the MASK&n;&t; * be set instead of the GROUP entry, if there is a MASK.&n;&t; */
r_for
c_loop
(paren
id|ap
op_assign
id|acl-&gt;acl_entry
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|acl-&gt;acl_cnt
suffix:semicolon
id|ap
op_increment
comma
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|ap-&gt;ae_tag
)paren
(brace
r_case
id|ACL_USER_OBJ
suffix:colon
id|ap-&gt;ae_perm
op_assign
(paren
id|mode
op_rshift
l_int|6
)paren
op_amp
l_int|0x7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_GROUP_OBJ
suffix:colon
id|gap
op_assign
id|ap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_MASK
suffix:colon
id|nomask
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;ae_perm
op_assign
(paren
id|mode
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_OTHER
suffix:colon
id|ap-&gt;ae_perm
op_assign
id|mode
op_amp
l_int|0x7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the ACL_GROUP_OBJ if there&squot;s no ACL_MASK */
r_if
c_cond
(paren
id|gap
op_logical_and
id|nomask
)paren
id|gap-&gt;ae_perm
op_assign
(paren
id|mode
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
suffix:semicolon
)brace
multiline_comment|/*&n; * When inheriting an Access ACL from a directory Default ACL,&n; * the ACL bits are set to the intersection of the ACL default&n; * permission bits and the file permission bits in mode. If there&n; * are no permission bits on the file then we must not give them&n; * the ACL. This is what what makes umask() work with ACLs.&n; */
id|STATIC
r_void
DECL|function|xfs_acl_filter_mode
id|xfs_acl_filter_mode
c_func
(paren
id|mode_t
id|mode
comma
id|xfs_acl_t
op_star
id|acl
)paren
(brace
r_int
id|i
comma
id|nomask
op_assign
l_int|1
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|ap
suffix:semicolon
id|xfs_acl_entry_t
op_star
id|gap
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Set ACL entries. POSIX1003.1eD16 requires that the MASK&n;&t; * be merged with GROUP entry, if there is a MASK.&n;&t; */
r_for
c_loop
(paren
id|ap
op_assign
id|acl-&gt;acl_entry
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|acl-&gt;acl_cnt
suffix:semicolon
id|ap
op_increment
comma
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|ap-&gt;ae_tag
)paren
(brace
r_case
id|ACL_USER_OBJ
suffix:colon
id|ap-&gt;ae_perm
op_and_assign
(paren
id|mode
op_rshift
l_int|6
)paren
op_amp
l_int|0x7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_GROUP_OBJ
suffix:colon
id|gap
op_assign
id|ap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_MASK
suffix:colon
id|nomask
op_assign
l_int|0
suffix:semicolon
id|ap-&gt;ae_perm
op_and_assign
(paren
id|mode
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACL_OTHER
suffix:colon
id|ap-&gt;ae_perm
op_and_assign
id|mode
op_amp
l_int|0x7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the ACL_GROUP_OBJ if there&squot;s no ACL_MASK */
r_if
c_cond
(paren
id|gap
op_logical_and
id|nomask
)paren
id|gap-&gt;ae_perm
op_and_assign
(paren
id|mode
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
suffix:semicolon
)brace
eof
