multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_itable.h&quot;
macro_line|#include &quot;xfs_utils.h&quot;
multiline_comment|/*&n; * xfs_get_dir_entry is used to get a reference to an inode given&n; * its parent directory inode and the name of the file.&t; It does&n; * not lock the child inode, and it unlocks the directory before&n; * returning.  The directory&squot;s generation number is returned for&n; * use by a later call to xfs_lock_dir_and_entry.&n; */
r_int
DECL|function|xfs_get_dir_entry
id|xfs_get_dir_entry
c_func
(paren
id|vname_t
op_star
id|dentry
comma
id|xfs_inode_t
op_star
op_star
id|ipp
)paren
(brace
id|vnode_t
op_star
id|vp
suffix:semicolon
id|bhv_desc_t
op_star
id|bdp
suffix:semicolon
id|vp
op_assign
id|VNAME_TO_VNODE
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|bdp
op_assign
id|vn_bhv_lookup_unlocked
c_func
(paren
id|VN_BHV_HEAD
c_func
(paren
id|vp
)paren
comma
op_amp
id|xfs_vnodeops
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdp
)paren
(brace
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
id|VN_HOLD
c_func
(paren
id|vp
)paren
suffix:semicolon
op_star
id|ipp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xfs_dir_lookup_int
id|xfs_dir_lookup_int
c_func
(paren
id|bhv_desc_t
op_star
id|dir_bdp
comma
id|uint
id|lock_mode
comma
id|vname_t
op_star
id|dentry
comma
id|xfs_ino_t
op_star
id|inum
comma
id|xfs_inode_t
op_star
op_star
id|ipp
)paren
(brace
id|vnode_t
op_star
id|dir_vp
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|dir_vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|dir_vp
comma
id|__FUNCTION__
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|dir_bdp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_DIR_LOOKUP
c_func
(paren
id|dp-&gt;i_mount
comma
l_int|NULL
comma
id|dp
comma
id|VNAME
c_func
(paren
id|dentry
)paren
comma
id|VNAMELEN
c_func
(paren
id|dentry
)paren
comma
id|inum
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * Unlock the directory. We do this because we can&squot;t&n;&t;&t; * hold the directory lock while doing the vn_get()&n;&t;&t; * in xfs_iget().  Doing so could cause us to hold&n;&t;&t; * a lock while waiting for the inode to finish&n;&t;&t; * being inactive while it&squot;s waiting for a log&n;&t;&t; * reservation in the inactive routine.&n;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|lock_mode
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iget
c_func
(paren
id|dp-&gt;i_mount
comma
l_int|NULL
comma
op_star
id|inum
comma
l_int|0
comma
l_int|0
comma
id|ipp
comma
l_int|0
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|dp
comma
id|lock_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
id|ipp
)paren
op_member_access_from_pointer
id|i_d.di_mode
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The inode has been freed.  Something is&n;&t;&t;&t; * wrong so just get out of here.&n;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|lock_mode
)paren
suffix:semicolon
id|xfs_iput_new
c_func
(paren
op_star
id|ipp
comma
l_int|0
)paren
suffix:semicolon
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|dp
comma
id|lock_mode
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocates a new inode from disk and return a pointer to the&n; * incore copy. This routine will internally commit the current&n; * transaction and allocate a new one if the Space Manager needed&n; * to do an allocation to replenish the inode free-list.&n; *&n; * This routine is designed to be called from xfs_create and&n; * xfs_create_dir.&n; *&n; */
r_int
DECL|function|xfs_dir_ialloc
id|xfs_dir_ialloc
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|tpp
comma
multiline_comment|/* input: current transaction;&n;&t;&t;&t;&t;&t;   output: may be a new transaction. */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* directory within whose allocate&n;&t;&t;&t;&t;&t;   the inode. */
id|mode_t
id|mode
comma
id|nlink_t
id|nlink
comma
id|xfs_dev_t
id|rdev
comma
id|cred_t
op_star
id|credp
comma
id|prid_t
id|prid
comma
multiline_comment|/* project id */
r_int
id|okalloc
comma
multiline_comment|/* ok to allocate new space */
id|xfs_inode_t
op_star
op_star
id|ipp
comma
multiline_comment|/* pointer to inode; it will be&n;&t;&t;&t;&t;&t;   locked. */
r_int
op_star
id|committed
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_trans_t
op_star
id|ntp
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_buf_t
op_star
id|ialloc_context
op_assign
l_int|NULL
suffix:semicolon
id|boolean_t
id|call_again
op_assign
id|B_FALSE
suffix:semicolon
r_int
id|code
suffix:semicolon
id|uint
id|log_res
suffix:semicolon
id|uint
id|log_count
suffix:semicolon
r_void
op_star
id|dqinfo
suffix:semicolon
id|uint
id|tflags
suffix:semicolon
id|tp
op_assign
op_star
id|tpp
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * xfs_ialloc will return a pointer to an incore inode if&n;&t; * the Space Manager has an available inode on the free&n;&t; * list. Otherwise, it will do an allocation and replenish&n;&t; * the freelist.  Since we can only do one allocation per&n;&t; * transaction without deadlocks, we will need to commit the&n;&t; * current transaction and start a new one.  We will then&n;&t; * need to call xfs_ialloc again to get the inode.&n;&t; *&n;&t; * If xfs_ialloc did an allocation to replenish the freelist,&n;&t; * it returns the bp containing the head of the freelist as&n;&t; * ialloc_context. We will hold a lock on it across the&n;&t; * transaction commit so that no other process can steal&n;&t; * the inode(s) that we&squot;ve just allocated.&n;&t; */
id|code
op_assign
id|xfs_ialloc
c_func
(paren
id|tp
comma
id|dp
comma
id|mode
comma
id|nlink
comma
id|rdev
comma
id|credp
comma
id|prid
comma
id|okalloc
comma
op_amp
id|ialloc_context
comma
op_amp
id|call_again
comma
op_amp
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return an error if we were unable to allocate a new inode.&n;&t; * This should only happen if we run out of space on disk or&n;&t; * encounter a disk error.&n;&t; */
r_if
c_cond
(paren
id|code
)paren
(brace
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|code
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|call_again
op_logical_and
(paren
id|ip
op_eq
l_int|NULL
)paren
)paren
(brace
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If call_again is set, then we were unable to get an&n;&t; * inode in one operation.  We need to commit the current&n;&t; * transaction and call xfs_ialloc() again.  It is guaranteed&n;&t; * to succeed the second time.&n;&t; */
r_if
c_cond
(paren
id|call_again
)paren
(brace
multiline_comment|/*&n;&t;&t; * Normally, xfs_trans_commit releases all the locks.&n;&t;&t; * We call bhold to hang on to the ialloc_context across&n;&t;&t; * the commit.  Holding this buffer prevents any other&n;&t;&t; * processes from doing any allocations in this&n;&t;&t; * allocation group.&n;&t;&t; */
id|xfs_trans_bhold
c_func
(paren
id|tp
comma
id|ialloc_context
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Save the log reservation so we can use&n;&t;&t; * them in the next transaction.&n;&t;&t; */
id|log_res
op_assign
id|xfs_trans_get_log_res
c_func
(paren
id|tp
)paren
suffix:semicolon
id|log_count
op_assign
id|xfs_trans_get_log_count
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We want the quota changes to be associated with the next&n;&t;&t; * transaction, NOT this one. So, detach the dqinfo from this&n;&t;&t; * and attach it to the next transaction.&n;&t;&t; */
id|dqinfo
op_assign
l_int|NULL
suffix:semicolon
id|tflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;t_dqinfo
)paren
(brace
id|dqinfo
op_assign
(paren
r_void
op_star
)paren
id|tp-&gt;t_dqinfo
suffix:semicolon
id|tp-&gt;t_dqinfo
op_assign
l_int|NULL
suffix:semicolon
id|tflags
op_assign
id|tp-&gt;t_flags
op_amp
id|XFS_TRANS_DQ_DIRTY
suffix:semicolon
id|tp-&gt;t_flags
op_and_assign
op_complement
(paren
id|XFS_TRANS_DQ_DIRTY
)paren
suffix:semicolon
)brace
id|ntp
op_assign
id|xfs_trans_dup
c_func
(paren
id|tp
)paren
suffix:semicolon
id|code
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|tp
op_assign
id|ntp
suffix:semicolon
r_if
c_cond
(paren
id|committed
op_ne
l_int|NULL
)paren
(brace
op_star
id|committed
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we get an error during the commit processing,&n;&t;&t; * release the buffer that is still held and return&n;&t;&t; * to the caller.&n;&t;&t; */
r_if
c_cond
(paren
id|code
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|ialloc_context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqinfo
)paren
(brace
id|tp-&gt;t_dqinfo
op_assign
id|dqinfo
suffix:semicolon
id|XFS_TRANS_FREE_DQINFO
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp
)paren
suffix:semicolon
)brace
op_star
id|tpp
op_assign
id|ntp
suffix:semicolon
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|code
suffix:semicolon
)brace
id|code
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|log_res
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|log_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Re-attach the quota info that we detached from prev trx.&n;&t;&t; */
r_if
c_cond
(paren
id|dqinfo
)paren
(brace
id|tp-&gt;t_dqinfo
op_assign
id|dqinfo
suffix:semicolon
id|tp-&gt;t_flags
op_or_assign
id|tflags
suffix:semicolon
)brace
r_if
c_cond
(paren
id|code
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|ialloc_context
)paren
suffix:semicolon
op_star
id|tpp
op_assign
id|ntp
suffix:semicolon
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|code
suffix:semicolon
)brace
id|xfs_trans_bjoin
c_func
(paren
id|tp
comma
id|ialloc_context
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Call ialloc again. Since we&squot;ve locked out all&n;&t;&t; * other allocations in this allocation group,&n;&t;&t; * this call should always succeed.&n;&t;&t; */
id|code
op_assign
id|xfs_ialloc
c_func
(paren
id|tp
comma
id|dp
comma
id|mode
comma
id|nlink
comma
id|rdev
comma
id|credp
comma
id|prid
comma
id|okalloc
comma
op_amp
id|ialloc_context
comma
op_amp
id|call_again
comma
op_amp
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we get an error at this point, return to the caller&n;&t;&t; * so that the current transaction can be aborted.&n;&t;&t; */
r_if
c_cond
(paren
id|code
)paren
(brace
op_star
id|tpp
op_assign
id|tp
suffix:semicolon
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|code
suffix:semicolon
)brace
id|ASSERT
(paren
(paren
op_logical_neg
id|call_again
)paren
op_logical_and
(paren
id|ip
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|committed
op_ne
l_int|NULL
)paren
(brace
op_star
id|committed
op_assign
l_int|0
suffix:semicolon
)brace
)brace
op_star
id|ipp
op_assign
id|ip
suffix:semicolon
op_star
id|tpp
op_assign
id|tp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement the link count on an inode &amp; log the change.&n; * If this causes the link count to go to zero, initiate the&n; * logging activity required to truncate a file.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_droplink
id|xfs_droplink
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|ASSERT
(paren
id|ip-&gt;i_d.di_nlink
OG
l_int|0
)paren
suffix:semicolon
id|ip-&gt;i_d.di_nlink
op_decrement
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nlink
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re dropping the last link to this file.&n;&t;&t; * Move the on-disk inode to the AGI unlinked list.&n;&t;&t; * From xfs_inactive() we will pull the inode from&n;&t;&t; * the list and free it.&n;&t;&t; */
id|error
op_assign
id|xfs_iunlink
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This gets called when the inode&squot;s version needs to be changed from 1 to 2.&n; * Currently this happens when the nlink field overflows the old 16-bit value&n; * or when chproj is called to change the project for the first time.&n; * As a side effect the superblock version will also get rev&squot;d&n; * to contain the NLINK bit.&n; */
r_void
DECL|function|xfs_bump_ino_vers2
id|xfs_bump_ino_vers2
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
suffix:semicolon
id|ip-&gt;i_d.di_version
op_assign
id|XFS_DINODE_VERSION_2
suffix:semicolon
id|ip-&gt;i_d.di_onlink
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|ip-&gt;i_d.di_pad
(braket
l_int|0
)braket
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|ip-&gt;i_d.di_pad
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|XFS_SB_VERSION_ADDNLINK
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|xfs_mod_sb
c_func
(paren
id|tp
comma
id|XFS_SB_VERSIONNUM
)paren
suffix:semicolon
)brace
r_else
(brace
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Caller must log the inode */
)brace
multiline_comment|/*&n; * Increment the link count on an inode &amp; log the change.&n; */
r_int
DECL|function|xfs_bumplink
id|xfs_bumplink
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nlink
op_ge
id|XFS_MAXLINK
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EMLINK
)paren
suffix:semicolon
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
OG
l_int|0
)paren
suffix:semicolon
id|ip-&gt;i_d.di_nlink
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_nlink
OG
id|XFS_MAXLINK_1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The inode has increased its number of links beyond&n;&t;&t; * what can fit in an old format inode.  It now needs&n;&t;&t; * to be converted to a version 2 inode with a 32 bit&n;&t;&t; * link count.  If this is the first inode in the file&n;&t;&t; * system to do this, then we need to bump the superblock&n;&t;&t; * version number as well.&n;&t;&t; */
id|xfs_bump_ino_vers2
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to truncate the given file to 0 length.  Currently called&n; * only out of xfs_remove when it has to truncate a file to free&n; * up space for the remove to proceed.&n; */
r_int
DECL|function|xfs_truncate_file
id|xfs_truncate_file
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
multiline_comment|/*&n;&t; * This is called to truncate the quotainodes too.&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_ino
op_ne
id|mp-&gt;m_sb.sb_uquotino
)paren
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_ino
op_ne
id|mp-&gt;m_sb.sb_gquotino
)paren
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Make the call to xfs_itruncate_start before starting the&n;&t; * transaction, because we cannot make the call while we&squot;re&n;&t; * in a transaction.&n;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_itruncate_start
c_func
(paren
id|ip
comma
id|XFS_ITRUNC_DEFINITE
comma
(paren
id|xfs_fsize_t
)paren
l_int|0
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_TRUNCATE_FILE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Follow the normal truncate locking protocol.  Since we&n;&t; * hold the inode in the transaction, we know that it&squot;s number&n;&t; * of references will stay constant.&n;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Signal a sync xaction.  The only case where that isn&squot;t&n;&t; * the case is if we&squot;re truncating an already unlinked file&n;&t; * on a wsync fs.  In that case, we know the blocks can&squot;t&n;&t; * reappear in the file because the links to file are&n;&t; * permanently toast.  Currently, we&squot;re always going to&n;&t; * want a sync transaction because this code is being&n;&t; * called from places where nlink is guaranteed to be 1&n;&t; * but I&squot;m leaving the tests in to protect against future&n;&t; * changes -- rcc.&n;&t; */
id|error
op_assign
id|xfs_itruncate_finish
c_func
(paren
op_amp
id|tp
comma
id|ip
comma
(paren
id|xfs_fsize_t
)paren
l_int|0
comma
id|XFS_DATA_FORK
comma
(paren
(paren
id|ip-&gt;i_d.di_nlink
op_ne
l_int|0
op_logical_or
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
