multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * xfs_dir2_leaf.c&n; * XFS directory version 2 implementation - single leaf form&n; * see xfs_dir2_leaf.h for data structures.&n; * These directories have multiple XFS_DIR2_DATA blocks and one&n; * XFS_DIR2_LEAF1 block containing the hash table and freespace map.&n; */
macro_line|#include &lt;xfs.h&gt;
multiline_comment|/*&n; * Local function declarations.&n; */
macro_line|#ifdef DEBUG
r_static
r_void
id|xfs_dir2_leaf_check
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dabuf_t
op_star
id|bp
)paren
suffix:semicolon
macro_line|#else
DECL|macro|xfs_dir2_leaf_check
mdefine_line|#define xfs_dir2_leaf_check(dp, bp)
macro_line|#endif
r_static
r_int
id|xfs_dir2_leaf_lookup_int
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dabuf_t
op_star
op_star
id|lbpp
comma
r_int
op_star
id|indexp
comma
id|xfs_dabuf_t
op_star
op_star
id|dbpp
)paren
suffix:semicolon
multiline_comment|/*&n; * Convert a block form directory to a leaf form directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_to_leaf
id|xfs_dir2_block_to_leaf
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|dbp
)paren
multiline_comment|/* input block&squot;s buffer */
(brace
id|xfs_dir2_data_off_t
op_star
id|bestsp
suffix:semicolon
multiline_comment|/* leaf&squot;s bestsp entries */
id|xfs_dablk_t
id|blkno
suffix:semicolon
multiline_comment|/* leaf block&squot;s bno */
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block&squot;s leaf entries */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block&squot;s tail */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
id|xfs_dabuf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* leaf block&squot;s buffer */
id|xfs_dir2_db_t
id|ldb
suffix:semicolon
multiline_comment|/* leaf block&squot;s bno */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf&squot;s tail */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log block header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to rescan bestfree */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_b
c_func
(paren
l_string|&quot;block_to_leaf&quot;
comma
id|args
comma
id|dbp
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * Add the leaf block to the inode.&n;&t; * This interface will only put blocks in the leaf/node range.&n;&t; * Since that&squot;s empty now, we&squot;ll get the root (block 0 in range).&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|args
comma
op_amp
id|blkno
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ldb
op_assign
id|XFS_DIR2_DA_TO_DB
c_func
(paren
id|mp
comma
id|blkno
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ldb
op_eq
id|XFS_DIR2_LEAF_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the leaf block, get a buffer for it.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_leaf_init
c_func
(paren
id|args
comma
id|ldb
comma
op_amp
id|lbp
comma
id|XFS_DIR2_LEAF1_MAGIC
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|lbp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|block
op_assign
id|dbp-&gt;data
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the counts in the leaf header.&n;&t; */
id|INT_COPY
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* INT_: type change */
id|INT_COPY
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* INT_: type change */
multiline_comment|/*&n;&t; * Could compact these but I think we always do the conversion&n;&t; * after squeezing out stale entries.&n;&t; */
id|memcpy
c_func
(paren
id|leaf-&gt;ents
comma
id|blp
comma
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_dir2_leaf_entry_t
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|lbp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|needscan
op_assign
l_int|0
suffix:semicolon
id|needlog
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Make the space formerly occupied by the leaf entries and block&n;&t; * tail be free.&n;&t; */
id|xfs_dir2_data_make_free
c_func
(paren
id|tp
comma
id|dbp
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|blp
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|mp-&gt;m_dirblksize
op_minus
(paren
r_char
op_star
)paren
id|blp
)paren
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the block header, make it a data block.&n;&t; */
id|INT_SET
c_func
(paren
id|block-&gt;hdr.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_data_t
op_star
)paren
id|block
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up leaf tail and bests table.&n;&t; */
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|bestsp
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_COPY
c_func
(paren
id|bestsp
(braket
l_int|0
)braket
comma
id|block-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log the data header and leaf bests table.&n;&t; */
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|lbp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add an entry to a leaf form directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_addname
id|xfs_dir2_leaf_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_dir2_data_off_t
op_star
id|bestsp
suffix:semicolon
multiline_comment|/* freespace table in leaf */
r_int
id|compact
suffix:semicolon
multiline_comment|/* need to compact leaves */
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
multiline_comment|/* data block structure */
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data block buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data block entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* data unused entry */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|grown
suffix:semicolon
multiline_comment|/* allocated new data block */
r_int
id|highstale
suffix:semicolon
multiline_comment|/* index of next stale leaf */
r_int
id|i
suffix:semicolon
multiline_comment|/* temporary, index */
r_int
id|index
suffix:semicolon
multiline_comment|/* leaf table position */
id|xfs_dabuf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* leaf&squot;s buffer */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
r_int
id|length
suffix:semicolon
multiline_comment|/* length of new entry */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry table pointer */
r_int
id|lfloglow
suffix:semicolon
multiline_comment|/* low leaf logging index */
r_int
id|lfloghigh
suffix:semicolon
multiline_comment|/* high leaf logging index */
r_int
id|lowstale
suffix:semicolon
multiline_comment|/* index of prev stale leaf */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail pointer */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needbytes
suffix:semicolon
multiline_comment|/* leaf block bytes needed */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log data header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to rescan data free */
id|xfs_dir2_data_off_t
op_star
id|tagp
suffix:semicolon
multiline_comment|/* end of data entry */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_db_t
id|use_block
suffix:semicolon
multiline_comment|/* data block number */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;leaf_addname&quot;
comma
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Read the leaf block.&n;&t; */
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|mp-&gt;m_dirleafblk
comma
op_minus
l_int|1
comma
op_amp
id|lbp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|lbp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the entry by hash value and name.&n;&t; * We know it&squot;s not there, our caller has already done a lookup.&n;&t; * So the index is of the entry to insert in front of.&n;&t; * But if there are dup hash values the index is of the first of those.&n;&t; */
id|index
op_assign
id|xfs_dir2_leaf_search_hash
c_func
(paren
id|args
comma
id|lbp
)paren
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|bestsp
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|length
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if there are any entries with the same hash value&n;&t; * and space in their block for the new entry.&n;&t; * This is good because it puts multiple same-hash value entries&n;&t; * in a data block, improving the lookup of those entries.&n;&t; */
r_for
c_loop
(paren
id|use_block
op_assign
op_minus
l_int|1
comma
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
id|index
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|lep-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|args-&gt;hashval
suffix:semicolon
id|index
op_increment
comma
id|lep
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
r_continue
suffix:semicolon
id|i
op_assign
id|XFS_DIR2_DATAPTR_TO_DB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
OL
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDATAOFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
op_ge
id|length
)paren
(brace
id|use_block
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find a block yet, linear search all the data blocks.&n;&t; */
r_if
c_cond
(paren
id|use_block
op_eq
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Remember a block we see that&squot;s missing.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDATAOFF
op_logical_and
id|use_block
op_eq
op_minus
l_int|1
)paren
id|use_block
op_assign
id|i
suffix:semicolon
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
op_ge
id|length
)paren
(brace
id|use_block
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * How many bytes do we need in the leaf block?&n;&t; */
id|needbytes
op_assign
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;ents
(braket
l_int|0
)braket
)paren
)paren
op_plus
(paren
id|use_block
op_ne
op_minus
l_int|1
ques
c_cond
l_int|0
suffix:colon
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;bests
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now kill use_block if it refers to a missing block, so we&n;&t; * can use it as an indication of allocation needed.&n;&t; */
r_if
c_cond
(paren
id|use_block
op_ne
op_minus
l_int|1
op_logical_and
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|use_block
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDATAOFF
)paren
id|use_block
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t have enough free bytes but we can make enough&n;&t; * by compacting out stale entries, we&squot;ll do that.&n;&t; */
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|bestsp
op_minus
(paren
r_char
op_star
)paren
op_amp
id|leaf-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
template_param
l_int|1
)paren
(brace
id|compact
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Otherwise if we don&squot;t have enough free bytes we need to&n;&t; * convert to node form.&n;&t; */
r_else
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|bestsp
op_minus
(paren
r_char
op_star
)paren
op_amp
id|leaf-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
OL
id|needbytes
)paren
(brace
multiline_comment|/*&n;&t;&t; * Just checking or no space reservation, give up.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
op_logical_or
id|args-&gt;total
op_eq
l_int|0
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Convert to node form.&n;&t;&t; */
id|error
op_assign
id|xfs_dir2_leaf_to_node
c_func
(paren
id|args
comma
id|lbp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|lbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Then add the new entry.&n;&t;&t; */
r_return
id|xfs_dir2_node_addname
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Otherwise it will fit without compaction.&n;&t; */
r_else
id|compact
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If just checking, then it will fit unless we needed to allocate&n;&t; * a new data block.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|use_block
op_eq
op_minus
l_int|1
ques
c_cond
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If no allocations are allowed, return now before we&squot;ve&n;&t; * changed anything.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;total
op_eq
l_int|0
op_logical_and
id|use_block
op_eq
op_minus
l_int|1
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Need to compact the leaf entries, removing stale ones.&n;&t; * Leave one stale entry behind - the one closest to our&n;&t; * insertion index - and we&squot;ll shift that one to our insertion&n;&t; * point later.&n;&t; */
r_if
c_cond
(paren
id|compact
)paren
(brace
id|xfs_dir2_leaf_compact_x1
c_func
(paren
id|lbp
comma
op_amp
id|index
comma
op_amp
id|lowstale
comma
op_amp
id|highstale
comma
op_amp
id|lfloglow
comma
op_amp
id|lfloghigh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There are stale entries, so we&squot;ll need log-low and log-high&n;&t; * impossibly bad values later.&n;&t; */
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|lfloglow
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|lfloghigh
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there was no data block space found, we need to allocate&n;&t; * a new one.&n;&t; */
r_if
c_cond
(paren
id|use_block
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Add the new data block.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_grow_inode
c_func
(paren
id|args
comma
id|XFS_DIR2_DATA_SPACE
comma
op_amp
id|use_block
)paren
)paren
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Initialize the block.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_data_init
c_func
(paren
id|args
comma
id|use_block
comma
op_amp
id|dbp
)paren
)paren
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we&squot;re adding a new data block on the end we need to&n;&t;&t; * extend the bests table.  Copy it up one entry.&n;&t;&t; */
r_if
c_cond
(paren
id|use_block
op_ge
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|bestsp
op_decrement
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|bestsp
(braket
l_int|0
)braket
comma
op_amp
id|bestsp
(braket
l_int|1
)braket
comma
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|bestsp
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_tail
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we&squot;re filling in a previously empty block just log it.&n;&t;&t; */
r_else
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
id|use_block
comma
id|use_block
)paren
suffix:semicolon
id|data
op_assign
id|dbp-&gt;data
suffix:semicolon
id|INT_COPY
c_func
(paren
id|bestsp
(braket
id|use_block
)braket
comma
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|grown
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Already had space in some data block.&n;&t; * Just read that one in.&n;&t; */
r_else
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|use_block
)paren
comma
op_minus
l_int|1
comma
op_amp
id|dbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|data
op_assign
id|dbp-&gt;data
suffix:semicolon
id|grown
op_assign
l_int|0
suffix:semicolon
)brace
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the biggest freespace in our data block.&n;&t; */
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|data
op_plus
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
op_ge
id|length
)paren
suffix:semicolon
id|needscan
op_assign
id|needlog
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the initial part of our freespace in use for the new entry.&n;&t; */
id|xfs_dir2_data_use_free
c_func
(paren
id|tp
comma
id|dbp
comma
id|dup
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|data
)paren
comma
id|length
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize our new entry (at last).&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|dup
suffix:semicolon
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|args-&gt;inumber
)paren
suffix:semicolon
id|dep-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|dep-&gt;name
comma
id|args-&gt;name
comma
id|dep-&gt;namelen
)paren
suffix:semicolon
id|tagp
op_assign
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|data
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to scan fix up the bestfree table.&n;&t; */
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
id|data
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to log the data block&squot;s header.&n;&t; */
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|tp
comma
id|dbp
comma
id|dep
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the bests table needs to be changed, do it.&n;&t; * Log the change unless we&squot;ve already done that.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|use_block
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|INT_COPY
c_func
(paren
id|bestsp
(braket
id|use_block
)braket
comma
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|grown
)paren
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
id|use_block
comma
id|use_block
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we need to make room to insert the leaf entry.&n;&t; * If there are no stale entries, we just insert a hole at index.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * lep is still good as the index leaf entry.&n;&t;&t; */
r_if
c_cond
(paren
id|index
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|memmove
c_func
(paren
id|lep
op_plus
l_int|1
comma
id|lep
comma
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|index
)paren
op_star
r_sizeof
(paren
op_star
id|lep
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Record low and high logging indices for the leaf.&n;&t;&t; */
id|lfloglow
op_assign
id|index
suffix:semicolon
id|lfloghigh
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There are stale entries.&n;&t; * We will use one of them for the new entry.&n;&t; * It&squot;s probably not at the right location, so we&squot;ll have to&n;&t; * shift some up or down first.&n;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t; * If we didn&squot;t compact before, we need to find the nearest&n;&t;&t; * stale entries before and after our insertion point.&n;&t;&t; */
r_if
c_cond
(paren
id|compact
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Find the first stale entry before the insertion&n;&t;&t;&t; * point, if any.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|lowstale
op_assign
id|index
op_minus
l_int|1
suffix:semicolon
id|lowstale
op_ge
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|lowstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
suffix:semicolon
id|lowstale
op_decrement
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Find the next stale entry at or after the insertion&n;&t;&t;&t; * point, if any.   Stop if we go so far that the&n;&t;&t;&t; * lowstale entry would be better.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|highstale
op_assign
id|index
suffix:semicolon
id|highstale
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|highstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
op_logical_and
(paren
id|lowstale
OL
l_int|0
op_logical_or
id|index
op_minus
id|lowstale
op_minus
l_int|1
op_ge
id|highstale
op_minus
id|index
)paren
suffix:semicolon
id|highstale
op_increment
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the low one is better, use it.&n;&t;&t; */
r_if
c_cond
(paren
id|lowstale
op_ge
l_int|0
op_logical_and
(paren
id|highstale
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|index
op_minus
id|lowstale
op_minus
l_int|1
OL
id|highstale
op_minus
id|index
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|index
op_minus
id|lowstale
op_minus
l_int|1
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|lowstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Copy entries up to cover the stale entry&n;&t;&t;&t; * and make room for the new entry.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|index
op_minus
id|lowstale
op_minus
l_int|1
OG
l_int|0
)paren
id|memmove
c_func
(paren
op_amp
id|leaf-&gt;ents
(braket
id|lowstale
)braket
comma
op_amp
id|leaf-&gt;ents
(braket
id|lowstale
op_plus
l_int|1
)braket
comma
(paren
id|index
op_minus
id|lowstale
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|lep
)paren
)paren
suffix:semicolon
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
op_minus
l_int|1
)braket
suffix:semicolon
id|lfloglow
op_assign
id|MIN
c_func
(paren
id|lowstale
comma
id|lfloglow
)paren
suffix:semicolon
id|lfloghigh
op_assign
id|MAX
c_func
(paren
id|index
op_minus
l_int|1
comma
id|lfloghigh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The high one is better, so use that one.&n;&t;&t; */
r_else
(brace
id|ASSERT
c_func
(paren
id|highstale
op_minus
id|index
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|highstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Copy entries down to copver the stale entry&n;&t;&t;&t; * and make room for the new entry.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|highstale
op_minus
id|index
OG
l_int|0
)paren
id|memmove
c_func
(paren
op_amp
id|leaf-&gt;ents
(braket
id|index
op_plus
l_int|1
)braket
comma
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
comma
(paren
id|highstale
op_minus
id|index
)paren
op_star
r_sizeof
(paren
op_star
id|lep
)paren
)paren
suffix:semicolon
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
id|lfloglow
op_assign
id|MIN
c_func
(paren
id|index
comma
id|lfloglow
)paren
suffix:semicolon
id|lfloghigh
op_assign
id|MAX
c_func
(paren
id|highstale
comma
id|lfloghigh
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the new leaf entry.&n;&t; */
id|INT_SET
c_func
(paren
id|lep-&gt;hashval
comma
id|ARCH_CONVERT
comma
id|args-&gt;hashval
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|use_block
comma
id|INT_GET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log the leaf fields and give up the buffers.&n;&t; */
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|lbp
comma
id|lfloglow
comma
id|lfloghigh
)paren
suffix:semicolon
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Check the internal consistency of a leaf1 block.&n; * Pop an assert if something is wrong.&n; */
r_void
DECL|function|xfs_dir2_leaf_check
id|xfs_dir2_leaf_check
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* leaf&squot;s buffer */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* leaf index */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail pointer */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|stale
suffix:semicolon
multiline_comment|/* count of stale leaves */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAF1_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This value is not restrictive enough.&n;&t; * Should factor in the size of the bests table as well.&n;&t; * We can deduce a value for that from di_size.&n;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_le
id|XFS_DIR2_MAX_LEAF_ENTS
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Leaves and bests don&squot;t overlap.&n;&t; */
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|leaf-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
op_le
(paren
r_char
op_star
)paren
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check hash value order, count stale entries.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|stale
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_plus
l_int|1
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|i
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|i
op_plus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|i
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
id|stale
op_increment
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
op_eq
id|stale
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/*&n; * Compact out any stale entries in the leaf.&n; * Log the header and changed leaf entries, if any.&n; */
r_void
DECL|function|xfs_dir2_leaf_compact
id|xfs_dir2_leaf_compact
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* leaf buffer */
(brace
r_int
id|from
suffix:semicolon
multiline_comment|/* source leaf index */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
r_int
id|loglow
suffix:semicolon
multiline_comment|/* first leaf entry to log */
r_int
id|to
suffix:semicolon
multiline_comment|/* target leaf index */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Compress out the stale entries in place.&n;&t; */
r_for
c_loop
(paren
id|from
op_assign
id|to
op_assign
l_int|0
comma
id|loglow
op_assign
op_minus
l_int|1
suffix:semicolon
id|from
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|from
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|from
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only actually copy the entries that are different.&n;&t;&t; */
r_if
c_cond
(paren
id|from
OG
id|to
)paren
(brace
r_if
c_cond
(paren
id|loglow
op_eq
op_minus
l_int|1
)paren
id|loglow
op_assign
id|to
suffix:semicolon
id|leaf-&gt;ents
(braket
id|to
)braket
op_assign
id|leaf-&gt;ents
(braket
id|from
)braket
suffix:semicolon
)brace
id|to
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update and log the header, log the leaf entries.&n;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
op_eq
id|from
op_minus
id|to
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_header
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loglow
op_ne
op_minus
l_int|1
)paren
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|loglow
comma
id|to
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Compact the leaf entries, removing stale ones.&n; * Leave one stale entry behind - the one closest to our&n; * insertion index - and the caller will shift that one to our insertion&n; * point later.&n; * Return new insertion index, where the remaining stale entry is,&n; * and leaf logging indices.&n; */
r_void
DECL|function|xfs_dir2_leaf_compact_x1
id|xfs_dir2_leaf_compact_x1
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* leaf buffer */
r_int
op_star
id|indexp
comma
multiline_comment|/* insertion index */
r_int
op_star
id|lowstalep
comma
multiline_comment|/* out: stale entry before us */
r_int
op_star
id|highstalep
comma
multiline_comment|/* out: stale entry after us */
r_int
op_star
id|lowlogp
comma
multiline_comment|/* out: low log index */
r_int
op_star
id|highlogp
)paren
multiline_comment|/* out: high log index */
(brace
r_int
id|from
suffix:semicolon
multiline_comment|/* source copy index */
r_int
id|highstale
suffix:semicolon
multiline_comment|/* stale entry at/after index */
r_int
id|index
suffix:semicolon
multiline_comment|/* insertion index */
r_int
id|keepstale
suffix:semicolon
multiline_comment|/* source index of kept stale */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
r_int
id|lowstale
suffix:semicolon
multiline_comment|/* stale entry before index */
r_int
id|newindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* new insertion index */
r_int
id|to
suffix:semicolon
multiline_comment|/* destination copy index */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
OG
l_int|1
)paren
suffix:semicolon
id|index
op_assign
op_star
id|indexp
suffix:semicolon
multiline_comment|/*&n;&t; * Find the first stale entry before our index, if any.&n;&t; */
r_for
c_loop
(paren
id|lowstale
op_assign
id|index
op_minus
l_int|1
suffix:semicolon
id|lowstale
op_ge
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|lowstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
suffix:semicolon
id|lowstale
op_decrement
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t; * Find the first stale entry at or after our index, if any.&n;&t; * Stop if the answer would be worse than lowstale.&n;&t; */
r_for
c_loop
(paren
id|highstale
op_assign
id|index
suffix:semicolon
id|highstale
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|highstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
op_logical_and
(paren
id|lowstale
template_param
id|highstale
op_minus
id|index
)paren
suffix:semicolon
id|highstale
op_increment
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t; * Pick the better of lowstale and highstale.&n;&t; */
r_if
c_cond
(paren
id|lowstale
op_ge
l_int|0
op_logical_and
(paren
id|highstale
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|index
op_minus
id|lowstale
op_le
id|highstale
op_minus
id|index
)paren
)paren
id|keepstale
op_assign
id|lowstale
suffix:semicolon
r_else
id|keepstale
op_assign
id|highstale
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the entries in place, removing all the stale entries&n;&t; * except keepstale.&n;&t; */
r_for
c_loop
(paren
id|from
op_assign
id|to
op_assign
l_int|0
suffix:semicolon
id|from
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|from
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Notice the new value of index.&n;&t;&t; */
r_if
c_cond
(paren
id|index
op_eq
id|from
)paren
id|newindex
op_assign
id|to
suffix:semicolon
r_if
c_cond
(paren
id|from
op_ne
id|keepstale
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|from
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
(brace
r_if
c_cond
(paren
id|from
op_eq
id|to
)paren
op_star
id|lowlogp
op_assign
id|to
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Record the new keepstale value for the insertion.&n;&t;&t; */
r_if
c_cond
(paren
id|from
op_eq
id|keepstale
)paren
id|lowstale
op_assign
id|highstale
op_assign
id|to
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Copy only the entries that have moved.&n;&t;&t; */
r_if
c_cond
(paren
id|from
OG
id|to
)paren
id|leaf-&gt;ents
(braket
id|to
)braket
op_assign
id|leaf-&gt;ents
(braket
id|from
)braket
suffix:semicolon
id|to
op_increment
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|from
OG
id|to
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the insertion point was past the last entry,&n;&t; * set the new insertion point accordingly.&n;&t; */
r_if
c_cond
(paren
id|index
op_eq
id|from
)paren
id|newindex
op_assign
id|to
suffix:semicolon
op_star
id|indexp
op_assign
id|newindex
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the leaf header values.&n;&t; */
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|from
op_minus
id|to
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remember the low/high stale value only in the &quot;right&quot;&n;&t; * direction.&n;&t; */
r_if
c_cond
(paren
id|lowstale
op_ge
id|newindex
)paren
id|lowstale
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|highstale
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
op_star
id|highlogp
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
op_star
id|lowstalep
op_assign
id|lowstale
suffix:semicolon
op_star
id|highstalep
op_assign
id|highstale
suffix:semicolon
)brace
multiline_comment|/*&n; * Getdents (readdir) for leaf and node directories.&n; * This reads the data blocks only, so is the same for both forms.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_getdents
id|xfs_dir2_leaf_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
id|uio_t
op_star
id|uio
comma
multiline_comment|/* I/O control &amp; vectors */
r_int
op_star
id|eofp
comma
multiline_comment|/* out: reached end of dir */
id|xfs_dirent_t
op_star
id|dbp
comma
multiline_comment|/* caller&squot;s buffer */
id|xfs_dir2_put_t
id|put
)paren
multiline_comment|/* ABI formatting routine */
(brace
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* data block buffer */
r_int
id|byteoff
suffix:semicolon
multiline_comment|/* offset in current block */
id|xfs_dir2_db_t
id|curdb
suffix:semicolon
multiline_comment|/* db for current block */
id|xfs_dir2_off_t
id|curoff
suffix:semicolon
multiline_comment|/* current overall offset */
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
multiline_comment|/* data block structure */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* unused entry */
r_int
id|eof
suffix:semicolon
multiline_comment|/* reached end of directory */
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* temporary loop index */
r_int
id|j
suffix:semicolon
multiline_comment|/* temporary loop index */
r_int
id|length
suffix:semicolon
multiline_comment|/* temporary length value */
id|xfs_bmbt_irec_t
op_star
id|map
suffix:semicolon
multiline_comment|/* map vector for blocks */
id|xfs_extlen_t
id|map_blocks
suffix:semicolon
multiline_comment|/* number of fsbs in map */
id|xfs_dablk_t
id|map_off
suffix:semicolon
multiline_comment|/* last mapped file offset */
r_int
id|map_size
suffix:semicolon
multiline_comment|/* total entries in *map */
r_int
id|map_valid
suffix:semicolon
multiline_comment|/* valid entries in *map */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_off_t
id|newoff
suffix:semicolon
multiline_comment|/* new curoff after new blk */
r_int
id|nmap
suffix:semicolon
multiline_comment|/* mappings to ask xfs_bmapi */
id|xfs_dir2_put_args_t
id|p
suffix:semicolon
multiline_comment|/* formatting arg bundle */
r_char
op_star
id|ptr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* pointer to current data */
r_int
id|ra_current
suffix:semicolon
multiline_comment|/* number of read-ahead blks */
r_int
id|ra_index
suffix:semicolon
multiline_comment|/* *map index for read-ahead */
r_int
id|ra_offset
suffix:semicolon
multiline_comment|/* map entry offset for ra */
r_int
id|ra_want
suffix:semicolon
multiline_comment|/* readahead count wanted */
multiline_comment|/*&n;&t; * If the offset is at or past the largest allowed value,&n;&t; * give up right away, return eof.&n;&t; */
r_if
c_cond
(paren
id|uio-&gt;uio_offset
op_ge
id|XFS_DIR2_MAX_DATAPTR
)paren
(brace
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Setup formatting arguments.&n;&t; */
id|p.dbp
op_assign
id|dbp
suffix:semicolon
id|p.put
op_assign
id|put
suffix:semicolon
id|p.uio
op_assign
id|uio
suffix:semicolon
multiline_comment|/*&n;&t; * Set up to bmap a number of blocks based on the caller&squot;s&n;&t; * buffer size, the directory block size, and the filesystem&n;&t; * block size.&n;&t; */
id|map_size
op_assign
id|howmany
c_func
(paren
id|uio-&gt;uio_resid
op_plus
id|mp-&gt;m_dirblksize
comma
id|mp-&gt;m_sb.sb_blocksize
)paren
suffix:semicolon
id|map
op_assign
id|kmem_alloc
c_func
(paren
id|map_size
op_star
r_sizeof
(paren
op_star
id|map
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|map_valid
op_assign
id|ra_index
op_assign
id|ra_offset
op_assign
id|ra_current
op_assign
id|map_blocks
op_assign
l_int|0
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|eof
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Inside the loop we keep the main offset value as a byte offset&n;&t; * in the directory file.&n;&t; */
id|curoff
op_assign
id|XFS_DIR2_DATAPTR_TO_BYTE
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Force this conversion through db so we truncate the offset&n;&t; * down to get the start of the data block.&n;&t; */
id|map_off
op_assign
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|XFS_DIR2_BYTE_TO_DB
c_func
(paren
id|mp
comma
id|curoff
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over directory entries until we reach the end offset.&n;&t; * Get more blocks and readahead as necessary.&n;&t; */
r_while
c_loop
(paren
id|curoff
OL
id|XFS_DIR2_LEAF_OFFSET
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we have no buffer, or we&squot;re off the end of the&n;&t;&t; * current buffer, need to get another one.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bp
op_logical_or
id|ptr
op_ge
(paren
r_char
op_star
)paren
id|bp-&gt;data
op_plus
id|mp-&gt;m_dirblksize
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we have a buffer, we need to release it and&n;&t;&t;&t; * take it out of the mapping.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bp
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|map_blocks
op_sub_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Loop to get rid of the extents for the&n;&t;&t;&t;&t; * directory block.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|j
op_assign
id|MIN
c_func
(paren
(paren
r_int
)paren
id|map-&gt;br_blockcount
comma
id|i
)paren
suffix:semicolon
id|map-&gt;br_blockcount
op_sub_assign
id|j
suffix:semicolon
id|map-&gt;br_startblock
op_add_assign
id|j
suffix:semicolon
id|map-&gt;br_startoff
op_add_assign
id|j
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If mapping is done, pitch it from&n;&t;&t;&t;&t;&t; * the table.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|map-&gt;br_blockcount
op_logical_and
op_decrement
id|map_valid
)paren
id|memmove
c_func
(paren
op_amp
id|map
(braket
l_int|0
)braket
comma
op_amp
id|map
(braket
l_int|1
)braket
comma
r_sizeof
(paren
id|map
(braket
l_int|0
)braket
)paren
op_star
id|map_valid
)paren
suffix:semicolon
id|i
op_sub_assign
id|j
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Recalculate the readahead blocks wanted.&n;&t;&t;&t; */
id|ra_want
op_assign
id|howmany
c_func
(paren
id|uio-&gt;uio_resid
op_plus
id|mp-&gt;m_dirblksize
comma
id|mp-&gt;m_sb.sb_blocksize
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we don&squot;t have as many as we want, and we haven&squot;t&n;&t;&t;&t; * run out of data blocks, get some more mappings.&n;&t;&t;&t; */
r_if
c_cond
(paren
l_int|1
op_plus
id|ra_want
OG
id|map_blocks
op_logical_and
id|map_off
OL
id|XFS_DIR2_BYTE_TO_DA
c_func
(paren
id|mp
comma
id|XFS_DIR2_LEAF_OFFSET
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get more bmaps, fill in after the ones&n;&t;&t;&t;&t; * we already have in the table.&n;&t;&t;&t;&t; */
id|nmap
op_assign
id|map_size
op_minus
id|map_valid
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|dp
comma
id|map_off
comma
id|XFS_DIR2_BYTE_TO_DA
c_func
(paren
id|mp
comma
id|XFS_DIR2_LEAF_OFFSET
)paren
op_minus
id|map_off
comma
id|XFS_BMAPI_METADATA
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|map
(braket
id|map_valid
)braket
comma
op_amp
id|nmap
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Don&squot;t know if we should ignore this or&n;&t;&t;&t;&t; * try to return an error.&n;&t;&t;&t;&t; * The trouble with returning errors&n;&t;&t;&t;&t; * is that readdir will just stop without&n;&t;&t;&t;&t; * actually passing the error through.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
multiline_comment|/* XXX */
multiline_comment|/*&n;&t;&t;&t;&t; * If we got all the mappings we asked for,&n;&t;&t;&t;&t; * set the final map offset based on the&n;&t;&t;&t;&t; * last bmap value received.&n;&t;&t;&t;&t; * Otherwise, we&squot;ve reached the end.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|nmap
op_eq
id|map_size
op_minus
id|map_valid
)paren
id|map_off
op_assign
id|map
(braket
id|map_valid
op_plus
id|nmap
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|map
(braket
id|map_valid
op_plus
id|nmap
op_minus
l_int|1
)braket
dot
id|br_blockcount
suffix:semicolon
r_else
id|map_off
op_assign
id|XFS_DIR2_BYTE_TO_DA
c_func
(paren
id|mp
comma
id|XFS_DIR2_LEAF_OFFSET
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Look for holes in the mapping, and&n;&t;&t;&t;&t; * eliminate them.  Count up the valid blocks.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|map_valid
suffix:semicolon
id|i
OL
id|map_valid
op_plus
id|nmap
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
(brace
id|nmap
op_decrement
suffix:semicolon
id|length
op_assign
id|map_valid
op_plus
id|nmap
op_minus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|length
)paren
id|memmove
c_func
(paren
op_amp
id|map
(braket
id|i
)braket
comma
op_amp
id|map
(braket
id|i
op_plus
l_int|1
)braket
comma
r_sizeof
(paren
id|map
(braket
id|i
)braket
)paren
op_star
id|length
)paren
suffix:semicolon
)brace
r_else
(brace
id|map_blocks
op_add_assign
id|map
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
id|map_valid
op_add_assign
id|nmap
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * No valid mappings, so no more data blocks.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|map_valid
)paren
(brace
id|curoff
op_assign
id|XFS_DIR2_DA_TO_BYTE
c_func
(paren
id|mp
comma
id|map_off
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Read the directory block starting at the first&n;&t;&t;&t; * mapping.&n;&t;&t;&t; */
id|curdb
op_assign
id|XFS_DIR2_DA_TO_DB
c_func
(paren
id|mp
comma
id|map-&gt;br_startoff
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|map-&gt;br_startoff
comma
id|map-&gt;br_blockcount
op_ge
id|mp-&gt;m_dirblkfsbs
ques
c_cond
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|map-&gt;br_startblock
)paren
suffix:colon
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Should just skip over the data block instead&n;&t;&t;&t; * of giving up.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
multiline_comment|/* XXX */
multiline_comment|/*&n;&t;&t;&t; * Adjust the current amount of read-ahead: we just&n;&t;&t;&t; * read a block that was previously ra.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ra_current
)paren
id|ra_current
op_sub_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Do we need more readahead?&n;&t;&t;&t; */
r_for
c_loop
(paren
id|ra_index
op_assign
id|ra_offset
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
id|ra_want
OG
id|ra_current
op_logical_and
id|i
OL
id|map_blocks
suffix:semicolon
id|i
op_add_assign
id|mp-&gt;m_dirblkfsbs
)paren
(brace
id|ASSERT
c_func
(paren
id|ra_index
OL
id|map_valid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Read-ahead a contiguous directory block.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|i
OG
id|ra_current
op_logical_and
id|map
(braket
id|ra_index
)braket
dot
id|br_blockcount
op_ge
id|mp-&gt;m_dirblkfsbs
)paren
(brace
id|xfs_baread
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|map
(braket
id|ra_index
)braket
dot
id|br_startblock
op_plus
id|ra_offset
)paren
comma
(paren
r_int
)paren
id|BTOBB
c_func
(paren
id|mp-&gt;m_dirblksize
)paren
)paren
suffix:semicolon
id|ra_current
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Read-ahead a non-contiguous directory block.&n;&t;&t;&t;&t; * This doesn&squot;t use our mapping, but this&n;&t;&t;&t;&t; * is a very rare case.&n;&t;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|i
OG
id|ra_current
)paren
(brace
(paren
r_void
)paren
id|xfs_da_reada_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|map
(braket
id|ra_index
)braket
dot
id|br_startoff
op_plus
id|ra_offset
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|ra_current
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Advance offset through the mapping table.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * The rest of this extent but not&n;&t;&t;&t;&t;&t; * more than a dir block.&n;&t;&t;&t;&t;&t; */
id|length
op_assign
id|MIN
c_func
(paren
id|mp-&gt;m_dirblkfsbs
comma
(paren
r_int
)paren
(paren
id|map
(braket
id|ra_index
)braket
dot
id|br_blockcount
op_minus
id|ra_offset
)paren
)paren
suffix:semicolon
id|j
op_add_assign
id|length
suffix:semicolon
id|ra_offset
op_add_assign
id|length
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Advance to the next mapping if&n;&t;&t;&t;&t;&t; * this one is used up.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ra_offset
op_eq
id|map
(braket
id|ra_index
)braket
dot
id|br_blockcount
)paren
(brace
id|ra_offset
op_assign
l_int|0
suffix:semicolon
id|ra_index
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Having done a read, we need to set a new offset.&n;&t;&t;&t; */
id|newoff
op_assign
id|XFS_DIR2_DB_OFF_TO_BYTE
c_func
(paren
id|mp
comma
id|curdb
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Start of the current block.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|curoff
OL
id|newoff
)paren
id|curoff
op_assign
id|newoff
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Make sure we&squot;re in the right block.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|curoff
OG
id|newoff
)paren
id|ASSERT
c_func
(paren
id|XFS_DIR2_BYTE_TO_DB
c_func
(paren
id|mp
comma
id|curoff
)paren
op_eq
id|curdb
)paren
suffix:semicolon
id|data
op_assign
id|bp-&gt;data
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Find our position in the block.&n;&t;&t;&t; */
id|ptr
op_assign
(paren
r_char
op_star
)paren
op_amp
id|data-&gt;u
suffix:semicolon
id|byteoff
op_assign
id|XFS_DIR2_BYTE_TO_OFF
c_func
(paren
id|mp
comma
id|curoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Skip past the header.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|byteoff
op_eq
l_int|0
)paren
id|curoff
op_add_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|data-&gt;hdr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Skip past entries until we reach our offset.&n;&t;&t;&t; */
r_else
(brace
r_while
c_loop
(paren
(paren
r_char
op_star
)paren
id|ptr
op_minus
(paren
r_char
op_star
)paren
id|data
OL
id|byteoff
)paren
(brace
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
(brace
id|length
op_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ptr
op_add_assign
id|length
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|ptr
suffix:semicolon
id|length
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
suffix:semicolon
id|ptr
op_add_assign
id|length
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Now set our real offset.&n;&t;&t;&t;&t; */
id|curoff
op_assign
id|XFS_DIR2_DB_OFF_TO_BYTE
c_func
(paren
id|mp
comma
id|XFS_DIR2_BYTE_TO_DB
c_func
(paren
id|mp
comma
id|curoff
)paren
comma
(paren
r_char
op_star
)paren
id|ptr
op_minus
(paren
r_char
op_star
)paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ge
(paren
r_char
op_star
)paren
id|data
op_plus
id|mp-&gt;m_dirblksize
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * We have a pointer to an entry.&n;&t;&t; * Is it a live one?&n;&t;&t; */
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|ptr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No, it&squot;s unused, skip over it.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
(brace
id|length
op_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ptr
op_add_assign
id|length
suffix:semicolon
id|curoff
op_add_assign
id|length
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Copy the entry into the putargs, and try formatting it.&n;&t;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|ptr
suffix:semicolon
id|p.namelen
op_assign
id|dep-&gt;namelen
suffix:semicolon
id|length
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|p.namelen
)paren
suffix:semicolon
id|p.cook
op_assign
id|XFS_DIR2_BYTE_TO_DATAPTR
c_func
(paren
id|mp
comma
id|curoff
op_plus
id|length
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
id|p.ino
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
op_plus
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#else
id|p.ino
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#endif
id|p.name
op_assign
(paren
r_char
op_star
)paren
id|dep-&gt;name
suffix:semicolon
id|error
op_assign
id|p
dot
id|put
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Won&squot;t fit.  Return to caller.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|p.done
)paren
(brace
id|eof
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Advance to next entry in the block.&n;&t;&t; */
id|ptr
op_add_assign
id|length
suffix:semicolon
id|curoff
op_add_assign
id|length
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * All done.  Set output offset value to current offset.&n;&t; */
op_star
id|eofp
op_assign
id|eof
suffix:semicolon
r_if
c_cond
(paren
id|curoff
OG
id|XFS_DIR2_DATAPTR_TO_BYTE
c_func
(paren
id|mp
comma
id|XFS_DIR2_MAX_DATAPTR
)paren
)paren
id|uio-&gt;uio_offset
op_assign
id|XFS_DIR2_MAX_DATAPTR
suffix:semicolon
r_else
id|uio-&gt;uio_offset
op_assign
id|XFS_DIR2_BYTE_TO_DATAPTR
c_func
(paren
id|mp
comma
id|curoff
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|map
comma
id|map_size
op_star
r_sizeof
(paren
op_star
id|map
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a new leaf block, leaf1 or leafn magic accepted.&n; */
r_int
DECL|function|xfs_dir2_leaf_init
id|xfs_dir2_leaf_init
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dir2_db_t
id|bno
comma
multiline_comment|/* directory block number */
id|xfs_dabuf_t
op_star
op_star
id|bpp
comma
multiline_comment|/* out: leaf buffer */
r_int
id|magic
)paren
multiline_comment|/* magic number for block */
(brace
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* leaf buffer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|bno
op_ge
id|XFS_DIR2_LEAF_FIRSTDB
c_func
(paren
id|mp
)paren
op_logical_and
id|bno
OL
id|XFS_DIR2_FREE_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the buffer for the block.&n;&t; */
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|bno
)paren
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the header.&n;&t; */
id|INT_SET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
comma
id|magic
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|leaf-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|leaf-&gt;hdr.info.back
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s a leaf-format directory initialize the tail.&n;&t; * In this case our caller has the real bests table to copy into&n;&t; * the block.&n;&t; */
r_if
c_cond
(paren
id|magic
op_eq
id|XFS_DIR2_LEAF1_MAGIC
)paren
(brace
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_tail
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
)brace
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Log the bests entries indicated from a leaf1 block.&n; */
r_void
DECL|function|xfs_dir2_leaf_log_bests
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* leaf buffer */
r_int
id|first
comma
multiline_comment|/* first entry to log */
r_int
id|last
)paren
multiline_comment|/* last entry to log */
(brace
id|xfs_dir2_data_off_t
op_star
id|firstb
suffix:semicolon
multiline_comment|/* pointer to first entry */
id|xfs_dir2_data_off_t
op_star
id|lastb
suffix:semicolon
multiline_comment|/* pointer to last entry */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail structure */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAF1_MAGIC
)paren
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|tp-&gt;t_mountp
comma
id|leaf
)paren
suffix:semicolon
id|firstb
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
op_plus
id|first
suffix:semicolon
id|lastb
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
op_plus
id|last
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|firstb
op_minus
(paren
r_char
op_star
)paren
id|leaf
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|lastb
op_minus
(paren
r_char
op_star
)paren
id|leaf
op_plus
r_sizeof
(paren
op_star
id|lastb
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log the leaf entries indicated from a leaf1 or leafn block.&n; */
r_void
DECL|function|xfs_dir2_leaf_log_ents
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* leaf buffer */
r_int
id|first
comma
multiline_comment|/* first entry to log */
r_int
id|last
)paren
multiline_comment|/* last entry to log */
(brace
id|xfs_dir2_leaf_entry_t
op_star
id|firstlep
suffix:semicolon
multiline_comment|/* pointer to first entry */
id|xfs_dir2_leaf_entry_t
op_star
id|lastlep
suffix:semicolon
multiline_comment|/* pointer to last entry */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAF1_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|firstlep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|first
)braket
suffix:semicolon
id|lastlep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|last
)braket
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|firstlep
op_minus
(paren
r_char
op_star
)paren
id|leaf
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|lastlep
op_minus
(paren
r_char
op_star
)paren
id|leaf
op_plus
r_sizeof
(paren
op_star
id|lastlep
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log the header of the leaf1 or leafn block.&n; */
r_void
DECL|function|xfs_dir2_leaf_log_header
id|xfs_dir2_leaf_log_header
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* leaf buffer */
(brace
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAF1_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|leaf-&gt;hdr
op_minus
(paren
r_char
op_star
)paren
id|leaf
)paren
comma
(paren
id|uint
)paren
(paren
r_sizeof
(paren
id|leaf-&gt;hdr
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log the tail of the leaf1 block.&n; */
r_void
DECL|function|xfs_dir2_leaf_log_tail
id|xfs_dir2_leaf_log_tail
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* leaf buffer */
(brace
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAF1_MAGIC
)paren
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|ltp
op_minus
(paren
r_char
op_star
)paren
id|leaf
)paren
comma
(paren
id|uint
)paren
(paren
id|mp-&gt;m_dirblksize
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the entry referred to by args in the leaf format directory.&n; * Most of the work is done by the xfs_dir2_leaf_lookup_int routine which&n; * is also used by the node-format code.&n; */
r_int
DECL|function|xfs_dir2_leaf_lookup
id|xfs_dir2_leaf_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data block buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data block entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
r_int
id|index
suffix:semicolon
multiline_comment|/* found entry index */
id|xfs_dabuf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* leaf buffer */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;leaf_lookup&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up name in the leaf block, returning both buffers and index.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_leaf_lookup_int
c_func
(paren
id|args
comma
op_amp
id|lbp
comma
op_amp
id|index
comma
op_amp
id|dbp
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Get to the leaf entry and contained data entry address.&n;&t; */
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the data entry.&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|dbp-&gt;data
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|dp-&gt;i_mount
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return the found inode number.&n;&t; */
id|args-&gt;inumber
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up name/hash in the leaf block.&n; * Fill in indexp with the found index, and dbpp with the data buffer.&n; * If not found dbpp will be NULL, and ENOENT comes back.&n; * lbpp will always be filled in with the leaf buffer unless there&squot;s an error.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_lookup_int
id|xfs_dir2_leaf_lookup_int
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
op_star
id|lbpp
comma
multiline_comment|/* out: leaf buffer */
r_int
op_star
id|indexp
comma
multiline_comment|/* out: index in leaf block */
id|xfs_dabuf_t
op_star
op_star
id|dbpp
)paren
multiline_comment|/* out: data buffer */
(brace
id|xfs_dir2_db_t
id|curdb
suffix:semicolon
multiline_comment|/* current data block number */
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
r_int
id|index
suffix:semicolon
multiline_comment|/* index in leaf block */
id|xfs_dabuf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* leaf buffer */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_db_t
id|newdb
suffix:semicolon
multiline_comment|/* new data block number */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Read the leaf block into the buffer.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|mp-&gt;m_dirleafblk
comma
op_minus
l_int|1
comma
op_amp
id|lbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_star
id|lbpp
op_assign
id|lbp
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look for the first leaf entry with our hash value.&n;&t; */
id|index
op_assign
id|xfs_dir2_leaf_search_hash
c_func
(paren
id|args
comma
id|lbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over all the entries with the right hash value&n;&t; * looking to match the name.&n;&t; */
r_for
c_loop
(paren
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
comma
id|dbp
op_assign
l_int|NULL
comma
id|curdb
op_assign
op_minus
l_int|1
suffix:semicolon
id|index
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|lep-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|args-&gt;hashval
suffix:semicolon
id|lep
op_increment
comma
id|index
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip over stale leaf entries.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the new data block number.&n;&t;&t; */
id|newdb
op_assign
id|XFS_DIR2_DATAPTR_TO_DB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s not the same as the old data block number,&n;&t;&t; * need to pitch the old one and read the new one.&n;&t;&t; */
r_if
c_cond
(paren
id|newdb
op_ne
id|curdb
)paren
(brace
r_if
c_cond
(paren
id|dbp
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|newdb
)paren
comma
op_minus
l_int|1
comma
op_amp
id|dbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
id|curdb
op_assign
id|newdb
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Point to the data entry.&n;&t;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|dbp-&gt;data
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it matches then return it.&n;&t;&t; */
r_if
c_cond
(paren
id|dep-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|dep-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|dep-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|dbpp
op_assign
id|dbp
suffix:semicolon
op_star
id|indexp
op_assign
id|index
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * No match found, return ENOENT.&n;&t; */
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dbp
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from a leaf format directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_removename
id|xfs_dir2_leaf_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_dir2_data_off_t
op_star
id|bestsp
suffix:semicolon
multiline_comment|/* leaf block best freespace */
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
multiline_comment|/* data block structure */
id|xfs_dir2_db_t
id|db
suffix:semicolon
multiline_comment|/* data block number */
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data block buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry structure */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
id|xfs_dir2_db_t
id|i
suffix:semicolon
multiline_comment|/* temporary data block # */
r_int
id|index
suffix:semicolon
multiline_comment|/* index into leaf entries */
id|xfs_dabuf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* leaf buffer */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log data header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to rescan data frees */
id|xfs_dir2_data_off_t
id|oldbest
suffix:semicolon
multiline_comment|/* old value of best free */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;leaf_removename&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lookup the leaf entry, get the leaf and data blocks read in.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_leaf_lookup_int
c_func
(paren
id|args
comma
op_amp
id|lbp
comma
op_amp
id|index
comma
op_amp
id|dbp
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|data
op_assign
id|dbp-&gt;data
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the leaf entry, use that to point to the data entry.&n;&t; */
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
id|db
op_assign
id|XFS_DIR2_DATAPTR_TO_DB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|data
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|needscan
op_assign
id|needlog
op_assign
l_int|0
suffix:semicolon
id|oldbest
op_assign
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|bestsp
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|db
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|oldbest
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the former data entry unused.&n;&t; */
id|xfs_dir2_data_make_free
c_func
(paren
id|tp
comma
id|dbp
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|data
)paren
comma
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We just mark the leaf entry stale by putting a null in it.&n;&t; */
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_NULL_DATAPTR
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|lbp
comma
id|index
comma
id|index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the freespace in the data block again if necessary,&n;&t; * log the data block header if necessary.&n;&t; */
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
id|data
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the longest freespace in the data block has changed,&n;&t; * put the new value in the bests table and log that.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_ne
id|oldbest
)paren
(brace
id|INT_COPY
c_func
(paren
id|bestsp
(braket
id|db
)braket
comma
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
id|db
comma
id|db
)paren
suffix:semicolon
)brace
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the data block is now empty then get rid of the data block.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_eq
id|mp-&gt;m_dirblksize
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|data-&gt;hdr
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|db
op_ne
id|mp-&gt;m_dirdatablk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_shrink_inode
c_func
(paren
id|args
comma
id|db
comma
id|dbp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Nope, can&squot;t get rid of it because it caused&n;&t;&t;&t; * allocation of a bmap btree block to do so.&n;&t;&t;&t; * Just go on, returning success, leaving the&n;&t;&t;&t; * empty block in place.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
op_logical_and
id|args-&gt;total
op_eq
l_int|0
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|lbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this is the last data block then compact the&n;&t;&t; * bests table by getting rid of entries.&n;&t;&t; */
r_if
c_cond
(paren
id|db
op_eq
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Look for the last active entry (i).&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|db
op_minus
l_int|1
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDATAOFF
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Copy the table down so inactive entries at the&n;&t;&t;&t; * end are removed.&n;&t;&t;&t; */
id|memmove
c_func
(paren
op_amp
id|bestsp
(braket
id|db
op_minus
id|i
)braket
comma
id|bestsp
comma
(paren
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
(paren
id|db
op_minus
id|i
)paren
)paren
op_star
r_sizeof
(paren
op_star
id|bestsp
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|db
op_minus
id|i
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_tail
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|INT_SET
c_func
(paren
id|bestsp
(braket
id|db
)braket
comma
id|ARCH_CONVERT
comma
id|NULLDATAOFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the data block was not the first one, drop it.&n;&t; */
r_else
r_if
c_cond
(paren
id|db
op_ne
id|mp-&gt;m_dirdatablk
op_logical_and
id|dbp
op_ne
l_int|NULL
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
id|dbp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if we can convert to block form.&n;&t; */
r_return
id|xfs_dir2_leaf_to_block
c_func
(paren
id|args
comma
id|lbp
comma
id|dbp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace the inode number in a leaf format directory entry.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_replace
id|xfs_dir2_leaf_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data block buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data block entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
r_int
id|index
suffix:semicolon
multiline_comment|/* index of leaf entry */
id|xfs_dabuf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* leaf buffer */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;leaf_replace&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the entry.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_leaf_lookup_int
c_func
(paren
id|args
comma
op_amp
id|lbp
comma
op_amp
id|index
comma
op_amp
id|dbp
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the leaf entry, get data address from it.&n;&t; */
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the data entry.&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|dbp-&gt;data
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|dp-&gt;i_mount
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;inumber
op_ne
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put the new inode number in, log it.&n;&t; */
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|args-&gt;inumber
)paren
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|tp
comma
id|dbp
comma
id|dep
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return index in the leaf block (lbp) which is either the first&n; * one with this hash value, or if there are none, the insert point&n; * for that hash value.&n; */
r_int
multiline_comment|/* index value */
DECL|function|xfs_dir2_leaf_search_hash
id|xfs_dir2_leaf_search_hash
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|lbp
)paren
multiline_comment|/* leaf buffer */
(brace
id|xfs_dahash_t
id|hash
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hash from this entry */
id|xfs_dahash_t
id|hashwant
suffix:semicolon
multiline_comment|/* hash value looking for */
r_int
id|high
suffix:semicolon
multiline_comment|/* high leaf index */
r_int
id|low
suffix:semicolon
multiline_comment|/* low leaf index */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
r_int
id|mid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* current leaf index */
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
macro_line|#ifndef __KERNEL__
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Note, the table cannot be empty, so we have to go through the loop.&n;&t; * Binary search the leaf entries looking for our hash value.&n;&t; */
r_for
c_loop
(paren
id|lep
op_assign
id|leaf-&gt;ents
comma
id|low
op_assign
l_int|0
comma
id|high
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
comma
id|hashwant
op_assign
id|args-&gt;hashval
suffix:semicolon
id|low
op_le
id|high
suffix:semicolon
)paren
(brace
id|mid
op_assign
(paren
id|low
op_plus
id|high
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hash
op_assign
id|INT_GET
c_func
(paren
id|lep
(braket
id|mid
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
id|hashwant
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|hash
OL
id|hashwant
)paren
id|low
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
id|high
op_assign
id|mid
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Found one, back up through all the equal hash values.&n;&t; */
r_if
c_cond
(paren
id|hash
op_eq
id|hashwant
)paren
(brace
r_while
c_loop
(paren
id|mid
OG
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|lep
(braket
id|mid
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hashwant
)paren
(brace
id|mid
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Need to point to an entry higher than ours.&n;&t; */
r_else
r_if
c_cond
(paren
id|hash
OL
id|hashwant
)paren
id|mid
op_increment
suffix:semicolon
r_return
id|mid
suffix:semicolon
)brace
multiline_comment|/*&n; * Trim off a trailing data block.  We know it&squot;s empty since the leaf&n; * freespace table says so.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_trim_data
id|xfs_dir2_leaf_trim_data
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|lbp
comma
multiline_comment|/* leaf buffer */
id|xfs_dir2_db_t
id|db
)paren
multiline_comment|/* data block number */
(brace
id|xfs_dir2_data_off_t
op_star
id|bestsp
suffix:semicolon
multiline_comment|/* leaf bests table */
macro_line|#ifdef DEBUG
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
multiline_comment|/* data block structure */
macro_line|#endif
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data block buffer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * Read the offending data block.  We need its buffer.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|db
)paren
comma
op_minus
l_int|1
comma
op_amp
id|dbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|data
op_assign
id|dbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|data-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* this seems to be an error&n;&t; * data is only valid if DEBUG is defined?&n;&t; * RMC 09/08/1999&n;&t; */
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_eq
id|mp-&gt;m_dirblksize
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|data-&gt;hdr
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|db
op_eq
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get rid of the data block.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_shrink_inode
c_func
(paren
id|args
comma
id|db
comma
id|dbp
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Eliminate the last bests entry from the table.&n;&t; */
id|bestsp
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|bestsp
(braket
l_int|1
)braket
comma
op_amp
id|bestsp
(braket
l_int|0
)braket
comma
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|bestsp
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_tail
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert node form directory to leaf form directory.&n; * The root of the node form dir needs to already be a LEAFN block.&n; * Just return if we can&squot;t do anything.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_node_to_leaf
id|xfs_dir2_node_to_leaf
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
multiline_comment|/* directory operation state */
(brace
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
id|xfs_dabuf_t
op_star
id|fbp
suffix:semicolon
multiline_comment|/* buffer for freespace block */
id|xfs_fileoff_t
id|fo
suffix:semicolon
multiline_comment|/* freespace file offset */
id|xfs_dir2_free_t
op_star
id|free
suffix:semicolon
multiline_comment|/* freespace structure */
id|xfs_dabuf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* buffer for leaf block */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* tail of leaf structure */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|rval
suffix:semicolon
multiline_comment|/* successful free trim? */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
multiline_comment|/*&n;&t; * There&squot;s more than a leaf level in the btree, so there must&n;&t; * be multiple leafn blocks.  Give up.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;path.active
OG
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;node_to_leaf&quot;
comma
id|args
)paren
suffix:semicolon
id|mp
op_assign
id|state-&gt;mp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * Get the last offset in the file.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_last_offset
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|fo
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|fo
op_sub_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
multiline_comment|/*&n;&t; * If there are freespace blocks other than the first one,&n;&t; * take this opportunity to remove trailing empty freespace blocks&n;&t; * that may have been left behind during no-space-reservation&n;&t; * operations.&n;&t; */
r_while
c_loop
(paren
id|fo
OG
id|mp-&gt;m_dirfreeblk
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_node_trim_free
c_func
(paren
id|args
comma
id|fo
comma
op_amp
id|rval
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rval
)paren
id|fo
op_sub_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now find the block just before the freespace block.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_last_before
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|fo
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If it&squot;s not the single leaf block, give up.&n;&t; */
r_if
c_cond
(paren
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|fo
)paren
OG
id|XFS_DIR2_LEAF_OFFSET
op_plus
id|mp-&gt;m_dirblksize
)paren
r_return
l_int|0
suffix:semicolon
id|lbp
op_assign
id|state-&gt;path.blk
(braket
l_int|0
)braket
dot
id|bp
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the freespace block.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|mp-&gt;m_dirfreeblk
comma
op_minus
l_int|1
comma
op_amp
id|fbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now see if the leafn and free data will fit in a leaf1.&n;&t; * If not, release the buffer and give up.&n;&t; */
r_if
c_cond
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;hdr
)paren
op_plus
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;ents
(braket
l_int|0
)braket
)paren
op_plus
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;bests
(braket
l_int|0
)braket
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;tail
)paren
OG
id|mp-&gt;m_dirblksize
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|fbp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the leaf has any stale entries in it, compress them out.&n;&t; * The compact routine will log the header.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
id|xfs_dir2_leaf_compact
c_func
(paren
id|args
comma
id|lbp
)paren
suffix:semicolon
r_else
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_LEAF1_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the leaf tail from the freespace block.&n;&t; */
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|INT_COPY
c_func
(paren
id|ltp-&gt;bestcount
comma
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the leaf bests table.&n;&t; */
id|memcpy
c_func
(paren
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
comma
id|free-&gt;bests
comma
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|leaf-&gt;bests
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_bests
c_func
(paren
id|tp
comma
id|lbp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_tail
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_leaf_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get rid of the freespace block.&n;&t; */
id|error
op_assign
id|xfs_dir2_shrink_inode
c_func
(paren
id|args
comma
id|XFS_DIR2_FREE_FIRSTDB
c_func
(paren
id|mp
)paren
comma
id|fbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * This can&squot;t fail here because it can only happen when&n;&t;&t; * punching out the middle of an extent, and this is an&n;&t;&t; * isolated block.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|fbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Now see if we can convert the single-leaf directory&n;&t; * down to a block form directory.&n;&t; * This routine always kills the dabuf for the leaf, so&n;&t; * eliminate it from the path.&n;&t; */
id|error
op_assign
id|xfs_dir2_leaf_to_block
c_func
(paren
id|args
comma
id|lbp
comma
l_int|NULL
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
l_int|0
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
