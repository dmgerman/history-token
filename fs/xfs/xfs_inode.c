multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_imap.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_utils.h&quot;
macro_line|#include &quot;xfs_dir2_trace.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_mac.h&quot;
macro_line|#include &quot;xfs_acl.h&quot;
DECL|variable|xfs_ifork_zone
id|kmem_zone_t
op_star
id|xfs_ifork_zone
suffix:semicolon
DECL|variable|xfs_inode_zone
id|kmem_zone_t
op_star
id|xfs_inode_zone
suffix:semicolon
DECL|variable|xfs_chashlist_zone
id|kmem_zone_t
op_star
id|xfs_chashlist_zone
suffix:semicolon
multiline_comment|/*&n; * Used in xfs_itruncate().  This is the maximum number of extents&n; * freed from a file in a single transaction.&n; */
DECL|macro|XFS_ITRUNC_MAX_EXTENTS
mdefine_line|#define&t;XFS_ITRUNC_MAX_EXTENTS&t;2
id|STATIC
r_int
id|xfs_iflush_int
c_func
(paren
id|xfs_inode_t
op_star
comma
id|xfs_buf_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iformat_local
c_func
(paren
id|xfs_inode_t
op_star
comma
id|xfs_dinode_t
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iformat_extents
c_func
(paren
id|xfs_inode_t
op_star
comma
id|xfs_dinode_t
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iformat_btree
c_func
(paren
id|xfs_inode_t
op_star
comma
id|xfs_dinode_t
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Make sure that the extents in the given memory buffer&n; * are valid.&n; */
id|STATIC
r_void
DECL|function|xfs_validate_extents
id|xfs_validate_extents
c_func
(paren
id|xfs_bmbt_rec_t
op_star
id|ep
comma
r_int
id|nrecs
comma
r_int
id|disk
comma
id|xfs_exntfmt_t
id|fmt
)paren
(brace
id|xfs_bmbt_irec_t
id|irec
suffix:semicolon
id|xfs_bmbt_rec_t
id|rec
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nrecs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rec.l0
op_assign
id|get_unaligned
c_func
(paren
(paren
id|__uint64_t
op_star
)paren
op_amp
id|ep-&gt;l0
)paren
suffix:semicolon
id|rec.l1
op_assign
id|get_unaligned
c_func
(paren
(paren
id|__uint64_t
op_star
)paren
op_amp
id|ep-&gt;l1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disk
)paren
id|xfs_bmbt_disk_get_all
c_func
(paren
op_amp
id|rec
comma
op_amp
id|irec
)paren
suffix:semicolon
r_else
id|xfs_bmbt_get_all
c_func
(paren
op_amp
id|rec
comma
op_amp
id|irec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
op_eq
id|XFS_EXTFMT_NOSTATE
)paren
id|ASSERT
c_func
(paren
id|irec.br_state
op_eq
id|XFS_EXT_NORM
)paren
suffix:semicolon
id|ep
op_increment
suffix:semicolon
)brace
)brace
macro_line|#else /* DEBUG */
DECL|macro|xfs_validate_extents
mdefine_line|#define xfs_validate_extents(ep, nrecs, disk, fmt)
macro_line|#endif /* DEBUG */
multiline_comment|/*&n; * Check that none of the inode&squot;s in the buffer have a next&n; * unlinked field of 0.&n; */
macro_line|#if defined(DEBUG)
r_void
DECL|function|xfs_inobp_check
id|xfs_inobp_check
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|j
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|j
op_assign
id|mp-&gt;m_inode_cluster_size
op_rshift
id|mp-&gt;m_sb.sb_inodelog
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|i
op_star
id|mp-&gt;m_sb.sb_inodesize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;Detected a bogus zero next_unlinked field in incore inode buffer 0x%p.  About to pop an ASSERT.&quot;
comma
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * called from bwrite on xfs inode buffers&n; */
r_void
DECL|function|xfs_inobp_bwcheck
id|xfs_inobp_bwcheck
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|j
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE3
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|mp
op_assign
id|XFS_BUF_FSPRIVATE3
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
suffix:semicolon
id|j
op_assign
id|mp-&gt;m_inode_cluster_size
op_rshift
id|mp-&gt;m_sb.sb_inodelog
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|i
op_star
id|mp-&gt;m_sb.sb_inodesize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DINODE_MAGIC
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;Bad magic # 0x%x in XFS inode buffer 0x%Lx, starting blockno %Ld, offset 0x%x&quot;
comma
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__uint64_t
)paren
(paren
id|__psunsigned_t
)paren
id|bp
comma
(paren
id|__int64_t
)paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
comma
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|i
op_star
id|mp-&gt;m_sb.sb_inodesize
)paren
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;corrupt, unmount and run xfs_repair&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;Bad next_unlinked field (0) in XFS inode buffer 0x%p, starting blockno %Ld, offset 0x%x&quot;
comma
(paren
id|__uint64_t
)paren
(paren
id|__psunsigned_t
)paren
id|bp
comma
(paren
id|__int64_t
)paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
comma
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|i
op_star
id|mp-&gt;m_sb.sb_inodesize
)paren
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;corrupt, unmount and run xfs_repair&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to map an inode number within a file&n; * system to the buffer containing the on-disk version of the&n; * inode.  It returns a pointer to the buffer containing the&n; * on-disk inode in the bpp parameter, and in the dip parameter&n; * it returns a pointer to the on-disk inode within that buffer.&n; *&n; * If a non-zero error is returned, then the contents of bpp and&n; * dipp are undefined.&n; *&n; * Use xfs_imap() to determine the size and location of the&n; * buffer to read from disk.&n; */
r_int
DECL|function|xfs_inotobp
id|xfs_inotobp
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_ino_t
id|ino
comma
id|xfs_dinode_t
op_star
op_star
id|dipp
comma
id|xfs_buf_t
op_star
op_star
id|bpp
comma
r_int
op_star
id|offset
)paren
(brace
r_int
id|di_ok
suffix:semicolon
id|xfs_imap_t
id|imap
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
multiline_comment|/*&n;&t; * Call the space managment code to find the location of the&n;&t; * inode on disk.&n;&t; */
id|imap.im_blkno
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_imap
c_func
(paren
id|mp
comma
id|tp
comma
id|ino
comma
op_amp
id|imap
comma
id|XFS_IMAP_LOOKUP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_inotobp: xfs_imap()  returned an &quot;
l_string|&quot;error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the inode number maps to a block outside the bounds of the&n;&t; * file system then return NULL rather than calling read_buf&n;&t; * and panicing when we get an error from the driver.&n;&t; */
r_if
c_cond
(paren
(paren
id|imap.im_blkno
op_plus
id|imap.im_len
)paren
OG
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_sb.sb_dblocks
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_inotobp: inode number (%d + %d) maps to a block outside the bounds &quot;
l_string|&quot;of the file system %s.  Returning EINVAL.&quot;
comma
id|imap.im_blkno
comma
id|imap.im_len
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read in the buffer.  If tp is NULL, xfs_trans_read_buf() will&n;&t; * default to just a read_buf() call.&n;&t; */
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|imap.im_blkno
comma
(paren
r_int
)paren
id|imap.im_len
comma
id|XFS_BUF_LOCK
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_inotobp: xfs_trans_read_buf()  returned an &quot;
l_string|&quot;error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
l_int|0
)paren
suffix:semicolon
id|di_ok
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DINODE_MAGIC
op_logical_and
id|XFS_DINODE_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_version
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|di_ok
comma
id|mp
comma
id|XFS_ERRTAG_ITOBP_INOTOBP
comma
id|XFS_RANDOM_ITOBP_INOTOBP
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_inotobp&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|dip
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_inotobp: XFS_TEST_ERROR()  returned an &quot;
l_string|&quot;error on %s.  Returning EFSCORRUPTED.&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|xfs_inobp_check
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set *dipp to point to the on-disk inode in the buffer.&n;&t; */
op_star
id|dipp
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|imap.im_boffset
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
op_star
id|offset
op_assign
id|imap.im_boffset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to map an inode to the buffer containing&n; * the on-disk version of the inode.  It returns a pointer to the&n; * buffer containing the on-disk inode in the bpp parameter, and in&n; * the dip parameter it returns a pointer to the on-disk inode within&n; * that buffer.&n; *&n; * If a non-zero error is returned, then the contents of bpp and&n; * dipp are undefined.&n; *&n; * If the inode is new and has not yet been initialized, use xfs_imap()&n; * to determine the size and location of the buffer to read from disk.&n; * If the inode has already been mapped to its buffer and read in once,&n; * then use the mapping information stored in the inode rather than&n; * calling xfs_imap().  This allows us to avoid the overhead of looking&n; * at the inode btree for small block file systems (see xfs_dilocate()).&n; * We can tell whether the inode has been mapped in before by comparing&n; * its disk block address to 0.  Only uninitialized inodes will have&n; * 0 for the disk block address.&n; */
r_int
DECL|function|xfs_itobp
id|xfs_itobp
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dinode_t
op_star
op_star
id|dipp
comma
id|xfs_buf_t
op_star
op_star
id|bpp
comma
id|xfs_daddr_t
id|bno
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_imap_t
id|imap
suffix:semicolon
macro_line|#ifdef __KERNEL__
r_int
id|i
suffix:semicolon
r_int
id|ni
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ip-&gt;i_blkno
op_eq
(paren
id|xfs_daddr_t
)paren
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Call the space management code to find the location of the&n;&t;&t; * inode on disk.&n;&t;&t; */
id|imap.im_blkno
op_assign
id|bno
suffix:semicolon
id|error
op_assign
id|xfs_imap
c_func
(paren
id|mp
comma
id|tp
comma
id|ip-&gt;i_ino
comma
op_amp
id|imap
comma
id|XFS_IMAP_LOOKUP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the inode number maps to a block outside the bounds&n;&t;&t; * of the file system then return NULL rather than calling&n;&t;&t; * read_buf and panicing when we get an error from the&n;&t;&t; * driver.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|imap.im_blkno
op_plus
id|imap.im_len
)paren
OG
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_sb.sb_dblocks
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_itobp: &quot;
l_string|&quot;(imap.im_blkno (0x%llx) &quot;
l_string|&quot;+ imap.im_len (0x%llx)) &gt; &quot;
l_string|&quot; XFS_FSB_TO_BB(mp, &quot;
l_string|&quot;mp-&gt;m_sb.sb_dblocks) (0x%llx)&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|imap.im_blkno
comma
(paren
r_int
r_int
r_int
)paren
id|imap.im_len
comma
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_sb.sb_dblocks
)paren
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Fill in the fields in the inode that will be used to&n;&t;&t; * map the inode to its buffer from now on.&n;&t;&t; */
id|ip-&gt;i_blkno
op_assign
id|imap.im_blkno
suffix:semicolon
id|ip-&gt;i_len
op_assign
id|imap.im_len
suffix:semicolon
id|ip-&gt;i_boffset
op_assign
id|imap.im_boffset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We&squot;ve already mapped the inode once, so just use the&n;&t;&t; * mapping that we saved the first time.&n;&t;&t; */
id|imap.im_blkno
op_assign
id|ip-&gt;i_blkno
suffix:semicolon
id|imap.im_len
op_assign
id|ip-&gt;i_len
suffix:semicolon
id|imap.im_boffset
op_assign
id|ip-&gt;i_boffset
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bno
op_eq
l_int|0
op_logical_or
id|bno
op_eq
id|imap.im_blkno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read in the buffer.  If tp is NULL, xfs_trans_read_buf() will&n;&t; * default to just a read_buf() call.&n;&t; */
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|imap.im_blkno
comma
(paren
r_int
)paren
id|imap.im_len
comma
id|XFS_BUF_LOCK
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_itobp: &quot;
l_string|&quot;xfs_trans_read_buf() returned error %d, &quot;
l_string|&quot;imap.im_blkno 0x%llx, imap.im_len 0x%llx&quot;
comma
id|error
comma
(paren
r_int
r_int
r_int
)paren
id|imap.im_blkno
comma
(paren
r_int
r_int
r_int
)paren
id|imap.im_len
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef __KERNEL__
multiline_comment|/*&n;&t; * Validate the magic number and version of every inode in the buffer&n;&t; * (if DEBUG kernel) or the first inode in the buffer, otherwise.&n;&t; */
macro_line|#ifdef DEBUG
id|ni
op_assign
id|BBTOB
c_func
(paren
id|imap.im_len
)paren
op_rshift
id|mp-&gt;m_sb.sb_inodelog
suffix:semicolon
macro_line|#else
id|ni
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ni
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|di_ok
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
(paren
id|i
op_lshift
id|mp-&gt;m_sb.sb_inodelog
)paren
)paren
suffix:semicolon
id|di_ok
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DINODE_MAGIC
op_logical_and
id|XFS_DINODE_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_version
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|di_ok
comma
id|mp
comma
id|XFS_ERRTAG_ITOBP_INOTOBP
comma
id|XFS_RANDOM_ITOBP_INOTOBP
)paren
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|prdev
c_func
(paren
l_string|&quot;bad inode magic/vsn daddr 0x%llx #%d (magic=%x)&quot;
comma
id|mp-&gt;m_dev
comma
(paren
r_int
r_int
r_int
)paren
id|imap.im_blkno
comma
id|i
comma
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
macro_line|#endif
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_itobp&quot;
comma
id|XFS_ERRLEVEL_HIGH
comma
id|mp
comma
id|dip
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* __KERNEL__ */
id|xfs_inobp_check
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the buffer as an inode buffer now that it looks good&n;&t; */
id|XFS_BUF_SET_VTYPE
c_func
(paren
id|bp
comma
id|B_FS_INO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set *dipp to point to the on-disk inode in the buffer.&n;&t; */
op_star
id|dipp
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|imap.im_boffset
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move inode type and inode format specific information from the&n; * on-disk inode to the in-core inode.  For fifos, devs, and sockets&n; * this means set if_rdev to the proper value.  For files, directories,&n; * and symlinks this means to bring in the in-line data or extent&n; * pointers.  For a file in B-tree format, only the root is immediately&n; * brought in-core.  The rest will be in-lined in if_extents when it&n; * is first referenced (see xfs_iread_extents()).&n; */
id|STATIC
r_int
DECL|function|xfs_iformat
id|xfs_iformat
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dinode_t
op_star
id|dip
)paren
(brace
id|xfs_attr_shortform_t
op_star
id|atp
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fsize_t
id|di_size
suffix:semicolon
id|ip-&gt;i_df.if_ext_max
op_assign
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_nextents
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_anextents
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_nblocks
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt dinode %Lu, extent total = %d, nblocks = %Lu.&quot;
l_string|&quot;  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
comma
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_nextents
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_anextents
comma
id|ARCH_CONVERT
)paren
)paren
comma
(paren
r_int
r_int
r_int
)paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_nblocks
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iformat(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
comma
id|dip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_forkoff
comma
id|ARCH_CONVERT
)paren
OG
id|ip-&gt;i_mount-&gt;m_sb.sb_inodesize
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt dinode %Lu, forkoff = 0x%x.&quot;
l_string|&quot;  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
comma
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_forkoff
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iformat(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
comma
id|dip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
(brace
r_case
id|IFIFO
suffix:colon
r_case
id|IFCHR
suffix:colon
r_case
id|IFBLK
suffix:colon
r_case
id|IFSOCK
suffix:colon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_format
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DINODE_FMT_DEV
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iformat(3)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
comma
id|dip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|ip-&gt;i_d.di_size
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_df.if_u2.if_rdev
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_u.di_dev
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IFREG
suffix:colon
r_case
id|IFLNK
suffix:colon
r_case
id|IFDIR
suffix:colon
r_switch
c_cond
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_format
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * no local regular files yet&n;&t;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_mode
comma
id|ARCH_CONVERT
)paren
op_amp
id|IFMT
)paren
op_eq
id|IFREG
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt inode (local format for regular file) %Lu.  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iformat(4)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
comma
id|dip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|di_size
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|di_size
OG
id|XFS_DFORK_DSIZE_ARCH
c_func
(paren
id|dip
comma
id|ip-&gt;i_mount
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt inode %Lu (bad size %Ld for local inode).  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
comma
(paren
r_int
r_int
)paren
id|di_size
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iformat(5)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
comma
id|dip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|size
op_assign
(paren
r_int
)paren
id|di_size
suffix:semicolon
id|error
op_assign
id|xfs_iformat_local
c_func
(paren
id|ip
comma
id|dip
comma
id|XFS_DATA_FORK
comma
id|size
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|error
op_assign
id|xfs_iformat_extents
c_func
(paren
id|ip
comma
id|dip
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|error
op_assign
id|xfs_iformat_btree
c_func
(paren
id|ip
comma
id|dip
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_iformat(6)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_iformat(7)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_DFORK_Q_ARCH
c_func
(paren
id|dip
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip-&gt;i_afp
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_ifork_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ip-&gt;i_afp-&gt;if_ext_max
op_assign
id|XFS_IFORK_ASIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_aformat
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
id|atp
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|XFS_DFORK_APTR_ARCH
c_func
(paren
id|dip
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|size
op_assign
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|atp-&gt;hdr.totsize
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iformat_local
c_func
(paren
id|ip
comma
id|dip
comma
id|XFS_ATTR_FORK
comma
id|size
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|error
op_assign
id|xfs_iformat_extents
c_func
(paren
id|ip
comma
id|dip
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|error
op_assign
id|xfs_iformat_btree
c_func
(paren
id|ip
comma
id|dip
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|kmem_zone_free
c_func
(paren
id|xfs_ifork_zone
comma
id|ip-&gt;i_afp
)paren
suffix:semicolon
id|ip-&gt;i_afp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_idestroy_fork
c_func
(paren
id|ip
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The file is in-lined in the on-disk inode.&n; * If it fits into if_inline_data, then copy&n; * it there, otherwise allocate a buffer for it&n; * and copy the data there.  Either way, set&n; * if_data to point at the data.&n; * If we allocate a buffer for the data, make&n; * sure that its size is a multiple of 4 and&n; * record the real size in i_real_bytes.&n; */
id|STATIC
r_int
DECL|function|xfs_iformat_local
id|xfs_iformat_local
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dinode_t
op_star
id|dip
comma
r_int
id|whichfork
comma
r_int
id|size
)paren
(brace
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
r_int
id|real_size
suffix:semicolon
multiline_comment|/*&n;&t; * If the size is unreasonable, then something&n;&t; * is wrong and we just bail out rather than crash in&n;&t; * kmem_alloc() or memcpy() below.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|size
OG
id|XFS_DFORK_SIZE_ARCH
c_func
(paren
id|dip
comma
id|ip-&gt;i_mount
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt inode %Lu (bad size %d for local fork, size = %d).  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
comma
id|size
comma
id|XFS_DFORK_SIZE_ARCH
c_func
(paren
id|dip
comma
id|ip-&gt;i_mount
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iformat_local&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
comma
id|dip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|real_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|ifp-&gt;if_u1.if_data
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|size
op_le
r_sizeof
(paren
id|ifp-&gt;if_u2.if_inline_data
)paren
)paren
id|ifp-&gt;if_u1.if_data
op_assign
id|ifp-&gt;if_u2.if_inline_data
suffix:semicolon
r_else
(brace
id|real_size
op_assign
id|roundup
c_func
(paren
id|size
comma
l_int|4
)paren
suffix:semicolon
id|ifp-&gt;if_u1.if_data
op_assign
id|kmem_alloc
c_func
(paren
id|real_size
comma
id|KM_SLEEP
)paren
suffix:semicolon
)brace
id|ifp-&gt;if_bytes
op_assign
id|size
suffix:semicolon
id|ifp-&gt;if_real_bytes
op_assign
id|real_size
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
id|memcpy
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|XFS_DFORK_PTR_ARCH
c_func
(paren
id|dip
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
comma
id|size
)paren
suffix:semicolon
id|ifp-&gt;if_flags
op_and_assign
op_complement
id|XFS_IFEXTENTS
suffix:semicolon
id|ifp-&gt;if_flags
op_or_assign
id|XFS_IFINLINE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The file consists of a set of extents all&n; * of which fit into the on-disk inode.&n; * If there are few enough extents to fit into&n; * the if_inline_ext, then copy them there.&n; * Otherwise allocate a buffer for them and copy&n; * them into it.  Either way, set if_extents&n; * to point at the extents.&n; */
id|STATIC
r_int
DECL|function|xfs_iformat_extents
id|xfs_iformat_extents
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dinode_t
op_star
id|dip
comma
r_int
id|whichfork
)paren
(brace
id|xfs_bmbt_rec_t
op_star
id|ep
comma
op_star
id|dp
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
r_int
id|nex
suffix:semicolon
r_int
id|real_size
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|nex
op_assign
id|XFS_DFORK_NEXTENTS_ARCH
c_func
(paren
id|dip
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|size
op_assign
id|nex
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the number of extents is unreasonable, then something&n;&t; * is wrong and we just bail out rather than crash in&n;&t; * kmem_alloc() or memcpy() below.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|size
template_param
id|XFS_DFORK_SIZE_ARCH
c_func
(paren
id|dip
comma
id|ip-&gt;i_mount
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt inode %Lu ((a)extents = %d).  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
comma
id|nex
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iformat_extents(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
comma
id|dip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|real_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nex
op_eq
l_int|0
)paren
id|ifp-&gt;if_u1.if_extents
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|nex
op_le
id|XFS_INLINE_EXTS
)paren
id|ifp-&gt;if_u1.if_extents
op_assign
id|ifp-&gt;if_u2.if_inline_ext
suffix:semicolon
r_else
(brace
id|ifp-&gt;if_u1.if_extents
op_assign
id|kmem_alloc
c_func
(paren
id|size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_u1.if_extents
op_ne
l_int|NULL
)paren
suffix:semicolon
id|real_size
op_assign
id|size
suffix:semicolon
)brace
id|ifp-&gt;if_bytes
op_assign
id|size
suffix:semicolon
id|ifp-&gt;if_real_bytes
op_assign
id|real_size
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|dp
op_assign
(paren
id|xfs_bmbt_rec_t
op_star
)paren
id|XFS_DFORK_PTR_ARCH
c_func
(paren
id|dip
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_validate_extents
c_func
(paren
id|dp
comma
id|nex
comma
l_int|1
comma
id|XFS_EXTFMT_INODE
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|ep
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nex
suffix:semicolon
id|i
op_increment
comma
id|ep
op_increment
comma
id|dp
op_increment
)paren
(brace
id|ep-&gt;l0
op_assign
id|INT_GET
c_func
(paren
id|get_unaligned
c_func
(paren
(paren
id|__uint64_t
op_star
)paren
op_amp
id|dp-&gt;l0
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ep-&gt;l1
op_assign
id|INT_GET
c_func
(paren
id|get_unaligned
c_func
(paren
(paren
id|__uint64_t
op_star
)paren
op_amp
id|dp-&gt;l1
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
id|xfs_bmap_trace_exlist
c_func
(paren
l_string|&quot;xfs_iformat_extents&quot;
comma
id|ip
comma
id|nex
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|whichfork
op_ne
id|XFS_DATA_FORK
op_logical_or
id|XFS_EXTFMT_INODE
c_func
(paren
id|ip
)paren
op_eq
id|XFS_EXTFMT_NOSTATE
)paren
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|xfs_check_nostate_extents
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|nex
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_iformat_extents(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
id|ifp-&gt;if_flags
op_or_assign
id|XFS_IFEXTENTS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The file has too many extents to fit into&n; * the inode, so they are in B-tree format.&n; * Allocate a buffer for the root of the B-tree&n; * and copy the root into it.  The i_extents&n; * field will remain NULL until all of the&n; * extents are read in (when they are needed).&n; */
id|STATIC
r_int
DECL|function|xfs_iformat_btree
id|xfs_iformat_btree
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dinode_t
op_star
id|dip
comma
r_int
id|whichfork
)paren
(brace
id|xfs_bmdr_block_t
op_star
id|dfp
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* REFERENCED */
r_int
id|nrecs
suffix:semicolon
r_int
id|size
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|dfp
op_assign
(paren
id|xfs_bmdr_block_t
op_star
)paren
id|XFS_DFORK_PTR_ARCH
c_func
(paren
id|dip
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|size
op_assign
id|XFS_BMAP_BROOT_SPACE
c_func
(paren
id|dfp
)paren
suffix:semicolon
id|nrecs
op_assign
id|XFS_BMAP_BROOT_NUMRECS
c_func
(paren
id|dfp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * blow out if -- fork has less extents than can fit in&n;&t; * fork (fork shouldn&squot;t be a btree format), root btree&n;&t; * block has more records than can fit into the fork,&n;&t; * or the number of extents is greater than the number of&n;&t; * blocks.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_le
id|ifp-&gt;if_ext_max
op_logical_or
id|XFS_BMDR_SPACE_CALC
c_func
(paren
id|nrecs
)paren
OG
id|XFS_DFORK_SIZE_ARCH
c_func
(paren
id|dip
comma
id|ip-&gt;i_mount
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
OG
id|ip-&gt;i_d.di_nblocks
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|ip-&gt;i_mount
comma
l_string|&quot;corrupt inode %Lu (btree).  Unmount and run xfs_repair.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_iformat_btree&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|ifp-&gt;if_broot_bytes
op_assign
id|size
suffix:semicolon
id|ifp-&gt;if_broot
op_assign
id|kmem_alloc
c_func
(paren
id|size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_broot
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy and convert from the on-disk structure&n;&t; * to the in-memory structure.&n;&t; */
id|xfs_bmdr_to_bmbt
c_func
(paren
id|dfp
comma
id|XFS_DFORK_SIZE_ARCH
c_func
(paren
id|dip
comma
id|ip-&gt;i_mount
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
comma
id|ifp-&gt;if_broot
comma
id|size
)paren
suffix:semicolon
id|ifp-&gt;if_flags
op_and_assign
op_complement
id|XFS_IFEXTENTS
suffix:semicolon
id|ifp-&gt;if_flags
op_or_assign
id|XFS_IFBROOT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_xlate_dinode_core - translate an xfs_inode_core_t between ondisk&n; * and native format&n; *&n; * buf  = on-disk representation&n; * dip  = native representation&n; * dir  = direction - +ve -&gt; disk to native&n; *                    -ve -&gt; native to disk&n; * arch = on-disk architecture&n; */
r_void
DECL|function|xfs_xlate_dinode_core
id|xfs_xlate_dinode_core
c_func
(paren
id|xfs_caddr_t
id|buf
comma
id|xfs_dinode_core_t
op_star
id|dip
comma
r_int
id|dir
comma
id|xfs_arch_t
id|arch
)paren
(brace
id|xfs_dinode_core_t
op_star
id|buf_core
op_assign
(paren
id|xfs_dinode_core_t
op_star
)paren
id|buf
suffix:semicolon
id|xfs_dinode_core_t
op_star
id|mem_core
op_assign
(paren
id|xfs_dinode_core_t
op_star
)paren
id|dip
suffix:semicolon
id|ASSERT
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arch
op_eq
id|ARCH_NOCONVERT
)paren
(brace
r_if
c_cond
(paren
id|dir
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
(paren
id|xfs_caddr_t
)paren
id|mem_core
comma
(paren
id|xfs_caddr_t
)paren
id|buf_core
comma
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
(paren
id|xfs_caddr_t
)paren
id|buf_core
comma
(paren
id|xfs_caddr_t
)paren
id|mem_core
comma
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_magic
comma
id|mem_core-&gt;di_magic
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_mode
comma
id|mem_core-&gt;di_mode
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_version
comma
id|mem_core-&gt;di_version
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_format
comma
id|mem_core-&gt;di_format
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_onlink
comma
id|mem_core-&gt;di_onlink
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_uid
comma
id|mem_core-&gt;di_uid
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_gid
comma
id|mem_core-&gt;di_gid
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_nlink
comma
id|mem_core-&gt;di_nlink
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_projid
comma
id|mem_core-&gt;di_projid
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|mem_core-&gt;di_pad
comma
id|buf_core-&gt;di_pad
comma
r_sizeof
(paren
id|buf_core-&gt;di_pad
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|buf_core-&gt;di_pad
comma
id|mem_core-&gt;di_pad
comma
r_sizeof
(paren
id|buf_core-&gt;di_pad
)paren
)paren
suffix:semicolon
)brace
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_flushiter
comma
id|mem_core-&gt;di_flushiter
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_atime.t_sec
comma
id|mem_core-&gt;di_atime.t_sec
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_atime.t_nsec
comma
id|mem_core-&gt;di_atime.t_nsec
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_mtime.t_sec
comma
id|mem_core-&gt;di_mtime.t_sec
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_mtime.t_nsec
comma
id|mem_core-&gt;di_mtime.t_nsec
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_ctime.t_sec
comma
id|mem_core-&gt;di_ctime.t_sec
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_ctime.t_nsec
comma
id|mem_core-&gt;di_ctime.t_nsec
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_size
comma
id|mem_core-&gt;di_size
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_nblocks
comma
id|mem_core-&gt;di_nblocks
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_extsize
comma
id|mem_core-&gt;di_extsize
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_nextents
comma
id|mem_core-&gt;di_nextents
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_anextents
comma
id|mem_core-&gt;di_anextents
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_forkoff
comma
id|mem_core-&gt;di_forkoff
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_aformat
comma
id|mem_core-&gt;di_aformat
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_dmevmask
comma
id|mem_core-&gt;di_dmevmask
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_dmstate
comma
id|mem_core-&gt;di_dmstate
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_flags
comma
id|mem_core-&gt;di_flags
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
id|INT_XLATE
c_func
(paren
id|buf_core-&gt;di_gen
comma
id|mem_core-&gt;di_gen
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a mount structure and an inode number, return a pointer&n; * to a newly allocated in-core inode coresponding to the given&n; * inode number.&n; *&n; * Initialize the inode&squot;s attributes and extent pointers if it&n; * already has them (it will not if the inode has no links).&n; */
r_int
DECL|function|xfs_iread
id|xfs_iread
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_ino_t
id|ino
comma
id|xfs_inode_t
op_star
op_star
id|ipp
comma
id|xfs_daddr_t
id|bno
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_inode_zone
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ip
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_inode_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ip-&gt;i_ino
op_assign
id|ino
suffix:semicolon
id|ip-&gt;i_mount
op_assign
id|mp
suffix:semicolon
multiline_comment|/*&n;&t; * Get pointer&squot;s to the on-disk inode and the buffer containing it.&n;&t; * If the inode number refers to a block outside the file system&n;&t; * then xfs_itobp() will return NULL.  In this case we should&n;&t; * return NULL as well.  Set i_blkno to 0 so that xfs_itobp() will&n;&t; * know that this is a new incore inode.&n;&t; */
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|bp
comma
id|bno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|kmem_zone_free
c_func
(paren
id|xfs_inode_zone
comma
id|ip
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize inode&squot;s trace buffers.&n;&t; * Do this before xfs_iformat in case it adds entries.&n;&t; */
macro_line|#ifdef XFS_BMAP_TRACE
id|ip-&gt;i_xtrace
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_BMAP_KTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMBT_TRACE
id|ip-&gt;i_btrace
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_BMBT_KTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_RW_TRACE
id|ip-&gt;i_rwtrace
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_RW_KTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_STRAT_TRACE
id|ip-&gt;i_strat_trace
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_STRAT_KTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_ILOCK_TRACE
id|ip-&gt;i_lock_trace
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_ILOCK_KTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DIR2_TRACE
id|ip-&gt;i_dir_trace
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_DIR2_KTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If we got something that isn&squot;t an inode it means someone&n;&t; * (nfs or dmi) has a stale handle.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DINODE_MAGIC
)paren
(brace
id|kmem_zone_free
c_func
(paren
id|xfs_inode_zone
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iread: &quot;
l_string|&quot;dip-&gt;di_core.di_magic (0x%x) != &quot;
l_string|&quot;XFS_DINODE_MAGIC (0x%x)&quot;
comma
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
comma
id|XFS_DINODE_MAGIC
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the on-disk inode is already linked to a directory&n;&t; * entry, copy all of the inode into the in-core inode.&n;&t; * xfs_iformat() handles copying in the inode format&n;&t; * specific information.&n;&t; * Otherwise, just get the truly permanent information.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|dip-&gt;di_core.di_mode
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_xlate_dinode_core
c_func
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|dip-&gt;di_core
comma
op_amp
(paren
id|ip-&gt;i_d
)paren
comma
l_int|1
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iformat
c_func
(paren
id|ip
comma
id|dip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kmem_zone_free
c_func
(paren
id|xfs_inode_zone
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iread: &quot;
l_string|&quot;xfs_iformat() returned error %d&quot;
comma
id|error
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_return
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
id|ip-&gt;i_d.di_magic
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ip-&gt;i_d.di_version
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_version
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ip-&gt;i_d.di_gen
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_gen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ip-&gt;i_d.di_flushiter
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_flushiter
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure to pull in the mode here as well in&n;&t;&t; * case the inode is released without being used.&n;&t;&t; * This ensures that xfs_inactive() will see that&n;&t;&t; * the inode is already free and not try to mess&n;&t;&t; * with the uninitialized part of it.&n;&t;&t; */
id|ip-&gt;i_d.di_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the per-fork minima and maxima for a new&n;&t;&t; * inode here.  xfs_iformat will do it for old inodes.&n;&t;&t; */
id|ip-&gt;i_df.if_ext_max
op_assign
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ip-&gt;i_reclaim
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The inode format changed when we moved the link count and&n;&t; * made it 32 bits long.  If this is an old format inode,&n;&t; * convert it in memory to look like a new one.  If it gets&n;&t; * flushed to disk we will convert back before flushing or&n;&t; * logging it.  We zero out the new projid field and the old link&n;&t; * count field.  We&squot;ll handle clearing the pad field (the remains&n;&t; * of the old uuid field) when we actually convert the inode to&n;&t; * the new format. We don&squot;t change the version number so that we&n;&t; * can distinguish this from a real new format inode.&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
(brace
id|ip-&gt;i_d.di_nlink
op_assign
id|ip-&gt;i_d.di_onlink
suffix:semicolon
id|ip-&gt;i_d.di_onlink
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_projid
op_assign
l_int|0
suffix:semicolon
)brace
id|ip-&gt;i_delayed_blks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the buffer containing the inode as something to keep&n;&t; * around for a while.  This helps to keep recently accessed&n;&t; * meta-data in-core longer.&n;&t; */
id|XFS_BUF_SET_REF
c_func
(paren
id|bp
comma
id|XFS_INO_REF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Use xfs_trans_brelse() to release the buffer containing the&n;&t; * on-disk inode, because it was acquired with xfs_trans_read_buf()&n;&t; * in xfs_itobp() above.  If tp is NULL, this is just a normal&n;&t; * brelse().  If we&squot;re within a transaction, then xfs_trans_brelse()&n;&t; * will only release the buffer if it is not dirty within the&n;&t; * transaction.  It will be OK to release the buffer in this case,&n;&t; * because inodes on disk are never destroyed and we will be&n;&t; * locking the new in-core inode before putting it in the hash&n;&t; * table where other processes can find it.  Thus we don&squot;t have&n;&t; * to worry about the inode being changed just because we released&n;&t; * the buffer.&n;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
op_star
id|ipp
op_assign
id|ip
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in extents from a btree-format inode.&n; * Allocate and fill in if_extents.  Real work is done in xfs_bmap.c.&n; */
r_int
DECL|function|xfs_iread_extents
id|xfs_iread_extents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|whichfork
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_iread_extents&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|ip-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|size
op_assign
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We know that the size is valid (it&squot;s checked in iformat_btree)&n;&t; */
id|ifp-&gt;if_u1.if_extents
op_assign
id|kmem_alloc
c_func
(paren
id|size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_u1.if_extents
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ifp-&gt;if_lastex
op_assign
id|NULLEXTNUM
suffix:semicolon
id|ifp-&gt;if_bytes
op_assign
id|ifp-&gt;if_real_bytes
op_assign
(paren
r_int
)paren
id|size
suffix:semicolon
id|ifp-&gt;if_flags
op_or_assign
id|XFS_IFEXTENTS
suffix:semicolon
id|error
op_assign
id|xfs_bmap_read_extents
c_func
(paren
id|tp
comma
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kmem_free
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|size
)paren
suffix:semicolon
id|ifp-&gt;if_u1.if_extents
op_assign
l_int|NULL
suffix:semicolon
id|ifp-&gt;if_bytes
op_assign
id|ifp-&gt;if_real_bytes
op_assign
l_int|0
suffix:semicolon
id|ifp-&gt;if_flags
op_and_assign
op_complement
id|XFS_IFEXTENTS
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_validate_extents
c_func
(paren
(paren
id|xfs_bmbt_rec_t
op_star
)paren
id|ifp-&gt;if_u1.if_extents
comma
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
comma
l_int|0
comma
id|XFS_EXTFMT_INODE
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate an inode on disk and return a copy of its in-core version.&n; * The in-core inode is locked exclusively.  Set mode, nlink, and rdev&n; * appropriately within the inode.  The uid and gid for the inode are&n; * set according to the contents of the given cred structure.&n; *&n; * Use xfs_dialloc() to allocate the on-disk inode. If xfs_dialloc()&n; * has a free inode available, call xfs_iget()&n; * to obtain the in-core version of the allocated inode.  Finally,&n; * fill in the inode and log its initial contents.  In this case,&n; * ialloc_context would be set to NULL and call_again set to false.&n; *&n; * If xfs_dialloc() does not have an available inode,&n; * it will replenish its supply by doing an allocation. Since we can&n; * only do one allocation within a transaction without deadlocks, we&n; * must commit the current transaction before returning the inode itself.&n; * In this case, therefore, we will set call_again to true and return.&n; * The caller should then commit the current transaction, start a new&n; * transaction, and call xfs_ialloc() again to actually get the inode.&n; *&n; * To ensure that some other process does not grab the inode that&n; * was allocated during the first call to xfs_ialloc(), this routine&n; * also returns the [locked] bp pointing to the head of the freelist&n; * as ialloc_context.  The caller should hold this buffer across&n; * the commit and pass it back into this routine on the second call.&n; */
r_int
DECL|function|xfs_ialloc
id|xfs_ialloc
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|pip
comma
id|mode_t
id|mode
comma
id|nlink_t
id|nlink
comma
id|xfs_dev_t
id|rdev
comma
id|cred_t
op_star
id|cr
comma
id|xfs_prid_t
id|prid
comma
r_int
id|okalloc
comma
id|xfs_buf_t
op_star
op_star
id|ialloc_context
comma
id|boolean_t
op_star
id|call_again
comma
id|xfs_inode_t
op_star
op_star
id|ipp
)paren
(brace
id|xfs_ino_t
id|ino
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|uint
id|flags
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Call the space management code to pick&n;&t; * the on-disk inode to be allocated.&n;&t; */
id|ASSERT
c_func
(paren
id|pip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_dialloc
c_func
(paren
id|tp
comma
id|pip
ques
c_cond
id|pip-&gt;i_ino
suffix:colon
l_int|0
comma
id|mode
comma
id|okalloc
comma
id|ialloc_context
comma
id|call_again
comma
op_amp
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|call_again
op_logical_or
id|ino
op_eq
id|NULLFSINO
)paren
(brace
op_star
id|ipp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_star
id|ialloc_context
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the in-core inode with the lock held exclusively.&n;&t; * This is because we&squot;re setting fields here we need&n;&t; * to prevent others from looking at until we&squot;re done.&n;&t; */
id|error
op_assign
id|xfs_trans_iget
c_func
(paren
id|tp-&gt;t_mountp
comma
id|tp
comma
id|ino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
id|vp-&gt;v_type
op_assign
id|IFTOVT
c_func
(paren
id|mode
)paren
suffix:semicolon
id|ip-&gt;i_d.di_mode
op_assign
(paren
id|__uint16_t
)paren
id|mode
suffix:semicolon
id|ip-&gt;i_d.di_onlink
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_nlink
op_assign
id|nlink
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
op_eq
id|nlink
)paren
suffix:semicolon
id|ip-&gt;i_d.di_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|ip-&gt;i_d.di_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|ip-&gt;i_d.di_projid
op_assign
id|prid
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|ip-&gt;i_d.di_pad
(braket
l_int|0
)braket
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|ip-&gt;i_d.di_pad
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the superblock version is up to where we support new format&n;&t; * inodes and this is currently an old format inode, then change&n;&t; * the inode version number now.  This way we only do the conversion&n;&t; * here rather than here and in the flush/logging code.&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|tp-&gt;t_mountp-&gt;m_sb
)paren
op_logical_and
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
(brace
id|ip-&gt;i_d.di_version
op_assign
id|XFS_DINODE_VERSION_2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We&squot;ve already zeroed the old link count, the projid field,&n;&t;&t; * and the pad field.&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * Project ids won&squot;t be stored on disk if we are using a version 1 inode.&n;&t; */
r_if
c_cond
(paren
(paren
id|prid
op_ne
l_int|0
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
)paren
id|xfs_bump_ino_vers2
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_INHERIT_GID
c_func
(paren
id|pip
comma
id|vp-&gt;v_vfsp
)paren
)paren
(brace
id|ip-&gt;i_d.di_gid
op_assign
id|pip-&gt;i_d.di_gid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pip-&gt;i_d.di_mode
op_amp
id|ISGID
)paren
op_logical_and
(paren
id|mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
(brace
id|ip-&gt;i_d.di_mode
op_or_assign
id|ISGID
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If the group ID of the new file does not match the effective group&n;&t; * ID or one of the supplementary group IDs, the ISGID bit is cleared&n;&t; * (and only if the irix_sgid_inherit compatibility variable is set).&n;&t; */
r_if
c_cond
(paren
(paren
id|irix_sgid_inherit
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|ISGID
)paren
op_logical_and
(paren
op_logical_neg
id|in_group_p
c_func
(paren
(paren
id|gid_t
)paren
id|ip-&gt;i_d.di_gid
)paren
)paren
)paren
(brace
id|ip-&gt;i_d.di_mode
op_and_assign
op_complement
id|ISGID
suffix:semicolon
)brace
id|ip-&gt;i_d.di_size
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nblocks
op_eq
l_int|0
)paren
suffix:semicolon
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_CHG
op_or
id|XFS_ICHGTIME_ACC
op_or
id|XFS_ICHGTIME_MOD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * di_gen will have been taken care of in xfs_iread.&n;&t; */
id|ip-&gt;i_d.di_extsize
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_dmevmask
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_dmstate
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_NODUMP
)paren
op_logical_and
id|xfs_inherit_nodump
)paren
id|ip-&gt;i_d.di_flags
op_or_assign
id|XFS_DIFLAG_NODUMP
suffix:semicolon
id|flags
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|IFMT
)paren
(brace
r_case
id|IFIFO
suffix:colon
r_case
id|IFCHR
suffix:colon
r_case
id|IFBLK
suffix:colon
r_case
id|IFSOCK
suffix:colon
id|ip-&gt;i_d.di_format
op_assign
id|XFS_DINODE_FMT_DEV
suffix:semicolon
id|ip-&gt;i_df.if_u2.if_rdev
op_assign
id|rdev
suffix:semicolon
id|ip-&gt;i_df.if_flags
op_assign
l_int|0
suffix:semicolon
id|flags
op_or_assign
id|XFS_ILOG_DEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IFREG
suffix:colon
r_case
id|IFDIR
suffix:colon
r_if
c_cond
(paren
(paren
id|pip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_SYNC
)paren
op_logical_and
id|xfs_inherit_sync
)paren
id|ip-&gt;i_d.di_flags
op_or_assign
id|XFS_DIFLAG_SYNC
suffix:semicolon
r_case
id|IFLNK
suffix:colon
id|ip-&gt;i_d.di_format
op_assign
id|XFS_DINODE_FMT_EXTENTS
suffix:semicolon
id|ip-&gt;i_df.if_flags
op_assign
id|XFS_IFEXTENTS
suffix:semicolon
id|ip-&gt;i_df.if_bytes
op_assign
id|ip-&gt;i_df.if_real_bytes
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_df.if_u1.if_extents
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute fork settings for new inode.&n;&t; */
id|ip-&gt;i_d.di_aformat
op_assign
id|XFS_DINODE_FMT_EXTENTS
suffix:semicolon
id|ip-&gt;i_d.di_anextents
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Log the new values stuffed into the inode.&n;&t; */
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* now that we have a v_type we can set Linux inode ops (&amp; unlock) */
id|VFS_INIT_VNODE
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|tp-&gt;t_mountp
)paren
comma
id|vp
comma
id|XFS_ITOBHV
c_func
(paren
id|ip
)paren
comma
l_int|1
)paren
suffix:semicolon
op_star
id|ipp
op_assign
id|ip
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check to make sure that there are no blocks allocated to the&n; * file beyond the size of the file.  We don&squot;t check this for&n; * files with fixed size extents or real time extents, but we&n; * at least do it for regular files.&n; */
macro_line|#ifdef DEBUG
r_void
DECL|function|xfs_isize_check
id|xfs_isize_check
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_fsize_t
id|isize
)paren
(brace
id|xfs_fileoff_t
id|map_first
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
id|xfs_bmbt_irec_t
id|imaps
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_ne
id|IFREG
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
r_return
suffix:semicolon
id|nimaps
op_assign
l_int|2
suffix:semicolon
id|map_first
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|isize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The filesystem could be shutting down, so bmapi may return&n;&t; * an error.&n;&t; */
r_if
c_cond
(paren
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|map_first
comma
(paren
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
)paren
op_minus
id|map_first
)paren
comma
id|XFS_BMAPI_ENTIRE
comma
l_int|NULL
comma
l_int|0
comma
id|imaps
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
)paren
r_return
suffix:semicolon
id|ASSERT
c_func
(paren
id|nimaps
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|imaps
(braket
l_int|0
)braket
dot
id|br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/*&n; * Calculate the last possible buffered byte in a file.  This must&n; * include data that was buffered beyond the EOF by the write code.&n; * This also needs to deal with overflowing the xfs_fsize_t type&n; * which can happen for sizes near the limit.&n; *&n; * We also need to take into account any blocks beyond the EOF.  It&n; * may be the case that they were buffered by a write which failed.&n; * In that case the pages will still be in memory, but the inode size&n; * will never have been updated.&n; */
id|xfs_fsize_t
DECL|function|xfs_file_last_byte
id|xfs_file_last_byte
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_fsize_t
id|last_byte
suffix:semicolon
id|xfs_fileoff_t
id|last_block
suffix:semicolon
id|xfs_fileoff_t
id|size_last_block
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|ip-&gt;i_iolock
)paren
comma
id|MR_UPDATE
op_or
id|MR_ACCESS
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Only check for blocks beyond the EOF if the extents have&n;&t; * been read in.  This eliminates the need for the inode lock,&n;&t; * and it also saves us from looking when it really isn&squot;t&n;&t; * necessary.&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_df.if_flags
op_amp
id|XFS_IFEXTENTS
)paren
(brace
id|error
op_assign
id|xfs_bmap_last_offset
c_func
(paren
l_int|NULL
comma
id|ip
comma
op_amp
id|last_block
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|last_block
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|last_block
op_assign
l_int|0
suffix:semicolon
)brace
id|size_last_block
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|ip-&gt;i_d.di_size
)paren
suffix:semicolon
id|last_block
op_assign
id|XFS_FILEOFF_MAX
c_func
(paren
id|last_block
comma
id|size_last_block
)paren
suffix:semicolon
id|last_byte
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|last_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_byte
OL
l_int|0
)paren
(brace
r_return
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|last_byte
op_add_assign
(paren
l_int|1
op_lshift
id|mp-&gt;m_writeio_log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_byte
OL
l_int|0
)paren
(brace
r_return
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
id|last_byte
suffix:semicolon
)brace
macro_line|#if defined(XFS_RW_TRACE)
id|STATIC
r_void
DECL|function|xfs_itrunc_trace
id|xfs_itrunc_trace
c_func
(paren
r_int
id|tag
comma
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|flag
comma
id|xfs_fsize_t
id|new_size
comma
id|xfs_off_t
id|toss_start
comma
id|xfs_off_t
id|toss_finish
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_rwtrace
op_eq
l_int|NULL
)paren
(brace
r_return
suffix:semicolon
)brace
id|ktrace_enter
c_func
(paren
id|ip-&gt;i_rwtrace
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
)paren
id|tag
)paren
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|ip-&gt;i_d.di_size
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|ip-&gt;i_d.di_size
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
)paren
id|flag
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|new_size
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|new_size
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|toss_start
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|toss_start
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|toss_finish
op_rshift
l_int|32
)paren
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|toss_finish
op_amp
l_int|0xffffffff
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
)paren
r_private
dot
id|p_cpuid
)paren
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|xfs_itrunc_trace
mdefine_line|#define&t;xfs_itrunc_trace(tag, ip, flag, new_size, toss_start, toss_finish)
macro_line|#endif
multiline_comment|/*&n; * Start the truncation of the file to new_size.  The new size&n; * must be smaller than the current size.  This routine will&n; * clear the buffer and page caches of file data in the removed&n; * range, and xfs_itruncate_finish() will remove the underlying&n; * disk blocks.&n; *&n; * The inode must have its I/O lock locked EXCLUSIVELY, and it&n; * must NOT have the inode lock held at all.  This is because we&squot;re&n; * calling into the buffer/page cache code and we can&squot;t hold the&n; * inode lock when we do so.&n; *&n; * The flags parameter can have either the value XFS_ITRUNC_DEFINITE&n; * or XFS_ITRUNC_MAYBE.  The XFS_ITRUNC_MAYBE value should be used&n; * in the case that the caller is locking things out of order and&n; * may not be able to call xfs_itruncate_finish() with the inode lock&n; * held without dropping the I/O lock.  If the caller must drop the&n; * I/O lock before calling xfs_itruncate_finish(), then xfs_itruncate_start()&n; * must be called again with all the same restrictions as the initial&n; * call.&n; */
r_void
DECL|function|xfs_itruncate_start
id|xfs_itruncate_start
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|flags
comma
id|xfs_fsize_t
id|new_size
)paren
(brace
id|xfs_fsize_t
id|last_byte
suffix:semicolon
id|xfs_off_t
id|toss_start
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_iolock
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|new_size
op_eq
l_int|0
)paren
op_logical_or
(paren
id|new_size
op_le
id|ip-&gt;i_d.di_size
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_eq
id|XFS_ITRUNC_DEFINITE
)paren
op_logical_or
(paren
id|flags
op_eq
id|XFS_ITRUNC_MAYBE
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Call VOP_TOSS_PAGES() or VOP_FLUSHINVAL_PAGES() to get rid of pages and buffers&n;&t; * overlapping the region being removed.  We have to use&n;&t; * the less efficient VOP_FLUSHINVAL_PAGES() in the case that the&n;&t; * caller may not be able to finish the truncate without&n;&t; * dropping the inode&squot;s I/O lock.  Make sure&n;&t; * to catch any pages brought in by buffers overlapping&n;&t; * the EOF by searching out beyond the isize by our&n;&t; * block size. We round new_size up to a block boundary&n;&t; * so that we don&squot;t toss things on the same block as&n;&t; * new_size but before it.&n;&t; *&n;&t; * Before calling VOP_TOSS_PAGES() or VOP_FLUSHINVAL_PAGES(), make sure to&n;&t; * call remapf() over the same region if the file is mapped.&n;&t; * This frees up mapped file references to the pages in the&n;&t; * given range and for the VOP_FLUSHINVAL_PAGES() case it ensures&n;&t; * that we get the latest mapped changes flushed out.&n;&t; */
id|toss_start
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|new_size
)paren
suffix:semicolon
id|toss_start
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|toss_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|toss_start
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The place to start tossing is beyond our maximum&n;&t;&t; * file size, so there is no way that the data extended&n;&t;&t; * out there.&n;&t;&t; */
r_return
suffix:semicolon
)brace
id|last_byte
op_assign
id|xfs_file_last_byte
c_func
(paren
id|ip
)paren
suffix:semicolon
id|xfs_itrunc_trace
c_func
(paren
id|XFS_ITRUNC_START
comma
id|ip
comma
id|flags
comma
id|new_size
comma
id|toss_start
comma
id|last_byte
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_byte
OG
id|toss_start
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_ITRUNC_DEFINITE
)paren
(brace
id|VOP_TOSS_PAGES
c_func
(paren
id|vp
comma
id|toss_start
comma
op_minus
l_int|1
comma
id|FI_REMAPF_LOCKED
)paren
suffix:semicolon
)brace
r_else
(brace
id|VOP_FLUSHINVAL_PAGES
c_func
(paren
id|vp
comma
id|toss_start
comma
op_minus
l_int|1
comma
id|FI_REMAPF_LOCKED
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|new_size
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|VN_CACHED
c_func
(paren
id|vp
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Shrink the file to the given new_size.  The new&n; * size must be smaller than the current size.&n; * This will free up the underlying blocks&n; * in the removed range after a call to xfs_itruncate_start()&n; * or xfs_atruncate_start().&n; *&n; * The transaction passed to this routine must have made&n; * a permanent log reservation of at least XFS_ITRUNCATE_LOG_RES.&n; * This routine may commit the given transaction and&n; * start new ones, so make sure everything involved in&n; * the transaction is tidy before calling here.&n; * Some transaction will be returned to the caller to be&n; * committed.  The incoming transaction must already include&n; * the inode, and both inode locks must be held exclusively.&n; * The inode must also be &quot;held&quot; within the transaction.  On&n; * return the inode will be &quot;held&quot; within the returned transaction.&n; * This routine does NOT require any disk space to be reserved&n; * for it within the transaction.&n; *&n; * The fork parameter must be either xfs_attr_fork or xfs_data_fork,&n; * and it indicates the fork which is to be truncated.  For the&n; * attribute fork we only support truncation to size 0.&n; *&n; * We use the sync parameter to indicate whether or not the first&n; * transaction we perform might have to be synchronous.  For the attr fork,&n; * it needs to be so if the unlink of the inode is not yet known to be&n; * permanent in the log.  This keeps us from freeing and reusing the&n; * blocks of the attribute fork before the unlink of the inode becomes&n; * permanent.&n; *&n; * For the data fork, we normally have to run synchronously if we&squot;re&n; * being called out of the inactive path or we&squot;re being called&n; * out of the create path where we&squot;re truncating an existing file.&n; * Either way, the truncate needs to be sync so blocks don&squot;t reappear&n; * in the file with altered data in case of a crash.  wsync filesystems&n; * can run the first case async because anything that shrinks the inode&n; * has to run sync so by the time we&squot;re called here from inactive, the&n; * inode size is permanently set to 0.&n; *&n; * Calls from the truncate path always need to be sync unless we&squot;re&n; * in a wsync filesystem and the file has already been unlinked.&n; *&n; * The caller is responsible for correctly setting the sync parameter.&n; * It gets too hard for us to guess here which path we&squot;re being called&n; * out of just based on inode state.&n; */
r_int
DECL|function|xfs_itruncate_finish
id|xfs_itruncate_finish
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_fsize_t
id|new_size
comma
r_int
id|fork
comma
r_int
id|sync
)paren
(brace
id|xfs_fsblock_t
id|first_block
suffix:semicolon
id|xfs_fileoff_t
id|first_unmap_block
suffix:semicolon
id|xfs_fileoff_t
id|last_block
suffix:semicolon
id|xfs_filblks_t
id|unmap_len
op_assign
l_int|0
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_trans_t
op_star
id|ntp
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_iolock
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|new_size
op_eq
l_int|0
)paren
op_logical_or
(paren
id|new_size
op_le
id|ip-&gt;i_d.di_size
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|tp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
op_star
id|tp
)paren
op_member_access_from_pointer
id|t_flags
op_amp
id|XFS_TRANS_PERM_LOG_RES
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_transp
op_eq
op_star
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_itemp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_itemp-&gt;ili_flags
op_amp
id|XFS_ILI_HOLD
)paren
suffix:semicolon
id|ntp
op_assign
op_star
id|tp
suffix:semicolon
id|mp
op_assign
(paren
id|ntp
)paren
op_member_access_from_pointer
id|t_mountp
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_NOT_DQATTACHED
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We only support truncating the entire attribute fork.&n;&t; */
r_if
c_cond
(paren
id|fork
op_eq
id|XFS_ATTR_FORK
)paren
(brace
id|new_size
op_assign
l_int|0LL
suffix:semicolon
)brace
id|first_unmap_block
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|new_size
)paren
suffix:semicolon
id|xfs_itrunc_trace
c_func
(paren
id|XFS_ITRUNC_FINISH1
comma
id|ip
comma
l_int|0
comma
id|new_size
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first thing we do is set the size to new_size permanently&n;&t; * on disk.  This way we don&squot;t have to worry about anyone ever&n;&t; * being able to look at the data being freed even in the face&n;&t; * of a crash.  What we&squot;re getting around here is the case where&n;&t; * we free a block, it is allocated to another file, it is written&n;&t; * to, and then we crash.  If the new data gets written to the&n;&t; * file but the log buffers containing the free and reallocation&n;&t; * don&squot;t, then we&squot;d end up with garbage in the blocks being freed.&n;&t; * As long as we make the new_size permanent before actually&n;&t; * freeing any blocks it doesn&squot;t matter if they get writtten to.&n;&t; *&n;&t; * The callers must signal into us whether or not the size&n;&t; * setting here must be synchronous.  There are a few cases&n;&t; * where it doesn&squot;t have to be synchronous.  Those cases&n;&t; * occur if the file is unlinked and we know the unlink is&n;&t; * permanent or if the blocks being truncated are guaranteed&n;&t; * to be beyond the inode eof (regardless of the link count)&n;&t; * and the eof value is permanent.  Both of these cases occur&n;&t; * only on wsync-mounted filesystems.  In those cases, we&squot;re&n;&t; * guaranteed that no user will ever see the data in the blocks&n;&t; * that are being truncated so the truncate can run async.&n;&t; * In the free beyond eof case, the file may wind up with&n;&t; * more blocks allocated to it than it needs if we crash&n;&t; * and that won&squot;t get fixed until the next time the file&n;&t; * is re-opened and closed but that&squot;s ok as that shouldn&squot;t&n;&t; * be too many blocks.&n;&t; *&n;&t; * However, we can&squot;t just make all wsync xactions run async&n;&t; * because there&squot;s one call out of the create path that needs&n;&t; * to run sync where it&squot;s truncating an existing file to size&n;&t; * 0 whose size is &gt; 0.&n;&t; *&n;&t; * It&squot;s probably possible to come up with a test in this&n;&t; * routine that would correctly distinguish all the above&n;&t; * cases from the values of the function parameters and the&n;&t; * inode state but for sanity&squot;s sake, I&squot;ve decided to let the&n;&t; * layers above just tell us.  It&squot;s simpler to correctly figure&n;&t; * out in the layer above exactly under what conditions we&n;&t; * can run async and I think it&squot;s easier for others read and&n;&t; * follow the logic in case something has to be changed.&n;&t; * cscope is your friend -- rcc.&n;&t; *&n;&t; * The attribute fork is much simpler.&n;&t; *&n;&t; * For the attribute fork we allow the caller to tell us whether&n;&t; * the unlink of the inode that led to this call is yet permanent&n;&t; * in the on disk log.  If it is not and we will be freeing extents&n;&t; * in this inode then we make the first transaction synchronous&n;&t; * to make sure that the unlink is permanent by the time we free&n;&t; * the blocks.&n;&t; */
r_if
c_cond
(paren
id|fork
op_eq
id|XFS_DATA_FORK
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nextents
OG
l_int|0
)paren
(brace
id|ip-&gt;i_d.di_size
op_assign
id|new_size
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|ntp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|sync
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_anextents
OG
l_int|0
)paren
id|xfs_trans_set_sync
c_func
(paren
id|ntp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|fork
op_eq
id|XFS_DATA_FORK
op_logical_or
(paren
id|fork
op_eq
id|XFS_ATTR_FORK
op_logical_and
(paren
(paren
id|sync
op_logical_and
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
)paren
op_logical_or
(paren
id|sync
op_eq
l_int|0
op_logical_and
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since it is possible for space to become allocated beyond&n;&t; * the end of the file (in a crash where the space is allocated&n;&t; * but the inode size is not yet updated), simply remove any&n;&t; * blocks which show up between the new EOF and the maximum&n;&t; * possible file size.  If the first block to be removed is&n;&t; * beyond the maximum file size (ie it is the same as last_block),&n;&t; * then there is nothing to do.&n;&t; */
id|last_block
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|first_unmap_block
op_le
id|last_block
)paren
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|last_block
op_eq
id|first_unmap_block
)paren
(brace
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|unmap_len
op_assign
id|last_block
op_minus
id|first_unmap_block
op_plus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
multiline_comment|/*&n;&t;&t; * Free up up to XFS_ITRUNC_MAX_EXTENTS.  xfs_bunmapi()&n;&t;&t; * will tell us whether it freed the entire range or&n;&t;&t; * not.  If this is a synchronous mount (wsync),&n;&t;&t; * then we can tell bunmapi to keep all the&n;&t;&t; * transactions asynchronous since the unlink&n;&t;&t; * transaction that made this inode inactive has&n;&t;&t; * already hit the disk.  There&squot;s no danger of&n;&t;&t; * the freed blocks being reused, there being a&n;&t;&t; * crash, and the reused blocks suddenly reappearing&n;&t;&t; * in this file with garbage in them once recovery&n;&t;&t; * runs.&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|first_block
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bunmapi
c_func
(paren
id|ntp
comma
id|ip
comma
id|first_unmap_block
comma
id|unmap_len
comma
id|XFS_BMAPI_AFLAG
c_func
(paren
id|fork
)paren
op_or
(paren
id|sync
ques
c_cond
l_int|0
suffix:colon
id|XFS_BMAPI_ASYNC
)paren
comma
id|XFS_ITRUNC_MAX_EXTENTS
comma
op_amp
id|first_block
comma
op_amp
id|free_list
comma
op_amp
id|done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the bunmapi call encounters an error,&n;&t;&t;&t; * return to the caller where the transaction&n;&t;&t;&t; * can be properly aborted.  We just need to&n;&t;&t;&t; * make sure we&squot;re not holding any resources&n;&t;&t;&t; * that we were not when we came in.&n;&t;&t;&t; */
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Duplicate the transaction that has the permanent&n;&t;&t; * reservation and commit the old transaction.&n;&t;&t; */
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
id|tp
comma
op_amp
id|free_list
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
id|ntp
op_assign
op_star
id|tp
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the bmap finish call encounters an error,&n;&t;&t;&t; * return to the caller where the transaction&n;&t;&t;&t; * can be properly aborted.  We just need to&n;&t;&t;&t; * make sure we&squot;re not holding any resources&n;&t;&t;&t; * that we were not when we came in.&n;&t;&t;&t; *&n;&t;&t;&t; * Aborting from this point might lose some&n;&t;&t;&t; * blocks in the file system, but oh well.&n;&t;&t;&t; */
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|committed
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If the passed in transaction committed&n;&t;&t;&t;&t; * in xfs_bmap_finish(), then we want to&n;&t;&t;&t;&t; * add the inode to this one before returning.&n;&t;&t;&t;&t; * This keeps things simple for the higher&n;&t;&t;&t;&t; * level code, because it always knows that&n;&t;&t;&t;&t; * the inode is locked and held in the&n;&t;&t;&t;&t; * transaction that returns to it whether&n;&t;&t;&t;&t; * errors occur or not.  We don&squot;t mark the&n;&t;&t;&t;&t; * inode dirty so that this transaction can&n;&t;&t;&t;&t; * be easily aborted if possible.&n;&t;&t;&t;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|ntp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|ntp
comma
id|ip
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|committed
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The first xact was committed,&n;&t;&t;&t; * so add the inode to the new one.&n;&t;&t;&t; * Mark it dirty so it will be logged&n;&t;&t;&t; * and moved forward in the log as&n;&t;&t;&t; * part of every commit.&n;&t;&t;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|ntp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|ntp
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|ntp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
id|ntp
op_assign
id|xfs_trans_dup
c_func
(paren
id|ntp
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_trans_commit
c_func
(paren
op_star
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
op_star
id|tp
op_assign
id|ntp
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|ntp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ITRUNCATE_LOG_COUNT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add the inode being truncated to the next chained&n;&t;&t; * transaction.&n;&t;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|ntp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|ntp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Only update the size in the case of the data fork, but&n;&t; * always re-log the inode so that our permanent transaction&n;&t; * can keep on rolling it forward in the log.&n;&t; */
r_if
c_cond
(paren
id|fork
op_eq
id|XFS_DATA_FORK
)paren
(brace
id|xfs_isize_check
c_func
(paren
id|mp
comma
id|ip
comma
id|new_size
)paren
suffix:semicolon
id|ip-&gt;i_d.di_size
op_assign
id|new_size
suffix:semicolon
)brace
id|xfs_trans_log_inode
c_func
(paren
id|ntp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|new_size
op_ne
l_int|0
)paren
op_logical_or
(paren
id|fork
op_eq
id|XFS_ATTR_FORK
)paren
op_logical_or
(paren
id|ip-&gt;i_delayed_blks
op_eq
l_int|0
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|new_size
op_ne
l_int|0
)paren
op_logical_or
(paren
id|fork
op_eq
id|XFS_ATTR_FORK
)paren
op_logical_or
(paren
id|ip-&gt;i_d.di_nextents
op_eq
l_int|0
)paren
)paren
suffix:semicolon
id|xfs_itrunc_trace
c_func
(paren
id|XFS_ITRUNC_FINISH2
comma
id|ip
comma
l_int|0
comma
id|new_size
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_igrow_start&n; *&n; * Do the first part of growing a file: zero any data in the last&n; * block that is beyond the old EOF.  We need to do this before&n; * the inode is joined to the transaction to modify the i_size.&n; * That way we can drop the inode lock and call into the buffer&n; * cache to get the buffer mapping the EOF.&n; */
r_int
DECL|function|xfs_igrow_start
id|xfs_igrow_start
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_fsize_t
id|new_size
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_fsize_t
id|isize
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|ip-&gt;i_lock
)paren
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|ip-&gt;i_iolock
)paren
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|new_size
OG
id|ip-&gt;i_d.di_size
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|isize
op_assign
id|ip-&gt;i_d.di_size
suffix:semicolon
multiline_comment|/*&n;&t; * Zero any pages that may have been created by&n;&t; * xfs_write_file() beyond the end of the file&n;&t; * and any blocks between the old and new file sizes.&n;&t; */
id|error
op_assign
id|xfs_zero_eof
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
comma
op_amp
id|ip-&gt;i_iocore
comma
id|new_size
comma
id|isize
comma
id|new_size
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_igrow_finish&n; *&n; * This routine is called to extend the size of a file.&n; * The inode must have both the iolock and the ilock locked&n; * for update and it must be a part of the current transaction.&n; * The xfs_igrow_start() function must have been called previously.&n; * If the change_flag is not zero, the inode change timestamp will&n; * be updated.&n; */
r_void
DECL|function|xfs_igrow_finish
id|xfs_igrow_finish
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_fsize_t
id|new_size
comma
r_int
id|change_flag
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|ip-&gt;i_lock
)paren
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|ip-&gt;i_iolock
)paren
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_transp
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|new_size
OG
id|ip-&gt;i_d.di_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the file size.  Update the inode change timestamp&n;&t; * if change_flag set.&n;&t; */
id|ip-&gt;i_d.di_size
op_assign
id|new_size
suffix:semicolon
r_if
c_cond
(paren
id|change_flag
)paren
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when the inode&squot;s link count goes to 0.&n; * We place the on-disk inode on a list in the AGI.  It&n; * will be pulled from this list when the inode is freed.&n; */
r_int
DECL|function|xfs_iunlink
id|xfs_iunlink
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_buf_t
op_star
id|agibp
suffix:semicolon
id|xfs_buf_t
op_star
id|ibp
suffix:semicolon
id|xfs_agnumber_t
id|agno
suffix:semicolon
id|xfs_daddr_t
id|agdaddr
suffix:semicolon
id|xfs_agino_t
id|agino
suffix:semicolon
r_int
id|bucket_index
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|agi_ok
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_mode
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_transp
op_eq
id|tp
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|agno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|agdaddr
op_assign
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the agi buffer first.  It ensures lock ordering&n;&t; * on the list.&n;&t; */
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|agdaddr
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
comma
op_amp
id|agibp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Validate the magic number of the agi block.&n;&t; */
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agibp
)paren
suffix:semicolon
id|agi_ok
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
op_logical_and
id|XFS_AGI_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_versionnum
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|agi_ok
comma
id|mp
comma
id|XFS_ERRTAG_IUNLINK
comma
id|XFS_RANDOM_IUNLINK
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iunlink&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|agi
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agibp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the index into the agi hash table for the&n;&t; * list this inode will go on.&n;&t; */
id|agino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agino
op_ne
l_int|0
)paren
suffix:semicolon
id|bucket_index
op_assign
id|agino
op_mod
id|XFS_AGI_UNLINKED_BUCKETS
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|agino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGINO
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is already another inode in the bucket we need&n;&t;&t; * to add ourselves to.  Add us at the front of the list.&n;&t;&t; * Here we put the head pointer into our next pointer,&n;&t;&t; * and then we fall through to point the head at us.&n;&t;&t; */
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|ibp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGINO
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/* both on-disk, don&squot;t endian flip twice */
id|dip-&gt;di_next_unlinked
op_assign
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
suffix:semicolon
id|offset
op_assign
id|ip-&gt;i_boffset
op_plus
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_next_unlinked
)paren
suffix:semicolon
id|xfs_trans_inode_buf
c_func
(paren
id|tp
comma
id|ibp
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|ibp
comma
id|offset
comma
(paren
id|offset
op_plus
r_sizeof
(paren
id|xfs_agino_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|xfs_inobp_check
c_func
(paren
id|mp
comma
id|ibp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Point the bucket head pointer at the inode being inserted.&n;&t; */
id|ASSERT
c_func
(paren
id|agino
op_ne
l_int|0
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
comma
id|agino
)paren
suffix:semicolon
id|offset
op_assign
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_unlinked
)paren
op_plus
(paren
r_sizeof
(paren
id|xfs_agino_t
)paren
op_star
id|bucket_index
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|agibp
comma
id|offset
comma
(paren
id|offset
op_plus
r_sizeof
(paren
id|xfs_agino_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Pull the on-disk inode from the AGI unlinked list.&n; */
id|STATIC
r_int
DECL|function|xfs_iunlink_remove
id|xfs_iunlink_remove
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_ino_t
id|next_ino
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_buf_t
op_star
id|agibp
suffix:semicolon
id|xfs_buf_t
op_star
id|ibp
suffix:semicolon
id|xfs_agnumber_t
id|agno
suffix:semicolon
id|xfs_daddr_t
id|agdaddr
suffix:semicolon
id|xfs_agino_t
id|agino
suffix:semicolon
id|xfs_agino_t
id|next_agino
suffix:semicolon
id|xfs_buf_t
op_star
id|last_ibp
suffix:semicolon
id|xfs_dinode_t
op_star
id|last_dip
suffix:semicolon
r_int
id|bucket_index
suffix:semicolon
r_int
id|offset
comma
id|last_offset
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|agi_ok
suffix:semicolon
multiline_comment|/*&n;&t; * First pull the on-disk inode from the AGI unlinked list.&n;&t; */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|agno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|agdaddr
op_assign
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the agi buffer first.  It ensures lock ordering&n;&t; * on the list.&n;&t; */
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|agdaddr
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
comma
op_amp
id|agibp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_iunlink_remove: xfs_trans_read_buf()  returned an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Validate the magic number of the agi block.&n;&t; */
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agibp
)paren
suffix:semicolon
id|agi_ok
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
op_logical_and
id|XFS_AGI_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_versionnum
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|agi_ok
comma
id|mp
comma
id|XFS_ERRTAG_IUNLINK_REMOVE
comma
id|XFS_RANDOM_IUNLINK_REMOVE
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_iunlink_remove&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|agi
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agibp
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_iunlink_remove: XFS_TEST_ERROR()  returned an error on %s.  Returning EFSCORRUPTED.&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the index into the agi hash table for the&n;&t; * list this inode will go on.&n;&t; */
id|agino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agino
op_ne
l_int|0
)paren
suffix:semicolon
id|bucket_index
op_assign
id|agino
op_mod
id|XFS_AGI_UNLINKED_BUCKETS
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGINO
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|agino
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re at the head of the list.  Get the inode&squot;s&n;&t;&t; * on-disk buffer to see if there is anyone after us&n;&t;&t; * on the list.  Only modify our next pointer if it&n;&t;&t; * is not already NULLAGINO.  This saves us the overhead&n;&t;&t; * of dealing with the buffer when there is no need to&n;&t;&t; * change it.&n;&t;&t; */
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|ibp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_iunlink_remove: xfs_itobp()  returned an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|next_agino
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|next_agino
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_agino
op_ne
id|NULLAGINO
)paren
(brace
id|INT_SET
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
comma
id|NULLAGINO
)paren
suffix:semicolon
id|offset
op_assign
id|ip-&gt;i_boffset
op_plus
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_next_unlinked
)paren
suffix:semicolon
id|xfs_trans_inode_buf
c_func
(paren
id|tp
comma
id|ibp
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|ibp
comma
id|offset
comma
(paren
id|offset
op_plus
r_sizeof
(paren
id|xfs_agino_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|xfs_inobp_check
c_func
(paren
id|mp
comma
id|ibp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|ibp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Point the bucket head pointer at the next inode.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|next_agino
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|next_agino
op_ne
id|agino
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
comma
id|next_agino
)paren
suffix:semicolon
id|offset
op_assign
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_unlinked
)paren
op_plus
(paren
r_sizeof
(paren
id|xfs_agino_t
)paren
op_star
id|bucket_index
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|agibp
comma
id|offset
comma
(paren
id|offset
op_plus
r_sizeof
(paren
id|xfs_agino_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We need to search the list for the inode being freed.&n;&t;&t; */
id|next_agino
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket_index
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|last_ibp
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|next_agino
op_ne
id|agino
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If the last inode wasn&squot;t the one pointing to&n;&t;&t;&t; * us, then release its buffer since we&squot;re not&n;&t;&t;&t; * going to do anything with it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|last_ibp
op_ne
l_int|NULL
)paren
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|last_ibp
)paren
suffix:semicolon
)brace
id|next_ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|next_agino
)paren
suffix:semicolon
id|error
op_assign
id|xfs_inotobp
c_func
(paren
id|mp
comma
id|tp
comma
id|next_ino
comma
op_amp
id|last_dip
comma
op_amp
id|last_ibp
comma
op_amp
id|last_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_iunlink_remove: xfs_inotobp()  returned an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|next_agino
op_assign
id|INT_GET
c_func
(paren
id|last_dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|next_agino
op_ne
id|NULLAGINO
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|next_agino
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now last_ibp points to the buffer previous to us on&n;&t;&t; * the unlinked list.  Pull us from the list.&n;&t;&t; */
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
id|tp
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|ibp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_iunlink_remove: xfs_itobp()  returned an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|next_agino
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|next_agino
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|next_agino
op_ne
id|agino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next_agino
op_ne
id|NULLAGINO
)paren
(brace
id|INT_SET
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
comma
id|NULLAGINO
)paren
suffix:semicolon
id|offset
op_assign
id|ip-&gt;i_boffset
op_plus
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_next_unlinked
)paren
suffix:semicolon
id|xfs_trans_inode_buf
c_func
(paren
id|tp
comma
id|ibp
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|ibp
comma
id|offset
comma
(paren
id|offset
op_plus
r_sizeof
(paren
id|xfs_agino_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|xfs_inobp_check
c_func
(paren
id|mp
comma
id|ibp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|ibp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Point the previous inode on the list to the next inode.&n;&t;&t; */
id|INT_SET
c_func
(paren
id|last_dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
comma
id|next_agino
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|next_agino
op_ne
l_int|0
)paren
suffix:semicolon
id|offset
op_assign
id|last_offset
op_plus
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_next_unlinked
)paren
suffix:semicolon
id|xfs_trans_inode_buf
c_func
(paren
id|tp
comma
id|last_ibp
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|last_ibp
comma
id|offset
comma
(paren
id|offset
op_plus
r_sizeof
(paren
id|xfs_agino_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|xfs_inobp_check
c_func
(paren
id|mp
comma
id|last_ibp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to return an inode to the inode free list.&n; * The inode should already be truncated to 0 length and have&n; * no pages associated with it.  This routine also assumes that&n; * the inode is already a part of the transaction.&n; *&n; * The on-disk copy of the inode will have been added to the list&n; * of unlinked inodes in the AGI. We need to remove the inode from&n; * that list atomically with respect to freeing it here.&n; */
r_int
DECL|function|xfs_ifree
id|xfs_ifree
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_transp
op_eq
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nextents
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_d.di_size
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_ne
id|IFREG
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nblocks
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull the on-disk inode from the AGI unlinked list.&n;&t; */
id|error
op_assign
id|xfs_iunlink_remove
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
id|xfs_difree
c_func
(paren
id|tp
comma
id|ip-&gt;i_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ip-&gt;i_d.di_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* mark incore inode as free */
id|ip-&gt;i_d.di_flags
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_dmevmask
op_assign
l_int|0
suffix:semicolon
id|ip-&gt;i_d.di_forkoff
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* mark the attr fork not in use */
id|ip-&gt;i_df.if_ext_max
op_assign
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|ip-&gt;i_d.di_format
op_assign
id|XFS_DINODE_FMT_EXTENTS
suffix:semicolon
id|ip-&gt;i_d.di_aformat
op_assign
id|XFS_DINODE_FMT_EXTENTS
suffix:semicolon
multiline_comment|/*&n;&t; * Bump the generation count so no one will be confused&n;&t; * by reincarnations of this inode.&n;&t; */
id|ip-&gt;i_d.di_gen
op_increment
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reallocate the space for if_broot based on the number of records&n; * being added or deleted as indicated in rec_diff.  Move the records&n; * and pointers in if_broot to fit the new size.  When shrinking this&n; * will eliminate holes between the records and pointers created by&n; * the caller.  When growing this will create holes to be filled in&n; * by the caller.&n; *&n; * The caller must not request to add more records than would fit in&n; * the on-disk inode root.  If the if_broot is currently NULL, then&n; * if we adding records one will be allocated.  The caller must also&n; * not request that the number of records go below zero, although&n; * it can go to zero.&n; *&n; * ip -- the inode whose if_broot area is changing&n; * ext_diff -- the change in the number of records, positive or negative,&n; *&t; requested for the if_broot array.&n; */
r_void
DECL|function|xfs_iroot_realloc
id|xfs_iroot_realloc
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|rec_diff
comma
r_int
id|whichfork
)paren
(brace
r_int
id|cur_max
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
id|xfs_bmbt_block_t
op_star
id|new_broot
suffix:semicolon
r_int
id|new_max
suffix:semicolon
r_int
id|new_size
suffix:semicolon
r_char
op_star
id|np
suffix:semicolon
r_char
op_star
id|op
suffix:semicolon
multiline_comment|/*&n;&t; * Handle the degenerate case quietly.&n;&t; */
r_if
c_cond
(paren
id|rec_diff
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rec_diff
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * If there wasn&squot;t any memory allocated before, just&n;&t;&t; * allocate it now and get out.&n;&t;&t; */
r_if
c_cond
(paren
id|ifp-&gt;if_broot_bytes
op_eq
l_int|0
)paren
(brace
id|new_size
op_assign
(paren
r_int
)paren
id|XFS_BMAP_BROOT_SPACE_CALC
c_func
(paren
id|rec_diff
)paren
suffix:semicolon
id|ifp-&gt;if_broot
op_assign
(paren
id|xfs_bmbt_block_t
op_star
)paren
id|kmem_alloc
c_func
(paren
id|new_size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ifp-&gt;if_broot_bytes
op_assign
(paren
r_int
)paren
id|new_size
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If there is already an existing if_broot, then we need&n;&t;&t; * to realloc() it and shift the pointers to their new&n;&t;&t; * location.  The records don&squot;t change location because&n;&t;&t; * they are kept butted up against the btree block header.&n;&t;&t; */
id|cur_max
op_assign
id|XFS_BMAP_BROOT_MAXRECS
c_func
(paren
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|new_max
op_assign
id|cur_max
op_plus
id|rec_diff
suffix:semicolon
id|new_size
op_assign
(paren
r_int
)paren
id|XFS_BMAP_BROOT_SPACE_CALC
c_func
(paren
id|new_max
)paren
suffix:semicolon
id|ifp-&gt;if_broot
op_assign
(paren
id|xfs_bmbt_block_t
op_star
)paren
id|kmem_realloc
c_func
(paren
id|ifp-&gt;if_broot
comma
id|new_size
comma
(paren
r_int
)paren
id|XFS_BMAP_BROOT_SPACE_CALC
c_func
(paren
id|cur_max
)paren
comma
multiline_comment|/* old size */
id|KM_SLEEP
)paren
suffix:semicolon
id|op
op_assign
(paren
r_char
op_star
)paren
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|ifp-&gt;if_broot
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|np
op_assign
(paren
r_char
op_star
)paren
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|ifp-&gt;if_broot
comma
l_int|1
comma
(paren
r_int
)paren
id|new_size
)paren
suffix:semicolon
id|ifp-&gt;if_broot_bytes
op_assign
(paren
r_int
)paren
id|new_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_broot_bytes
op_le
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_plus
id|XFS_BROOT_SIZE_ADJ
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|np
comma
id|op
comma
id|cur_max
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dfsbno_t
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * rec_diff is less than 0.  In this case, we are shrinking the&n;&t; * if_broot buffer.  It must already exist.  If we go to zero&n;&t; * records, just get rid of the root and clear the status bit.&n;&t; */
id|ASSERT
c_func
(paren
(paren
id|ifp-&gt;if_broot
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ifp-&gt;if_broot_bytes
OG
l_int|0
)paren
)paren
suffix:semicolon
id|cur_max
op_assign
id|XFS_BMAP_BROOT_MAXRECS
c_func
(paren
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|new_max
op_assign
id|cur_max
op_plus
id|rec_diff
suffix:semicolon
id|ASSERT
c_func
(paren
id|new_max
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_max
OG
l_int|0
)paren
id|new_size
op_assign
(paren
r_int
)paren
id|XFS_BMAP_BROOT_SPACE_CALC
c_func
(paren
id|new_max
)paren
suffix:semicolon
r_else
id|new_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|new_size
OG
l_int|0
)paren
(brace
id|new_broot
op_assign
(paren
id|xfs_bmbt_block_t
op_star
)paren
id|kmem_alloc
c_func
(paren
id|new_size
comma
id|KM_SLEEP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * First copy over the btree block header.&n;&t;&t; */
id|memcpy
c_func
(paren
id|new_broot
comma
id|ifp-&gt;if_broot
comma
r_sizeof
(paren
id|xfs_bmbt_block_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|new_broot
op_assign
l_int|NULL
suffix:semicolon
id|ifp-&gt;if_flags
op_and_assign
op_complement
id|XFS_IFBROOT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Only copy the records and pointers if there are any.&n;&t; */
r_if
c_cond
(paren
id|new_max
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * First copy the records.&n;&t;&t; */
id|op
op_assign
(paren
r_char
op_star
)paren
id|XFS_BMAP_BROOT_REC_ADDR
c_func
(paren
id|ifp-&gt;if_broot
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|np
op_assign
(paren
r_char
op_star
)paren
id|XFS_BMAP_BROOT_REC_ADDR
c_func
(paren
id|new_broot
comma
l_int|1
comma
(paren
r_int
)paren
id|new_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|np
comma
id|op
comma
id|new_max
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Then copy the pointers.&n;&t;&t; */
id|op
op_assign
(paren
r_char
op_star
)paren
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|ifp-&gt;if_broot
comma
l_int|1
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|np
op_assign
(paren
r_char
op_star
)paren
id|XFS_BMAP_BROOT_PTR_ADDR
c_func
(paren
id|new_broot
comma
l_int|1
comma
(paren
r_int
)paren
id|new_size
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|np
comma
id|op
comma
id|new_max
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dfsbno_t
)paren
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|ifp-&gt;if_broot
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|ifp-&gt;if_broot
op_assign
id|new_broot
suffix:semicolon
id|ifp-&gt;if_broot_bytes
op_assign
(paren
r_int
)paren
id|new_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_broot_bytes
op_le
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_plus
id|XFS_BROOT_SIZE_ADJ
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when the amount of space needed for if_extents&n; * is increased or decreased.  The change in size is indicated by&n; * the number of extents that need to be added or deleted in the&n; * ext_diff parameter.&n; *&n; * If the amount of space needed has decreased below the size of the&n; * inline buffer, then switch to using the inline buffer.  Otherwise,&n; * use kmem_realloc() or kmem_alloc() to adjust the size of the buffer&n; * to what is needed.&n; *&n; * ip -- the inode whose if_extents area is changing&n; * ext_diff -- the change in the number of extents, positive or negative,&n; *&t; requested for the if_extents array.&n; */
r_void
DECL|function|xfs_iext_realloc
id|xfs_iext_realloc
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|ext_diff
comma
r_int
id|whichfork
)paren
(brace
r_int
id|byte_diff
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
r_int
id|new_size
suffix:semicolon
id|uint
id|rnew_size
suffix:semicolon
r_if
c_cond
(paren
id|ext_diff
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|byte_diff
op_assign
id|ext_diff
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|new_size
op_assign
(paren
r_int
)paren
id|ifp-&gt;if_bytes
op_plus
id|byte_diff
suffix:semicolon
id|ASSERT
c_func
(paren
id|new_size
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_size
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_extents
op_ne
id|ifp-&gt;if_u2.if_inline_ext
)paren
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_real_bytes
op_ne
l_int|0
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|ifp-&gt;if_real_bytes
)paren
suffix:semicolon
)brace
id|ifp-&gt;if_u1.if_extents
op_assign
l_int|NULL
suffix:semicolon
id|rnew_size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|new_size
op_le
r_sizeof
(paren
id|ifp-&gt;if_u2.if_inline_ext
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the valid extents can fit in if_inline_ext,&n;&t;&t; * copy them from the malloc&squot;d vector and free it.&n;&t;&t; */
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_extents
op_ne
id|ifp-&gt;if_u2.if_inline_ext
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For now, empty files are format EXTENTS,&n;&t;&t;&t; * so the if_extents pointer is null.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_extents
)paren
(brace
id|memcpy
c_func
(paren
id|ifp-&gt;if_u2.if_inline_ext
comma
id|ifp-&gt;if_u1.if_extents
comma
id|new_size
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|ifp-&gt;if_real_bytes
)paren
suffix:semicolon
)brace
id|ifp-&gt;if_u1.if_extents
op_assign
id|ifp-&gt;if_u2.if_inline_ext
suffix:semicolon
)brace
id|rnew_size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rnew_size
op_assign
id|new_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rnew_size
op_amp
(paren
id|rnew_size
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
id|rnew_size
op_assign
id|xfs_iroundup
c_func
(paren
id|rnew_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Stuck with malloc/realloc.&n;&t;&t; */
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_extents
op_eq
id|ifp-&gt;if_u2.if_inline_ext
)paren
(brace
id|ifp-&gt;if_u1.if_extents
op_assign
(paren
id|xfs_bmbt_rec_t
op_star
)paren
id|kmem_alloc
c_func
(paren
id|rnew_size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|ifp-&gt;if_u2.if_inline_ext
comma
r_sizeof
(paren
id|ifp-&gt;if_u2.if_inline_ext
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rnew_size
op_ne
id|ifp-&gt;if_real_bytes
)paren
(brace
id|ifp-&gt;if_u1.if_extents
op_assign
(paren
id|xfs_bmbt_rec_t
op_star
)paren
id|kmem_realloc
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|rnew_size
comma
id|ifp-&gt;if_real_bytes
comma
id|KM_NOFS
)paren
suffix:semicolon
)brace
)brace
id|ifp-&gt;if_real_bytes
op_assign
id|rnew_size
suffix:semicolon
id|ifp-&gt;if_bytes
op_assign
id|new_size
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when the amount of space needed for if_data&n; * is increased or decreased.  The change in size is indicated by&n; * the number of bytes that need to be added or deleted in the&n; * byte_diff parameter.&n; *&n; * If the amount of space needed has decreased below the size of the&n; * inline buffer, then switch to using the inline buffer.  Otherwise,&n; * use kmem_realloc() or kmem_alloc() to adjust the size of the buffer&n; * to what is needed.&n; *&n; * ip -- the inode whose if_data area is changing&n; * byte_diff -- the change in the number of bytes, positive or negative,&n; *&t; requested for the if_data array.&n; */
r_void
DECL|function|xfs_idata_realloc
id|xfs_idata_realloc
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|byte_diff
comma
r_int
id|whichfork
)paren
(brace
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
r_int
id|new_size
suffix:semicolon
r_int
id|real_size
suffix:semicolon
r_if
c_cond
(paren
id|byte_diff
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|new_size
op_assign
(paren
r_int
)paren
id|ifp-&gt;if_bytes
op_plus
id|byte_diff
suffix:semicolon
id|ASSERT
c_func
(paren
id|new_size
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_size
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_data
op_ne
id|ifp-&gt;if_u2.if_inline_data
)paren
(brace
id|kmem_free
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|ifp-&gt;if_real_bytes
)paren
suffix:semicolon
)brace
id|ifp-&gt;if_u1.if_data
op_assign
l_int|NULL
suffix:semicolon
id|real_size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|new_size
op_le
r_sizeof
(paren
id|ifp-&gt;if_u2.if_inline_data
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the valid extents/data can fit in if_inline_ext/data,&n;&t;&t; * copy them from the malloc&squot;d vector and free it.&n;&t;&t; */
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_data
op_eq
l_int|NULL
)paren
(brace
id|ifp-&gt;if_u1.if_data
op_assign
id|ifp-&gt;if_u2.if_inline_data
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_data
op_ne
id|ifp-&gt;if_u2.if_inline_data
)paren
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_real_bytes
op_ne
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ifp-&gt;if_u2.if_inline_data
comma
id|ifp-&gt;if_u1.if_data
comma
id|new_size
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|ifp-&gt;if_real_bytes
)paren
suffix:semicolon
id|ifp-&gt;if_u1.if_data
op_assign
id|ifp-&gt;if_u2.if_inline_data
suffix:semicolon
)brace
id|real_size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Stuck with malloc/realloc.&n;&t;&t; * For inline data, the underlying buffer must be&n;&t;&t; * a multiple of 4 bytes in size so that it can be&n;&t;&t; * logged and stay on word boundaries.  We enforce&n;&t;&t; * that here.&n;&t;&t; */
id|real_size
op_assign
id|roundup
c_func
(paren
id|new_size
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_data
op_eq
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_real_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|ifp-&gt;if_u1.if_data
op_assign
id|kmem_alloc
c_func
(paren
id|real_size
comma
id|KM_SLEEP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ifp-&gt;if_u1.if_data
op_ne
id|ifp-&gt;if_u2.if_inline_data
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Only do the realloc if the underlying size&n;&t;&t;&t; * is really changing.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ifp-&gt;if_real_bytes
op_ne
id|real_size
)paren
(brace
id|ifp-&gt;if_u1.if_data
op_assign
id|kmem_realloc
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|real_size
comma
id|ifp-&gt;if_real_bytes
comma
id|KM_SLEEP
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_real_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|ifp-&gt;if_u1.if_data
op_assign
id|kmem_alloc
c_func
(paren
id|real_size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|ifp-&gt;if_u2.if_inline_data
comma
id|ifp-&gt;if_bytes
)paren
suffix:semicolon
)brace
)brace
id|ifp-&gt;if_real_bytes
op_assign
id|real_size
suffix:semicolon
id|ifp-&gt;if_bytes
op_assign
id|new_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_bytes
op_le
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map inode to disk block and offset.&n; *&n; * mp -- the mount point structure for the current file system&n; * tp -- the current transaction&n; * ino -- the inode number of the inode to be located&n; * imap -- this structure is filled in with the information necessary&n; *&t; to retrieve the given inode from disk&n; * flags -- flags to pass to xfs_dilocate indicating whether or not&n; *&t; lookups in the inode btree were OK or not&n; */
r_int
DECL|function|xfs_imap
id|xfs_imap
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_ino_t
id|ino
comma
id|xfs_imap_t
op_star
id|imap
comma
id|uint
id|flags
)paren
(brace
id|xfs_fsblock_t
id|fsbno
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|off
suffix:semicolon
r_int
id|error
suffix:semicolon
id|fsbno
op_assign
id|imap-&gt;im_blkno
ques
c_cond
id|XFS_DADDR_TO_FSB
c_func
(paren
id|mp
comma
id|imap-&gt;im_blkno
)paren
suffix:colon
id|NULLFSBLOCK
suffix:semicolon
id|error
op_assign
id|xfs_dilocate
c_func
(paren
id|mp
comma
id|tp
comma
id|ino
comma
op_amp
id|fsbno
comma
op_amp
id|len
comma
op_amp
id|off
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|imap-&gt;im_blkno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|fsbno
)paren
suffix:semicolon
id|imap-&gt;im_len
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|len
)paren
suffix:semicolon
id|imap-&gt;im_agblkno
op_assign
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|fsbno
)paren
suffix:semicolon
id|imap-&gt;im_ioffset
op_assign
(paren
id|ushort
)paren
id|off
suffix:semicolon
id|imap-&gt;im_boffset
op_assign
(paren
id|ushort
)paren
(paren
id|off
op_lshift
id|mp-&gt;m_sb.sb_inodelog
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xfs_idestroy_fork
id|xfs_idestroy_fork
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|whichfork
)paren
(brace
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ifp-&gt;if_broot
op_ne
l_int|NULL
)paren
(brace
id|kmem_free
c_func
(paren
id|ifp-&gt;if_broot
comma
id|ifp-&gt;if_broot_bytes
)paren
suffix:semicolon
id|ifp-&gt;if_broot
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the format is local, then we can&squot;t have an extents&n;&t; * array so just look for an inline data array.  If we&squot;re&n;&t; * not local then we may or may not have an extents list,&n;&t; * so check and free it up if we do.&n;&t; */
r_if
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
r_if
c_cond
(paren
(paren
id|ifp-&gt;if_u1.if_data
op_ne
id|ifp-&gt;if_u2.if_inline_data
)paren
op_logical_and
(paren
id|ifp-&gt;if_u1.if_data
op_ne
l_int|NULL
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_real_bytes
op_ne
l_int|0
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|ifp-&gt;if_real_bytes
)paren
suffix:semicolon
id|ifp-&gt;if_u1.if_data
op_assign
l_int|NULL
suffix:semicolon
id|ifp-&gt;if_real_bytes
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_and
(paren
id|ifp-&gt;if_u1.if_extents
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ifp-&gt;if_u1.if_extents
op_ne
id|ifp-&gt;if_u2.if_inline_ext
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_real_bytes
op_ne
l_int|0
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ifp-&gt;if_u1.if_extents
comma
id|ifp-&gt;if_real_bytes
)paren
suffix:semicolon
id|ifp-&gt;if_u1.if_extents
op_assign
l_int|NULL
suffix:semicolon
id|ifp-&gt;if_real_bytes
op_assign
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_u1.if_extents
op_eq
l_int|NULL
op_logical_or
id|ifp-&gt;if_u1.if_extents
op_eq
id|ifp-&gt;if_u2.if_inline_ext
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_real_bytes
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_ATTR_FORK
)paren
(brace
id|kmem_zone_free
c_func
(paren
id|xfs_ifork_zone
comma
id|ip-&gt;i_afp
)paren
suffix:semicolon
id|ip-&gt;i_afp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called free all the memory associated with an inode.&n; * It must free the inode itself and any buffers allocated for&n; * if_extents/if_data and if_broot.  It must also free the lock&n; * associated with the inode.&n; */
r_void
DECL|function|xfs_idestroy
id|xfs_idestroy
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
(brace
r_case
id|IFREG
suffix:colon
r_case
id|IFDIR
suffix:colon
r_case
id|IFLNK
suffix:colon
id|xfs_idestroy_fork
c_func
(paren
id|ip
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_afp
)paren
id|xfs_idestroy_fork
c_func
(paren
id|ip
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
macro_line|#ifdef NOTYET
r_if
c_cond
(paren
id|ip-&gt;i_range_lock.r_sleep
op_ne
l_int|NULL
)paren
(brace
id|freesema
c_func
(paren
id|ip-&gt;i_range_lock.r_sleep
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ip-&gt;i_range_lock.r_sleep
comma
r_sizeof
(paren
id|sema_t
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* NOTYET */
id|mrfree
c_func
(paren
op_amp
id|ip-&gt;i_lock
)paren
suffix:semicolon
id|mrfree
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
macro_line|#ifdef NOTYET
id|mutex_destroy
c_func
(paren
op_amp
id|ip-&gt;i_range_lock.r_spinlock
)paren
suffix:semicolon
macro_line|#endif /* NOTYET */
id|freesema
c_func
(paren
op_amp
id|ip-&gt;i_flock
)paren
suffix:semicolon
macro_line|#ifdef XFS_BMAP_TRACE
id|ktrace_free
c_func
(paren
id|ip-&gt;i_xtrace
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMBT_TRACE
id|ktrace_free
c_func
(paren
id|ip-&gt;i_btrace
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_RW_TRACE
id|ktrace_free
c_func
(paren
id|ip-&gt;i_rwtrace
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_STRAT_TRACE
id|ktrace_free
c_func
(paren
id|ip-&gt;i_strat_trace
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_ILOCK_TRACE
id|ktrace_free
c_func
(paren
id|ip-&gt;i_lock_trace
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DIR2_TRACE
id|ktrace_free
c_func
(paren
id|ip-&gt;i_dir_trace
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ip-&gt;i_itemp
)paren
(brace
multiline_comment|/* XXXdpd should be able to assert this but shutdown&n;&t;&t; * is leaving the AIL behind. */
id|ASSERT
c_func
(paren
(paren
(paren
id|ip-&gt;i_itemp-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
op_eq
l_int|0
)paren
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
suffix:semicolon
id|xfs_inode_item_destroy
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
id|kmem_zone_free
c_func
(paren
id|xfs_inode_zone
comma
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Increment the pin count of the given buffer.&n; * This value is protected by ipinlock spinlock in the mount structure.&n; */
r_void
DECL|function|xfs_ipin
id|xfs_ipin
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|ip-&gt;i_pincount
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement the pin count of the given inode, and wake up&n; * anyone in xfs_iwait_unpin() if the count goes to 0.  The&n; * inode must have been previoulsy pinned with a call to xfs_ipin().&n; */
r_void
DECL|function|xfs_iunpin
id|xfs_iunpin
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|ASSERT
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|ip-&gt;i_pincount
)paren
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|ip-&gt;i_pincount
)paren
)paren
(brace
id|vnode_t
op_star
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/* make sync come back and flush this inode */
r_if
c_cond
(paren
id|vp
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode-&gt;i_state
op_amp
id|I_NEW
)paren
)paren
id|mark_inode_dirty_sync
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|ip-&gt;i_ipin_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called to wait for the given inode to be unpinned.&n; * It will sleep until this happens.  The caller must have the&n; * inode locked in at least shared mode so that the buffer cannot&n; * be subsequently pinned once someone is waiting for it to be&n; * unpinned.&n; */
r_void
DECL|function|xfs_iunpin_wait
id|xfs_iunpin_wait
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_inode_log_item_t
op_star
id|iip
suffix:semicolon
id|xfs_lsn_t
id|lsn
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
op_or
id|MR_ACCESS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|ip-&gt;i_pincount
)paren
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|iip
op_assign
id|ip-&gt;i_itemp
suffix:semicolon
r_if
c_cond
(paren
id|iip
op_logical_and
id|iip-&gt;ili_last_lsn
)paren
(brace
id|lsn
op_assign
id|iip-&gt;ili_last_lsn
suffix:semicolon
)brace
r_else
(brace
id|lsn
op_assign
(paren
id|xfs_lsn_t
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Give the log a push so we don&squot;t wait here too long.&n;&t; */
id|xfs_log_force
c_func
(paren
id|ip-&gt;i_mount
comma
id|lsn
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|ip-&gt;i_ipin_wait
comma
(paren
id|atomic_read
c_func
(paren
op_amp
id|ip-&gt;i_pincount
)paren
op_eq
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_iextents_copy()&n; *&n; * This is called to copy the REAL extents (as opposed to the delayed&n; * allocation extents) from the inode into the given buffer.  It&n; * returns the number of bytes copied into the buffer.&n; *&n; * If there are no delayed allocation extents, then we can just&n; * memcpy() the extents into the buffer.  Otherwise, we need to&n; * examine each extent in turn and skip those which are delayed.&n; */
r_int
DECL|function|xfs_iextents_copy
id|xfs_iextents_copy
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_bmbt_rec_t
op_star
id|buffer
comma
r_int
id|whichfork
)paren
(brace
r_int
id|copied
suffix:semicolon
id|xfs_bmbt_rec_t
op_star
id|dest_ep
suffix:semicolon
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
macro_line|#ifdef XFS_BMAP_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_iextents_copy&quot;
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
r_int
id|nrecs
suffix:semicolon
id|xfs_fsblock_t
id|start_block
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
op_or
id|MR_ACCESS
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_bytes
OG
l_int|0
)paren
suffix:semicolon
id|nrecs
op_assign
id|ifp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|xfs_bmap_trace_exlist
c_func
(paren
id|fname
comma
id|ip
comma
id|nrecs
comma
id|whichfork
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nrecs
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There are some delayed allocation extents in the&n;&t; * inode, so copy the extents one at a time and skip&n;&t; * the delayed ones.  There must be at least one&n;&t; * non-delayed extent.&n;&t; */
id|ep
op_assign
id|ifp-&gt;if_u1.if_extents
suffix:semicolon
id|dest_ep
op_assign
id|buffer
suffix:semicolon
id|copied
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nrecs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|start_block
op_assign
id|xfs_bmbt_get_startblock
c_func
(paren
id|ep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ISNULLSTARTBLOCK
c_func
(paren
id|start_block
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It&squot;s a delayed allocation extent, so skip it.&n;&t;&t;&t; */
id|ep
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Translate to on disk format */
id|put_unaligned
c_func
(paren
id|INT_GET
c_func
(paren
id|ep-&gt;l0
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__uint64_t
op_star
)paren
op_amp
id|dest_ep-&gt;l0
)paren
suffix:semicolon
id|put_unaligned
c_func
(paren
id|INT_GET
c_func
(paren
id|ep-&gt;l1
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__uint64_t
op_star
)paren
op_amp
id|dest_ep-&gt;l1
)paren
suffix:semicolon
id|dest_ep
op_increment
suffix:semicolon
id|ep
op_increment
suffix:semicolon
id|copied
op_increment
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|copied
op_ne
l_int|0
)paren
suffix:semicolon
id|xfs_validate_extents
c_func
(paren
id|buffer
comma
id|copied
comma
l_int|1
comma
id|XFS_EXTFMT_INODE
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
r_return
(paren
id|copied
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Each of the following cases stores data into the same region&n; * of the on-disk inode, so only one of them can be valid at&n; * any given time. While it is possible to have conflicting formats&n; * and log flags, e.g. having XFS_ILOG_?DATA set when the fork is&n; * in EXTENTS format, this can only happen when the fork has&n; * changed formats after being modified but before being flushed.&n; * In these cases, the format always takes precedence, because the&n; * format indicates the current state of the fork.&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_int
DECL|function|xfs_iflush_fork
id|xfs_iflush_fork
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dinode_t
op_star
id|dip
comma
id|xfs_inode_log_item_t
op_star
id|iip
comma
r_int
id|whichfork
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
r_char
op_star
id|cp
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
macro_line|#ifdef XFS_TRANS_DEBUG
r_int
id|first
suffix:semicolon
macro_line|#endif
r_static
r_const
r_int
id|brootflag
(braket
l_int|2
)braket
op_assign
(brace
id|XFS_ILOG_DBROOT
comma
id|XFS_ILOG_ABROOT
)brace
suffix:semicolon
r_static
r_const
r_int
id|dataflag
(braket
l_int|2
)braket
op_assign
(brace
id|XFS_ILOG_DDATA
comma
id|XFS_ILOG_ADATA
)brace
suffix:semicolon
r_static
r_const
r_int
id|extflag
(braket
l_int|2
)braket
op_assign
(brace
id|XFS_ILOG_DEXT
comma
id|XFS_ILOG_AEXT
)brace
suffix:semicolon
r_if
c_cond
(paren
id|iip
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can happen if we gave up in iformat in an error path,&n;&t; * for the attribute fork.&n;&t; */
r_if
c_cond
(paren
id|ifp
op_eq
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|whichfork
op_eq
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|cp
op_assign
id|XFS_DFORK_PTR_ARCH
c_func
(paren
id|dip
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_switch
c_cond
(paren
id|XFS_IFORK_FORMAT
c_func
(paren
id|ip
comma
id|whichfork
)paren
)paren
(brace
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|dataflag
(braket
id|whichfork
)braket
)paren
op_logical_and
(paren
id|ifp-&gt;if_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_bytes
op_le
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|cp
comma
id|ifp-&gt;if_u1.if_data
comma
id|ifp-&gt;if_bytes
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_DIR_SHORTFORM_VALIDATE_ONDISK
c_func
(paren
id|mp
comma
id|dip
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_iflush_fork&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|ASSERT
c_func
(paren
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_logical_or
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|extflag
(braket
id|whichfork
)braket
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ifp-&gt;if_u1.if_extents
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|ifp-&gt;if_bytes
op_eq
l_int|0
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ifp-&gt;if_u1.if_extents
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|ifp-&gt;if_bytes
OG
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|extflag
(braket
id|whichfork
)braket
)paren
op_logical_and
(paren
id|ifp-&gt;if_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_IFORK_NEXTENTS
c_func
(paren
id|ip
comma
id|whichfork
)paren
OG
l_int|0
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_iextents_copy
c_func
(paren
id|ip
comma
(paren
id|xfs_bmbt_rec_t
op_star
)paren
id|cp
comma
id|whichfork
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|brootflag
(braket
id|whichfork
)braket
)paren
op_logical_and
(paren
id|ifp-&gt;if_broot_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_broot
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_broot_bytes
op_le
(paren
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
op_plus
id|XFS_BROOT_SIZE_ADJ
)paren
)paren
suffix:semicolon
id|xfs_bmbt_to_bmdr
c_func
(paren
id|ifp-&gt;if_broot
comma
id|ifp-&gt;if_broot_bytes
comma
(paren
id|xfs_bmdr_block_t
op_star
)paren
id|cp
comma
id|XFS_DFORK_SIZE_ARCH
c_func
(paren
id|dip
comma
id|mp
comma
id|whichfork
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_DEV
suffix:colon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DEV
)paren
(brace
id|ASSERT
c_func
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dip-&gt;di_u.di_dev
comma
id|ARCH_CONVERT
comma
id|ip-&gt;i_df.if_u2.if_rdev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_UUID
suffix:colon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_UUID
)paren
(brace
id|ASSERT
c_func
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dip-&gt;di_u.di_muuid
comma
op_amp
id|ip-&gt;i_df.if_u2.if_uuid
comma
r_sizeof
(paren
id|uuid_t
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_iflush() will write a modified inode&squot;s changes out to the&n; * inode&squot;s on disk home.  The caller must have the inode lock held&n; * in at least shared mode and the inode flush semaphore must be&n; * held as well.  The inode lock will still be held upon return from&n; * the call and the caller is free to unlock it.&n; * The inode flush lock will be unlocked when the inode reaches the disk.&n; * The flags indicate how the inode&squot;s buffer should be written out.&n; */
r_int
DECL|function|xfs_iflush
id|xfs_iflush
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|flags
)paren
(brace
id|xfs_inode_log_item_t
op_star
id|iip
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* REFERENCED */
id|xfs_chash_t
op_star
id|ch
suffix:semicolon
id|xfs_inode_t
op_star
id|iq
suffix:semicolon
r_int
id|clcount
suffix:semicolon
multiline_comment|/* count of inodes clustered */
r_int
id|bufwasdelwri
suffix:semicolon
r_enum
(brace
id|INT_DELWRI
op_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
comma
id|INT_ASYNC
op_assign
(paren
l_int|1
op_lshift
l_int|1
)paren
)brace
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_iflush_count
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
op_or
id|MR_ACCESS
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|valusema
c_func
(paren
op_amp
id|ip-&gt;i_flock
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_or
id|ip-&gt;i_d.di_nextents
OG
id|ip-&gt;i_df.if_ext_max
)paren
suffix:semicolon
id|iip
op_assign
id|ip-&gt;i_itemp
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * If the inode isn&squot;t dirty, then just release the inode&n;&t; * flush lock and do nothing.&n;&t; */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|iip
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|iip
op_ne
l_int|NULL
)paren
ques
c_cond
op_logical_neg
(paren
id|iip-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
suffix:colon
l_int|1
)paren
suffix:semicolon
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We can&squot;t flush the inode until it is unpinned, so&n;&t; * wait for it.  We know noone new can pin it, because&n;&t; * we are holding the inode lock shared and you need&n;&t; * to hold it exclusively to pin the inode.&n;&t; */
id|xfs_iunpin_wait
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This may have been unpinned because the filesystem is shutting&n;&t; * down forcibly. If that&squot;s the case we must not write this inode&n;&t; * to disk, because the log record didn&squot;t make it to disk!&n;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|ip-&gt;i_update_core
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iip
)paren
id|iip-&gt;ili_format.ilf_fields
op_assign
l_int|0
suffix:semicolon
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the buffer containing the on-disk inode.&n;&t; */
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|bp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decide how buffer will be flushed out.  This is done before&n;&t; * the call to xfs_iflush_int because this field is zeroed by it.&n;&t; */
r_if
c_cond
(paren
id|iip
op_ne
l_int|NULL
op_logical_and
id|iip-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Flush out the inode buffer according to the directions&n;&t;&t; * of the caller.  In the cases where the caller has given&n;&t;&t; * us a choice choose the non-delwri case.  This is because&n;&t;&t; * the inode is in the AIL and we need to get it out soon.&n;&t;&t; */
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|XFS_IFLUSH_SYNC
suffix:colon
r_case
id|XFS_IFLUSH_DELWRI_ELSE_SYNC
suffix:colon
id|flags
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_IFLUSH_ASYNC
suffix:colon
r_case
id|XFS_IFLUSH_DELWRI_ELSE_ASYNC
suffix:colon
id|flags
op_assign
id|INT_ASYNC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_IFLUSH_DELWRI
suffix:colon
id|flags
op_assign
id|INT_DELWRI
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|XFS_IFLUSH_DELWRI_ELSE_SYNC
suffix:colon
r_case
id|XFS_IFLUSH_DELWRI_ELSE_ASYNC
suffix:colon
r_case
id|XFS_IFLUSH_DELWRI
suffix:colon
id|flags
op_assign
id|INT_DELWRI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_IFLUSH_ASYNC
suffix:colon
id|flags
op_assign
id|INT_ASYNC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_IFLUSH_SYNC
suffix:colon
id|flags
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * First flush out the inode that xfs_iflush was called with.&n;&t; */
id|error
op_assign
id|xfs_iflush_int
c_func
(paren
id|ip
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|corrupt_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * inode clustering:&n;&t; * see if other inodes can be gathered into this write&n;&t; */
id|ip-&gt;i_chash-&gt;chl_buf
op_assign
id|bp
suffix:semicolon
id|ch
op_assign
id|XFS_CHASH
c_func
(paren
id|mp
comma
id|ip-&gt;i_blkno
)paren
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
)paren
suffix:semicolon
id|clcount
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|iq
op_assign
id|ip-&gt;i_cnext
suffix:semicolon
id|iq
op_ne
id|ip
suffix:semicolon
id|iq
op_assign
id|iq-&gt;i_cnext
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do an un-protected check to see if the inode is dirty and&n;&t;&t; * is a candidate for flushing.  These checks will be repeated&n;&t;&t; * later after the appropriate locks are acquired.&n;&t;&t; */
id|iip
op_assign
id|iq-&gt;i_itemp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iq-&gt;i_update_core
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|iip
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
op_logical_and
id|xfs_ipincount
c_func
(paren
id|iq
)paren
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Try to get locks.  If any are unavailable,&n;&t;&t; * then this inode cannot be flushed and is skipped.&n;&t;&t; */
multiline_comment|/* get inode locks (just i_lock) */
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|iq
comma
id|XFS_ILOCK_SHARED
)paren
)paren
(brace
multiline_comment|/* get inode flush lock */
r_if
c_cond
(paren
id|xfs_iflock_nowait
c_func
(paren
id|iq
)paren
)paren
(brace
multiline_comment|/* check if pinned */
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|iq
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* arriving here means that&n;&t;&t;&t;&t;&t; * this inode can be flushed.&n;&t;&t;&t;&t;&t; * first re-check that it&squot;s&n;&t;&t;&t;&t;&t; * dirty&n;&t;&t;&t;&t;&t; */
id|iip
op_assign
id|iq-&gt;i_itemp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iq-&gt;i_update_core
op_ne
l_int|0
)paren
op_logical_or
(paren
(paren
id|iip
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
)paren
(brace
id|clcount
op_increment
suffix:semicolon
id|error
op_assign
id|xfs_iflush_int
c_func
(paren
id|iq
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|iq
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_goto
id|cluster_corrupt_out
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_ifunlock
c_func
(paren
id|iq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_ifunlock
c_func
(paren
id|iq
)paren
suffix:semicolon
)brace
)brace
id|xfs_iunlock
c_func
(paren
id|iq
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
)brace
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clcount
)paren
(brace
id|XFS_STATS_INC
c_func
(paren
id|xs_icluster_flushcnt
)paren
suffix:semicolon
id|XFS_STATS_ADD
c_func
(paren
id|xs_icluster_flushinode
comma
id|clcount
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the buffer is pinned then push on the log so we won&squot;t&n;&t; * get stuck waiting in the write for too long.&n;&t; */
r_if
c_cond
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|INT_DELWRI
)paren
(brace
id|xfs_bdwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|INT_ASYNC
)paren
(brace
id|xfs_bawrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|corrupt_out
suffix:colon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_CORRUPT_INCORE
)paren
suffix:semicolon
id|xfs_iflush_abort
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Unlocks the flush lock&n;&t; */
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
id|cluster_corrupt_out
suffix:colon
multiline_comment|/* Corruption detected in the clustering loop.  Invalidate the&n;&t; * inode buffer and shut down the filesystem.&n;&t; */
id|mutex_spinunlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean up the buffer.  If it was B_DELWRI, just release it --&n;&t; * brelse can handle it with no problems.  If not, shut down the&n;&t; * filesystem before releasing the buffer.&n;&t; */
r_if
c_cond
(paren
(paren
id|bufwasdelwri
op_assign
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_CORRUPT_INCORE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bufwasdelwri
)paren
(brace
multiline_comment|/*&n;&t;&t; * Just like incore_relse: if we have b_iodone functions,&n;&t;&t; * mark the buffer as an error and call them.  Otherwise&n;&t;&t; * mark it as stale and brelse.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
)paren
(brace
id|XFS_BUF_CLR_BDSTRAT_FUNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_UNDONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SHUT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_ERROR
c_func
(paren
id|bp
comma
id|EIO
)paren
suffix:semicolon
id|xfs_biodone
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
id|xfs_iflush_abort
c_func
(paren
id|iq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Unlocks the flush lock&n;&t; */
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_iflush_int
id|xfs_iflush_int
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_inode_log_item_t
op_star
id|iip
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
macro_line|#ifdef XFS_TRANS_DEBUG
r_int
id|first
suffix:semicolon
macro_line|#endif
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
op_or
id|MR_ACCESS
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|valusema
c_func
(paren
op_amp
id|ip-&gt;i_flock
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_BTREE
op_logical_or
id|ip-&gt;i_d.di_nextents
OG
id|ip-&gt;i_df.if_ext_max
)paren
suffix:semicolon
id|iip
op_assign
id|ip-&gt;i_itemp
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * If the inode isn&squot;t dirty, then just release the inode&n;&t; * flush lock and do nothing.&n;&t; */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|iip
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
)paren
(brace
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set *dip = inode&squot;s place in the buffer */
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|ip-&gt;i_boffset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear i_update_core before copying out the data.&n;&t; * This is for coordination with our timestamp updates&n;&t; * that don&squot;t hold the inode lock. They will always&n;&t; * update the timestamps BEFORE setting i_update_core,&n;&t; * so if we clear i_update_core after they set it we&n;&t; * are guaranteed to see their updates to the timestamps.&n;&t; * I believe that this depends on strongly ordered memory&n;&t; * semantics, but we have that.  We use the SYNCHRONIZE&n;&t; * macro to make sure that the compiler does not reorder&n;&t; * the i_update_core access below the data copy below.&n;&t; */
id|ip-&gt;i_update_core
op_assign
l_int|0
suffix:semicolon
id|SYNCHRONIZE
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DINODE_MAGIC
comma
id|mp
comma
id|XFS_ERRTAG_IFLUSH_1
comma
id|XFS_RANDOM_IFLUSH_1
)paren
)paren
(brace
id|xfs_cmn_err
c_func
(paren
id|XFS_PTAG_IFLUSH
comma
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iflush: Bad inode %Lu magic number 0x%x, ptr 0x%p&quot;
comma
id|ip-&gt;i_ino
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
comma
id|dip
)paren
suffix:semicolon
r_goto
id|corrupt_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
id|ip-&gt;i_d.di_magic
op_ne
id|XFS_DINODE_MAGIC
comma
id|mp
comma
id|XFS_ERRTAG_IFLUSH_2
comma
id|XFS_RANDOM_IFLUSH_2
)paren
)paren
(brace
id|xfs_cmn_err
c_func
(paren
id|XFS_PTAG_IFLUSH
comma
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iflush: Bad inode %Lu, ptr 0x%p, magic number 0x%x&quot;
comma
id|ip-&gt;i_ino
comma
id|ip
comma
id|ip-&gt;i_d.di_magic
)paren
suffix:semicolon
r_goto
id|corrupt_out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFREG
)paren
(brace
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
comma
id|mp
comma
id|XFS_ERRTAG_IFLUSH_3
comma
id|XFS_RANDOM_IFLUSH_3
)paren
)paren
(brace
id|xfs_cmn_err
c_func
(paren
id|XFS_PTAG_IFLUSH
comma
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iflush: Bad regular inode %Lu, ptr 0x%p&quot;
comma
id|ip-&gt;i_ino
comma
id|ip
)paren
suffix:semicolon
r_goto
id|corrupt_out
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
(brace
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_format
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
comma
id|mp
comma
id|XFS_ERRTAG_IFLUSH_4
comma
id|XFS_RANDOM_IFLUSH_4
)paren
)paren
(brace
id|xfs_cmn_err
c_func
(paren
id|XFS_PTAG_IFLUSH
comma
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iflush: Bad directory inode %Lu, ptr 0x%p&quot;
comma
id|ip-&gt;i_ino
comma
id|ip
)paren
suffix:semicolon
r_goto
id|corrupt_out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
id|ip-&gt;i_d.di_nextents
op_plus
id|ip-&gt;i_d.di_anextents
OG
id|ip-&gt;i_d.di_nblocks
comma
id|mp
comma
id|XFS_ERRTAG_IFLUSH_5
comma
id|XFS_RANDOM_IFLUSH_5
)paren
)paren
(brace
id|xfs_cmn_err
c_func
(paren
id|XFS_PTAG_IFLUSH
comma
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iflush: detected corrupt incore inode %Lu, total extents = %d, nblocks = %Ld, ptr 0x%p&quot;
comma
id|ip-&gt;i_ino
comma
id|ip-&gt;i_d.di_nextents
op_plus
id|ip-&gt;i_d.di_anextents
comma
id|ip-&gt;i_d.di_nblocks
comma
id|ip
)paren
suffix:semicolon
r_goto
id|corrupt_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
id|ip-&gt;i_d.di_forkoff
OG
id|mp-&gt;m_sb.sb_inodesize
comma
id|mp
comma
id|XFS_ERRTAG_IFLUSH_6
comma
id|XFS_RANDOM_IFLUSH_6
)paren
)paren
(brace
id|xfs_cmn_err
c_func
(paren
id|XFS_PTAG_IFLUSH
comma
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_iflush: bad inode %Lu, forkoff 0x%x, ptr 0x%p&quot;
comma
id|ip-&gt;i_ino
comma
id|ip-&gt;i_d.di_forkoff
comma
id|ip
)paren
suffix:semicolon
r_goto
id|corrupt_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * bump the flush iteration count, used to detect flushes which&n;&t; * postdate a log record during recovery.&n;&t; */
id|ip-&gt;i_d.di_flushiter
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the dirty parts of the inode into the on-disk&n;&t; * inode.  We always copy out the core of the inode,&n;&t; * because if the inode is dirty at all the core must&n;&t; * be.&n;&t; */
id|xfs_xlate_dinode_core
c_func
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|dip-&gt;di_core
)paren
comma
op_amp
(paren
id|ip-&gt;i_d
)paren
comma
op_minus
l_int|1
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* Wrap, we never let the log put out DI_MAX_FLUSH */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_flushiter
op_eq
id|DI_MAX_FLUSH
)paren
id|ip-&gt;i_d.di_flushiter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If this is really an old format inode and the superblock version&n;&t; * has not been updated to support only new format inodes, then&n;&t; * convert back to the old inode format.  If the superblock version&n;&t; * has been updated, then make the conversion permanent.&n;&t; */
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
op_logical_or
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Convert it back.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
op_le
id|XFS_MAXLINK_1
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dip-&gt;di_core.di_onlink
comma
id|ARCH_CONVERT
comma
id|ip-&gt;i_d.di_nlink
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The superblock version has already been bumped,&n;&t;&t;&t; * so just make the conversion to the new inode&n;&t;&t;&t; * format permanent.&n;&t;&t;&t; */
id|ip-&gt;i_d.di_version
op_assign
id|XFS_DINODE_VERSION_2
suffix:semicolon
id|INT_SET
c_func
(paren
id|dip-&gt;di_core.di_version
comma
id|ARCH_CONVERT
comma
id|XFS_DINODE_VERSION_2
)paren
suffix:semicolon
id|ip-&gt;i_d.di_onlink
op_assign
l_int|0
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|dip-&gt;di_core.di_onlink
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|ip-&gt;i_d.di_pad
(braket
l_int|0
)braket
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|ip-&gt;i_d.di_pad
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|dip-&gt;di_core.di_pad
(braket
l_int|0
)braket
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|dip-&gt;di_core.di_pad
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_projid
op_eq
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|xfs_iflush_fork
c_func
(paren
id|ip
comma
id|dip
comma
id|iip
comma
id|XFS_DATA_FORK
comma
id|bp
)paren
op_eq
id|EFSCORRUPTED
)paren
(brace
r_goto
id|corrupt_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The only error from xfs_iflush_fork is on the data fork.&n;&t;&t; */
(paren
r_void
)paren
id|xfs_iflush_fork
c_func
(paren
id|ip
comma
id|dip
comma
id|iip
comma
id|XFS_ATTR_FORK
comma
id|bp
)paren
suffix:semicolon
)brace
id|xfs_inobp_check
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;ve recorded everything logged in the inode, so we&squot;d&n;&t; * like to clear the ilf_fields bits so we don&squot;t log and&n;&t; * flush things unnecessarily.  However, we can&squot;t stop&n;&t; * logging all this information until the data we&squot;ve copied&n;&t; * into the disk buffer is written to disk.  If we did we might&n;&t; * overwrite the copy of the inode in the log with all the&n;&t; * data after re-logging only part of it, and in the face of&n;&t; * a crash we wouldn&squot;t have all the data we need to recover.&n;&t; *&n;&t; * What we do is move the bits to the ili_last_fields field.&n;&t; * When logging the inode, these bits are moved back to the&n;&t; * ilf_fields field.  In the xfs_iflush_done() routine we&n;&t; * clear ili_last_fields, since we know that the information&n;&t; * those bits represent is permanently on disk.  As long as&n;&t; * the flush completes before the inode is logged again, then&n;&t; * both ilf_fields and ili_last_fields will be cleared.&n;&t; *&n;&t; * We can play with the ilf_fields bits here, because the inode&n;&t; * lock must be held exclusively in order to set bits there&n;&t; * and the flush lock protects the ili_last_fields bits.&n;&t; * Set ili_logged so the flush done&n;&t; * routine can tell whether or not to look in the AIL.&n;&t; * Also, store the current LSN of the inode so that we can tell&n;&t; * whether the item has moved in the AIL from xfs_iflush_done().&n;&t; * In order to read the lsn we need the AIL lock, because&n;&t; * it is a 64 bit value that cannot be read atomically.&n;&t; */
r_if
c_cond
(paren
id|iip
op_ne
l_int|NULL
op_logical_and
id|iip-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
(brace
id|iip-&gt;ili_last_fields
op_assign
id|iip-&gt;ili_format.ilf_fields
suffix:semicolon
id|iip-&gt;ili_format.ilf_fields
op_assign
l_int|0
suffix:semicolon
id|iip-&gt;ili_logged
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
r_sizeof
(paren
id|xfs_lsn_t
)paren
op_eq
l_int|8
)paren
suffix:semicolon
multiline_comment|/* don&squot;t lock if it shrinks */
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|iip-&gt;ili_flush_lsn
op_assign
id|iip-&gt;ili_item.li_lsn
suffix:semicolon
id|AIL_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Attach the function xfs_iflush_done to the inode&squot;s&n;&t;&t; * buffer.  This will remove the inode from the AIL&n;&t;&t; * and unlock the inode&squot;s flush lock when the inode is&n;&t;&t; * completely written to disk.&n;&t;&t; */
id|xfs_buf_attach_iodone
c_func
(paren
id|bp
comma
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_buf_t
op_star
comma
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_iflush_done
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|iip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re flushing an inode which is not in the AIL and has&n;&t;&t; * not been logged but has i_update_core set.  For this&n;&t;&t; * case we can use a B_DELWRI flush and immediately drop&n;&t;&t; * the inode flush lock because we can avoid the whole&n;&t;&t; * AIL state thing.  It&squot;s OK to drop the flush lock now,&n;&t;&t; * because we&squot;ve already locked the buffer and to do anything&n;&t;&t; * you really need both.&n;&t;&t; */
r_if
c_cond
(paren
id|iip
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|iip-&gt;ili_logged
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_last_fields
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|iip-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|corrupt_out
suffix:colon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush all inactive inodes in mp.  Return true if no user references&n; * were found, false otherwise.&n; */
r_int
DECL|function|xfs_iflush_all
id|xfs_iflush_all
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|flag
)paren
(brace
r_int
id|busy
suffix:semicolon
r_int
id|done
suffix:semicolon
r_int
id|purged
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vmap_t
id|vmap
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|busy
op_assign
id|done
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
id|purged
op_assign
l_int|0
suffix:semicolon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ip
op_assign
id|mp-&gt;m_inodes
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* Make sure we skip markers inserted by sync */
r_if
c_cond
(paren
id|ip-&gt;i_mount
op_eq
l_int|NULL
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * It&squot;s up to our caller to purge the root&n;&t;&t;&t; * and quota vnodes later.&n;&t;&t;&t; */
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vp
)paren
(brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_finish_reclaim
c_func
(paren
id|ip
comma
l_int|0
comma
id|XFS_IFLUSH_ASYNC
)paren
suffix:semicolon
id|purged
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vn_count
c_func
(paren
id|vp
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|vn_count
c_func
(paren
id|vp
)paren
op_eq
l_int|1
op_logical_and
(paren
id|ip
op_eq
id|mp-&gt;m_rootip
op_logical_or
(paren
id|mp-&gt;m_quotainfo
op_logical_and
(paren
id|ip-&gt;i_ino
op_eq
id|mp-&gt;m_sb.sb_uquotino
op_logical_or
id|ip-&gt;i_ino
op_eq
id|mp-&gt;m_sb.sb_gquotino
)paren
)paren
)paren
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|XFS_FLUSH_ALL
)paren
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|busy
op_assign
l_int|1
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Ignore busy inodes but continue flushing&n;&t;&t;&t;&t; * others.&n;&t;&t;&t;&t; */
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Sample vp mapping while holding mp locked on MP&n;&t;&t;&t; * systems, so we don&squot;t purge a reclaimed or&n;&t;&t;&t; * nonexistent vnode.  We break from the loop&n;&t;&t;&t; * since we know that we modify&n;&t;&t;&t; * it by pulling ourselves from it in xfs_reclaim()&n;&t;&t;&t; * called via vn_purge() below.  Set ip to the next&n;&t;&t;&t; * entry in the list anyway so we&squot;ll know below&n;&t;&t;&t; * whether we reached the end or not.&n;&t;&t;&t; */
id|VMAP
c_func
(paren
id|vp
comma
id|vmap
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|vn_purge
c_func
(paren
id|vp
comma
op_amp
id|vmap
)paren
suffix:semicolon
id|purged
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ip
op_ne
id|mp-&gt;m_inodes
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to distinguish between when we exit the loop&n;&t;&t; * after a purge and when we simply hit the end of the&n;&t;&t; * list.  We can&squot;t use the (ip == mp-&gt;m_inodes) test,&n;&t;&t; * because when we purge an inode at the start of the list&n;&t;&t; * the next inode on the list becomes mp-&gt;m_inodes.  That&n;&t;&t; * would cause such a test to bail out early.  The purged&n;&t;&t; * variable tells us how we got out of the loop.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|purged
)paren
(brace
id|done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
op_logical_neg
id|busy
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_iaccess: check accessibility of inode for mode.&n; */
r_int
DECL|function|xfs_iaccess
id|xfs_iaccess
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|mode_t
id|mode
comma
id|cred_t
op_star
id|cr
)paren
(brace
r_int
id|error
suffix:semicolon
id|mode_t
id|orgmode
op_assign
id|mode
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify that the MAC policy allows the requested access.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|_MAC_XFS_IACCESS
c_func
(paren
id|ip
comma
id|mode
comma
id|cr
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|IWRITE
)paren
(brace
id|umode_t
id|imode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|S_ISREG
c_func
(paren
id|imode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|imode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|imode
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EACCES
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there&squot;s an Access Control List it&squot;s used instead of&n;&t; * the mode bits.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|_ACL_XFS_IACCESS
c_func
(paren
id|ip
comma
id|mode
comma
id|cr
)paren
)paren
op_ne
op_minus
l_int|1
)paren
r_return
id|error
ques
c_cond
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
id|ip-&gt;i_d.di_uid
)paren
(brace
id|mode
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_group_p
c_func
(paren
(paren
id|gid_t
)paren
id|ip-&gt;i_d.di_gid
)paren
)paren
id|mode
op_rshift_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the DACs are ok we don&squot;t need any capability check.&n;&t; */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|mode
)paren
op_eq
id|mode
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Read/write DACs are always overridable.&n;&t; * Executable DACs are overridable if at least one exec bit is set.&n;&t; */
r_if
c_cond
(paren
(paren
id|orgmode
op_amp
(paren
id|IREAD
op_or
id|IWRITE
)paren
)paren
op_logical_or
(paren
id|inode-&gt;i_mode
op_amp
id|S_IXUGO
)paren
)paren
r_if
c_cond
(paren
id|capable_cred
c_func
(paren
id|cr
comma
id|CAP_DAC_OVERRIDE
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|orgmode
op_eq
id|IREAD
)paren
op_logical_or
(paren
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|orgmode
op_amp
op_complement
(paren
id|IWRITE
op_or
id|IEXEC
)paren
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|capable_cred
c_func
(paren
id|cr
comma
id|CAP_DAC_READ_SEARCH
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef&t;NOISE
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Ick: mode=%o, orgmode=%o&quot;
comma
id|mode
comma
id|orgmode
)paren
suffix:semicolon
macro_line|#endif&t;/* NOISE */
r_return
id|XFS_ERROR
c_func
(paren
id|EACCES
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|EACCES
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return whether or not it is OK to swap to the given file in the&n; * given range.  Return 0 for OK and otherwise return the error.&n; *&n; * It is only OK to swap to a file if it has no holes, and all&n; * extents have been initialized.&n; *&n; * We use the vnode behavior chain prevent and allow primitives&n; * to ensure that the vnode chain stays coherent while we do this.&n; * This allows us to walk the chain down to the bottom where XFS&n; * lives without worrying about it changing out from under us.&n; */
r_int
DECL|function|xfs_swappable
id|xfs_swappable
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Verify that the file does not have any&n;&t; * holes or unwritten exents.&n;&t; */
r_return
id|xfs_bmap_check_swappable
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_iroundup: round up argument to next power of two&n; */
id|uint
DECL|function|xfs_iroundup
id|xfs_iroundup
c_func
(paren
id|uint
id|v
)paren
(brace
r_int
id|i
suffix:semicolon
id|uint
id|m
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
op_amp
(paren
id|v
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_return
id|v
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|v
op_amp
l_int|0x80000000
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
op_amp
(paren
id|v
op_plus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_return
id|v
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|m
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|31
suffix:semicolon
id|i
op_increment
comma
id|m
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|v
op_amp
id|m
)paren
r_continue
suffix:semicolon
id|v
op_or_assign
id|m
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
op_amp
(paren
id|v
op_plus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_return
id|v
op_plus
l_int|1
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Change the requested timestamp in the given inode.&n; * We don&squot;t lock across timestamp updates, and we don&squot;t log them but&n; * we do record the fact that there is dirty information in core.&n; *&n; * NOTE -- callers MUST combine XFS_ICHGTIME_MOD or XFS_ICHGTIME_CHG&n; *&t;&t;with XFS_ICHGTIME_ACC to be sure that access time&n; *&t;&t;update will take.  Calling first with XFS_ICHGTIME_ACC&n; *&t;&t;and then XFS_ICHGTIME_MOD may fail to modify the access&n; *&t;&t;timestamp if the filesystem is mounted noacctm.&n; */
r_void
DECL|function|xfs_ichgtime
id|xfs_ichgtime
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|flags
)paren
(brace
id|timespec_t
id|tv
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;re not supposed to change timestamps in readonly-mounted&n;&t; * filesystems.  Throw it away if anyone asks us.&n;&t; */
r_if
c_cond
(paren
id|vp-&gt;v_vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t update access timestamps on reads if mounted &quot;noatime&quot;&n;&t; * Throw it away if anyone asks us.&n;&t; */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_mount-&gt;m_flags
op_amp
id|XFS_MOUNT_NOATIME
op_logical_or
id|IS_NOATIME
c_func
(paren
id|inode
)paren
)paren
op_logical_and
(paren
(paren
id|flags
op_amp
(paren
id|XFS_ICHGTIME_ACC
op_or
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
)paren
op_eq
id|XFS_ICHGTIME_ACC
)paren
)paren
r_return
suffix:semicolon
id|nanotime
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_ICHGTIME_MOD
)paren
(brace
id|inode-&gt;i_mtime
op_assign
id|tv
suffix:semicolon
id|ip-&gt;i_d.di_mtime.t_sec
op_assign
(paren
id|__int32_t
)paren
id|tv.tv_sec
suffix:semicolon
id|ip-&gt;i_d.di_mtime.t_nsec
op_assign
(paren
id|__int32_t
)paren
id|tv.tv_nsec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_ICHGTIME_ACC
)paren
(brace
id|inode-&gt;i_atime
op_assign
id|tv
suffix:semicolon
id|ip-&gt;i_d.di_atime.t_sec
op_assign
(paren
id|__int32_t
)paren
id|tv.tv_sec
suffix:semicolon
id|ip-&gt;i_d.di_atime.t_nsec
op_assign
(paren
id|__int32_t
)paren
id|tv.tv_nsec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_ICHGTIME_CHG
)paren
(brace
id|inode-&gt;i_ctime
op_assign
id|tv
suffix:semicolon
id|ip-&gt;i_d.di_ctime.t_sec
op_assign
(paren
id|__int32_t
)paren
id|tv.tv_sec
suffix:semicolon
id|ip-&gt;i_d.di_ctime.t_nsec
op_assign
(paren
id|__int32_t
)paren
id|tv.tv_nsec
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We update the i_update_core field _after_ changing&n;&t; * the timestamps in order to coordinate properly with&n;&t; * xfs_iflush() so that we don&squot;t lose timestamp updates.&n;&t; * This keeps us from having to hold the inode lock&n;&t; * while doing this.  We use the SYNCHRONIZE macro to&n;&t; * ensure that the compiler does not reorder the update&n;&t; * of i_update_core above the timestamp updates above.&n;&t; */
id|SYNCHRONIZE
c_func
(paren
)paren
suffix:semicolon
id|ip-&gt;i_update_core
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode-&gt;i_state
op_amp
id|I_LOCK
)paren
)paren
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
macro_line|#ifdef XFS_ILOCK_TRACE
r_void
DECL|function|xfs_ilock_trace
id|xfs_ilock_trace
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
id|lock
comma
r_int
r_int
id|lockflags
comma
id|inst_t
op_star
id|ra
)paren
(brace
id|ktrace_enter
c_func
(paren
id|ip-&gt;i_lock_trace
comma
(paren
r_void
op_star
)paren
id|ip
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|lock
comma
multiline_comment|/* 1 = LOCK, 3=UNLOCK, etc */
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|lockflags
comma
multiline_comment|/* XFS_ILOCK_EXCL etc */
(paren
r_void
op_star
)paren
id|ra
comma
multiline_comment|/* caller of ilock */
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|cpuid
c_func
(paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|current_pid
c_func
(paren
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* ILOCK_TRACE */
eof
