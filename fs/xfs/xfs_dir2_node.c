multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * xfs_dir2_node.c&n; * XFS directory implementation, version 2, node form files&n; * See data structures in xfs_dir2_node.h and xfs_da_btree.h.&n; */
macro_line|#include &lt;xfs.h&gt;
multiline_comment|/*&n; * Function declarations.&n; */
r_static
r_void
id|xfs_dir2_free_log_header
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dabuf_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_leafn_add
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|index
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_static
r_void
id|xfs_dir2_leafn_check
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dabuf_t
op_star
id|bp
)paren
suffix:semicolon
macro_line|#else
DECL|macro|xfs_dir2_leafn_check
mdefine_line|#define xfs_dir2_leafn_check(dp, bp)
macro_line|#endif
r_static
r_void
id|xfs_dir2_leafn_moveents
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dabuf_t
op_star
id|bp_s
comma
r_int
id|start_s
comma
id|xfs_dabuf_t
op_star
id|bp_d
comma
r_int
id|start_d
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|xfs_dir2_leafn_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_leafn_remove
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
id|index
comma
id|xfs_da_state_blk_t
op_star
id|dblk
comma
r_int
op_star
id|rval
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_node_addname_int
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_da_state_blk_t
op_star
id|fblk
)paren
suffix:semicolon
multiline_comment|/*&n; * Log entries from a freespace block.&n; */
r_void
DECL|function|xfs_dir2_free_log_bests
id|xfs_dir2_free_log_bests
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* freespace buffer */
r_int
id|first
comma
multiline_comment|/* first entry to log */
r_int
id|last
)paren
multiline_comment|/* last entry to log */
(brace
id|xfs_dir2_free_t
op_star
id|free
suffix:semicolon
multiline_comment|/* freespace structure */
id|free
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|free-&gt;bests
(braket
id|first
)braket
op_minus
(paren
r_char
op_star
)paren
id|free
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|free-&gt;bests
(braket
id|last
)braket
op_minus
(paren
r_char
op_star
)paren
id|free
op_plus
r_sizeof
(paren
id|free-&gt;bests
(braket
l_int|0
)braket
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log header from a freespace block.&n; */
r_static
r_void
DECL|function|xfs_dir2_free_log_header
id|xfs_dir2_free_log_header
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* freespace buffer */
(brace
id|xfs_dir2_free_t
op_star
id|free
suffix:semicolon
multiline_comment|/* freespace structure */
id|free
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|free-&gt;hdr
op_minus
(paren
r_char
op_star
)paren
id|free
)paren
comma
(paren
id|uint
)paren
(paren
r_sizeof
(paren
id|xfs_dir2_free_hdr_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a leaf-format directory to a node-format directory.&n; * We need to change the magic number of the leaf block, and copy&n; * the freespace table out of the leaf block into its own block.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_to_node
id|xfs_dir2_leaf_to_node
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|lbp
)paren
multiline_comment|/* leaf buffer */
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_dabuf_t
op_star
id|fbp
suffix:semicolon
multiline_comment|/* freespace buffer */
id|xfs_dir2_db_t
id|fdb
suffix:semicolon
multiline_comment|/* freespace block number */
id|xfs_dir2_free_t
op_star
id|free
suffix:semicolon
multiline_comment|/* freespace structure */
id|xfs_dir2_data_off_t
op_star
id|from
suffix:semicolon
multiline_comment|/* pointer to freespace entry */
r_int
id|i
suffix:semicolon
multiline_comment|/* leaf freespace index */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|n
suffix:semicolon
multiline_comment|/* count of live freespc ents */
id|xfs_dir2_data_off_t
id|off
suffix:semicolon
multiline_comment|/* freespace entry value */
id|xfs_dir2_data_off_t
op_star
id|to
suffix:semicolon
multiline_comment|/* pointer to freespace entry */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_b
c_func
(paren
l_string|&quot;leaf_to_node&quot;
comma
id|args
comma
id|lbp
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * Add a freespace block to the directory.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_grow_inode
c_func
(paren
id|args
comma
id|XFS_DIR2_FREE_SPACE
comma
op_amp
id|fdb
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|fdb
op_eq
id|XFS_DIR2_FREE_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the buffer for the new freespace block.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|fdb
)paren
comma
op_minus
l_int|1
comma
op_amp
id|fbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|fbp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the freespace block header.&n;&t; */
id|INT_SET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_le
(paren
id|uint
)paren
id|dp-&gt;i_d.di_size
op_div
id|mp-&gt;m_dirblksize
)paren
suffix:semicolon
id|INT_COPY
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy freespace entries from the leaf block to the new block.&n;&t; * Count active entries.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|n
op_assign
l_int|0
comma
id|from
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
comma
id|to
op_assign
id|free-&gt;bests
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
comma
id|from
op_increment
comma
id|to
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|off
op_assign
id|INT_GET
c_func
(paren
op_star
id|from
comma
id|ARCH_CONVERT
)paren
)paren
op_ne
id|NULLDATAOFF
)paren
id|n
op_increment
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|to
comma
id|ARCH_CONVERT
comma
id|off
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|free-&gt;hdr.nused
comma
id|ARCH_CONVERT
comma
id|n
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log everything.&n;&t; */
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|lbp
)paren
suffix:semicolon
id|xfs_dir2_free_log_header
c_func
(paren
id|tp
comma
id|fbp
)paren
suffix:semicolon
id|xfs_dir2_free_log_bests
c_func
(paren
id|tp
comma
id|fbp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|fbp
)paren
suffix:semicolon
id|xfs_dir2_leafn_check
c_func
(paren
id|dp
comma
id|lbp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a leaf entry to a leaf block in a node-form directory.&n; * The other work necessary is done from the caller.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leafn_add
id|xfs_dir2_leafn_add
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* leaf buffer */
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
r_int
id|index
)paren
multiline_comment|/* insertion pt for new entry */
(brace
r_int
id|compact
suffix:semicolon
multiline_comment|/* compacting stale leaves */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|highstale
suffix:semicolon
multiline_comment|/* next stale entry */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
r_int
id|lfloghigh
suffix:semicolon
multiline_comment|/* high leaf entry logging */
r_int
id|lfloglow
suffix:semicolon
multiline_comment|/* low leaf entry logging */
r_int
id|lowstale
suffix:semicolon
multiline_comment|/* previous stale entry */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_sb
c_func
(paren
l_string|&quot;leafn_add&quot;
comma
id|args
comma
id|index
comma
id|bp
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * If there are already the maximum number of leaf entries in&n;&t; * the block, if there are no stale entries it won&squot;t fit.&n;&t; * Caller will do a split.  If there are stale entries we&squot;ll do&n;&t; * a compact.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_MAX_LEAF_ENTS
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
id|compact
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
OG
l_int|1
suffix:semicolon
)brace
r_else
id|compact
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|index
op_eq
l_int|0
op_logical_or
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|index
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_le
id|args-&gt;hashval
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|index
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|index
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|args-&gt;hashval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;justcheck
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Compact out all but one stale leaf entry.  Leaves behind&n;&t; * the entry closest to index.&n;&t; */
r_if
c_cond
(paren
id|compact
)paren
(brace
id|xfs_dir2_leaf_compact_x1
c_func
(paren
id|bp
comma
op_amp
id|index
comma
op_amp
id|lowstale
comma
op_amp
id|highstale
comma
op_amp
id|lfloglow
comma
op_amp
id|lfloghigh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set impossible logging indices for this case.&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|lfloglow
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|lfloghigh
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No stale entries, just insert a space for the new entry.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|memmove
c_func
(paren
id|lep
op_plus
l_int|1
comma
id|lep
comma
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|index
)paren
op_star
r_sizeof
(paren
op_star
id|lep
)paren
)paren
suffix:semicolon
id|lfloglow
op_assign
id|index
suffix:semicolon
id|lfloghigh
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There are stale entries.  We&squot;ll use one for the new entry.&n;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t; * If we didn&squot;t do a compact then we need to figure out&n;&t;&t; * which stale entry will be used.&n;&t;&t; */
r_if
c_cond
(paren
id|compact
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Find first stale entry before our insertion point.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|lowstale
op_assign
id|index
op_minus
l_int|1
suffix:semicolon
id|lowstale
op_ge
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|lowstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
suffix:semicolon
id|lowstale
op_decrement
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Find next stale entry after insertion point.&n;&t;&t;&t; * Stop looking if the answer would be worse than&n;&t;&t;&t; * lowstale already found.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|highstale
op_assign
id|index
suffix:semicolon
id|highstale
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|highstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
op_logical_and
(paren
id|lowstale
OL
l_int|0
op_logical_or
id|index
op_minus
id|lowstale
op_minus
l_int|1
op_ge
id|highstale
op_minus
id|index
)paren
suffix:semicolon
id|highstale
op_increment
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Using the low stale entry.&n;&t;&t; * Shift entries up toward the stale slot.&n;&t;&t; */
r_if
c_cond
(paren
id|lowstale
op_ge
l_int|0
op_logical_and
(paren
id|highstale
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|index
op_minus
id|lowstale
op_minus
l_int|1
OL
id|highstale
op_minus
id|index
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|lowstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|index
op_minus
id|lowstale
op_minus
l_int|1
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_minus
id|lowstale
op_minus
l_int|1
OG
l_int|0
)paren
id|memmove
c_func
(paren
op_amp
id|leaf-&gt;ents
(braket
id|lowstale
)braket
comma
op_amp
id|leaf-&gt;ents
(braket
id|lowstale
op_plus
l_int|1
)braket
comma
(paren
id|index
op_minus
id|lowstale
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|lep
)paren
)paren
suffix:semicolon
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
op_minus
l_int|1
)braket
suffix:semicolon
id|lfloglow
op_assign
id|MIN
c_func
(paren
id|lowstale
comma
id|lfloglow
)paren
suffix:semicolon
id|lfloghigh
op_assign
id|MAX
c_func
(paren
id|index
op_minus
l_int|1
comma
id|lfloghigh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Using the high stale entry.&n;&t;&t; * Shift entries down toward the stale slot.&n;&t;&t; */
r_else
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|highstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|highstale
op_minus
id|index
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|highstale
op_minus
id|index
OG
l_int|0
)paren
id|memmove
c_func
(paren
op_amp
id|leaf-&gt;ents
(braket
id|index
op_plus
l_int|1
)braket
comma
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
comma
(paren
id|highstale
op_minus
id|index
)paren
op_star
r_sizeof
(paren
op_star
id|lep
)paren
)paren
suffix:semicolon
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
id|lfloglow
op_assign
id|MIN
c_func
(paren
id|index
comma
id|lfloglow
)paren
suffix:semicolon
id|lfloghigh
op_assign
id|MAX
c_func
(paren
id|highstale
comma
id|lfloghigh
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Insert the new entry, log everything.&n;&t; */
id|INT_SET
c_func
(paren
id|lep-&gt;hashval
comma
id|ARCH_CONVERT
comma
id|args-&gt;hashval
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|args-&gt;blkno
comma
id|args-&gt;index
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|bp
comma
id|lfloglow
comma
id|lfloghigh
)paren
suffix:semicolon
id|xfs_dir2_leafn_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Check internal consistency of a leafn block.&n; */
r_void
DECL|function|xfs_dir2_leafn_check
id|xfs_dir2_leafn_check
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* leaf buffer */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* leaf index */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|stale
suffix:semicolon
multiline_comment|/* count of stale leaves */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_le
id|XFS_DIR2_MAX_LEAF_ENTS
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|stale
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_plus
l_int|1
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|i
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|i
op_plus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|i
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
id|stale
op_increment
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
op_eq
id|stale
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/*&n; * Return the last hash value in the leaf.&n; * Stale entries are ok.&n; */
id|xfs_dahash_t
multiline_comment|/* hash value */
DECL|function|xfs_dir2_leafn_lasthash
id|xfs_dir2_leafn_lasthash
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* leaf buffer */
r_int
op_star
id|count
)paren
multiline_comment|/* count of entries in leaf */
(brace
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
op_star
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a leaf entry in a node-format leaf block.&n; * If this is an addname then the extrablk in state is a freespace block,&n; * otherwise it&squot;s a data block.&n; */
r_int
DECL|function|xfs_dir2_leafn_lookup_int
id|xfs_dir2_leafn_lookup_int
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* leaf buffer */
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
r_int
op_star
id|indexp
comma
multiline_comment|/* out: leaf entry index */
id|xfs_da_state_t
op_star
id|state
)paren
multiline_comment|/* state to fill in */
(brace
id|xfs_dabuf_t
op_star
id|curbp
suffix:semicolon
multiline_comment|/* current data/free buffer */
id|xfs_dir2_db_t
id|curdb
suffix:semicolon
multiline_comment|/* current data block number */
id|xfs_dir2_db_t
id|curfdb
suffix:semicolon
multiline_comment|/* current free block number */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data block entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|fi
suffix:semicolon
multiline_comment|/* free entry index */
id|xfs_dir2_free_t
op_star
id|free
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* free block structure */
r_int
id|index
suffix:semicolon
multiline_comment|/* leaf entry index */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
r_int
id|length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* length of new data entry */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_db_t
id|newdb
suffix:semicolon
multiline_comment|/* new data block number */
id|xfs_dir2_db_t
id|newfdb
suffix:semicolon
multiline_comment|/* new free block number */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
macro_line|#ifdef __KERNEL__
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|xfs_dir2_leafn_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the hash value in the leaf entries.&n;&t; */
id|index
op_assign
id|xfs_dir2_leaf_search_hash
c_func
(paren
id|args
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have a buffer coming in?&n;&t; */
r_if
c_cond
(paren
id|state-&gt;extravalid
)paren
id|curbp
op_assign
id|state-&gt;extrablk.bp
suffix:semicolon
r_else
id|curbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * For addname, it&squot;s a free block buffer, get the block number.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;addname
)paren
(brace
id|curfdb
op_assign
id|curbp
ques
c_cond
id|state-&gt;extrablk.blkno
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|curdb
op_assign
op_minus
l_int|1
suffix:semicolon
id|length
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|free
op_assign
(paren
id|curbp
ques
c_cond
id|curbp-&gt;data
suffix:colon
l_int|NULL
)paren
)paren
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For others, it&squot;s a data block buffer, get the block number.&n;&t; */
r_else
(brace
id|curfdb
op_assign
op_minus
l_int|1
suffix:semicolon
id|curdb
op_assign
id|curbp
ques
c_cond
id|state-&gt;extrablk.blkno
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop over leaf entries with the right hash value.&n;&t; */
r_for
c_loop
(paren
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
id|index
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|lep-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|args-&gt;hashval
suffix:semicolon
id|lep
op_increment
comma
id|index
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip stale leaf entries.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Pull the data block number from the entry.&n;&t;&t; */
id|newdb
op_assign
id|XFS_DIR2_DATAPTR_TO_DB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For addname, we&squot;re looking for a place to put the new entry.&n;&t;&t; * We want to use a data block with an entry of equal&n;&t;&t; * hash value to ours if there is one with room.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;addname
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If this block isn&squot;t the data block we already have&n;&t;&t;&t; * in hand, take a look at it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|newdb
op_ne
id|curdb
)paren
(brace
id|curdb
op_assign
id|newdb
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Convert the data block to the free block&n;&t;&t;&t;&t; * holding its freespace information.&n;&t;&t;&t;&t; */
id|newfdb
op_assign
id|XFS_DIR2_DB_TO_FDB
c_func
(paren
id|mp
comma
id|newdb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If it&squot;s not the one we have in hand,&n;&t;&t;&t;&t; * read it in.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|newfdb
op_ne
id|curfdb
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If we had one before, drop it.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|curbp
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|curbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Read the free block.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|newfdb
)paren
comma
op_minus
l_int|1
comma
op_amp
id|curbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|curfdb
op_assign
id|newfdb
suffix:semicolon
id|free
op_assign
id|curbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
op_mod
id|XFS_DIR2_MAX_FREE_BESTS
c_func
(paren
id|mp
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
op_le
id|curdb
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|curdb
OL
id|INT_GET
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get the index for our entry.&n;&t;&t;&t;&t; */
id|fi
op_assign
id|XFS_DIR2_DB_TO_FDINDEX
c_func
(paren
id|mp
comma
id|curdb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If it has room, return it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|fi
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDATAOFF
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_dir2_leafn_lookup_int&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|fi
)braket
comma
id|ARCH_CONVERT
)paren
op_ge
id|length
)paren
(brace
op_star
id|indexp
op_assign
id|index
suffix:semicolon
id|state-&gt;extravalid
op_assign
l_int|1
suffix:semicolon
id|state-&gt;extrablk.bp
op_assign
id|curbp
suffix:semicolon
id|state-&gt;extrablk.blkno
op_assign
id|curfdb
suffix:semicolon
id|state-&gt;extrablk.index
op_assign
id|fi
suffix:semicolon
id|state-&gt;extrablk.magic
op_assign
id|XFS_DIR2_FREE_MAGIC
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t; * Not adding a new entry, so we really want to find&n;&t;&t; * the name given to us.&n;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If it&squot;s a different data block, go get it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|newdb
op_ne
id|curdb
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If we had a block before, drop it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|curbp
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|curbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Read the data block.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|newdb
)paren
comma
op_minus
l_int|1
comma
op_amp
id|curbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|curbp
)paren
suffix:semicolon
id|curdb
op_assign
id|newdb
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Point to the data entry.&n;&t;&t;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|curbp-&gt;data
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Compare the entry, return it if it matches.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dep-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|dep-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|dep-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
id|args-&gt;inumber
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
op_star
id|indexp
op_assign
id|index
suffix:semicolon
id|state-&gt;extravalid
op_assign
l_int|1
suffix:semicolon
id|state-&gt;extrablk.bp
op_assign
id|curbp
suffix:semicolon
id|state-&gt;extrablk.blkno
op_assign
id|curdb
suffix:semicolon
id|state-&gt;extrablk.index
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|curbp-&gt;data
)paren
suffix:semicolon
id|state-&gt;extrablk.magic
op_assign
id|XFS_DIR2_DATA_MAGIC
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find a match.&n;&t; * If we are holding a buffer, give it back in case our caller&n;&t; * finds it useful.&n;&t; */
r_if
c_cond
(paren
(paren
id|state-&gt;extravalid
op_assign
(paren
id|curbp
op_ne
l_int|NULL
)paren
)paren
)paren
(brace
id|state-&gt;extrablk.bp
op_assign
id|curbp
suffix:semicolon
id|state-&gt;extrablk.index
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For addname, giving back a free block.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;addname
)paren
(brace
id|state-&gt;extrablk.blkno
op_assign
id|curfdb
suffix:semicolon
id|state-&gt;extrablk.magic
op_assign
id|XFS_DIR2_FREE_MAGIC
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * For other callers, giving back a data block.&n;&t;&t; */
r_else
(brace
id|state-&gt;extrablk.blkno
op_assign
id|curdb
suffix:semicolon
id|state-&gt;extrablk.magic
op_assign
id|XFS_DIR2_DATA_MAGIC
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Return the final index, that will be the insertion point.&n;&t; */
op_star
id|indexp
op_assign
id|index
suffix:semicolon
id|ASSERT
c_func
(paren
id|index
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Move count leaf entries from source to destination leaf.&n; * Log entries and headers.  Stale entries are preserved.&n; */
r_static
r_void
DECL|function|xfs_dir2_leafn_moveents
id|xfs_dir2_leafn_moveents
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|bp_s
comma
multiline_comment|/* source leaf buffer */
r_int
id|start_s
comma
multiline_comment|/* source leaf index */
id|xfs_dabuf_t
op_star
id|bp_d
comma
multiline_comment|/* destination leaf buffer */
r_int
id|start_d
comma
multiline_comment|/* destination leaf index */
r_int
id|count
)paren
multiline_comment|/* count of leaves to copy */
(brace
id|xfs_dir2_leaf_t
op_star
id|leaf_d
suffix:semicolon
multiline_comment|/* destination leaf structure */
id|xfs_dir2_leaf_t
op_star
id|leaf_s
suffix:semicolon
multiline_comment|/* source leaf structure */
r_int
id|stale
suffix:semicolon
multiline_comment|/* count stale leaves copied */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_bibii
c_func
(paren
l_string|&quot;leafn_moveents&quot;
comma
id|args
comma
id|bp_s
comma
id|start_s
comma
id|bp_d
comma
id|start_d
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Silently return if nothing to do.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|leaf_s
op_assign
id|bp_s-&gt;data
suffix:semicolon
id|leaf_d
op_assign
id|bp_d-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * If the destination index is not the end of the current&n;&t; * destination leaf entries, open up a hole in the destination&n;&t; * to hold the new entries.&n;&t; */
r_if
c_cond
(paren
id|start_d
OL
id|INT_GET
c_func
(paren
id|leaf_d-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|memmove
c_func
(paren
op_amp
id|leaf_d-&gt;ents
(braket
id|start_d
op_plus
id|count
)braket
comma
op_amp
id|leaf_d-&gt;ents
(braket
id|start_d
)braket
comma
(paren
id|INT_GET
c_func
(paren
id|leaf_d-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|start_d
)paren
op_star
r_sizeof
(paren
id|xfs_dir2_leaf_entry_t
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|bp_d
comma
id|start_d
op_plus
id|count
comma
id|count
op_plus
id|INT_GET
c_func
(paren
id|leaf_d-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the source has stale leaves, count the ones in the copy range&n;&t; * so we can update the header correctly.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|leaf_s-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* temp leaf index */
r_for
c_loop
(paren
id|i
op_assign
id|start_s
comma
id|stale
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|start_s
op_plus
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf_s-&gt;ents
(braket
id|i
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
id|stale
op_increment
suffix:semicolon
)brace
)brace
r_else
id|stale
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the leaf entries from source to destination.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|leaf_d-&gt;ents
(braket
id|start_d
)braket
comma
op_amp
id|leaf_s-&gt;ents
(braket
id|start_s
)braket
comma
id|count
op_star
r_sizeof
(paren
id|xfs_dir2_leaf_entry_t
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|bp_d
comma
id|start_d
comma
id|start_d
op_plus
id|count
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there are source entries after the ones we copied,&n;&t; * delete the ones we copied by sliding the next ones down.&n;&t; */
r_if
c_cond
(paren
id|start_s
op_plus
id|count
OL
id|INT_GET
c_func
(paren
id|leaf_s-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|memmove
c_func
(paren
op_amp
id|leaf_s-&gt;ents
(braket
id|start_s
)braket
comma
op_amp
id|leaf_s-&gt;ents
(braket
id|start_s
op_plus
id|count
)braket
comma
id|count
op_star
r_sizeof
(paren
id|xfs_dir2_leaf_entry_t
)paren
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|bp_s
comma
id|start_s
comma
id|start_s
op_plus
id|count
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the headers and log them.&n;&t; */
id|INT_MOD
c_func
(paren
id|leaf_s-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|count
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|leaf_s-&gt;hdr.stale
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|stale
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|leaf_d-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
id|count
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|leaf_d-&gt;hdr.stale
comma
id|ARCH_CONVERT
comma
id|stale
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|bp_s
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|bp_d
)paren
suffix:semicolon
id|xfs_dir2_leafn_check
c_func
(paren
id|args-&gt;dp
comma
id|bp_s
)paren
suffix:semicolon
id|xfs_dir2_leafn_check
c_func
(paren
id|args-&gt;dp
comma
id|bp_d
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine the sort order of two leaf blocks.&n; * Returns 1 if both are valid and leaf2 should be before leaf1, else 0.&n; */
r_int
multiline_comment|/* sort order */
DECL|function|xfs_dir2_leafn_order
id|xfs_dir2_leafn_order
c_func
(paren
id|xfs_dabuf_t
op_star
id|leaf1_bp
comma
multiline_comment|/* leaf1 buffer */
id|xfs_dabuf_t
op_star
id|leaf2_bp
)paren
multiline_comment|/* leaf2 buffer */
(brace
id|xfs_dir2_leaf_t
op_star
id|leaf1
suffix:semicolon
multiline_comment|/* leaf1 structure */
id|xfs_dir2_leaf_t
op_star
id|leaf2
suffix:semicolon
multiline_comment|/* leaf2 structure */
id|leaf1
op_assign
id|leaf1_bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|leaf2_bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;ents
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|leaf1-&gt;ents
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|INT_GET
c_func
(paren
id|leaf2-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|leaf1-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Rebalance leaf entries between two leaf blocks.&n; * This is actually only called when the second block is new,&n; * though the code deals with the general case.&n; * A new entry will be inserted in one of the blocks, and that&n; * entry is taken into account when balancing.&n; */
r_static
r_void
DECL|function|xfs_dir2_leafn_rebalance
id|xfs_dir2_leafn_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
multiline_comment|/* btree cursor */
id|xfs_da_state_blk_t
op_star
id|blk1
comma
multiline_comment|/* first btree block */
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
multiline_comment|/* second btree block */
(brace
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
r_int
id|count
suffix:semicolon
multiline_comment|/* count (&amp; direction) leaves */
r_int
id|isleft
suffix:semicolon
multiline_comment|/* new goes in left leaf */
id|xfs_dir2_leaf_t
op_star
id|leaf1
suffix:semicolon
multiline_comment|/* first leaf structure */
id|xfs_dir2_leaf_t
op_star
id|leaf2
suffix:semicolon
multiline_comment|/* second leaf structure */
r_int
id|mid
suffix:semicolon
multiline_comment|/* midpoint leaf index */
macro_line|#ifdef DEBUG
r_int
id|oldstale
suffix:semicolon
multiline_comment|/* old count of stale leaves */
macro_line|#endif
r_int
id|oldsum
suffix:semicolon
multiline_comment|/* old total leaf count */
r_int
id|swap
suffix:semicolon
multiline_comment|/* swapped leaf blocks */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
multiline_comment|/*&n;&t; * If the block order is wrong, swap the arguments.&n;&t; */
r_if
c_cond
(paren
(paren
id|swap
op_assign
id|xfs_dir2_leafn_order
c_func
(paren
id|blk1-&gt;bp
comma
id|blk2-&gt;bp
)paren
)paren
)paren
(brace
id|xfs_da_state_blk_t
op_star
id|tmp
suffix:semicolon
multiline_comment|/* temp for block swap */
id|tmp
op_assign
id|blk1
suffix:semicolon
id|blk1
op_assign
id|blk2
suffix:semicolon
id|blk2
op_assign
id|tmp
suffix:semicolon
)brace
id|leaf1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|oldsum
op_assign
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|oldstale
op_assign
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#endif
id|mid
op_assign
id|oldsum
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If the old leaf count was odd then the new one will be even,&n;&t; * so we need to divide the new count evenly.&n;&t; */
r_if
c_cond
(paren
id|oldsum
op_amp
l_int|1
)paren
(brace
id|xfs_dahash_t
id|midhash
suffix:semicolon
multiline_comment|/* middle entry hash value */
r_if
c_cond
(paren
id|mid
op_ge
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|midhash
op_assign
id|INT_GET
c_func
(paren
id|leaf2-&gt;ents
(braket
id|mid
op_minus
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_else
id|midhash
op_assign
id|INT_GET
c_func
(paren
id|leaf1-&gt;ents
(braket
id|mid
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|isleft
op_assign
id|args-&gt;hashval
op_le
id|midhash
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the old count is even then the new count is odd, so there&squot;s&n;&t; * no preferred side for the new entry.&n;&t; * Pick the left one.&n;&t; */
r_else
id|isleft
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate moved entry count.&t; Positive means left-to-right,&n;&t; * negative means right-to-left.  Then move the entries.&n;&t; */
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|mid
op_plus
(paren
id|isleft
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
id|xfs_dir2_leafn_moveents
c_func
(paren
id|args
comma
id|blk1-&gt;bp
comma
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
comma
id|blk2-&gt;bp
comma
l_int|0
comma
id|count
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|xfs_dir2_leafn_moveents
c_func
(paren
id|args
comma
id|blk2-&gt;bp
comma
l_int|0
comma
id|blk1-&gt;bp
comma
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
id|count
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_eq
id|oldsum
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
op_eq
id|oldstale
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark whether we&squot;re inserting into the old or new leaf.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|state-&gt;inleaf
op_assign
id|swap
suffix:semicolon
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|state-&gt;inleaf
op_assign
op_logical_neg
id|swap
suffix:semicolon
r_else
id|state-&gt;inleaf
op_assign
id|swap
op_xor
(paren
id|args-&gt;hashval
OL
id|INT_GET
c_func
(paren
id|leaf2-&gt;ents
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the expected index for insertion.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;inleaf
)paren
id|blk2-&gt;index
op_assign
id|blk1-&gt;index
op_minus
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from a node directory.&n; * This removes the leaf entry and the data entry,&n; * and updates the free block if necessary.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leafn_remove
id|xfs_dir2_leafn_remove
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* leaf buffer */
r_int
id|index
comma
multiline_comment|/* leaf entry index */
id|xfs_da_state_blk_t
op_star
id|dblk
comma
multiline_comment|/* data block */
r_int
op_star
id|rval
)paren
multiline_comment|/* resulting block needs join */
(brace
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
multiline_comment|/* data block structure */
id|xfs_dir2_db_t
id|db
suffix:semicolon
multiline_comment|/* data block number */
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data block buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data block entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
r_int
id|longest
suffix:semicolon
multiline_comment|/* longest data free entry */
r_int
id|off
suffix:semicolon
multiline_comment|/* data block entry offset */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log data header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to rescan data frees */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_sb
c_func
(paren
l_string|&quot;leafn_remove&quot;
comma
id|args
comma
id|index
comma
id|bp
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the entry we&squot;re removing.&n;&t; */
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Extract the data block and offset from the entry.&n;&t; */
id|db
op_assign
id|XFS_DIR2_DATAPTR_TO_DB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dblk-&gt;blkno
op_eq
id|db
)paren
suffix:semicolon
id|off
op_assign
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dblk-&gt;index
op_eq
id|off
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Kill the leaf entry by marking it stale.&n;&t; * Log the leaf block changes.&n;&t; */
id|INT_MOD
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_header
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_NULL_DATAPTR
)paren
suffix:semicolon
id|xfs_dir2_leaf_log_ents
c_func
(paren
id|tp
comma
id|bp
comma
id|index
comma
id|index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make the data entry free.  Keep track of the longest freespace&n;&t; * in the data block in case it changes.&n;&t; */
id|dbp
op_assign
id|dblk-&gt;bp
suffix:semicolon
id|data
op_assign
id|dbp-&gt;data
suffix:semicolon
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|data
op_plus
id|off
)paren
suffix:semicolon
id|longest
op_assign
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|needlog
op_assign
id|needscan
op_assign
l_int|0
suffix:semicolon
id|xfs_dir2_data_make_free
c_func
(paren
id|tp
comma
id|dbp
comma
id|off
comma
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Rescan the data block freespaces for bestfree.&n;&t; * Log the data block header if needed.&n;&t; */
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
id|data
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the longest data block freespace changes, need to update&n;&t; * the corresponding freeblock entry.&n;&t; */
r_if
c_cond
(paren
id|longest
OL
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_dabuf_t
op_star
id|fbp
suffix:semicolon
multiline_comment|/* freeblock buffer */
id|xfs_dir2_db_t
id|fdb
suffix:semicolon
multiline_comment|/* freeblock block number */
r_int
id|findex
suffix:semicolon
multiline_comment|/* index in freeblock entries */
id|xfs_dir2_free_t
op_star
id|free
suffix:semicolon
multiline_comment|/* freeblock structure */
r_int
id|logfree
suffix:semicolon
multiline_comment|/* need to log free entry */
multiline_comment|/*&n;&t;&t; * Convert the data block number to a free block,&n;&t;&t; * read in the free block.&n;&t;&t; */
id|fdb
op_assign
id|XFS_DIR2_DB_TO_FDB
c_func
(paren
id|mp
comma
id|db
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|fdb
)paren
comma
op_minus
l_int|1
comma
op_amp
id|fbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_MAX_FREE_BESTS
c_func
(paren
id|mp
)paren
op_star
(paren
id|fdb
op_minus
id|XFS_DIR2_FREE_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate which entry we need to fix.&n;&t;&t; */
id|findex
op_assign
id|XFS_DIR2_DB_TO_FDINDEX
c_func
(paren
id|mp
comma
id|db
)paren
suffix:semicolon
id|longest
op_assign
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the data block is now empty we can get rid of it&n;&t;&t; * (usually).&n;&t;&t; */
r_if
c_cond
(paren
id|longest
op_eq
id|mp-&gt;m_dirblksize
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|data-&gt;hdr
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try to punch out the data block.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_dir2_shrink_inode
c_func
(paren
id|args
comma
id|db
comma
id|dbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|dblk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We can get ENOSPC if there&squot;s no space reservation.&n;&t;&t;&t; * In this case just drop the buffer and some one else&n;&t;&t;&t; * will eventually get rid of the empty block.&n;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
op_logical_and
id|args-&gt;total
op_eq
l_int|0
)paren
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
r_else
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we got rid of the data block, we can eliminate that entry&n;&t;&t; * in the free block.&n;&t;&t; */
r_if
c_cond
(paren
id|data
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * One less used entry in the free table.&n;&t;&t;&t; */
id|INT_MOD
c_func
(paren
id|free-&gt;hdr.nused
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_free_log_header
c_func
(paren
id|tp
comma
id|fbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this was the last entry in the table, we can&n;&t;&t;&t; * trim the table size back.  There might be other&n;&t;&t;&t; * entries at the end referring to non-existent&n;&t;&t;&t; * data blocks, get those too.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|findex
op_eq
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* free entry index */
r_for
c_loop
(paren
id|i
op_assign
id|findex
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDATAOFF
suffix:semicolon
id|i
op_decrement
)paren
r_continue
suffix:semicolon
id|INT_SET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
id|logfree
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Not the last entry, just punch it out.&n;&t;&t;&t; */
r_else
(brace
id|INT_SET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
comma
id|NULLDATAOFF
)paren
suffix:semicolon
id|logfree
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If there are no useful entries left in the block,&n;&t;&t;&t; * get rid of the block if we can.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|free-&gt;hdr.nused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|error
op_assign
id|xfs_dir2_shrink_inode
c_func
(paren
id|args
comma
id|fdb
comma
id|fbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|fbp
op_assign
l_int|NULL
suffix:semicolon
id|logfree
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
op_ne
id|ENOSPC
op_logical_or
id|args-&gt;total
op_ne
l_int|0
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * It&squot;s possible to get ENOSPC if there is no&n;&t;&t;&t;&t; * space reservation.  In this case some one&n;&t;&t;&t;&t; * else will eventually get rid of this block.&n;&t;&t;&t;&t; */
)brace
)brace
multiline_comment|/*&n;&t;&t; * Data block is not empty, just set the free entry to&n;&t;&t; * the new value.&n;&t;&t; */
r_else
(brace
id|INT_SET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
comma
id|longest
)paren
suffix:semicolon
id|logfree
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Log the free entry that changed, unless we got rid of it.&n;&t;&t; */
r_if
c_cond
(paren
id|logfree
)paren
id|xfs_dir2_free_log_bests
c_func
(paren
id|tp
comma
id|fbp
comma
id|findex
comma
id|findex
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Drop the buffer if we still have it.&n;&t;&t; */
r_if
c_cond
(paren
id|fbp
)paren
id|xfs_da_buf_done
c_func
(paren
id|fbp
)paren
suffix:semicolon
)brace
id|xfs_dir2_leafn_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return indication of whether this leaf block is emtpy enough&n;&t; * to justify trying to join it with a neighbor.&n;&t; */
op_star
id|rval
op_assign
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;hdr
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;ents
(braket
l_int|0
)braket
)paren
op_star
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
)paren
OL
id|mp-&gt;m_dir_magicpct
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Split the leaf entries in the old block into old and new blocks.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leafn_split
id|xfs_dir2_leafn_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
multiline_comment|/* btree cursor */
id|xfs_da_state_blk_t
op_star
id|oldblk
comma
multiline_comment|/* original block */
id|xfs_da_state_blk_t
op_star
id|newblk
)paren
multiline_comment|/* newly created block */
(brace
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
id|xfs_dablk_t
id|blkno
suffix:semicolon
multiline_comment|/* new leaf block number */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
multiline_comment|/*&n;&t; * Allocate space for a new leaf node.&n;&t; */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|args
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|oldblk-&gt;magic
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|args
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize the new leaf block.&n;&t; */
id|error
op_assign
id|xfs_dir2_leaf_init
c_func
(paren
id|args
comma
id|XFS_DIR2_DA_TO_DB
c_func
(paren
id|mp
comma
id|blkno
)paren
comma
op_amp
id|newblk-&gt;bp
comma
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|newblk-&gt;blkno
op_assign
id|blkno
suffix:semicolon
id|newblk-&gt;magic
op_assign
id|XFS_DIR2_LEAFN_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t; * Rebalance the entries across the two leaves, link the new&n;&t; * block into the leaves.&n;&t; */
id|xfs_dir2_leafn_rebalance
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_blk_link
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Insert the new entry in the correct block.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;inleaf
)paren
id|error
op_assign
id|xfs_dir2_leafn_add
c_func
(paren
id|oldblk-&gt;bp
comma
id|args
comma
id|oldblk-&gt;index
)paren
suffix:semicolon
r_else
id|error
op_assign
id|xfs_dir2_leafn_add
c_func
(paren
id|newblk-&gt;bp
comma
id|args
comma
id|newblk-&gt;index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update last hashval in each block since we added the name.&n;&t; */
id|oldblk-&gt;hashval
op_assign
id|xfs_dir2_leafn_lasthash
c_func
(paren
id|oldblk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
id|newblk-&gt;hashval
op_assign
id|xfs_dir2_leafn_lasthash
c_func
(paren
id|newblk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_dir2_leafn_check
c_func
(paren
id|args-&gt;dp
comma
id|oldblk-&gt;bp
)paren
suffix:semicolon
id|xfs_dir2_leafn_check
c_func
(paren
id|args-&gt;dp
comma
id|newblk-&gt;bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Check a leaf block and its neighbors to see if the block should be&n; * collapsed into one or the other neighbor.  Always keep the block&n; * with the smaller block number.&n; * If the current block is over 50% full, don&squot;t try to join it, return 0.&n; * If the block is empty, fill in the state structure and return 2.&n; * If it can be collapsed, fill in the state structure and return 1.&n; * If nothing can be done, return 0.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leafn_toosmall
id|xfs_dir2_leafn_toosmall
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
multiline_comment|/* btree cursor */
r_int
op_star
id|action
)paren
multiline_comment|/* resulting action to take */
(brace
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
multiline_comment|/* leaf block */
id|xfs_dablk_t
id|blkno
suffix:semicolon
multiline_comment|/* leaf block number */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* leaf buffer */
r_int
id|bytes
suffix:semicolon
multiline_comment|/* bytes in use */
r_int
id|count
suffix:semicolon
multiline_comment|/* leaf live entry count */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|forward
suffix:semicolon
multiline_comment|/* sibling block direction */
r_int
id|i
suffix:semicolon
multiline_comment|/* sibling counter */
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
multiline_comment|/* leaf block header */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
r_int
id|rval
suffix:semicolon
multiline_comment|/* result from path_shift */
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being over 50% full.&n;&t; * If so, it&squot;s not worth even looking to see if we might be able&n;&t; * to coalesce with a sibling.&n;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|info
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_dir2_leaf_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;hdr
)paren
op_plus
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;ents
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
(paren
id|state-&gt;blocksize
op_rshift
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Blk over 50%, don&squot;t try to join.&n;&t;&t; */
op_star
id|action
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being empty.&n;&t; * If the block is empty, we&squot;ll simply delete it, no need to&n;&t; * coalesce it with a sibling block.  We choose (arbitrarily)&n;&t; * to merge with the forward block unless it is NULL.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make altpath point to the block we want to keep and&n;&t;&t; * path point to the block we want to drop (this one).&n;&t;&t; */
id|forward
op_assign
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
op_star
id|action
op_assign
id|rval
ques
c_cond
l_int|2
suffix:colon
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Examine each sibling block to see if we can coalesce with&n;&t; * at least 25% free space to spare.  We need to figure out&n;&t; * whether to merge with the forward or the backward block.&n;&t; * We prefer coalescing with the lower numbered sibling so as&n;&t; * to shrink a directory over time.&n;&t; */
id|forward
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|forward
op_assign
op_logical_neg
id|forward
comma
id|i
op_increment
)paren
(brace
id|blkno
op_assign
id|forward
ques
c_cond
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
suffix:colon
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the sibling leaf block.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|state-&gt;args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Count bytes in the two blocks combined.&n;&t;&t; */
id|leaf
op_assign
(paren
id|xfs_dir2_leaf_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_assign
id|state-&gt;blocksize
op_minus
(paren
id|state-&gt;blocksize
op_rshift
l_int|2
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|count
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|leaf-&gt;ents
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fits with at least 25% to spare.&n;&t;&t; */
r_if
c_cond
(paren
id|bytes
op_ge
l_int|0
)paren
r_break
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Didn&squot;t like either block, give up.&n;&t; */
r_if
c_cond
(paren
id|i
op_ge
l_int|2
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Done with the sibling leaf block here, drop the dabuf&n;&t; * so path_shift can get it.&n;&t; */
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make altpath point to the block we want to keep (the lower&n;&t; * numbered block) and path point to the block we want to drop.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
OL
id|blk-&gt;blkno
)paren
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|rval
)paren
suffix:semicolon
r_else
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
comma
id|forward
comma
l_int|0
comma
op_amp
id|rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
op_star
id|action
op_assign
id|rval
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move all the leaf entries from drop_blk to save_blk.&n; * This is done as part of a join operation.&n; */
r_void
DECL|function|xfs_dir2_leafn_unbalance
id|xfs_dir2_leafn_unbalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
multiline_comment|/* cursor */
id|xfs_da_state_blk_t
op_star
id|drop_blk
comma
multiline_comment|/* dead block */
id|xfs_da_state_blk_t
op_star
id|save_blk
)paren
multiline_comment|/* surviving block */
(brace
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
id|xfs_dir2_leaf_t
op_star
id|drop_leaf
suffix:semicolon
multiline_comment|/* dead leaf structure */
id|xfs_dir2_leaf_t
op_star
id|save_leaf
suffix:semicolon
multiline_comment|/* surviving leaf structure */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|ASSERT
c_func
(paren
id|drop_blk-&gt;magic
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|save_blk-&gt;magic
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|drop_leaf
op_assign
id|drop_blk-&gt;bp-&gt;data
suffix:semicolon
id|save_leaf
op_assign
id|save_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there are any stale leaf entries, take this opportunity&n;&t; * to purge them.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
id|xfs_dir2_leaf_compact
c_func
(paren
id|args
comma
id|drop_blk-&gt;bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
id|xfs_dir2_leaf_compact
c_func
(paren
id|args
comma
id|save_blk-&gt;bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Move the entries from drop to the appropriate end of save.&n;&t; */
id|drop_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_dir2_leafn_order
c_func
(paren
id|save_blk-&gt;bp
comma
id|drop_blk-&gt;bp
)paren
)paren
id|xfs_dir2_leafn_moveents
c_func
(paren
id|args
comma
id|drop_blk-&gt;bp
comma
l_int|0
comma
id|save_blk-&gt;bp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_else
id|xfs_dir2_leafn_moveents
c_func
(paren
id|args
comma
id|drop_blk-&gt;bp
comma
l_int|0
comma
id|save_blk-&gt;bp
comma
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|save_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|save_leaf-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir2_leafn_check
c_func
(paren
id|args-&gt;dp
comma
id|save_blk-&gt;bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Top-level node form directory addname routine.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_node_addname
id|xfs_dir2_node_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
multiline_comment|/* leaf block for insert */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|rval
suffix:semicolon
multiline_comment|/* sub-return value */
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
multiline_comment|/* btree cursor */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;node_addname&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the state (btree cursor).&n;&t; */
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_dirblksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the name.  We&squot;re not supposed to find it, but&n;&t; * this gives us the insertion point.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|rval
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_ne
id|ENOENT
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Add the data entry to a data block.&n;&t; * Extravalid is set to a freeblock found by lookup.&n;&t; */
id|rval
op_assign
id|xfs_dir2_node_addname_int
c_func
(paren
id|args
comma
id|state-&gt;extravalid
ques
c_cond
op_amp
id|state-&gt;extrablk
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Add the new leaf entry.&n;&t; */
id|rval
op_assign
id|xfs_dir2_leafn_add
c_func
(paren
id|blk-&gt;bp
comma
id|args
comma
id|blk-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * It worked, fix the hash values up the btree.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|args-&gt;justcheck
)paren
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * It didn&squot;t work, we need to split the leaf block.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;total
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|rval
op_eq
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Split the leaf block and insert the new entry.&n;&t;&t; */
id|rval
op_assign
id|xfs_da_split
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the data entry for a node-format directory name addition.&n; * The leaf entry is added in xfs_dir2_leafn_add.&n; * We may enter with a freespace block that the lookup found.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_node_addname_int
id|xfs_dir2_node_addname_int
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_da_state_blk_t
op_star
id|fblk
)paren
multiline_comment|/* optional freespace block */
(brace
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
multiline_comment|/* data block structure */
id|xfs_dir2_db_t
id|dbno
suffix:semicolon
multiline_comment|/* data block number */
id|xfs_dabuf_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* data block buffer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry pointer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* data unused entry pointer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_dir2_db_t
id|fbno
suffix:semicolon
multiline_comment|/* freespace block number */
id|xfs_dabuf_t
op_star
id|fbp
suffix:semicolon
multiline_comment|/* freespace buffer */
r_int
id|findex
suffix:semicolon
multiline_comment|/* freespace entry index */
id|xfs_dir2_db_t
id|foundbno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* found freespace block no */
r_int
id|foundindex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* found freespace entry idx */
id|xfs_dir2_free_t
op_star
id|free
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* freespace block structure */
id|xfs_dir2_db_t
id|ifbno
suffix:semicolon
multiline_comment|/* initial freespace block no */
id|xfs_dir2_db_t
id|lastfbno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* highest freespace block no */
r_int
id|length
suffix:semicolon
multiline_comment|/* length of the new entry */
r_int
id|logfree
suffix:semicolon
multiline_comment|/* need to log free entry */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log data header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to rescan data frees */
id|xfs_dir2_data_off_t
op_star
id|tagp
suffix:semicolon
multiline_comment|/* data entry tag pointer */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|length
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we came in with a freespace block that means that lookup&n;&t; * found an entry with our hash value.&t;This is the freespace&n;&t; * block for that data entry.&n;&t; */
r_if
c_cond
(paren
id|fblk
)paren
(brace
id|fbp
op_assign
id|fblk-&gt;bp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remember initial freespace block number.&n;&t;&t; */
id|ifbno
op_assign
id|fblk-&gt;blkno
suffix:semicolon
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|findex
op_assign
id|fblk-&gt;index
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This means the free entry showed that the data block had&n;&t;&t; * space for our entry, so we remembered it.&n;&t;&t; * Use that data block.&n;&t;&t; */
r_if
c_cond
(paren
id|findex
op_ge
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|findex
OL
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDATAOFF
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
)paren
op_ge
id|length
)paren
suffix:semicolon
id|dbno
op_assign
id|INT_GET
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
op_plus
id|findex
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The data block looked at didn&squot;t have enough room.&n;&t;&t; * We&squot;ll start at the beginning of the freespace entries.&n;&t;&t; */
r_else
(brace
id|dbno
op_assign
op_minus
l_int|1
suffix:semicolon
id|findex
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Didn&squot;t come in with a freespace block, so don&squot;t have a data block.&n;&t; */
r_else
(brace
id|ifbno
op_assign
id|dbno
op_assign
op_minus
l_int|1
suffix:semicolon
id|fbp
op_assign
l_int|NULL
suffix:semicolon
id|findex
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we don&squot;t have a data block yet, we&squot;re going to scan the&n;&t; * freespace blocks looking for one.  Figure out what the&n;&t; * highest freespace block number is.&n;&t; */
r_if
c_cond
(paren
id|dbno
op_eq
op_minus
l_int|1
)paren
(brace
id|xfs_fileoff_t
id|fo
suffix:semicolon
multiline_comment|/* freespace block number */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_last_offset
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|fo
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|lastfbno
op_assign
id|XFS_DIR2_DA_TO_DB
c_func
(paren
id|mp
comma
(paren
id|xfs_dablk_t
)paren
id|fo
)paren
suffix:semicolon
id|fbno
op_assign
id|ifbno
suffix:semicolon
id|foundindex
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * While we haven&squot;t identified a data block, search the freeblock&n;&t; * data for a good data block.&t;If we find a null freeblock entry,&n;&t; * indicating a hole in the data blocks, remember that.&n;&t; */
r_while
c_loop
(paren
id|dbno
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we don&squot;t have a freeblock in hand, get the next one.&n;&t;&t; */
r_if
c_cond
(paren
id|fbp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Happens the first time through unless lookup gave&n;&t;&t;&t; * us a freespace block to start with.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_increment
id|fbno
op_eq
l_int|0
)paren
id|fbno
op_assign
id|XFS_DIR2_FREE_FIRSTDB
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If it&squot;s ifbno we already looked at it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fbno
op_eq
id|ifbno
)paren
id|fbno
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If it&squot;s off the end we&squot;re done.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fbno
op_ge
id|lastfbno
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Read the block.  There can be holes in the&n;&t;&t;&t; * freespace blocks, so this might not succeed.&n;&t;&t;&t; * This should be really rare, so there&squot;s no reason&n;&t;&t;&t; * to avoid it.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|fbno
)paren
comma
op_minus
l_int|1
comma
op_amp
id|fbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fbp
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|findex
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Look at the current free entry.  Is it good enough?&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDATAOFF
op_logical_and
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
)paren
op_ge
id|length
)paren
id|dbno
op_assign
id|INT_GET
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
)paren
op_plus
id|findex
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If we haven&squot;t found an empty entry yet, and this&n;&t;&t;&t; * one is empty, remember this slot.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|foundindex
op_eq
op_minus
l_int|1
op_logical_and
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDATAOFF
)paren
(brace
id|foundindex
op_assign
id|findex
suffix:semicolon
id|foundbno
op_assign
id|fbno
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Are we done with the freeblock?&n;&t;&t;&t; */
r_if
c_cond
(paren
op_increment
id|findex
op_eq
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If there is space left in this freeblock,&n;&t;&t;&t;&t; * and we don&squot;t have an empty entry yet,&n;&t;&t;&t;&t; * remember this slot.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|foundindex
op_eq
op_minus
l_int|1
op_logical_and
id|findex
OL
id|XFS_DIR2_MAX_FREE_BESTS
c_func
(paren
id|mp
)paren
)paren
(brace
id|foundindex
op_assign
id|findex
suffix:semicolon
id|foundbno
op_assign
id|fbno
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Drop the block.&n;&t;&t;&t;&t; */
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|fbp
)paren
suffix:semicolon
id|fbp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fblk
op_logical_and
id|fblk-&gt;bp
)paren
id|fblk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If we don&squot;t have a data block, and there&squot;s no free slot in a&n;&t; * freeblock, we need to add a new freeblock.&n;&t; */
r_if
c_cond
(paren
id|dbno
op_eq
op_minus
l_int|1
op_logical_and
id|foundindex
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Not allowed to allocate, so return failure.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
op_logical_or
id|args-&gt;total
op_eq
l_int|0
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Add the new freeblock.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_grow_inode
c_func
(paren
id|args
comma
id|XFS_DIR2_FREE_SPACE
comma
op_amp
id|fbno
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Get a buffer for the new block.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|fbno
)paren
comma
op_minus
l_int|1
comma
op_amp
id|fbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|fbp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the new block to be empty, and remember&n;&t;&t; * its first slot as our empty slot.&n;&t;&t; */
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|INT_SET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|free-&gt;hdr.firstdb
comma
id|ARCH_CONVERT
comma
(paren
id|fbno
op_minus
id|XFS_DIR2_FREE_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
op_star
id|XFS_DIR2_MAX_FREE_BESTS
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|free-&gt;hdr.nused
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|foundindex
op_assign
l_int|0
suffix:semicolon
id|foundbno
op_assign
id|fbno
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we don&squot;t have a data block, and we don&squot;t have a freeblock buffer&n;&t; * in hand (we dropped the one with the free slot in it),&n;&t; * go read the freeblock again.&n;&t; */
r_if
c_cond
(paren
id|dbno
op_eq
op_minus
l_int|1
op_logical_and
id|fbp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re going to use the empty slot we found before.&n;&t;&t; */
id|findex
op_assign
id|foundindex
suffix:semicolon
id|fbno
op_assign
id|foundbno
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|fbno
)paren
comma
op_minus
l_int|1
comma
op_amp
id|fbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|fbp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we don&squot;t have a data block, we need to allocate one and make&n;&t; * the freespace entries refer to it.&n;&t; */
r_if
c_cond
(paren
id|dbno
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Not allowed to allocate, return failure.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
op_logical_or
id|args-&gt;total
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Drop the freespace buffer unless it came from our&n;&t;&t;&t; * caller.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fblk
op_eq
l_int|NULL
op_logical_or
id|fblk-&gt;bp
op_eq
l_int|NULL
)paren
id|xfs_da_buf_done
c_func
(paren
id|fbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Allocate and initialize the new data block.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_grow_inode
c_func
(paren
id|args
comma
id|XFS_DIR2_DATA_SPACE
comma
op_amp
id|dbno
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|xfs_dir2_data_init
c_func
(paren
id|args
comma
id|dbno
comma
op_amp
id|dbp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Drop the freespace buffer unless it came from our&n;&t;&t;&t; * caller.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fblk
op_eq
l_int|NULL
op_logical_or
id|fblk-&gt;bp
op_eq
l_int|NULL
)paren
id|xfs_da_buf_done
c_func
(paren
id|fbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the freespace entry for this data block is not in the&n;&t;&t; * freespace block we have in hand, drop the one we have&n;&t;&t; * and get the right one.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_DIR2_DB_TO_FDB
c_func
(paren
id|mp
comma
id|dbno
)paren
op_ne
id|fbno
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|fbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fblk
op_logical_and
id|fblk-&gt;bp
)paren
id|fblk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
id|fbno
op_assign
id|XFS_DIR2_DB_TO_FDB
c_func
(paren
id|mp
comma
id|dbno
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|fbno
)paren
comma
op_minus
l_int|1
comma
op_amp
id|fbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|fbp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|free
op_assign
id|fbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Set the freespace block index from the data block number.&n;&t;&t; */
id|findex
op_assign
id|XFS_DIR2_DB_TO_FDINDEX
c_func
(paren
id|mp
comma
id|dbno
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s after the end of the current entries in the&n;&t;&t; * freespace block, extend that table.&n;&t;&t; */
r_if
c_cond
(paren
id|findex
op_ge
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|findex
OL
id|XFS_DIR2_MAX_FREE_BESTS
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|free-&gt;hdr.nvalid
comma
id|ARCH_CONVERT
comma
id|findex
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Tag new entry so nused will go up.&n;&t;&t;&t; */
id|INT_SET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
comma
id|NULLDATAOFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If this entry was for an empty data block&n;&t;&t; * (this should always be true) then update the header.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDATAOFF
)paren
(brace
id|INT_MOD
c_func
(paren
id|free-&gt;hdr.nused
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_free_log_header
c_func
(paren
id|tp
comma
id|fbp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update the real value in the table.&n;&t;&t; * We haven&squot;t allocated the data entry yet so this will&n;&t;&t; * change again.&n;&t;&t; */
id|data
op_assign
id|dbp-&gt;data
suffix:semicolon
id|INT_COPY
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|logfree
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We had a data block so we don&squot;t have to make a new one.&n;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t; * If just checking, we succeeded.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
)paren
(brace
r_if
c_cond
(paren
id|fblk
op_eq
l_int|NULL
op_logical_or
id|fblk-&gt;bp
op_eq
l_int|NULL
)paren
id|xfs_da_buf_done
c_func
(paren
id|fbp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Read the data block in.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|dbno
)paren
comma
op_minus
l_int|1
comma
op_amp
id|dbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|fblk
op_eq
l_int|NULL
op_logical_or
id|fblk-&gt;bp
op_eq
l_int|NULL
)paren
id|xfs_da_buf_done
c_func
(paren
id|fbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|data
op_assign
id|dbp-&gt;data
suffix:semicolon
id|logfree
op_assign
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_ge
id|length
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the existing unused space.&n;&t; */
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|data
op_plus
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|needscan
op_assign
id|needlog
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the first part of the unused space, inuse for us.&n;&t; */
id|xfs_dir2_data_use_free
c_func
(paren
id|tp
comma
id|dbp
comma
id|dup
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|data
)paren
comma
id|length
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the new entry and log it.&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|dup
suffix:semicolon
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|args-&gt;inumber
)paren
suffix:semicolon
id|dep-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|dep-&gt;name
comma
id|args-&gt;name
comma
id|dep-&gt;namelen
)paren
suffix:semicolon
id|tagp
op_assign
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|data
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|tp
comma
id|dbp
comma
id|dep
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Rescan the block for bestfree if needed.&n;&t; */
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
id|data
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log the data block header if needed.&n;&t; */
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the freespace entry is now wrong, update it.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|ARCH_CONVERT
)paren
op_ne
id|INT_GET
c_func
(paren
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|INT_COPY
c_func
(paren
id|free-&gt;bests
(braket
id|findex
)braket
comma
id|data-&gt;hdr.bestfree
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|logfree
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Log the freespace entry if needed.&n;&t; */
r_if
c_cond
(paren
id|logfree
)paren
id|xfs_dir2_free_log_bests
c_func
(paren
id|tp
comma
id|fbp
comma
id|findex
comma
id|findex
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the caller didn&squot;t hand us the freespace block, drop it.&n;&t; */
r_if
c_cond
(paren
id|fblk
op_eq
l_int|NULL
op_logical_or
id|fblk-&gt;bp
op_eq
l_int|NULL
)paren
id|xfs_da_buf_done
c_func
(paren
id|fbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return the data block and offset in args, then drop the data block.&n;&t; */
id|args-&gt;blkno
op_assign
(paren
id|xfs_dablk_t
)paren
id|dbno
suffix:semicolon
id|args-&gt;index
op_assign
id|INT_GET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup an entry in a node-format directory.&n; * All the real work happens in xfs_da_node_lookup_int.&n; * The only real output is the inode number of the entry.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_node_lookup
id|xfs_dir2_node_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* btree level */
r_int
id|rval
suffix:semicolon
multiline_comment|/* operation return value */
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
multiline_comment|/* btree cursor */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;node_lookup&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the btree cursor.&n;&t; */
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_dirblksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the path to the entry in the cursor.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|rval
op_assign
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Release the btree blocks and leaf block.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;path.active
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release the data block if we have it.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;extravalid
op_logical_and
id|state-&gt;extrablk.bp
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;extrablk.bp
)paren
suffix:semicolon
id|state-&gt;extrablk.bp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from a node-format directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_node_removename
id|xfs_dir2_node_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
multiline_comment|/* leaf block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|rval
suffix:semicolon
multiline_comment|/* operation return value */
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
multiline_comment|/* btree cursor */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;node_removename&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the btree cursor.&n;&t; */
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_dirblksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the entry we&squot;re deleting, set up the cursor.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|rval
op_assign
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find it, upper layer screwed up.&n;&t; */
r_if
c_cond
(paren
id|rval
op_ne
id|EEXIST
)paren
(brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|state-&gt;extravalid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove the leaf and data entries.&n;&t; * Extrablk refers to the data block.&n;&t; */
id|error
op_assign
id|xfs_dir2_leafn_remove
c_func
(paren
id|args
comma
id|blk-&gt;bp
comma
id|blk-&gt;index
comma
op_amp
id|state-&gt;extrablk
comma
op_amp
id|rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fix the hash values up the btree.&n;&t; */
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we need to join leaf blocks, do it.&n;&t; */
r_if
c_cond
(paren
id|rval
op_logical_and
id|state-&gt;path.active
OG
l_int|1
)paren
id|error
op_assign
id|xfs_da_join
c_func
(paren
id|state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If no errors so far, try conversion to leaf format.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|xfs_dir2_node_to_leaf
c_func
(paren
id|state
)paren
suffix:semicolon
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace an entry&squot;s inode number in a node-format directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_node_replace
id|xfs_dir2_node_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
multiline_comment|/* leaf block */
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
multiline_comment|/* data block structure */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry changed */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* btree level */
id|xfs_ino_t
id|inum
suffix:semicolon
multiline_comment|/* new inode number */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry being changed */
r_int
id|rval
suffix:semicolon
multiline_comment|/* internal return value */
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
multiline_comment|/* btree cursor */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;node_replace&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the btree cursor.&n;&t; */
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_dirblksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
id|inum
op_assign
id|args-&gt;inumber
suffix:semicolon
multiline_comment|/*&n;&t; * Lookup the entry to change in the btree.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|rval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|rval
op_assign
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It should be found, since the vnodeops layer has looked it up&n;&t; * and locked it.  But paranoia is good.&n;&t; */
r_if
c_cond
(paren
id|rval
op_eq
id|EEXIST
)paren
(brace
multiline_comment|/*&n;&t;&t; * Find the leaf entry.&n;&t;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|leaf
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|lep
op_assign
op_amp
id|leaf-&gt;ents
(braket
id|blk-&gt;index
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|state-&gt;extravalid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Point to the data entry.&n;&t;&t; */
id|data
op_assign
id|state-&gt;extrablk.bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|data-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
)paren
suffix:semicolon
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|data
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|state-&gt;mp
comma
id|INT_GET
c_func
(paren
id|lep-&gt;address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|inum
op_ne
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fill in the new inode number and log the entry.&n;&t;&t; */
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|inum
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;extrablk.bp
comma
id|dep
)paren
suffix:semicolon
id|rval
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find it, and we&squot;re holding a data block.  Drop it.&n;&t; */
r_else
r_if
c_cond
(paren
id|state-&gt;extravalid
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;extrablk.bp
)paren
suffix:semicolon
id|state-&gt;extrablk.bp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release all the buffers in the cursor.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;path.active
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Trim off a trailing empty freespace block.&n; * Return (in rvalp) 1 if we did it, 0 if not.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_node_trim_free
id|xfs_dir2_node_trim_free
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_fileoff_t
id|fo
comma
multiline_comment|/* free block number */
r_int
op_star
id|rvalp
)paren
multiline_comment|/* out: did something */
(brace
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* freespace buffer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return code */
id|xfs_dir2_free_t
op_star
id|free
suffix:semicolon
multiline_comment|/* freespace structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * Read the freespace block.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
(paren
id|xfs_dablk_t
)paren
id|fo
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|free
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_FREE_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there are used entries, there&squot;s nothing to do.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.nused
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
op_star
id|rvalp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Blow the block away.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_shrink_inode
c_func
(paren
id|args
comma
id|XFS_DIR2_DA_TO_DB
c_func
(paren
id|mp
comma
(paren
id|xfs_dablk_t
)paren
id|fo
)paren
comma
id|bp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Can&squot;t fail with ENOSPC since that only happens with no&n;&t;&t; * space reservation, when breaking up an extent into two&n;&t;&t; * pieces.  This is the last block of an extent.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return that we succeeded.&n;&t; */
op_star
id|rvalp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
