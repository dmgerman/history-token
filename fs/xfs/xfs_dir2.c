multiline_comment|/*&n; * Copyright (c) 2000-2001 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * XFS v2 directory implmentation.&n; * Top-level and utility routines.&n; */
macro_line|#include &lt;xfs.h&gt;
multiline_comment|/*&n; * Declarations for interface routines.&n; */
r_static
r_void
id|xfs_dir2_mount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_isempty
c_func
(paren
id|xfs_inode_t
op_star
id|dp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_init
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_inode_t
op_star
id|pdp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_createname
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
id|inum
comma
id|xfs_fsblock_t
op_star
id|first
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_lookup
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
op_star
id|inum
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_removename
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
id|ino
comma
id|xfs_fsblock_t
op_star
id|first
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eofp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_replace
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
id|inum
comma
id|xfs_fsblock_t
op_star
id|first
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_canenter
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_shortform_validate_ondisk
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dinode_t
op_star
id|dip
)paren
suffix:semicolon
multiline_comment|/*&n; * Utility routine declarations.&n; */
r_static
r_int
id|xfs_dir2_put_dirent64_direct
c_func
(paren
id|xfs_dir2_put_args_t
op_star
id|pa
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_put_dirent64_uio
c_func
(paren
id|xfs_dir2_put_args_t
op_star
id|pa
)paren
suffix:semicolon
multiline_comment|/*&n; * Directory operations vector.&n; */
DECL|variable|xfsv2_dirops
id|xfs_dirops_t
id|xfsv2_dirops
op_assign
(brace
dot
id|xd_mount
op_assign
id|xfs_dir2_mount
comma
dot
id|xd_isempty
op_assign
id|xfs_dir2_isempty
comma
dot
id|xd_init
op_assign
id|xfs_dir2_init
comma
dot
id|xd_createname
op_assign
id|xfs_dir2_createname
comma
dot
id|xd_lookup
op_assign
id|xfs_dir2_lookup
comma
dot
id|xd_removename
op_assign
id|xfs_dir2_removename
comma
dot
id|xd_getdents
op_assign
id|xfs_dir2_getdents
comma
dot
id|xd_replace
op_assign
id|xfs_dir2_replace
comma
dot
id|xd_canenter
op_assign
id|xfs_dir2_canenter
comma
dot
id|xd_shortform_validate_ondisk
op_assign
id|xfs_dir2_shortform_validate_ondisk
comma
dot
id|xd_shortform_to_single
op_assign
id|xfs_dir2_sf_to_block
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Interface routines.&n; */
multiline_comment|/*&n; * Initialize directory-related fields in the mount structure.&n; */
r_static
r_void
DECL|function|xfs_dir2_mount
id|xfs_dir2_mount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
multiline_comment|/* filesystem mount point */
(brace
id|mp-&gt;m_dirversion
op_assign
l_int|2
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
l_int|1
op_lshift
(paren
id|mp-&gt;m_sb.sb_blocklog
op_plus
id|mp-&gt;m_sb.sb_dirblklog
)paren
)paren
op_le
id|XFS_MAX_BLOCKSIZE
)paren
suffix:semicolon
id|mp-&gt;m_dirblksize
op_assign
l_int|1
op_lshift
(paren
id|mp-&gt;m_sb.sb_blocklog
op_plus
id|mp-&gt;m_sb.sb_dirblklog
)paren
suffix:semicolon
id|mp-&gt;m_dirblkfsbs
op_assign
l_int|1
op_lshift
id|mp-&gt;m_sb.sb_dirblklog
suffix:semicolon
id|mp-&gt;m_dirdatablk
op_assign
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|XFS_DIR2_DATA_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|mp-&gt;m_dirleafblk
op_assign
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|XFS_DIR2_LEAF_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|mp-&gt;m_dirfreeblk
op_assign
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|XFS_DIR2_FREE_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|mp-&gt;m_attr_node_ents
op_assign
(paren
id|mp-&gt;m_sb.sb_blocksize
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_hdr_t
)paren
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|mp-&gt;m_dir_node_ents
op_assign
(paren
id|mp-&gt;m_dirblksize
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_hdr_t
)paren
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|mp-&gt;m_dir_magicpct
op_assign
(paren
id|mp-&gt;m_dirblksize
op_star
l_int|37
)paren
op_div
l_int|100
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 1 if directory contains only &quot;.&quot; and &quot;..&quot;.&n; */
r_static
r_int
multiline_comment|/* return code */
DECL|function|xfs_dir2_isempty
id|xfs_dir2_isempty
c_func
(paren
id|xfs_inode_t
op_star
id|dp
)paren
multiline_comment|/* incore inode structure */
(brace
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform directory structure */
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Might happen during shutdown.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
op_eq
l_int|0
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
r_return
id|INT_ISZERO
c_func
(paren
id|sfp-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a directory with its &quot;.&quot; and &quot;..&quot; entries.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_init
id|xfs_dir2_init
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
id|xfs_inode_t
op_star
id|pdp
)paren
multiline_comment|/* incore parent directory inode */
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.trans
op_assign
id|tp
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir_ino_validate
c_func
(paren
id|tp-&gt;t_mountp
comma
id|pdp-&gt;i_ino
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_return
id|xfs_dir2_sf_create
c_func
(paren
op_amp
id|args
comma
id|pdp-&gt;i_ino
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  Enter a name in a directory.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_createname
id|xfs_dir2_createname
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
r_char
op_star
id|name
comma
multiline_comment|/* new entry name */
r_int
id|namelen
comma
multiline_comment|/* new entry name length */
id|xfs_ino_t
id|inum
comma
multiline_comment|/* new entry inode number */
id|xfs_fsblock_t
op_star
id|first
comma
multiline_comment|/* bmap&squot;s firstblock */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* bmap&squot;s freeblock list */
id|xfs_extlen_t
id|total
)paren
multiline_comment|/* bmap&squot;s total block count */
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
r_int
id|v
suffix:semicolon
multiline_comment|/* type-checking value */
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir_ino_validate
c_func
(paren
id|tp-&gt;t_mountp
comma
id|inum
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_dir_create
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
id|inum
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|first
suffix:semicolon
id|args.flist
op_assign
id|flist
suffix:semicolon
id|args.total
op_assign
id|total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|tp
suffix:semicolon
id|args.justcheck
op_assign
l_int|0
suffix:semicolon
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
id|rval
op_assign
id|xfs_dir2_sf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isblock
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_block_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isleaf
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
id|rval
op_assign
id|xfs_dir2_node_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup a name in a directory, give back the inode number.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_lookup
id|xfs_dir2_lookup
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
r_char
op_star
id|name
comma
multiline_comment|/* lookup name */
r_int
id|namelen
comma
multiline_comment|/* lookup name length */
id|xfs_ino_t
op_star
id|inum
)paren
multiline_comment|/* out: inode number */
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
r_int
id|v
suffix:semicolon
multiline_comment|/* type-checking value */
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_dir_lookup
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
l_int|0
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
l_int|NULL
suffix:semicolon
id|args.flist
op_assign
l_int|NULL
suffix:semicolon
id|args.total
op_assign
l_int|0
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|tp
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
l_int|0
suffix:semicolon
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
id|rval
op_assign
id|xfs_dir2_sf_lookup
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isblock
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_block_lookup
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isleaf
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_leaf_lookup
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
id|rval
op_assign
id|xfs_dir2_node_lookup
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_eq
id|EEXIST
)paren
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rval
op_eq
l_int|0
)paren
op_star
id|inum
op_assign
id|args.inumber
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from a directory.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_removename
id|xfs_dir2_removename
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
r_char
op_star
id|name
comma
multiline_comment|/* name of entry to remove */
r_int
id|namelen
comma
multiline_comment|/* name length of entry to remove */
id|xfs_ino_t
id|ino
comma
multiline_comment|/* inode number of entry to remove */
id|xfs_fsblock_t
op_star
id|first
comma
multiline_comment|/* bmap&squot;s firstblock */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* bmap&squot;s freeblock list */
id|xfs_extlen_t
id|total
)paren
multiline_comment|/* bmap&squot;s total block count */
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
r_int
id|v
suffix:semicolon
multiline_comment|/* type-checking value */
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_dir_remove
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
id|ino
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|first
suffix:semicolon
id|args.flist
op_assign
id|flist
suffix:semicolon
id|args.total
op_assign
id|total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|tp
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
id|rval
op_assign
id|xfs_dir2_sf_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isblock
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_block_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isleaf
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_leaf_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
id|rval
op_assign
id|xfs_dir2_node_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a directory.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_getdents
id|xfs_dir2_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
id|uio_t
op_star
id|uio
comma
multiline_comment|/* caller&squot;s buffer control */
r_int
op_star
id|eofp
)paren
multiline_comment|/* out: eof reached */
(brace
r_int
id|alignment
suffix:semicolon
multiline_comment|/* alignment required for ABI */
id|xfs_dirent_t
op_star
id|dbp
suffix:semicolon
multiline_comment|/* malloc&squot;ed buffer */
id|xfs_dir2_put_t
id|put
suffix:semicolon
multiline_comment|/* entry formatting routine */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
r_int
id|v
suffix:semicolon
multiline_comment|/* type-checking value */
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_dir_getdents
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If our caller has given us a single contiguous aligned memory buffer,&n;&t; * just work directly within that buffer.  If it&squot;s in user memory,&n;&t; * lock it down first.&n;&t; */
id|alignment
op_assign
r_sizeof
(paren
id|xfs_off_t
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uio-&gt;uio_iovcnt
op_eq
l_int|1
)paren
op_logical_and
(paren
(paren
(paren
id|__psint_t
)paren
id|uio-&gt;uio_iov
(braket
l_int|0
)braket
dot
id|iov_base
op_amp
id|alignment
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|uio-&gt;uio_iov
(braket
l_int|0
)braket
dot
id|iov_len
op_amp
id|alignment
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|dbp
op_assign
l_int|NULL
suffix:semicolon
id|put
op_assign
id|xfs_dir2_put_dirent64_direct
suffix:semicolon
)brace
r_else
(brace
id|dbp
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|dbp
)paren
op_plus
id|MAXNAMELEN
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|put
op_assign
id|xfs_dir2_put_dirent64_uio
suffix:semicolon
)brace
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
id|rval
op_assign
id|xfs_dir2_sf_getdents
c_func
(paren
id|dp
comma
id|uio
comma
id|eofp
comma
id|dbp
comma
id|put
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isblock
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_block_getdents
c_func
(paren
id|tp
comma
id|dp
comma
id|uio
comma
id|eofp
comma
id|dbp
comma
id|put
)paren
suffix:semicolon
r_else
id|rval
op_assign
id|xfs_dir2_leaf_getdents
c_func
(paren
id|tp
comma
id|dp
comma
id|uio
comma
id|eofp
comma
id|dbp
comma
id|put
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dbp
op_ne
l_int|NULL
)paren
id|kmem_free
c_func
(paren
id|dbp
comma
r_sizeof
(paren
op_star
id|dbp
)paren
op_plus
id|MAXNAMELEN
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace the inode number of a directory entry.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_replace
id|xfs_dir2_replace
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
r_char
op_star
id|name
comma
multiline_comment|/* name of entry to replace */
r_int
id|namelen
comma
multiline_comment|/* name length of entry to replace */
id|xfs_ino_t
id|inum
comma
multiline_comment|/* new inode number */
id|xfs_fsblock_t
op_star
id|first
comma
multiline_comment|/* bmap&squot;s firstblock */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* bmap&squot;s freeblock list */
id|xfs_extlen_t
id|total
)paren
multiline_comment|/* bmap&squot;s total block count */
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
r_int
id|v
suffix:semicolon
multiline_comment|/* type-checking value */
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir_ino_validate
c_func
(paren
id|tp-&gt;t_mountp
comma
id|inum
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
id|inum
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|first
suffix:semicolon
id|args.flist
op_assign
id|flist
suffix:semicolon
id|args.total
op_assign
id|total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|tp
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
id|rval
op_assign
id|xfs_dir2_sf_replace
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isblock
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_block_replace
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isleaf
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_leaf_replace
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
id|rval
op_assign
id|xfs_dir2_node_replace
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * See if this entry can be added to the directory without allocating space.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_canenter
id|xfs_dir2_canenter
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
r_char
op_star
id|name
comma
multiline_comment|/* name of entry to add */
r_int
id|namelen
)paren
multiline_comment|/* name length of entry to add */
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
multiline_comment|/* operation arguments */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
r_int
id|v
suffix:semicolon
multiline_comment|/* type-checking value */
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
l_int|0
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
l_int|NULL
suffix:semicolon
id|args.flist
op_assign
l_int|NULL
suffix:semicolon
id|args.total
op_assign
l_int|0
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|tp
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
id|rval
op_assign
id|xfs_dir2_sf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isblock
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_block_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_dir2_isleaf
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|v
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|v
)paren
id|rval
op_assign
id|xfs_dir2_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_else
id|rval
op_assign
id|xfs_dir2_node_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Dummy routine for shortform inode validation.&n; * Can&squot;t really do this.&n; */
multiline_comment|/* ARGSUSED */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_shortform_validate_ondisk
id|xfs_dir2_shortform_validate_ondisk
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* filesystem mount point */
id|xfs_dinode_t
op_star
id|dip
)paren
multiline_comment|/* ondisk inode */
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Utility routines.&n; */
multiline_comment|/*&n; * Add a block to the directory.&n; * This routine is for data and free blocks, not leaf/node blocks&n; * which are handled by xfs_da_grow_inode.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_grow_inode
id|xfs_dir2_grow_inode
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
r_int
id|space
comma
multiline_comment|/* v2 dir&squot;s space XFS_DIR2_xxx_SPACE */
id|xfs_dir2_db_t
op_star
id|dbp
)paren
multiline_comment|/* out: block number added */
(brace
id|xfs_fileoff_t
id|bno
suffix:semicolon
multiline_comment|/* directory offset of new block */
r_int
id|count
suffix:semicolon
multiline_comment|/* count of filesystem blocks */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|got
suffix:semicolon
multiline_comment|/* blocks actually mapped */
r_int
id|i
suffix:semicolon
multiline_comment|/* temp mapping index */
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
multiline_comment|/* single structure for bmap */
r_int
id|mapi
suffix:semicolon
multiline_comment|/* mapping index */
id|xfs_bmbt_irec_t
op_star
id|mapp
suffix:semicolon
multiline_comment|/* bmap mapping structure(s) */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|nmap
suffix:semicolon
multiline_comment|/* number of bmap entries */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_s
c_func
(paren
l_string|&quot;grow_inode&quot;
comma
id|args
comma
id|space
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Set lowest possible block in the space requested.&n;&t; */
id|bno
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|space
op_star
id|XFS_DIR2_SPACE_SIZE
)paren
suffix:semicolon
id|count
op_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
multiline_comment|/*&n;&t; * Find the first hole for our block.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_first_unused
c_func
(paren
id|tp
comma
id|dp
comma
id|count
comma
op_amp
id|bno
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|nmap
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;firstblock
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try mapping the new block contiguously (one extent).&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|dp
comma
id|bno
comma
id|count
comma
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_METADATA
op_or
id|XFS_BMAPI_CONTIG
comma
id|args-&gt;firstblock
comma
id|args-&gt;total
comma
op_amp
id|map
comma
op_amp
id|nmap
comma
id|args-&gt;flist
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nmap
op_le
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Got it in 1.&n;&t; */
r_if
c_cond
(paren
id|nmap
op_eq
l_int|1
)paren
(brace
id|mapp
op_assign
op_amp
id|map
suffix:semicolon
id|mapi
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Didn&squot;t work and this is a multiple-fsb directory block.&n;&t; * Try again with contiguous flag turned on.&n;&t; */
r_else
r_if
c_cond
(paren
id|nmap
op_eq
l_int|0
op_logical_and
id|count
OG
l_int|1
)paren
(brace
id|xfs_fileoff_t
id|b
suffix:semicolon
multiline_comment|/* current file offset */
multiline_comment|/*&n;&t;&t; * Space for maximum number of mappings.&n;&t;&t; */
id|mapp
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
comma
id|KM_SLEEP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Iterate until we get to the end of our block.&n;&t;&t; */
r_for
c_loop
(paren
id|b
op_assign
id|bno
comma
id|mapi
op_assign
l_int|0
suffix:semicolon
id|b
OL
id|bno
op_plus
id|count
suffix:semicolon
)paren
(brace
r_int
id|c
suffix:semicolon
multiline_comment|/* current fsb count */
multiline_comment|/*&n;&t;&t;&t; * Can&squot;t map more than MAX_NMAP at once.&n;&t;&t;&t; */
id|nmap
op_assign
id|MIN
c_func
(paren
id|XFS_BMAP_MAX_NMAP
comma
id|count
)paren
suffix:semicolon
id|c
op_assign
(paren
r_int
)paren
(paren
id|bno
op_plus
id|count
op_minus
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|dp
comma
id|b
comma
id|c
comma
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_METADATA
comma
id|args-&gt;firstblock
comma
id|args-&gt;total
comma
op_amp
id|mapp
(braket
id|mapi
)braket
comma
op_amp
id|nmap
comma
id|args-&gt;flist
)paren
)paren
)paren
(brace
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nmap
OL
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Add this bunch into our table, go to the next offset.&n;&t;&t;&t; */
id|mapi
op_add_assign
id|nmap
suffix:semicolon
id|b
op_assign
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_blockcount
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Didn&squot;t work.&n;&t; */
r_else
(brace
id|mapi
op_assign
l_int|0
suffix:semicolon
id|mapp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * See how many fsb&squot;s we got.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|got
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mapi
suffix:semicolon
id|i
op_increment
)paren
id|got
op_add_assign
id|mapp
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
multiline_comment|/*&n;&t; * Didn&squot;t get enough fsb&squot;s, or the first/last block&squot;s are wrong.&n;&t; */
r_if
c_cond
(paren
id|got
op_ne
id|count
op_logical_or
id|mapp
(braket
l_int|0
)braket
dot
id|br_startoff
op_ne
id|bno
op_logical_or
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_blockcount
op_ne
id|bno
op_plus
id|count
)paren
(brace
r_if
c_cond
(paren
id|mapp
op_ne
op_amp
id|map
)paren
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Done with the temporary mapping table.&n;&t; */
r_if
c_cond
(paren
id|mapp
op_ne
op_amp
id|map
)paren
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
)paren
suffix:semicolon
op_star
id|dbp
op_assign
id|XFS_DIR2_DA_TO_DB
c_func
(paren
id|mp
comma
(paren
id|xfs_dablk_t
)paren
id|bno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update file&squot;s size if this is the data space and it grew.&n;&t; */
r_if
c_cond
(paren
id|space
op_eq
id|XFS_DIR2_DATA_SPACE
)paren
(brace
id|xfs_fsize_t
id|size
suffix:semicolon
multiline_comment|/* directory file (data) size */
id|size
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|bno
op_plus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|dp-&gt;i_d.di_size
)paren
(brace
id|dp-&gt;i_d.di_size
op_assign
id|size
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * See if the directory is a single-block form directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_isblock
id|xfs_dir2_isblock
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
r_int
op_star
id|vp
)paren
multiline_comment|/* out: 1 is block, 0 is not block */
(brace
id|xfs_fileoff_t
id|last
suffix:semicolon
multiline_comment|/* last file offset */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_bmap_last_offset
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|last
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
id|rval
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|last
)paren
op_eq
id|mp-&gt;m_dirblksize
suffix:semicolon
id|ASSERT
c_func
(paren
id|rval
op_eq
l_int|0
op_logical_or
id|dp-&gt;i_d.di_size
op_eq
id|mp-&gt;m_dirblksize
)paren
suffix:semicolon
op_star
id|vp
op_assign
id|rval
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * See if the directory is a single-leaf form directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_isleaf
id|xfs_dir2_isleaf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
r_int
op_star
id|vp
)paren
multiline_comment|/* out: 1 is leaf, 0 is not leaf */
(brace
id|xfs_fileoff_t
id|last
suffix:semicolon
multiline_comment|/* last file offset */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|xfs_bmap_last_offset
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|last
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|rval
suffix:semicolon
)brace
op_star
id|vp
op_assign
id|last
op_eq
id|mp-&gt;m_dirleafblk
op_plus
(paren
l_int|1
op_lshift
id|mp-&gt;m_sb.sb_dirblklog
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Getdents put routine for 64-bit ABI, direct form.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_put_dirent64_direct
id|xfs_dir2_put_dirent64_direct
c_func
(paren
id|xfs_dir2_put_args_t
op_star
id|pa
)paren
multiline_comment|/* argument bundle */
(brace
id|xfs_dirent_t
op_star
id|idbp
suffix:semicolon
multiline_comment|/* dirent pointer */
id|iovec_t
op_star
id|iovp
suffix:semicolon
multiline_comment|/* io vector */
r_int
id|namelen
suffix:semicolon
multiline_comment|/* entry name length */
r_int
id|reclen
suffix:semicolon
multiline_comment|/* entry total length */
id|uio_t
op_star
id|uio
suffix:semicolon
multiline_comment|/* I/O control */
id|namelen
op_assign
id|pa-&gt;namelen
suffix:semicolon
id|reclen
op_assign
id|DIRENTSIZE
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|uio
op_assign
id|pa-&gt;uio
suffix:semicolon
multiline_comment|/*&n;&t; * Won&squot;t fit in the remaining space.&n;&t; */
r_if
c_cond
(paren
id|reclen
OG
id|uio-&gt;uio_resid
)paren
(brace
id|pa-&gt;done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|iovp
op_assign
id|uio-&gt;uio_iov
suffix:semicolon
id|idbp
op_assign
(paren
id|xfs_dirent_t
op_star
)paren
id|iovp-&gt;iov_base
suffix:semicolon
id|iovp-&gt;iov_base
op_assign
(paren
r_char
op_star
)paren
id|idbp
op_plus
id|reclen
suffix:semicolon
id|iovp-&gt;iov_len
op_sub_assign
id|reclen
suffix:semicolon
id|uio-&gt;uio_resid
op_sub_assign
id|reclen
suffix:semicolon
id|idbp-&gt;d_reclen
op_assign
id|reclen
suffix:semicolon
id|idbp-&gt;d_ino
op_assign
id|pa-&gt;ino
suffix:semicolon
id|idbp-&gt;d_off
op_assign
id|pa-&gt;cook
suffix:semicolon
id|idbp-&gt;d_name
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pa-&gt;done
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|idbp-&gt;d_name
comma
id|pa-&gt;name
comma
id|namelen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Getdents put routine for 64-bit ABI, uio form.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_put_dirent64_uio
id|xfs_dir2_put_dirent64_uio
c_func
(paren
id|xfs_dir2_put_args_t
op_star
id|pa
)paren
multiline_comment|/* argument bundle */
(brace
id|xfs_dirent_t
op_star
id|idbp
suffix:semicolon
multiline_comment|/* dirent pointer */
r_int
id|namelen
suffix:semicolon
multiline_comment|/* entry name length */
r_int
id|reclen
suffix:semicolon
multiline_comment|/* entry total length */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value */
id|uio_t
op_star
id|uio
suffix:semicolon
multiline_comment|/* I/O control */
id|namelen
op_assign
id|pa-&gt;namelen
suffix:semicolon
id|reclen
op_assign
id|DIRENTSIZE
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|uio
op_assign
id|pa-&gt;uio
suffix:semicolon
multiline_comment|/*&n;&t; * Won&squot;t fit in the remaining space.&n;&t; */
r_if
c_cond
(paren
id|reclen
OG
id|uio-&gt;uio_resid
)paren
(brace
id|pa-&gt;done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|idbp
op_assign
id|pa-&gt;dbp
suffix:semicolon
id|idbp-&gt;d_reclen
op_assign
id|reclen
suffix:semicolon
id|idbp-&gt;d_ino
op_assign
id|pa-&gt;ino
suffix:semicolon
id|idbp-&gt;d_off
op_assign
id|pa-&gt;cook
suffix:semicolon
id|idbp-&gt;d_name
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|memcpy
c_func
(paren
id|idbp-&gt;d_name
comma
id|pa-&gt;name
comma
id|namelen
)paren
suffix:semicolon
id|rval
op_assign
id|uiomove
c_func
(paren
(paren
id|caddr_t
)paren
id|idbp
comma
id|reclen
comma
id|UIO_READ
comma
id|uio
)paren
suffix:semicolon
id|pa-&gt;done
op_assign
(paren
id|rval
op_eq
l_int|0
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove the given block from the directory.&n; * This routine is used for data and free blocks, leaf/node are done&n; * by xfs_da_shrink_inode.&n; */
r_int
DECL|function|xfs_dir2_shrink_inode
id|xfs_dir2_shrink_inode
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dir2_db_t
id|db
comma
multiline_comment|/* directory block number */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* block&squot;s buffer */
(brace
id|xfs_fileoff_t
id|bno
suffix:semicolon
multiline_comment|/* directory file offset */
id|xfs_dablk_t
id|da
suffix:semicolon
multiline_comment|/* directory file offset */
r_int
id|done
suffix:semicolon
multiline_comment|/* bunmap is finished */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_db
c_func
(paren
l_string|&quot;shrink_inode&quot;
comma
id|args
comma
id|db
comma
id|bp
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|da
op_assign
id|XFS_DIR2_DB_TO_DA
c_func
(paren
id|mp
comma
id|db
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Unmap the fsblock(s).&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bunmapi
c_func
(paren
id|tp
comma
id|dp
comma
id|da
comma
id|mp-&gt;m_dirblkfsbs
comma
id|XFS_BMAPI_METADATA
comma
l_int|0
comma
id|args-&gt;firstblock
comma
id|args-&gt;flist
comma
op_amp
id|done
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * ENOSPC actually can happen if we&squot;re in a removename with&n;&t;&t; * no space reservation, and the resulting block removal&n;&t;&t; * would cause a bmap btree split or conversion from extents&n;&t;&t; * to btree.  This can only happen for un-fragmented&n;&t;&t; * directory blocks, since you need to be punching out&n;&t;&t; * the middle of an extent.&n;&t;&t; * In this case we need to leave the block in the file,&n;&t;&t; * and not binval it.&n;&t;&t; * So the block has to be in a consistent empty state&n;&t;&t; * and appropriately logged.&n;&t;&t; * We don&squot;t free up the buffer, the caller can tell it&n;&t;&t; * hasn&squot;t happened since it got an error back.&n;&t;&t; */
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|done
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Invalidate the buffer from the transaction.&n;&t; */
id|xfs_da_binval
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s not a data block, we&squot;re done.&n;&t; */
r_if
c_cond
(paren
id|db
op_ge
id|XFS_DIR2_LEAF_FIRSTDB
c_func
(paren
id|mp
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the block isn&squot;t the last one in the directory, we&squot;re done.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OG
id|XFS_DIR2_DB_OFF_TO_BYTE
c_func
(paren
id|mp
comma
id|db
op_plus
l_int|1
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|bno
op_assign
id|da
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_last_before
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|bno
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This can&squot;t really happen unless there&squot;s kernel corruption.&n;&t;&t; */
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|db
op_eq
id|mp-&gt;m_dirdatablk
)paren
id|ASSERT
c_func
(paren
id|bno
op_eq
l_int|0
)paren
suffix:semicolon
r_else
id|ASSERT
c_func
(paren
id|bno
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the size to the new last block.&n;&t; */
id|dp-&gt;i_d.di_size
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|bno
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
