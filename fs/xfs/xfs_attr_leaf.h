multiline_comment|/*&n; * Copyright (c) 2000, 2002-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#ifndef __XFS_ATTR_LEAF_H__
DECL|macro|__XFS_ATTR_LEAF_H__
mdefine_line|#define&t;__XFS_ATTR_LEAF_H__
multiline_comment|/*&n; * Attribute storage layout, internal structure, access macros, etc.&n; *&n; * Attribute lists are structured around Btrees where all the data&n; * elements are in the leaf nodes.  Attribute names are hashed into an int,&n; * then that int is used as the index into the Btree.  Since the hashval&n; * of an attribute name may not be unique, we may have duplicate keys.  The&n; * internal links in the Btree are logical block offsets into the file.&n; */
r_struct
id|attrlist
suffix:semicolon
r_struct
id|attrlist_cursor_kern
suffix:semicolon
r_struct
id|attrnames
suffix:semicolon
r_struct
id|xfs_dabuf
suffix:semicolon
r_struct
id|xfs_da_args
suffix:semicolon
r_struct
id|xfs_da_state
suffix:semicolon
r_struct
id|xfs_da_state_blk
suffix:semicolon
r_struct
id|xfs_inode
suffix:semicolon
r_struct
id|xfs_trans
suffix:semicolon
multiline_comment|/*========================================================================&n; * Attribute structure when equal to XFS_LBSIZE(mp) bytes.&n; *========================================================================*/
multiline_comment|/*&n; * This is the structure of the leaf nodes in the Btree.&n; *&n; * Struct leaf_entry&squot;s are packed from the top.  Name/values grow from the&n; * bottom but are not packed.  The freemap contains run-length-encoded entries&n; * for the free bytes after the leaf_entry&squot;s, but only the N largest such,&n; * smaller runs are dropped.  When the freemap doesn&squot;t show enough space&n; * for an allocation, we compact the name/value area and try again.  If we&n; * still don&squot;t have enough space, then we have to split the block.  The&n; * name/value structs (both local and remote versions) must be 32bit aligned.&n; *&n; * Since we have duplicate hash keys, for each key that matches, compare&n; * the actual name string.  The root and intermediate node search always&n; * takes the first-in-the-block key match found, so we should only have&n; * to work &quot;forw&quot;ard.  If none matches, continue with the &quot;forw&quot;ard leaf&n; * nodes until the hash key changes or the attribute name is found.&n; *&n; * We store the fact that an attribute is a ROOT/USER/SECURE attribute in&n; * the leaf_entry.  The namespaces are independent only because we also look&n; * at the namespace bit when we are looking for a matching attribute name.&n; *&n; * We also store a &quot;incomplete&quot; bit in the leaf_entry.  It shows that an&n; * attribute is in the middle of being created and should not be shown to&n; * the user if we crash during the time that the bit is set.  We clear the&n; * bit when we have finished setting up the attribute.  We do this because&n; * we cannot create some large attributes inside a single transaction, and we&n; * need some indication that we weren&squot;t finished if we crash in the middle.&n; */
DECL|macro|XFS_ATTR_LEAF_MAPSIZE
mdefine_line|#define XFS_ATTR_LEAF_MAPSIZE&t;3&t;/* how many freespace slots */
DECL|struct|xfs_attr_leafblock
r_typedef
r_struct
id|xfs_attr_leafblock
(brace
DECL|struct|xfs_attr_leaf_hdr
r_struct
id|xfs_attr_leaf_hdr
(brace
multiline_comment|/* constant-structure header block */
DECL|member|info
id|xfs_da_blkinfo_t
id|info
suffix:semicolon
multiline_comment|/* block type, links, etc. */
DECL|member|count
id|__uint16_t
id|count
suffix:semicolon
multiline_comment|/* count of active leaf_entry&squot;s */
DECL|member|usedbytes
id|__uint16_t
id|usedbytes
suffix:semicolon
multiline_comment|/* num bytes of names/values stored */
DECL|member|firstused
id|__uint16_t
id|firstused
suffix:semicolon
multiline_comment|/* first used byte in name area */
DECL|member|holes
id|__uint8_t
id|holes
suffix:semicolon
multiline_comment|/* != 0 if blk needs compaction */
DECL|member|pad1
id|__uint8_t
id|pad1
suffix:semicolon
DECL|struct|xfs_attr_leaf_map
r_struct
id|xfs_attr_leaf_map
(brace
multiline_comment|/* RLE map of free bytes */
DECL|member|base
id|__uint16_t
id|base
suffix:semicolon
multiline_comment|/* base of free region */
DECL|member|size
id|__uint16_t
id|size
suffix:semicolon
multiline_comment|/* length of free region */
DECL|member|freemap
)brace
id|freemap
(braket
id|XFS_ATTR_LEAF_MAPSIZE
)braket
suffix:semicolon
multiline_comment|/* N largest free regions */
DECL|member|hdr
)brace
id|hdr
suffix:semicolon
DECL|struct|xfs_attr_leaf_entry
r_struct
id|xfs_attr_leaf_entry
(brace
multiline_comment|/* sorted on key, not name */
DECL|member|hashval
id|xfs_dahash_t
id|hashval
suffix:semicolon
multiline_comment|/* hash value of name */
DECL|member|nameidx
id|__uint16_t
id|nameidx
suffix:semicolon
multiline_comment|/* index into buffer of name/value */
DECL|member|flags
id|__uint8_t
id|flags
suffix:semicolon
multiline_comment|/* LOCAL/ROOT/SECURE/INCOMPLETE flag */
DECL|member|pad2
id|__uint8_t
id|pad2
suffix:semicolon
multiline_comment|/* unused pad byte */
DECL|member|entries
)brace
id|entries
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* variable sized array */
DECL|struct|xfs_attr_leaf_name_local
r_struct
id|xfs_attr_leaf_name_local
(brace
DECL|member|valuelen
id|__uint16_t
id|valuelen
suffix:semicolon
multiline_comment|/* number of bytes in value */
DECL|member|namelen
id|__uint8_t
id|namelen
suffix:semicolon
multiline_comment|/* length of name bytes */
DECL|member|nameval
id|__uint8_t
id|nameval
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* name/value bytes */
DECL|member|namelist
)brace
id|namelist
suffix:semicolon
multiline_comment|/* grows from bottom of buf */
DECL|struct|xfs_attr_leaf_name_remote
r_struct
id|xfs_attr_leaf_name_remote
(brace
DECL|member|valueblk
id|xfs_dablk_t
id|valueblk
suffix:semicolon
multiline_comment|/* block number of value bytes */
DECL|member|valuelen
id|__uint32_t
id|valuelen
suffix:semicolon
multiline_comment|/* number of bytes in value */
DECL|member|namelen
id|__uint8_t
id|namelen
suffix:semicolon
multiline_comment|/* length of name bytes */
DECL|member|name
id|__uint8_t
id|name
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* name bytes */
DECL|member|valuelist
)brace
id|valuelist
suffix:semicolon
multiline_comment|/* grows from bottom of buf */
DECL|typedef|xfs_attr_leafblock_t
)brace
id|xfs_attr_leafblock_t
suffix:semicolon
DECL|typedef|xfs_attr_leaf_hdr_t
r_typedef
r_struct
id|xfs_attr_leaf_hdr
id|xfs_attr_leaf_hdr_t
suffix:semicolon
DECL|typedef|xfs_attr_leaf_map_t
r_typedef
r_struct
id|xfs_attr_leaf_map
id|xfs_attr_leaf_map_t
suffix:semicolon
DECL|typedef|xfs_attr_leaf_entry_t
r_typedef
r_struct
id|xfs_attr_leaf_entry
id|xfs_attr_leaf_entry_t
suffix:semicolon
DECL|typedef|xfs_attr_leaf_name_local_t
r_typedef
r_struct
id|xfs_attr_leaf_name_local
id|xfs_attr_leaf_name_local_t
suffix:semicolon
DECL|typedef|xfs_attr_leaf_name_remote_t
r_typedef
r_struct
id|xfs_attr_leaf_name_remote
id|xfs_attr_leaf_name_remote_t
suffix:semicolon
multiline_comment|/*&n; * Flags used in the leaf_entry[i].flags field.&n; * NOTE: the INCOMPLETE bit must not collide with the flags bits specified&n; * on the system call, they are &quot;or&quot;ed together for various operations.&n; */
DECL|macro|XFS_ATTR_LOCAL_BIT
mdefine_line|#define&t;XFS_ATTR_LOCAL_BIT&t;0&t;/* attr is stored locally */
DECL|macro|XFS_ATTR_ROOT_BIT
mdefine_line|#define&t;XFS_ATTR_ROOT_BIT&t;1&t;/* limit access to trusted attrs */
DECL|macro|XFS_ATTR_SECURE_BIT
mdefine_line|#define&t;XFS_ATTR_SECURE_BIT&t;2&t;/* limit access to secure attrs */
DECL|macro|XFS_ATTR_INCOMPLETE_BIT
mdefine_line|#define&t;XFS_ATTR_INCOMPLETE_BIT&t;7&t;/* attr in middle of create/delete */
DECL|macro|XFS_ATTR_LOCAL
mdefine_line|#define XFS_ATTR_LOCAL&t;&t;(1 &lt;&lt; XFS_ATTR_LOCAL_BIT)
DECL|macro|XFS_ATTR_ROOT
mdefine_line|#define XFS_ATTR_ROOT&t;&t;(1 &lt;&lt; XFS_ATTR_ROOT_BIT)
DECL|macro|XFS_ATTR_SECURE
mdefine_line|#define XFS_ATTR_SECURE&t;&t;(1 &lt;&lt; XFS_ATTR_SECURE_BIT)
DECL|macro|XFS_ATTR_INCOMPLETE
mdefine_line|#define XFS_ATTR_INCOMPLETE&t;(1 &lt;&lt; XFS_ATTR_INCOMPLETE_BIT)
multiline_comment|/*&n; * Alignment for namelist and valuelist entries (since they are mixed&n; * there can be only one alignment value)&n; */
DECL|macro|XFS_ATTR_LEAF_NAME_ALIGN
mdefine_line|#define&t;XFS_ATTR_LEAF_NAME_ALIGN&t;((uint)sizeof(xfs_dablk_t))
multiline_comment|/*&n; * Cast typed pointers for &quot;local&quot; and &quot;remote&quot; name/value structs.&n; */
macro_line|#if XFS_WANT_FUNCS || (XFS_WANT_SPACE &amp;&amp; XFSSO_XFS_ATTR_LEAF_NAME_REMOTE)
id|xfs_attr_leaf_name_remote_t
op_star
id|xfs_attr_leaf_name_remote
c_func
(paren
id|xfs_attr_leafblock_t
op_star
id|leafp
comma
r_int
id|idx
)paren
suffix:semicolon
DECL|macro|XFS_ATTR_LEAF_NAME_REMOTE
mdefine_line|#define XFS_ATTR_LEAF_NAME_REMOTE(leafp,idx)&t;&bslash;&n;&t;xfs_attr_leaf_name_remote(leafp,idx)
macro_line|#else
DECL|macro|XFS_ATTR_LEAF_NAME_REMOTE
mdefine_line|#define XFS_ATTR_LEAF_NAME_REMOTE(leafp,idx)&t;/* remote name struct ptr */ &bslash;&n;&t;((xfs_attr_leaf_name_remote_t *)&t;&t;&bslash;&n;&t; &amp;((char *)(leafp))[ INT_GET((leafp)-&gt;entries[idx].nameidx, ARCH_CONVERT) ])
macro_line|#endif
macro_line|#if XFS_WANT_FUNCS || (XFS_WANT_SPACE &amp;&amp; XFSSO_XFS_ATTR_LEAF_NAME_LOCAL)
id|xfs_attr_leaf_name_local_t
op_star
id|xfs_attr_leaf_name_local
c_func
(paren
id|xfs_attr_leafblock_t
op_star
id|leafp
comma
r_int
id|idx
)paren
suffix:semicolon
DECL|macro|XFS_ATTR_LEAF_NAME_LOCAL
mdefine_line|#define XFS_ATTR_LEAF_NAME_LOCAL(leafp,idx)&t;&bslash;&n;&t;xfs_attr_leaf_name_local(leafp,idx)
macro_line|#else
DECL|macro|XFS_ATTR_LEAF_NAME_LOCAL
mdefine_line|#define XFS_ATTR_LEAF_NAME_LOCAL(leafp,idx)&t;/* local name struct ptr */ &bslash;&n;&t;((xfs_attr_leaf_name_local_t *)&t;&t;&bslash;&n;&t; &amp;((char *)(leafp))[ INT_GET((leafp)-&gt;entries[idx].nameidx, ARCH_CONVERT) ])
macro_line|#endif
macro_line|#if XFS_WANT_FUNCS || (XFS_WANT_SPACE &amp;&amp; XFSSO_XFS_ATTR_LEAF_NAME)
r_char
op_star
id|xfs_attr_leaf_name
c_func
(paren
id|xfs_attr_leafblock_t
op_star
id|leafp
comma
r_int
id|idx
)paren
suffix:semicolon
DECL|macro|XFS_ATTR_LEAF_NAME
mdefine_line|#define XFS_ATTR_LEAF_NAME(leafp,idx)&t;&t;xfs_attr_leaf_name(leafp,idx)
macro_line|#else
DECL|macro|XFS_ATTR_LEAF_NAME
mdefine_line|#define XFS_ATTR_LEAF_NAME(leafp,idx)&t;&t;/* generic name struct ptr */ &bslash;&n;&t;(&amp;((char *)(leafp))[ INT_GET((leafp)-&gt;entries[idx].nameidx, ARCH_CONVERT) ])
macro_line|#endif
multiline_comment|/*&n; * Calculate total bytes used (including trailing pad for alignment) for&n; * a &quot;local&quot; name/value structure, a &quot;remote&quot; name/value structure, and&n; * a pointer which might be either.&n; */
macro_line|#if XFS_WANT_FUNCS || (XFS_WANT_SPACE &amp;&amp; XFSSO_XFS_ATTR_LEAF_ENTSIZE_REMOTE)
r_int
id|xfs_attr_leaf_entsize_remote
c_func
(paren
r_int
id|nlen
)paren
suffix:semicolon
DECL|macro|XFS_ATTR_LEAF_ENTSIZE_REMOTE
mdefine_line|#define XFS_ATTR_LEAF_ENTSIZE_REMOTE(nlen)&t;&bslash;&n;&t;xfs_attr_leaf_entsize_remote(nlen)
macro_line|#else
DECL|macro|XFS_ATTR_LEAF_ENTSIZE_REMOTE
mdefine_line|#define XFS_ATTR_LEAF_ENTSIZE_REMOTE(nlen)&t;/* space for remote struct */ &bslash;&n;&t;(((uint)sizeof(xfs_attr_leaf_name_remote_t) - 1 + (nlen) + &bslash;&n;&t;  XFS_ATTR_LEAF_NAME_ALIGN - 1) &amp; ~(XFS_ATTR_LEAF_NAME_ALIGN - 1))
macro_line|#endif
macro_line|#if XFS_WANT_FUNCS || (XFS_WANT_SPACE &amp;&amp; XFSSO_XFS_ATTR_LEAF_ENTSIZE_LOCAL)
r_int
id|xfs_attr_leaf_entsize_local
c_func
(paren
r_int
id|nlen
comma
r_int
id|vlen
)paren
suffix:semicolon
DECL|macro|XFS_ATTR_LEAF_ENTSIZE_LOCAL
mdefine_line|#define XFS_ATTR_LEAF_ENTSIZE_LOCAL(nlen,vlen)&t;&bslash;&n;&t;xfs_attr_leaf_entsize_local(nlen,vlen)
macro_line|#else
DECL|macro|XFS_ATTR_LEAF_ENTSIZE_LOCAL
mdefine_line|#define XFS_ATTR_LEAF_ENTSIZE_LOCAL(nlen,vlen)&t;/* space for local struct */ &bslash;&n;&t;(((uint)sizeof(xfs_attr_leaf_name_local_t) - 1 + (nlen) + (vlen) + &bslash;&n;&t;  XFS_ATTR_LEAF_NAME_ALIGN - 1) &amp; ~(XFS_ATTR_LEAF_NAME_ALIGN - 1))
macro_line|#endif
macro_line|#if XFS_WANT_FUNCS || (XFS_WANT_SPACE &amp;&amp; XFSSO_XFS_ATTR_LEAF_ENTSIZE_LOCAL_MAX)
r_int
id|xfs_attr_leaf_entsize_local_max
c_func
(paren
r_int
id|bsize
)paren
suffix:semicolon
DECL|macro|XFS_ATTR_LEAF_ENTSIZE_LOCAL_MAX
mdefine_line|#define XFS_ATTR_LEAF_ENTSIZE_LOCAL_MAX(bsize)&t;&bslash;&n;&t;xfs_attr_leaf_entsize_local_max(bsize)
macro_line|#else
DECL|macro|XFS_ATTR_LEAF_ENTSIZE_LOCAL_MAX
mdefine_line|#define XFS_ATTR_LEAF_ENTSIZE_LOCAL_MAX(bsize)&t;/* max local struct size */ &bslash;&n;&t;(((bsize) &gt;&gt; 1) + ((bsize) &gt;&gt; 2))
macro_line|#endif
multiline_comment|/*========================================================================&n; * Structure used to pass context around among the routines.&n; *========================================================================*/
DECL|struct|xfs_attr_list_context
r_typedef
r_struct
id|xfs_attr_list_context
(brace
DECL|member|dp
r_struct
id|xfs_inode
op_star
id|dp
suffix:semicolon
multiline_comment|/* inode */
DECL|member|cursor
r_struct
id|attrlist_cursor_kern
op_star
id|cursor
suffix:semicolon
multiline_comment|/* position in list */
DECL|member|alist
r_struct
id|attrlist
op_star
id|alist
suffix:semicolon
multiline_comment|/* output buffer */
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* num used entries */
DECL|member|dupcnt
r_int
id|dupcnt
suffix:semicolon
multiline_comment|/* count dup hashvals seen */
DECL|member|bufsize
r_int
id|bufsize
suffix:semicolon
multiline_comment|/* total buffer size */
DECL|member|firstu
r_int
id|firstu
suffix:semicolon
multiline_comment|/* first used byte in buffer */
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* from VOP call */
DECL|member|resynch
r_int
id|resynch
suffix:semicolon
multiline_comment|/* T/F: resynch with cursor */
DECL|typedef|xfs_attr_list_context_t
)brace
id|xfs_attr_list_context_t
suffix:semicolon
multiline_comment|/*&n; * Used to keep a list of &quot;remote value&quot; extents when unlinking an inode.&n; */
DECL|struct|xfs_attr_inactive_list
r_typedef
r_struct
id|xfs_attr_inactive_list
(brace
DECL|member|valueblk
id|xfs_dablk_t
id|valueblk
suffix:semicolon
multiline_comment|/* block number of value bytes */
DECL|member|valuelen
r_int
id|valuelen
suffix:semicolon
multiline_comment|/* number of bytes in value */
DECL|typedef|xfs_attr_inactive_list_t
)brace
id|xfs_attr_inactive_list_t
suffix:semicolon
multiline_comment|/*========================================================================&n; * Function prototypes for the kernel.&n; *========================================================================*/
multiline_comment|/*&n; * Internal routines when dirsize &lt; XFS_LITINO(mp).&n; */
r_int
id|xfs_attr_shortform_create
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_add
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|add
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_lookup
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_getvalue
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_to_leaf
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_remove
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|remove
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_list
c_func
(paren
r_struct
id|xfs_attr_list_context
op_star
id|context
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_replace
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_shortform_allfit
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|bp
comma
r_struct
id|xfs_inode
op_star
id|dp
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal routines when dirsize == XFS_LBSIZE(mp).&n; */
r_int
id|xfs_attr_leaf_to_node
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_to_shortform
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|bp
comma
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_clearflag
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_setflag
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_flipflags
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
multiline_comment|/*&n; * Routines used for growing the Btree.&n; */
r_int
id|xfs_attr_leaf_create
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
comma
id|xfs_dablk_t
id|which_block
comma
r_struct
id|xfs_dabuf
op_star
op_star
id|bpp
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_split
c_func
(paren
r_struct
id|xfs_da_state
op_star
id|state
comma
r_struct
id|xfs_da_state_blk
op_star
id|oldblk
comma
r_struct
id|xfs_da_state_blk
op_star
id|newblk
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_lookup_int
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|leaf
comma
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_getvalue
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|bp
comma
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_add
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|leaf_buffer
comma
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_remove
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|leaf_buffer
comma
r_struct
id|xfs_da_args
op_star
id|args
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_list_int
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|bp
comma
r_struct
id|xfs_attr_list_context
op_star
id|context
)paren
suffix:semicolon
multiline_comment|/*&n; * Routines used for shrinking the Btree.&n; */
r_int
id|xfs_attr_leaf_toosmall
c_func
(paren
r_struct
id|xfs_da_state
op_star
id|state
comma
r_int
op_star
id|retval
)paren
suffix:semicolon
r_void
id|xfs_attr_leaf_unbalance
c_func
(paren
r_struct
id|xfs_da_state
op_star
id|state
comma
r_struct
id|xfs_da_state_blk
op_star
id|drop_blk
comma
r_struct
id|xfs_da_state_blk
op_star
id|save_blk
)paren
suffix:semicolon
r_int
id|xfs_attr_root_inactive
c_func
(paren
r_struct
id|xfs_trans
op_star
op_star
id|trans
comma
r_struct
id|xfs_inode
op_star
id|dp
)paren
suffix:semicolon
r_int
id|xfs_attr_node_inactive
c_func
(paren
r_struct
id|xfs_trans
op_star
op_star
id|trans
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_struct
id|xfs_dabuf
op_star
id|bp
comma
r_int
id|level
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_inactive
c_func
(paren
r_struct
id|xfs_trans
op_star
op_star
id|trans
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_struct
id|xfs_dabuf
op_star
id|bp
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_freextent
c_func
(paren
r_struct
id|xfs_trans
op_star
op_star
id|trans
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
id|xfs_dablk_t
id|blkno
comma
r_int
id|blkcnt
)paren
suffix:semicolon
multiline_comment|/*&n; * Utility routines.&n; */
id|xfs_dahash_t
id|xfs_attr_leaf_lasthash
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|bp
comma
r_int
op_star
id|count
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_order
c_func
(paren
r_struct
id|xfs_dabuf
op_star
id|leaf1_bp
comma
r_struct
id|xfs_dabuf
op_star
id|leaf2_bp
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_newentsize
c_func
(paren
r_struct
id|xfs_da_args
op_star
id|args
comma
r_int
id|blocksize
comma
r_int
op_star
id|local
)paren
suffix:semicolon
r_int
id|xfs_attr_leaf_entsize
c_func
(paren
r_struct
id|xfs_attr_leafblock
op_star
id|leaf
comma
r_int
id|index
)paren
suffix:semicolon
r_int
id|xfs_attr_put_listent
c_func
(paren
r_struct
id|xfs_attr_list_context
op_star
id|context
comma
r_struct
id|attrnames
op_star
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|valuelen
)paren
suffix:semicolon
r_int
id|xfs_attr_rolltrans
c_func
(paren
r_struct
id|xfs_trans
op_star
op_star
id|transp
comma
r_struct
id|xfs_inode
op_star
id|dp
)paren
suffix:semicolon
macro_line|#endif&t;/* __XFS_ATTR_LEAF_H__ */
eof
