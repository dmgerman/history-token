multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;xfs_types.h&gt;
macro_line|#include &quot;kmem.h&quot;
macro_line|#include &quot;spin.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;atomic.h&quot;
macro_line|#include &quot;ktrace.h&quot;
macro_line|#if&t;(defined(DEBUG) || defined(CONFIG_XFS_VNODE_TRACING))
DECL|variable|ktrace_hdr_zone
r_static
id|kmem_zone_t
op_star
id|ktrace_hdr_zone
suffix:semicolon
DECL|variable|ktrace_ent_zone
r_static
id|kmem_zone_t
op_star
id|ktrace_ent_zone
suffix:semicolon
DECL|variable|ktrace_zentries
r_static
r_int
id|ktrace_zentries
suffix:semicolon
r_void
DECL|function|ktrace_init
id|ktrace_init
c_func
(paren
r_int
id|zentries
)paren
(brace
id|ktrace_zentries
op_assign
id|zentries
suffix:semicolon
id|ktrace_hdr_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|ktrace_t
)paren
comma
l_string|&quot;ktrace_hdr&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ktrace_hdr_zone
)paren
suffix:semicolon
id|ktrace_ent_zone
op_assign
id|kmem_zone_init
c_func
(paren
id|ktrace_zentries
op_star
r_sizeof
(paren
id|ktrace_entry_t
)paren
comma
l_string|&quot;ktrace_ent&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ktrace_ent_zone
)paren
suffix:semicolon
)brace
r_void
DECL|function|ktrace_uninit
id|ktrace_uninit
c_func
(paren
r_void
)paren
(brace
id|kmem_cache_destroy
c_func
(paren
id|ktrace_hdr_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|ktrace_ent_zone
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ktrace_alloc()&n; *&n; * Allocate a ktrace header and enough buffering for the given&n; * number of entries.&n; */
id|ktrace_t
op_star
DECL|function|ktrace_alloc
id|ktrace_alloc
c_func
(paren
r_int
id|nentries
comma
r_int
id|sleep
)paren
(brace
id|ktrace_t
op_star
id|ktp
suffix:semicolon
id|ktrace_entry_t
op_star
id|ktep
suffix:semicolon
id|ktp
op_assign
(paren
id|ktrace_t
op_star
)paren
id|kmem_zone_alloc
c_func
(paren
id|ktrace_hdr_zone
comma
id|sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ktp
op_eq
(paren
id|ktrace_t
op_star
)paren
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * KM_SLEEP callers don&squot;t expect failure.&n;&t;&t; */
r_if
c_cond
(paren
id|sleep
op_amp
id|KM_SLEEP
)paren
id|panic
c_func
(paren
l_string|&quot;ktrace_alloc: NULL memory on KM_SLEEP request!&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Special treatment for buffers with the ktrace_zentries entries&n;&t; */
r_if
c_cond
(paren
id|nentries
op_eq
id|ktrace_zentries
)paren
(brace
id|ktep
op_assign
(paren
id|ktrace_entry_t
op_star
)paren
id|kmem_zone_zalloc
c_func
(paren
id|ktrace_ent_zone
comma
id|sleep
)paren
suffix:semicolon
)brace
r_else
(brace
id|ktep
op_assign
(paren
id|ktrace_entry_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
(paren
id|nentries
op_star
r_sizeof
(paren
op_star
id|ktep
)paren
)paren
comma
id|sleep
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ktep
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * KM_SLEEP callers don&squot;t expect failure.&n;&t;&t; */
r_if
c_cond
(paren
id|sleep
op_amp
id|KM_SLEEP
)paren
id|panic
c_func
(paren
l_string|&quot;ktrace_alloc: NULL memory on KM_SLEEP request!&quot;
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ktp
comma
r_sizeof
(paren
op_star
id|ktp
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|spinlock_init
c_func
(paren
op_amp
(paren
id|ktp-&gt;kt_lock
)paren
comma
l_string|&quot;kt_lock&quot;
)paren
suffix:semicolon
id|ktp-&gt;kt_entries
op_assign
id|ktep
suffix:semicolon
id|ktp-&gt;kt_nentries
op_assign
id|nentries
suffix:semicolon
id|ktp-&gt;kt_index
op_assign
l_int|0
suffix:semicolon
id|ktp-&gt;kt_rollover
op_assign
l_int|0
suffix:semicolon
r_return
id|ktp
suffix:semicolon
)brace
multiline_comment|/*&n; * ktrace_free()&n; *&n; * Free up the ktrace header and buffer.  It is up to the caller&n; * to ensure that no-one is referencing it.&n; */
r_void
DECL|function|ktrace_free
id|ktrace_free
c_func
(paren
id|ktrace_t
op_star
id|ktp
)paren
(brace
r_int
id|entries_size
suffix:semicolon
r_if
c_cond
(paren
id|ktp
op_eq
(paren
id|ktrace_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|spinlock_destroy
c_func
(paren
op_amp
id|ktp-&gt;kt_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Special treatment for the Vnode trace buffer.&n;&t; */
r_if
c_cond
(paren
id|ktp-&gt;kt_nentries
op_eq
id|ktrace_zentries
)paren
(brace
id|kmem_zone_free
c_func
(paren
id|ktrace_ent_zone
comma
id|ktp-&gt;kt_entries
)paren
suffix:semicolon
)brace
r_else
(brace
id|entries_size
op_assign
(paren
r_int
)paren
(paren
id|ktp-&gt;kt_nentries
op_star
r_sizeof
(paren
id|ktrace_entry_t
)paren
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ktp-&gt;kt_entries
comma
id|entries_size
)paren
suffix:semicolon
)brace
id|kmem_zone_free
c_func
(paren
id|ktrace_hdr_zone
comma
id|ktp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enter the given values into the &quot;next&quot; entry in the trace buffer.&n; * kt_index is always the index of the next entry to be filled.&n; */
r_void
DECL|function|ktrace_enter
id|ktrace_enter
c_func
(paren
id|ktrace_t
op_star
id|ktp
comma
r_void
op_star
id|val0
comma
r_void
op_star
id|val1
comma
r_void
op_star
id|val2
comma
r_void
op_star
id|val3
comma
r_void
op_star
id|val4
comma
r_void
op_star
id|val5
comma
r_void
op_star
id|val6
comma
r_void
op_star
id|val7
comma
r_void
op_star
id|val8
comma
r_void
op_star
id|val9
comma
r_void
op_star
id|val10
comma
r_void
op_star
id|val11
comma
r_void
op_star
id|val12
comma
r_void
op_star
id|val13
comma
r_void
op_star
id|val14
comma
r_void
op_star
id|val15
)paren
(brace
r_int
id|index
suffix:semicolon
id|ktrace_entry_t
op_star
id|ktep
suffix:semicolon
id|ASSERT
c_func
(paren
id|ktp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Grab an entry by pushing the index up to the next one.&n;&t; */
id|index
op_assign
id|atomicIncWithWrap
c_func
(paren
op_amp
id|ktp-&gt;kt_index
comma
id|ktp-&gt;kt_nentries
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ktp-&gt;kt_rollover
op_logical_and
id|index
op_eq
id|ktp-&gt;kt_nentries
op_minus
l_int|1
)paren
id|ktp-&gt;kt_rollover
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|index
OL
id|ktp-&gt;kt_nentries
)paren
)paren
suffix:semicolon
id|ktep
op_assign
op_amp
(paren
id|ktp-&gt;kt_entries
(braket
id|index
)braket
)paren
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|0
)braket
op_assign
id|val0
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|1
)braket
op_assign
id|val1
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|2
)braket
op_assign
id|val2
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|3
)braket
op_assign
id|val3
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|4
)braket
op_assign
id|val4
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|5
)braket
op_assign
id|val5
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|6
)braket
op_assign
id|val6
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|7
)braket
op_assign
id|val7
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|8
)braket
op_assign
id|val8
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|9
)braket
op_assign
id|val9
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|10
)braket
op_assign
id|val10
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|11
)braket
op_assign
id|val11
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|12
)braket
op_assign
id|val12
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|13
)braket
op_assign
id|val13
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|14
)braket
op_assign
id|val14
suffix:semicolon
id|ktep-&gt;val
(braket
l_int|15
)braket
op_assign
id|val15
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the number of entries in the trace buffer.&n; */
r_int
DECL|function|ktrace_nentries
id|ktrace_nentries
c_func
(paren
id|ktrace_t
op_star
id|ktp
)paren
(brace
r_if
c_cond
(paren
id|ktp
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|ktp-&gt;kt_rollover
ques
c_cond
id|ktp-&gt;kt_nentries
suffix:colon
id|ktp-&gt;kt_index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ktrace_first()&n; *&n; * This is used to find the start of the trace buffer.&n; * In conjunction with ktrace_next() it can be used to&n; * iterate through the entire trace buffer.  This code does&n; * not do any locking because it is assumed that it is called&n; * from the debugger.&n; *&n; * The caller must pass in a pointer to a ktrace_snap&n; * structure in which we will keep some state used to&n; * iterate through the buffer.&t;This state must not touched&n; * by any code outside of this module.&n; */
id|ktrace_entry_t
op_star
DECL|function|ktrace_first
id|ktrace_first
c_func
(paren
id|ktrace_t
op_star
id|ktp
comma
id|ktrace_snap_t
op_star
id|ktsp
)paren
(brace
id|ktrace_entry_t
op_star
id|ktep
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|nentries
suffix:semicolon
r_if
c_cond
(paren
id|ktp-&gt;kt_rollover
)paren
id|index
op_assign
id|ktp-&gt;kt_index
suffix:semicolon
r_else
id|index
op_assign
l_int|0
suffix:semicolon
id|ktsp-&gt;ks_start
op_assign
id|index
suffix:semicolon
id|ktep
op_assign
op_amp
(paren
id|ktp-&gt;kt_entries
(braket
id|index
)braket
)paren
suffix:semicolon
id|nentries
op_assign
id|ktrace_nentries
c_func
(paren
id|ktp
)paren
suffix:semicolon
id|index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|nentries
)paren
(brace
id|ktsp-&gt;ks_index
op_assign
id|index
suffix:semicolon
)brace
r_else
(brace
id|ktsp-&gt;ks_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|index
OG
id|nentries
)paren
id|ktep
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|ktep
suffix:semicolon
)brace
multiline_comment|/*&n; * ktrace_next()&n; *&n; * This is used to iterate through the entries of the given&n; * trace buffer.  The caller must pass in the ktrace_snap_t&n; * structure initialized by ktrace_first().  The return value&n; * will be either a pointer to the next ktrace_entry or NULL&n; * if all of the entries have been traversed.&n; */
id|ktrace_entry_t
op_star
DECL|function|ktrace_next
id|ktrace_next
c_func
(paren
id|ktrace_t
op_star
id|ktp
comma
id|ktrace_snap_t
op_star
id|ktsp
)paren
(brace
r_int
id|index
suffix:semicolon
id|ktrace_entry_t
op_star
id|ktep
suffix:semicolon
id|index
op_assign
id|ktsp-&gt;ks_index
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|ktsp-&gt;ks_start
)paren
(brace
id|ktep
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|ktep
op_assign
op_amp
id|ktp-&gt;kt_entries
(braket
id|index
)braket
suffix:semicolon
)brace
id|index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|ktrace_nentries
c_func
(paren
id|ktp
)paren
)paren
(brace
id|ktsp-&gt;ks_index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ktsp-&gt;ks_index
op_assign
id|index
suffix:semicolon
)brace
r_return
id|ktep
suffix:semicolon
)brace
macro_line|#if&t;(defined(DEBUG) || defined(CONFIG_XFS_VNODE_TRACING))
DECL|variable|ktrace_first
id|EXPORT_SYMBOL
c_func
(paren
id|ktrace_first
)paren
suffix:semicolon
DECL|variable|ktrace_next
id|EXPORT_SYMBOL
c_func
(paren
id|ktrace_next
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * ktrace_skip()&n; *&n; * Skip the next &quot;count&quot; entries and return the entry after that.&n; * Return NULL if this causes us to iterate past the beginning again.&n; */
id|ktrace_entry_t
op_star
DECL|function|ktrace_skip
id|ktrace_skip
c_func
(paren
id|ktrace_t
op_star
id|ktp
comma
r_int
id|count
comma
id|ktrace_snap_t
op_star
id|ktsp
)paren
(brace
r_int
id|index
suffix:semicolon
r_int
id|new_index
suffix:semicolon
id|ktrace_entry_t
op_star
id|ktep
suffix:semicolon
r_int
id|nentries
op_assign
id|ktrace_nentries
c_func
(paren
id|ktp
)paren
suffix:semicolon
id|index
op_assign
id|ktsp-&gt;ks_index
suffix:semicolon
id|new_index
op_assign
id|index
op_plus
id|count
suffix:semicolon
r_while
c_loop
(paren
id|new_index
op_ge
id|nentries
)paren
(brace
id|new_index
op_sub_assign
id|nentries
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index
op_eq
id|ktsp-&gt;ks_start
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;ve iterated around to the start, so we&squot;re done.&n;&t;&t; */
id|ktep
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|new_index
OL
id|index
)paren
op_logical_and
(paren
id|index
OL
id|ktsp-&gt;ks_index
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;ve skipped past the start again, so we&squot;re done.&n;&t;&t; */
id|ktep
op_assign
l_int|NULL
suffix:semicolon
id|ktsp-&gt;ks_index
op_assign
id|ktsp-&gt;ks_start
suffix:semicolon
)brace
r_else
(brace
id|ktep
op_assign
op_amp
(paren
id|ktp-&gt;kt_entries
(braket
id|new_index
)braket
)paren
suffix:semicolon
id|new_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|new_index
op_eq
id|nentries
)paren
(brace
id|ktsp-&gt;ks_index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ktsp-&gt;ks_index
op_assign
id|new_index
suffix:semicolon
)brace
)brace
r_return
id|ktep
suffix:semicolon
)brace
macro_line|#else
id|ktrace_t
op_star
DECL|function|ktrace_alloc
id|ktrace_alloc
c_func
(paren
r_int
id|nentries
comma
r_int
id|sleep
)paren
(brace
multiline_comment|/*&n;&t; * KM_SLEEP callers don&squot;t expect failure.&n;&t; */
r_if
c_cond
(paren
id|sleep
op_amp
id|KM_SLEEP
)paren
id|panic
c_func
(paren
l_string|&quot;ktrace_alloc: NULL memory on KM_SLEEP request!&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
eof
