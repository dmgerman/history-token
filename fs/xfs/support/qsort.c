multiline_comment|/*&n; * Copyright (c) 1992, 1993&n; *&t;The Regents of the University of California.  All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, this list of conditions and the following disclaimer.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. Neither the name of the University nor the names of its contributors&n; *    may be used to endorse or promote products derived from this software&n; *    without specific prior written permission.&n; *&n; * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&squot;&squot; AND&n; * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE&n; * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE&n; * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE&n; * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL&n; * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS&n; * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT&n; * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY&n; * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF&n; * SUCH DAMAGE.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
multiline_comment|/*&n; * Qsort routine from Bentley &amp; McIlroy&squot;s &quot;Engineering a Sort Function&quot;.&n; */
DECL|macro|swapcode
mdefine_line|#define swapcode(TYPE, parmi, parmj, n) { &t;&t;&bslash;&n;&t;long i = (n) / sizeof (TYPE); &t;&t;&t;&bslash;&n;&t;register TYPE *pi = (TYPE *) (parmi); &t;&t;&bslash;&n;&t;register TYPE *pj = (TYPE *) (parmj); &t;&t;&bslash;&n;&t;do { &t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;register TYPE&t;t = *pi;&t;&t;&bslash;&n;&t;&t;*pi++ = *pj;&t;&t;&t;&t;&bslash;&n;&t;&t;*pj++ = t;&t;&t;&t;&t;&bslash;&n;        } while (--i &gt; 0);&t;&t;&t;&t;&bslash;&n;}
DECL|macro|SWAPINIT
mdefine_line|#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || &bslash;&n;&t;es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
r_static
id|__inline
r_void
DECL|function|swapfunc
id|swapfunc
c_func
(paren
r_char
op_star
id|a
comma
r_char
op_star
id|b
comma
r_int
id|n
comma
r_int
id|swaptype
)paren
(brace
r_if
c_cond
(paren
id|swaptype
op_le
l_int|1
)paren
id|swapcode
c_func
(paren
r_int
comma
id|a
comma
id|b
comma
id|n
)paren
r_else
id|swapcode
c_func
(paren
r_char
comma
id|a
comma
id|b
comma
id|n
)paren
)brace
DECL|macro|swap
mdefine_line|#define swap(a, b)&t;&t;&t;&t;&t;&bslash;&n;&t;if (swaptype == 0) {&t;&t;&t;&t;&bslash;&n;&t;&t;long t = *(long *)(a);&t;&t;&t;&bslash;&n;&t;&t;*(long *)(a) = *(long *)(b);&t;&t;&bslash;&n;&t;&t;*(long *)(b) = t;&t;&t;&t;&bslash;&n;&t;} else&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;swapfunc(a, b, es, swaptype)
DECL|macro|vecswap
mdefine_line|#define vecswap(a, b, n) &t;if ((n) &gt; 0) swapfunc(a, b, n, swaptype)
r_static
id|__inline
r_char
op_star
DECL|function|med3
id|med3
c_func
(paren
r_char
op_star
id|a
comma
r_char
op_star
id|b
comma
r_char
op_star
id|c
comma
r_int
(paren
op_star
id|cmp
)paren
(paren
r_const
r_void
op_star
comma
r_const
r_void
op_star
)paren
)paren
(brace
r_return
id|cmp
c_func
(paren
id|a
comma
id|b
)paren
OL
l_int|0
ques
c_cond
(paren
id|cmp
c_func
(paren
id|b
comma
id|c
)paren
OL
l_int|0
ques
c_cond
id|b
suffix:colon
(paren
id|cmp
c_func
(paren
id|a
comma
id|c
)paren
OL
l_int|0
ques
c_cond
id|c
suffix:colon
id|a
)paren
)paren
suffix:colon
(paren
id|cmp
c_func
(paren
id|b
comma
id|c
)paren
OG
l_int|0
ques
c_cond
id|b
suffix:colon
(paren
id|cmp
c_func
(paren
id|a
comma
id|c
)paren
OL
l_int|0
ques
c_cond
id|a
suffix:colon
id|c
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|qsort
id|qsort
c_func
(paren
r_void
op_star
id|aa
comma
r_int
id|n
comma
r_int
id|es
comma
r_int
(paren
op_star
id|cmp
)paren
(paren
r_const
r_void
op_star
comma
r_const
r_void
op_star
)paren
)paren
(brace
r_char
op_star
id|pa
comma
op_star
id|pb
comma
op_star
id|pc
comma
op_star
id|pd
comma
op_star
id|pl
comma
op_star
id|pm
comma
op_star
id|pn
suffix:semicolon
r_int
id|d
comma
id|r
comma
id|swaptype
comma
id|swap_cnt
suffix:semicolon
r_register
r_char
op_star
id|a
op_assign
id|aa
suffix:semicolon
id|loop
suffix:colon
id|SWAPINIT
c_func
(paren
id|a
comma
id|es
)paren
suffix:semicolon
id|swap_cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|7
)paren
(brace
r_for
c_loop
(paren
id|pm
op_assign
(paren
r_char
op_star
)paren
id|a
op_plus
id|es
suffix:semicolon
id|pm
OL
(paren
r_char
op_star
)paren
id|a
op_plus
id|n
op_star
id|es
suffix:semicolon
id|pm
op_add_assign
id|es
)paren
r_for
c_loop
(paren
id|pl
op_assign
id|pm
suffix:semicolon
id|pl
OG
(paren
r_char
op_star
)paren
id|a
op_logical_and
id|cmp
c_func
(paren
id|pl
op_minus
id|es
comma
id|pl
)paren
OG
l_int|0
suffix:semicolon
id|pl
op_sub_assign
id|es
)paren
id|swap
c_func
(paren
id|pl
comma
id|pl
op_minus
id|es
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pm
op_assign
(paren
r_char
op_star
)paren
id|a
op_plus
(paren
id|n
op_div
l_int|2
)paren
op_star
id|es
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|7
)paren
(brace
id|pl
op_assign
(paren
r_char
op_star
)paren
id|a
suffix:semicolon
id|pn
op_assign
(paren
r_char
op_star
)paren
id|a
op_plus
(paren
id|n
op_minus
l_int|1
)paren
op_star
id|es
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|40
)paren
(brace
id|d
op_assign
(paren
id|n
op_div
l_int|8
)paren
op_star
id|es
suffix:semicolon
id|pl
op_assign
id|med3
c_func
(paren
id|pl
comma
id|pl
op_plus
id|d
comma
id|pl
op_plus
l_int|2
op_star
id|d
comma
id|cmp
)paren
suffix:semicolon
id|pm
op_assign
id|med3
c_func
(paren
id|pm
op_minus
id|d
comma
id|pm
comma
id|pm
op_plus
id|d
comma
id|cmp
)paren
suffix:semicolon
id|pn
op_assign
id|med3
c_func
(paren
id|pn
op_minus
l_int|2
op_star
id|d
comma
id|pn
op_minus
id|d
comma
id|pn
comma
id|cmp
)paren
suffix:semicolon
)brace
id|pm
op_assign
id|med3
c_func
(paren
id|pl
comma
id|pm
comma
id|pn
comma
id|cmp
)paren
suffix:semicolon
)brace
id|swap
c_func
(paren
id|a
comma
id|pm
)paren
suffix:semicolon
id|pa
op_assign
id|pb
op_assign
(paren
r_char
op_star
)paren
id|a
op_plus
id|es
suffix:semicolon
id|pc
op_assign
id|pd
op_assign
(paren
r_char
op_star
)paren
id|a
op_plus
(paren
id|n
op_minus
l_int|1
)paren
op_star
id|es
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_while
c_loop
(paren
id|pb
op_le
id|pc
op_logical_and
(paren
id|r
op_assign
id|cmp
c_func
(paren
id|pb
comma
id|a
)paren
)paren
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
l_int|0
)paren
(brace
id|swap_cnt
op_assign
l_int|1
suffix:semicolon
id|swap
c_func
(paren
id|pa
comma
id|pb
)paren
suffix:semicolon
id|pa
op_add_assign
id|es
suffix:semicolon
)brace
id|pb
op_add_assign
id|es
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pb
op_le
id|pc
op_logical_and
(paren
id|r
op_assign
id|cmp
c_func
(paren
id|pc
comma
id|a
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|r
op_eq
l_int|0
)paren
(brace
id|swap_cnt
op_assign
l_int|1
suffix:semicolon
id|swap
c_func
(paren
id|pc
comma
id|pd
)paren
suffix:semicolon
id|pd
op_sub_assign
id|es
suffix:semicolon
)brace
id|pc
op_sub_assign
id|es
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb
OG
id|pc
)paren
r_break
suffix:semicolon
id|swap
c_func
(paren
id|pb
comma
id|pc
)paren
suffix:semicolon
id|swap_cnt
op_assign
l_int|1
suffix:semicolon
id|pb
op_add_assign
id|es
suffix:semicolon
id|pc
op_sub_assign
id|es
suffix:semicolon
)brace
r_if
c_cond
(paren
id|swap_cnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Switch to insertion sort */
r_for
c_loop
(paren
id|pm
op_assign
(paren
r_char
op_star
)paren
id|a
op_plus
id|es
suffix:semicolon
id|pm
OL
(paren
r_char
op_star
)paren
id|a
op_plus
id|n
op_star
id|es
suffix:semicolon
id|pm
op_add_assign
id|es
)paren
r_for
c_loop
(paren
id|pl
op_assign
id|pm
suffix:semicolon
id|pl
OG
(paren
r_char
op_star
)paren
id|a
op_logical_and
id|cmp
c_func
(paren
id|pl
op_minus
id|es
comma
id|pl
)paren
OG
l_int|0
suffix:semicolon
id|pl
op_sub_assign
id|es
)paren
id|swap
c_func
(paren
id|pl
comma
id|pl
op_minus
id|es
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pn
op_assign
(paren
r_char
op_star
)paren
id|a
op_plus
id|n
op_star
id|es
suffix:semicolon
id|r
op_assign
id|min
c_func
(paren
id|pa
op_minus
(paren
r_char
op_star
)paren
id|a
comma
id|pb
op_minus
id|pa
)paren
suffix:semicolon
id|vecswap
c_func
(paren
id|a
comma
id|pb
op_minus
id|r
comma
id|r
)paren
suffix:semicolon
id|r
op_assign
id|min
c_func
(paren
(paren
r_int
)paren
(paren
id|pd
op_minus
id|pc
)paren
comma
(paren
r_int
)paren
(paren
id|pn
op_minus
id|pd
op_minus
id|es
)paren
)paren
suffix:semicolon
id|vecswap
c_func
(paren
id|pb
comma
id|pn
op_minus
id|r
comma
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|pb
op_minus
id|pa
)paren
OG
id|es
)paren
id|qsort
c_func
(paren
id|a
comma
id|r
op_div
id|es
comma
id|es
comma
id|cmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|pd
op_minus
id|pc
)paren
OG
id|es
)paren
(brace
multiline_comment|/* Iterate rather than recurse to save stack space */
id|a
op_assign
id|pn
op_minus
id|r
suffix:semicolon
id|n
op_assign
id|r
op_div
id|es
suffix:semicolon
r_goto
id|loop
suffix:semicolon
)brace
multiline_comment|/*&t;&t;qsort(pn - r, r / es, es, cmp);*/
)brace
eof
