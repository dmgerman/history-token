multiline_comment|/* Copyright (C) 1991, 1992, 1996, 1997, 1999 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;   Written by Douglas C. Schmidt (schmidt@ics.uci.edu).&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Lesser General Public&n;   License as published by the Free Software Foundation; either&n;   version 2.1 of the License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&t; See the GNU&n;   Lesser General Public License for more details.&n;&n;   You should have received a copy of the GNU Lesser General Public&n;   License along with the GNU C Library; if not, write to the Free&n;   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA&n;   02111-1307 USA.  */
multiline_comment|/* If you consider tuning this algorithm, you should consult first:&n;   Engineering a sort function; Jon Bentley and M. Douglas McIlroy;&n;   Software - Practice and Experience; Vol. 23 (11), 1249-1265, 1993.  */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
multiline_comment|/* Byte-wise swap two items of size SIZE. */
DECL|macro|SWAP
mdefine_line|#define SWAP(a, b, size)&t;&t;&t;&t;&t;&t;      &bslash;&n;  do&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;      register size_t __size = (size);&t;&t;&t;&t;&t;      &bslash;&n;      register char *__a = (a), *__b = (b);&t;&t;&t;&t;      &bslash;&n;      do&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;  char __tmp = *__a;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;  *__a++ = *__b;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;  *__b++ = __tmp;&t;&t;&t;&t;&t;&t;      &bslash;&n;&t;} while (--__size &gt; 0);&t;&t;&t;&t;&t;&t;      &bslash;&n;    } while (0)
multiline_comment|/* Discontinue quicksort algorithm when partition gets below this size.&n;   This particular magic number was chosen to work best on a Sun 4/260. */
DECL|macro|MAX_THRESH
mdefine_line|#define MAX_THRESH 4
multiline_comment|/* Stack node declarations used to store unfulfilled partition obligations. */
r_typedef
r_struct
(brace
DECL|member|lo
r_char
op_star
id|lo
suffix:semicolon
DECL|member|hi
r_char
op_star
id|hi
suffix:semicolon
DECL|typedef|stack_node
)brace
id|stack_node
suffix:semicolon
multiline_comment|/* The next 4 #defines implement a very fast in-line stack abstraction. */
multiline_comment|/* The stack needs log (total_elements) entries (we could even subtract&n;   log(MAX_THRESH)).  Since total_elements has type size_t, we get as&n;   upper bound for log (total_elements):&n;   bits per byte (CHAR_BIT) * sizeof(size_t).  */
DECL|macro|STACK_SIZE
mdefine_line|#define STACK_SIZE&t;(8 * sizeof(unsigned long int))
DECL|macro|PUSH
mdefine_line|#define PUSH(low, high) ((void) ((top-&gt;lo = (low)), (top-&gt;hi = (high)), ++top))
DECL|macro|POP
mdefine_line|#define POP(low, high)&t;((void) (--top, (low = top-&gt;lo), (high = top-&gt;hi)))
DECL|macro|STACK_NOT_EMPTY
mdefine_line|#define STACK_NOT_EMPTY (stack &lt; top)
multiline_comment|/* Order size using quicksort.&t;This implementation incorporates&n;   four optimizations discussed in Sedgewick:&n;&n;   1. Non-recursive, using an explicit stack of pointer that store the&n;      next array partition to sort.  To save time, this maximum amount&n;      of space required to store an array of SIZE_MAX is allocated on the&n;      stack.  Assuming a 32-bit (64 bit) integer for size_t, this needs&n;      only 32 * sizeof(stack_node) == 256 bytes (for 64 bit: 1024 bytes).&n;      Pretty cheap, actually.&n;&n;   2. Chose the pivot element using a median-of-three decision tree.&n;      This reduces the probability of selecting a bad pivot value and&n;      eliminates certain extraneous comparisons.&n;&n;   3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving&n;      insertion sort to order the MAX_THRESH items within each partition.&n;      This is a big win, since insertion sort is faster for small, mostly&n;      sorted array segments.&n;&n;   4. The larger of the two sub-partitions is always pushed onto the&n;      stack first, with the algorithm then concentrating on the&n;      smaller partition.  This *guarantees* no more than log (total_elems)&n;      stack size is needed (actually O(1) in this case)!  */
r_void
DECL|function|qsort
id|qsort
(paren
r_void
op_star
r_const
id|pbase
comma
r_int
id|total_elems
comma
r_int
id|size
comma
r_int
(paren
op_star
id|cmp
)paren
(paren
r_const
r_void
op_star
comma
r_const
r_void
op_star
)paren
)paren
(brace
r_register
r_char
op_star
id|base_ptr
op_assign
(paren
r_char
op_star
)paren
id|pbase
suffix:semicolon
r_const
r_int
id|max_thresh
op_assign
id|MAX_THRESH
op_star
id|size
suffix:semicolon
r_if
c_cond
(paren
id|total_elems
op_eq
l_int|0
)paren
multiline_comment|/* Avoid lossage with unsigned arithmetic below.  */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|total_elems
OG
id|MAX_THRESH
)paren
(brace
r_char
op_star
id|lo
op_assign
id|base_ptr
suffix:semicolon
r_char
op_star
id|hi
op_assign
op_amp
id|lo
(braket
id|size
op_star
(paren
id|total_elems
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|stack_node
id|stack
(braket
id|STACK_SIZE
)braket
suffix:semicolon
id|stack_node
op_star
id|top
op_assign
id|stack
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|STACK_NOT_EMPTY
)paren
(brace
r_char
op_star
id|left_ptr
suffix:semicolon
r_char
op_star
id|right_ptr
suffix:semicolon
multiline_comment|/* Select median value from among LO, MID, and HI. Rearrange&n;&t;     LO and HI so the three values are sorted. This lowers the&n;&t;     probability of picking a pathological pivot value and&n;&t;     skips a comparison for both the LEFT_PTR and RIGHT_PTR in&n;&t;     the while loops. */
r_char
op_star
id|mid
op_assign
id|lo
op_plus
id|size
op_star
(paren
(paren
id|hi
op_minus
id|lo
)paren
op_div
id|size
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|cmp
)paren
(paren
(paren
r_void
op_star
)paren
id|mid
comma
(paren
r_void
op_star
)paren
id|lo
)paren
OL
l_int|0
)paren
id|SWAP
(paren
id|mid
comma
id|lo
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|cmp
)paren
(paren
(paren
r_void
op_star
)paren
id|hi
comma
(paren
r_void
op_star
)paren
id|mid
)paren
OL
l_int|0
)paren
id|SWAP
(paren
id|mid
comma
id|hi
comma
id|size
)paren
suffix:semicolon
r_else
r_goto
id|jump_over
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|cmp
)paren
(paren
(paren
r_void
op_star
)paren
id|mid
comma
(paren
r_void
op_star
)paren
id|lo
)paren
OL
l_int|0
)paren
id|SWAP
(paren
id|mid
comma
id|lo
comma
id|size
)paren
suffix:semicolon
id|jump_over
suffix:colon
suffix:semicolon
id|left_ptr
op_assign
id|lo
op_plus
id|size
suffix:semicolon
id|right_ptr
op_assign
id|hi
op_minus
id|size
suffix:semicolon
multiline_comment|/* Here&squot;s the famous ``collapse the walls&squot;&squot; section of quicksort.&n;&t;     Gotta like those tight inner loops!  They are the main reason&n;&t;     that this algorithm runs much faster than others. */
r_do
(brace
r_while
c_loop
(paren
(paren
op_star
id|cmp
)paren
(paren
(paren
r_void
op_star
)paren
id|left_ptr
comma
(paren
r_void
op_star
)paren
id|mid
)paren
OL
l_int|0
)paren
id|left_ptr
op_add_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|cmp
)paren
(paren
(paren
r_void
op_star
)paren
id|mid
comma
(paren
r_void
op_star
)paren
id|right_ptr
)paren
OL
l_int|0
)paren
id|right_ptr
op_sub_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|left_ptr
OL
id|right_ptr
)paren
(brace
id|SWAP
(paren
id|left_ptr
comma
id|right_ptr
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mid
op_eq
id|left_ptr
)paren
id|mid
op_assign
id|right_ptr
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mid
op_eq
id|right_ptr
)paren
id|mid
op_assign
id|left_ptr
suffix:semicolon
id|left_ptr
op_add_assign
id|size
suffix:semicolon
id|right_ptr
op_sub_assign
id|size
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|left_ptr
op_eq
id|right_ptr
)paren
(brace
id|left_ptr
op_add_assign
id|size
suffix:semicolon
id|right_ptr
op_sub_assign
id|size
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|left_ptr
op_le
id|right_ptr
)paren
suffix:semicolon
multiline_comment|/* Set up pointers for next iteration.  First determine whether&n;&t;     left and right partitions are below the threshold size.  If so,&n;&t;     ignore one or both.  Otherwise, push the larger partition&squot;s&n;&t;     bounds on the stack and continue sorting the smaller one. */
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|right_ptr
op_minus
id|lo
)paren
op_le
id|max_thresh
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|hi
op_minus
id|left_ptr
)paren
op_le
id|max_thresh
)paren
multiline_comment|/* Ignore both small partitions. */
id|POP
(paren
id|lo
comma
id|hi
)paren
suffix:semicolon
r_else
multiline_comment|/* Ignore small left partition. */
id|lo
op_assign
id|left_ptr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|hi
op_minus
id|left_ptr
)paren
op_le
id|max_thresh
)paren
multiline_comment|/* Ignore small right partition. */
id|hi
op_assign
id|right_ptr
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|right_ptr
op_minus
id|lo
)paren
OG
(paren
id|hi
op_minus
id|left_ptr
)paren
)paren
(brace
multiline_comment|/* Push larger left partition indices. */
id|PUSH
(paren
id|lo
comma
id|right_ptr
)paren
suffix:semicolon
id|lo
op_assign
id|left_ptr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Push larger right partition indices. */
id|PUSH
(paren
id|left_ptr
comma
id|hi
)paren
suffix:semicolon
id|hi
op_assign
id|right_ptr
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Once the BASE_PTR array is partially sorted by quicksort the rest&n;     is completely sorted using insertion sort, since this is efficient&n;     for partitions below MAX_THRESH size. BASE_PTR points to the beginning&n;     of the array to sort, and END_PTR points at the very last element in&n;     the array (*not* one beyond it!). */
(brace
r_char
op_star
r_const
id|end_ptr
op_assign
op_amp
id|base_ptr
(braket
id|size
op_star
(paren
id|total_elems
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_char
op_star
id|tmp_ptr
op_assign
id|base_ptr
suffix:semicolon
r_char
op_star
r_const
id|thresh
op_assign
id|min_t
c_func
(paren
r_char
op_star
r_const
comma
id|end_ptr
comma
id|base_ptr
op_plus
id|max_thresh
)paren
suffix:semicolon
r_register
r_char
op_star
id|run_ptr
suffix:semicolon
multiline_comment|/* Find smallest element in first threshold and place it at the&n;       array&squot;s beginning.  This is the smallest array element,&n;       and the operation speeds up insertion sort&squot;s inner loop. */
r_for
c_loop
(paren
id|run_ptr
op_assign
id|tmp_ptr
op_plus
id|size
suffix:semicolon
id|run_ptr
op_le
id|thresh
suffix:semicolon
id|run_ptr
op_add_assign
id|size
)paren
r_if
c_cond
(paren
(paren
op_star
id|cmp
)paren
(paren
(paren
r_void
op_star
)paren
id|run_ptr
comma
(paren
r_void
op_star
)paren
id|tmp_ptr
)paren
OL
l_int|0
)paren
id|tmp_ptr
op_assign
id|run_ptr
suffix:semicolon
r_if
c_cond
(paren
id|tmp_ptr
op_ne
id|base_ptr
)paren
id|SWAP
(paren
id|tmp_ptr
comma
id|base_ptr
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Insertion sort, running from left-hand-side up to right-hand-side.  */
id|run_ptr
op_assign
id|base_ptr
op_plus
id|size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|run_ptr
op_add_assign
id|size
)paren
op_le
id|end_ptr
)paren
(brace
id|tmp_ptr
op_assign
id|run_ptr
op_minus
id|size
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|cmp
)paren
(paren
(paren
r_void
op_star
)paren
id|run_ptr
comma
(paren
r_void
op_star
)paren
id|tmp_ptr
)paren
OL
l_int|0
)paren
id|tmp_ptr
op_sub_assign
id|size
suffix:semicolon
id|tmp_ptr
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|tmp_ptr
op_ne
id|run_ptr
)paren
(brace
r_char
op_star
id|trav
suffix:semicolon
id|trav
op_assign
id|run_ptr
op_plus
id|size
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|trav
op_ge
id|run_ptr
)paren
(brace
r_char
id|c
op_assign
op_star
id|trav
suffix:semicolon
r_char
op_star
id|hi
comma
op_star
id|lo
suffix:semicolon
r_for
c_loop
(paren
id|hi
op_assign
id|lo
op_assign
id|trav
suffix:semicolon
(paren
id|lo
op_sub_assign
id|size
)paren
op_ge
id|tmp_ptr
suffix:semicolon
id|hi
op_assign
id|lo
)paren
op_star
id|hi
op_assign
op_star
id|lo
suffix:semicolon
op_star
id|hi
op_assign
id|c
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
eof
