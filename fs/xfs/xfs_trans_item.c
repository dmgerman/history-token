multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &lt;xfs.h&gt;
id|STATIC
r_int
id|xfs_trans_unlock_chunk
c_func
(paren
id|xfs_log_item_chunk_t
op_star
comma
r_int
comma
r_int
comma
id|xfs_lsn_t
)paren
suffix:semicolon
multiline_comment|/*&n; * This is called to add the given log item to the transaction&squot;s&n; * list of log items.  It must find a free log item descriptor&n; * or allocate a new one and add the item to that descriptor.&n; * The function returns a pointer to item descriptor used to point&n; * to the new item.  The log item will now point to its new descriptor&n; * with its li_desc field.&n; */
id|xfs_log_item_desc_t
op_star
DECL|function|xfs_trans_add_item
id|xfs_trans_add_item
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_log_item_t
op_star
id|lip
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If there are no free descriptors, allocate a new chunk&n;&t; * of them and put it at the front of the chunk list.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_items_free
op_eq
l_int|0
)paren
(brace
id|licp
op_assign
(paren
id|xfs_log_item_chunk_t
op_star
)paren
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
id|xfs_log_item_chunk_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|licp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the chunk, and then&n;&t;&t; * claim the first slot in the newly allocated chunk.&n;&t;&t; */
id|XFS_LIC_INIT
c_func
(paren
id|licp
)paren
suffix:semicolon
id|XFS_LIC_CLAIM
c_func
(paren
id|licp
comma
l_int|0
)paren
suffix:semicolon
id|licp-&gt;lic_unused
op_assign
l_int|1
suffix:semicolon
id|XFS_LIC_INIT_SLOT
c_func
(paren
id|licp
comma
l_int|0
)paren
suffix:semicolon
id|lidp
op_assign
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Link in the new chunk and update the free count.&n;&t;&t; */
id|licp-&gt;lic_next
op_assign
id|tp-&gt;t_items.lic_next
suffix:semicolon
id|tp-&gt;t_items.lic_next
op_assign
id|licp
suffix:semicolon
id|tp-&gt;t_items_free
op_assign
id|XFS_LIC_NUM_SLOTS
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the descriptor and the generic portion&n;&t;&t; * of the log item.&n;&t;&t; *&n;&t;&t; * Point the new slot at this item and return it.&n;&t;&t; * Also point the log item at its currently active&n;&t;&t; * descriptor and set the item&squot;s mount pointer.&n;&t;&t; */
id|lidp-&gt;lid_item
op_assign
id|lip
suffix:semicolon
id|lidp-&gt;lid_flags
op_assign
l_int|0
suffix:semicolon
id|lidp-&gt;lid_size
op_assign
l_int|0
suffix:semicolon
id|lip-&gt;li_desc
op_assign
id|lidp
suffix:semicolon
id|lip-&gt;li_mountp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
r_return
(paren
id|lidp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the free descriptor. It is somewhere in the chunklist&n;&t; * of descriptors.&n;&t; */
id|licp
op_assign
op_amp
id|tp-&gt;t_items
suffix:semicolon
r_while
c_loop
(paren
id|licp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_VACANCY
c_func
(paren
id|licp
)paren
)paren
(brace
r_if
c_cond
(paren
id|licp-&gt;lic_unused
op_le
id|XFS_LIC_MAX_SLOT
)paren
(brace
id|i
op_assign
id|licp-&gt;lic_unused
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|XFS_LIC_MAX_SLOT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_le
id|XFS_LIC_MAX_SLOT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|licp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we find a free descriptor, claim it,&n;&t; * initialize it, and return it.&n;&t; */
id|XFS_LIC_CLAIM
c_func
(paren
id|licp
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|licp-&gt;lic_unused
op_le
id|i
)paren
(brace
id|licp-&gt;lic_unused
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|XFS_LIC_INIT_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
suffix:semicolon
)brace
id|lidp
op_assign
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
suffix:semicolon
id|tp-&gt;t_items_free
op_decrement
suffix:semicolon
id|lidp-&gt;lid_item
op_assign
id|lip
suffix:semicolon
id|lidp-&gt;lid_flags
op_assign
l_int|0
suffix:semicolon
id|lidp-&gt;lid_size
op_assign
l_int|0
suffix:semicolon
id|lip-&gt;li_desc
op_assign
id|lidp
suffix:semicolon
id|lip-&gt;li_mountp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
r_return
(paren
id|lidp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the given descriptor.&n; *&n; * This requires setting the bit in the chunk&squot;s free mask corresponding&n; * to the given slot.&n; */
r_void
DECL|function|xfs_trans_free_item
id|xfs_trans_free_item
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_log_item_desc_t
op_star
id|lidp
)paren
(brace
id|uint
id|slot
suffix:semicolon
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_log_item_chunk_t
op_star
op_star
id|licpp
suffix:semicolon
id|slot
op_assign
id|XFS_LIC_DESC_TO_SLOT
c_func
(paren
id|lidp
)paren
suffix:semicolon
id|licp
op_assign
id|XFS_LIC_DESC_TO_CHUNK
c_func
(paren
id|lidp
)paren
suffix:semicolon
id|XFS_LIC_RELSE
c_func
(paren
id|licp
comma
id|slot
)paren
suffix:semicolon
id|lidp-&gt;lid_item-&gt;li_desc
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;t_items_free
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * If there are no more used items in the chunk and this is not&n;&t; * the chunk embedded in the transaction structure, then free&n;&t; * the chunk. First pull it from the chunk list and then&n;&t; * free it back to the heap.  We didn&squot;t bother with a doubly&n;&t; * linked list here because the lists should be very short&n;&t; * and this is not a performance path.  It&squot;s better to save&n;&t; * the memory of the extra pointer.&n;&t; *&n;&t; * Also decrement the transaction structure&squot;s count of free items&n;&t; * by the number in a chunk since we are freeing an empty chunk.&n;&t; */
r_if
c_cond
(paren
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
op_logical_and
(paren
id|licp
op_ne
op_amp
(paren
id|tp-&gt;t_items
)paren
)paren
)paren
(brace
id|licpp
op_assign
op_amp
(paren
id|tp-&gt;t_items.lic_next
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|licpp
op_ne
id|licp
)paren
(brace
id|ASSERT
c_func
(paren
op_star
id|licpp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|licpp
op_assign
op_amp
(paren
(paren
op_star
id|licpp
)paren
op_member_access_from_pointer
id|lic_next
)paren
suffix:semicolon
)brace
op_star
id|licpp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
id|kmem_free
c_func
(paren
id|licp
comma
r_sizeof
(paren
id|xfs_log_item_chunk_t
)paren
)paren
suffix:semicolon
id|tp-&gt;t_items_free
op_sub_assign
id|XFS_LIC_NUM_SLOTS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called to find the descriptor corresponding to the given&n; * log item.  It returns a pointer to the descriptor.&n; * The log item MUST have a corresponding descriptor in the given&n; * transaction.  This routine does not return NULL, it panics.&n; *&n; * The descriptor pointer is kept in the log item&squot;s li_desc field.&n; * Just return it.&n; */
multiline_comment|/*ARGSUSED*/
id|xfs_log_item_desc_t
op_star
DECL|function|xfs_trans_find_item
id|xfs_trans_find_item
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_log_item_t
op_star
id|lip
)paren
(brace
id|ASSERT
c_func
(paren
id|lip-&gt;li_desc
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|lip-&gt;li_desc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a pointer to the first descriptor in the chunk list.&n; * This does not return NULL if there are none, it panics.&n; *&n; * The first descriptor must be in either the first or second chunk.&n; * This is because the only chunk allowed to be empty is the first.&n; * All others are freed when they become empty.&n; *&n; * At some point this and xfs_trans_next_item() should be optimized&n; * to quickly look at the mask to determine if there is anything to&n; * look at.&n; */
id|xfs_log_item_desc_t
op_star
DECL|function|xfs_trans_first_item
id|xfs_trans_first_item
c_func
(paren
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|licp
op_assign
op_amp
id|tp-&gt;t_items
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s not in the first chunk, skip to the second.&n;&t; */
r_if
c_cond
(paren
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
(brace
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return the first non-free descriptor in the chunk.&n;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
(paren
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
)paren
suffix:semicolon
)brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_trans_first_item() -- no first item&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a descriptor, return the next descriptor in the chunk list.&n; * This returns NULL if there are no more used descriptors in the list.&n; *&n; * We do this by first locating the chunk in which the descriptor resides,&n; * and then scanning forward in the chunk and the list for the next&n; * used descriptor.&n; */
multiline_comment|/*ARGSUSED*/
id|xfs_log_item_desc_t
op_star
DECL|function|xfs_trans_next_item
id|xfs_trans_next_item
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_log_item_desc_t
op_star
id|lidp
)paren
(brace
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|licp
op_assign
id|XFS_LIC_DESC_TO_CHUNK
c_func
(paren
id|lidp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First search the rest of the chunk. The for loop keeps us&n;&t; * from referencing things beyond the end of the chunk.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
(paren
r_int
)paren
id|XFS_LIC_DESC_TO_SLOT
c_func
(paren
id|lidp
)paren
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
(paren
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now search the next chunk.  It must be there, because the&n;&t; * next chunk would have been freed if it were empty.&n;&t; * If there is no next chunk, return NULL.&n;&t; */
r_if
c_cond
(paren
id|licp-&gt;lic_next
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
(paren
id|XFS_LIC_SLOT
c_func
(paren
id|licp
comma
id|i
)paren
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* keep gcc quite */
)brace
multiline_comment|/*&n; * This is called to unlock all of the items of a transaction and to free&n; * all the descriptors of that transaction.&n; *&n; * It walks the list of descriptors and unlocks each item.  It frees&n; * each chunk except that embedded in the transaction as it goes along.&n; */
r_void
DECL|function|xfs_trans_free_items
id|xfs_trans_free_items
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
r_int
id|flags
)paren
(brace
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_log_item_chunk_t
op_star
id|next_licp
suffix:semicolon
r_int
m_abort
suffix:semicolon
m_abort
op_assign
id|flags
op_amp
id|XFS_TRANS_ABORT
suffix:semicolon
id|licp
op_assign
op_amp
id|tp-&gt;t_items
suffix:semicolon
multiline_comment|/*&n;&t; * Special case the embedded chunk so we don&squot;t free it below.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
(brace
(paren
r_void
)paren
id|xfs_trans_unlock_chunk
c_func
(paren
id|licp
comma
l_int|1
comma
m_abort
comma
id|NULLCOMMITLSN
)paren
suffix:semicolon
id|XFS_LIC_ALL_FREE
c_func
(paren
id|licp
)paren
suffix:semicolon
id|licp-&gt;lic_unused
op_assign
l_int|0
suffix:semicolon
)brace
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
multiline_comment|/*&n;&t; * Unlock each item in each chunk and free the chunks.&n;&t; */
r_while
c_loop
(paren
id|licp
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_trans_unlock_chunk
c_func
(paren
id|licp
comma
l_int|1
comma
m_abort
comma
id|NULLCOMMITLSN
)paren
suffix:semicolon
id|next_licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
id|kmem_free
c_func
(paren
id|licp
comma
r_sizeof
(paren
id|xfs_log_item_chunk_t
)paren
)paren
suffix:semicolon
id|licp
op_assign
id|next_licp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reset the transaction structure&squot;s free item count.&n;&t; */
id|tp-&gt;t_items_free
op_assign
id|XFS_LIC_NUM_SLOTS
suffix:semicolon
id|tp-&gt;t_items.lic_next
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to unlock the items associated with a transaction.&n; * Items which were not logged should be freed.&n; * Those which were logged must still be tracked so they can be unpinned&n; * when the transaction commits.&n; */
r_void
DECL|function|xfs_trans_unlock_items
id|xfs_trans_unlock_items
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_lsn_t
id|commit_lsn
)paren
(brace
id|xfs_log_item_chunk_t
op_star
id|licp
suffix:semicolon
id|xfs_log_item_chunk_t
op_star
id|next_licp
suffix:semicolon
id|xfs_log_item_chunk_t
op_star
op_star
id|licpp
suffix:semicolon
r_int
id|freed
suffix:semicolon
id|freed
op_assign
l_int|0
suffix:semicolon
id|licp
op_assign
op_amp
id|tp-&gt;t_items
suffix:semicolon
multiline_comment|/*&n;&t; * Special case the embedded chunk so we don&squot;t free.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
(brace
id|freed
op_assign
id|xfs_trans_unlock_chunk
c_func
(paren
id|licp
comma
l_int|0
comma
l_int|0
comma
id|commit_lsn
)paren
suffix:semicolon
)brace
id|licpp
op_assign
op_amp
(paren
id|tp-&gt;t_items.lic_next
)paren
suffix:semicolon
id|licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
multiline_comment|/*&n;&t; * Unlock each item in each chunk, free non-dirty descriptors,&n;&t; * and free empty chunks.&n;&t; */
r_while
c_loop
(paren
id|licp
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
suffix:semicolon
id|freed
op_add_assign
id|xfs_trans_unlock_chunk
c_func
(paren
id|licp
comma
l_int|0
comma
l_int|0
comma
id|commit_lsn
)paren
suffix:semicolon
id|next_licp
op_assign
id|licp-&gt;lic_next
suffix:semicolon
r_if
c_cond
(paren
id|XFS_LIC_ARE_ALL_FREE
c_func
(paren
id|licp
)paren
)paren
(brace
op_star
id|licpp
op_assign
id|next_licp
suffix:semicolon
id|kmem_free
c_func
(paren
id|licp
comma
r_sizeof
(paren
id|xfs_log_item_chunk_t
)paren
)paren
suffix:semicolon
id|freed
op_sub_assign
id|XFS_LIC_NUM_SLOTS
suffix:semicolon
)brace
r_else
(brace
id|licpp
op_assign
op_amp
(paren
id|licp-&gt;lic_next
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_star
id|licpp
op_eq
id|next_licp
)paren
suffix:semicolon
id|licp
op_assign
id|next_licp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fix the free descriptor count in the transaction.&n;&t; */
id|tp-&gt;t_items_free
op_add_assign
id|freed
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlock each item pointed to by a descriptor in the given chunk.&n; * Stamp the commit lsn into each item if necessary.&n; * Free descriptors pointing to items which are not dirty if freeing_chunk&n; * is zero. If freeing_chunk is non-zero, then we need to unlock all&n; * items in the chunk including those with XFS_LID_SYNC_UNLOCK set.&n; * Return the number of descriptors freed.&n; */
id|STATIC
r_int
DECL|function|xfs_trans_unlock_chunk
id|xfs_trans_unlock_chunk
c_func
(paren
id|xfs_log_item_chunk_t
op_star
id|licp
comma
r_int
id|freeing_chunk
comma
r_int
m_abort
comma
id|xfs_lsn_t
id|commit_lsn
)paren
(brace
id|xfs_log_item_desc_t
op_star
id|lidp
suffix:semicolon
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|freed
suffix:semicolon
id|freed
op_assign
l_int|0
suffix:semicolon
id|lidp
op_assign
id|licp-&gt;lic_descs
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|licp-&gt;lic_unused
suffix:semicolon
id|i
op_increment
comma
id|lidp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_LIC_ISFREE
c_func
(paren
id|licp
comma
id|i
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|lip
op_assign
id|lidp-&gt;lid_item
suffix:semicolon
id|lip-&gt;li_desc
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|commit_lsn
op_ne
id|NULLCOMMITLSN
)paren
id|IOP_COMMITTING
c_func
(paren
id|lip
comma
id|commit_lsn
)paren
suffix:semicolon
multiline_comment|/* XXXsup */
r_if
c_cond
(paren
m_abort
)paren
id|lip-&gt;li_flags
op_or_assign
id|XFS_LI_ABORTED
suffix:semicolon
multiline_comment|/* if (abort) {&n;&t;&t;&t;IOP_ABORT(lip);&n;&t;&t;} else */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_SYNC_UNLOCK
)paren
op_logical_or
id|freeing_chunk
op_logical_or
m_abort
)paren
(brace
id|IOP_UNLOCK
c_func
(paren
id|lip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Free the descriptor if the item is not dirty&n;&t;&t; * within this transaction and the caller is not&n;&t;&t; * going to just free the entire thing regardless.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|freeing_chunk
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|lidp-&gt;lid_flags
op_amp
id|XFS_LID_DIRTY
)paren
op_logical_or
m_abort
)paren
)paren
(brace
id|XFS_LIC_RELSE
c_func
(paren
id|licp
comma
id|i
)paren
suffix:semicolon
id|freed
op_increment
suffix:semicolon
)brace
)brace
r_return
(paren
id|freed
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to add the given busy item to the transaction&squot;s&n; * list of busy items.  It must find a free busy item descriptor&n; * or allocate a new one and add the item to that descriptor.&n; * The function returns a pointer to busy descriptor used to point&n; * to the new busy entry.  The log busy entry will now point to its new&n; * descriptor with its ???? field.&n; */
id|xfs_log_busy_slot_t
op_star
DECL|function|xfs_trans_add_busy
id|xfs_trans_add_busy
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_agnumber_t
id|ag
comma
id|xfs_extlen_t
id|idx
)paren
(brace
id|xfs_log_busy_chunk_t
op_star
id|lbcp
suffix:semicolon
id|xfs_log_busy_slot_t
op_star
id|lbsp
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If there are no free descriptors, allocate a new chunk&n;&t; * of them and put it at the front of the chunk list.&n;&t; */
r_if
c_cond
(paren
id|tp-&gt;t_busy_free
op_eq
l_int|0
)paren
(brace
id|lbcp
op_assign
(paren
id|xfs_log_busy_chunk_t
op_star
)paren
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
id|xfs_log_busy_chunk_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lbcp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the chunk, and then&n;&t;&t; * claim the first slot in the newly allocated chunk.&n;&t;&t; */
id|XFS_LBC_INIT
c_func
(paren
id|lbcp
)paren
suffix:semicolon
id|XFS_LBC_CLAIM
c_func
(paren
id|lbcp
comma
l_int|0
)paren
suffix:semicolon
id|lbcp-&gt;lbc_unused
op_assign
l_int|1
suffix:semicolon
id|lbsp
op_assign
id|XFS_LBC_SLOT
c_func
(paren
id|lbcp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Link in the new chunk and update the free count.&n;&t;&t; */
id|lbcp-&gt;lbc_next
op_assign
id|tp-&gt;t_busy.lbc_next
suffix:semicolon
id|tp-&gt;t_busy.lbc_next
op_assign
id|lbcp
suffix:semicolon
id|tp-&gt;t_busy_free
op_assign
id|XFS_LIC_NUM_SLOTS
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Initialize the descriptor and the generic portion&n;&t;&t; * of the log item.&n;&t;&t; *&n;&t;&t; * Point the new slot at this item and return it.&n;&t;&t; * Also point the log item at its currently active&n;&t;&t; * descriptor and set the item&squot;s mount pointer.&n;&t;&t; */
id|lbsp-&gt;lbc_ag
op_assign
id|ag
suffix:semicolon
id|lbsp-&gt;lbc_idx
op_assign
id|idx
suffix:semicolon
r_return
(paren
id|lbsp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the free descriptor. It is somewhere in the chunklist&n;&t; * of descriptors.&n;&t; */
id|lbcp
op_assign
op_amp
id|tp-&gt;t_busy
suffix:semicolon
r_while
c_loop
(paren
id|lbcp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|XFS_LBC_VACANCY
c_func
(paren
id|lbcp
)paren
)paren
(brace
r_if
c_cond
(paren
id|lbcp-&gt;lbc_unused
op_le
id|XFS_LBC_MAX_SLOT
)paren
(brace
id|i
op_assign
id|lbcp-&gt;lbc_unused
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* out-of-order vacancy */
id|printk
c_func
(paren
l_string|&quot;OOO vacancy lbcp 0x%p&bslash;n&quot;
comma
id|lbcp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|lbcp
op_assign
id|lbcp-&gt;lbc_next
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|lbcp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we find a free descriptor, claim it,&n;&t; * initialize it, and return it.&n;&t; */
id|XFS_LBC_CLAIM
c_func
(paren
id|lbcp
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbcp-&gt;lbc_unused
op_le
id|i
)paren
(brace
id|lbcp-&gt;lbc_unused
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|lbsp
op_assign
id|XFS_LBC_SLOT
c_func
(paren
id|lbcp
comma
id|i
)paren
suffix:semicolon
id|tp-&gt;t_busy_free
op_decrement
suffix:semicolon
id|lbsp-&gt;lbc_ag
op_assign
id|ag
suffix:semicolon
id|lbsp-&gt;lbc_idx
op_assign
id|idx
suffix:semicolon
r_return
(paren
id|lbsp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_trans_free_busy&n; * Free all of the busy lists from a transaction&n; */
r_void
DECL|function|xfs_trans_free_busy
id|xfs_trans_free_busy
c_func
(paren
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_log_busy_chunk_t
op_star
id|lbcp
suffix:semicolon
id|xfs_log_busy_chunk_t
op_star
id|lbcq
suffix:semicolon
id|lbcp
op_assign
id|tp-&gt;t_busy.lbc_next
suffix:semicolon
r_while
c_loop
(paren
id|lbcp
op_ne
l_int|NULL
)paren
(brace
id|lbcq
op_assign
id|lbcp-&gt;lbc_next
suffix:semicolon
id|kmem_free
c_func
(paren
id|lbcp
comma
r_sizeof
(paren
id|xfs_log_busy_chunk_t
)paren
)paren
suffix:semicolon
id|lbcp
op_assign
id|lbcq
suffix:semicolon
)brace
id|XFS_LBC_INIT
c_func
(paren
op_amp
id|tp-&gt;t_busy
)paren
suffix:semicolon
id|tp-&gt;t_busy.lbc_unused
op_assign
l_int|0
suffix:semicolon
)brace
eof
