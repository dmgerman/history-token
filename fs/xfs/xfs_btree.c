multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * This file contains common code for the space manager&squot;s btree implementations.&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
multiline_comment|/*&n; * Cursor allocation zone.&n; */
DECL|variable|xfs_btree_cur_zone
id|kmem_zone_t
op_star
id|xfs_btree_cur_zone
suffix:semicolon
multiline_comment|/*&n; * Btree magic numbers.&n; */
DECL|variable|xfs_magics
r_const
id|__uint32_t
id|xfs_magics
(braket
id|XFS_BTNUM_MAX
)braket
op_assign
(brace
id|XFS_ABTB_MAGIC
comma
id|XFS_ABTC_MAGIC
comma
id|XFS_BMAP_MAGIC
comma
id|XFS_IBT_MAGIC
)brace
suffix:semicolon
multiline_comment|/*&n; * Prototypes for internal routines.&n; */
multiline_comment|/*&n; * Checking routine: return maxrecs for the block.&n; */
id|STATIC
r_int
multiline_comment|/* number of records fitting in block */
id|xfs_btree_maxrecs
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_btree_block_t
op_star
id|block
)paren
suffix:semicolon
multiline_comment|/* generic btree block pointer */
multiline_comment|/*&n; * Internal routines.&n; */
multiline_comment|/*&n; * Checking routine: return maxrecs for the block.&n; */
id|STATIC
r_int
multiline_comment|/* number of records fitting in block */
DECL|function|xfs_btree_maxrecs
id|xfs_btree_maxrecs
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_btree_block_t
op_star
id|block
)paren
multiline_comment|/* generic btree block pointer */
(brace
r_switch
c_cond
(paren
id|cur-&gt;bc_btnum
)paren
(brace
r_case
id|XFS_BTNUM_BNO
suffix:colon
r_case
id|XFS_BTNUM_CNT
suffix:colon
r_return
(paren
r_int
)paren
id|XFS_ALLOC_BLOCK_MAXRECS
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_h.bb_level
comma
id|ARCH_CONVERT
)paren
comma
id|cur
)paren
suffix:semicolon
r_case
id|XFS_BTNUM_BMAP
suffix:colon
r_return
(paren
r_int
)paren
id|XFS_BMAP_BLOCK_IMAXRECS
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_h.bb_level
comma
id|ARCH_CONVERT
)paren
comma
id|cur
)paren
suffix:semicolon
r_case
id|XFS_BTNUM_INO
suffix:colon
r_return
(paren
r_int
)paren
id|XFS_INOBT_BLOCK_MAXRECS
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_h.bb_level
comma
id|ARCH_CONVERT
)paren
comma
id|cur
)paren
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * External routines.&n; */
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Debug routine: check that block header is ok.&n; */
r_void
DECL|function|xfs_btree_check_block
id|xfs_btree_check_block
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_btree_block_t
op_star
id|block
comma
multiline_comment|/* generic btree block pointer */
r_int
id|level
comma
multiline_comment|/* level of the btree block */
id|xfs_buf_t
op_star
id|bp
)paren
multiline_comment|/* buffer containing block, if any */
(brace
r_if
c_cond
(paren
id|XFS_BTREE_LONG_PTRS
c_func
(paren
id|cur-&gt;bc_btnum
)paren
)paren
id|xfs_btree_check_lblock
c_func
(paren
id|cur
comma
(paren
id|xfs_btree_lblock_t
op_star
)paren
id|block
comma
id|level
comma
id|bp
)paren
suffix:semicolon
r_else
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
(paren
id|xfs_btree_sblock_t
op_star
)paren
id|block
comma
id|level
comma
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Debug routine: check that keys are in the right order.&n; */
r_void
DECL|function|xfs_btree_check_key
id|xfs_btree_check_key
c_func
(paren
id|xfs_btnum_t
id|btnum
comma
multiline_comment|/* btree identifier */
r_void
op_star
id|ak1
comma
multiline_comment|/* pointer to left (lower) key */
r_void
op_star
id|ak2
)paren
multiline_comment|/* pointer to right (higher) key */
(brace
r_switch
c_cond
(paren
id|btnum
)paren
(brace
r_case
id|XFS_BTNUM_BNO
suffix:colon
(brace
id|xfs_alloc_key_t
op_star
id|k1
suffix:semicolon
id|xfs_alloc_key_t
op_star
id|k2
suffix:semicolon
id|k1
op_assign
id|ak1
suffix:semicolon
id|k2
op_assign
id|ak2
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|k1-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|k2-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|XFS_BTNUM_CNT
suffix:colon
(brace
id|xfs_alloc_key_t
op_star
id|k1
suffix:semicolon
id|xfs_alloc_key_t
op_star
id|k2
suffix:semicolon
id|k1
op_assign
id|ak1
suffix:semicolon
id|k2
op_assign
id|ak2
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|k1-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|k2-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|k1-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|k2-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|k1-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|k2-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|XFS_BTNUM_BMAP
suffix:colon
(brace
id|xfs_bmbt_key_t
op_star
id|k1
suffix:semicolon
id|xfs_bmbt_key_t
op_star
id|k2
suffix:semicolon
id|k1
op_assign
id|ak1
suffix:semicolon
id|k2
op_assign
id|ak2
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|k1-&gt;br_startoff
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|k2-&gt;br_startoff
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|XFS_BTNUM_INO
suffix:colon
(brace
id|xfs_inobt_key_t
op_star
id|k1
suffix:semicolon
id|xfs_inobt_key_t
op_star
id|k2
suffix:semicolon
id|k1
op_assign
id|ak1
suffix:semicolon
id|k2
op_assign
id|ak2
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|k1-&gt;ir_startino
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|k2-&gt;ir_startino
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/*&n; * Checking routine: check that long form block header is ok.&n; */
multiline_comment|/* ARGSUSED */
r_int
multiline_comment|/* error (0 or EFSCORRUPTED) */
DECL|function|xfs_btree_check_lblock
id|xfs_btree_check_lblock
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_btree_lblock_t
op_star
id|block
comma
multiline_comment|/* btree long form block pointer */
r_int
id|level
comma
multiline_comment|/* level of the btree block */
id|xfs_buf_t
op_star
id|bp
)paren
multiline_comment|/* buffer for block, if any */
(brace
r_int
id|lblock_ok
suffix:semicolon
multiline_comment|/* block passes checks */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount point */
id|mp
op_assign
id|cur-&gt;bc_mp
suffix:semicolon
id|lblock_ok
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|xfs_magics
(braket
id|cur-&gt;bc_btnum
)braket
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
op_eq
id|level
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_le
id|xfs_btree_maxrecs
c_func
(paren
id|cur
comma
(paren
id|xfs_btree_block_t
op_star
)paren
id|block
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDFSBNO
op_logical_or
id|XFS_FSB_SANITY_CHECK
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDFSBNO
op_logical_or
id|XFS_FSB_SANITY_CHECK
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|lblock_ok
comma
id|mp
comma
id|XFS_ERRTAG_BTREE_CHECK_LBLOCK
comma
id|XFS_RANDOM_BTREE_CHECK_LBLOCK
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|bp
)paren
id|xfs_buftrace
c_func
(paren
l_string|&quot;LBTREE ERROR&quot;
comma
id|bp
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_btree_check_lblock&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Checking routine: check that (long) pointer is ok.&n; */
r_int
multiline_comment|/* error (0 or EFSCORRUPTED) */
DECL|function|xfs_btree_check_lptr
id|xfs_btree_check_lptr
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_dfsbno_t
id|ptr
comma
multiline_comment|/* btree block disk address */
r_int
id|level
)paren
multiline_comment|/* btree block level */
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount point */
id|mp
op_assign
id|cur-&gt;bc_mp
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|level
OG
l_int|0
op_logical_and
id|ptr
op_ne
id|NULLDFSBNO
op_logical_and
id|XFS_FSB_SANITY_CHECK
c_func
(paren
id|mp
comma
id|ptr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Debug routine: check that records are in the right order.&n; */
r_void
DECL|function|xfs_btree_check_rec
id|xfs_btree_check_rec
c_func
(paren
id|xfs_btnum_t
id|btnum
comma
multiline_comment|/* btree identifier */
r_void
op_star
id|ar1
comma
multiline_comment|/* pointer to left (lower) record */
r_void
op_star
id|ar2
)paren
multiline_comment|/* pointer to right (higher) record */
(brace
r_switch
c_cond
(paren
id|btnum
)paren
(brace
r_case
id|XFS_BTNUM_BNO
suffix:colon
(brace
id|xfs_alloc_rec_t
op_star
id|r1
suffix:semicolon
id|xfs_alloc_rec_t
op_star
id|r2
suffix:semicolon
id|r1
op_assign
id|ar1
suffix:semicolon
id|r2
op_assign
id|ar2
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|r1-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|r2-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|XFS_BTNUM_CNT
suffix:colon
(brace
id|xfs_alloc_rec_t
op_star
id|r1
suffix:semicolon
id|xfs_alloc_rec_t
op_star
id|r2
suffix:semicolon
id|r1
op_assign
id|ar1
suffix:semicolon
id|r2
op_assign
id|ar2
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|r2-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|r2-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|r1-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|r2-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|XFS_BTNUM_BMAP
suffix:colon
(brace
id|xfs_bmbt_rec_t
op_star
id|r1
suffix:semicolon
id|xfs_bmbt_rec_t
op_star
id|r2
suffix:semicolon
id|r1
op_assign
id|ar1
suffix:semicolon
id|r2
op_assign
id|ar2
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_bmbt_disk_get_startoff
c_func
(paren
id|r1
)paren
op_plus
id|xfs_bmbt_disk_get_blockcount
c_func
(paren
id|r1
)paren
op_le
id|xfs_bmbt_disk_get_startoff
c_func
(paren
id|r2
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|XFS_BTNUM_INO
suffix:colon
(brace
id|xfs_inobt_rec_t
op_star
id|r1
suffix:semicolon
id|xfs_inobt_rec_t
op_star
id|r2
suffix:semicolon
id|r1
op_assign
id|ar1
suffix:semicolon
id|r2
op_assign
id|ar2
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|r1-&gt;ir_startino
comma
id|ARCH_CONVERT
)paren
op_plus
id|XFS_INODES_PER_CHUNK
op_le
id|INT_GET
c_func
(paren
id|r2-&gt;ir_startino
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/*&n; * Checking routine: check that block header is ok.&n; */
multiline_comment|/* ARGSUSED */
r_int
multiline_comment|/* error (0 or EFSCORRUPTED) */
DECL|function|xfs_btree_check_sblock
id|xfs_btree_check_sblock
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_btree_sblock_t
op_star
id|block
comma
multiline_comment|/* btree short form block pointer */
r_int
id|level
comma
multiline_comment|/* level of the btree block */
id|xfs_buf_t
op_star
id|bp
)paren
multiline_comment|/* buffer containing block */
(brace
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* buffer for ag. freespace struct */
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* ag. freespace structure */
id|xfs_agblock_t
id|agflen
suffix:semicolon
multiline_comment|/* native ag. freespace length */
r_int
id|sblock_ok
suffix:semicolon
multiline_comment|/* block passes checks */
id|agbp
op_assign
id|cur-&gt;bc_private.a.agbp
suffix:semicolon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|agflen
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sblock_ok
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|xfs_magics
(braket
id|cur-&gt;bc_btnum
)braket
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
op_eq
id|level
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_le
id|xfs_btree_maxrecs
c_func
(paren
id|cur
comma
(paren
id|xfs_btree_block_t
op_star
)paren
id|block
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
op_logical_or
id|INT_GET
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
OL
id|agflen
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
op_logical_or
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
OL
id|agflen
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|sblock_ok
comma
id|cur-&gt;bc_mp
comma
id|XFS_ERRTAG_BTREE_CHECK_SBLOCK
comma
id|XFS_RANDOM_BTREE_CHECK_SBLOCK
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|bp
)paren
id|xfs_buftrace
c_func
(paren
l_string|&quot;SBTREE ERROR&quot;
comma
id|bp
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_btree_check_sblock&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|cur-&gt;bc_mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Checking routine: check that (short) pointer is ok.&n; */
r_int
multiline_comment|/* error (0 or EFSCORRUPTED) */
DECL|function|xfs_btree_check_sptr
id|xfs_btree_check_sptr
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_agblock_t
id|ptr
comma
multiline_comment|/* btree block disk address */
r_int
id|level
)paren
multiline_comment|/* btree block level */
(brace
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* buffer for ag. freespace struct */
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* ag. freespace structure */
id|agbp
op_assign
id|cur-&gt;bc_private.a.agbp
suffix:semicolon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|level
OG
l_int|0
op_logical_and
id|ptr
op_ne
id|NULLAGBLOCK
op_logical_and
id|ptr
op_ne
l_int|0
op_logical_and
id|ptr
OL
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete the btree cursor.&n; */
r_void
DECL|function|xfs_btree_del_cursor
id|xfs_btree_del_cursor
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|error
)paren
multiline_comment|/* del because of error */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* btree level */
multiline_comment|/*&n;&t; * Clear the buffer pointers, and release the buffers.&n;&t; * If we&squot;re doing this in the face of an error, we&n;&t; * need to make sure to inspect all of the entries&n;&t; * in the bc_bufs array for buffers to be unlocked.&n;&t; * This is because some of the btree code works from&n;&t; * level n down to 0, and if we get an error along&n;&t; * the way we won&squot;t have initialized all the entries&n;&t; * down to 0.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cur-&gt;bc_nlevels
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;bc_bufs
(braket
id|i
)braket
)paren
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|i
comma
l_int|NULL
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Can&squot;t free a bmap cursor without having dealt with the&n;&t; * allocated indirect blocks&squot; accounting.&n;&t; */
id|ASSERT
c_func
(paren
id|cur-&gt;bc_btnum
op_ne
id|XFS_BTNUM_BMAP
op_logical_or
id|cur-&gt;bc_private.b.allocated
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free the cursor.&n;&t; */
id|kmem_zone_free
c_func
(paren
id|xfs_btree_cur_zone
comma
id|cur
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Duplicate the btree cursor.&n; * Allocate a new one, copy the record, re-get the buffers.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_btree_dup_cursor
id|xfs_btree_dup_cursor
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* input cursor */
id|xfs_btree_cur_t
op_star
op_star
id|ncur
)paren
multiline_comment|/* output cursor */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* btree block&squot;s buffer pointer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* level number of btree block */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure for filesystem */
id|xfs_btree_cur_t
op_star
r_new
suffix:semicolon
multiline_comment|/* new cursor value */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer, can be NULL */
id|tp
op_assign
id|cur-&gt;bc_tp
suffix:semicolon
id|mp
op_assign
id|cur-&gt;bc_mp
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a new cursor like the old one.&n;&t; */
r_new
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
id|cur-&gt;bc_private.a.agbp
comma
id|cur-&gt;bc_private.a.agno
comma
id|cur-&gt;bc_btnum
comma
id|cur-&gt;bc_private.b.ip
comma
id|cur-&gt;bc_private.b.whichfork
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the record currently in the cursor.&n;&t; */
r_new
op_member_access_from_pointer
id|bc_rec
op_assign
id|cur-&gt;bc_rec
suffix:semicolon
multiline_comment|/*&n;&t; * For each level current, re-get the buffer and copy the ptr value.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_new
op_member_access_from_pointer
id|bc_nlevels
suffix:semicolon
id|i
op_increment
)paren
(brace
r_new
op_member_access_from_pointer
id|bc_ptrs
(braket
id|i
)braket
op_assign
id|cur-&gt;bc_ptrs
(braket
id|i
)braket
suffix:semicolon
r_new
op_member_access_from_pointer
id|bc_ra
(braket
id|i
)braket
op_assign
id|cur-&gt;bc_ra
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|i
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
comma
id|mp-&gt;m_bsize
comma
l_int|0
comma
op_amp
id|bp
)paren
)paren
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
r_new
comma
id|error
)paren
suffix:semicolon
op_star
id|ncur
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_new
op_member_access_from_pointer
id|bc_bufs
(braket
id|i
)braket
op_assign
id|bp
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
r_else
r_new
op_member_access_from_pointer
id|bc_bufs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For bmap btrees, copy the firstblock, flist, and flags values,&n;&t; * since init cursor doesn&squot;t get them.&n;&t; */
r_if
c_cond
(paren
r_new
op_member_access_from_pointer
id|bc_btnum
op_eq
id|XFS_BTNUM_BMAP
)paren
(brace
r_new
op_member_access_from_pointer
id|bc_private.b.firstblock
op_assign
id|cur-&gt;bc_private.b.firstblock
suffix:semicolon
r_new
op_member_access_from_pointer
id|bc_private.b.flist
op_assign
id|cur-&gt;bc_private.b.flist
suffix:semicolon
r_new
op_member_access_from_pointer
id|bc_private.b.flags
op_assign
id|cur-&gt;bc_private.b.flags
suffix:semicolon
)brace
op_star
id|ncur
op_assign
r_new
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Change the cursor to point to the first record at the given level.&n; * Other levels are unaffected.&n; */
r_int
multiline_comment|/* success=1, failure=0 */
DECL|function|xfs_btree_firstrec
id|xfs_btree_firstrec
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
)paren
multiline_comment|/* level to change */
(brace
id|xfs_btree_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* generic btree block pointer */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer containing block */
multiline_comment|/*&n;&t; * Get the block pointer for this level.&n;&t; */
id|block
op_assign
id|xfs_btree_get_block
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|bp
)paren
suffix:semicolon
id|xfs_btree_check_block
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It&squot;s empty, there is no such record.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|block-&gt;bb_h.bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set the ptr value to 1, that&squot;s the first record/key.&n;&t; */
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Retrieve the block pointer from the cursor at the given level.&n; * This may be a bmap btree root or from a buffer.&n; */
id|xfs_btree_block_t
op_star
multiline_comment|/* generic btree block pointer */
DECL|function|xfs_btree_get_block
id|xfs_btree_get_block
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level in btree */
id|xfs_buf_t
op_star
op_star
id|bpp
)paren
multiline_comment|/* buffer containing the block */
(brace
id|xfs_btree_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* return value */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* return buffer */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
r_int
id|whichfork
suffix:semicolon
multiline_comment|/* data or attr fork */
r_if
c_cond
(paren
id|cur-&gt;bc_btnum
op_eq
id|XFS_BTNUM_BMAP
op_logical_and
id|level
op_eq
id|cur-&gt;bc_nlevels
op_minus
l_int|1
)paren
(brace
id|whichfork
op_assign
id|cur-&gt;bc_private.b.whichfork
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|cur-&gt;bc_private.b.ip
comma
id|whichfork
)paren
suffix:semicolon
id|block
op_assign
(paren
id|xfs_btree_block_t
op_star
)paren
id|ifp-&gt;if_broot
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|block
op_ne
l_int|NULL
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
id|block
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a buffer for the block, return it with no data read.&n; * Long-form addressing.&n; */
id|xfs_buf_t
op_star
multiline_comment|/* buffer for fsbno */
DECL|function|xfs_btree_get_bufl
id|xfs_btree_get_bufl
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_fsblock_t
id|fsbno
comma
multiline_comment|/* file system block number */
id|uint
id|lock
)paren
multiline_comment|/* lock flags for get_buf */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer pointer (return value) */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* real disk block address */
id|ASSERT
c_func
(paren
id|fsbno
op_ne
id|NULLFSBLOCK
)paren
suffix:semicolon
id|d
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|fsbno
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
comma
id|lock
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_return
id|bp
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a buffer for the block, return it with no data read.&n; * Short-form addressing.&n; */
id|xfs_buf_t
op_star
multiline_comment|/* buffer for agno/agbno */
DECL|function|xfs_btree_get_bufs
id|xfs_btree_get_bufs
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_agblock_t
id|agbno
comma
multiline_comment|/* allocation group block number */
id|uint
id|lock
)paren
multiline_comment|/* lock flags for get_buf */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer pointer (return value) */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* real disk block address */
id|ASSERT
c_func
(paren
id|agno
op_ne
id|NULLAGNUMBER
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agbno
op_ne
id|NULLAGBLOCK
)paren
suffix:semicolon
id|d
op_assign
id|XFS_AGB_TO_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
comma
id|lock
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_return
id|bp
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a new btree cursor.&n; * The cursor is either for allocation (A) or bmap (B) or inodes (I).&n; */
id|xfs_btree_cur_t
op_star
multiline_comment|/* new btree cursor */
DECL|function|xfs_btree_init_cursor
id|xfs_btree_init_cursor
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|agbp
comma
multiline_comment|/* (A only) buffer for agf structure */
multiline_comment|/* (I only) buffer for agi structure */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* (AI only) allocation group number */
id|xfs_btnum_t
id|btnum
comma
multiline_comment|/* btree identifier */
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* (B only) inode owning the btree */
r_int
id|whichfork
)paren
multiline_comment|/* (B only) data or attr fork */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* (A) allocation group freespace */
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
multiline_comment|/* (I) allocation group inodespace */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* return value */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* (I) inode fork pointer */
r_int
id|nlevels
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of levels in the btree */
id|ASSERT
c_func
(paren
id|xfs_btree_cur_zone
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a new cursor.&n;&t; */
id|cur
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_btree_cur_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Deduce the number of btree levels from the arguments.&n;&t; */
r_switch
c_cond
(paren
id|btnum
)paren
(brace
r_case
id|XFS_BTNUM_BNO
suffix:colon
r_case
id|XFS_BTNUM_CNT
suffix:colon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|nlevels
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|btnum
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_BTNUM_BMAP
suffix:colon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|nlevels
op_assign
id|INT_GET
c_func
(paren
id|ifp-&gt;if_broot-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_BTNUM_INO
suffix:colon
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|nlevels
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_level
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the common fields.&n;&t; */
id|cur-&gt;bc_tp
op_assign
id|tp
suffix:semicolon
id|cur-&gt;bc_mp
op_assign
id|mp
suffix:semicolon
id|cur-&gt;bc_nlevels
op_assign
id|nlevels
suffix:semicolon
id|cur-&gt;bc_btnum
op_assign
id|btnum
suffix:semicolon
id|cur-&gt;bc_blocklog
op_assign
id|mp-&gt;m_sb.sb_blocklog
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in private fields.&n;&t; */
r_switch
c_cond
(paren
id|btnum
)paren
(brace
r_case
id|XFS_BTNUM_BNO
suffix:colon
r_case
id|XFS_BTNUM_CNT
suffix:colon
multiline_comment|/*&n;&t;&t; * Allocation btree fields.&n;&t;&t; */
id|cur-&gt;bc_private.a.agbp
op_assign
id|agbp
suffix:semicolon
id|cur-&gt;bc_private.a.agno
op_assign
id|agno
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_BTNUM_BMAP
suffix:colon
multiline_comment|/*&n;&t;&t; * Bmap btree fields.&n;&t;&t; */
id|cur-&gt;bc_private.b.forksize
op_assign
id|XFS_IFORK_SIZE
c_func
(paren
id|ip
comma
id|whichfork
)paren
suffix:semicolon
id|cur-&gt;bc_private.b.ip
op_assign
id|ip
suffix:semicolon
id|cur-&gt;bc_private.b.firstblock
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|cur-&gt;bc_private.b.flist
op_assign
l_int|NULL
suffix:semicolon
id|cur-&gt;bc_private.b.allocated
op_assign
l_int|0
suffix:semicolon
id|cur-&gt;bc_private.b.flags
op_assign
l_int|0
suffix:semicolon
id|cur-&gt;bc_private.b.whichfork
op_assign
id|whichfork
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_BTNUM_INO
suffix:colon
multiline_comment|/*&n;&t;&t; * Inode allocation btree fields.&n;&t;&t; */
id|cur-&gt;bc_private.i.agbp
op_assign
id|agbp
suffix:semicolon
id|cur-&gt;bc_private.i.agno
op_assign
id|agno
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|cur
suffix:semicolon
)brace
multiline_comment|/*&n; * Check for the cursor referring to the last block at the given level.&n; */
r_int
multiline_comment|/* 1=is last block, 0=not last block */
DECL|function|xfs_btree_islastblock
id|xfs_btree_islastblock
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
)paren
multiline_comment|/* level to check */
(brace
id|xfs_btree_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* generic btree block pointer */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer containing block */
id|block
op_assign
id|xfs_btree_get_block
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|bp
)paren
suffix:semicolon
id|xfs_btree_check_block
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BTREE_LONG_PTRS
c_func
(paren
id|cur-&gt;bc_btnum
)paren
)paren
r_return
id|INT_GET
c_func
(paren
id|block-&gt;bb_u.l.bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDFSBNO
suffix:semicolon
r_else
r_return
id|INT_GET
c_func
(paren
id|block-&gt;bb_u.s.bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
suffix:semicolon
)brace
multiline_comment|/*&n; * Change the cursor to point to the last record in the current block&n; * at the given level.  Other levels are unaffected.&n; */
r_int
multiline_comment|/* success=1, failure=0 */
DECL|function|xfs_btree_lastrec
id|xfs_btree_lastrec
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
)paren
multiline_comment|/* level to change */
(brace
id|xfs_btree_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* generic btree block pointer */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer containing block */
multiline_comment|/*&n;&t; * Get the block pointer for this level.&n;&t; */
id|block
op_assign
id|xfs_btree_get_block
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|bp
)paren
suffix:semicolon
id|xfs_btree_check_block
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It&squot;s empty, there is no such record.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|block-&gt;bb_h.bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Set the ptr value to numrecs, that&squot;s the last record/key.&n;&t; */
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_h.bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Compute first and last byte offsets for the fields given.&n; * Interprets the offsets table, which contains struct field offsets.&n; */
r_void
DECL|function|xfs_btree_offsets
id|xfs_btree_offsets
c_func
(paren
id|__int64_t
id|fields
comma
multiline_comment|/* bitmask of fields */
r_const
r_int
op_star
id|offsets
comma
multiline_comment|/* table of field offsets */
r_int
id|nbits
comma
multiline_comment|/* number of bits to inspect */
r_int
op_star
id|first
comma
multiline_comment|/* output: first byte offset */
r_int
op_star
id|last
)paren
multiline_comment|/* output: last byte offset */
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* current bit number */
id|__int64_t
id|imask
suffix:semicolon
multiline_comment|/* mask for current bit number */
id|ASSERT
c_func
(paren
id|fields
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the lowest bit, so the first byte offset.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|imask
op_assign
l_int|1LL
suffix:semicolon
suffix:semicolon
id|i
op_increment
comma
id|imask
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|imask
op_amp
id|fields
)paren
(brace
op_star
id|first
op_assign
id|offsets
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Find the highest bit, so the last byte offset.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|nbits
op_minus
l_int|1
comma
id|imask
op_assign
l_int|1LL
op_lshift
id|i
suffix:semicolon
suffix:semicolon
id|i
op_decrement
comma
id|imask
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|imask
op_amp
id|fields
)paren
(brace
op_star
id|last
op_assign
id|offsets
(braket
id|i
op_plus
l_int|1
)braket
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Get a buffer for the block, return it read in.&n; * Long-form addressing.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_btree_read_bufl
id|xfs_btree_read_bufl
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_fsblock_t
id|fsbno
comma
multiline_comment|/* file system block number */
id|uint
id|lock
comma
multiline_comment|/* lock flags for read_buf */
id|xfs_buf_t
op_star
op_star
id|bpp
comma
multiline_comment|/* buffer for fsbno */
r_int
id|refval
)paren
multiline_comment|/* ref count value for buffer */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* return value */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* real disk block address */
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|fsbno
op_ne
id|NULLFSBLOCK
)paren
suffix:semicolon
id|d
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|fsbno
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
comma
id|lock
comma
op_amp
id|bp
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|bp
op_logical_or
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_MAP
comma
id|refval
)paren
suffix:semicolon
)brace
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a buffer for the block, return it read in.&n; * Short-form addressing.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_btree_read_bufs
id|xfs_btree_read_bufs
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_agblock_t
id|agbno
comma
multiline_comment|/* allocation group block number */
id|uint
id|lock
comma
multiline_comment|/* lock flags for read_buf */
id|xfs_buf_t
op_star
op_star
id|bpp
comma
multiline_comment|/* buffer for agno/agbno */
r_int
id|refval
)paren
multiline_comment|/* ref count value for buffer */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* return value */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* real disk block address */
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|agno
op_ne
id|NULLAGNUMBER
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agbno
op_ne
id|NULLAGBLOCK
)paren
suffix:semicolon
id|d
op_assign
id|XFS_AGB_TO_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
comma
id|lock
comma
op_amp
id|bp
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|bp
op_logical_or
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|refval
)paren
(brace
r_case
id|XFS_ALLOC_BTREE_REF
suffix:colon
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_MAP
comma
id|refval
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_INO_BTREE_REF
suffix:colon
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_INOMAP
comma
id|refval
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read-ahead the block, don&squot;t wait for it, don&squot;t return a buffer.&n; * Long-form addressing.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_btree_reada_bufl
id|xfs_btree_reada_bufl
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_fsblock_t
id|fsbno
comma
multiline_comment|/* file system block number */
id|xfs_extlen_t
id|count
)paren
multiline_comment|/* count of filesystem blocks */
(brace
id|xfs_daddr_t
id|d
suffix:semicolon
id|ASSERT
c_func
(paren
id|fsbno
op_ne
id|NULLFSBLOCK
)paren
suffix:semicolon
id|d
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|fsbno
)paren
suffix:semicolon
id|xfs_baread
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
op_star
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read-ahead the block, don&squot;t wait for it, don&squot;t return a buffer.&n; * Short-form addressing.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_btree_reada_bufs
id|xfs_btree_reada_bufs
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_agblock_t
id|agbno
comma
multiline_comment|/* allocation group block number */
id|xfs_extlen_t
id|count
)paren
multiline_comment|/* count of filesystem blocks */
(brace
id|xfs_daddr_t
id|d
suffix:semicolon
id|ASSERT
c_func
(paren
id|agno
op_ne
id|NULLAGNUMBER
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agbno
op_ne
id|NULLAGBLOCK
)paren
suffix:semicolon
id|d
op_assign
id|XFS_AGB_TO_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
)paren
suffix:semicolon
id|xfs_baread
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|d
comma
id|mp-&gt;m_bsize
op_star
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read-ahead btree blocks, at the given level.&n; * Bits in lr are set from XFS_BTCUR_{LEFT,RIGHT}RA.&n; */
r_int
DECL|function|xfs_btree_readahead_core
id|xfs_btree_readahead_core
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|lev
comma
multiline_comment|/* level in btree */
r_int
id|lr
)paren
multiline_comment|/* left/right bits */
(brace
id|xfs_alloc_block_t
op_star
id|a
suffix:semicolon
id|xfs_bmbt_block_t
op_star
id|b
suffix:semicolon
id|xfs_inobt_block_t
op_star
id|i
suffix:semicolon
r_int
id|rval
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
op_ne
l_int|NULL
)paren
suffix:semicolon
id|cur-&gt;bc_ra
(braket
id|lev
)braket
op_or_assign
id|lr
suffix:semicolon
r_switch
c_cond
(paren
id|cur-&gt;bc_btnum
)paren
(brace
r_case
id|XFS_BTNUM_BNO
suffix:colon
r_case
id|XFS_BTNUM_CNT
suffix:colon
id|a
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lr
op_amp
id|XFS_BTCUR_LEFTRA
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|a-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
id|xfs_btree_reada_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_private.a.agno
comma
id|INT_GET
c_func
(paren
id|a-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|1
)paren
suffix:semicolon
id|rval
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lr
op_amp
id|XFS_BTCUR_RIGHTRA
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|a-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
id|xfs_btree_reada_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_private.a.agno
comma
id|INT_GET
c_func
(paren
id|a-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|1
)paren
suffix:semicolon
id|rval
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_BTNUM_BMAP
suffix:colon
id|b
op_assign
id|XFS_BUF_TO_BMBT_BLOCK
c_func
(paren
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lr
op_amp
id|XFS_BTCUR_LEFTRA
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|b-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDFSBNO
)paren
(brace
id|xfs_btree_reada_bufl
c_func
(paren
id|cur-&gt;bc_mp
comma
id|INT_GET
c_func
(paren
id|b-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|1
)paren
suffix:semicolon
id|rval
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lr
op_amp
id|XFS_BTCUR_RIGHTRA
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|b-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLDFSBNO
)paren
(brace
id|xfs_btree_reada_bufl
c_func
(paren
id|cur-&gt;bc_mp
comma
id|INT_GET
c_func
(paren
id|b-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|1
)paren
suffix:semicolon
id|rval
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_BTNUM_INO
suffix:colon
id|i
op_assign
id|XFS_BUF_TO_INOBT_BLOCK
c_func
(paren
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lr
op_amp
id|XFS_BTCUR_LEFTRA
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|i-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
id|xfs_btree_reada_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_private.i.agno
comma
id|INT_GET
c_func
(paren
id|i-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|1
)paren
suffix:semicolon
id|rval
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lr
op_amp
id|XFS_BTCUR_RIGHTRA
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|i-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
id|xfs_btree_reada_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_private.i.agno
comma
id|INT_GET
c_func
(paren
id|i-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|1
)paren
suffix:semicolon
id|rval
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the buffer for level &quot;lev&quot; in the cursor to bp, releasing&n; * any previous buffer.&n; */
r_void
DECL|function|xfs_btree_setbuf
id|xfs_btree_setbuf
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|lev
comma
multiline_comment|/* level in btree */
id|xfs_buf_t
op_star
id|bp
)paren
multiline_comment|/* new buffer to set */
(brace
id|xfs_btree_block_t
op_star
id|b
suffix:semicolon
multiline_comment|/* btree block */
id|xfs_buf_t
op_star
id|obp
suffix:semicolon
multiline_comment|/* old buffer pointer */
id|obp
op_assign
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
suffix:semicolon
r_if
c_cond
(paren
id|obp
)paren
id|xfs_trans_brelse
c_func
(paren
id|cur-&gt;bc_tp
comma
id|obp
)paren
suffix:semicolon
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
op_assign
id|bp
suffix:semicolon
id|cur-&gt;bc_ra
(braket
id|lev
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
suffix:semicolon
id|b
op_assign
id|XFS_BUF_TO_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BTREE_LONG_PTRS
c_func
(paren
id|cur-&gt;bc_btnum
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|b-&gt;bb_u.l.bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDFSBNO
)paren
id|cur-&gt;bc_ra
(braket
id|lev
)braket
op_or_assign
id|XFS_BTCUR_LEFTRA
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|b-&gt;bb_u.l.bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLDFSBNO
)paren
id|cur-&gt;bc_ra
(braket
id|lev
)braket
op_or_assign
id|XFS_BTCUR_RIGHTRA
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|b-&gt;bb_u.s.bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
)paren
id|cur-&gt;bc_ra
(braket
id|lev
)braket
op_or_assign
id|XFS_BTCUR_LEFTRA
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|b-&gt;bb_u.s.bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
)paren
id|cur-&gt;bc_ra
(braket
id|lev
)braket
op_or_assign
id|XFS_BTCUR_RIGHTRA
suffix:semicolon
)brace
)brace
eof
