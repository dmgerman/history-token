multiline_comment|/*&n; * Copyright (c) 2000-2001 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_dir_leaf.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
multiline_comment|/*&n; * xfs_dir.c&n; *&n; * Provide the external interfaces to manage directories.&n; */
multiline_comment|/*========================================================================&n; * Function prototypes for the kernel.&n; *========================================================================*/
multiline_comment|/*&n; * Functions for the dirops interfaces.&n; */
r_static
r_void
id|xfs_dir_mount
c_func
(paren
r_struct
id|xfs_mount
op_star
id|mp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_isempty
c_func
(paren
r_struct
id|xfs_inode
op_star
id|dp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_init
c_func
(paren
r_struct
id|xfs_trans
op_star
id|trans
comma
r_struct
id|xfs_inode
op_star
id|dir
comma
r_struct
id|xfs_inode
op_star
id|parent_dir
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_createname
c_func
(paren
r_struct
id|xfs_trans
op_star
id|trans
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_char
op_star
id|name_string
comma
r_int
id|name_len
comma
id|xfs_ino_t
id|inode_number
comma
id|xfs_fsblock_t
op_star
id|firstblock
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_lookup
c_func
(paren
r_struct
id|xfs_trans
op_star
id|tp
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_char
op_star
id|name_string
comma
r_int
id|name_length
comma
id|xfs_ino_t
op_star
id|inode_number
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_removename
c_func
(paren
r_struct
id|xfs_trans
op_star
id|trans
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_char
op_star
id|name_string
comma
r_int
id|name_length
comma
id|xfs_ino_t
id|ino
comma
id|xfs_fsblock_t
op_star
id|firstblock
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_getdents
c_func
(paren
r_struct
id|xfs_trans
op_star
id|tp
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_struct
id|uio
op_star
id|uiop
comma
r_int
op_star
id|eofp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_replace
c_func
(paren
r_struct
id|xfs_trans
op_star
id|tp
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_char
op_star
id|name_string
comma
r_int
id|name_length
comma
id|xfs_ino_t
id|inode_number
comma
id|xfs_fsblock_t
op_star
id|firstblock
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_canenter
c_func
(paren
r_struct
id|xfs_trans
op_star
id|tp
comma
r_struct
id|xfs_inode
op_star
id|dp
comma
r_char
op_star
id|name_string
comma
r_int
id|name_length
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir_shortform_validate_ondisk
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dinode_t
op_star
id|dip
)paren
suffix:semicolon
DECL|variable|xfsv1_dirops
id|xfs_dirops_t
id|xfsv1_dirops
op_assign
(brace
dot
id|xd_mount
op_assign
id|xfs_dir_mount
comma
dot
id|xd_isempty
op_assign
id|xfs_dir_isempty
comma
dot
id|xd_init
op_assign
id|xfs_dir_init
comma
dot
id|xd_createname
op_assign
id|xfs_dir_createname
comma
dot
id|xd_lookup
op_assign
id|xfs_dir_lookup
comma
dot
id|xd_removename
op_assign
id|xfs_dir_removename
comma
dot
id|xd_getdents
op_assign
id|xfs_dir_getdents
comma
dot
id|xd_replace
op_assign
id|xfs_dir_replace
comma
dot
id|xd_canenter
op_assign
id|xfs_dir_canenter
comma
dot
id|xd_shortform_validate_ondisk
op_assign
id|xfs_dir_shortform_validate_ondisk
comma
dot
id|xd_shortform_to_single
op_assign
id|xfs_dir_shortform_to_leaf
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Internal routines when dirsize == XFS_LBSIZE(mp).&n; */
id|STATIC
r_int
id|xfs_dir_leaf_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_leaf_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
r_int
op_star
id|number_entries
comma
r_int
op_star
id|total_namebytes
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_leaf_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eofp
comma
id|xfs_dirent_t
op_star
id|dbp
comma
id|xfs_dir_put_t
id|put
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_leaf_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal routines when dirsize &gt; XFS_LBSIZE(mp).&n; */
id|STATIC
r_int
id|xfs_dir_node_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_node_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_node_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_node_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eofp
comma
id|xfs_dirent_t
op_star
id|dbp
comma
id|xfs_dir_put_t
id|put
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_node_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
macro_line|#if defined(DEBUG)
DECL|variable|xfs_dir_trace_buf
id|ktrace_t
op_star
id|xfs_dir_trace_buf
suffix:semicolon
macro_line|#endif
multiline_comment|/*========================================================================&n; * Overall external interface routines.&n; *========================================================================*/
DECL|variable|xfs_dir_hash_dot
DECL|variable|xfs_dir_hash_dotdot
id|xfs_dahash_t
id|xfs_dir_hash_dot
comma
id|xfs_dir_hash_dotdot
suffix:semicolon
multiline_comment|/*&n; * One-time startup routine called from xfs_init().&n; */
r_void
DECL|function|xfs_dir_startup
id|xfs_dir_startup
c_func
(paren
r_void
)paren
(brace
id|xfs_dir_hash_dot
op_assign
id|xfs_da_hashname
c_func
(paren
l_string|&quot;.&quot;
comma
l_int|1
)paren
suffix:semicolon
id|xfs_dir_hash_dotdot
op_assign
id|xfs_da_hashname
c_func
(paren
l_string|&quot;..&quot;
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize directory-related fields in the mount structure.&n; */
r_static
r_void
DECL|function|xfs_dir_mount
id|xfs_dir_mount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|uint
id|shortcount
comma
id|leafcount
comma
id|count
suffix:semicolon
id|mp-&gt;m_dirversion
op_assign
l_int|1
suffix:semicolon
id|shortcount
op_assign
(paren
id|mp-&gt;m_attroffset
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_sf_hdr_t
)paren
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_sf_entry_t
)paren
suffix:semicolon
id|leafcount
op_assign
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
)paren
op_div
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_name_t
)paren
)paren
suffix:semicolon
id|count
op_assign
id|shortcount
OG
id|leafcount
ques
c_cond
id|shortcount
suffix:colon
id|leafcount
suffix:semicolon
id|mp-&gt;m_dircook_elog
op_assign
id|xfs_da_log2_roundup
c_func
(paren
id|count
op_plus
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_dircook_elog
op_le
id|mp-&gt;m_sb.sb_blocklog
)paren
suffix:semicolon
id|mp-&gt;m_dir_node_ents
op_assign
id|mp-&gt;m_attr_node_ents
op_assign
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_hdr_t
)paren
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|mp-&gt;m_dir_magicpct
op_assign
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_star
l_int|37
)paren
op_div
l_int|100
suffix:semicolon
id|mp-&gt;m_dirblksize
op_assign
id|mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|mp-&gt;m_dirblkfsbs
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 1 if directory contains only &quot;.&quot; and &quot;..&quot;.&n; */
r_static
r_int
DECL|function|xfs_dir_isempty
id|xfs_dir_isempty
c_func
(paren
id|xfs_inode_t
op_star
id|dp
)paren
(brace
id|xfs_dir_sf_hdr_t
op_star
id|hdr
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|hdr
op_assign
(paren
id|xfs_dir_sf_hdr_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
r_return
id|hdr-&gt;count
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a directory with its &quot;.&quot; and &quot;..&quot; entries.&n; */
r_static
r_int
DECL|function|xfs_dir_init
id|xfs_dir_init
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dir
comma
id|xfs_inode_t
op_star
id|parent_dir
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
r_int
id|error
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.dp
op_assign
id|dir
suffix:semicolon
id|args.trans
op_assign
id|trans
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dir-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir_ino_validate
c_func
(paren
id|trans-&gt;t_mountp
comma
id|parent_dir-&gt;i_ino
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_return
id|xfs_dir_shortform_create
c_func
(paren
op_amp
id|args
comma
id|parent_dir-&gt;i_ino
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic handler routine to add a name to a directory.&n; * Transitions directory from shortform to Btree as necessary.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir_createname
id|xfs_dir_createname
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
id|inum
comma
id|xfs_fsblock_t
op_star
id|firstblock
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
r_int
id|retval
comma
id|newsize
comma
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|xfs_dir_ino_validate
c_func
(paren
id|trans-&gt;t_mountp
comma
id|inum
)paren
)paren
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_dir_create
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
id|inum
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|firstblock
suffix:semicolon
id|args.flist
op_assign
id|flist
suffix:semicolon
id|args.total
op_assign
id|total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|trans
suffix:semicolon
id|args.justcheck
op_assign
l_int|0
suffix:semicolon
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|newsize
op_assign
id|XFS_DIR_SF_ENTSIZE_BYNAME
c_func
(paren
id|args.namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dp-&gt;i_d.di_size
op_plus
id|newsize
)paren
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_shortform_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|total
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_shortform_to_leaf
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|done
op_assign
id|retval
op_ne
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
op_logical_and
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_DATA_FORK
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|done
op_assign
id|retval
op_ne
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
r_if
c_cond
(paren
id|total
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_to_node
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
id|done
op_assign
id|retval
op_ne
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|retval
op_assign
id|xfs_dir_node_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic handler routine to check if a name can be added to a directory,&n; * without adding any blocks to the directory.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir_canenter
id|xfs_dir_canenter
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
r_int
id|retval
comma
id|newsize
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
l_int|0
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
l_int|NULL
suffix:semicolon
id|args.flist
op_assign
l_int|NULL
suffix:semicolon
id|args.total
op_assign
l_int|0
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|trans
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|newsize
op_assign
id|XFS_DIR_SF_ENTSIZE_BYNAME
c_func
(paren
id|args.namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dp-&gt;i_d.di_size
op_plus
id|newsize
)paren
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
r_else
id|retval
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_DATA_FORK
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|xfs_dir_node_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic handler routine to remove a name from a directory.&n; * Transitions directory from Btree to shortform as necessary.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir_removename
id|xfs_dir_removename
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
id|ino
comma
id|xfs_fsblock_t
op_star
id|firstblock
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
r_int
id|count
comma
id|totallen
comma
id|newsize
comma
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_dir_remove
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
id|ino
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|firstblock
suffix:semicolon
id|args.flist
op_assign
id|flist
suffix:semicolon
id|args.total
op_assign
id|total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|trans
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|retval
op_assign
id|xfs_dir_shortform_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_DATA_FORK
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_leaf_removename
c_func
(paren
op_amp
id|args
comma
op_amp
id|count
comma
op_amp
id|totallen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
id|newsize
op_assign
id|XFS_DIR_SF_ALLFIT
c_func
(paren
id|count
comma
id|totallen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newsize
op_le
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_leaf_to_shortform
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|retval
op_assign
id|xfs_dir_node_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir_lookup
id|xfs_dir_lookup
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
op_star
id|inum
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_dir_lookup
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
l_int|0
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
l_int|NULL
suffix:semicolon
id|args.flist
op_assign
l_int|NULL
suffix:semicolon
id|args.total
op_assign
l_int|0
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|trans
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
l_int|0
suffix:semicolon
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|retval
op_assign
id|xfs_dir_shortform_lookup
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_DATA_FORK
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_leaf_lookup
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|xfs_dir_node_lookup
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
id|retval
op_assign
l_int|0
suffix:semicolon
op_star
id|inum
op_assign
id|args.inumber
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Implement readdir.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir_getdents
id|xfs_dir_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eofp
)paren
(brace
id|xfs_dirent_t
op_star
id|dbp
suffix:semicolon
r_int
id|alignment
comma
id|retval
suffix:semicolon
id|xfs_dir_put_t
id|put
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_dir_getdents
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If our caller has given us a single contiguous memory buffer,&n;&t; * just work directly within that buffer.  If it&squot;s in user memory,&n;&t; * lock it down first.&n;&t; */
id|alignment
op_assign
r_sizeof
(paren
id|xfs_off_t
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uio-&gt;uio_iovcnt
op_eq
l_int|1
)paren
op_logical_and
(paren
(paren
(paren
id|__psint_t
)paren
id|uio-&gt;uio_iov
(braket
l_int|0
)braket
dot
id|iov_base
op_amp
id|alignment
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|uio-&gt;uio_iov
(braket
l_int|0
)braket
dot
id|iov_len
op_amp
id|alignment
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|dbp
op_assign
l_int|NULL
suffix:semicolon
id|put
op_assign
id|xfs_dir_put_dirent64_direct
suffix:semicolon
)brace
r_else
(brace
id|dbp
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|dbp
)paren
op_plus
id|MAXNAMELEN
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|put
op_assign
id|xfs_dir_put_dirent64_uio
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|retval
op_assign
id|xfs_dir_shortform_getdents
c_func
(paren
id|dp
comma
id|uio
comma
id|eofp
comma
id|dbp
comma
id|put
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_DATA_FORK
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_leaf_getdents
c_func
(paren
id|trans
comma
id|dp
comma
id|uio
comma
id|eofp
comma
id|dbp
comma
id|put
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|xfs_dir_node_getdents
c_func
(paren
id|trans
comma
id|dp
comma
id|uio
comma
id|eofp
comma
id|dbp
comma
id|put
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dbp
op_ne
l_int|NULL
)paren
id|kmem_free
c_func
(paren
id|dbp
comma
r_sizeof
(paren
op_star
id|dbp
)paren
op_plus
id|MAXNAMELEN
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir_replace
id|xfs_dir_replace
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|xfs_ino_t
id|inum
comma
id|xfs_fsblock_t
op_star
id|firstblock
comma
id|xfs_bmap_free_t
op_star
id|flist
comma
id|xfs_extlen_t
id|total
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|dp-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|xfs_dir_ino_validate
c_func
(paren
id|trans-&gt;t_mountp
comma
id|inum
)paren
)paren
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|name
comma
id|namelen
)paren
suffix:semicolon
id|args.inumber
op_assign
id|inum
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|firstblock
suffix:semicolon
id|args.flist
op_assign
id|flist
suffix:semicolon
id|args.total
op_assign
id|total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|trans
suffix:semicolon
id|args.justcheck
op_assign
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|retval
op_assign
id|xfs_dir_shortform_replace
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_DATA_FORK
)paren
)paren
(brace
id|retval
op_assign
id|xfs_dir_leaf_replace
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|xfs_dir_node_replace
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
DECL|function|xfs_dir_shortform_validate_ondisk
id|xfs_dir_shortform_validate_ondisk
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dinode_t
op_star
id|dp
)paren
(brace
id|xfs_ino_t
id|ino
suffix:semicolon
r_int
id|namelen_sum
suffix:semicolon
r_int
id|count
suffix:semicolon
id|xfs_dir_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_dir_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|dp-&gt;di_core.di_mode
comma
id|ARCH_CONVERT
)paren
op_amp
id|IFMT
)paren
op_ne
id|IFDIR
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dp-&gt;di_core.di_format
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dp-&gt;di_core.di_size
comma
id|ARCH_CONVERT
)paren
OL
r_sizeof
(paren
id|sf-&gt;hdr
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;Invalid shortform size: dp 0x%p&quot;
comma
id|dp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
(paren
op_amp
id|dp-&gt;di_u.di_dirsf
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_GET_DIR_INO_ARCH
c_func
(paren
id|mp
comma
id|sf-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_dir_ino_validate
c_func
(paren
id|mp
comma
id|ino
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|count
op_assign
id|sf-&gt;hdr.count
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
OL
l_int|0
)paren
op_logical_or
(paren
(paren
id|count
op_star
l_int|10
)paren
OG
id|XFS_LITINO
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;Invalid shortform count: dp 0x%p&quot;
comma
id|dp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|namelen_sum
op_assign
l_int|0
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|sf-&gt;hdr.count
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|ino
op_assign
id|XFS_GET_DIR_INO_ARCH
c_func
(paren
id|mp
comma
id|sfe-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir_ino_validate
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_ge
id|XFS_LITINO
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;Invalid shortform namelen: dp 0x%p&quot;
comma
id|dp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|namelen_sum
op_add_assign
id|sfe-&gt;namelen
suffix:semicolon
id|sfe
op_assign
id|XFS_DIR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen_sum
op_ge
id|XFS_LITINO
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;Invalid shortform namelen: dp 0x%p&quot;
comma
id|dp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * External routines when dirsize == XFS_LBSIZE(dp-&gt;i_mount).&n; *========================================================================*/
multiline_comment|/*&n; * Add a name to the leaf directory structure&n; * This is the external routine.&n; */
r_int
DECL|function|xfs_dir_leaf_addname
id|xfs_dir_leaf_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
r_int
id|index
comma
id|retval
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_lookup_int
c_func
(paren
id|bp
comma
id|args
comma
op_amp
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|ENOENT
)paren
id|retval
op_assign
id|xfs_dir_leaf_add
c_func
(paren
id|bp
comma
id|args
comma
id|index
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from the leaf directory structure&n; * This is the external routine.&n; */
id|STATIC
r_int
DECL|function|xfs_dir_leaf_removename
id|xfs_dir_leaf_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
r_int
op_star
id|count
comma
r_int
op_star
id|totallen
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
r_int
id|index
comma
id|retval
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_lookup_int
c_func
(paren
id|bp
comma
id|args
comma
op_amp
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
(brace
(paren
r_void
)paren
id|xfs_dir_leaf_remove
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|index
)paren
suffix:semicolon
op_star
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
op_star
id|totallen
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a name in a leaf directory structure.&n; * This is the external routine.&n; */
id|STATIC
r_int
DECL|function|xfs_dir_leaf_lookup
id|xfs_dir_leaf_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
r_int
id|index
comma
id|retval
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_lookup_int
c_func
(paren
id|bp
comma
id|args
comma
op_amp
id|index
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy out directory entries for getdents(), for leaf directories.&n; */
id|STATIC
r_int
DECL|function|xfs_dir_leaf_getdents
id|xfs_dir_leaf_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eofp
comma
id|xfs_dirent_t
op_star
id|dbp
comma
id|xfs_dir_put_t
id|put
)paren
(brace
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|retval
comma
id|eob
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|dp-&gt;i_transp
comma
id|dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_getdents_int
c_func
(paren
id|bp
comma
id|dp
comma
l_int|0
comma
id|uio
comma
op_amp
id|eob
comma
id|dbp
comma
id|put
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
op_star
id|eofp
op_assign
(paren
id|eob
op_eq
l_int|0
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a name in a leaf directory structure, replace the inode number.&n; * This is the external routine.&n; */
id|STATIC
r_int
DECL|function|xfs_dir_leaf_replace
id|xfs_dir_leaf_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
r_int
id|index
comma
id|retval
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|xfs_ino_t
id|inum
suffix:semicolon
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_dir_leaf_name_t
op_star
id|namest
suffix:semicolon
id|inum
op_assign
id|args-&gt;inumber
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_lookup_int
c_func
(paren
id|bp
comma
id|args
comma
op_amp
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
(brace
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|index
)braket
suffix:semicolon
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX - replace assert? */
id|XFS_DIR_SF_PUT_DIRINO_ARCH
c_func
(paren
op_amp
id|inum
comma
op_amp
id|namest-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|namest
comma
r_sizeof
(paren
id|namest-&gt;inumber
)paren
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * External routines when dirsize &gt; XFS_LBSIZE(mp).&n; *========================================================================*/
multiline_comment|/*&n; * Add a name to a Btree-format directory.&n; *&n; * This will involve walking down the Btree, and may involve splitting&n; * leaf nodes and even splitting intermediate nodes up to and including&n; * the root node (a special case of an intermediate node).&n; */
id|STATIC
r_int
DECL|function|xfs_dir_node_addname
id|xfs_dir_node_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
r_int
id|retval
comma
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in bucket of arguments/results/context to carry around.&n;&t; */
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Search to see if name already exists, and get back a pointer&n;&t; * to where it should go.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|retval
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|ENOENT
)paren
r_goto
id|error
suffix:semicolon
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_add
c_func
(paren
id|blk-&gt;bp
comma
id|args
comma
id|blk-&gt;index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Addition succeeded, update Btree hashvals.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|args-&gt;justcheck
)paren
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Addition failed, split as many Btree elements as required.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;total
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|retval
op_eq
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|retval
op_assign
id|xfs_da_split
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|error
suffix:colon
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from a B-tree directory.&n; *&n; * This will involve walking down the Btree, and may involve joining&n; * leaf nodes and even joining intermediate nodes up to and including&n; * the root node (a special case of an intermediate node).&n; */
id|STATIC
r_int
DECL|function|xfs_dir_node_removename
id|xfs_dir_node_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
r_int
id|retval
comma
id|error
suffix:semicolon
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Search to see if name exists, and get back a pointer to it.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|retval
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
id|EEXIST
)paren
(brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove the name and update the hashvals in the tree.&n;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_remove
c_func
(paren
id|args-&gt;trans
comma
id|blk-&gt;bp
comma
id|blk-&gt;index
)paren
suffix:semicolon
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if the tree needs to be collapsed.&n;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|error
op_assign
id|xfs_da_join
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a filename in a int directory.&n; * Use an internal routine to actually do all the work.&n; */
id|STATIC
r_int
DECL|function|xfs_dir_node_lookup
id|xfs_dir_node_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
r_int
id|retval
comma
id|error
comma
id|i
suffix:semicolon
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Search to see if name exists,&n;&t; * and get back a pointer to it.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|retval
op_assign
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If not in a transaction, we have to release all the buffers.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;path.active
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_dir_node_getdents
id|xfs_dir_node_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eofp
comma
id|xfs_dirent_t
op_star
id|dbp
comma
id|xfs_dir_put_t
id|put
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree
suffix:semicolon
id|xfs_dir_leafblock_t
op_star
id|leaf
op_assign
l_int|NULL
suffix:semicolon
id|xfs_dablk_t
id|bno
comma
id|nextbno
suffix:semicolon
id|xfs_dahash_t
id|cookhash
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
comma
id|eob
comma
id|i
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|xfs_daddr_t
id|nextda
suffix:semicolon
multiline_comment|/*&n;&t; * Pick up our context.&n;&t; */
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|bno
op_assign
id|XFS_DA_COOKIE_BNO
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
id|cookhash
op_assign
id|XFS_DA_COOKIE_HASH
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;node: start&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Re-find our place, even if we&squot;re confused about what our place is.&n;&t; *&n;&t; * First we check the block number from the magic cookie, it is a&n;&t; * cache of where we ended last time.  If we find a leaf block, and&n;&t; * the starting hashval in that block is less than our desired&n;&t; * hashval, then we run with it.&n;&t; */
r_if
c_cond
(paren
id|bno
OG
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|trans
comma
id|dp
comma
id|bno
comma
op_minus
l_int|2
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_ne
l_int|0
)paren
op_logical_and
(paren
id|error
op_ne
id|EFSCORRUPTED
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR_LEAF_MAGIC
)paren
(brace
id|xfs_dir_trace_g_dub
c_func
(paren
l_string|&quot;node: block not a leaf&quot;
comma
id|dp
comma
id|uio
comma
id|bno
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
op_logical_and
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OG
id|cookhash
)paren
(brace
id|xfs_dir_trace_g_dub
c_func
(paren
l_string|&quot;node: leaf hash too large&quot;
comma
id|dp
comma
id|uio
comma
id|bno
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp
op_logical_and
id|cookhash
OG
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_dir_trace_g_dub
c_func
(paren
l_string|&quot;node: leaf hash too small&quot;
comma
id|dp
comma
id|uio
comma
id|bno
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we did not find a leaf block from the blockno in the cookie,&n;&t; * or we there was no blockno in the cookie (eg: first time thru),&n;&t; * the we start at the top of the Btree and re-find our hashval.&n;&t; */
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
(brace
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;node: start at root&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
id|bno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|trans
comma
id|dp
comma
id|bno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DA_NODE_MAGIC
)paren
r_break
suffix:semicolon
id|btree
op_assign
op_amp
id|node-&gt;btree
(braket
l_int|0
)braket
suffix:semicolon
id|xfs_dir_trace_g_dun
c_func
(paren
l_string|&quot;node: node detail&quot;
comma
id|dp
comma
id|uio
comma
id|node
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|btree
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|cookhash
)paren
(brace
id|bno
op_assign
id|INT_GET
c_func
(paren
id|btree-&gt;before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;node: hash beyond EOF&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
id|uio-&gt;uio_offset
op_assign
id|XFS_DA_MAKE_COOKIE
c_func
(paren
id|mp
comma
l_int|0
comma
l_int|0
comma
id|XFS_DA_MAXHASH
)paren
suffix:semicolon
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_dir_trace_g_dub
c_func
(paren
l_string|&quot;node: going to block&quot;
comma
id|dp
comma
id|uio
comma
id|bno
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
id|cookhash
op_ne
id|XFS_DA_MAXHASH
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;ve dropped down to the (first) leaf block that contains the&n;&t; * hashval we are interested in.  Continue rolling upward thru the&n;&t; * leaf blocks until we fill up our buffer.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR_LEAF_MAGIC
)paren
)paren
(brace
id|xfs_dir_trace_g_dul
c_func
(paren
l_string|&quot;node: not a leaf&quot;
comma
id|dp
comma
id|uio
comma
id|leaf
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_dir_node_getdents(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|leaf
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|xfs_dir_trace_g_dul
c_func
(paren
l_string|&quot;node: leaf detail&quot;
comma
id|dp
comma
id|uio
comma
id|leaf
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nextbno
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|nextda
op_assign
id|xfs_da_reada_buf
c_func
(paren
id|trans
comma
id|dp
comma
id|nextbno
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
)brace
r_else
id|nextda
op_assign
op_minus
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_dir_leaf_getdents_int
c_func
(paren
id|bp
comma
id|dp
comma
id|bno
comma
id|uio
comma
op_amp
id|eob
comma
id|dbp
comma
id|put
comma
id|nextda
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
id|bno
op_assign
id|nextbno
suffix:semicolon
r_if
c_cond
(paren
id|eob
)paren
(brace
id|xfs_dir_trace_g_dub
c_func
(paren
l_string|&quot;node: E-O-B&quot;
comma
id|dp
comma
id|uio
comma
id|bno
)paren
suffix:semicolon
op_star
id|eofp
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bno
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|trans
comma
id|dp
comma
id|bno
comma
id|nextda
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bp
op_eq
l_int|NULL
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_dir_node_getdents(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;node: E-O-F&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a filename in an int directory, replace the inode number.&n; * Use an internal routine to actually do the lookup.&n; */
id|STATIC
r_int
DECL|function|xfs_dir_node_replace
id|xfs_dir_node_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_dir_leaf_name_t
op_star
id|namest
suffix:semicolon
id|xfs_ino_t
id|inum
suffix:semicolon
r_int
id|retval
comma
id|error
comma
id|i
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_dir_node_ents
suffix:semicolon
id|inum
op_assign
id|args-&gt;inumber
suffix:semicolon
multiline_comment|/*&n;&t; * Search to see if name exists,&n;&t; * and get back a pointer to it.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|retval
op_assign
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
(brace
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|bp
op_assign
id|blk-&gt;bp
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|blk-&gt;index
)braket
suffix:semicolon
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX - replace assert ? */
id|XFS_DIR_SF_PUT_DIRINO_ARCH
c_func
(paren
op_amp
id|inum
comma
op_amp
id|namest-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|namest
comma
r_sizeof
(paren
id|namest-&gt;inumber
)paren
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
id|blk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|state-&gt;path.active
op_minus
l_int|1
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;path.active
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#if defined(XFS_DIR_TRACE)
multiline_comment|/*&n; * Add a trace buffer entry for an inode and a uio.&n; */
r_void
DECL|function|xfs_dir_trace_g_du
id|xfs_dir_trace_g_du
c_func
(paren
r_char
op_star
id|where
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
)paren
(brace
id|xfs_dir_trace_enter
c_func
(paren
id|XFS_DIR_KTRACE_G_DU
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|dp
comma
(paren
id|__psunsigned_t
)paren
id|dp-&gt;i_mount
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_rshift
l_int|32
)paren
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
id|__psunsigned_t
)paren
id|uio-&gt;uio_resid
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for an inode and a uio.&n; */
r_void
DECL|function|xfs_dir_trace_g_dub
id|xfs_dir_trace_g_dub
c_func
(paren
r_char
op_star
id|where
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
id|xfs_dablk_t
id|bno
)paren
(brace
id|xfs_dir_trace_enter
c_func
(paren
id|XFS_DIR_KTRACE_G_DUB
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|dp
comma
(paren
id|__psunsigned_t
)paren
id|dp-&gt;i_mount
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_rshift
l_int|32
)paren
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
id|__psunsigned_t
)paren
id|uio-&gt;uio_resid
comma
(paren
id|__psunsigned_t
)paren
id|bno
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for an inode and a uio.&n; */
r_void
DECL|function|xfs_dir_trace_g_dun
id|xfs_dir_trace_g_dun
c_func
(paren
r_char
op_star
id|where
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
id|xfs_da_intnode_t
op_star
id|node
)paren
(brace
id|xfs_dir_trace_enter
c_func
(paren
id|XFS_DIR_KTRACE_G_DUN
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|dp
comma
(paren
id|__psunsigned_t
)paren
id|dp-&gt;i_mount
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_rshift
l_int|32
)paren
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
id|__psunsigned_t
)paren
id|uio-&gt;uio_resid
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for an inode and a uio.&n; */
r_void
DECL|function|xfs_dir_trace_g_dul
id|xfs_dir_trace_g_dul
c_func
(paren
r_char
op_star
id|where
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
id|xfs_dir_leafblock_t
op_star
id|leaf
)paren
(brace
id|xfs_dir_trace_enter
c_func
(paren
id|XFS_DIR_KTRACE_G_DUL
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|dp
comma
(paren
id|__psunsigned_t
)paren
id|dp-&gt;i_mount
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_rshift
l_int|32
)paren
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
id|__psunsigned_t
)paren
id|uio-&gt;uio_resid
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for an inode and a uio.&n; */
r_void
DECL|function|xfs_dir_trace_g_due
id|xfs_dir_trace_g_due
c_func
(paren
r_char
op_star
id|where
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
id|xfs_dir_leaf_entry_t
op_star
id|entry
)paren
(brace
id|xfs_dir_trace_enter
c_func
(paren
id|XFS_DIR_KTRACE_G_DUE
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|dp
comma
(paren
id|__psunsigned_t
)paren
id|dp-&gt;i_mount
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_rshift
l_int|32
)paren
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
id|__psunsigned_t
)paren
id|uio-&gt;uio_resid
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for an inode and a uio.&n; */
r_void
DECL|function|xfs_dir_trace_g_duc
id|xfs_dir_trace_g_duc
c_func
(paren
r_char
op_star
id|where
comma
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
id|xfs_off_t
id|cookie
)paren
(brace
id|xfs_dir_trace_enter
c_func
(paren
id|XFS_DIR_KTRACE_G_DUC
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|dp
comma
(paren
id|__psunsigned_t
)paren
id|dp-&gt;i_mount
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_rshift
l_int|32
)paren
comma
(paren
id|__psunsigned_t
)paren
(paren
id|uio-&gt;uio_offset
op_amp
l_int|0xFFFFFFFF
)paren
comma
(paren
id|__psunsigned_t
)paren
id|uio-&gt;uio_resid
comma
(paren
id|__psunsigned_t
)paren
(paren
id|cookie
op_rshift
l_int|32
)paren
comma
(paren
id|__psunsigned_t
)paren
(paren
id|cookie
op_amp
l_int|0xFFFFFFFF
)paren
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for the arguments given to the routine,&n; * generic form.&n; */
r_void
DECL|function|xfs_dir_trace_enter
id|xfs_dir_trace_enter
c_func
(paren
r_int
id|type
comma
r_char
op_star
id|where
comma
id|__psunsigned_t
id|a0
comma
id|__psunsigned_t
id|a1
comma
id|__psunsigned_t
id|a2
comma
id|__psunsigned_t
id|a3
comma
id|__psunsigned_t
id|a4
comma
id|__psunsigned_t
id|a5
comma
id|__psunsigned_t
id|a6
comma
id|__psunsigned_t
id|a7
comma
id|__psunsigned_t
id|a8
comma
id|__psunsigned_t
id|a9
comma
id|__psunsigned_t
id|a10
comma
id|__psunsigned_t
id|a11
)paren
(brace
id|ASSERT
c_func
(paren
id|xfs_dir_trace_buf
)paren
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|xfs_dir_trace_buf
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|__psunsigned_t
)paren
id|type
)paren
comma
(paren
r_void
op_star
)paren
id|where
comma
(paren
r_void
op_star
)paren
id|a0
comma
(paren
r_void
op_star
)paren
id|a1
comma
(paren
r_void
op_star
)paren
id|a2
comma
(paren
r_void
op_star
)paren
id|a3
comma
(paren
r_void
op_star
)paren
id|a4
comma
(paren
r_void
op_star
)paren
id|a5
comma
(paren
r_void
op_star
)paren
id|a6
comma
(paren
r_void
op_star
)paren
id|a7
comma
(paren
r_void
op_star
)paren
id|a8
comma
(paren
r_void
op_star
)paren
id|a9
comma
(paren
r_void
op_star
)paren
id|a10
comma
(paren
r_void
op_star
)paren
id|a11
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* XFS_DIR_TRACE */
eof
