multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * This file contains the implementation of the xfs_inode_log_item.&n; * It contains the item operations used to manipulate the inode log&n; * items as well as utility routines used by the inode specific&n; * transaction routines.&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_trans_priv.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
DECL|variable|xfs_ili_zone
id|kmem_zone_t
op_star
id|xfs_ili_zone
suffix:semicolon
multiline_comment|/* inode log item zone */
multiline_comment|/*&n; * This returns the number of iovecs needed to log the given inode item.&n; *&n; * We need one iovec for the inode log format structure, one for the&n; * inode core, and possibly one for the inode data/extents/b-tree root&n; * and one for the inode attribute data/extents/b-tree root.&n; */
id|STATIC
id|uint
DECL|function|xfs_inode_item_size
id|xfs_inode_item_size
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
id|uint
id|nvecs
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|ip
op_assign
id|iip-&gt;ili_inode
suffix:semicolon
id|nvecs
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * Only log the data/extents/b-tree root if there is something&n;&t; * left to log.&n;&t; */
id|iip-&gt;ili_format.ilf_fields
op_or_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_format
)paren
(brace
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEV
op_or
id|XFS_ILOG_UUID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DEXT
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_nextents
OG
l_int|0
)paren
op_logical_and
(paren
id|ip-&gt;i_df.if_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_u1.if_extents
op_ne
l_int|NULL
)paren
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
id|XFS_ILOG_DEXT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_ext_max
op_eq
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_DEV
op_or
id|XFS_ILOG_UUID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DBROOT
)paren
op_logical_and
(paren
id|ip-&gt;i_df.if_broot_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_broot
op_ne
l_int|NULL
)paren
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DBROOT
)paren
)paren
suffix:semicolon
macro_line|#ifdef XFS_TRANS_DEBUG
r_if
c_cond
(paren
id|iip-&gt;ili_root_size
OG
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|iip-&gt;ili_root_size
op_eq
id|ip-&gt;i_df.if_broot_bytes
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|memcmp
c_func
(paren
id|iip-&gt;ili_orig_root
comma
id|ip-&gt;i_df.if_broot
comma
id|iip-&gt;ili_root_size
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_broot_bytes
op_eq
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
id|XFS_ILOG_DBROOT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEV
op_or
id|XFS_ILOG_UUID
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DDATA
)paren
op_logical_and
(paren
id|ip-&gt;i_df.if_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_size
OG
l_int|0
)paren
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
id|XFS_ILOG_DDATA
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_DEV
suffix:colon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_UUID
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_UUID
suffix:colon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_DEV
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are no attributes associated with this file,&n;&t; * then there cannot be anything more to log.&n;&t; * Clear all attribute-related log flags.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
)paren
(brace
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_ADATA
op_or
id|XFS_ILOG_ABROOT
op_or
id|XFS_ILOG_AEXT
)paren
suffix:semicolon
r_return
id|nvecs
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Log any necessary attribute data.&n;&t; */
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_aformat
)paren
(brace
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_ADATA
op_or
id|XFS_ILOG_ABROOT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_AEXT
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_anextents
OG
l_int|0
)paren
op_logical_and
(paren
id|ip-&gt;i_afp-&gt;if_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_u1.if_extents
op_ne
l_int|NULL
)paren
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
id|XFS_ILOG_AEXT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_ADATA
op_or
id|XFS_ILOG_AEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ABROOT
)paren
op_logical_and
(paren
id|ip-&gt;i_afp-&gt;if_broot_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_broot
op_ne
l_int|NULL
)paren
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
id|XFS_ILOG_ABROOT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
(paren
id|XFS_ILOG_AEXT
op_or
id|XFS_ILOG_ABROOT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ADATA
)paren
op_logical_and
(paren
id|ip-&gt;i_afp-&gt;if_bytes
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|iip-&gt;ili_format.ilf_fields
op_and_assign
op_complement
id|XFS_ILOG_ADATA
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|nvecs
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to fill in the vector of log iovecs for the&n; * given inode log item.  It fills the first item with an inode&n; * log format structure, the second with the on-disk inode structure,&n; * and a possible third and/or fourth with the inode data/extents/b-tree&n; * root and inode attributes data/extents/b-tree root.&n; */
id|STATIC
r_void
DECL|function|xfs_inode_item_format
id|xfs_inode_item_format
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
comma
id|xfs_log_iovec_t
op_star
id|log_vector
)paren
(brace
id|uint
id|nvecs
suffix:semicolon
id|xfs_log_iovec_t
op_star
id|vecp
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|data_bytes
suffix:semicolon
id|xfs_bmbt_rec_t
op_star
id|ext_buffer
suffix:semicolon
r_int
id|nrecs
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|ip
op_assign
id|iip-&gt;ili_inode
suffix:semicolon
id|vecp
op_assign
id|log_vector
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
op_amp
id|iip-&gt;ili_format
suffix:semicolon
id|vecp-&gt;i_len
op_assign
r_sizeof
(paren
id|xfs_inode_log_format_t
)paren
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Clear i_update_core if the timestamps (or any other&n;&t; * non-transactional modification) need flushing/logging&n;&t; * and we&squot;re about to log them with the rest of the core.&n;&t; *&n;&t; * This is the same logic as xfs_iflush() but this code can&squot;t&n;&t; * run at the same time as xfs_iflush because we&squot;re in commit&n;&t; * processing here and so we have the inode lock held in&n;&t; * exclusive mode.  Although it doesn&squot;t really matter&n;&t; * for the timestamps if both routines were to grab the&n;&t; * timestamps or not.  That would be ok.&n;&t; *&n;&t; * We clear i_update_core before copying out the data.&n;&t; * This is for coordination with our timestamp updates&n;&t; * that don&squot;t hold the inode lock. They will always&n;&t; * update the timestamps BEFORE setting i_update_core,&n;&t; * so if we clear i_update_core after they set it we&n;&t; * are guaranteed to see their updates to the timestamps&n;&t; * either here.  Likewise, if they set it after we clear it&n;&t; * here, we&squot;ll see it either on the next commit of this&n;&t; * inode or the next time the inode gets flushed via&n;&t; * xfs_iflush().  This depends on strongly ordered memory&n;&t; * semantics, but we have that.  We use the SYNCHRONIZE&n;&t; * macro to make sure that the compiler does not reorder&n;&t; * the i_update_core access below the data copy below.&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_update_core
)paren
(brace
id|ip-&gt;i_update_core
op_assign
l_int|0
suffix:semicolon
id|SYNCHRONIZE
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t have to worry about re-ordering here because&n;&t; * the update_size field is protected by the inode lock&n;&t; * and we have that held in exclusive mode.&n;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_update_size
)paren
id|ip-&gt;i_update_size
op_assign
l_int|0
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
op_amp
id|ip-&gt;i_d
suffix:semicolon
id|vecp-&gt;i_len
op_assign
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
id|iip-&gt;ili_format.ilf_fields
op_or_assign
id|XFS_ILOG_CORE
suffix:semicolon
multiline_comment|/*&n;&t; * If this is really an old format inode, then we need to&n;&t; * log it as such.  This means that we have to copy the link&n;&t; * count from the new field to the old.  We don&squot;t have to worry&n;&t; * about the new fields, because nothing trusts them as long as&n;&t; * the old inode version number is there.  If the superblock already&n;&t; * has a new version number, then we don&squot;t bother converting back.&n;&t; */
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
op_logical_or
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_version
op_eq
id|XFS_DINODE_VERSION_1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Convert it back.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
op_le
id|XFS_MAXLINK_1
)paren
suffix:semicolon
id|ip-&gt;i_d.di_onlink
op_assign
id|ip-&gt;i_d.di_nlink
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * The superblock version has already been bumped,&n;&t;&t;&t; * so just make the conversion to the new inode&n;&t;&t;&t; * format permanent.&n;&t;&t;&t; */
id|ip-&gt;i_d.di_version
op_assign
id|XFS_DINODE_VERSION_2
suffix:semicolon
id|ip-&gt;i_d.di_onlink
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|ip-&gt;i_d.di_pad
(braket
l_int|0
)braket
)paren
comma
l_int|0
comma
r_sizeof
(paren
id|ip-&gt;i_d.di_pad
)paren
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_format
)paren
(brace
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEV
op_or
id|XFS_ILOG_UUID
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DEXT
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_bytes
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_u1.if_extents
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nextents
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_extents_buf
op_eq
l_int|NULL
)paren
suffix:semicolon
id|nrecs
op_assign
id|ip-&gt;i_df.if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nrecs
OG
l_int|0
)paren
suffix:semicolon
macro_line|#if ARCH_CONVERT == ARCH_NOCONVERT
r_if
c_cond
(paren
id|nrecs
op_eq
id|ip-&gt;i_d.di_nextents
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * There are no delayed allocation&n;&t;&t;&t;&t; * extents, so just point to the&n;&t;&t;&t;&t; * real extents array.&n;&t;&t;&t;&t; */
id|vecp-&gt;i_addr
op_assign
(paren
r_char
op_star
)paren
(paren
id|ip-&gt;i_df.if_u1.if_extents
)paren
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|ip-&gt;i_df.if_bytes
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * There are delayed allocation extents&n;&t;&t;&t;&t; * in the inode, or we need to convert&n;&t;&t;&t;&t; * the extents to on disk format.&n;&t;&t;&t;&t; * Use xfs_iextents_copy()&n;&t;&t;&t;&t; * to copy only the real extents into&n;&t;&t;&t;&t; * a separate buffer.  We&squot;ll free the&n;&t;&t;&t;&t; * buffer in the unlock routine.&n;&t;&t;&t;&t; */
id|ext_buffer
op_assign
id|kmem_alloc
c_func
(paren
id|ip-&gt;i_df.if_bytes
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|iip-&gt;ili_extents_buf
op_assign
id|ext_buffer
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
id|ext_buffer
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|xfs_iextents_copy
c_func
(paren
id|ip
comma
id|ext_buffer
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|vecp-&gt;i_len
op_le
id|ip-&gt;i_df.if_bytes
)paren
suffix:semicolon
id|iip-&gt;ili_format.ilf_dsize
op_assign
id|vecp-&gt;i_len
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_DEV
op_or
id|XFS_ILOG_UUID
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DBROOT
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_broot_bytes
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_broot
op_ne
l_int|NULL
)paren
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
id|ip-&gt;i_df.if_broot
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|ip-&gt;i_df.if_broot_bytes
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
id|iip-&gt;ili_format.ilf_dsize
op_assign
id|ip-&gt;i_df.if_broot_bytes
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_DEV
op_or
id|XFS_ILOG_UUID
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DDATA
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_bytes
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_size
OG
l_int|0
)paren
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
id|ip-&gt;i_df.if_u1.if_data
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Round i_bytes up to a word boundary.&n;&t;&t;&t; * The underlying memory is guaranteed to&n;&t;&t;&t; * to be there by xfs_idata_realloc().&n;&t;&t;&t; */
id|data_bytes
op_assign
id|roundup
c_func
(paren
id|ip-&gt;i_df.if_bytes
comma
l_int|4
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_df.if_real_bytes
op_eq
l_int|0
)paren
op_logical_or
(paren
id|ip-&gt;i_df.if_real_bytes
op_eq
id|data_bytes
)paren
)paren
suffix:semicolon
id|vecp-&gt;i_len
op_assign
(paren
r_int
)paren
id|data_bytes
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
id|iip-&gt;ili_format.ilf_dsize
op_assign
(paren
r_int
)paren
id|data_bytes
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_DEV
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_UUID
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DEV
)paren
(brace
id|iip-&gt;ili_format.ilf_u.ilfu_rdev
op_assign
id|ip-&gt;i_df.if_u2.if_rdev
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_UUID
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_DBROOT
op_or
id|XFS_ILOG_DEXT
op_or
id|XFS_ILOG_DDATA
op_or
id|XFS_ILOG_DEV
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_UUID
)paren
(brace
id|iip-&gt;ili_format.ilf_u.ilfu_uuid
op_assign
id|ip-&gt;i_df.if_u2.if_uuid
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are no attributes associated with the file,&n;&t; * then we&squot;re done.&n;&t; * Assert that no attribute-related log flags are set.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|nvecs
op_eq
id|iip-&gt;ili_item.li_desc-&gt;lid_size
)paren
suffix:semicolon
id|iip-&gt;ili_format.ilf_size
op_assign
id|nvecs
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_ADATA
op_or
id|XFS_ILOG_ABROOT
op_or
id|XFS_ILOG_AEXT
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_aformat
)paren
(brace
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_ADATA
op_or
id|XFS_ILOG_ABROOT
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_AEXT
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_bytes
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_u1.if_extents
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_anextents
OG
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|nrecs
op_assign
id|ip-&gt;i_afp-&gt;if_bytes
op_div
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|nrecs
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nrecs
op_eq
id|ip-&gt;i_d.di_anextents
)paren
suffix:semicolon
macro_line|#if ARCH_CONVERT == ARCH_NOCONVERT
multiline_comment|/*&n;&t;&t;&t; * There are not delayed allocation extents&n;&t;&t;&t; * for attributes, so just point at the array.&n;&t;&t;&t; */
id|vecp-&gt;i_addr
op_assign
(paren
r_char
op_star
)paren
(paren
id|ip-&gt;i_afp-&gt;if_u1.if_extents
)paren
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|ip-&gt;i_afp-&gt;if_bytes
suffix:semicolon
macro_line|#else
id|ASSERT
c_func
(paren
id|iip-&gt;ili_aextents_buf
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to endian flip before logging&n;&t;&t;&t; */
id|ext_buffer
op_assign
id|kmem_alloc
c_func
(paren
id|ip-&gt;i_afp-&gt;if_bytes
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|iip-&gt;ili_aextents_buf
op_assign
id|ext_buffer
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
id|ext_buffer
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|xfs_iextents_copy
c_func
(paren
id|ip
comma
id|ext_buffer
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
macro_line|#endif
id|iip-&gt;ili_format.ilf_asize
op_assign
id|vecp-&gt;i_len
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_ADATA
op_or
id|XFS_ILOG_AEXT
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ABROOT
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_broot_bytes
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_broot
op_ne
l_int|NULL
)paren
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
id|ip-&gt;i_afp-&gt;if_broot
suffix:semicolon
id|vecp-&gt;i_len
op_assign
id|ip-&gt;i_afp-&gt;if_broot_bytes
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
id|iip-&gt;ili_format.ilf_asize
op_assign
id|ip-&gt;i_afp-&gt;if_broot_bytes
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
(paren
id|XFS_ILOG_ABROOT
op_or
id|XFS_ILOG_AEXT
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ADATA
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_bytes
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|vecp-&gt;i_addr
op_assign
(paren
id|xfs_caddr_t
)paren
id|ip-&gt;i_afp-&gt;if_u1.if_data
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Round i_bytes up to a word boundary.&n;&t;&t;&t; * The underlying memory is guaranteed to&n;&t;&t;&t; * to be there by xfs_idata_realloc().&n;&t;&t;&t; */
id|data_bytes
op_assign
id|roundup
c_func
(paren
id|ip-&gt;i_afp-&gt;if_bytes
comma
l_int|4
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_afp-&gt;if_real_bytes
op_eq
l_int|0
)paren
op_logical_or
(paren
id|ip-&gt;i_afp-&gt;if_real_bytes
op_eq
id|data_bytes
)paren
)paren
suffix:semicolon
id|vecp-&gt;i_len
op_assign
(paren
r_int
)paren
id|data_bytes
suffix:semicolon
id|vecp
op_increment
suffix:semicolon
id|nvecs
op_increment
suffix:semicolon
id|iip-&gt;ili_format.ilf_asize
op_assign
(paren
r_int
)paren
id|data_bytes
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nvecs
op_eq
id|iip-&gt;ili_item.li_desc-&gt;lid_size
)paren
suffix:semicolon
id|iip-&gt;ili_format.ilf_size
op_assign
id|nvecs
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to pin the inode associated with the inode log&n; * item in memory so it cannot be written out.  Do this by calling&n; * xfs_ipin() to bump the pin count in the inode while holding the&n; * inode pin lock.&n; */
id|STATIC
r_void
DECL|function|xfs_inode_item_pin
id|xfs_inode_item_pin
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|iip-&gt;ili_inode-&gt;i_lock
)paren
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|xfs_ipin
c_func
(paren
id|iip-&gt;ili_inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to unpin the inode associated with the inode log&n; * item which was previously pinned with a call to xfs_inode_item_pin().&n; * Just call xfs_iunpin() on the inode to do this.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_void
DECL|function|xfs_inode_item_unpin
id|xfs_inode_item_unpin
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
comma
r_int
id|stale
)paren
(brace
id|xfs_iunpin
c_func
(paren
id|iip-&gt;ili_inode
)paren
suffix:semicolon
)brace
multiline_comment|/* ARGSUSED */
id|STATIC
r_void
DECL|function|xfs_inode_item_unpin_remove
id|xfs_inode_item_unpin_remove
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
comma
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_iunpin
c_func
(paren
id|iip-&gt;ili_inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to attempt to lock the inode associated with this&n; * inode log item, in preparation for the push routine which does the actual&n; * iflush.  Don&squot;t sleep on the inode lock or the flush lock.&n; *&n; * If the flush lock is already held, indicating that the inode has&n; * been or is in the process of being flushed, then (ideally) we&squot;d like to&n; * see if the inode&squot;s buffer is still incore, and if so give it a nudge.&n; * We delay doing so until the pushbuf routine, though, to avoid holding&n; * the AIL lock across a call to the blackhole which is the buffercache.&n; * Also we don&squot;t want to sleep in any device strategy routines, which can happen&n; * if we do the subsequent bawrite in here.&n; */
id|STATIC
id|uint
DECL|function|xfs_inode_item_trylock
id|xfs_inode_item_trylock
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
r_register
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|ip
op_assign
id|iip-&gt;ili_inode
suffix:semicolon
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
OG
l_int|0
)paren
(brace
r_return
id|XFS_ITEM_PINNED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
)paren
(brace
r_return
id|XFS_ITEM_LOCKED
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If someone else isn&squot;t already trying to push the inode&n;&t;&t; * buffer, we get to do it.&n;&t;&t; */
r_if
c_cond
(paren
id|iip-&gt;ili_pushbuf_flag
op_eq
l_int|0
)paren
(brace
id|iip-&gt;ili_pushbuf_flag
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|iip-&gt;ili_push_owner
op_assign
id|get_thread_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * Inode is left locked in shared mode.&n;&t;&t;&t; * Pushbuf routine gets to unlock it.&n;&t;&t;&t; */
r_return
id|XFS_ITEM_PUSHBUF
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We hold the AIL_LOCK, so we must specify the&n;&t;&t;&t; * NONOTIFY flag so that we won&squot;t double trip.&n;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
op_or
id|XFS_IUNLOCK_NONOTIFY
)paren
suffix:semicolon
r_return
id|XFS_ITEM_FLUSHING
suffix:semicolon
)brace
multiline_comment|/* NOTREACHED */
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|iip-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_logged
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|XFS_ITEM_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlock the inode associated with the inode log item.&n; * Clear the fields of the inode and inode log item that&n; * are specific to the current transaction.  If the&n; * hold flags is set, do not unlock the inode.&n; */
id|STATIC
r_void
DECL|function|xfs_inode_item_unlock
id|xfs_inode_item_unlock
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
id|uint
id|hold
suffix:semicolon
id|uint
id|iolocked
suffix:semicolon
id|uint
id|lock_flags
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_inode-&gt;i_itemp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|iip-&gt;ili_inode-&gt;i_lock
)paren
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
op_logical_neg
(paren
id|iip-&gt;ili_inode-&gt;i_itemp-&gt;ili_flags
op_amp
id|XFS_ILI_IOLOCKED_EXCL
)paren
)paren
op_logical_or
id|ismrlocked
c_func
(paren
op_amp
(paren
id|iip-&gt;ili_inode-&gt;i_iolock
)paren
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
op_logical_neg
(paren
id|iip-&gt;ili_inode-&gt;i_itemp-&gt;ili_flags
op_amp
id|XFS_ILI_IOLOCKED_SHARED
)paren
)paren
op_logical_or
id|ismrlocked
c_func
(paren
op_amp
(paren
id|iip-&gt;ili_inode-&gt;i_iolock
)paren
comma
id|MR_ACCESS
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the transaction pointer in the inode.&n;&t; */
id|ip
op_assign
id|iip-&gt;ili_inode
suffix:semicolon
id|ip-&gt;i_transp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If the inode needed a separate buffer with which to log&n;&t; * its extents, then free it now.&n;&t; */
r_if
c_cond
(paren
id|iip-&gt;ili_extents_buf
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nextents
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_DEXT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_bytes
OG
l_int|0
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|iip-&gt;ili_extents_buf
comma
id|ip-&gt;i_df.if_bytes
)paren
suffix:semicolon
id|iip-&gt;ili_extents_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iip-&gt;ili_aextents_buf
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_anextents
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_AEXT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_afp-&gt;if_bytes
OG
l_int|0
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|iip-&gt;ili_aextents_buf
comma
id|ip-&gt;i_afp-&gt;if_bytes
)paren
suffix:semicolon
id|iip-&gt;ili_aextents_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Figure out if we should unlock the inode or not.&n;&t; */
id|hold
op_assign
id|iip-&gt;ili_flags
op_amp
id|XFS_ILI_HOLD
suffix:semicolon
multiline_comment|/*&n;&t; * Before clearing out the flags, remember whether we&n;&t; * are holding the inode&squot;s IO lock.&n;&t; */
id|iolocked
op_assign
id|iip-&gt;ili_flags
op_amp
id|XFS_ILI_IOLOCKED_ANY
suffix:semicolon
multiline_comment|/*&n;&t; * Clear out the fields of the inode log item particular&n;&t; * to the current transaction.&n;&t; */
id|iip-&gt;ili_ilock_recur
op_assign
l_int|0
suffix:semicolon
id|iip-&gt;ili_iolock_recur
op_assign
l_int|0
suffix:semicolon
id|iip-&gt;ili_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Unlock the inode if XFS_ILI_HOLD was not set.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hold
)paren
(brace
id|lock_flags
op_assign
id|XFS_ILOCK_EXCL
suffix:semicolon
r_if
c_cond
(paren
id|iolocked
op_amp
id|XFS_ILI_IOLOCKED_EXCL
)paren
(brace
id|lock_flags
op_or_assign
id|XFS_IOLOCK_EXCL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|iolocked
op_amp
id|XFS_ILI_IOLOCKED_SHARED
)paren
(brace
id|lock_flags
op_or_assign
id|XFS_IOLOCK_SHARED
suffix:semicolon
)brace
id|xfs_iput
c_func
(paren
id|iip-&gt;ili_inode
comma
id|lock_flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called to find out where the oldest active copy of the&n; * inode log item in the on disk log resides now that the last log&n; * write of it completed at the given lsn.  Since we always re-log&n; * all dirty data in an inode, the latest copy in the on disk log&n; * is the only one that matters.  Therefore, simply return the&n; * given lsn.&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
id|xfs_lsn_t
DECL|function|xfs_inode_item_committed
id|xfs_inode_item_committed
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
comma
id|xfs_lsn_t
id|lsn
)paren
(brace
r_return
(paren
id|lsn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The transaction with the inode locked has aborted.  The inode&n; * must not be dirty within the transaction (unless we&squot;re forcibly&n; * shutting down).  We simply unlock just as if the transaction&n; * had been cancelled.&n; */
id|STATIC
r_void
DECL|function|xfs_inode_item_abort
id|xfs_inode_item_abort
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
id|xfs_inode_item_unlock
c_func
(paren
id|iip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This gets called by xfs_trans_push_ail(), when IOP_TRYLOCK&n; * failed to get the inode flush lock but did get the inode locked SHARED.&n; * Here we&squot;re trying to see if the inode buffer is incore, and if so whether it&squot;s&n; * marked delayed write. If that&squot;s the case, we&squot;ll initiate a bawrite on that&n; * buffer to expedite the process.&n; *&n; * We aren&squot;t holding the AIL_LOCK (or the flush lock) when this gets called,&n; * so it is inherently race-y.&n; */
id|STATIC
r_void
DECL|function|xfs_inode_item_pushbuf
id|xfs_inode_item_pushbuf
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|uint
id|dopush
suffix:semicolon
id|ip
op_assign
id|iip-&gt;ili_inode
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|ip-&gt;i_lock
)paren
comma
id|MR_ACCESS
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The ili_pushbuf_flag keeps others from&n;&t; * trying to duplicate our effort.&n;&t; */
id|ASSERT
c_func
(paren
id|iip-&gt;ili_pushbuf_flag
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iip-&gt;ili_push_owner
op_eq
id|get_thread_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If flushlock isn&squot;t locked anymore, chances are that the&n;&t; * inode flush completed and the inode was taken off the AIL.&n;&t; * So, just get out.&n;&t; */
r_if
c_cond
(paren
(paren
id|valusema
c_func
(paren
op_amp
(paren
id|ip-&gt;i_flock
)paren
)paren
OG
l_int|0
)paren
op_logical_or
(paren
(paren
id|iip-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|iip-&gt;ili_pushbuf_flag
op_assign
l_int|0
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|bp
op_assign
id|xfs_incore
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|iip-&gt;ili_format.ilf_blkno
comma
id|iip-&gt;ili_format.ilf_len
comma
id|XFS_INCORE_TRYLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We were racing with iflush because we don&squot;t hold&n;&t;&t;&t; * the AIL_LOCK or the flush lock. However, at this point,&n;&t;&t;&t; * we have the buffer, and we know that it&squot;s dirty.&n;&t;&t;&t; * So, it&squot;s possible that iflush raced with us, and&n;&t;&t;&t; * this item is already taken off the AIL.&n;&t;&t;&t; * If not, we can flush it async.&n;&t;&t;&t; */
id|dopush
op_assign
(paren
(paren
id|iip-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
op_logical_and
(paren
id|valusema
c_func
(paren
op_amp
(paren
id|ip-&gt;i_flock
)paren
)paren
op_le
l_int|0
)paren
)paren
suffix:semicolon
id|iip-&gt;ili_pushbuf_flag
op_assign
l_int|0
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;INODE ITEM PUSH&quot;
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dopush
)paren
(brace
id|xfs_bawrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|iip-&gt;ili_pushbuf_flag
op_assign
l_int|0
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have to be careful about resetting pushbuf flag too early (above).&n;&t; * Even though in theory we can do it as soon as we have the buflock,&n;&t; * we don&squot;t want others to be doing work needlessly. They&squot;ll come to&n;&t; * this function thinking that pushing the buffer is their&n;&t; * responsibility only to find that the buffer is still locked by&n;&t; * another doing the same thing&n;&t; */
id|iip-&gt;ili_pushbuf_flag
op_assign
l_int|0
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to asynchronously write the inode associated with this&n; * inode log item out to disk. The inode will already have been locked by&n; * a successful call to xfs_inode_item_trylock().&n; */
id|STATIC
r_void
DECL|function|xfs_inode_item_push
id|xfs_inode_item_push
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|ip
op_assign
id|iip-&gt;ili_inode
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
(paren
id|ip-&gt;i_lock
)paren
comma
id|MR_ACCESS
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|valusema
c_func
(paren
op_amp
(paren
id|ip-&gt;i_flock
)paren
)paren
op_le
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we were able to lock the inode&squot;s flush lock and&n;&t; * we found it on the AIL, the inode must be dirty.  This&n;&t; * is because the inode is removed from the AIL while still&n;&t; * holding the flush lock in xfs_iflush_done().  Thus, if&n;&t; * we found it in the AIL and were able to obtain the flush&n;&t; * lock without sleeping, then there must not have been&n;&t; * anyone in the process of flushing the inode.&n;&t; */
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
op_logical_or
id|iip-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Write out the inode.  The completion routine (&squot;iflush_done&squot;) will&n;&t; * pull it from the AIL, mark it clean, unlock the flush lock.&n;&t; */
(paren
r_void
)paren
id|xfs_iflush
c_func
(paren
id|ip
comma
id|XFS_IFLUSH_ASYNC
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * XXX rcc - this one really has to do something.  Probably needs&n; * to stamp in a new field in the incore inode.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_void
DECL|function|xfs_inode_item_committing
id|xfs_inode_item_committing
c_func
(paren
id|xfs_inode_log_item_t
op_star
id|iip
comma
id|xfs_lsn_t
id|lsn
)paren
(brace
id|iip-&gt;ili_last_lsn
op_assign
id|lsn
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the ops vector shared by all buf log items.&n; */
DECL|variable|xfs_inode_item_ops
r_struct
id|xfs_item_ops
id|xfs_inode_item_ops
op_assign
(brace
dot
id|iop_size
op_assign
(paren
id|uint
c_func
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_inode_item_size
comma
dot
id|iop_format
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_log_iovec_t
op_star
)paren
)paren
id|xfs_inode_item_format
comma
dot
id|iop_pin
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_inode_item_pin
comma
dot
id|iop_unpin
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
r_int
)paren
)paren
id|xfs_inode_item_unpin
comma
dot
id|iop_unpin_remove
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_trans_t
op_star
)paren
)paren
id|xfs_inode_item_unpin_remove
comma
dot
id|iop_trylock
op_assign
(paren
id|uint
c_func
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_inode_item_trylock
comma
dot
id|iop_unlock
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_inode_item_unlock
comma
dot
id|iop_committed
op_assign
(paren
id|xfs_lsn_t
c_func
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_lsn_t
)paren
)paren
id|xfs_inode_item_committed
comma
dot
id|iop_push
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_inode_item_push
comma
dot
id|iop_abort
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_inode_item_abort
comma
dot
id|iop_pushbuf
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_inode_item_pushbuf
comma
dot
id|iop_committing
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_log_item_t
op_star
comma
id|xfs_lsn_t
)paren
)paren
id|xfs_inode_item_committing
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize the inode log item for a newly allocated (in-core) inode.&n; */
r_void
DECL|function|xfs_inode_item_init
id|xfs_inode_item_init
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_inode_log_item_t
op_star
id|iip
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_itemp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|iip
op_assign
id|ip-&gt;i_itemp
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_ili_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|iip-&gt;ili_item.li_type
op_assign
id|XFS_LI_INODE
suffix:semicolon
id|iip-&gt;ili_item.li_ops
op_assign
op_amp
id|xfs_inode_item_ops
suffix:semicolon
id|iip-&gt;ili_item.li_mountp
op_assign
id|mp
suffix:semicolon
id|iip-&gt;ili_inode
op_assign
id|ip
suffix:semicolon
multiline_comment|/*&n;&t;   We have zeroed memory. No need ...&n;&t;   iip-&gt;ili_extents_buf = NULL;&n;&t;   iip-&gt;ili_pushbuf_flag = 0;&n;&t; */
id|iip-&gt;ili_format.ilf_type
op_assign
id|XFS_LI_INODE
suffix:semicolon
id|iip-&gt;ili_format.ilf_ino
op_assign
id|ip-&gt;i_ino
suffix:semicolon
id|iip-&gt;ili_format.ilf_blkno
op_assign
id|ip-&gt;i_blkno
suffix:semicolon
id|iip-&gt;ili_format.ilf_len
op_assign
id|ip-&gt;i_len
suffix:semicolon
id|iip-&gt;ili_format.ilf_boffset
op_assign
id|ip-&gt;i_boffset
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the inode log item and any memory hanging off of it.&n; */
r_void
DECL|function|xfs_inode_item_destroy
id|xfs_inode_item_destroy
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
macro_line|#ifdef XFS_TRANS_DEBUG
r_if
c_cond
(paren
id|ip-&gt;i_itemp-&gt;ili_root_size
op_ne
l_int|0
)paren
(brace
id|kmem_free
c_func
(paren
id|ip-&gt;i_itemp-&gt;ili_orig_root
comma
id|ip-&gt;i_itemp-&gt;ili_root_size
)paren
suffix:semicolon
)brace
macro_line|#endif
id|kmem_zone_free
c_func
(paren
id|xfs_ili_zone
comma
id|ip-&gt;i_itemp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the inode flushing I/O completion routine.  It is called&n; * from interrupt level when the buffer containing the inode is&n; * flushed to disk.  It is responsible for removing the inode item&n; * from the AIL if it has not been re-logged, and unlocking the inode&squot;s&n; * flush lock.&n; */
multiline_comment|/*ARGSUSED*/
r_void
DECL|function|xfs_iflush_done
id|xfs_iflush_done
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_inode_log_item_t
op_star
id|iip
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|ip
op_assign
id|iip-&gt;ili_inode
suffix:semicolon
multiline_comment|/*&n;&t; * We only want to pull the item from the AIL if it is&n;&t; * actually there and its location in the log has not&n;&t; * changed since we started the flush.  Thus, we only bother&n;&t; * if the ili_logged flag is set and the inode&squot;s lsn has not&n;&t; * changed.  First we check the lsn outside&n;&t; * the lock since it&squot;s cheaper, and then we recheck while&n;&t; * holding the lock before removing the inode from the AIL.&n;&t; */
r_if
c_cond
(paren
id|iip-&gt;ili_logged
op_logical_and
(paren
id|iip-&gt;ili_item.li_lsn
op_eq
id|iip-&gt;ili_flush_lsn
)paren
)paren
(brace
id|AIL_LOCK
c_func
(paren
id|ip-&gt;i_mount
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_item.li_lsn
op_eq
id|iip-&gt;ili_flush_lsn
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * xfs_trans_delete_ail() drops the AIL lock.&n;&t;&t;&t; */
id|xfs_trans_delete_ail
c_func
(paren
id|ip-&gt;i_mount
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|iip
comma
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
id|AIL_UNLOCK
c_func
(paren
id|ip-&gt;i_mount
comma
id|s
)paren
suffix:semicolon
)brace
)brace
id|iip-&gt;ili_logged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the ili_last_fields bits now that we know that the&n;&t; * data corresponding to them is safely on disk.&n;&t; */
id|iip-&gt;ili_last_fields
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Release the inode&squot;s flush lock since we&squot;re done with it.&n;&t; */
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the inode flushing abort routine.  It is called&n; * from xfs_iflush when the filesystem is shutting down to clean&n; * up the inode state.&n; * It is responsible for removing the inode item&n; * from the AIL if it has not been re-logged, and unlocking the inode&squot;s&n; * flush lock.&n; */
r_void
DECL|function|xfs_iflush_abort
id|xfs_iflush_abort
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_inode_log_item_t
op_star
id|iip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|iip
op_assign
id|ip-&gt;i_itemp
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|iip
)paren
(brace
r_if
c_cond
(paren
id|iip-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
(brace
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iip-&gt;ili_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * xfs_trans_delete_ail() drops the AIL lock.&n;&t;&t;&t;&t; */
id|xfs_trans_delete_ail
c_func
(paren
id|mp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|iip
comma
id|s
)paren
suffix:semicolon
)brace
r_else
id|AIL_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
)brace
id|iip-&gt;ili_logged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear the ili_last_fields bits now that we know that the&n;&t;&t; * data corresponding to them is safely on disk.&n;&t;&t; */
id|iip-&gt;ili_last_fields
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Clear the inode logging fields so no more flushes are&n;&t;&t; * attempted.&n;&t;&t; */
id|iip-&gt;ili_format.ilf_fields
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release the inode&squot;s flush lock since we&squot;re done with it.&n;&t; */
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
eof
