multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * xfs_dir_leaf.c&n; *&n; * GROT: figure out how to recover gracefully when bmap returns ENOSPC.&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_dir_leaf.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
multiline_comment|/*&n; * xfs_dir_leaf.c&n; *&n; * Routines to implement leaf blocks of directories as Btrees of hashed names.&n; */
multiline_comment|/*========================================================================&n; * Function prototypes for the kernel.&n; *========================================================================*/
multiline_comment|/*&n; * Routines used for growing the Btree.&n; */
id|STATIC
r_void
id|xfs_dir_leaf_add_work
c_func
(paren
id|xfs_dabuf_t
op_star
id|leaf_buffer
comma
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|insertion_index
comma
r_int
id|freemap_index
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_leaf_compact
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_dabuf_t
op_star
id|leaf_buffer
comma
r_int
id|musthave
comma
r_int
id|justcheck
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_dir_leaf_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_dir_leaf_figure_balance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|leaf_blk_1
comma
id|xfs_da_state_blk_t
op_star
id|leaf_blk_2
comma
r_int
op_star
id|number_entries_in_blk1
comma
r_int
op_star
id|number_namebytes_in_blk1
)paren
suffix:semicolon
multiline_comment|/*&n; * Utility routines.&n; */
id|STATIC
r_void
id|xfs_dir_leaf_moveents
c_func
(paren
id|xfs_dir_leafblock_t
op_star
id|src_leaf
comma
r_int
id|src_start
comma
id|xfs_dir_leafblock_t
op_star
id|dst_leaf
comma
r_int
id|dst_start
comma
r_int
id|move_count
comma
id|xfs_mount_t
op_star
id|mp
)paren
suffix:semicolon
multiline_comment|/*========================================================================&n; * External routines when dirsize &lt; XFS_IFORK_DSIZE(dp).&n; *========================================================================*/
multiline_comment|/*&n; * Validate a given inode number.&n; */
r_int
DECL|function|xfs_dir_ino_validate
id|xfs_dir_ino_validate
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_ino_t
id|ino
)paren
(brace
id|xfs_agblock_t
id|agblkno
suffix:semicolon
id|xfs_agino_t
id|agino
suffix:semicolon
id|xfs_agnumber_t
id|agno
suffix:semicolon
r_int
id|ino_ok
suffix:semicolon
r_int
id|ioff
suffix:semicolon
id|agno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|agblkno
op_assign
id|XFS_INO_TO_AGBNO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|ioff
op_assign
id|XFS_INO_TO_OFFSET
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|agino
op_assign
id|XFS_OFFBNO_TO_AGINO
c_func
(paren
id|mp
comma
id|agblkno
comma
id|ioff
)paren
suffix:semicolon
id|ino_ok
op_assign
id|agno
OL
id|mp-&gt;m_sb.sb_agcount
op_logical_and
id|agblkno
OL
id|mp-&gt;m_sb.sb_agblocks
op_logical_and
id|agblkno
op_ne
l_int|0
op_logical_and
id|ioff
OL
(paren
l_int|1
op_lshift
id|mp-&gt;m_sb.sb_inopblog
)paren
op_logical_and
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
op_eq
id|ino
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|ino_ok
comma
id|mp
comma
id|XFS_ERRTAG_DIR_INO_VALIDATE
comma
id|XFS_RANDOM_DIR_INO_VALIDATE
)paren
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;Invalid inode number 0x%Lx&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ino
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_dir_ino_validate&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the initial contents of a shortform directory.&n; */
r_int
DECL|function|xfs_dir_shortform_create
id|xfs_dir_shortform_create
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_ino_t
id|parent
)paren
(brace
id|xfs_dir_sf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_d.di_size
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
(brace
id|dp-&gt;i_df.if_flags
op_and_assign
op_complement
id|XFS_IFEXTENTS
suffix:semicolon
multiline_comment|/* just in case */
id|dp-&gt;i_d.di_format
op_assign
id|XFS_DINODE_FMT_LOCAL
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|dp-&gt;i_df.if_flags
op_or_assign
id|XFS_IFINLINE
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
r_sizeof
(paren
op_star
id|hdr
)paren
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|hdr
op_assign
(paren
id|xfs_dir_sf_hdr_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|XFS_DIR_SF_PUT_DIRINO_ARCH
c_func
(paren
op_amp
id|parent
comma
op_amp
id|hdr-&gt;parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
r_sizeof
(paren
op_star
id|hdr
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a name to the shortform directory structure.&n; * Overflow from the inode has already been checked for.&n; */
r_int
DECL|function|xfs_dir_shortform_addname
id|xfs_dir_shortform_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_dir_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_dir_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|i
comma
id|offset
comma
id|size
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Catch the case where the conversion from shortform to leaf&n;&t; * failed part way through.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
r_sizeof
(paren
id|xfs_dir_sf_hdr_t
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|args-&gt;name
(braket
l_int|0
)braket
op_eq
id|sfe-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfe-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
id|sfe
op_assign
id|XFS_DIR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
id|offset
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|sfe
op_minus
(paren
r_char
op_star
)paren
id|sf
)paren
suffix:semicolon
id|size
op_assign
id|XFS_DIR_SF_ENTSIZE_BYNAME
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|size
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|sfe
op_assign
(paren
id|xfs_dir_sf_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|sf
op_plus
id|offset
)paren
suffix:semicolon
id|XFS_DIR_SF_PUT_DIRINO_ARCH
c_func
(paren
op_amp
id|args-&gt;inumber
comma
op_amp
id|sfe-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfe-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|sfe-&gt;name
comma
id|args-&gt;name
comma
id|sfe-&gt;namelen
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_add_assign
id|size
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from the shortform directory structure.&n; */
r_int
DECL|function|xfs_dir_shortform_removename
id|xfs_dir_shortform_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_dir_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_dir_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|base
comma
id|size
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Catch the case where the conversion from shortform to leaf&n;&t; * failed part way through.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
r_sizeof
(paren
id|xfs_dir_sf_hdr_t
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|base
op_assign
r_sizeof
(paren
id|xfs_dir_sf_hdr_t
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|size
op_assign
id|XFS_DIR_SF_ENTSIZE_BYENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|sfe-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|sfe-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|base
op_add_assign
id|size
suffix:semicolon
id|sfe
op_assign
id|XFS_DIR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|base
op_plus
id|size
)paren
op_ne
id|dp-&gt;i_d.di_size
)paren
(brace
id|memmove
c_func
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|sf
)paren
(braket
id|base
)braket
comma
op_amp
(paren
(paren
r_char
op_star
)paren
id|sf
)paren
(braket
id|base
op_plus
id|size
)braket
comma
id|dp-&gt;i_d.di_size
op_minus
(paren
id|base
op_plus
id|size
)paren
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|size
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_sub_assign
id|size
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a name in a shortform directory structure.&n; */
r_int
DECL|function|xfs_dir_shortform_lookup
id|xfs_dir_shortform_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_dir_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_dir_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Catch the case where the conversion from shortform to leaf&n;&t; * failed part way through.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
r_sizeof
(paren
id|xfs_dir_sf_hdr_t
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;namelen
op_eq
l_int|2
op_logical_and
id|args-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|args-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|XFS_DIR_SF_GET_DIRINO_ARCH
c_func
(paren
op_amp
id|sf-&gt;hdr.parent
comma
op_amp
id|args-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args-&gt;namelen
op_eq
l_int|1
op_logical_and
id|args-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|args-&gt;inumber
op_assign
id|dp-&gt;i_ino
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|sfe-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfe-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
id|XFS_DIR_SF_GET_DIRINO_ARCH
c_func
(paren
op_amp
id|sfe-&gt;inumber
comma
op_amp
id|args-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
id|sfe
op_assign
id|XFS_DIR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from using the shortform to the leaf.&n; */
r_int
DECL|function|xfs_dir_shortform_to_leaf
id|xfs_dir_shortform_to_leaf
c_func
(paren
id|xfs_da_args_t
op_star
id|iargs
)paren
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dir_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_dir_sf_entry_t
op_star
id|sfe
suffix:semicolon
id|xfs_da_args_t
id|args
suffix:semicolon
id|xfs_ino_t
id|inumber
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
r_int
id|retval
comma
id|i
comma
id|size
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|dp
op_assign
id|iargs-&gt;dp
suffix:semicolon
multiline_comment|/*&n;&t; * Catch the case where the conversion from shortform to leaf&n;&t; * failed part way through.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
r_sizeof
(paren
id|xfs_dir_sf_hdr_t
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|size
op_assign
id|dp-&gt;i_df.if_bytes
suffix:semicolon
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpbuffer
comma
id|dp-&gt;i_df.if_u1.if_data
comma
id|size
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|XFS_DIR_SF_GET_DIRINO_ARCH
c_func
(paren
op_amp
id|sf-&gt;hdr.parent
comma
op_amp
id|inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|size
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
l_int|0
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|iargs-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|iargs
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|ASSERT
c_func
(paren
id|blkno
op_eq
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_create
c_func
(paren
id|iargs
comma
id|blkno
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
id|args.name
op_assign
l_string|&quot;.&quot;
suffix:semicolon
id|args.namelen
op_assign
l_int|1
suffix:semicolon
id|args.hashval
op_assign
id|xfs_dir_hash_dot
suffix:semicolon
id|args.inumber
op_assign
id|dp-&gt;i_ino
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|iargs-&gt;firstblock
suffix:semicolon
id|args.flist
op_assign
id|iargs-&gt;flist
suffix:semicolon
id|args.total
op_assign
id|iargs-&gt;total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|iargs-&gt;trans
suffix:semicolon
id|args.justcheck
op_assign
l_int|0
suffix:semicolon
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|args.name
op_assign
l_string|&quot;..&quot;
suffix:semicolon
id|args.namelen
op_assign
l_int|2
suffix:semicolon
id|args.hashval
op_assign
id|xfs_dir_hash_dotdot
suffix:semicolon
id|args.inumber
op_assign
id|inumber
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|args.name
op_assign
(paren
r_char
op_star
)paren
(paren
id|sfe-&gt;name
)paren
suffix:semicolon
id|args.namelen
op_assign
id|sfe-&gt;namelen
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|sfe-&gt;name
)paren
comma
id|sfe-&gt;namelen
)paren
suffix:semicolon
id|XFS_DIR_SF_GET_DIRINO_ARCH
c_func
(paren
op_amp
id|sfe-&gt;inumber
comma
op_amp
id|args.inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|sfe
op_assign
id|XFS_DIR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|size
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_dir_shortform_compare
id|xfs_dir_shortform_compare
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
id|xfs_dir_sf_sort_t
op_star
id|sa
comma
op_star
id|sb
suffix:semicolon
id|sa
op_assign
(paren
id|xfs_dir_sf_sort_t
op_star
)paren
id|a
suffix:semicolon
id|sb
op_assign
(paren
id|xfs_dir_sf_sort_t
op_star
)paren
id|b
suffix:semicolon
r_if
c_cond
(paren
id|sa-&gt;hash
OL
id|sb-&gt;hash
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sa-&gt;hash
OG
id|sb-&gt;hash
)paren
r_return
l_int|1
suffix:semicolon
r_else
r_return
id|sa-&gt;entno
op_minus
id|sb-&gt;entno
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy out directory entries for getdents(), for shortform directories.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|xfs_dir_shortform_getdents
id|xfs_dir_shortform_getdents
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eofp
comma
id|xfs_dirent_t
op_star
id|dbp
comma
id|xfs_dir_put_t
id|put
)paren
(brace
id|xfs_dir_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_dir_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|retval
comma
id|i
comma
id|sbsize
comma
id|nsbuf
comma
id|lastresid
op_assign
l_int|0
comma
id|want_entno
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_dahash_t
id|cookhash
comma
id|hash
suffix:semicolon
id|xfs_dir_put_args_t
id|p
suffix:semicolon
id|xfs_dir_sf_sort_t
op_star
id|sbuf
comma
op_star
id|sbp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|cookhash
op_assign
id|XFS_DA_COOKIE_HASH
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
id|want_entno
op_assign
id|XFS_DA_COOKIE_ENTRY
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
id|nsbuf
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|2
suffix:semicolon
id|sbsize
op_assign
(paren
id|nsbuf
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|sbuf
)paren
suffix:semicolon
id|sbp
op_assign
id|sbuf
op_assign
id|kmem_alloc
c_func
(paren
id|sbsize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;sf: start&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Collect all the entries into the buffer.&n;&t; * Entry 0 is .&n;&t; */
id|sbp-&gt;entno
op_assign
l_int|0
suffix:semicolon
id|sbp-&gt;seqno
op_assign
l_int|0
suffix:semicolon
id|sbp-&gt;hash
op_assign
id|xfs_dir_hash_dot
suffix:semicolon
id|sbp-&gt;ino
op_assign
id|dp-&gt;i_ino
suffix:semicolon
id|sbp-&gt;name
op_assign
l_string|&quot;.&quot;
suffix:semicolon
id|sbp-&gt;namelen
op_assign
l_int|1
suffix:semicolon
id|sbp
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Entry 1 is ..&n;&t; */
id|sbp-&gt;entno
op_assign
l_int|1
suffix:semicolon
id|sbp-&gt;seqno
op_assign
l_int|0
suffix:semicolon
id|sbp-&gt;hash
op_assign
id|xfs_dir_hash_dotdot
suffix:semicolon
id|sbp-&gt;ino
op_assign
id|XFS_GET_DIR_INO_ARCH
c_func
(paren
id|mp
comma
id|sf-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sbp-&gt;name
op_assign
l_string|&quot;..&quot;
suffix:semicolon
id|sbp-&gt;namelen
op_assign
l_int|2
suffix:semicolon
id|sbp
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the directory data for the rest of the entries.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|sfe
OL
(paren
r_char
op_star
)paren
id|sf
)paren
op_logical_or
(paren
(paren
r_char
op_star
)paren
id|sfe
op_ge
(paren
(paren
r_char
op_star
)paren
id|sf
op_plus
id|dp-&gt;i_df.if_bytes
)paren
)paren
)paren
)paren
(brace
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;sf: corrupted&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_dir_shortform_getdents&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|sfe
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|sbuf
comma
id|sbsize
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|sbp-&gt;entno
op_assign
id|i
op_plus
l_int|2
suffix:semicolon
id|sbp-&gt;seqno
op_assign
l_int|0
suffix:semicolon
id|sbp-&gt;hash
op_assign
id|xfs_da_hashname
c_func
(paren
(paren
r_char
op_star
)paren
id|sfe-&gt;name
comma
id|sfe-&gt;namelen
)paren
suffix:semicolon
id|sbp-&gt;ino
op_assign
id|XFS_GET_DIR_INO_ARCH
c_func
(paren
id|mp
comma
id|sfe-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sbp-&gt;name
op_assign
(paren
r_char
op_star
)paren
id|sfe-&gt;name
suffix:semicolon
id|sbp-&gt;namelen
op_assign
id|sfe-&gt;namelen
suffix:semicolon
id|sfe
op_assign
id|XFS_DIR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
id|sbp
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Sort the entries on hash then entno.&n;&t; */
id|qsort
c_func
(paren
id|sbuf
comma
id|nsbuf
comma
r_sizeof
(paren
op_star
id|sbuf
)paren
comma
id|xfs_dir_shortform_compare
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Stuff in last entry.&n;&t; */
id|sbp-&gt;entno
op_assign
id|nsbuf
suffix:semicolon
id|sbp-&gt;hash
op_assign
id|XFS_DA_MAXHASH
suffix:semicolon
id|sbp-&gt;seqno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out the sequence numbers in case there&squot;s a hash duplicate.&n;&t; */
r_for
c_loop
(paren
id|hash
op_assign
id|sbuf-&gt;hash
comma
id|sbp
op_assign
id|sbuf
op_plus
l_int|1
suffix:semicolon
id|sbp
OL
op_amp
id|sbuf
(braket
id|nsbuf
op_plus
l_int|1
)braket
suffix:semicolon
id|sbp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sbp-&gt;hash
op_eq
id|hash
)paren
id|sbp-&gt;seqno
op_assign
id|sbp
(braket
op_minus
l_int|1
)braket
dot
id|seqno
op_plus
l_int|1
suffix:semicolon
r_else
id|hash
op_assign
id|sbp-&gt;hash
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set up put routine.&n;&t; */
id|p.dbp
op_assign
id|dbp
suffix:semicolon
id|p.put
op_assign
id|put
suffix:semicolon
id|p.uio
op_assign
id|uio
suffix:semicolon
multiline_comment|/*&n;&t; * Find our place.&n;&t; */
r_for
c_loop
(paren
id|sbp
op_assign
id|sbuf
suffix:semicolon
id|sbp
OL
op_amp
id|sbuf
(braket
id|nsbuf
op_plus
l_int|1
)braket
suffix:semicolon
id|sbp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sbp-&gt;hash
OG
id|cookhash
op_logical_or
(paren
id|sbp-&gt;hash
op_eq
id|cookhash
op_logical_and
id|sbp-&gt;seqno
op_ge
id|want_entno
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Did we fail to find anything?  We stop at the last entry,&n;&t; * the one we put maxhash into.&n;&t; */
r_if
c_cond
(paren
id|sbp
op_eq
op_amp
id|sbuf
(braket
id|nsbuf
)braket
)paren
(brace
id|kmem_free
c_func
(paren
id|sbuf
comma
id|sbsize
)paren
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;sf: hash beyond end&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
id|uio-&gt;uio_offset
op_assign
id|XFS_DA_MAKE_COOKIE
c_func
(paren
id|mp
comma
l_int|0
comma
l_int|0
comma
id|XFS_DA_MAXHASH
)paren
suffix:semicolon
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop putting entries into the user buffer.&n;&t; */
r_while
c_loop
(paren
id|sbp
OL
op_amp
id|sbuf
(braket
id|nsbuf
)braket
)paren
(brace
multiline_comment|/*&n;&t;&t; * Save the first resid in a run of equal-hashval entries&n;&t;&t; * so that we can back them out if they don&squot;t all fit.&n;&t;&t; */
r_if
c_cond
(paren
id|sbp-&gt;seqno
op_eq
l_int|0
op_logical_or
id|sbp
op_eq
id|sbuf
)paren
id|lastresid
op_assign
id|uio-&gt;uio_resid
suffix:semicolon
id|XFS_PUT_COOKIE
c_func
(paren
id|p.cook
comma
id|mp
comma
l_int|0
comma
id|sbp
(braket
l_int|1
)braket
dot
id|seqno
comma
id|sbp
(braket
l_int|1
)braket
dot
id|hash
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
id|p.ino
op_assign
id|sbp-&gt;ino
op_plus
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#else
id|p.ino
op_assign
id|sbp-&gt;ino
suffix:semicolon
macro_line|#endif
id|p.name
op_assign
id|sbp-&gt;name
suffix:semicolon
id|p.namelen
op_assign
id|sbp-&gt;namelen
suffix:semicolon
id|retval
op_assign
id|p
dot
id|put
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p.done
)paren
(brace
id|uio-&gt;uio_offset
op_assign
id|XFS_DA_MAKE_COOKIE
c_func
(paren
id|mp
comma
l_int|0
comma
l_int|0
comma
id|sbp-&gt;hash
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|sbuf
comma
id|sbsize
)paren
suffix:semicolon
id|uio-&gt;uio_resid
op_assign
id|lastresid
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;sf: E-O-B&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|sbp
op_increment
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|sbuf
comma
id|sbsize
)paren
suffix:semicolon
id|uio-&gt;uio_offset
op_assign
id|p.cook.o
suffix:semicolon
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;sf: E-O-F&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a name in a shortform directory structure, replace the inode number.&n; */
r_int
DECL|function|xfs_dir_shortform_replace
id|xfs_dir_shortform_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_dir_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_dir_sf_entry_t
op_star
id|sfe
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Catch the case where the conversion from shortform to leaf&n;&t; * failed part way through.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
r_sizeof
(paren
id|xfs_dir_sf_hdr_t
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_dir_shortform_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;namelen
op_eq
l_int|2
op_logical_and
id|args-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|args-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
multiline_comment|/* XXX - replace assert? */
id|XFS_DIR_SF_PUT_DIRINO_ARCH
c_func
(paren
op_amp
id|args-&gt;inumber
comma
op_amp
id|sf-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|args-&gt;namelen
op_ne
l_int|1
op_logical_or
id|args-&gt;name
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|sfe-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfe-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|memcmp
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|args-&gt;inumber
comma
(paren
r_char
op_star
)paren
op_amp
id|sfe-&gt;inumber
comma
r_sizeof
(paren
id|xfs_ino_t
)paren
)paren
)paren
suffix:semicolon
id|XFS_DIR_SF_PUT_DIRINO_ARCH
c_func
(paren
op_amp
id|args-&gt;inumber
comma
op_amp
id|sfe-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sfe
op_assign
id|XFS_DIR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a leaf directory to shortform structure&n; */
r_int
DECL|function|xfs_dir_leaf_to_shortform
id|xfs_dir_leaf_to_shortform
c_func
(paren
id|xfs_da_args_t
op_star
id|iargs
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_dir_leaf_name_t
op_star
id|namest
suffix:semicolon
id|xfs_da_args_t
id|args
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_ino_t
id|parent
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
r_int
id|retval
comma
id|i
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|dp
op_assign
id|iargs-&gt;dp
suffix:semicolon
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|iargs-&gt;trans
comma
id|iargs-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpbuffer
comma
id|bp-&gt;data
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_dir_leafblock_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bp-&gt;data
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find and special case the parent inode number&n;&t; */
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|entry
op_increment
comma
id|i
op_decrement
)paren
(brace
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;namelen
op_eq
l_int|2
)paren
op_logical_and
(paren
id|namest-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
op_logical_and
(paren
id|namest-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
(brace
id|XFS_DIR_SF_GET_DIRINO_ARCH
c_func
(paren
op_amp
id|namest-&gt;inumber
comma
op_amp
id|parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|entry-&gt;namelen
op_eq
l_int|1
)paren
op_logical_and
(paren
id|namest-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
(brace
id|INT_ZERO
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
id|retval
op_assign
id|xfs_da_shrink_inode
c_func
(paren
id|iargs
comma
l_int|0
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
id|retval
op_assign
id|xfs_dir_shortform_create
c_func
(paren
id|iargs
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the rest of the filenames&n;&t; */
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
id|iargs-&gt;firstblock
suffix:semicolon
id|args.flist
op_assign
id|iargs-&gt;flist
suffix:semicolon
id|args.total
op_assign
id|iargs-&gt;total
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_DATA_FORK
suffix:semicolon
id|args.trans
op_assign
id|iargs-&gt;trans
suffix:semicolon
id|args.justcheck
op_assign
l_int|0
suffix:semicolon
id|args.addname
op_assign
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
r_continue
suffix:semicolon
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|args.name
op_assign
(paren
r_char
op_star
)paren
(paren
id|namest-&gt;name
)paren
suffix:semicolon
id|args.namelen
op_assign
id|entry-&gt;namelen
suffix:semicolon
id|args.hashval
op_assign
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|XFS_DIR_SF_GET_DIRINO_ARCH
c_func
(paren
op_amp
id|namest-&gt;inumber
comma
op_amp
id|args.inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir_shortform_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from using a single leaf to a root node and a leaf.&n; */
r_int
DECL|function|xfs_dir_leaf_to_node
id|xfs_dir_leaf_to_node
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp1
comma
op_star
id|bp2
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|retval
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|args
comma
op_amp
id|blkno
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|blkno
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp1
op_ne
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_da_get_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|1
comma
op_minus
l_int|1
comma
op_amp
id|bp2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|bp1
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp2
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp2-&gt;data
comma
id|bp1-&gt;data
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp2
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the new root node.&n;&t; */
id|retval
op_assign
id|xfs_da_node_create
c_func
(paren
id|args
comma
l_int|0
comma
l_int|1
comma
op_amp
id|bp1
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|bp2
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|node
op_assign
id|bp1-&gt;data
suffix:semicolon
id|leaf
op_assign
id|bp2-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp2
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|before
comma
id|ARCH_CONVERT
comma
id|blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp1
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
op_amp
id|node-&gt;btree
(braket
l_int|0
)braket
comma
r_sizeof
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
)paren
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp1
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for growing the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Create the initial contents of a leaf directory&n; * or a leaf in a node directory.&n; */
r_int
DECL|function|xfs_dir_leaf_create
id|xfs_dir_leaf_create
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dablk_t
id|blkno
comma
id|xfs_dabuf_t
op_star
op_star
id|bpp
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_da_get_buf
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|leaf
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;info.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Split the leaf node, rebalance, then add the new entry.&n; */
r_int
DECL|function|xfs_dir_leaf_split
id|xfs_dir_leaf_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|oldblk
comma
id|xfs_da_state_blk_t
op_star
id|newblk
)paren
(brace
id|xfs_dablk_t
id|blkno
suffix:semicolon
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for a new leaf node.&n;&t; */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|ASSERT
c_func
(paren
id|args
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|oldblk-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|args
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|xfs_dir_leaf_create
c_func
(paren
id|args
comma
id|blkno
comma
op_amp
id|newblk-&gt;bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|newblk-&gt;blkno
op_assign
id|blkno
suffix:semicolon
id|newblk-&gt;magic
op_assign
id|XFS_DIR_LEAF_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t; * Rebalance the entries across the two leaves.&n;&t; */
id|xfs_dir_leaf_rebalance
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_blk_link
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Insert the new entry in the correct block.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;inleaf
)paren
(brace
id|error
op_assign
id|xfs_dir_leaf_add
c_func
(paren
id|oldblk-&gt;bp
comma
id|args
comma
id|oldblk-&gt;index
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_dir_leaf_add
c_func
(paren
id|newblk-&gt;bp
comma
id|args
comma
id|newblk-&gt;index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update last hashval in each block since we added the name.&n;&t; */
id|oldblk-&gt;hashval
op_assign
id|xfs_dir_leaf_lasthash
c_func
(paren
id|oldblk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
id|newblk-&gt;hashval
op_assign
id|xfs_dir_leaf_lasthash
c_func
(paren
id|newblk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a name to the leaf directory structure.&n; *&n; * Must take into account fragmented leaves and leaves where spacemap has&n; * lost some freespace information (ie: holes).&n; */
r_int
DECL|function|xfs_dir_leaf_add
id|xfs_dir_leaf_add
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|index
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_dir_leaf_map_t
op_star
id|map
suffix:semicolon
r_int
id|tablesize
comma
id|entsize
comma
id|sum
comma
id|i
comma
id|tmp
comma
id|error
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|index
op_le
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|entsize
op_assign
id|XFS_DIR_LEAF_ENTSIZE_BYNAME
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Search through freemap for first-fit on new name length.&n;&t; * (may need to figure in size of entry struct too)&n;&t; */
id|tablesize
op_assign
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|XFS_DIR_LEAF_MAPSIZE
op_minus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|sum
op_assign
l_int|0
comma
id|i
op_assign
id|XFS_DIR_LEAF_MAPSIZE
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|map
op_decrement
comma
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|tablesize
OG
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|sum
op_add_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* no space in this map */
id|tmp
op_assign
id|entsize
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|tmp
op_add_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
op_ge
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|args-&gt;justcheck
)paren
id|xfs_dir_leaf_add_work
c_func
(paren
id|bp
comma
id|args
comma
id|index
comma
id|i
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sum
op_add_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are no holes in the address space of the block,&n;&t; * and we don&squot;t have enough freespace, then compaction will do us&n;&t; * no good and we should just give up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hdr-&gt;holes
op_logical_and
(paren
id|sum
OL
id|entsize
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compact the entries to coalesce free space.&n;&t; * Pass the justcheck flag so the checking pass can return&n;&t; * an error, without changing anything, if it won&squot;t fit.&n;&t; */
id|error
op_assign
id|xfs_dir_leaf_compact
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|args-&gt;total
op_eq
l_int|0
ques
c_cond
id|entsize
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:colon
l_int|0
comma
id|args-&gt;justcheck
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * After compaction, the block is guaranteed to have only one&n;&t; * free region, in freemap[0].  If it is not big enough, give up.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|entsize
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|args-&gt;justcheck
)paren
id|xfs_dir_leaf_add_work
c_func
(paren
id|bp
comma
id|args
comma
id|index
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a name to a leaf directory structure.&n; */
id|STATIC
r_void
DECL|function|xfs_dir_leaf_add_work
id|xfs_dir_leaf_add_work
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|index
comma
r_int
id|mapindex
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_dir_leaf_name_t
op_star
id|namest
suffix:semicolon
id|xfs_dir_leaf_map_t
op_star
id|map
suffix:semicolon
multiline_comment|/* REFERENCED */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|mapindex
op_ge
l_int|0
)paren
op_logical_and
(paren
id|mapindex
OL
id|XFS_DIR_LEAF_MAPSIZE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|index
op_le
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Force open some space in the entry array and fill it in.&n;&t; */
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|index
suffix:semicolon
id|tmp
op_mul_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|entry
op_plus
l_int|1
comma
id|entry
comma
id|tmp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
id|tmp
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for the new string (at the end of the run).&n;&t; */
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|mapindex
)braket
suffix:semicolon
id|mp
op_assign
id|args-&gt;trans-&gt;t_mountp
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
op_ge
id|XFS_DIR_LEAF_ENTSIZE_BYNAME
c_func
(paren
id|args-&gt;namelen
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|XFS_DIR_LEAF_ENTSIZE_BYNAME
c_func
(paren
id|args-&gt;namelen
)paren
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
comma
id|args-&gt;hashval
)paren
suffix:semicolon
id|entry-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the string and inode number into the new space.&n;&t; */
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|XFS_DIR_SF_PUT_DIRINO_ARCH
c_func
(paren
op_amp
id|args-&gt;inumber
comma
op_amp
id|namest-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|namest-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|namest
comma
id|XFS_DIR_LEAF_ENTSIZE_BYENTRY
c_func
(paren
id|entry
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the control info for this leaf node&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|INT_COPY
c_func
(paren
id|hdr-&gt;firstused
comma
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFS_DIR_LEAF_MAPSIZE
suffix:semicolon
id|map
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_eq
id|tmp
)paren
(brace
id|INT_MOD
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
comma
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
op_minus
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
id|INT_MOD
c_func
(paren
id|hdr-&gt;namebytes
comma
id|ARCH_CONVERT
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Garbage collect a leaf directory block by copying it to a new buffer.&n; */
id|STATIC
r_int
DECL|function|xfs_dir_leaf_compact
id|xfs_dir_leaf_compact
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
id|musthave
comma
r_int
id|justcheck
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf_s
comma
op_star
id|leaf_d
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr_s
comma
op_star
id|hdr_d
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
r_char
op_star
id|tmpbuffer2
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rval
suffix:semicolon
r_int
id|lbsize
suffix:semicolon
id|mp
op_assign
id|trans-&gt;t_mountp
suffix:semicolon
id|lbsize
op_assign
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|lbsize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpbuffer
comma
id|bp-&gt;data
comma
id|lbsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make a second copy in case xfs_dir_leaf_moveents()&n;&t; * below destroys the original.&n;&t; */
r_if
c_cond
(paren
id|musthave
op_logical_or
id|justcheck
)paren
(brace
id|tmpbuffer2
op_assign
id|kmem_alloc
c_func
(paren
id|lbsize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpbuffer2
comma
id|bp-&gt;data
comma
id|lbsize
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bp-&gt;data
comma
l_int|0
comma
id|lbsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy basic information&n;&t; */
id|leaf_s
op_assign
(paren
id|xfs_dir_leafblock_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|leaf_d
op_assign
id|bp-&gt;data
suffix:semicolon
id|hdr_s
op_assign
op_amp
id|leaf_s-&gt;hdr
suffix:semicolon
id|hdr_d
op_assign
op_amp
id|leaf_d-&gt;hdr
suffix:semicolon
id|hdr_d-&gt;info
op_assign
id|hdr_s-&gt;info
suffix:semicolon
multiline_comment|/* struct copy */
id|INT_SET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|lbsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|INT_SET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|lbsize
op_minus
l_int|1
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|hdr_d-&gt;holes
op_assign
l_int|0
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy all entry&squot;s in the same (sorted) order,&n;&t; * but allocate filenames packed and in sequence.&n;&t; * This changes the source (leaf_s) as well.&n;&t; */
id|xfs_dir_leaf_moveents
c_func
(paren
id|leaf_s
comma
l_int|0
comma
id|leaf_d
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|musthave
op_logical_and
id|INT_GET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
OL
id|musthave
)paren
id|rval
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_else
id|rval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|justcheck
op_logical_or
id|rval
op_eq
id|ENOSPC
)paren
(brace
id|ASSERT
c_func
(paren
id|tmpbuffer2
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp-&gt;data
comma
id|tmpbuffer2
comma
id|lbsize
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_da_log_buf
c_func
(paren
id|trans
comma
id|bp
comma
l_int|0
comma
id|lbsize
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|lbsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|musthave
op_logical_or
id|justcheck
)paren
id|kmem_free
c_func
(paren
id|tmpbuffer2
comma
id|lbsize
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Redistribute the directory entries between two leaf nodes,&n; * taking into account the size of the new entry.&n; *&n; * NOTE: if new block is empty, then it will get the upper half of old block.&n; */
id|STATIC
r_void
DECL|function|xfs_dir_leaf_rebalance
id|xfs_dir_leaf_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
(brace
id|xfs_da_state_blk_t
op_star
id|tmp_blk
suffix:semicolon
id|xfs_dir_leafblock_t
op_star
id|leaf1
comma
op_star
id|leaf2
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr1
comma
op_star
id|hdr2
suffix:semicolon
r_int
id|count
comma
id|totallen
comma
id|max
comma
id|space
comma
id|swap
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|ASSERT
c_func
(paren
id|blk1-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk2-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|leaf1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check ordering of blocks, reverse if it makes things simpler.&n;&t; */
id|swap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xfs_dir_leaf_order
c_func
(paren
id|blk1-&gt;bp
comma
id|blk2-&gt;bp
)paren
)paren
(brace
id|tmp_blk
op_assign
id|blk1
suffix:semicolon
id|blk1
op_assign
id|blk2
suffix:semicolon
id|blk2
op_assign
id|tmp_blk
suffix:semicolon
id|leaf1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|swap
op_assign
l_int|1
suffix:semicolon
)brace
id|hdr1
op_assign
op_amp
id|leaf1-&gt;hdr
suffix:semicolon
id|hdr2
op_assign
op_amp
id|leaf2-&gt;hdr
suffix:semicolon
multiline_comment|/*&n;&t; * Examine entries until we reduce the absolute difference in&n;&t; * byte usage between the two blocks to a minimum.  Then get&n;&t; * the direction to copy and the number of elements to move.&n;&t; */
id|state-&gt;inleaf
op_assign
id|xfs_dir_leaf_figure_balance
c_func
(paren
id|state
comma
id|blk1
comma
id|blk2
comma
op_amp
id|count
comma
op_amp
id|totallen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swap
)paren
id|state-&gt;inleaf
op_assign
op_logical_neg
id|state-&gt;inleaf
suffix:semicolon
multiline_comment|/*&n;&t; * Move any entries required from leaf to leaf:&n;&t; */
r_if
c_cond
(paren
id|count
OL
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Figure the total bytes to be added to the destination leaf.&n;&t;&t; */
id|count
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
suffix:semicolon
multiline_comment|/* number entries being moved */
id|space
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;namebytes
comma
id|ARCH_CONVERT
)paren
op_minus
id|totallen
suffix:semicolon
id|space
op_add_assign
id|count
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_name_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|space
op_add_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * leaf2 is the destination, compact it if it looks tight.&n;&t;&t; */
id|max
op_assign
id|INT_GET
c_func
(paren
id|hdr2-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
id|max
op_sub_assign
id|INT_GET
c_func
(paren
id|hdr2-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
id|max
)paren
(brace
id|xfs_dir_leaf_compact
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|blk2-&gt;bp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move high entries from leaf1 to low end of leaf2.&n;&t;&t; */
id|xfs_dir_leaf_moveents
c_func
(paren
id|leaf1
comma
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
comma
id|leaf2
comma
l_int|0
comma
id|count
comma
id|state-&gt;mp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|blk1-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|blk2-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OG
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Figure the total bytes to be added to the destination leaf.&n;&t;&t; */
id|count
op_sub_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* number entries being moved */
id|space
op_assign
id|totallen
op_minus
id|INT_GET
c_func
(paren
id|hdr1-&gt;namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|space
op_add_assign
id|count
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_name_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|space
op_add_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * leaf1 is the destination, compact it if it looks tight.&n;&t;&t; */
id|max
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
id|max
op_sub_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
id|max
)paren
(brace
id|xfs_dir_leaf_compact
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|blk1-&gt;bp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move low entries from leaf2 to high end of leaf1.&n;&t;&t; */
id|xfs_dir_leaf_moveents
c_func
(paren
id|leaf2
comma
l_int|0
comma
id|leaf1
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|count
comma
id|state-&gt;mp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|blk1-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|blk2-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy out last hashval in each block for B-tree code.&n;&t; */
id|blk1-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|leaf1-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|blk2-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|leaf2-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the expected index for insertion.&n;&t; * GROT: this doesn&squot;t work unless blk2 was originally empty.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;inleaf
)paren
(brace
id|blk2-&gt;index
op_assign
id|blk1-&gt;index
op_minus
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Examine entries until we reduce the absolute difference in&n; * byte usage between the two blocks to a minimum.&n; * GROT: Is this really necessary?  With other than a 512 byte blocksize,&n; * GROT: there will always be enough room in either block for a new entry.&n; * GROT: Do a double-split for this case?&n; */
id|STATIC
r_int
DECL|function|xfs_dir_leaf_figure_balance
id|xfs_dir_leaf_figure_balance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
comma
r_int
op_star
id|countarg
comma
r_int
op_star
id|namebytesarg
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf1
comma
op_star
id|leaf2
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr1
comma
op_star
id|hdr2
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
r_int
id|count
comma
id|max
comma
id|totallen
comma
id|half
suffix:semicolon
r_int
id|lastdelta
comma
id|foundit
comma
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|leaf1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|hdr1
op_assign
op_amp
id|leaf1-&gt;hdr
suffix:semicolon
id|hdr2
op_assign
op_amp
id|leaf2-&gt;hdr
suffix:semicolon
id|foundit
op_assign
l_int|0
suffix:semicolon
id|totallen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Examine entries until we reduce the absolute difference in&n;&t; * byte usage between the two blocks to a minimum.&n;&t; */
id|max
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|hdr2-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|half
op_assign
(paren
id|max
op_plus
l_int|1
)paren
op_star
(paren
id|uint
)paren
(paren
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|half
op_add_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;namebytes
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|hdr2-&gt;namebytes
comma
id|ARCH_CONVERT
)paren
op_plus
id|state-&gt;args-&gt;namelen
suffix:semicolon
id|half
op_div_assign
l_int|2
suffix:semicolon
id|lastdelta
op_assign
id|state-&gt;blocksize
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf1-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|max
suffix:semicolon
id|entry
op_increment
comma
id|count
op_increment
)paren
(brace
DECL|macro|XFS_DIR_ABS
mdefine_line|#define XFS_DIR_ABS(A)&t;(((A) &lt; 0) ? -(A) : (A))
multiline_comment|/*&n;&t;&t; * The new entry is in the first block, account for it.&n;&t;&t; */
r_if
c_cond
(paren
id|count
op_eq
id|blk1-&gt;index
)paren
(brace
id|tmp
op_assign
id|totallen
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
id|XFS_DIR_LEAF_ENTSIZE_BYNAME
c_func
(paren
id|state-&gt;args-&gt;namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_DIR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
OG
id|lastdelta
)paren
r_break
suffix:semicolon
id|lastdelta
op_assign
id|XFS_DIR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
suffix:semicolon
id|totallen
op_assign
id|tmp
suffix:semicolon
id|foundit
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wrap around into the second block if necessary.&n;&t;&t; */
r_if
c_cond
(paren
id|count
op_eq
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|leaf1
op_assign
id|leaf2
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf1-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Figure out if next leaf entry would be too much.&n;&t;&t; */
id|tmp
op_assign
id|totallen
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
id|XFS_DIR_LEAF_ENTSIZE_BYENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_DIR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
OG
id|lastdelta
)paren
r_break
suffix:semicolon
id|lastdelta
op_assign
id|XFS_DIR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
suffix:semicolon
id|totallen
op_assign
id|tmp
suffix:semicolon
DECL|macro|XFS_DIR_ABS
macro_line|#undef XFS_DIR_ABS
)brace
multiline_comment|/*&n;&t; * Calculate the number of namebytes that will end up in lower block.&n;&t; * If new entry not in lower block, fix up the count.&n;&t; */
id|totallen
op_sub_assign
id|count
op_star
(paren
id|uint
)paren
(paren
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foundit
)paren
(brace
id|totallen
op_sub_assign
(paren
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_minus
l_int|1
)paren
op_plus
id|state-&gt;args-&gt;namelen
suffix:semicolon
)brace
op_star
id|countarg
op_assign
id|count
suffix:semicolon
op_star
id|namebytesarg
op_assign
id|totallen
suffix:semicolon
r_return
id|foundit
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for shrinking the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Check a leaf block and its neighbors to see if the block should be&n; * collapsed into one or the other neighbor.  Always keep the block&n; * with the smaller block number.&n; * If the current block is over 50% full, don&squot;t try to join it, return 0.&n; * If the block is empty, fill in the state structure and return 2.&n; * If it can be collapsed, fill in the state structure and return 1.&n; * If nothing can be done, return 0.&n; */
r_int
DECL|function|xfs_dir_leaf_toosmall
id|xfs_dir_leaf_toosmall
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
r_int
op_star
id|action
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
r_int
id|count
comma
id|bytes
comma
id|forward
comma
id|error
comma
id|retval
comma
id|i
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being over 50% full.&n;&t; * If so, it&squot;s not worth even looking to see if we might be able&n;&t; * to coalesce with a sibling.&n;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|info
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_dir_leafblock_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
op_plus
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_plus
id|count
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_name_t
)paren
op_minus
l_int|1
)paren
op_plus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
(paren
id|state-&gt;blocksize
op_rshift
l_int|1
)paren
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* blk over 50%, don&squot;t try to join */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being empty.&n;&t; * If the block is empty, we&squot;ll simply delete it, no need to&n;&t; * coalesce it with a sibling block.  We choose (aribtrarily)&n;&t; * to merge with the forward block unless it is NULL.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make altpath point to the block we want to keep and&n;&t;&t; * path point to the block we want to drop (this one).&n;&t;&t; */
id|forward
op_assign
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|action
op_assign
l_int|2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Examine each sibling block to see if we can coalesce with&n;&t; * at least 25% free space to spare.  We need to figure out&n;&t; * whether to merge with the forward or the backward block.&n;&t; * We prefer coalescing with the lower numbered sibling so as&n;&t; * to shrink a directory over time.&n;&t; */
id|forward
op_assign
(paren
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/* start with smaller blk num */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|forward
op_assign
op_logical_neg
id|forward
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|forward
)paren
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_else
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|state-&gt;args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_dir_leafblock_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_assign
id|state-&gt;blocksize
op_minus
(paren
id|state-&gt;blocksize
op_rshift
l_int|2
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|count
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|count
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_name_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|bytes
op_sub_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
op_ge
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* fits with at least 25% to spare */
id|xfs_da_brelse
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
l_int|2
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make altpath point to the block we want to keep (the lower&n;&t; * numbered block) and path point to the block we want to drop.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
OL
id|blk-&gt;blkno
)paren
(brace
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|action
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from the leaf directory structure.&n; *&n; * Return 1 if leaf is less than 37% full, 0 if &gt;= 37% full.&n; * If two leaves are 37% full, when combined they will leave 25% free.&n; */
r_int
DECL|function|xfs_dir_leaf_remove
id|xfs_dir_leaf_remove
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
id|index
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_dir_leaf_map_t
op_star
id|map
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_dir_leaf_name_t
op_star
id|namest
suffix:semicolon
r_int
id|before
comma
id|after
comma
id|smallest
comma
id|entsize
suffix:semicolon
r_int
id|tablesize
comma
id|tmp
comma
id|i
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|mp
op_assign
id|trans-&gt;t_mountp
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_div
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|index
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|index
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan through free region table:&n;&t; *    check for adjacency of free&squot;d entry with an existing one,&n;&t; *    find smallest free region in case we need to replace it,&n;&t; *    adjust any map that borders the entry table,&n;&t; */
id|tablesize
op_assign
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
l_int|0
)braket
suffix:semicolon
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|before
op_assign
id|after
op_assign
op_minus
l_int|1
suffix:semicolon
id|smallest
op_assign
id|XFS_DIR_LEAF_MAPSIZE
op_minus
l_int|1
suffix:semicolon
id|entsize
op_assign
id|XFS_DIR_LEAF_ENTSIZE_BYENTRY
c_func
(paren
id|entry
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFS_DIR_LEAF_MAPSIZE
suffix:semicolon
id|map
op_increment
comma
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_eq
id|tablesize
)paren
(brace
id|INT_MOD
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
comma
op_minus
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|before
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_eq
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_plus
id|entsize
)paren
)paren
(brace
id|after
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|tmp
)paren
(brace
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|smallest
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Coalesce adjacent freemap regions,&n;&t; * or replace the smallest region.&n;&t; */
r_if
c_cond
(paren
(paren
id|before
op_ge
l_int|0
)paren
op_logical_or
(paren
id|after
op_ge
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|before
op_ge
l_int|0
)paren
op_logical_and
(paren
id|after
op_ge
l_int|0
)paren
)paren
(brace
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|before
)braket
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr-&gt;freemap
(braket
id|after
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr-&gt;freemap
(braket
id|after
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr-&gt;freemap
(braket
id|after
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|before
op_ge
l_int|0
)paren
(brace
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|before
)braket
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
)brace
r_else
(brace
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|after
)braket
suffix:semicolon
id|INT_COPY
c_func
(paren
id|map-&gt;base
comma
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Replace smallest region (if it is smaller than free&squot;d entry)&n;&t;&t; */
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|smallest
)braket
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|entsize
)paren
(brace
id|INT_COPY
c_func
(paren
id|map-&gt;base
comma
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Did we remove the first entry?&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|smallest
op_assign
l_int|1
suffix:semicolon
r_else
id|smallest
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Compress the remaining entries and zero out the removed stuff.&n;&t; */
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|namest
comma
l_int|0
comma
id|entsize
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|namest
comma
id|entsize
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr-&gt;namebytes
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|entry-&gt;namelen
)paren
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|index
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|entry
comma
id|entry
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
id|tmp
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|entry
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we removed the first entry, re-find the first used byte&n;&t; * in the name area.  Note that if the entry was the &quot;firstused&quot;,&n;&t; * then we don&squot;t have a &quot;hole&quot; in our block resulting from&n;&t; * removing the name.&n;&t; */
r_if
c_cond
(paren
id|smallest
)paren
(brace
id|tmp
op_assign
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|entry
op_increment
comma
id|i
op_decrement
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|tmp
)paren
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|tmp
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|hdr-&gt;holes
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* mark as needing compaction */
)brace
id|xfs_da_log_buf
c_func
(paren
id|trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if leaf is less than 50% full, caller may want to&n;&t; * &quot;join&quot; the leaf with a sibling if so.&n;&t; */
id|tmp
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
id|tmp
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|tmp
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_name_t
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|tmp
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
id|mp-&gt;m_dir_magicpct
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* leaf is &lt; 37% full */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move all the directory entries from drop_leaf into save_leaf.&n; */
r_void
DECL|function|xfs_dir_leaf_unbalance
id|xfs_dir_leaf_unbalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|drop_blk
comma
id|xfs_da_state_blk_t
op_star
id|save_blk
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|drop_leaf
comma
op_star
id|save_leaf
comma
op_star
id|tmp_leaf
suffix:semicolon
id|xfs_dir_leaf_hdr_t
op_star
id|drop_hdr
comma
op_star
id|save_hdr
comma
op_star
id|tmp_hdr
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|mp
op_assign
id|state-&gt;mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|drop_blk-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|save_blk-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|drop_leaf
op_assign
id|drop_blk-&gt;bp-&gt;data
suffix:semicolon
id|save_leaf
op_assign
id|save_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|drop_hdr
op_assign
op_amp
id|drop_leaf-&gt;hdr
suffix:semicolon
id|save_hdr
op_assign
op_amp
id|save_leaf-&gt;hdr
suffix:semicolon
multiline_comment|/*&n;&t; * Save last hashval from dying block for later Btree fixup.&n;&t; */
id|drop_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;entries
(braket
id|drop_leaf-&gt;hdr.count
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if we need a temp buffer, or can we do it in place.&n;&t; * Note that we don&squot;t check &quot;leaf&quot; for holes because we will&n;&t; * always be dropping it, toosmall() decided that for us already.&n;&t; */
r_if
c_cond
(paren
id|save_hdr-&gt;holes
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * dest leaf has no holes, so we add there.  May need&n;&t;&t; * to make some room in the entry array.&n;&t;&t; */
r_if
c_cond
(paren
id|xfs_dir_leaf_order
c_func
(paren
id|save_blk-&gt;bp
comma
id|drop_blk-&gt;bp
)paren
)paren
(brace
id|xfs_dir_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|save_leaf
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_dir_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|save_leaf
comma
id|INT_GET
c_func
(paren
id|save_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Destination has holes, so we make a temporary copy&n;&t;&t; * of the leaf and add them both to that.&n;&t;&t; */
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|state-&gt;blocksize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tmpbuffer
comma
l_int|0
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
id|tmp_leaf
op_assign
(paren
id|xfs_dir_leafblock_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|tmp_hdr
op_assign
op_amp
id|tmp_leaf-&gt;hdr
suffix:semicolon
id|tmp_hdr-&gt;info
op_assign
id|save_hdr-&gt;info
suffix:semicolon
multiline_comment|/* struct copy */
id|INT_ZERO
c_func
(paren
id|tmp_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|tmp_hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|tmp_hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|INT_SET
c_func
(paren
id|tmp_hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|tmp_hdr-&gt;namebytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_dir_leaf_order
c_func
(paren
id|save_blk-&gt;bp
comma
id|drop_blk-&gt;bp
)paren
)paren
(brace
id|xfs_dir_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
id|xfs_dir_leaf_moveents
c_func
(paren
id|save_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
id|INT_GET
c_func
(paren
id|tmp_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|save_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_dir_leaf_moveents
c_func
(paren
id|save_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|save_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
id|xfs_dir_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
id|INT_GET
c_func
(paren
id|tmp_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|save_leaf
comma
id|tmp_leaf
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
)brace
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|save_blk-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy out last hashval in each block for B-tree code.&n;&t; */
id|save_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|save_leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for finding things in the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Look up a name in a leaf directory structure.&n; * This is the internal routine, it uses the caller&squot;s buffer.&n; *&n; * Note that duplicate keys are allowed, but only check within the&n; * current leaf node.  The Btree code must check in adjacent leaf nodes.&n; *&n; * Return in *index the index into the entry[] array of either the found&n; * entry, or where the entry should have been (insert before that entry).&n; *&n; * Don&squot;t change the args-&gt;inumber unless we find the filename.&n; */
r_int
DECL|function|xfs_dir_leaf_lookup_int
id|xfs_dir_leaf_lookup_int
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
comma
r_int
op_star
id|index
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_dir_leaf_name_t
op_star
id|namest
suffix:semicolon
r_int
id|probe
comma
id|span
suffix:semicolon
id|xfs_dahash_t
id|hashval
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|args-&gt;dp-&gt;i_mount
)paren
op_div
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Binary search.  (note: small blocks will skip this loop)&n;&t; */
id|hashval
op_assign
id|args-&gt;hashval
suffix:semicolon
id|probe
op_assign
id|span
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_div
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|probe
)braket
suffix:semicolon
id|span
OG
l_int|4
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|probe
)braket
)paren
(brace
id|span
op_div_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OL
id|hashval
)paren
id|probe
op_add_assign
id|span
suffix:semicolon
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OG
id|hashval
)paren
id|probe
op_sub_assign
id|span
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|probe
op_ge
l_int|0
)paren
op_logical_and
"&bslash;"
(paren
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|probe
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|span
op_le
l_int|4
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hashval
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we may have duplicate hashval&squot;s, find the first matching&n;&t; * hashval in the leaf.&n;&t; */
r_while
c_loop
(paren
(paren
id|probe
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|hashval
)paren
)paren
(brace
id|entry
op_decrement
suffix:semicolon
id|probe
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|probe
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OL
id|hashval
)paren
)paren
(brace
id|entry
op_increment
suffix:semicolon
id|probe
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|probe
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ne
id|hashval
)paren
)paren
(brace
op_star
id|index
op_assign
id|probe
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Duplicate keys may be present, so search all of them for a match.&n;&t; */
r_while
c_loop
(paren
(paren
id|probe
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hashval
)paren
)paren
(brace
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|namest-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|namest-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
id|XFS_DIR_SF_GET_DIRINO_ARCH
c_func
(paren
op_amp
id|namest-&gt;inumber
comma
op_amp
id|args-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
op_star
id|index
op_assign
id|probe
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
id|entry
op_increment
suffix:semicolon
id|probe
op_increment
suffix:semicolon
)brace
op_star
id|index
op_assign
id|probe
suffix:semicolon
id|ASSERT
c_func
(paren
id|probe
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Utility routines.&n; *========================================================================*/
multiline_comment|/*&n; * Move the indicated entries from one leaf to another.&n; * NOTE: this routine modifies both source and destination leaves.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_void
DECL|function|xfs_dir_leaf_moveents
id|xfs_dir_leaf_moveents
c_func
(paren
id|xfs_dir_leafblock_t
op_star
id|leaf_s
comma
r_int
id|start_s
comma
id|xfs_dir_leafblock_t
op_star
id|leaf_d
comma
r_int
id|start_d
comma
r_int
id|count
comma
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_dir_leaf_hdr_t
op_star
id|hdr_s
comma
op_star
id|hdr_d
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry_s
comma
op_star
id|entry_d
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Check for nothing to do.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf_s-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf_d-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
id|hdr_s
op_assign
op_amp
id|leaf_s-&gt;hdr
suffix:semicolon
id|hdr_d
op_assign
op_amp
id|leaf_d-&gt;hdr
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_div
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry_s
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr_s
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_div
l_int|8
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry_d
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr_d
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_s
OL
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_d
op_le
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|count
op_le
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Move the entries in the destination leaf up to make a hole?&n;&t; */
r_if
c_cond
(paren
id|start_d
OL
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|start_d
suffix:semicolon
id|tmp
op_mul_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_d-&gt;entries
(braket
id|start_d
)braket
suffix:semicolon
id|entry_d
op_assign
op_amp
id|leaf_d-&gt;entries
(braket
id|start_d
op_plus
id|count
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|entry_d
comma
id|entry_s
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy all entry&squot;s in the same (sorted) order,&n;&t; * but allocate filenames packed and in sequence.&n;&t; */
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
)braket
suffix:semicolon
id|entry_d
op_assign
op_amp
id|leaf_d-&gt;entries
(braket
id|start_d
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|entry_s
op_increment
comma
id|entry_d
op_increment
comma
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry_s-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|hdr_s-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|entry_s-&gt;namelen
OL
id|MAXNAMELEN
)paren
suffix:semicolon
id|tmp
op_assign
id|XFS_DIR_LEAF_ENTSIZE_BYENTRY
c_func
(paren
id|entry_s
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|entry_d-&gt;hashval
op_assign
id|entry_s-&gt;hashval
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|INT_COPY
c_func
(paren
id|entry_d-&gt;nameidx
comma
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry_d-&gt;namelen
op_assign
id|entry_s-&gt;namelen
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry_d-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_plus
id|tmp
op_le
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf_d
comma
id|INT_GET
c_func
(paren
id|entry_d-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
comma
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf_s
comma
id|INT_GET
c_func
(paren
id|entry_s-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
comma
id|tmp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry_s-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_plus
id|tmp
op_le
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf_s
comma
id|INT_GET
c_func
(paren
id|entry_s-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
comma
l_int|0
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_s-&gt;namebytes
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|entry_d-&gt;namelen
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;namebytes
comma
id|ARCH_CONVERT
comma
id|entry_d-&gt;namelen
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Zero out the entries we just copied.&n;&t; */
r_if
c_cond
(paren
id|start_s
op_eq
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|tmp
op_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_s
op_plus
id|tmp
op_le
(paren
r_char
op_star
)paren
id|leaf_s
op_plus
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_s
comma
l_int|0
comma
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Move the remaining entries down to fill the hole,&n;&t;&t; * then zero the entries at the top.&n;&t;&t; */
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
suffix:semicolon
id|tmp
op_mul_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
op_plus
id|count
)braket
suffix:semicolon
id|entry_d
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|entry_d
comma
id|entry_s
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_s
op_plus
id|tmp
op_le
(paren
r_char
op_star
)paren
id|leaf_s
op_plus
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_s
comma
l_int|0
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the freemap information&n;&t; */
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_hdr_t
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir_leaf_entry_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|1
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|2
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|1
)braket
dot
id|size
comma
id|ARCH_CONVERT
comma
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|2
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|hdr_s-&gt;holes
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* leaf may not be compact */
)brace
multiline_comment|/*&n; * Compare two leaf blocks &quot;order&quot;.&n; */
r_int
DECL|function|xfs_dir_leaf_order
id|xfs_dir_leaf_order
c_func
(paren
id|xfs_dabuf_t
op_star
id|leaf1_bp
comma
id|xfs_dabuf_t
op_star
id|leaf2_bp
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf1
comma
op_star
id|leaf2
suffix:semicolon
id|leaf1
op_assign
id|leaf1_bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|leaf2_bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|leaf1-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|leaf1-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick up the last hashvalue from a leaf block.&n; */
id|xfs_dahash_t
DECL|function|xfs_dir_leaf_lasthash
id|xfs_dir_leaf_lasthash
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
op_star
id|count
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
op_star
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy out directory entries for getdents(), for leaf directories.&n; */
r_int
DECL|function|xfs_dir_leaf_getdents_int
id|xfs_dir_leaf_getdents_int
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dablk_t
id|bno
comma
id|uio_t
op_star
id|uio
comma
r_int
op_star
id|eobp
comma
id|xfs_dirent_t
op_star
id|dbp
comma
id|xfs_dir_put_t
id|put
comma
id|xfs_daddr_t
id|nextda
)paren
(brace
id|xfs_dir_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_dir_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_dir_leaf_name_t
op_star
id|namest
suffix:semicolon
r_int
id|entno
comma
id|want_entno
comma
id|i
comma
id|nextentno
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_dahash_t
id|cookhash
suffix:semicolon
id|xfs_dahash_t
id|nexthash
op_assign
l_int|0
suffix:semicolon
macro_line|#if (BITS_PER_LONG == 32)
id|xfs_dahash_t
id|lasthash
op_assign
id|XFS_DA_MAXHASH
suffix:semicolon
macro_line|#endif
id|xfs_dir_put_args_t
id|p
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR_LEAF_MAGIC
)paren
(brace
op_star
id|eobp
op_assign
l_int|1
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
multiline_comment|/* XXX wrong code */
)brace
id|want_entno
op_assign
id|XFS_DA_COOKIE_ENTRY
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
id|cookhash
op_assign
id|XFS_DA_COOKIE_HASH
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
id|xfs_dir_trace_g_dul
c_func
(paren
l_string|&quot;leaf: start&quot;
comma
id|dp
comma
id|uio
comma
id|leaf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Re-find our place.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|entno
op_assign
l_int|0
comma
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|namest
OL
(paren
r_char
op_star
)paren
id|leaf
)paren
op_logical_or
(paren
(paren
r_char
op_star
)paren
id|namest
op_ge
(paren
r_char
op_star
)paren
id|leaf
op_plus
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_dir_leaf_getdents_int(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;leaf: corrupted&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|cookhash
)paren
(brace
r_if
c_cond
(paren
id|entno
OL
id|want_entno
op_logical_and
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|cookhash
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Trying to get to a particular offset in a&n;&t;&t;&t;&t; * run of equal-hashval entries.&n;&t;&t;&t;&t; */
id|entno
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|want_entno
OG
l_int|0
op_logical_and
id|entno
op_eq
id|want_entno
op_logical_and
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|cookhash
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|entno
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;leaf: hash not found&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
)paren
id|uio-&gt;uio_offset
op_assign
id|XFS_DA_MAKE_COOKIE
c_func
(paren
id|mp
comma
l_int|0
comma
l_int|0
comma
id|XFS_DA_MAXHASH
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t set uio_offset if there&squot;s another block:&n;&t;&t; * the node code will be setting uio_offset anyway.&n;&t;&t; */
op_star
id|eobp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_dir_trace_g_due
c_func
(paren
l_string|&quot;leaf: hash found&quot;
comma
id|dp
comma
id|uio
comma
id|entry
)paren
suffix:semicolon
id|p.dbp
op_assign
id|dbp
suffix:semicolon
id|p.put
op_assign
id|put
suffix:semicolon
id|p.uio
op_assign
id|uio
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;re synchronized, start copying entries out to the user.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|entno
op_ge
l_int|0
op_logical_and
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
comma
(paren
id|entno
op_assign
id|nextentno
)paren
)paren
(brace
r_int
id|lastresid
op_assign
l_int|0
comma
id|retval
suffix:semicolon
id|xfs_dircook_t
id|lastoffset
suffix:semicolon
id|xfs_dahash_t
id|thishash
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check for a damaged directory leaf block and pick up&n;&t;&t; * the inode number from this entry.&n;&t;&t; */
id|namest
op_assign
id|XFS_DIR_LEAF_NAMESTRUCT
c_func
(paren
id|leaf
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|namest
OL
(paren
r_char
op_star
)paren
id|leaf
)paren
op_logical_or
(paren
(paren
r_char
op_star
)paren
id|namest
op_ge
(paren
r_char
op_star
)paren
id|leaf
op_plus
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_dir_leaf_getdents_int(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|leaf
)paren
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;leaf: corrupted&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|xfs_dir_trace_g_duc
c_func
(paren
l_string|&quot;leaf: middle cookie  &quot;
comma
id|dp
comma
id|uio
comma
id|p.cook.o
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|nexthash
op_assign
id|INT_GET
c_func
(paren
id|entry
(braket
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nexthash
op_eq
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
)paren
id|nextentno
op_assign
id|entno
op_plus
l_int|1
suffix:semicolon
r_else
id|nextentno
op_assign
l_int|0
suffix:semicolon
id|XFS_PUT_COOKIE
c_func
(paren
id|p.cook
comma
id|mp
comma
id|bno
comma
id|nextentno
comma
id|nexthash
)paren
suffix:semicolon
id|xfs_dir_trace_g_duc
c_func
(paren
l_string|&quot;leaf: middle cookie  &quot;
comma
id|dp
comma
id|uio
comma
id|p.cook.o
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|thishash
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|xfs_dabuf_t
op_star
id|bp2
suffix:semicolon
id|xfs_dir_leafblock_t
op_star
id|leaf2
suffix:semicolon
id|ASSERT
c_func
(paren
id|nextda
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_da_read_buf
c_func
(paren
id|dp-&gt;i_transp
comma
id|dp
comma
id|thishash
comma
id|nextda
comma
op_amp
id|bp2
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp2
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf2
op_assign
id|bp2-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR_LEAF_MAGIC
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.back
comma
id|ARCH_CONVERT
)paren
op_ne
id|bno
)paren
)paren
)paren
(brace
multiline_comment|/* GROT */
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_dir_leaf_getdents_int(3)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|leaf2
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|dp-&gt;i_transp
comma
id|bp2
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|nexthash
op_assign
id|INT_GET
c_func
(paren
id|leaf2-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|nextentno
op_assign
op_minus
l_int|1
suffix:semicolon
id|XFS_PUT_COOKIE
c_func
(paren
id|p.cook
comma
id|mp
comma
id|thishash
comma
l_int|0
comma
id|nexthash
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|dp-&gt;i_transp
comma
id|bp2
)paren
suffix:semicolon
id|xfs_dir_trace_g_duc
c_func
(paren
l_string|&quot;leaf: next blk cookie&quot;
comma
id|dp
comma
id|uio
comma
id|p.cook.o
)paren
suffix:semicolon
)brace
r_else
(brace
id|nextentno
op_assign
op_minus
l_int|1
suffix:semicolon
id|XFS_PUT_COOKIE
c_func
(paren
id|p.cook
comma
id|mp
comma
l_int|0
comma
l_int|0
comma
id|XFS_DA_MAXHASH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Save off the cookie so we can fall back should the&n;&t;&t; * &squot;put&squot; into the outgoing buffer fails.  To handle a run&n;&t;&t; * of equal-hashvals, the off_t structure on 64bit&n;&t;&t; * builds has entno built into the cookie to ID the&n;&t;&t; * entry.  On 32bit builds, we only have space for the&n;&t;&t; * hashval so we can&squot;t ID specific entries within a group&n;&t;&t; * of same hashval entries.   For this, lastoffset is set&n;&t;&t; * to the first in the run of equal hashvals so we don&squot;t&n;&t;&t; * include any entries unless we can include all entries&n;&t;&t; * that share the same hashval.  Hopefully the buffer&n;&t;&t; * provided is big enough to handle it (see pv763517).&n;&t;&t; */
macro_line|#if (BITS_PER_LONG == 32)
r_if
c_cond
(paren
(paren
id|thishash
op_assign
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_ne
id|lasthash
)paren
(brace
id|XFS_PUT_COOKIE
c_func
(paren
id|lastoffset
comma
id|mp
comma
id|bno
comma
id|entno
comma
id|thishash
)paren
suffix:semicolon
id|lastresid
op_assign
id|uio-&gt;uio_resid
suffix:semicolon
id|lasthash
op_assign
id|thishash
suffix:semicolon
)brace
r_else
(brace
id|xfs_dir_trace_g_duc
c_func
(paren
l_string|&quot;leaf: DUP COOKIES, skipped&quot;
comma
id|dp
comma
id|uio
comma
id|p.cook.o
)paren
suffix:semicolon
)brace
macro_line|#else
id|lasthash
op_assign
id|thishash
op_assign
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|XFS_PUT_COOKIE
c_func
(paren
id|lastoffset
comma
id|mp
comma
id|bno
comma
id|entno
comma
id|thishash
)paren
suffix:semicolon
id|lastresid
op_assign
id|uio-&gt;uio_resid
suffix:semicolon
macro_line|#endif /* BITS_PER_LONG == 32 */
multiline_comment|/*&n;&t;&t; * Put the current entry into the outgoing buffer.  If we fail&n;&t;&t; * then restore the UIO to the first entry in the current&n;&t;&t; * run of equal-hashval entries (probably one 1 entry long).&n;&t;&t; */
macro_line|#if XFS_BIG_FILESYSTEMS
id|p.ino
op_assign
id|XFS_GET_DIR_INO_ARCH
c_func
(paren
id|mp
comma
id|namest-&gt;inumber
comma
id|ARCH_CONVERT
)paren
op_plus
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#else
id|p.ino
op_assign
id|XFS_GET_DIR_INO_ARCH
c_func
(paren
id|mp
comma
id|namest-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#endif
id|p.name
op_assign
(paren
r_char
op_star
)paren
id|namest-&gt;name
suffix:semicolon
id|p.namelen
op_assign
id|entry-&gt;namelen
suffix:semicolon
id|retval
op_assign
id|p
dot
id|put
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p.done
)paren
(brace
id|uio-&gt;uio_offset
op_assign
id|lastoffset.o
suffix:semicolon
id|uio-&gt;uio_resid
op_assign
id|lastresid
suffix:semicolon
op_star
id|eobp
op_assign
l_int|1
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;leaf: E-O-B&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
id|uio-&gt;uio_offset
op_assign
id|p.cook.o
suffix:semicolon
op_star
id|eobp
op_assign
l_int|0
suffix:semicolon
id|xfs_dir_trace_g_du
c_func
(paren
l_string|&quot;leaf: E-O-F&quot;
comma
id|dp
comma
id|uio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Format a dirent64 structure and copy it out the the user&squot;s buffer.&n; */
r_int
DECL|function|xfs_dir_put_dirent64_direct
id|xfs_dir_put_dirent64_direct
c_func
(paren
id|xfs_dir_put_args_t
op_star
id|pa
)paren
(brace
id|iovec_t
op_star
id|iovp
suffix:semicolon
r_int
id|reclen
comma
id|namelen
suffix:semicolon
id|xfs_dirent_t
op_star
id|idbp
suffix:semicolon
id|uio_t
op_star
id|uio
suffix:semicolon
id|namelen
op_assign
id|pa-&gt;namelen
suffix:semicolon
id|reclen
op_assign
id|DIRENTSIZE
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|uio
op_assign
id|pa-&gt;uio
suffix:semicolon
r_if
c_cond
(paren
id|reclen
OG
id|uio-&gt;uio_resid
)paren
(brace
id|pa-&gt;done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|iovp
op_assign
id|uio-&gt;uio_iov
suffix:semicolon
id|idbp
op_assign
(paren
id|xfs_dirent_t
op_star
)paren
id|iovp-&gt;iov_base
suffix:semicolon
id|iovp-&gt;iov_base
op_assign
(paren
r_char
op_star
)paren
id|idbp
op_plus
id|reclen
suffix:semicolon
id|iovp-&gt;iov_len
op_sub_assign
id|reclen
suffix:semicolon
id|uio-&gt;uio_resid
op_sub_assign
id|reclen
suffix:semicolon
id|idbp-&gt;d_reclen
op_assign
id|reclen
suffix:semicolon
id|idbp-&gt;d_ino
op_assign
id|pa-&gt;ino
suffix:semicolon
id|idbp-&gt;d_off
op_assign
id|pa-&gt;cook.o
suffix:semicolon
id|idbp-&gt;d_name
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pa-&gt;done
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|idbp-&gt;d_name
comma
id|pa-&gt;name
comma
id|namelen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Format a dirent64 structure and copy it out the the user&squot;s buffer.&n; */
r_int
DECL|function|xfs_dir_put_dirent64_uio
id|xfs_dir_put_dirent64_uio
c_func
(paren
id|xfs_dir_put_args_t
op_star
id|pa
)paren
(brace
r_int
id|retval
comma
id|reclen
comma
id|namelen
suffix:semicolon
id|xfs_dirent_t
op_star
id|idbp
suffix:semicolon
id|uio_t
op_star
id|uio
suffix:semicolon
id|namelen
op_assign
id|pa-&gt;namelen
suffix:semicolon
id|reclen
op_assign
id|DIRENTSIZE
c_func
(paren
id|namelen
)paren
suffix:semicolon
id|uio
op_assign
id|pa-&gt;uio
suffix:semicolon
r_if
c_cond
(paren
id|reclen
OG
id|uio-&gt;uio_resid
)paren
(brace
id|pa-&gt;done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|idbp
op_assign
id|pa-&gt;dbp
suffix:semicolon
id|idbp-&gt;d_reclen
op_assign
id|reclen
suffix:semicolon
id|idbp-&gt;d_ino
op_assign
id|pa-&gt;ino
suffix:semicolon
id|idbp-&gt;d_off
op_assign
id|pa-&gt;cook.o
suffix:semicolon
id|idbp-&gt;d_name
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|memcpy
c_func
(paren
id|idbp-&gt;d_name
comma
id|pa-&gt;name
comma
id|namelen
)paren
suffix:semicolon
id|retval
op_assign
id|uiomove
c_func
(paren
(paren
id|caddr_t
)paren
id|idbp
comma
id|reclen
comma
id|UIO_READ
comma
id|uio
)paren
suffix:semicolon
id|pa-&gt;done
op_assign
(paren
id|retval
op_eq
l_int|0
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
eof
