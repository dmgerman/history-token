multiline_comment|/*&n; * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_fs.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_clnt.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rtalloc.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_itable.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_acl.h&quot;
macro_line|#include &quot;xfs_cap.h&quot;
macro_line|#include &quot;xfs_mac.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_trans_space.h&quot;
macro_line|#include &quot;xfs_utils.h&quot;
macro_line|#include &quot;xfs_qm.h&quot;
multiline_comment|/*&n; * The global quota manager. There is only one of these for the entire&n; * system, _not_ one per file system. XQM keeps track of the overall&n; * quota functionality, including maintaining the freelist and hash&n; * tables of dquots.&n; */
DECL|variable|xfs_Gqm_lock
id|mutex_t
id|xfs_Gqm_lock
suffix:semicolon
DECL|variable|xfs_Gqm
r_struct
id|xfs_qm
op_star
id|xfs_Gqm
suffix:semicolon
DECL|variable|qm_dqzone
id|kmem_zone_t
op_star
id|qm_dqzone
suffix:semicolon
DECL|variable|qm_dqtrxzone
id|kmem_zone_t
op_star
id|qm_dqtrxzone
suffix:semicolon
DECL|variable|xfs_qm_shaker
id|kmem_shaker_t
id|xfs_qm_shaker
suffix:semicolon
id|STATIC
r_void
id|xfs_qm_list_init
c_func
(paren
id|xfs_dqlist_t
op_star
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_qm_list_destroy
c_func
(paren
id|xfs_dqlist_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_init_quotainos
c_func
(paren
id|xfs_mount_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_shake
c_func
(paren
r_int
comma
r_int
r_int
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_extern
id|mutex_t
id|qcheck_lock
suffix:semicolon
macro_line|#endif
macro_line|#ifdef QUOTADEBUG
DECL|macro|XQM_LIST_PRINT
mdefine_line|#define XQM_LIST_PRINT(l, NXT, title) &bslash;&n;{ &bslash;&n;&t;xfs_dquot_t&t;*dqp; int i = 0; &bslash;&n;&t;cmn_err(CE_DEBUG, &quot;%s (#%d)&quot;, title, (int) (l)-&gt;qh_nelems); &bslash;&n;&t;for (dqp = (l)-&gt;qh_next; dqp != NULL; dqp = dqp-&gt;NXT) { &bslash;&n;&t;&t;cmn_err(CE_DEBUG, &quot;   %d.  &bslash;&quot;%d (%s)&bslash;&quot;   &quot; &bslash;&n;&t;&t;&t;&t;  &quot;bcnt = %d, icnt = %d, refs = %d&quot;, &bslash;&n;&t;&t;&t;++i, (int) INT_GET(dqp-&gt;q_core.d_id, ARCH_CONVERT), &bslash;&n;&t;&t;&t;DQFLAGTO_TYPESTR(dqp),&t;     &bslash;&n;&t;&t;&t;(int) INT_GET(dqp-&gt;q_core.d_bcount, ARCH_CONVERT), &bslash;&n;&t;&t;&t;(int) INT_GET(dqp-&gt;q_core.d_icount, ARCH_CONVERT), &bslash;&n;&t;&t;&t;(int) dqp-&gt;q_nrefs);  } &bslash;&n;}
macro_line|#else
DECL|macro|XQM_LIST_PRINT
mdefine_line|#define XQM_LIST_PRINT(l, NXT, title) do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * Initialize the XQM structure.&n; * Note that there is not one quota manager per file system.&n; */
id|STATIC
r_struct
id|xfs_qm
op_star
DECL|function|xfs_Gqm_init
id|xfs_Gqm_init
c_func
(paren
r_void
)paren
(brace
id|xfs_qm_t
op_star
id|xqm
suffix:semicolon
r_int
id|hsize
comma
id|i
suffix:semicolon
id|xqm
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xfs_qm_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xqm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the dquot hash tables.&n;&t; */
id|hsize
op_assign
(paren
id|DQUOT_HASH_HEURISTIC
OL
id|XFS_QM_NCSIZE_THRESHOLD
)paren
ques
c_cond
id|XFS_QM_HASHSIZE_LOW
suffix:colon
id|XFS_QM_HASHSIZE_HIGH
suffix:semicolon
id|xqm-&gt;qm_dqhashmask
op_assign
id|hsize
op_minus
l_int|1
suffix:semicolon
id|xqm-&gt;qm_usr_dqhtable
op_assign
(paren
id|xfs_dqhash_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
id|hsize
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|xqm-&gt;qm_grp_dqhtable
op_assign
(paren
id|xfs_dqhash_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
id|hsize
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xqm-&gt;qm_usr_dqhtable
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xqm-&gt;qm_grp_dqhtable
op_ne
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_qm_list_init
c_func
(paren
op_amp
(paren
id|xqm-&gt;qm_usr_dqhtable
(braket
id|i
)braket
)paren
comma
l_string|&quot;uxdqh&quot;
comma
id|i
)paren
suffix:semicolon
id|xfs_qm_list_init
c_func
(paren
op_amp
(paren
id|xqm-&gt;qm_grp_dqhtable
(braket
id|i
)braket
)paren
comma
l_string|&quot;gxdqh&quot;
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Freelist of all dquots of all file systems&n;&t; */
id|xfs_qm_freelist_init
c_func
(paren
op_amp
(paren
id|xqm-&gt;qm_dqfreelist
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dquot zone. we register our own low-memory callback.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|qm_dqzone
)paren
(brace
id|xqm-&gt;qm_dqzone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_dquot_t
)paren
comma
l_string|&quot;xfs_dquots&quot;
)paren
suffix:semicolon
id|qm_dqzone
op_assign
id|xqm-&gt;qm_dqzone
suffix:semicolon
)brace
r_else
id|xqm-&gt;qm_dqzone
op_assign
id|qm_dqzone
suffix:semicolon
id|xfs_qm_shaker
op_assign
id|kmem_shake_register
c_func
(paren
id|xfs_qm_shake
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The t_dqinfo portion of transactions.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|qm_dqtrxzone
)paren
(brace
id|xqm-&gt;qm_dqtrxzone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_dquot_acct_t
)paren
comma
l_string|&quot;xfs_dqtrx&quot;
)paren
suffix:semicolon
id|qm_dqtrxzone
op_assign
id|xqm-&gt;qm_dqtrxzone
suffix:semicolon
)brace
r_else
id|xqm-&gt;qm_dqtrxzone
op_assign
id|qm_dqtrxzone
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|xqm-&gt;qm_totaldquots
comma
l_int|0
)paren
suffix:semicolon
id|xqm-&gt;qm_dqfree_ratio
op_assign
id|XFS_QM_DQFREE_RATIO
suffix:semicolon
id|xqm-&gt;qm_nrefs
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|mutex_init
c_func
(paren
op_amp
id|qcheck_lock
comma
id|MUTEX_DEFAULT
comma
l_string|&quot;qchk&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|xqm
suffix:semicolon
)brace
multiline_comment|/*&n; * Destroy the global quota manager when its reference count goes to zero.&n; */
r_void
DECL|function|xfs_qm_destroy
id|xfs_qm_destroy
c_func
(paren
r_struct
id|xfs_qm
op_star
id|xqm
)paren
(brace
r_int
id|hsize
comma
id|i
suffix:semicolon
id|ASSERT
c_func
(paren
id|xqm
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xqm-&gt;qm_nrefs
op_eq
l_int|0
)paren
suffix:semicolon
id|kmem_shake_deregister
c_func
(paren
id|xfs_qm_shaker
)paren
suffix:semicolon
id|hsize
op_assign
id|xqm-&gt;qm_dqhashmask
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_qm_list_destroy
c_func
(paren
op_amp
(paren
id|xqm-&gt;qm_usr_dqhtable
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|xfs_qm_list_destroy
c_func
(paren
op_amp
(paren
id|xqm-&gt;qm_grp_dqhtable
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|xqm-&gt;qm_usr_dqhtable
comma
id|hsize
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|xqm-&gt;qm_grp_dqhtable
comma
id|hsize
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
)paren
suffix:semicolon
id|xqm-&gt;qm_usr_dqhtable
op_assign
l_int|NULL
suffix:semicolon
id|xqm-&gt;qm_grp_dqhtable
op_assign
l_int|NULL
suffix:semicolon
id|xqm-&gt;qm_dqhashmask
op_assign
l_int|0
suffix:semicolon
id|xfs_qm_freelist_destroy
c_func
(paren
op_amp
(paren
id|xqm-&gt;qm_dqfreelist
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|mutex_destroy
c_func
(paren
op_amp
id|qcheck_lock
)paren
suffix:semicolon
macro_line|#endif
id|kmem_free
c_func
(paren
id|xqm
comma
r_sizeof
(paren
id|xfs_qm_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called at mount time to let XQM know that another file system is&n; * starting quotas. This isn&squot;t crucial information as the individual mount&n; * structures are pretty independent, but it helps the XQM keep a&n; * global view of what&squot;s going on.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_int
DECL|function|xfs_qm_hold_quotafs_ref
id|xfs_qm_hold_quotafs_ref
c_func
(paren
r_struct
id|xfs_mount
op_star
id|mp
)paren
(brace
multiline_comment|/*&n;&t; * Need to lock the xfs_Gqm structure for things like this. For example,&n;&t; * the structure could disappear between the entry to this routine and&n;&t; * a HOLD operation if not locked.&n;&t; */
id|XFS_QM_LOCK
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_Gqm
op_eq
l_int|NULL
)paren
id|xfs_Gqm
op_assign
id|xfs_Gqm_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We can keep a list of all filesystems with quotas mounted for&n;&t; * debugging and statistical purposes, but ...&n;&t; * Just take a reference and get out.&n;&t; */
id|XFS_QM_HOLD
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|XFS_QM_UNLOCK
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the reference that a filesystem took at mount time,&n; * so that we know when we need to destroy the entire quota manager.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_void
DECL|function|xfs_qm_rele_quotafs_ref
id|xfs_qm_rele_quotafs_ref
c_func
(paren
r_struct
id|xfs_mount
op_star
id|mp
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
comma
op_star
id|nextdqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_Gqm-&gt;qm_nrefs
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go thru the freelist and destroy all inactive dquots.&n;&t; */
id|xfs_qm_freelist_lock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dqp
op_assign
id|xfs_Gqm-&gt;qm_dqfreelist.qh_next
suffix:semicolon
id|dqp
op_ne
(paren
id|xfs_dquot_t
op_star
)paren
op_amp
(paren
id|xfs_Gqm-&gt;qm_dqfreelist
)paren
suffix:semicolon
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|nextdqp
op_assign
id|dqp-&gt;dq_flnext
suffix:semicolon
r_if
c_cond
(paren
id|dqp-&gt;dq_flags
op_amp
id|XFS_DQ_INACTIVE
)paren
(brace
id|ASSERT
c_func
(paren
id|dqp-&gt;q_mount
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;HL_PREVP
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;MPL_PREVP
op_eq
l_int|NULL
)paren
suffix:semicolon
id|XQM_FREELIST_REMOVE
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
id|dqp
op_assign
id|nextdqp
suffix:semicolon
)brace
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Destroy the entire XQM. If somebody mounts with quotaon, this&squot;ll&n;&t; * be restarted.&n;&t; */
id|XFS_QM_LOCK
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|XFS_QM_RELE
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_Gqm-&gt;qm_nrefs
op_eq
l_int|0
)paren
(brace
id|xfs_qm_destroy
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|xfs_Gqm
op_assign
l_int|NULL
suffix:semicolon
)brace
id|XFS_QM_UNLOCK
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called at mount time from xfs_mountfs to initialize the quotainfo&n; * structure and start the global quotamanager (xfs_Gqm) if it hasn&squot;t done&n; * so already.&t;Note that the superblock has not been read in yet.&n; */
r_void
DECL|function|xfs_qm_mount_quotainit
id|xfs_qm_mount_quotainit
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|flags
)paren
(brace
multiline_comment|/*&n;&t; * User or group quotas has to be on.&n;&t; */
id|ASSERT
c_func
(paren
id|flags
op_amp
(paren
id|XFSMNT_UQUOTA
op_or
id|XFSMNT_GQUOTA
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the flags in the mount structure. From this point&n;&t; * onwards we look at m_qflags to figure out if quotas&squot;s ON/OFF, etc.&n;&t; * Note that we enforce nothing if accounting is off.&n;&t; * ie.&t;XFSMNT_*QUOTA must be ON for XFSMNT_*QUOTAENF.&n;&t; * It isn&squot;t necessary to take the quotaoff lock to do this; this is&n;&t; * called from mount.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|XFSMNT_UQUOTA
)paren
(brace
id|mp-&gt;m_qflags
op_or_assign
(paren
id|XFS_UQUOTA_ACCT
op_or
id|XFS_UQUOTA_ACTIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFSMNT_UQUOTAENF
)paren
id|mp-&gt;m_qflags
op_or_assign
id|XFS_UQUOTA_ENFD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFSMNT_GQUOTA
)paren
(brace
id|mp-&gt;m_qflags
op_or_assign
(paren
id|XFS_GQUOTA_ACCT
op_or
id|XFS_GQUOTA_ACTIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFSMNT_GQUOTAENF
)paren
id|mp-&gt;m_qflags
op_or_assign
id|XFS_GQUOTA_ENFD
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Just destroy the quotainfo structure.&n; */
r_void
DECL|function|xfs_qm_unmount_quotadestroy
id|xfs_qm_unmount_quotadestroy
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
)paren
id|xfs_qm_destroy_quotainfo
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from xfs_mountfs to start quotas and initialize all&n; * necessary data structures like quotainfo.  This is also responsible for&n; * running a quotacheck as necessary.  We are guaranteed that the superblock&n; * is consistently read in at this point.&n; */
r_int
DECL|function|xfs_qm_mount_quotas
id|xfs_qm_mount_quotas
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|mfsi_flags
)paren
(brace
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|uint
id|sbf
suffix:semicolon
multiline_comment|/*&n;&t; * If a file system had quotas running earlier, but decided to&n;&t; * mount without -o quota/uquota/gquota options, revoke the&n;&t; * quotachecked license, and bail out.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
(paren
id|mp-&gt;m_sb.sb_qflags
op_amp
(paren
id|XFS_UQUOTA_ACCT
op_or
id|XFS_GQUOTA_ACCT
)paren
)paren
)paren
(brace
id|mp-&gt;m_qflags
op_assign
l_int|0
suffix:semicolon
r_goto
id|write_changes
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If quotas on realtime volumes is not supported, we disable&n;&t; * quotas immediately.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_sb.sb_rextents
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Cannot turn on quotas for realtime filesystem %s&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
id|mp-&gt;m_qflags
op_assign
l_int|0
suffix:semicolon
r_goto
id|write_changes
suffix:semicolon
)brace
macro_line|#if defined(DEBUG) &amp;&amp; defined(XFS_LOUD_RECOVERY)
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Attempting to turn on disk quotas.&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the quotainfo structure inside the mount struct, and&n;&t; * create quotainode(s), and change/rev superblock if necessary.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_init_quotainfo
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We must turn off quotas.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|mp-&gt;m_quotainfo
op_eq
l_int|NULL
)paren
suffix:semicolon
id|mp-&gt;m_qflags
op_assign
l_int|0
suffix:semicolon
r_goto
id|write_changes
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If any of the quotas are not consistent, do a quotacheck.&n;&t; */
r_if
c_cond
(paren
id|XFS_QM_NEED_QUOTACHECK
c_func
(paren
id|mp
)paren
op_logical_and
op_logical_neg
(paren
id|mfsi_flags
op_amp
id|XFS_MFSI_NO_QUOTACHECK
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Doing a quotacheck. Please wait.&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_quotacheck
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
multiline_comment|/* Quotacheck has failed and quotas have&n;&t;&t;&t; * been disabled.&n;&t;&t;&t; */
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Done quotacheck.&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
id|write_changes
suffix:colon
multiline_comment|/*&n;&t; * We actually don&squot;t have to acquire the SB_LOCK at all.&n;&t; * This can only be called from mount, and that&squot;s single threaded. XXX&n;&t; */
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|sbf
op_assign
id|mp-&gt;m_sb.sb_qflags
suffix:semicolon
id|mp-&gt;m_sb.sb_qflags
op_assign
id|mp-&gt;m_qflags
op_amp
id|XFS_MOUNT_QUOTA_ALL
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbf
op_ne
(paren
id|mp-&gt;m_qflags
op_amp
id|XFS_MOUNT_QUOTA_ALL
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_qm_write_sb_changes
c_func
(paren
id|mp
comma
id|XFS_SB_QFLAGS
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We could only have been turning quotas off.&n;&t;&t;&t; * We aren&squot;t in very good shape actually because&n;&t;&t;&t; * the incore structures are convinced that quotas are&n;&t;&t;&t; * off, but the on disk superblock doesn&squot;t know that !&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;XFS mount_quotas: Superblock update failed!&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;Failed to initialize disk quotas.&quot;
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from the vfsops layer.&n; */
r_int
DECL|function|xfs_qm_unmount_quotas
id|xfs_qm_unmount_quotas
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_inode_t
op_star
id|uqp
comma
op_star
id|gqp
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Release the dquots that root inode, et al might be holding,&n;&t; * before we flush quotas and blow away the quotainfo structure.&n;&t; */
id|ASSERT
c_func
(paren
id|mp-&gt;m_rootip
)paren
suffix:semicolon
id|xfs_qm_dqdetach
c_func
(paren
id|mp-&gt;m_rootip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rbmip
)paren
id|xfs_qm_dqdetach
c_func
(paren
id|mp-&gt;m_rbmip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rsumip
)paren
id|xfs_qm_dqdetach
c_func
(paren
id|mp-&gt;m_rsumip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush out the quota inodes.&n;&t; */
id|uqp
op_assign
id|gqp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
)paren
(brace
r_if
c_cond
(paren
(paren
id|uqp
op_assign
id|mp-&gt;m_quotainfo-&gt;qi_uquotaip
)paren
op_ne
l_int|NULL
)paren
(brace
id|xfs_ilock
c_func
(paren
id|uqp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|uqp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|uqp
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|uqp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_qm_unmount_quotas(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|gqp
op_assign
id|mp-&gt;m_quotainfo-&gt;qi_gquotaip
)paren
op_ne
l_int|NULL
)paren
(brace
id|xfs_ilock
c_func
(paren
id|gqp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|gqp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|gqp
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|gqp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_qm_unmount_quotas(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|uqp
)paren
(brace
id|XFS_PURGE_INODE
c_func
(paren
id|uqp
)paren
suffix:semicolon
id|mp-&gt;m_quotainfo-&gt;qi_uquotaip
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gqp
)paren
(brace
id|XFS_PURGE_INODE
c_func
(paren
id|gqp
)paren
suffix:semicolon
id|mp-&gt;m_quotainfo-&gt;qi_gquotaip
op_assign
l_int|NULL
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush all dquots of the given file system to disk. The dquots are&n; * _not_ purged from memory here, just their data written to disk.&n; */
r_int
DECL|function|xfs_qm_dqflush_all
id|xfs_qm_dqflush_all
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|flags
)paren
(brace
r_int
id|recl
suffix:semicolon
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
r_int
id|niters
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|niters
op_assign
l_int|0
suffix:semicolon
id|again
suffix:colon
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
id|FOREACH_DQUOT_IN_MP
c_func
(paren
id|dqp
comma
id|mp
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;FLUSHALL: DQDIRTY&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX a sentinel would be better */
id|recl
op_assign
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqflock_nowait
c_func
(paren
id|dqp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we can&squot;t grab the flush lock then check&n;&t;&t;&t; * to see if the dquot has been flushed delayed&n;&t;&t;&t; * write.  If so, grab its buffer and send it&n;&t;&t;&t; * out immediately.  We&squot;ll be able to acquire&n;&t;&t;&t; * the flush lock when the I/O completes.&n;&t;&t;&t; */
id|xfs_qm_dqflock_pushbuf_wait
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Let go of the mplist lock. We don&squot;t want to hold it&n;&t;&t; * across a disk write.&n;&t;&t; */
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_qm_dqflush
c_func
(paren
id|dqp
comma
id|flags
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recl
op_ne
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* XXX restart limit */
r_goto
id|again
suffix:semicolon
)brace
)brace
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* return ! busy */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the group dquot pointers the user dquots may be&n; * carrying around as a hint. mplist is locked on entry and exit.&n; */
id|STATIC
r_void
DECL|function|xfs_qm_detach_gdquots
id|xfs_qm_detach_gdquots
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
comma
op_star
id|gdqp
suffix:semicolon
r_int
id|nrecl
suffix:semicolon
id|again
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_QM_IS_MPLIST_LOCKED
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|dqp
op_assign
id|XFS_QI_MPLNEXT
c_func
(paren
id|mp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dqp
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|gdqp
op_assign
id|dqp-&gt;q_gdquot
)paren
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|dqp-&gt;q_gdquot
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gdqp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Can&squot;t hold the mplist lock across a dqput.&n;&t;&t;&t; * XXXmust convert to marker based iterations here.&n;&t;&t;&t; */
id|nrecl
op_assign
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_qm_dqput
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nrecl
op_ne
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
)paren
r_goto
id|again
suffix:semicolon
)brace
id|dqp
op_assign
id|dqp-&gt;MPL_NEXT
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Go through all the incore dquots of this file system and take them&n; * off the mplist and hashlist, if the dquot type matches the dqtype&n; * parameter. This is used when turning off quota accounting for&n; * users and/or groups, as well as when the filesystem is unmounting.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_dqpurge_int
id|xfs_qm_dqpurge_int
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|flags
)paren
multiline_comment|/* QUOTAOFF/UMOUNTING/UQUOTA/GQUOTA */
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|uint
id|dqtype
suffix:semicolon
r_int
id|nrecl
suffix:semicolon
id|xfs_dquot_t
op_star
id|nextdqp
suffix:semicolon
r_int
id|nmisses
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|dqtype
op_assign
(paren
id|flags
op_amp
id|XFS_QMOPT_UQUOTA
)paren
ques
c_cond
id|XFS_DQ_USER
suffix:colon
l_int|0
suffix:semicolon
id|dqtype
op_or_assign
(paren
id|flags
op_amp
id|XFS_QMOPT_GQUOTA
)paren
ques
c_cond
id|XFS_DQ_GROUP
suffix:colon
l_int|0
suffix:semicolon
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In the first pass through all incore dquots of this filesystem,&n;&t; * we release the group dquot pointers the user dquots may be&n;&t; * carrying around as a hint. We need to do this irrespective of&n;&t; * what&squot;s being turned off.&n;&t; */
id|xfs_qm_detach_gdquots
c_func
(paren
id|mp
)paren
suffix:semicolon
id|again
suffix:colon
id|nmisses
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_QM_IS_MPLIST_LOCKED
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to get rid of all of the unwanted dquots. The idea is to&n;&t; * get them off mplist and hashlist, but leave them on freelist.&n;&t; */
id|dqp
op_assign
id|XFS_QI_MPLNEXT
c_func
(paren
id|mp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dqp
)paren
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s OK to look at the type without taking dqlock here.&n;&t;&t; * We&squot;re holding the mplist lock here, and that&squot;s needed for&n;&t;&t; * a dqreclaim.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dqp-&gt;dq_flags
op_amp
id|dqtype
)paren
op_eq
l_int|0
)paren
(brace
id|dqp
op_assign
id|dqp-&gt;MPL_NEXT
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqhashlock_nowait
c_func
(paren
id|dqp
)paren
)paren
(brace
id|nrecl
op_assign
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
id|XFS_DQ_HASH_LOCK
c_func
(paren
id|dqp-&gt;q_hash
)paren
suffix:semicolon
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * XXXTheoretically, we can get into a very long&n;&t;&t;&t; * ping pong game here.&n;&t;&t;&t; * No one can be adding dquots to the mplist at&n;&t;&t;&t; * this point, but somebody might be taking things off.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|nrecl
op_ne
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
)paren
(brace
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|dqp-&gt;q_hash
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Take the dquot off the mplist and hashlist. It may remain on&n;&t;&t; * freelist in INACTIVE state.&n;&t;&t; */
id|nextdqp
op_assign
id|dqp-&gt;MPL_NEXT
suffix:semicolon
id|nmisses
op_add_assign
id|xfs_qm_dqpurge
c_func
(paren
id|dqp
comma
id|flags
)paren
suffix:semicolon
id|dqp
op_assign
id|nextdqp
suffix:semicolon
)brace
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|nmisses
suffix:semicolon
)brace
r_int
DECL|function|xfs_qm_dqpurge_all
id|xfs_qm_dqpurge_all
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|flags
)paren
(brace
r_int
id|ndquots
suffix:semicolon
multiline_comment|/*&n;&t; * Purge the dquot cache.&n;&t; * None of the dquots should really be busy at this point.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
)paren
(brace
r_while
c_loop
(paren
(paren
id|ndquots
op_assign
id|xfs_qm_dqpurge_int
c_func
(paren
id|mp
comma
id|flags
)paren
)paren
)paren
(brace
id|delay
c_func
(paren
id|ndquots
op_star
l_int|10
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_dqattach_one
id|xfs_qm_dqattach_one
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
id|uint
id|doalloc
comma
id|uint
id|dolock
comma
id|xfs_dquot_t
op_star
id|udqhint
comma
multiline_comment|/* hint */
id|xfs_dquot_t
op_star
op_star
id|IO_idqpp
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * See if we already have it in the inode itself. IO_idqpp is&n;&t; * &amp;i_udquot or &amp;i_gdquot. This made the code look weird, but&n;&t; * made the logic a lot simpler.&n;&t; */
r_if
c_cond
(paren
(paren
id|dqp
op_assign
op_star
id|IO_idqpp
)paren
)paren
(brace
r_if
c_cond
(paren
id|dolock
)paren
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQATTACH: found in ip&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * udqhint is the i_udquot field in inode, and is non-NULL only&n;&t; * when the type arg is XFS_DQ_GROUP. Its purpose is to save a&n;&t; * lookup by dqid (xfs_qm_dqget) by caching a group dquot inside&n;&t; * the user dquot.&n;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
id|udqhint
op_logical_or
id|type
op_eq
id|XFS_DQ_GROUP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udqhint
op_logical_and
op_logical_neg
id|dolock
)paren
id|xfs_dqlock
c_func
(paren
id|udqhint
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No need to take dqlock to look at the id.&n;&t; * The ID can&squot;t change until it gets reclaimed, and it won&squot;t&n;&t; * be reclaimed as long as we have a ref from inode and we hold&n;&t; * the ilock.&n;&t; */
r_if
c_cond
(paren
id|udqhint
op_logical_and
(paren
id|dqp
op_assign
id|udqhint-&gt;q_gdquot
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
op_eq
id|id
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|udqhint
)paren
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|XFS_DQHOLD
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_star
id|IO_idqpp
op_eq
l_int|NULL
)paren
suffix:semicolon
op_star
id|IO_idqpp
op_assign
id|dqp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dolock
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|udqhint
)paren
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We can&squot;t hold a dquot lock when we call the dqget code.&n;&t; * We&squot;ll deadlock in no time, because of (not conforming to)&n;&t; * lock ordering - the inodelock comes before any dquot lock,&n;&t; * and we may drop and reacquire the ilock in xfs_qm_dqget().&n;&t; */
r_if
c_cond
(paren
id|udqhint
)paren
id|xfs_dqunlock
c_func
(paren
id|udqhint
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the dquot from somewhere. This bumps the&n;&t; * reference count of dquot and returns it locked.&n;&t; * This can return ENOENT if dquot didn&squot;t exist on&n;&t; * disk and we didn&squot;t ask it to allocate;&n;&t; * ESRCH if quotas got turned off suddenly.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|ip-&gt;i_mount
comma
id|ip
comma
id|id
comma
id|type
comma
id|doalloc
op_or
id|XFS_QMOPT_DOWARN
comma
op_amp
id|dqp
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|udqhint
op_logical_and
id|dolock
)paren
id|xfs_dqlock
c_func
(paren
id|udqhint
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQATTACH: found by dqget&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dqget may have dropped and re-acquired the ilock, but it guarantees&n;&t; * that the dquot returned is the one that should go in the inode.&n;&t; */
op_star
id|IO_idqpp
op_assign
id|dqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dolock
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|udqhint
)paren
r_goto
id|done
suffix:semicolon
id|ASSERT
c_func
(paren
id|udqhint
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dolock
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqlock_nowait
c_func
(paren
id|udqhint
)paren
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|udqhint
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
id|done
suffix:colon
macro_line|#ifdef QUOTADEBUG
r_if
c_cond
(paren
id|udqhint
)paren
(brace
r_if
c_cond
(paren
id|dolock
)paren
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|udqhint
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|dolock
)paren
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a udquot and gdquot, attach a ptr to the group dquot in the&n; * udquot as a hint for future lookups. The idea sounds simple, but the&n; * execution isn&squot;t, because the udquot might have a group dquot attached&n; * already and getting rid of that gets us into lock ordering contraints.&n; * The process is complicated more by the fact that the dquots may or may not&n; * be locked on entry.&n; */
id|STATIC
r_void
DECL|function|xfs_qm_dqattach_grouphint
id|xfs_qm_dqattach_grouphint
c_func
(paren
id|xfs_dquot_t
op_star
id|udq
comma
id|xfs_dquot_t
op_star
id|gdq
comma
id|uint
id|locked
)paren
(brace
id|xfs_dquot_t
op_star
id|tmp
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
r_if
c_cond
(paren
id|locked
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|udq
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|gdq
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
id|xfs_dqlock
c_func
(paren
id|udq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|udq-&gt;q_gdquot
)paren
)paren
(brace
r_if
c_cond
(paren
id|tmp
op_eq
id|gdq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
id|xfs_dqunlock
c_func
(paren
id|udq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|udq-&gt;q_gdquot
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We can&squot;t keep any dqlocks when calling dqrele,&n;&t;&t; * because the freelist lock comes before dqlocks.&n;&t;&t; */
id|xfs_dqunlock
c_func
(paren
id|udq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|locked
)paren
id|xfs_dqunlock
c_func
(paren
id|gdq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we took a hard reference once upon a time in dqget,&n;&t;&t; * so give it back when the udquot no longer points at it&n;&t;&t; * dqput() does the unlocking of the dquot.&n;&t;&t; */
id|xfs_qm_dqrele
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|udq
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|gdq
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|udq
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|gdq
)paren
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|udq
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|gdq
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Somebody could have attached a gdquot here,&n;&t; * when we dropped the uqlock. If so, just do nothing.&n;&t; */
r_if
c_cond
(paren
id|udq-&gt;q_gdquot
op_eq
l_int|NULL
)paren
(brace
id|XFS_DQHOLD
c_func
(paren
id|gdq
)paren
suffix:semicolon
id|udq-&gt;q_gdquot
op_assign
id|gdq
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|locked
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|gdq
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|udq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Given a locked inode, attach dquot(s) to it, taking UQUOTAON / GQUOTAON&n; * in to account.&n; * If XFS_QMOPT_DQALLOC, the dquot(s) will be allocated if needed.&n; * If XFS_QMOPT_DQLOCK, the dquot(s) will be returned locked. This option pretty&n; * much made this code a complete mess, but it has been pretty useful.&n; * If XFS_QMOPT_ILOCKED, then inode sent is already locked EXCL.&n; * Inode may get unlocked and relocked in here, and the caller must deal with&n; * the consequences.&n; */
r_int
DECL|function|xfs_qm_dqattach
id|xfs_qm_dqattach
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|flags
)paren
(brace
id|xfs_mount_t
op_star
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|uint
id|nquotas
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|XFS_NOT_DQATTACHED
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
op_logical_or
(paren
id|ip-&gt;i_ino
op_eq
id|mp-&gt;m_sb.sb_uquotino
)paren
op_logical_or
(paren
id|ip-&gt;i_ino
op_eq
id|mp-&gt;m_sb.sb_gquotino
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|XFS_QMOPT_ILOCKED
)paren
op_eq
l_int|0
op_logical_or
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_QMOPT_ILOCKED
)paren
)paren
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|error
op_assign
id|xfs_qm_dqattach_one
c_func
(paren
id|ip
comma
id|ip-&gt;i_d.di_uid
comma
id|XFS_DQ_USER
comma
id|flags
op_amp
id|XFS_QMOPT_DQALLOC
comma
id|flags
op_amp
id|XFS_QMOPT_DQLOCK
comma
l_int|NULL
comma
op_amp
id|ip-&gt;i_udquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|done
suffix:semicolon
id|nquotas
op_increment
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|error
op_assign
id|xfs_qm_dqattach_one
c_func
(paren
id|ip
comma
id|ip-&gt;i_d.di_gid
comma
id|XFS_DQ_GROUP
comma
id|flags
op_amp
id|XFS_QMOPT_DQALLOC
comma
id|flags
op_amp
id|XFS_QMOPT_DQLOCK
comma
id|ip-&gt;i_udquot
comma
op_amp
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Don&squot;t worry about the udquot that we may have&n;&t;&t; * attached above. It&squot;ll get detached, if not already.&n;&t;&t; */
r_if
c_cond
(paren
id|error
)paren
r_goto
id|done
suffix:semicolon
id|nquotas
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attach this group quota to the user quota as a hint.&n;&t; * This WON&squot;T, in general, result in a thrash.&n;&t; */
r_if
c_cond
(paren
id|nquotas
op_eq
l_int|2
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We may or may not have the i_udquot locked at this point,&n;&t;&t; * but this check is OK since we don&squot;t depend on the i_gdquot to&n;&t;&t; * be accurate 100% all the time. It is just a hint, and this&n;&t;&t; * will succeed in general.&n;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_udquot-&gt;q_gdquot
op_eq
id|ip-&gt;i_gdquot
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Attach i_gdquot to the gdquot hint inside the i_udquot.&n;&t;&t; */
id|xfs_qm_dqattach_grouphint
c_func
(paren
id|ip-&gt;i_udquot
comma
id|ip-&gt;i_gdquot
comma
id|flags
op_amp
id|XFS_QMOPT_DQLOCK
)paren
suffix:semicolon
)brace
id|done
suffix:colon
macro_line|#ifdef QUOTADEBUG
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_udquot
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DQLOCK
)paren
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|ip-&gt;i_udquot
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_gdquot
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DQLOCK
)paren
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|ip-&gt;i_gdquot
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_QMOPT_ILOCKED
)paren
)paren
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
r_else
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release dquots (and their references) if any.&n; * The inode should be locked EXCL except when this&squot;s called by&n; * xfs_ireclaim.&n; */
r_void
DECL|function|xfs_qm_dqdetach
id|xfs_qm_dqdetach
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ip-&gt;i_udquot
op_logical_or
id|ip-&gt;i_gdquot
)paren
)paren
r_return
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_ino
op_ne
id|ip-&gt;i_mount-&gt;m_sb.sb_uquotino
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_ino
op_ne
id|ip-&gt;i_mount-&gt;m_sb.sb_gquotino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_udquot
)paren
id|xfs_dqtrace_entry_ino
c_func
(paren
id|ip-&gt;i_udquot
comma
l_string|&quot;DQDETTACH&quot;
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_udquot
)paren
(brace
id|xfs_qm_dqrele
c_func
(paren
id|ip-&gt;i_udquot
)paren
suffix:semicolon
id|ip-&gt;i_udquot
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_gdquot
)paren
(brace
id|xfs_qm_dqrele
c_func
(paren
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
id|ip-&gt;i_gdquot
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called by VFS_SYNC and flags arg determines the caller,&n; * and its motives, as done in xfs_sync.&n; *&n; * vfs_sync: SYNC_FSDATA|SYNC_ATTR|SYNC_BDFLUSH 0x31&n; * syscall sync: SYNC_FSDATA|SYNC_ATTR|SYNC_DELWRI 0x25&n; * umountroot : SYNC_WAIT | SYNC_CLOSE | SYNC_ATTR | SYNC_FSDATA&n; */
r_int
DECL|function|xfs_qm_sync
id|xfs_qm_sync
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|flags
)paren
(brace
r_int
id|recl
comma
id|restarts
suffix:semicolon
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|uint
id|flush_flags
suffix:semicolon
id|boolean_t
id|nowait
suffix:semicolon
r_int
id|error
suffix:semicolon
id|restarts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We won&squot;t block unless we are asked to.&n;&t; */
id|nowait
op_assign
(paren
id|boolean_t
)paren
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
op_logical_or
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|again
suffix:colon
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dqpurge_all() also takes the mplist lock and iterate thru all dquots&n;&t; * in quotaoff. However, if the QUOTA_ACTIVE bits are not cleared&n;&t; * when we have the mplist lock, we know that dquots will be consistent&n;&t; * as long as we have it locked.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|FOREACH_DQUOT_IN_MP
c_func
(paren
id|dqp
comma
id|mp
)paren
(brace
multiline_comment|/*&n;&t;&t; * If this is vfs_sync calling, then skip the dquots that&n;&t;&t; * don&squot;t &squot;seem&squot; to be dirty. ie. don&squot;t acquire dqlock.&n;&t;&t; * This is very similar to what xfs_sync does with inodes.&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nowait
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try to acquire the dquot lock. We are NOT out of&n;&t;&t;&t; * lock order, but we just don&squot;t want to wait for this&n;&t;&t;&t; * lock, unless somebody wanted us to.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqlock_nowait
c_func
(paren
id|dqp
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
(brace
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Now, find out for sure if this dquot is dirty or not.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* XXX a sentinel would be better */
id|recl
op_assign
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqflock_nowait
c_func
(paren
id|dqp
)paren
)paren
(brace
r_if
c_cond
(paren
id|nowait
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we can&squot;t grab the flush lock then if the caller&n;&t;&t;&t; * really wanted us to give this our best shot,&n;&t;&t;&t; * see if we can give a push to the buffer before we wait&n;&t;&t;&t; * on the flush lock. At this point, we know that&n;&t;&t;&t; * eventhough the dquot is being flushed,&n;&t;&t;&t; * it has (new) dirty data.&n;&t;&t;&t; */
id|xfs_qm_dqflock_pushbuf_wait
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Let go of the mplist lock. We don&squot;t want to hold it&n;&t;&t; * across a disk write&n;&t;&t; */
id|flush_flags
op_assign
(paren
id|nowait
)paren
ques
c_cond
id|XFS_QMOPT_DELWRI
suffix:colon
id|XFS_QMOPT_SYNC
suffix:semicolon
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;XQM_SYNC: DQFLUSH&quot;
)paren
suffix:semicolon
id|error
op_assign
id|xfs_qm_dqflush
c_func
(paren
id|dqp
comma
id|flush_flags
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_and
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Need to prevent umount failure */
r_else
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recl
op_ne
id|XFS_QI_MPLRECLAIMS
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
op_increment
id|restarts
op_ge
id|XFS_QM_SYNC_MAX_RESTARTS
)paren
r_break
suffix:semicolon
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This initializes all the quota information that&squot;s kept in the&n; * mount structure&n; */
r_int
DECL|function|xfs_qm_init_quotainfo
id|xfs_qm_init_quotainfo
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_quotainfo_t
op_star
id|qinf
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Tell XQM that we exist as soon as possible.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_hold_quotafs_ref
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|qinf
op_assign
id|mp-&gt;m_quotainfo
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xfs_quotainfo_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if quotainodes are setup, and if not, allocate them,&n;&t; * and change the superblock accordingly.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_init_quotainos
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
id|kmem_free
c_func
(paren
id|qinf
comma
r_sizeof
(paren
id|xfs_quotainfo_t
)paren
)paren
suffix:semicolon
id|mp-&gt;m_quotainfo
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|spinlock_init
c_func
(paren
op_amp
id|qinf-&gt;qi_pinlock
comma
l_string|&quot;xfs_qinf_pin&quot;
)paren
suffix:semicolon
id|xfs_qm_list_init
c_func
(paren
op_amp
id|qinf-&gt;qi_dqlist
comma
l_string|&quot;mpdqlist&quot;
comma
l_int|0
)paren
suffix:semicolon
id|qinf-&gt;qi_dqreclaims
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* mutex used to serialize quotaoffs */
id|mutex_init
c_func
(paren
op_amp
id|qinf-&gt;qi_quotaofflock
comma
id|MUTEX_DEFAULT
comma
l_string|&quot;qoff&quot;
)paren
suffix:semicolon
multiline_comment|/* Precalc some constants */
id|qinf-&gt;qi_dqchunklen
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|XFS_DQUOT_CLUSTER_SIZE_FSB
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|qinf-&gt;qi_dqchunklen
)paren
suffix:semicolon
id|qinf-&gt;qi_dqperchunk
op_assign
id|BBTOB
c_func
(paren
id|qinf-&gt;qi_dqchunklen
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|qinf-&gt;qi_dqperchunk
comma
r_sizeof
(paren
id|xfs_dqblk_t
)paren
)paren
suffix:semicolon
id|mp-&gt;m_qflags
op_or_assign
(paren
id|mp-&gt;m_sb.sb_qflags
op_amp
id|XFS_ALL_QUOTA_CHKD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We try to get the limits from the superuser&squot;s limits fields.&n;&t; * This is quite hacky, but it is standard quota practice.&n;&t; * We look at the USR dquot with id == 0 first, but if user quotas&n;&t; * are not enabled we goto the GRP dquot with id == 0.&n;&t; * We don&squot;t really care to keep separate default limits for user&n;&t; * and group quotas, at least not at this point.&n;&t; */
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|mp
comma
l_int|NULL
comma
(paren
id|xfs_dqid_t
)paren
l_int|0
comma
(paren
id|XFS_IS_UQUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
ques
c_cond
id|XFS_DQ_USER
suffix:colon
id|XFS_DQ_GROUP
comma
id|XFS_QMOPT_DQSUSER
op_or
id|XFS_QMOPT_DOWARN
comma
op_amp
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|xfs_disk_dquot_t
op_star
id|ddqp
op_assign
op_amp
id|dqp-&gt;q_core
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The warnings and timers set the grace period given to&n;&t;&t; * a user or group before he or she can not perform any&n;&t;&t; * more writing. If it is zero, a default is used.&n;&t;&t; */
id|qinf-&gt;qi_btimelimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_btimer
comma
id|ARCH_CONVERT
)paren
ques
c_cond
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_btimer
comma
id|ARCH_CONVERT
)paren
suffix:colon
id|XFS_QM_BTIMELIMIT
suffix:semicolon
id|qinf-&gt;qi_itimelimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_itimer
comma
id|ARCH_CONVERT
)paren
ques
c_cond
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_itimer
comma
id|ARCH_CONVERT
)paren
suffix:colon
id|XFS_QM_ITIMELIMIT
suffix:semicolon
id|qinf-&gt;qi_rtbtimelimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_rtbtimer
comma
id|ARCH_CONVERT
)paren
ques
c_cond
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_rtbtimer
comma
id|ARCH_CONVERT
)paren
suffix:colon
id|XFS_QM_RTBTIMELIMIT
suffix:semicolon
id|qinf-&gt;qi_bwarnlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_bwarns
comma
id|ARCH_CONVERT
)paren
ques
c_cond
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_bwarns
comma
id|ARCH_CONVERT
)paren
suffix:colon
id|XFS_QM_BWARNLIMIT
suffix:semicolon
id|qinf-&gt;qi_iwarnlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_iwarns
comma
id|ARCH_CONVERT
)paren
ques
c_cond
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_iwarns
comma
id|ARCH_CONVERT
)paren
suffix:colon
id|XFS_QM_IWARNLIMIT
suffix:semicolon
id|qinf-&gt;qi_bhardlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|qinf-&gt;qi_bsoftlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|qinf-&gt;qi_ihardlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|qinf-&gt;qi_isoftlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|qinf-&gt;qi_rtbhardlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_rtb_hardlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|qinf-&gt;qi_rtbsoftlimit
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_rtb_softlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We sent the XFS_QMOPT_DQSUSER flag to dqget because&n;&t;&t; * we don&squot;t want this dquot cached. We haven&squot;t done a&n;&t;&t; * quotacheck yet, and quotacheck doesn&squot;t like incore dquots.&n;&t;&t; */
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
r_else
(brace
id|qinf-&gt;qi_btimelimit
op_assign
id|XFS_QM_BTIMELIMIT
suffix:semicolon
id|qinf-&gt;qi_itimelimit
op_assign
id|XFS_QM_ITIMELIMIT
suffix:semicolon
id|qinf-&gt;qi_rtbtimelimit
op_assign
id|XFS_QM_RTBTIMELIMIT
suffix:semicolon
id|qinf-&gt;qi_bwarnlimit
op_assign
id|XFS_QM_BWARNLIMIT
suffix:semicolon
id|qinf-&gt;qi_iwarnlimit
op_assign
id|XFS_QM_IWARNLIMIT
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Gets called when unmounting a filesystem or when all quotas get&n; * turned off.&n; * This purges the quota inodes, destroys locks and frees itself.&n; */
r_void
DECL|function|xfs_qm_destroy_quotainfo
id|xfs_qm_destroy_quotainfo
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_quotainfo_t
op_star
id|qi
suffix:semicolon
id|qi
op_assign
id|mp-&gt;m_quotainfo
suffix:semicolon
id|ASSERT
c_func
(paren
id|qi
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_Gqm
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Release the reference that XQM kept, so that we know&n;&t; * when the XQM structure should be freed. We cannot assume&n;&t; * that xfs_Gqm is non-null after this point.&n;&t; */
id|xfs_qm_rele_quotafs_ref
c_func
(paren
id|mp
)paren
suffix:semicolon
id|spinlock_destroy
c_func
(paren
op_amp
id|qi-&gt;qi_pinlock
)paren
suffix:semicolon
id|xfs_qm_list_destroy
c_func
(paren
op_amp
id|qi-&gt;qi_dqlist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qi-&gt;qi_uquotaip
)paren
(brace
id|XFS_PURGE_INODE
c_func
(paren
id|qi-&gt;qi_uquotaip
)paren
suffix:semicolon
id|qi-&gt;qi_uquotaip
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* paranoia */
)brace
r_if
c_cond
(paren
id|qi-&gt;qi_gquotaip
)paren
(brace
id|XFS_PURGE_INODE
c_func
(paren
id|qi-&gt;qi_gquotaip
)paren
suffix:semicolon
id|qi-&gt;qi_gquotaip
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mutex_destroy
c_func
(paren
op_amp
id|qi-&gt;qi_quotaofflock
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|qi
comma
r_sizeof
(paren
id|xfs_quotainfo_t
)paren
)paren
suffix:semicolon
id|mp-&gt;m_quotainfo
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* ------------------- PRIVATE STATIC FUNCTIONS ----------------------- */
multiline_comment|/* ARGSUSED */
id|STATIC
r_void
DECL|function|xfs_qm_list_init
id|xfs_qm_list_init
c_func
(paren
id|xfs_dqlist_t
op_star
id|list
comma
r_char
op_star
id|str
comma
r_int
id|n
)paren
(brace
id|mutex_init
c_func
(paren
op_amp
id|list-&gt;qh_lock
comma
id|MUTEX_DEFAULT
comma
id|str
)paren
suffix:semicolon
id|list-&gt;qh_next
op_assign
l_int|NULL
suffix:semicolon
id|list-&gt;qh_version
op_assign
l_int|0
suffix:semicolon
id|list-&gt;qh_nelems
op_assign
l_int|0
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_qm_list_destroy
id|xfs_qm_list_destroy
c_func
(paren
id|xfs_dqlist_t
op_star
id|list
)paren
(brace
id|mutex_destroy
c_func
(paren
op_amp
(paren
id|list-&gt;qh_lock
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Stripped down version of dqattach. This doesn&squot;t attach, or even look at the&n; * dquots attached to the inode. The rationale is that there won&squot;t be any&n; * attached at the time this is called from quotacheck.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_dqget_noattach
id|xfs_qm_dqget_noattach
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dquot_t
op_star
op_star
id|O_udqpp
comma
id|xfs_dquot_t
op_star
op_star
id|O_gdqpp
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_dquot_t
op_star
id|udqp
comma
op_star
id|gdqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|udqp
op_assign
l_int|NULL
suffix:semicolon
id|gdqp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We want the dquot allocated if it doesn&squot;t exist.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|mp
comma
id|ip
comma
id|ip-&gt;i_d.di_uid
comma
id|XFS_DQ_USER
comma
id|XFS_QMOPT_DQALLOC
op_or
id|XFS_QMOPT_DOWARN
comma
op_amp
id|udqp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Shouldn&squot;t be able to turn off quotas here.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|error
op_ne
id|ESRCH
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOENT
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|udqp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
op_eq
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udqp
)paren
id|xfs_dqunlock
c_func
(paren
id|udqp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|mp
comma
id|ip
comma
id|ip-&gt;i_d.di_gid
comma
id|XFS_DQ_GROUP
comma
id|XFS_QMOPT_DQALLOC
op_or
id|XFS_QMOPT_DOWARN
comma
op_amp
id|gdqp
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|udqp
)paren
id|xfs_qm_dqrele
c_func
(paren
id|udqp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|ESRCH
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOENT
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|gdqp
)paren
suffix:semicolon
multiline_comment|/* Reacquire the locks in the right order */
r_if
c_cond
(paren
id|udqp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqlock_nowait
c_func
(paren
id|udqp
)paren
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|udqp
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|gdqp
)paren
suffix:semicolon
)brace
)brace
)brace
op_star
id|O_udqpp
op_assign
id|udqp
suffix:semicolon
op_star
id|O_gdqpp
op_assign
id|gdqp
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
r_if
c_cond
(paren
id|udqp
)paren
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|udqp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gdqp
)paren
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|gdqp
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an inode and return with a reference already taken, but unlocked&n; * This is how we create quota inodes&n; */
id|STATIC
r_int
DECL|function|xfs_qm_qino_alloc
id|xfs_qm_qino_alloc
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_inode_t
op_star
op_star
id|ip
comma
id|__int64_t
id|sbfields
comma
id|uint
id|flags
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|cred_t
id|zerocr
suffix:semicolon
r_int
id|committed
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_QM_QINOCREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|XFS_QM_QINOCREATE_SPACE_RES
c_func
(paren
id|mp
)paren
comma
id|XFS_CREATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_CREATE_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|zerocr
comma
l_int|0
comma
r_sizeof
(paren
id|zerocr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir_ialloc
c_func
(paren
op_amp
id|tp
comma
id|mp-&gt;m_rootip
comma
id|S_IFREG
comma
l_int|1
comma
l_int|0
comma
op_amp
id|zerocr
comma
l_int|0
comma
l_int|1
comma
id|ip
comma
op_amp
id|committed
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Keep an extra reference to this quota inode. This inode is&n;&t; * locked exclusively and joined to the transaction already.&n;&t; */
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
op_star
id|ip
)paren
)paren
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|XFS_ITOV
c_func
(paren
(paren
op_star
id|ip
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make the changes in the superblock, and log those too.&n;&t; * sbfields arg may contain fields other than *QUOTINO;&n;&t; * VERSIONNUM for example.&n;&t; */
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_SBVERSION
)paren
(brace
macro_line|#if defined(DEBUG) &amp;&amp; defined(XFS_LOUD_RECOVERY)
r_int
id|oldv
op_assign
id|mp-&gt;m_sb.sb_versionnum
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_SB_VERSION_HASQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|sbfields
op_amp
(paren
id|XFS_SB_VERSIONNUM
op_or
id|XFS_SB_UQUOTINO
op_or
id|XFS_SB_GQUOTINO
op_or
id|XFS_SB_QFLAGS
)paren
)paren
op_eq
(paren
id|XFS_SB_VERSIONNUM
op_or
id|XFS_SB_UQUOTINO
op_or
id|XFS_SB_GQUOTINO
op_or
id|XFS_SB_QFLAGS
)paren
)paren
suffix:semicolon
id|XFS_SB_VERSION_ADDQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
suffix:semicolon
id|mp-&gt;m_sb.sb_uquotino
op_assign
id|NULLFSINO
suffix:semicolon
id|mp-&gt;m_sb.sb_gquotino
op_assign
id|NULLFSINO
suffix:semicolon
multiline_comment|/* qflags will get updated _after_ quotacheck */
id|mp-&gt;m_sb.sb_qflags
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(DEBUG) &amp;&amp; defined(XFS_LOUD_RECOVERY)
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Old superblock version %x, converting to %x.&quot;
comma
id|oldv
comma
id|mp-&gt;m_sb.sb_versionnum
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_UQUOTA
)paren
id|mp-&gt;m_sb.sb_uquotino
op_assign
(paren
op_star
id|ip
)paren
op_member_access_from_pointer
id|i_ino
suffix:semicolon
r_else
id|mp-&gt;m_sb.sb_gquotino
op_assign
(paren
op_star
id|ip
)paren
op_member_access_from_pointer
id|i_ino
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|xfs_mod_sb
c_func
(paren
id|tp
comma
id|sbfields
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;XFS qino_alloc failed!&quot;
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_reset_dqcounts
id|xfs_qm_reset_dqcounts
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
)paren
(brace
id|xfs_disk_dquot_t
op_star
id|ddq
suffix:semicolon
r_int
id|j
suffix:semicolon
id|xfs_buftrace
c_func
(paren
l_string|&quot;RESET DQUOTS&quot;
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset all counters and timers. They&squot;ll be&n;&t; * started afresh by xfs_qm_quotacheck.&n;&t; */
macro_line|#ifdef DEBUG
id|j
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|XFS_DQUOT_CLUSTER_SIZE_FSB
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|j
comma
r_sizeof
(paren
id|xfs_dqblk_t
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
op_eq
id|j
)paren
suffix:semicolon
macro_line|#endif
id|ddq
op_assign
(paren
id|xfs_disk_dquot_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do a sanity check, and if needed, repair the dqblk. Don&squot;t&n;&t;&t; * output any warnings because it&squot;s perfectly possible to&n;&t;&t; * find unitialized dquot blks. See comment in xfs_qm_dqcheck.&n;&t;&t; */
(paren
r_void
)paren
id|xfs_qm_dqcheck
c_func
(paren
id|ddq
comma
id|id
op_plus
id|j
comma
id|type
comma
id|XFS_QMOPT_DQREPAIR
comma
l_string|&quot;xfs_quotacheck&quot;
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_bcount
comma
id|ARCH_CONVERT
comma
l_int|0ULL
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_icount
comma
id|ARCH_CONVERT
comma
l_int|0ULL
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_rtbcount
comma
id|ARCH_CONVERT
comma
l_int|0ULL
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_btimer
comma
id|ARCH_CONVERT
comma
(paren
id|time_t
)paren
l_int|0
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_itimer
comma
id|ARCH_CONVERT
comma
(paren
id|time_t
)paren
l_int|0
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_bwarns
comma
id|ARCH_CONVERT
comma
l_int|0UL
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_iwarns
comma
id|ARCH_CONVERT
comma
l_int|0UL
)paren
suffix:semicolon
id|ddq
op_assign
(paren
id|xfs_disk_dquot_t
op_star
)paren
(paren
(paren
id|xfs_dqblk_t
op_star
)paren
id|ddq
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_dqiter_bufs
id|xfs_qm_dqiter_bufs
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|firstid
comma
id|xfs_fsblock_t
id|bno
comma
id|xfs_filblks_t
id|blkcnt
comma
id|uint
id|flags
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|notcommitted
suffix:semicolon
r_int
id|incr
suffix:semicolon
id|ASSERT
c_func
(paren
id|blkcnt
OG
l_int|0
)paren
suffix:semicolon
id|notcommitted
op_assign
l_int|0
suffix:semicolon
id|incr
op_assign
(paren
id|blkcnt
OG
id|XFS_QM_MAX_DQCLUSTER_LOGSZ
)paren
ques
c_cond
id|XFS_QM_MAX_DQCLUSTER_LOGSZ
suffix:colon
id|blkcnt
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Blkcnt arg can be a very big number, and might even be&n;&t; * larger than the log itself. So, we have to break it up into&n;&t; * manageable-sized transactions.&n;&t; * Note that we don&squot;t start a permanent transaction here; we might&n;&t; * not be able to get a log reservation for the whole thing up front,&n;&t; * and we don&squot;t really care to either, because we just discard&n;&t; * everything if we were to crash in the middle of this loop.&n;&t; */
r_while
c_loop
(paren
id|blkcnt
op_decrement
)paren
(brace
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|mp-&gt;m_ddev_targp
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|bno
)paren
comma
(paren
r_int
)paren
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
(paren
r_void
)paren
id|xfs_qm_reset_dqcounts
c_func
(paren
id|mp
comma
id|bp
comma
id|firstid
comma
id|flags
op_amp
id|XFS_QMOPT_UQUOTA
ques
c_cond
id|XFS_DQ_USER
suffix:colon
id|XFS_DQ_GROUP
)paren
suffix:semicolon
id|xfs_bdwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * goto the next block.&n;&t;&t; */
id|bno
op_increment
suffix:semicolon
id|firstid
op_add_assign
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Iterate over all allocated USR/GRP dquots in the system, calling a&n; * caller supplied function for every chunk of dquots that we find.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_dqiterate
id|xfs_qm_dqiterate
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_inode_t
op_star
id|qip
comma
id|uint
id|flags
)paren
(brace
id|xfs_bmbt_irec_t
op_star
id|map
suffix:semicolon
r_int
id|i
comma
id|nmaps
suffix:semicolon
multiline_comment|/* number of map entries */
r_int
id|error
suffix:semicolon
multiline_comment|/* return value */
id|xfs_fileoff_t
id|lblkno
suffix:semicolon
id|xfs_filblks_t
id|maxlblkcnt
suffix:semicolon
id|xfs_dqid_t
id|firstid
suffix:semicolon
id|xfs_fsblock_t
id|rablkno
suffix:semicolon
id|xfs_filblks_t
id|rablkcnt
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * This looks racey, but we can&squot;t keep an inode lock across a&n;&t; * trans_reserve. But, this gets called during quotacheck, and that&n;&t; * happens only at mount time which is single threaded.&n;&t; */
r_if
c_cond
(paren
id|qip-&gt;i_d.di_nblocks
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|map
op_assign
id|kmem_alloc
c_func
(paren
id|XFS_DQITER_MAP_SIZE
op_star
r_sizeof
(paren
op_star
id|map
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|lblkno
op_assign
l_int|0
suffix:semicolon
id|maxlblkcnt
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|XFS_MAXIOFFSET
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_do
(brace
id|nmaps
op_assign
id|XFS_DQITER_MAP_SIZE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We aren&squot;t changing the inode itself. Just changing&n;&t;&t; * some of its data. No new blocks are added here, and&n;&t;&t; * the inode is never added to the transaction.&n;&t;&t; */
id|xfs_ilock
c_func
(paren
id|qip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|qip
comma
id|lblkno
comma
id|maxlblkcnt
op_minus
id|lblkno
comma
id|XFS_BMAPI_METADATA
comma
l_int|NULL
comma
l_int|0
comma
id|map
comma
op_amp
id|nmaps
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|qip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
id|ASSERT
c_func
(paren
id|nmaps
op_le
id|XFS_DQITER_MAP_SIZE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nmaps
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|map
(braket
id|i
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|lblkno
op_add_assign
id|map
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
r_if
c_cond
(paren
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
r_continue
suffix:semicolon
id|firstid
op_assign
(paren
id|xfs_dqid_t
)paren
id|map
(braket
id|i
)braket
dot
id|br_startoff
op_star
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Do a read-ahead on the next extent.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
OL
id|nmaps
)paren
op_logical_and
(paren
id|map
(braket
id|i
op_plus
l_int|1
)braket
dot
id|br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
)paren
(brace
id|rablkcnt
op_assign
id|map
(braket
id|i
op_plus
l_int|1
)braket
dot
id|br_blockcount
suffix:semicolon
id|rablkno
op_assign
id|map
(braket
id|i
op_plus
l_int|1
)braket
dot
id|br_startblock
suffix:semicolon
r_while
c_loop
(paren
id|rablkcnt
op_decrement
)paren
(brace
id|xfs_baread
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|rablkno
)paren
comma
(paren
r_int
)paren
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|rablkno
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Iterate thru all the blks in the extent and&n;&t;&t;&t; * reset the counters of all the dquots inside them.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqiter_bufs
c_func
(paren
id|mp
comma
id|firstid
comma
id|map
(braket
id|i
)braket
dot
id|br_startblock
comma
id|map
(braket
id|i
)braket
dot
id|br_blockcount
comma
id|flags
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nmaps
OG
l_int|0
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|map
comma
id|XFS_DQITER_MAP_SIZE
op_star
r_sizeof
(paren
op_star
id|map
)paren
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by dqusage_adjust in doing a quotacheck.&n; * Given the inode, and a dquot (either USR or GRP, doesn&squot;t matter),&n; * this updates its incore copy as well as the buffer copy. This is&n; * so that once the quotacheck is done, we can just log all the buffers,&n; * as opposed to logging numerous updates to individual dquots.&n; */
id|STATIC
r_void
DECL|function|xfs_qm_quotacheck_dqadjust
id|xfs_qm_quotacheck_dqadjust
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
comma
id|xfs_qcnt_t
id|nblks
comma
id|xfs_qcnt_t
id|rtblks
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;QCHECK DQADJUST&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the inode count and the block count to reflect this inode&squot;s&n;&t; * resource usage.&n;&t; */
id|INT_MOD
c_func
(paren
id|dqp-&gt;q_core.d_icount
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|dqp-&gt;q_res_icount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nblks
)paren
(brace
id|INT_MOD
c_func
(paren
id|dqp-&gt;q_core.d_bcount
comma
id|ARCH_CONVERT
comma
id|nblks
)paren
suffix:semicolon
id|dqp-&gt;q_res_bcount
op_add_assign
id|nblks
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtblks
)paren
(brace
id|INT_MOD
c_func
(paren
id|dqp-&gt;q_core.d_rtbcount
comma
id|ARCH_CONVERT
comma
id|rtblks
)paren
suffix:semicolon
id|dqp-&gt;q_res_rtbcount
op_add_assign
id|rtblks
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set default limits, adjust timers (since we changed usages)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_SUSER_DQUOT
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_qm_adjust_dqlimits
c_func
(paren
id|dqp-&gt;q_mount
comma
op_amp
id|dqp-&gt;q_core
)paren
suffix:semicolon
id|xfs_qm_adjust_dqtimers
c_func
(paren
id|dqp-&gt;q_mount
comma
op_amp
id|dqp-&gt;q_core
)paren
suffix:semicolon
)brace
id|dqp-&gt;dq_flags
op_or_assign
id|XFS_DQ_DIRTY
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_get_rtblks
id|xfs_qm_get_rtblks
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_qcnt_t
op_star
id|O_rtblks
)paren
(brace
id|xfs_filblks_t
id|rtblks
suffix:semicolon
multiline_comment|/* total rt blks */
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
multiline_comment|/* inode fork pointer */
id|xfs_extnum_t
id|nextents
suffix:semicolon
multiline_comment|/* number of extent entries */
id|xfs_bmbt_rec_t
op_star
id|base
suffix:semicolon
multiline_comment|/* base of extent array */
id|xfs_bmbt_rec_t
op_star
id|ep
suffix:semicolon
multiline_comment|/* pointer to an extent entry */
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_REALTIME_INODE
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|ifp
op_assign
id|XFS_IFORK_PTR
c_func
(paren
id|ip
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFEXTENTS
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iread_extents
c_func
(paren
l_int|NULL
comma
id|ip
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|rtblks
op_assign
l_int|0
suffix:semicolon
id|nextents
op_assign
id|ifp-&gt;if_bytes
op_div
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
suffix:semicolon
id|base
op_assign
op_amp
id|ifp-&gt;if_u1.if_extents
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|ep
op_assign
id|base
suffix:semicolon
id|ep
OL
op_amp
id|base
(braket
id|nextents
)braket
suffix:semicolon
id|ep
op_increment
)paren
id|rtblks
op_add_assign
id|xfs_bmbt_get_blockcount
c_func
(paren
id|ep
)paren
suffix:semicolon
op_star
id|O_rtblks
op_assign
(paren
id|xfs_qcnt_t
)paren
id|rtblks
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * callback routine supplied to bulkstat(). Given an inumber, find its&n; * dquots and update them to account for resources taken by that inode.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_int
DECL|function|xfs_qm_dqusage_adjust
id|xfs_qm_dqusage_adjust
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point for filesystem */
id|xfs_ino_t
id|ino
comma
multiline_comment|/* inode number to get data for */
r_void
id|__user
op_star
id|buffer
comma
multiline_comment|/* not used */
r_int
id|ubsize
comma
multiline_comment|/* not used */
r_void
op_star
id|private_data
comma
multiline_comment|/* not used */
id|xfs_daddr_t
id|bno
comma
multiline_comment|/* starting block of inode cluster */
r_int
op_star
id|ubused
comma
multiline_comment|/* not used */
r_void
op_star
id|dip
comma
multiline_comment|/* on-disk inode pointer (not used) */
r_int
op_star
id|res
)paren
multiline_comment|/* result code value */
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_dquot_t
op_star
id|udqp
comma
op_star
id|gdqp
suffix:semicolon
id|xfs_qcnt_t
id|nblks
comma
id|rtblks
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * rootino must have its resources accounted for, not so with the quota&n;&t; * inodes.&n;&t; */
r_if
c_cond
(paren
id|ino
op_eq
id|mp-&gt;m_sb.sb_uquotino
op_logical_or
id|ino
op_eq
id|mp-&gt;m_sb.sb_gquotino
)paren
(brace
op_star
id|res
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t _need_ to take the ilock EXCL. However, the xfs_qm_dqget&n;&t; * interface expects the inode to be exclusively locked because that&squot;s&n;&t; * the case in all other instances. It&squot;s OK that we do this because&n;&t; * quotacheck is done only at mount time.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|ip
comma
id|bno
)paren
)paren
)paren
(brace
op_star
id|res
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
(brace
id|xfs_iput_new
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
op_star
id|res
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Obtain the locked dquots. In case of an error (eg. allocation&n;&t; * fails for ENOSPC), we return the negative of the error number&n;&t; * to bulkstat, so that it can get propagated to quotacheck() and&n;&t; * making us disable quotas for the file system.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget_noattach
c_func
(paren
id|ip
comma
op_amp
id|udqp
comma
op_amp
id|gdqp
)paren
)paren
)paren
(brace
id|xfs_iput
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
op_star
id|res
op_assign
id|BULKSTAT_RV_GIVEUP
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|rtblks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_REALTIME_INODE
c_func
(paren
id|ip
)paren
)paren
(brace
id|nblks
op_assign
(paren
id|xfs_qcnt_t
)paren
id|ip-&gt;i_d.di_nblocks
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Walk thru the extent list and count the realtime blocks.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_get_rtblks
c_func
(paren
id|ip
comma
op_amp
id|rtblks
)paren
)paren
)paren
(brace
id|xfs_iput
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udqp
)paren
id|xfs_qm_dqput
c_func
(paren
id|udqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gdqp
)paren
id|xfs_qm_dqput
c_func
(paren
id|gdqp
)paren
suffix:semicolon
op_star
id|res
op_assign
id|BULKSTAT_RV_GIVEUP
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|nblks
op_assign
(paren
id|xfs_qcnt_t
)paren
id|ip-&gt;i_d.di_nblocks
op_minus
id|rtblks
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_delayed_blks
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We can&squot;t release the inode while holding its dquot locks.&n;&t; * The inode can go into inactive and might try to acquire the dquotlocks.&n;&t; * So, just unlock here and do a vn_rele at the end.&n;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Add the (disk blocks and inode) resources occupied by this&n;&t; * inode to its dquots. We do this adjustment in the incore dquot,&n;&t; * and also copy the changes to its buffer.&n;&t; * We don&squot;t care about putting these changes in a transaction&n;&t; * envelope because if we crash in the middle of a &squot;quotacheck&squot;&n;&t; * we have to start from the beginning anyway.&n;&t; * Once we&squot;re done, we&squot;ll log all the dquot bufs.&n;&t; *&n;&t; * The *QUOTA_ON checks below may look pretty racey, but quotachecks&n;&t; * and quotaoffs don&squot;t race. (Quotachecks happen at mount time only).&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|udqp
)paren
suffix:semicolon
id|xfs_qm_quotacheck_dqadjust
c_func
(paren
id|udqp
comma
id|nblks
comma
id|rtblks
)paren
suffix:semicolon
id|xfs_qm_dqput
c_func
(paren
id|udqp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|xfs_qm_quotacheck_dqadjust
c_func
(paren
id|gdqp
comma
id|nblks
comma
id|rtblks
)paren
suffix:semicolon
id|xfs_qm_dqput
c_func
(paren
id|gdqp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now release the inode. This will send it to &squot;inactive&squot;, and&n;&t; * possibly even free blocks.&n;&t; */
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Goto next inode.&n;&t; */
op_star
id|res
op_assign
id|BULKSTAT_RV_DIDONE
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Walk thru all the filesystem inodes and construct a consistent view&n; * of the disk quota world. If the quotacheck fails, disable quotas.&n; */
r_int
DECL|function|xfs_qm_quotacheck
id|xfs_qm_quotacheck
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
r_int
id|done
comma
id|count
comma
id|error
suffix:semicolon
id|xfs_ino_t
id|lastino
suffix:semicolon
r_int
id|structsz
suffix:semicolon
id|xfs_inode_t
op_star
id|uip
comma
op_star
id|gip
suffix:semicolon
id|uint
id|flags
suffix:semicolon
id|count
op_assign
id|INT_MAX
suffix:semicolon
id|structsz
op_assign
l_int|1
suffix:semicolon
id|lastino
op_assign
l_int|0
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_QI_UQIP
c_func
(paren
id|mp
)paren
op_logical_or
id|XFS_QI_GQIP
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There should be no cached dquots. The (simplistic) quotacheck&n;&t; * algorithm doesn&squot;t like that.&n;&t; */
id|ASSERT
c_func
(paren
id|XFS_QI_MPLNDQUOTS
c_func
(paren
id|mp
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;XFS quotacheck %s: Please wait.&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First we go thru all the dquots on disk, USR and GRP, and reset&n;&t; * their counters to zero. We need a clean slate.&n;&t; * We don&squot;t log our changes till later.&n;&t; */
r_if
c_cond
(paren
(paren
id|uip
op_assign
id|XFS_QI_UQIP
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqiterate
c_func
(paren
id|mp
comma
id|uip
comma
id|XFS_QMOPT_UQUOTA
)paren
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|flags
op_or_assign
id|XFS_UQUOTA_CHKD
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|gip
op_assign
id|XFS_QI_GQIP
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqiterate
c_func
(paren
id|mp
comma
id|gip
comma
id|XFS_QMOPT_GQUOTA
)paren
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|flags
op_or_assign
id|XFS_GQUOTA_CHKD
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/*&n;&t;&t; * Iterate thru all the inodes in the file system,&n;&t;&t; * adjusting the corresponding dquot counters in core.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bulkstat
c_func
(paren
id|mp
comma
op_amp
id|lastino
comma
op_amp
id|count
comma
id|xfs_qm_dqusage_adjust
comma
l_int|NULL
comma
id|structsz
comma
l_int|NULL
comma
id|BULKSTAT_FG_IGET
op_or
id|BULKSTAT_FG_VFSLOCKED
comma
op_amp
id|done
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We can get this error if we couldn&squot;t do a dquot allocation inside&n;&t; * xfs_qm_dqusage_adjust (via bulkstat). We don&squot;t care about the&n;&t; * dirty dquots that might be cached, we just want to get rid of them&n;&t; * and turn quotaoff. The dquots won&squot;t be attached to any of the inodes&n;&t; * at this point (because we intentionally didn&squot;t in dqget_noattach).&n;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_qm_dqpurge_all
c_func
(paren
id|mp
comma
id|XFS_QMOPT_UQUOTA
op_or
id|XFS_QMOPT_GQUOTA
op_or
id|XFS_QMOPT_QUOTAOFF
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We&squot;ve made all the changes that we need to make incore.&n;&t; * Now flush_them down to disk buffers.&n;&t; */
id|xfs_qm_dqflush_all
c_func
(paren
id|mp
comma
id|XFS_QMOPT_DELWRI
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We didn&squot;t log anything, because if we crashed, we&squot;ll have to&n;&t; * start the quotacheck from scratch anyway. However, we must make&n;&t; * sure that our dquot changes are secure before we put the&n;&t; * quotacheck&squot;d stamp on the superblock. So, here we do a synchronous&n;&t; * flush.&n;&t; */
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If one type of quotas is off, then it will lose its&n;&t; * quotachecked status, since we won&squot;t be doing accounting for&n;&t; * that type anymore.&n;&t; */
id|mp-&gt;m_qflags
op_and_assign
op_complement
(paren
id|XFS_GQUOTA_CHKD
op_or
id|XFS_UQUOTA_CHKD
)paren
suffix:semicolon
id|mp-&gt;m_qflags
op_or_assign
id|flags
suffix:semicolon
id|XQM_LIST_PRINT
c_func
(paren
op_amp
(paren
id|XFS_QI_MPL_LIST
c_func
(paren
id|mp
)paren
)paren
comma
id|MPL_NEXT
comma
l_string|&quot;++++ Mp list +++&quot;
)paren
suffix:semicolon
id|error_return
suffix:colon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS quotacheck %s: Unsuccessful (Error %d): &quot;
l_string|&quot;Disabling quotas.&quot;
comma
id|mp-&gt;m_fsname
comma
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We must turn off quotas.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|mp-&gt;m_quotainfo
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_Gqm
op_ne
l_int|NULL
)paren
suffix:semicolon
id|xfs_qm_destroy_quotainfo
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_mount_reset_sbqflags
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;XFS quotacheck %s: Done.&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called after the superblock has been read in and we&squot;re ready to&n; * iget the quota inodes.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_init_quotainos
id|xfs_qm_init_quotainos
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_inode_t
op_star
id|uip
comma
op_star
id|gip
suffix:semicolon
r_int
id|error
suffix:semicolon
id|__int64_t
id|sbflags
suffix:semicolon
id|uint
id|flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_quotainfo
)paren
suffix:semicolon
id|uip
op_assign
id|gip
op_assign
l_int|NULL
suffix:semicolon
id|sbflags
op_assign
l_int|0
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Get the uquota and gquota inodes&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|mp-&gt;m_sb.sb_uquotino
op_ne
id|NULLFSINO
)paren
(brace
id|ASSERT
c_func
(paren
id|mp-&gt;m_sb.sb_uquotino
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|mp-&gt;m_sb.sb_uquotino
comma
l_int|0
comma
op_amp
id|uip
comma
l_int|0
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|mp-&gt;m_sb.sb_gquotino
op_ne
id|NULLFSINO
)paren
(brace
id|ASSERT
c_func
(paren
id|mp-&gt;m_sb.sb_gquotino
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|mp-&gt;m_sb.sb_gquotino
comma
l_int|0
comma
op_amp
id|gip
comma
l_int|0
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|uip
)paren
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|uip
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|flags
op_or_assign
id|XFS_QMOPT_SBVERSION
suffix:semicolon
id|sbflags
op_or_assign
(paren
id|XFS_SB_VERSIONNUM
op_or
id|XFS_SB_UQUOTINO
op_or
id|XFS_SB_GQUOTINO
op_or
id|XFS_SB_QFLAGS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Create the two inodes, if they don&squot;t exist already. The changes&n;&t; * made above will get added to a transaction and logged in one of&n;&t; * the qino_alloc calls below.  If the device is readonly,&n;&t; * temporarily switch to read-write to do this.&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|uip
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_qino_alloc
c_func
(paren
id|mp
comma
op_amp
id|uip
comma
id|sbflags
op_or
id|XFS_SB_UQUOTINO
comma
id|flags
op_or
id|XFS_QMOPT_UQUOTA
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
id|flags
op_and_assign
op_complement
id|XFS_QMOPT_SBVERSION
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|gip
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_qino_alloc
c_func
(paren
id|mp
comma
op_amp
id|gip
comma
id|sbflags
op_or
id|XFS_SB_GQUOTINO
comma
id|flags
op_or
id|XFS_QMOPT_GQUOTA
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|uip
)paren
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|uip
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
id|XFS_QI_UQIP
c_func
(paren
id|mp
)paren
op_assign
id|uip
suffix:semicolon
id|XFS_QI_GQIP
c_func
(paren
id|mp
)paren
op_assign
id|gip
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Traverse the freelist of dquots and attempt to reclaim a maximum of&n; * &squot;howmany&squot; dquots. This operation races with dqlookup(), and attempts to&n; * favor the lookup function ...&n; * XXXsup merge this with qm_reclaim_one().&n; */
id|STATIC
r_int
DECL|function|xfs_qm_shake_freelist
id|xfs_qm_shake_freelist
c_func
(paren
r_int
id|howmany
)paren
(brace
r_int
id|nreclaimed
suffix:semicolon
id|xfs_dqhash_t
op_star
id|hash
suffix:semicolon
id|xfs_dquot_t
op_star
id|dqp
comma
op_star
id|nextdqp
suffix:semicolon
r_int
id|restarts
suffix:semicolon
r_int
id|nflushes
suffix:semicolon
r_if
c_cond
(paren
id|howmany
op_le
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|nreclaimed
op_assign
l_int|0
suffix:semicolon
id|restarts
op_assign
l_int|0
suffix:semicolon
id|nflushes
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;Shake free 0x%x&quot;
comma
id|howmany
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* lock order is : hashchainlock, freelistlock, mplistlock */
id|tryagain
suffix:colon
id|xfs_qm_freelist_lock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dqp
op_assign
id|xfs_Gqm-&gt;qm_dqfreelist.qh_next
suffix:semicolon
(paren
(paren
id|dqp
op_ne
(paren
id|xfs_dquot_t
op_star
)paren
op_amp
id|xfs_Gqm-&gt;qm_dqfreelist
)paren
op_logical_and
id|nreclaimed
OL
id|howmany
)paren
suffix:semicolon
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are racing with dqlookup here. Naturally we don&squot;t&n;&t;&t; * want to reclaim a dquot that lookup wants.&n;&t;&t; */
r_if
c_cond
(paren
id|dqp-&gt;dq_flags
op_amp
id|XFS_DQ_WANT
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|restarts
op_ge
id|XFS_QM_RECLAIM_MAX_RESTARTS
)paren
r_return
(paren
id|nreclaimed
)paren
suffix:semicolon
id|XQM_STATS_INC
c_func
(paren
id|xqmstats.xs_qm_dqwants
)paren
suffix:semicolon
r_goto
id|tryagain
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the dquot is inactive, we are assured that it is&n;&t;&t; * not on the mplist or the hashlist, and that makes our&n;&t;&t; * life easier.&n;&t;&t; */
r_if
c_cond
(paren
id|dqp-&gt;dq_flags
op_amp
id|XFS_DQ_INACTIVE
)paren
(brace
id|ASSERT
c_func
(paren
id|dqp-&gt;q_mount
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;HL_PREVP
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;MPL_PREVP
op_eq
l_int|NULL
)paren
suffix:semicolon
id|XQM_STATS_INC
c_func
(paren
id|xqmstats.xs_qm_dqinact_reclaims
)paren
suffix:semicolon
id|nextdqp
op_assign
id|dqp-&gt;dq_flnext
suffix:semicolon
r_goto
id|off_freelist
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dqp-&gt;MPL_PREVP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to grab the flush lock. If this dquot is in the process of&n;&t;&t; * getting flushed to disk, we don&squot;t want to reclaim it.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqflock_nowait
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp
op_assign
id|dqp-&gt;dq_flnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We have the flush lock so we know that this is not in the&n;&t;&t; * process of being flushed. So, if this is dirty, flush it&n;&t;&t; * DELWRI so that we don&squot;t get a freelist infested with&n;&t;&t; * dirty dquots.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQSHAKE: DQDIRTY&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We flush it delayed write, so don&squot;t bother&n;&t;&t;&t; * releasing the mplock.&n;&t;&t;&t; */
(paren
r_void
)paren
id|xfs_qm_dqflush
c_func
(paren
id|dqp
comma
id|XFS_QMOPT_DELWRI
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/* dqflush unlocks dqflock */
id|dqp
op_assign
id|dqp-&gt;dq_flnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We&squot;re trying to get the hashlock out of order. This races&n;&t;&t; * with dqlookup; so, we giveup and goto the next dquot if&n;&t;&t; * we couldn&squot;t get the hashlock. This way, we won&squot;t starve&n;&t;&t; * a dqlookup process that holds the hashlock that is&n;&t;&t; * waiting for the freelist lock.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqhashlock_nowait
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp
op_assign
id|dqp-&gt;dq_flnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This races with dquot allocation code as well as dqflush_all&n;&t;&t; * and reclaim code. So, if we failed to grab the mplist lock,&n;&t;&t; * giveup everything and start over.&n;&t;&t; */
id|hash
op_assign
id|dqp-&gt;q_hash
suffix:semicolon
id|ASSERT
c_func
(paren
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_mplist_nowait
c_func
(paren
id|dqp-&gt;q_mount
)paren
)paren
(brace
multiline_comment|/* XXX put a sentinel so that we can come back here */
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|hash
)paren
suffix:semicolon
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|restarts
op_ge
id|XFS_QM_RECLAIM_MAX_RESTARTS
)paren
r_return
(paren
id|nreclaimed
)paren
suffix:semicolon
r_goto
id|tryagain
suffix:semicolon
)brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQSHAKE: UNLINKING&quot;
)paren
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;Shake 0x%p, ID 0x%x&bslash;n&quot;
comma
id|dqp
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|dqp-&gt;q_nrefs
op_eq
l_int|0
)paren
suffix:semicolon
id|nextdqp
op_assign
id|dqp-&gt;dq_flnext
suffix:semicolon
id|XQM_MPLIST_REMOVE
c_func
(paren
op_amp
(paren
id|XFS_QI_MPL_LIST
c_func
(paren
id|dqp-&gt;q_mount
)paren
)paren
comma
id|dqp
)paren
suffix:semicolon
id|XQM_HASHLIST_REMOVE
c_func
(paren
id|hash
comma
id|dqp
)paren
suffix:semicolon
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_mplist_unlock
c_func
(paren
id|dqp-&gt;q_mount
)paren
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|hash
)paren
suffix:semicolon
id|off_freelist
suffix:colon
id|XQM_FREELIST_REMOVE
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|nreclaimed
op_increment
suffix:semicolon
id|XQM_STATS_INC
c_func
(paren
id|xqmstats.xs_qm_dqshake_reclaims
)paren
suffix:semicolon
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp
op_assign
id|nextdqp
suffix:semicolon
)brace
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_return
(paren
id|nreclaimed
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The kmem_shake interface is invoked when memory is running low.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_int
DECL|function|xfs_qm_shake
id|xfs_qm_shake
c_func
(paren
r_int
id|nr_to_scan
comma
r_int
r_int
id|gfp_mask
)paren
(brace
r_int
id|ndqused
comma
id|nfree
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kmem_shake_allow
c_func
(paren
id|gfp_mask
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_Gqm
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|nfree
op_assign
id|xfs_Gqm-&gt;qm_dqfreelist.qh_nelems
suffix:semicolon
multiline_comment|/* free dquots */
multiline_comment|/* incore dquots in all f/s&squot;s */
id|ndqused
op_assign
id|atomic_read
c_func
(paren
op_amp
id|xfs_Gqm-&gt;qm_totaldquots
)paren
op_minus
id|nfree
suffix:semicolon
id|ASSERT
c_func
(paren
id|ndqused
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfree
op_le
id|ndqused
op_logical_and
id|nfree
OL
id|ndquot
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|ndqused
op_mul_assign
id|xfs_Gqm-&gt;qm_dqfree_ratio
suffix:semicolon
multiline_comment|/* target # of free dquots */
id|n
op_assign
id|nfree
op_minus
id|ndqused
op_minus
id|ndquot
suffix:semicolon
multiline_comment|/* # over target */
r_return
id|xfs_qm_shake_freelist
c_func
(paren
id|MAX
c_func
(paren
id|nfree
comma
id|n
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Just pop the least recently used dquot off the freelist and&n; * recycle it. The returned dquot is locked.&n; */
id|STATIC
id|xfs_dquot_t
op_star
DECL|function|xfs_qm_dqreclaim_one
id|xfs_qm_dqreclaim_one
c_func
(paren
r_void
)paren
(brace
id|xfs_dquot_t
op_star
id|dqpout
suffix:semicolon
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
r_int
id|restarts
suffix:semicolon
r_int
id|nflushes
suffix:semicolon
id|restarts
op_assign
l_int|0
suffix:semicolon
id|dqpout
op_assign
l_int|NULL
suffix:semicolon
id|nflushes
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* lockorder: hashchainlock, freelistlock, mplistlock, dqlock, dqflock */
id|startagain
suffix:colon
id|xfs_qm_freelist_lock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|FOREACH_DQUOT_IN_FREELIST
c_func
(paren
id|dqp
comma
op_amp
(paren
id|xfs_Gqm-&gt;qm_dqfreelist
)paren
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are racing with dqlookup here. Naturally we don&squot;t&n;&t;&t; * want to reclaim a dquot that lookup wants. We release the&n;&t;&t; * freelist lock and start over, so that lookup will grab&n;&t;&t; * both the dquot and the freelistlock.&n;&t;&t; */
r_if
c_cond
(paren
id|dqp-&gt;dq_flags
op_amp
id|XFS_DQ_WANT
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|dqp-&gt;dq_flags
op_amp
id|XFS_DQ_INACTIVE
)paren
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQRECLAIM: DQWANT&quot;
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|restarts
op_ge
id|XFS_QM_RECLAIM_MAX_RESTARTS
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|XQM_STATS_INC
c_func
(paren
id|xqmstats.xs_qm_dqwants
)paren
suffix:semicolon
r_goto
id|startagain
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the dquot is inactive, we are assured that it is&n;&t;&t; * not on the mplist or the hashlist, and that makes our&n;&t;&t; * life easier.&n;&t;&t; */
r_if
c_cond
(paren
id|dqp-&gt;dq_flags
op_amp
id|XFS_DQ_INACTIVE
)paren
(brace
id|ASSERT
c_func
(paren
id|dqp-&gt;q_mount
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;HL_PREVP
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;MPL_PREVP
op_eq
l_int|NULL
)paren
suffix:semicolon
id|XQM_FREELIST_REMOVE
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqpout
op_assign
id|dqp
suffix:semicolon
id|XQM_STATS_INC
c_func
(paren
id|xqmstats.xs_qm_dqinact_reclaims
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dqp-&gt;q_hash
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;MPL_PREVP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to grab the flush lock. If this dquot is in the process of&n;&t;&t; * getting flushed to disk, we don&squot;t want to reclaim it.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqflock_nowait
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We have the flush lock so we know that this is not in the&n;&t;&t; * process of being flushed. So, if this is dirty, flush it&n;&t;&t; * DELWRI so that we don&squot;t get a freelist infested with&n;&t;&t; * dirty dquots.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQRECLAIM: DQDIRTY&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We flush it delayed write, so don&squot;t bother&n;&t;&t;&t; * releasing the freelist lock.&n;&t;&t;&t; */
(paren
r_void
)paren
id|xfs_qm_dqflush
c_func
(paren
id|dqp
comma
id|XFS_QMOPT_DELWRI
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/* dqflush unlocks dqflock */
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_mplist_nowait
c_func
(paren
id|dqp-&gt;q_mount
)paren
)paren
(brace
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqhashlock_nowait
c_func
(paren
id|dqp
)paren
)paren
r_goto
id|mplistunlock
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;q_nrefs
op_eq
l_int|0
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQRECLAIM: UNLINKING&quot;
)paren
suffix:semicolon
id|XQM_MPLIST_REMOVE
c_func
(paren
op_amp
(paren
id|XFS_QI_MPL_LIST
c_func
(paren
id|dqp-&gt;q_mount
)paren
)paren
comma
id|dqp
)paren
suffix:semicolon
id|XQM_HASHLIST_REMOVE
c_func
(paren
id|dqp-&gt;q_hash
comma
id|dqp
)paren
suffix:semicolon
id|XQM_FREELIST_REMOVE
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqpout
op_assign
id|dqp
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|dqp-&gt;q_hash
)paren
suffix:semicolon
id|mplistunlock
suffix:colon
id|xfs_qm_mplist_unlock
c_func
(paren
id|dqp-&gt;q_mount
)paren
suffix:semicolon
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqpout
)paren
r_break
suffix:semicolon
)brace
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
r_return
(paren
id|dqpout
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------*/
multiline_comment|/*&n; * Return a new incore dquot. Depending on the number of&n; * dquots in the system, we either allocate a new one on the kernel heap,&n; * or reclaim a free one.&n; * Return value is B_TRUE if we allocated a new dquot, B_FALSE if we managed&n; * to reclaim an existing one from the freelist.&n; */
id|boolean_t
DECL|function|xfs_qm_dqalloc_incore
id|xfs_qm_dqalloc_incore
c_func
(paren
id|xfs_dquot_t
op_star
op_star
id|O_dqpp
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
multiline_comment|/*&n;&t; * Check against high water mark to see if we want to pop&n;&t; * a nincompoop dquot off the freelist.&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|xfs_Gqm-&gt;qm_totaldquots
)paren
op_ge
id|ndquot
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try to recycle a dquot from the freelist.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|dqp
op_assign
id|xfs_qm_dqreclaim_one
c_func
(paren
)paren
)paren
)paren
(brace
id|XQM_STATS_INC
c_func
(paren
id|xqmstats.xs_qm_dqreclaims
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Just zero the core here. The rest will get&n;&t;&t;&t; * reinitialized by caller. XXX we shouldn&squot;t even&n;&t;&t;&t; * do this zero ...&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
id|dqp-&gt;q_core
comma
l_int|0
comma
r_sizeof
(paren
id|dqp-&gt;q_core
)paren
)paren
suffix:semicolon
op_star
id|O_dqpp
op_assign
id|dqp
suffix:semicolon
r_return
(paren
id|B_FALSE
)paren
suffix:semicolon
)brace
id|XQM_STATS_INC
c_func
(paren
id|xqmstats.xs_qm_dqreclaim_misses
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a brand new dquot on the kernel heap and return it&n;&t; * to the caller to initialize.&n;&t; */
id|ASSERT
c_func
(paren
id|xfs_Gqm-&gt;qm_dqzone
op_ne
l_int|NULL
)paren
suffix:semicolon
op_star
id|O_dqpp
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_Gqm-&gt;qm_dqzone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|xfs_Gqm-&gt;qm_totaldquots
)paren
suffix:semicolon
r_return
(paren
id|B_TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a transaction and write the incore superblock changes to&n; * disk. flags parameter indicates which fields have changed.&n; */
r_int
DECL|function|xfs_qm_write_sb_changes
id|xfs_qm_write_sb_changes
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|__int64_t
id|flags
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Writing superblock quota changes :%s&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
macro_line|#endif
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_QM_SBCHANGE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|mp-&gt;m_sb.sb_sectsize
op_plus
l_int|128
comma
l_int|0
comma
l_int|0
comma
id|XFS_DEFAULT_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_mod_sb
c_func
(paren
id|tp
comma
id|flags
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------- utility functions for vnodeops ---------------- */
multiline_comment|/*&n; * Given an inode, a uid and gid (from cred_t) make sure that we have&n; * allocated relevant dquot(s) on disk, and that we won&squot;t exceed inode&n; * quotas by creating this file.&n; * This also attaches dquot(s) to the given inode after locking it,&n; * and returns the dquots corresponding to the uid and/or gid.&n; *&n; * in&t;: inode (unlocked)&n; * out&t;: udquot, gdquot with references taken and unlocked&n; */
r_int
DECL|function|xfs_qm_vop_dqalloc
id|xfs_qm_vop_dqalloc
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|uid_t
id|uid
comma
id|gid_t
id|gid
comma
id|uint
id|flags
comma
id|xfs_dquot_t
op_star
op_star
id|O_udqpp
comma
id|xfs_dquot_t
op_star
op_star
id|O_gdqpp
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_dquot_t
op_star
id|uq
comma
op_star
id|gq
suffix:semicolon
id|uint
id|lockflags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|lockflags
op_assign
id|XFS_ILOCK_EXCL
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lockflags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_QMOPT_INHERIT
)paren
op_logical_and
id|XFS_INHERIT_GID
c_func
(paren
id|ip
comma
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
)paren
)paren
id|gid
op_assign
id|ip-&gt;i_d.di_gid
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the dquot(s) to this inode, doing a dquot allocation&n;&t; * if necessary. The dquot(s) will not be locked.&n;&t; */
r_if
c_cond
(paren
id|XFS_NOT_DQATTACHED
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqattach
c_func
(paren
id|ip
comma
id|XFS_QMOPT_DQALLOC
op_or
id|XFS_QMOPT_ILOCKED
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lockflags
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
id|uq
op_assign
id|gq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_QMOPT_UQUOTA
)paren
op_logical_and
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_uid
op_ne
id|uid
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * What we need is the dquot that has this uid, and&n;&t;&t;&t; * if we send the inode to dqget, the uid of the inode&n;&t;&t;&t; * takes priority over what&squot;s sent in the uid argument.&n;&t;&t;&t; * We must unlock inode here before calling dqget if&n;&t;&t;&t; * we&squot;re not sending the inode, because otherwise&n;&t;&t;&t; * we&squot;ll deadlock by doing trans_reserve while&n;&t;&t;&t; * holding ilock.&n;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lockflags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|mp
comma
l_int|NULL
comma
(paren
id|xfs_dqid_t
)paren
id|uid
comma
id|XFS_DQ_USER
comma
id|XFS_QMOPT_DQALLOC
op_or
id|XFS_QMOPT_DOWARN
comma
op_amp
id|uq
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOENT
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Get the ilock in the right order.&n;&t;&t;&t; */
id|xfs_dqunlock
c_func
(paren
id|uq
)paren
suffix:semicolon
id|lockflags
op_assign
id|XFS_ILOCK_SHARED
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lockflags
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Take an extra reference, because we&squot;ll return&n;&t;&t;&t; * this to caller&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
)paren
suffix:semicolon
id|uq
op_assign
id|ip-&gt;i_udquot
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|uq
)paren
suffix:semicolon
id|XFS_DQHOLD
c_func
(paren
id|uq
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|uq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_QMOPT_GQUOTA
)paren
op_logical_and
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_gid
op_ne
id|gid
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lockflags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|mp
comma
l_int|NULL
comma
(paren
id|xfs_dqid_t
)paren
id|gid
comma
id|XFS_DQ_GROUP
comma
id|XFS_QMOPT_DQALLOC
op_or
id|XFS_QMOPT_DOWARN
comma
op_amp
id|gq
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|uq
)paren
id|xfs_qm_dqrele
c_func
(paren
id|uq
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOENT
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_dqunlock
c_func
(paren
id|gq
)paren
suffix:semicolon
id|lockflags
op_assign
id|XFS_ILOCK_SHARED
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lockflags
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
id|gq
op_assign
id|ip-&gt;i_gdquot
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|gq
)paren
suffix:semicolon
id|XFS_DQHOLD
c_func
(paren
id|gq
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|gq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|uq
)paren
id|xfs_dqtrace_entry_ino
c_func
(paren
id|uq
comma
l_string|&quot;DQALLOC&quot;
comma
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lockflags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|O_udqpp
)paren
op_star
id|O_udqpp
op_assign
id|uq
suffix:semicolon
r_else
r_if
c_cond
(paren
id|uq
)paren
id|xfs_qm_dqrele
c_func
(paren
id|uq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|O_gdqpp
)paren
op_star
id|O_gdqpp
op_assign
id|gq
suffix:semicolon
r_else
r_if
c_cond
(paren
id|gq
)paren
id|xfs_qm_dqrele
c_func
(paren
id|gq
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Actually transfer ownership, and do dquot modifications.&n; * These were already reserved.&n; */
id|xfs_dquot_t
op_star
DECL|function|xfs_qm_vop_chown
id|xfs_qm_vop_chown
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dquot_t
op_star
op_star
id|IO_olddq
comma
id|xfs_dquot_t
op_star
id|newdq
)paren
(brace
id|xfs_dquot_t
op_star
id|prevdq
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
suffix:semicolon
multiline_comment|/* old dquot */
id|prevdq
op_assign
op_star
id|IO_olddq
suffix:semicolon
id|ASSERT
c_func
(paren
id|prevdq
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|prevdq
op_ne
id|newdq
)paren
suffix:semicolon
id|xfs_trans_mod_dquot
c_func
(paren
id|tp
comma
id|prevdq
comma
id|XFS_TRANS_DQ_BCOUNT
comma
op_minus
(paren
id|ip-&gt;i_d.di_nblocks
)paren
)paren
suffix:semicolon
id|xfs_trans_mod_dquot
c_func
(paren
id|tp
comma
id|prevdq
comma
id|XFS_TRANS_DQ_ICOUNT
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* the sparkling new dquot */
id|xfs_trans_mod_dquot
c_func
(paren
id|tp
comma
id|newdq
comma
id|XFS_TRANS_DQ_BCOUNT
comma
id|ip-&gt;i_d.di_nblocks
)paren
suffix:semicolon
id|xfs_trans_mod_dquot
c_func
(paren
id|tp
comma
id|newdq
comma
id|XFS_TRANS_DQ_ICOUNT
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Take an extra reference, because the inode&n;&t; * is going to keep this dquot pointer even&n;&t; * after the trans_commit.&n;&t; */
id|xfs_dqlock
c_func
(paren
id|newdq
)paren
suffix:semicolon
id|XFS_DQHOLD
c_func
(paren
id|newdq
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|newdq
)paren
suffix:semicolon
op_star
id|IO_olddq
op_assign
id|newdq
suffix:semicolon
r_return
(paren
id|prevdq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Quota reservations for setattr(AT_UID|AT_GID).&n; */
r_int
DECL|function|xfs_qm_vop_chown_reserve
id|xfs_qm_vop_chown_reserve
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dquot_t
op_star
id|udqp
comma
id|xfs_dquot_t
op_star
id|gdqp
comma
id|uint
id|flags
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|uint
id|delblks
suffix:semicolon
id|xfs_dquot_t
op_star
id|unresudq
comma
op_star
id|unresgdq
comma
op_star
id|delblksudq
comma
op_star
id|delblksgdq
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|delblks
op_assign
id|ip-&gt;i_delayed_blks
suffix:semicolon
id|delblksudq
op_assign
id|delblksgdq
op_assign
id|unresudq
op_assign
id|unresgdq
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|udqp
op_logical_and
id|ip-&gt;i_d.di_uid
op_ne
(paren
id|uid_t
)paren
id|INT_GET
c_func
(paren
id|udqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|delblksudq
op_assign
id|udqp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there are delayed allocation blocks, then we have to&n;&t;&t; * unreserve those from the old dquot, and add them to the&n;&t;&t; * new dquot.&n;&t;&t; */
r_if
c_cond
(paren
id|delblks
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
)paren
suffix:semicolon
id|unresudq
op_assign
id|ip-&gt;i_udquot
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|ip-&gt;i_mount
)paren
op_logical_and
id|gdqp
op_logical_and
id|ip-&gt;i_d.di_gid
op_ne
id|INT_GET
c_func
(paren
id|gdqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|delblksgdq
op_assign
id|gdqp
suffix:semicolon
r_if
c_cond
(paren
id|delblks
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
id|unresgdq
op_assign
id|ip-&gt;i_gdquot
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve_quota_bydquots
c_func
(paren
id|tp
comma
id|ip-&gt;i_mount
comma
id|delblksudq
comma
id|delblksgdq
comma
id|ip-&gt;i_d.di_nblocks
comma
l_int|1
comma
id|flags
op_or
id|XFS_QMOPT_RES_REGBLKS
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do the delayed blks reservations/unreservations now. Since, these&n;&t; * are done without the help of a transaction, if a reservation fails&n;&t; * its previous reservations won&squot;t be automatically undone by trans&n;&t; * code. So, we have to do it manually here.&n;&t; */
r_if
c_cond
(paren
id|delblks
)paren
(brace
multiline_comment|/*&n;&t;&t; * Do the reservations first. Unreservation can&squot;t fail.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|delblksudq
op_logical_or
id|delblksgdq
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|unresudq
op_logical_or
id|unresgdq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve_quota_bydquots
c_func
(paren
l_int|NULL
comma
id|ip-&gt;i_mount
comma
id|delblksudq
comma
id|delblksgdq
comma
(paren
id|xfs_qcnt_t
)paren
id|delblks
comma
l_int|0
comma
id|flags
op_or
id|XFS_QMOPT_RES_REGBLKS
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|xfs_trans_reserve_quota_bydquots
c_func
(paren
l_int|NULL
comma
id|ip-&gt;i_mount
comma
id|unresudq
comma
id|unresgdq
comma
op_minus
(paren
(paren
id|xfs_qcnt_t
)paren
id|delblks
)paren
comma
l_int|0
comma
id|XFS_QMOPT_RES_REGBLKS
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_qm_vop_rename_dqattach
id|xfs_qm_vop_rename_dqattach
c_func
(paren
id|xfs_inode_t
op_star
op_star
id|i_tab
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ip
op_assign
id|i_tab
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_NOT_DQATTACHED
c_func
(paren
id|ip-&gt;i_mount
comma
id|ip
)paren
)paren
(brace
id|error
op_assign
id|xfs_qm_dqattach
c_func
(paren
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
(paren
id|i
OL
l_int|4
op_logical_and
id|i_tab
(braket
id|i
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Watch out for duplicate entries in the table.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ip
op_assign
id|i_tab
(braket
id|i
)braket
)paren
op_ne
id|i_tab
(braket
id|i
op_minus
l_int|1
)braket
)paren
(brace
r_if
c_cond
(paren
id|XFS_NOT_DQATTACHED
c_func
(paren
id|ip-&gt;i_mount
comma
id|ip
)paren
)paren
(brace
id|error
op_assign
id|xfs_qm_dqattach
c_func
(paren
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_qm_vop_dqattach_and_dqmod_newinode
id|xfs_qm_vop_dqattach_and_dqmod_newinode
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dquot_t
op_star
id|udqp
comma
id|xfs_dquot_t
op_star
id|gdqp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|tp-&gt;t_mountp
)paren
)paren
r_return
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|tp-&gt;t_mountp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|udqp
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|udqp
)paren
suffix:semicolon
id|XFS_DQHOLD
c_func
(paren
id|udqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|udqp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip-&gt;i_udquot
op_assign
id|udqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_uid
op_eq
id|INT_GET
c_func
(paren
id|udqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_trans_mod_dquot
c_func
(paren
id|tp
comma
id|udqp
comma
id|XFS_TRANS_DQ_ICOUNT
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gdqp
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|XFS_DQHOLD
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip-&gt;i_gdquot
op_assign
id|gdqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_gid
op_eq
id|INT_GET
c_func
(paren
id|gdqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_trans_mod_dquot
c_func
(paren
id|tp
comma
id|gdqp
comma
id|XFS_TRANS_DQ_ICOUNT
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ------------- list stuff -----------------*/
r_void
DECL|function|xfs_qm_freelist_init
id|xfs_qm_freelist_init
c_func
(paren
id|xfs_frlist_t
op_star
id|ql
)paren
(brace
id|ql-&gt;qh_next
op_assign
id|ql-&gt;qh_prev
op_assign
(paren
id|xfs_dquot_t
op_star
)paren
id|ql
suffix:semicolon
id|mutex_init
c_func
(paren
op_amp
id|ql-&gt;qh_lock
comma
id|MUTEX_DEFAULT
comma
l_string|&quot;dqf&quot;
)paren
suffix:semicolon
id|ql-&gt;qh_version
op_assign
l_int|0
suffix:semicolon
id|ql-&gt;qh_nelems
op_assign
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xfs_qm_freelist_destroy
id|xfs_qm_freelist_destroy
c_func
(paren
id|xfs_frlist_t
op_star
id|ql
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
comma
op_star
id|nextdqp
suffix:semicolon
id|mutex_lock
c_func
(paren
op_amp
id|ql-&gt;qh_lock
comma
id|PINOD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dqp
op_assign
id|ql-&gt;qh_next
suffix:semicolon
id|dqp
op_ne
(paren
id|xfs_dquot_t
op_star
)paren
id|ql
suffix:semicolon
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|nextdqp
op_assign
id|dqp-&gt;dq_flnext
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;FREELIST destroy 0x%p&quot;
comma
id|dqp
)paren
suffix:semicolon
macro_line|#endif
id|XQM_FREELIST_REMOVE
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp
op_assign
id|nextdqp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Don&squot;t bother about unlocking.&n;&t; */
id|mutex_destroy
c_func
(paren
op_amp
id|ql-&gt;qh_lock
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ql-&gt;qh_nelems
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_qm_freelist_insert
id|xfs_qm_freelist_insert
c_func
(paren
id|xfs_frlist_t
op_star
id|ql
comma
id|xfs_dquot_t
op_star
id|dq
)paren
(brace
id|dq-&gt;dq_flnext
op_assign
id|ql-&gt;qh_next
suffix:semicolon
id|dq-&gt;dq_flprev
op_assign
(paren
id|xfs_dquot_t
op_star
)paren
id|ql
suffix:semicolon
id|ql-&gt;qh_next
op_assign
id|dq
suffix:semicolon
id|dq-&gt;dq_flnext-&gt;dq_flprev
op_assign
id|dq
suffix:semicolon
id|xfs_Gqm-&gt;qm_dqfreelist.qh_nelems
op_increment
suffix:semicolon
id|xfs_Gqm-&gt;qm_dqfreelist.qh_version
op_increment
suffix:semicolon
)brace
r_void
DECL|function|xfs_qm_freelist_unlink
id|xfs_qm_freelist_unlink
c_func
(paren
id|xfs_dquot_t
op_star
id|dq
)paren
(brace
id|xfs_dquot_t
op_star
id|next
op_assign
id|dq-&gt;dq_flnext
suffix:semicolon
id|xfs_dquot_t
op_star
id|prev
op_assign
id|dq-&gt;dq_flprev
suffix:semicolon
id|next-&gt;dq_flprev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;dq_flnext
op_assign
id|next
suffix:semicolon
id|dq-&gt;dq_flnext
op_assign
id|dq-&gt;dq_flprev
op_assign
id|dq
suffix:semicolon
id|xfs_Gqm-&gt;qm_dqfreelist.qh_nelems
op_decrement
suffix:semicolon
id|xfs_Gqm-&gt;qm_dqfreelist.qh_version
op_increment
suffix:semicolon
)brace
r_void
DECL|function|xfs_qm_freelist_append
id|xfs_qm_freelist_append
c_func
(paren
id|xfs_frlist_t
op_star
id|ql
comma
id|xfs_dquot_t
op_star
id|dq
)paren
(brace
id|xfs_qm_freelist_insert
c_func
(paren
(paren
id|xfs_frlist_t
op_star
)paren
id|ql-&gt;qh_prev
comma
id|dq
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_qm_dqhashlock_nowait
id|xfs_qm_dqhashlock_nowait
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
r_int
id|locked
suffix:semicolon
id|locked
op_assign
id|mutex_trylock
c_func
(paren
op_amp
(paren
(paren
id|dqp
)paren
op_member_access_from_pointer
id|q_hash-&gt;qh_lock
)paren
)paren
suffix:semicolon
r_return
(paren
id|locked
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_qm_freelist_lock_nowait
id|xfs_qm_freelist_lock_nowait
c_func
(paren
id|xfs_qm_t
op_star
id|xqm
)paren
(brace
r_int
id|locked
suffix:semicolon
id|locked
op_assign
id|mutex_trylock
c_func
(paren
op_amp
(paren
id|xqm-&gt;qm_dqfreelist.qh_lock
)paren
)paren
suffix:semicolon
r_return
(paren
id|locked
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_qm_mplist_nowait
id|xfs_qm_mplist_nowait
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
r_int
id|locked
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_quotainfo
)paren
suffix:semicolon
id|locked
op_assign
id|mutex_trylock
c_func
(paren
op_amp
(paren
id|XFS_QI_MPLLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
r_return
(paren
id|locked
)paren
suffix:semicolon
)brace
eof
