multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_fs.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rtalloc.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_itable.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_acl.h&quot;
macro_line|#include &quot;xfs_cap.h&quot;
macro_line|#include &quot;xfs_mac.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_utils.h&quot;
macro_line|#include &quot;xfs_qm.h&quot;
macro_line|#ifdef DEBUG
DECL|macro|qdprintk
macro_line|# define qdprintk(s, args...)&t;cmn_err(CE_DEBUG, s, ## args)
macro_line|#else
DECL|macro|qdprintk
macro_line|# define qdprintk(s, args...)&t;do { } while (0)
macro_line|#endif
id|STATIC
r_int
id|xfs_qm_scall_trunc_qfiles
c_func
(paren
id|xfs_mount_t
op_star
comma
id|uint
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_scall_getquota
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_dqid_t
comma
id|uint
comma
id|fs_disk_quota_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_scall_getqstat
c_func
(paren
id|xfs_mount_t
op_star
comma
id|fs_quota_stat_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_scall_setqlim
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_dqid_t
comma
id|uint
comma
id|fs_disk_quota_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_scall_quotaon
c_func
(paren
id|xfs_mount_t
op_star
comma
id|uint
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_scall_quotaoff
c_func
(paren
id|xfs_mount_t
op_star
comma
id|uint
comma
id|boolean_t
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_log_quotaoff
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_qoff_logitem_t
op_star
op_star
comma
id|uint
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_qm_log_quotaoff_end
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_qoff_logitem_t
op_star
comma
id|uint
)paren
suffix:semicolon
id|STATIC
id|uint
id|xfs_qm_import_flags
c_func
(paren
id|uint
)paren
suffix:semicolon
id|STATIC
id|uint
id|xfs_qm_export_flags
c_func
(paren
id|uint
)paren
suffix:semicolon
id|STATIC
id|uint
id|xfs_qm_import_qtype_flags
c_func
(paren
id|uint
)paren
suffix:semicolon
id|STATIC
id|uint
id|xfs_qm_export_qtype_flags
c_func
(paren
id|uint
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_qm_export_dquot
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_disk_dquot_t
op_star
comma
id|fs_disk_quota_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * The main distribution switch of all XFS quotactl system calls.&n; */
r_int
DECL|function|xfs_qm_quotactl
id|xfs_qm_quotactl
c_func
(paren
r_struct
id|bhv_desc
op_star
id|bdp
comma
r_int
id|cmd
comma
r_int
id|id
comma
id|xfs_caddr_t
id|addr
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|vfs
op_star
id|vfsp
suffix:semicolon
id|vfsp
op_assign
id|bhvtovfs
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|XFS_VFSTOM
c_func
(paren
id|vfsp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_eq
l_int|NULL
op_logical_and
id|cmd
op_ne
id|Q_SYNC
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
OL
l_int|0
op_logical_and
id|cmd
op_ne
id|Q_SYNC
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The following commands are valid even when quotaoff.&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t;&t; * truncate quota files. quota must be off.&n;&t;&t; */
r_case
id|Q_XQUOTARM
suffix:colon
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_or
id|addr
op_eq
l_int|NULL
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
r_return
(paren
id|xfs_qm_scall_trunc_qfiles
c_func
(paren
id|mp
comma
id|xfs_qm_import_qtype_flags
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|addr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get quota status information.&n;&t;&t; */
r_case
id|Q_XGETQSTAT
suffix:colon
r_return
(paren
id|xfs_qm_scall_getqstat
c_func
(paren
id|mp
comma
(paren
id|fs_quota_stat_t
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * QUOTAON for root f/s and quota enforcement on others..&n;&t;&t; * Quota accounting for non-root f/s&squot;s must be turned on&n;&t;&t; * at mount time.&n;&t;&t; */
r_case
id|Q_XQUOTAON
suffix:colon
r_if
c_cond
(paren
id|addr
op_eq
l_int|NULL
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
r_return
(paren
id|xfs_qm_scall_quotaon
c_func
(paren
id|mp
comma
id|xfs_qm_import_flags
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|addr
)paren
)paren
)paren
suffix:semicolon
r_case
id|Q_XQUOTAOFF
suffix:colon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ESRCH
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|Q_XQUOTAOFF
suffix:colon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
id|error
op_assign
id|xfs_qm_scall_quotaoff
c_func
(paren
id|mp
comma
id|xfs_qm_import_flags
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|addr
)paren
comma
id|B_FALSE
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Defaults to XFS_GETUQUOTA.&n;&t;&t; */
r_case
id|Q_XGETQUOTA
suffix:colon
id|error
op_assign
id|xfs_qm_scall_getquota
c_func
(paren
id|mp
comma
(paren
id|xfs_dqid_t
)paren
id|id
comma
id|XFS_DQ_USER
comma
(paren
id|fs_disk_quota_t
op_star
)paren
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set limits, both hard and soft. Defaults to Q_SETUQLIM.&n;&t;&t; */
r_case
id|Q_XSETQLIM
suffix:colon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
id|error
op_assign
id|xfs_qm_scall_setqlim
c_func
(paren
id|mp
comma
(paren
id|xfs_dqid_t
)paren
id|id
comma
id|XFS_DQ_USER
comma
(paren
id|fs_disk_quota_t
op_star
)paren
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_XSETGQLIM
suffix:colon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
id|error
op_assign
id|xfs_qm_scall_setqlim
c_func
(paren
id|mp
comma
(paren
id|xfs_dqid_t
)paren
id|id
comma
id|XFS_DQ_GROUP
comma
(paren
id|fs_disk_quota_t
op_star
)paren
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_XGETGQUOTA
suffix:colon
id|error
op_assign
id|xfs_qm_scall_getquota
c_func
(paren
id|mp
comma
(paren
id|xfs_dqid_t
)paren
id|id
comma
id|XFS_DQ_GROUP
comma
(paren
id|fs_disk_quota_t
op_star
)paren
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Quotas are entirely undefined after quotaoff in XFS quotas.&n;&t;&t; * For instance, there&squot;s no way to set limits when quotaoff.&n;&t;&t; */
r_default
suffix:colon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Turn off quota accounting and/or enforcement for all udquots and/or&n; * gdquots. Called only at unmount time.&n; *&n; * This assumes that there are no dquots of this file system cached&n; * incore, and modifies the ondisk dquot directly. Therefore, for example,&n; * it is an error to call this twice, without purging the cache.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_scall_quotaoff
id|xfs_qm_scall_quotaoff
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|flags
comma
id|boolean_t
id|force
)paren
(brace
id|uint
id|dqtype
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
r_int
id|error
suffix:semicolon
id|uint
id|inactivate_flags
suffix:semicolon
id|xfs_qoff_logitem_t
op_star
id|qoffstart
suffix:semicolon
r_int
id|nculprits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|force
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No file system can have quotas enabled on disk but not in core.&n;&t; * Note that quota utilities (like quotaoff) _expect_&n;&t; * errno == EEXIST here.&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;m_qflags
op_amp
id|flags
)paren
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|flags
op_and_assign
(paren
id|XFS_ALL_QUOTA_ACCT
op_or
id|XFS_ALL_QUOTA_ENFD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t want to deal with two quotaoffs messing up each other,&n;&t; * so we&squot;re going to serialize it. quotaoff isn&squot;t exactly a performance&n;&t; * critical thing.&n;&t; * If quotaoff, then we must be dealing with the root filesystem.&n;&t; */
id|ASSERT
c_func
(paren
id|mp-&gt;m_quotainfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
)paren
id|mutex_lock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
comma
id|PINOD
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_quotainfo
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re just turning off quota enforcement, change mp and go.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_ALL_QUOTA_ACCT
)paren
op_eq
l_int|0
)paren
(brace
id|mp-&gt;m_qflags
op_and_assign
op_complement
(paren
id|flags
)paren
suffix:semicolon
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mp-&gt;m_sb.sb_qflags
op_assign
id|mp-&gt;m_qflags
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX what to do if error ? Revert back to old vals incore ? */
id|error
op_assign
id|xfs_qm_write_sb_changes
c_func
(paren
id|mp
comma
id|XFS_SB_QFLAGS
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|dqtype
op_assign
l_int|0
suffix:semicolon
id|inactivate_flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If accounting is off, we must turn enforcement off, clear the&n;&t; * quota &squot;CHKD&squot; certificate to make it known that we have to&n;&t; * do a quotacheck the next time this quota is turned on.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_UQUOTA_ACCT
)paren
(brace
id|dqtype
op_or_assign
id|XFS_QMOPT_UQUOTA
suffix:semicolon
id|flags
op_or_assign
(paren
id|XFS_UQUOTA_CHKD
op_or
id|XFS_UQUOTA_ENFD
)paren
suffix:semicolon
id|inactivate_flags
op_or_assign
id|XFS_UQUOTA_ACTIVE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_GQUOTA_ACCT
)paren
(brace
id|dqtype
op_or_assign
id|XFS_QMOPT_GQUOTA
suffix:semicolon
id|flags
op_or_assign
(paren
id|XFS_GQUOTA_CHKD
op_or
id|XFS_GQUOTA_ENFD
)paren
suffix:semicolon
id|inactivate_flags
op_or_assign
id|XFS_GQUOTA_ACTIVE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Nothing to do?  Don&squot;t complain. This happens when we&squot;re just&n;&t; * turning off quota enforcement.&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;m_qflags
op_amp
id|flags
)paren
op_eq
l_int|0
)paren
(brace
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Write the LI_QUOTAOFF log record, and do SB changes atomically,&n;&t; * and synchronously.&n;&t; */
id|xfs_qm_log_quotaoff
c_func
(paren
id|mp
comma
op_amp
id|qoffstart
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next we clear the XFS_MOUNT_*DQ_ACTIVE bit(s) in the mount struct&n;&t; * to take care of the race between dqget and quotaoff. We don&squot;t take&n;&t; * any special locks to reset these bits. All processes need to check&n;&t; * these bits *after* taking inode lock(s) to see if the particular&n;&t; * quota type is in the process of being turned off. If *ACTIVE, it is&n;&t; * guaranteed that all dquot structures and all quotainode ptrs will all&n;&t; * stay valid as long as that inode is kept locked.&n;&t; *&n;&t; * There is no turning back after this.&n;&t; */
id|mp-&gt;m_qflags
op_and_assign
op_complement
id|inactivate_flags
suffix:semicolon
multiline_comment|/*&n;&t; * Give back all the dquot reference(s) held by inodes.&n;&t; * Here we go thru every single incore inode in this file system, and&n;&t; * do a dqrele on the i_udquot/i_gdquot that it may have.&n;&t; * Essentially, as long as somebody has an inode locked, this guarantees&n;&t; * that quotas will not be turned off. This is handy because in a&n;&t; * transaction once we lock the inode(s) and check for quotaon, we can&n;&t; * depend on the quota inodes (and other things) being valid as long as&n;&t; * we keep the lock(s).&n;&t; */
id|xfs_qm_dqrele_all_inodes
c_func
(paren
id|mp
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Next we make the changes in the quota flag in the mount struct.&n;&t; * This isn&squot;t protected by a particular lock directly, because we&n;&t; * don&squot;t want to take a mrlock everytime we depend on quotas being on.&n;&t; */
id|mp-&gt;m_qflags
op_and_assign
op_complement
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go through all the dquots of this file system and purge them,&n;&t; * according to what was turned off. We may not be able to get rid&n;&t; * of all dquots, because dquots can have temporary references that&n;&t; * are not attached to inodes. eg. xfs_setattr, xfs_create.&n;&t; * So, if we couldn&squot;t purge all the dquots from the filesystem,&n;&t; * we can&squot;t get rid of the incore data structures.&n;&t; */
r_while
c_loop
(paren
(paren
id|nculprits
op_assign
id|xfs_qm_dqpurge_all
c_func
(paren
id|mp
comma
id|dqtype
op_or
id|XFS_QMOPT_QUOTAOFF
)paren
)paren
)paren
id|delay
c_func
(paren
l_int|10
op_star
id|nculprits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Transactions that had started before ACTIVE state bit was cleared&n;&t; * could have logged many dquots, so they&squot;d have higher LSNs than&n;&t; * the first QUOTAOFF log record does. If we happen to crash when&n;&t; * the tail of the log has gone past the QUOTAOFF record, but&n;&t; * before the last dquot modification, those dquots __will__&n;&t; * recover, and that&squot;s not good.&n;&t; *&n;&t; * So, we have QUOTAOFF start and end logitems; the start&n;&t; * logitem won&squot;t get overwritten until the end logitem appears...&n;&t; */
id|xfs_qm_log_quotaoff_end
c_func
(paren
id|mp
comma
id|qoffstart
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If quotas is completely disabled, close shop.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_MOUNT_QUOTA_ALL
)paren
op_eq
id|XFS_MOUNT_QUOTA_ALL
)paren
(brace
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
id|xfs_qm_destroy_quotainfo
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release our quotainode references, and vn_purge them,&n;&t; * if we don&squot;t need them anymore.&n;&t; */
r_if
c_cond
(paren
(paren
id|dqtype
op_amp
id|XFS_QMOPT_UQUOTA
)paren
op_logical_and
id|XFS_QI_UQIP
c_func
(paren
id|mp
)paren
)paren
(brace
id|XFS_PURGE_INODE
c_func
(paren
id|XFS_QI_UQIP
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|XFS_QI_UQIP
c_func
(paren
id|mp
)paren
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dqtype
op_amp
id|XFS_QMOPT_GQUOTA
)paren
op_logical_and
id|XFS_QI_GQIP
c_func
(paren
id|mp
)paren
)paren
(brace
id|XFS_PURGE_INODE
c_func
(paren
id|XFS_QI_GQIP
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|XFS_QI_GQIP
c_func
(paren
id|mp
)paren
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_scall_trunc_qfiles
id|xfs_qm_scall_trunc_qfiles
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|flags
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_inode_t
op_star
id|qip
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
op_logical_or
id|flags
op_eq
l_int|0
)paren
(brace
id|qdprintk
c_func
(paren
l_string|&quot;qtrunc flags=%x m_qflags=%x&bslash;n&quot;
comma
id|flags
comma
id|mp-&gt;m_qflags
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_DQ_USER
)paren
op_logical_and
id|mp-&gt;m_sb.sb_uquotino
op_ne
id|NULLFSINO
)paren
(brace
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|mp-&gt;m_sb.sb_uquotino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|qip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
(paren
r_void
)paren
id|xfs_truncate_file
c_func
(paren
id|mp
comma
id|qip
)paren
suffix:semicolon
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|qip
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_DQ_GROUP
)paren
op_logical_and
id|mp-&gt;m_sb.sb_gquotino
op_ne
id|NULLFSINO
)paren
(brace
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|mp-&gt;m_sb.sb_gquotino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|qip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
(paren
r_void
)paren
id|xfs_truncate_file
c_func
(paren
id|mp
comma
id|qip
)paren
suffix:semicolon
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|qip
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Switch on (a given) quota enforcement for a filesystem.  This takes&n; * effect immediately.&n; * (Switching on quota accounting must be done at mount time.)&n; */
id|STATIC
r_int
DECL|function|xfs_qm_scall_quotaon
id|xfs_qm_scall_quotaon
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|uint
id|flags
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|uint
id|qf
suffix:semicolon
id|uint
id|accflags
suffix:semicolon
id|__int64_t
id|sbflags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
id|flags
op_and_assign
(paren
id|XFS_ALL_QUOTA_ACCT
op_or
id|XFS_ALL_QUOTA_ENFD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Switching on quota accounting must be done at mount time.&n;&t; */
id|accflags
op_assign
id|flags
op_amp
id|XFS_ALL_QUOTA_ACCT
suffix:semicolon
id|flags
op_and_assign
op_complement
(paren
id|XFS_ALL_QUOTA_ACCT
)paren
suffix:semicolon
id|sbflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
)paren
(brace
id|qdprintk
c_func
(paren
l_string|&quot;quotaon: zero flags, m_qflags=%x&bslash;n&quot;
comma
id|mp-&gt;m_qflags
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* No fs can turn on quotas with a delayed effect */
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|XFS_ALL_QUOTA_ACCT
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Can&squot;t enforce without accounting. We check the superblock&n;&t; * qflags here instead of m_qflags because rootfs can have&n;&t; * quota acct on ondisk without m_qflags&squot; knowing.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|flags
op_amp
id|XFS_UQUOTA_ACCT
)paren
op_eq
l_int|0
op_logical_and
(paren
id|mp-&gt;m_sb.sb_qflags
op_amp
id|XFS_UQUOTA_ACCT
)paren
op_eq
l_int|0
op_logical_and
(paren
id|flags
op_amp
id|XFS_UQUOTA_ENFD
)paren
)paren
op_logical_or
(paren
(paren
id|flags
op_amp
id|XFS_GQUOTA_ACCT
)paren
op_eq
l_int|0
op_logical_and
(paren
id|mp-&gt;m_sb.sb_qflags
op_amp
id|XFS_GQUOTA_ACCT
)paren
op_eq
l_int|0
op_logical_and
(paren
id|flags
op_amp
id|XFS_GQUOTA_ENFD
)paren
)paren
)paren
(brace
id|qdprintk
c_func
(paren
l_string|&quot;Can&squot;t enforce without acct, flags=%x sbflags=%x&bslash;n&quot;
comma
id|flags
comma
id|mp-&gt;m_sb.sb_qflags
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If everything&squot;s upto-date incore, then don&squot;t waste time.&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;m_qflags
op_amp
id|flags
)paren
op_eq
id|flags
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Change sb_qflags on disk but not incore mp-&gt;qflags&n;&t; * if this is the root filesystem.&n;&t; */
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|qf
op_assign
id|mp-&gt;m_sb.sb_qflags
suffix:semicolon
id|mp-&gt;m_sb.sb_qflags
op_assign
id|qf
op_or
id|flags
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There&squot;s nothing to change if it&squot;s the same.&n;&t; */
r_if
c_cond
(paren
(paren
id|qf
op_amp
id|flags
)paren
op_eq
id|flags
op_logical_and
id|sbflags
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
id|sbflags
op_or_assign
id|XFS_SB_QFLAGS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_write_sb_changes
c_func
(paren
id|mp
comma
id|sbflags
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we aren&squot;t trying to switch on quota enforcement, we are done.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|mp-&gt;m_sb.sb_qflags
op_amp
id|XFS_UQUOTA_ACCT
)paren
op_ne
(paren
id|mp-&gt;m_qflags
op_amp
id|XFS_UQUOTA_ACCT
)paren
)paren
op_logical_or
(paren
id|flags
op_amp
id|XFS_ALL_QUOTA_ENFD
)paren
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ESRCH
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Switch on quota enforcement in core.&n;&t; */
id|mutex_lock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
comma
id|PINOD
)paren
suffix:semicolon
id|mp-&gt;m_qflags
op_or_assign
(paren
id|flags
op_amp
id|XFS_ALL_QUOTA_ENFD
)paren
suffix:semicolon
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return quota status information, such as uquota-off, enforcements, etc.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_scall_getqstat
id|xfs_qm_scall_getqstat
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|fs_quota_stat_t
op_star
id|out
)paren
(brace
id|xfs_inode_t
op_star
id|uip
comma
op_star
id|gip
suffix:semicolon
id|boolean_t
id|tempuqip
comma
id|tempgqip
suffix:semicolon
id|uip
op_assign
id|gip
op_assign
l_int|NULL
suffix:semicolon
id|tempuqip
op_assign
id|tempgqip
op_assign
id|B_FALSE
suffix:semicolon
id|memset
c_func
(paren
id|out
comma
l_int|0
comma
r_sizeof
(paren
id|fs_quota_stat_t
)paren
)paren
suffix:semicolon
id|out-&gt;qs_version
op_assign
id|FS_QSTAT_VERSION
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|out-&gt;qs_uquota.qfs_ino
op_assign
id|NULLFSINO
suffix:semicolon
id|out-&gt;qs_gquota.qfs_ino
op_assign
id|NULLFSINO
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|out-&gt;qs_flags
op_assign
(paren
id|__uint16_t
)paren
id|xfs_qm_export_flags
c_func
(paren
id|mp-&gt;m_qflags
op_amp
(paren
id|XFS_ALL_QUOTA_ACCT
op_or
id|XFS_ALL_QUOTA_ENFD
)paren
)paren
suffix:semicolon
id|out-&gt;qs_pad
op_assign
l_int|0
suffix:semicolon
id|out-&gt;qs_uquota.qfs_ino
op_assign
id|mp-&gt;m_sb.sb_uquotino
suffix:semicolon
id|out-&gt;qs_gquota.qfs_ino
op_assign
id|mp-&gt;m_sb.sb_gquotino
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
)paren
(brace
id|uip
op_assign
id|mp-&gt;m_quotainfo-&gt;qi_uquotaip
suffix:semicolon
id|gip
op_assign
id|mp-&gt;m_quotainfo-&gt;qi_gquotaip
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|uip
op_logical_and
id|mp-&gt;m_sb.sb_uquotino
op_ne
id|NULLFSINO
)paren
(brace
r_if
c_cond
(paren
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|mp-&gt;m_sb.sb_uquotino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|uip
comma
l_int|0
)paren
op_eq
l_int|0
)paren
id|tempuqip
op_assign
id|B_TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|gip
op_logical_and
id|mp-&gt;m_sb.sb_gquotino
op_ne
id|NULLFSINO
)paren
(brace
r_if
c_cond
(paren
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|mp-&gt;m_sb.sb_gquotino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|gip
comma
l_int|0
)paren
op_eq
l_int|0
)paren
id|tempgqip
op_assign
id|B_TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uip
)paren
(brace
id|out-&gt;qs_uquota.qfs_nblks
op_assign
id|uip-&gt;i_d.di_nblocks
suffix:semicolon
id|out-&gt;qs_uquota.qfs_nextents
op_assign
id|uip-&gt;i_d.di_nextents
suffix:semicolon
r_if
c_cond
(paren
id|tempuqip
)paren
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|uip
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gip
)paren
(brace
id|out-&gt;qs_gquota.qfs_nblks
op_assign
id|gip-&gt;i_d.di_nblocks
suffix:semicolon
id|out-&gt;qs_gquota.qfs_nextents
op_assign
id|gip-&gt;i_d.di_nextents
suffix:semicolon
r_if
c_cond
(paren
id|tempgqip
)paren
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|gip
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
)paren
(brace
id|out-&gt;qs_incoredqs
op_assign
id|XFS_QI_MPLNDQUOTS
c_func
(paren
id|mp
)paren
suffix:semicolon
id|out-&gt;qs_btimelimit
op_assign
id|XFS_QI_BTIMELIMIT
c_func
(paren
id|mp
)paren
suffix:semicolon
id|out-&gt;qs_itimelimit
op_assign
id|XFS_QI_ITIMELIMIT
c_func
(paren
id|mp
)paren
suffix:semicolon
id|out-&gt;qs_rtbtimelimit
op_assign
id|XFS_QI_RTBTIMELIMIT
c_func
(paren
id|mp
)paren
suffix:semicolon
id|out-&gt;qs_bwarnlimit
op_assign
id|XFS_QI_BWARNLIMIT
c_func
(paren
id|mp
)paren
suffix:semicolon
id|out-&gt;qs_iwarnlimit
op_assign
id|XFS_QI_IWARNLIMIT
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust quota limits, and start/stop timers accordingly.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_scall_setqlim
id|xfs_qm_scall_setqlim
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
id|fs_disk_quota_t
op_star
id|newlim
)paren
(brace
id|xfs_disk_dquot_t
op_star
id|ddq
suffix:semicolon
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_qcnt_t
id|hard
comma
id|soft
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newlim-&gt;d_fieldmask
op_amp
(paren
id|FS_DQ_LIMIT_MASK
op_or
id|FS_DQ_TIMER_MASK
)paren
)paren
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_QM_SETQLIM
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_disk_dquot_t
)paren
op_plus
l_int|128
comma
l_int|0
comma
l_int|0
comma
id|XFS_DEFAULT_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t want to race with a quotaoff so take the quotaoff lock.&n;&t; * (We don&squot;t hold an inode lock, so there&squot;s nothing else to stop&n;&t; * a quotaoff from happening). (XXXThis doesn&squot;t currently happen&n;&t; * because we take the vfslock before calling xfs_qm_sysent).&n;&t; */
id|mutex_lock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
comma
id|PINOD
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the dquot (locked), and join it to the transaction.&n;&t; * Allocate the dquot if this doesn&squot;t exist.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|id
comma
id|type
comma
id|XFS_QMOPT_DQALLOC
comma
op_amp
id|dqp
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOENT
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;Q_SETQLIM: AFT DQGET&quot;
)paren
suffix:semicolon
id|xfs_trans_dqjoin
c_func
(paren
id|tp
comma
id|dqp
)paren
suffix:semicolon
id|ddq
op_assign
op_amp
id|dqp-&gt;q_core
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that hardlimits are &gt;= soft limits before changing.&n;&t; */
id|hard
op_assign
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_BHARD
)paren
ques
c_cond
(paren
id|xfs_qcnt_t
)paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|newlim-&gt;d_blk_hardlimit
)paren
suffix:colon
id|INT_GET
c_func
(paren
id|ddq-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|soft
op_assign
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_BSOFT
)paren
ques
c_cond
(paren
id|xfs_qcnt_t
)paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|newlim-&gt;d_blk_softlimit
)paren
suffix:colon
id|INT_GET
c_func
(paren
id|ddq-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hard
op_eq
l_int|0
op_logical_or
id|hard
op_ge
id|soft
)paren
(brace
id|INT_SET
c_func
(paren
id|ddq-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
comma
id|hard
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
comma
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
id|mp-&gt;m_quotainfo-&gt;qi_bhardlimit
op_assign
id|hard
suffix:semicolon
id|mp-&gt;m_quotainfo-&gt;qi_bsoftlimit
op_assign
id|soft
suffix:semicolon
)brace
)brace
r_else
(brace
id|qdprintk
c_func
(paren
l_string|&quot;blkhard %Ld &lt; blksoft %Ld&bslash;n&quot;
comma
id|hard
comma
id|soft
)paren
suffix:semicolon
)brace
id|hard
op_assign
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_RTBHARD
)paren
ques
c_cond
(paren
id|xfs_qcnt_t
)paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|newlim-&gt;d_rtb_hardlimit
)paren
suffix:colon
id|INT_GET
c_func
(paren
id|ddq-&gt;d_rtb_hardlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|soft
op_assign
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_RTBSOFT
)paren
ques
c_cond
(paren
id|xfs_qcnt_t
)paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|newlim-&gt;d_rtb_softlimit
)paren
suffix:colon
id|INT_GET
c_func
(paren
id|ddq-&gt;d_rtb_softlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hard
op_eq
l_int|0
op_logical_or
id|hard
op_ge
id|soft
)paren
(brace
id|INT_SET
c_func
(paren
id|ddq-&gt;d_rtb_hardlimit
comma
id|ARCH_CONVERT
comma
id|hard
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_rtb_softlimit
comma
id|ARCH_CONVERT
comma
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
id|mp-&gt;m_quotainfo-&gt;qi_rtbhardlimit
op_assign
id|hard
suffix:semicolon
id|mp-&gt;m_quotainfo-&gt;qi_rtbsoftlimit
op_assign
id|soft
suffix:semicolon
)brace
)brace
r_else
(brace
id|qdprintk
c_func
(paren
l_string|&quot;rtbhard %Ld &lt; rtbsoft %Ld&bslash;n&quot;
comma
id|hard
comma
id|soft
)paren
suffix:semicolon
)brace
id|hard
op_assign
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_IHARD
)paren
ques
c_cond
(paren
id|xfs_qcnt_t
)paren
id|newlim-&gt;d_ino_hardlimit
suffix:colon
id|INT_GET
c_func
(paren
id|ddq-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|soft
op_assign
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_ISOFT
)paren
ques
c_cond
(paren
id|xfs_qcnt_t
)paren
id|newlim-&gt;d_ino_softlimit
suffix:colon
id|INT_GET
c_func
(paren
id|ddq-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hard
op_eq
l_int|0
op_logical_or
id|hard
op_ge
id|soft
)paren
(brace
id|INT_SET
c_func
(paren
id|ddq-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
comma
id|hard
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
comma
id|soft
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
id|mp-&gt;m_quotainfo-&gt;qi_ihardlimit
op_assign
id|hard
suffix:semicolon
id|mp-&gt;m_quotainfo-&gt;qi_isoftlimit
op_assign
id|soft
suffix:semicolon
)brace
)brace
r_else
(brace
id|qdprintk
c_func
(paren
l_string|&quot;ihard %Ld &lt; isoft %Ld&bslash;n&quot;
comma
id|hard
comma
id|soft
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Timelimits for the super user set the relative time&n;&t;&t; * the other users can be over quota for this file system.&n;&t;&t; * If it is zero a default is used.  Ditto for the default&n;&t;&t; * soft and hard limit values (already done, above).&n;&t;&t; */
r_if
c_cond
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_BTIMER
)paren
(brace
id|mp-&gt;m_quotainfo-&gt;qi_btimelimit
op_assign
id|newlim-&gt;d_btimer
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_btimer
comma
id|ARCH_CONVERT
comma
id|newlim-&gt;d_btimer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_ITIMER
)paren
(brace
id|mp-&gt;m_quotainfo-&gt;qi_itimelimit
op_assign
id|newlim-&gt;d_itimer
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_itimer
comma
id|ARCH_CONVERT
comma
id|newlim-&gt;d_itimer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newlim-&gt;d_fieldmask
op_amp
id|FS_DQ_RTBTIMER
)paren
(brace
id|mp-&gt;m_quotainfo-&gt;qi_rtbtimelimit
op_assign
id|newlim-&gt;d_rtbtimer
suffix:semicolon
id|INT_SET
c_func
(paren
id|ddq-&gt;d_rtbtimer
comma
id|ARCH_CONVERT
comma
id|newlim-&gt;d_rtbtimer
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (XFS_IS_QUOTA_ENFORCED(mp)) */
(brace
multiline_comment|/*&n;&t;&t; * If the user is now over quota, start the timelimit.&n;&t;&t; * The user will not be &squot;warned&squot;.&n;&t;&t; * Note that we keep the timers ticking, whether enforcement&n;&t;&t; * is on or off. We don&squot;t really want to bother with iterating&n;&t;&t; * over all ondisk dquots and turning the timers on/off.&n;&t;&t; */
id|xfs_qm_adjust_dqtimers
c_func
(paren
id|mp
comma
id|ddq
)paren
suffix:semicolon
)brace
id|dqp-&gt;dq_flags
op_or_assign
id|XFS_DQ_DIRTY
suffix:semicolon
id|xfs_trans_log_dquot
c_func
(paren
id|tp
comma
id|dqp
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;Q_SETQLIM: COMMIT&quot;
)paren
suffix:semicolon
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_qm_dqprint
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_dqrele
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|XFS_QI_QOFFLOCK
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_scall_getquota
id|xfs_qm_scall_getquota
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
id|fs_disk_quota_t
op_star
id|out
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Try to get the dquot. We don&squot;t want it allocated on disk, so&n;&t; * we aren&squot;t passing the XFS_QMOPT_DOALLOC flag. If it doesn&squot;t&n;&t; * exist, we&squot;ll get ENOENT back.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|id
comma
id|type
comma
l_int|0
comma
op_amp
id|dqp
)paren
)paren
)paren
(brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;Q_GETQUOTA SUCCESS&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If everything&squot;s NULL, this dquot doesn&squot;t quite exist as far as&n;&t; * our utility programs are concerned.&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_DQUOT_UNINITIALIZED
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_qm_dqput
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/* xfs_qm_dqprint(dqp); */
multiline_comment|/*&n;&t; * Convert the disk dquot to the exportable format&n;&t; */
id|xfs_qm_export_dquot
c_func
(paren
id|mp
comma
op_amp
id|dqp-&gt;q_core
comma
id|out
)paren
suffix:semicolon
id|xfs_qm_dqput
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_return
(paren
id|error
ques
c_cond
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_log_quotaoff_end
id|xfs_qm_log_quotaoff_end
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_qoff_logitem_t
op_star
id|startqoff
comma
id|uint
id|flags
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_qoff_logitem_t
op_star
id|qoffi
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_QM_QUOTAOFF_END
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_qoff_logitem_t
)paren
op_star
l_int|2
comma
l_int|0
comma
l_int|0
comma
id|XFS_DEFAULT_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|qoffi
op_assign
id|xfs_trans_get_qoff_item
c_func
(paren
id|tp
comma
id|startqoff
comma
id|flags
op_amp
id|XFS_ALL_QUOTA_ACCT
)paren
suffix:semicolon
id|xfs_trans_log_quotaoff_item
c_func
(paren
id|tp
comma
id|qoffi
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to make sure that the transaction is secure on disk before we&n;&t; * return and actually stop quota accounting. So, make it synchronous.&n;&t; * We don&squot;t care about quotoff&squot;s performance.&n;&t; */
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_log_quotaoff
id|xfs_qm_log_quotaoff
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_qoff_logitem_t
op_star
op_star
id|qoffstartp
comma
id|uint
id|flags
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|xfs_qoff_logitem_t
op_star
id|qoffi
op_assign
l_int|NULL
suffix:semicolon
id|uint
id|oldsbqflag
op_assign
l_int|0
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_QM_QUOTAOFF
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_qoff_logitem_t
)paren
op_star
l_int|2
op_plus
id|mp-&gt;m_sb.sb_sectsize
op_plus
l_int|128
comma
l_int|0
comma
l_int|0
comma
id|XFS_DEFAULT_LOG_COUNT
)paren
)paren
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
id|qoffi
op_assign
id|xfs_trans_get_qoff_item
c_func
(paren
id|tp
comma
l_int|NULL
comma
id|flags
op_amp
id|XFS_ALL_QUOTA_ACCT
)paren
suffix:semicolon
id|xfs_trans_log_quotaoff_item
c_func
(paren
id|tp
comma
id|qoffi
)paren
suffix:semicolon
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|oldsbqflag
op_assign
id|mp-&gt;m_sb.sb_qflags
suffix:semicolon
id|mp-&gt;m_sb.sb_qflags
op_assign
(paren
id|mp-&gt;m_qflags
op_amp
op_complement
(paren
id|flags
)paren
)paren
op_amp
id|XFS_MOUNT_QUOTA_ALL
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|xfs_mod_sb
c_func
(paren
id|tp
comma
id|XFS_SB_QFLAGS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to make sure that the transaction is secure on disk before we&n;&t; * return and actually stop quota accounting. So, make it synchronous.&n;&t; * We don&squot;t care about quotoff&squot;s performance.&n;&t; */
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|error0
suffix:colon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No one else is modifying sb_qflags, so this is OK.&n;&t;&t; * We still hold the quotaofflock.&n;&t;&t; */
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mp-&gt;m_sb.sb_qflags
op_assign
id|oldsbqflag
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
)brace
op_star
id|qoffstartp
op_assign
id|qoffi
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Translate an internal style on-disk-dquot to the exportable format.&n; * The main differences are that the counters/limits are all in Basic&n; * Blocks (BBs) instead of the internal FSBs, and all on-disk data has&n; * to be converted to the native endianness.&n; */
id|STATIC
r_void
DECL|function|xfs_qm_export_dquot
id|xfs_qm_export_dquot
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_disk_dquot_t
op_star
id|src
comma
r_struct
id|fs_disk_quota
op_star
id|dst
)paren
(brace
id|memset
c_func
(paren
id|dst
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dst
)paren
)paren
suffix:semicolon
id|dst-&gt;d_version
op_assign
id|FS_DQUOT_VERSION
suffix:semicolon
multiline_comment|/* different from src-&gt;d_version */
id|dst-&gt;d_flags
op_assign
id|xfs_qm_export_qtype_flags
c_func
(paren
id|INT_GET
c_func
(paren
id|src-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dst-&gt;d_id
op_assign
id|INT_GET
c_func
(paren
id|src-&gt;d_id
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_blk_hardlimit
op_assign
(paren
id|__uint64_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|src-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dst-&gt;d_blk_softlimit
op_assign
(paren
id|__uint64_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|src-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dst-&gt;d_ino_hardlimit
op_assign
(paren
id|__uint64_t
)paren
id|INT_GET
c_func
(paren
id|src-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_ino_softlimit
op_assign
(paren
id|__uint64_t
)paren
id|INT_GET
c_func
(paren
id|src-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_bcount
op_assign
(paren
id|__uint64_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|src-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dst-&gt;d_icount
op_assign
(paren
id|__uint64_t
)paren
id|INT_GET
c_func
(paren
id|src-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_btimer
op_assign
(paren
id|__uint32_t
)paren
id|INT_GET
c_func
(paren
id|src-&gt;d_btimer
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_itimer
op_assign
(paren
id|__uint32_t
)paren
id|INT_GET
c_func
(paren
id|src-&gt;d_itimer
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_iwarns
op_assign
id|INT_GET
c_func
(paren
id|src-&gt;d_iwarns
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_bwarns
op_assign
id|INT_GET
c_func
(paren
id|src-&gt;d_bwarns
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_rtb_hardlimit
op_assign
(paren
id|__uint64_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|src-&gt;d_rtb_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dst-&gt;d_rtb_softlimit
op_assign
(paren
id|__uint64_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|src-&gt;d_rtb_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dst-&gt;d_rtbcount
op_assign
(paren
id|__uint64_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|src-&gt;d_rtbcount
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dst-&gt;d_rtbtimer
op_assign
(paren
id|__uint32_t
)paren
id|INT_GET
c_func
(paren
id|src-&gt;d_rtbtimer
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dst-&gt;d_rtbwarns
op_assign
id|INT_GET
c_func
(paren
id|src-&gt;d_rtbwarns
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Internally, we don&squot;t reset all the timers when quota enforcement&n;&t; * gets turned off. No need to confuse the userlevel code,&n;&t; * so return zeroes in that case.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ENFORCED
c_func
(paren
id|mp
)paren
)paren
(brace
id|dst-&gt;d_btimer
op_assign
l_int|0
suffix:semicolon
id|dst-&gt;d_itimer
op_assign
l_int|0
suffix:semicolon
id|dst-&gt;d_rtbtimer
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ENFORCED
c_func
(paren
id|mp
)paren
op_logical_and
id|dst-&gt;d_id
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|dst-&gt;d_bcount
op_ge
(paren
r_int
)paren
id|dst-&gt;d_blk_softlimit
)paren
op_logical_and
(paren
id|dst-&gt;d_blk_softlimit
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|dst-&gt;d_btimer
op_ne
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|dst-&gt;d_icount
op_ge
(paren
r_int
)paren
id|dst-&gt;d_ino_softlimit
)paren
op_logical_and
(paren
id|dst-&gt;d_ino_softlimit
OG
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|dst-&gt;d_itimer
op_ne
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
id|STATIC
id|uint
DECL|function|xfs_qm_import_qtype_flags
id|xfs_qm_import_qtype_flags
c_func
(paren
id|uint
id|uflags
)paren
(brace
multiline_comment|/*&n;&t; * Can&squot;t be both at the same time.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|uflags
op_amp
(paren
id|XFS_GROUP_QUOTA
op_or
id|XFS_USER_QUOTA
)paren
)paren
op_eq
(paren
id|XFS_GROUP_QUOTA
op_or
id|XFS_USER_QUOTA
)paren
)paren
op_logical_or
(paren
(paren
id|uflags
op_amp
(paren
id|XFS_GROUP_QUOTA
op_or
id|XFS_USER_QUOTA
)paren
)paren
op_eq
l_int|0
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|uflags
op_amp
id|XFS_USER_QUOTA
)paren
ques
c_cond
id|XFS_DQ_USER
suffix:colon
id|XFS_DQ_GROUP
suffix:semicolon
)brace
id|STATIC
id|uint
DECL|function|xfs_qm_export_qtype_flags
id|xfs_qm_export_qtype_flags
c_func
(paren
id|uint
id|flags
)paren
(brace
multiline_comment|/*&n;&t; * Can&squot;t be both at the same time.&n;&t; */
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
(paren
id|XFS_GROUP_QUOTA
op_or
id|XFS_USER_QUOTA
)paren
)paren
op_ne
(paren
id|XFS_GROUP_QUOTA
op_or
id|XFS_USER_QUOTA
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
(paren
id|XFS_GROUP_QUOTA
op_or
id|XFS_USER_QUOTA
)paren
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|flags
op_amp
id|XFS_DQ_USER
)paren
ques
c_cond
id|XFS_USER_QUOTA
suffix:colon
id|XFS_GROUP_QUOTA
suffix:semicolon
)brace
id|STATIC
id|uint
DECL|function|xfs_qm_import_flags
id|xfs_qm_import_flags
c_func
(paren
id|uint
id|uflags
)paren
(brace
id|uint
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|uflags
op_amp
id|XFS_QUOTA_UDQ_ACCT
)paren
id|flags
op_or_assign
id|XFS_UQUOTA_ACCT
suffix:semicolon
r_if
c_cond
(paren
id|uflags
op_amp
id|XFS_QUOTA_GDQ_ACCT
)paren
id|flags
op_or_assign
id|XFS_GQUOTA_ACCT
suffix:semicolon
r_if
c_cond
(paren
id|uflags
op_amp
id|XFS_QUOTA_UDQ_ENFD
)paren
id|flags
op_or_assign
id|XFS_UQUOTA_ENFD
suffix:semicolon
r_if
c_cond
(paren
id|uflags
op_amp
id|XFS_QUOTA_GDQ_ENFD
)paren
id|flags
op_or_assign
id|XFS_GQUOTA_ENFD
suffix:semicolon
r_return
(paren
id|flags
)paren
suffix:semicolon
)brace
id|STATIC
id|uint
DECL|function|xfs_qm_export_flags
id|xfs_qm_export_flags
c_func
(paren
id|uint
id|flags
)paren
(brace
id|uint
id|uflags
suffix:semicolon
id|uflags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_UQUOTA_ACCT
)paren
id|uflags
op_or_assign
id|XFS_QUOTA_UDQ_ACCT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_GQUOTA_ACCT
)paren
id|uflags
op_or_assign
id|XFS_QUOTA_GDQ_ACCT
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_UQUOTA_ENFD
)paren
id|uflags
op_or_assign
id|XFS_QUOTA_UDQ_ENFD
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_GQUOTA_ENFD
)paren
id|uflags
op_or_assign
id|XFS_QUOTA_GDQ_ENFD
suffix:semicolon
r_return
(paren
id|uflags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Go thru all the inodes in the file system, releasing their dquots.&n; * Note that the mount structure gets modified to indicate that quotas are off&n; * AFTER this, in the case of quotaoff. This also gets called from&n; * xfs_rootumount.&n; */
r_void
DECL|function|xfs_qm_dqrele_all_inodes
id|xfs_qm_dqrele_all_inodes
c_func
(paren
r_struct
id|xfs_mount
op_star
id|mp
comma
id|uint
id|flags
)paren
(brace
id|vmap_t
id|vmap
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
comma
op_star
id|topino
suffix:semicolon
id|uint
id|ireclaims
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|boolean_t
id|vnode_refd
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_quotainfo
)paren
suffix:semicolon
id|again
suffix:colon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ip
op_assign
id|mp-&gt;m_inodes
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* Skip markers inserted by xfs_sync */
r_if
c_cond
(paren
id|ip-&gt;i_mount
op_eq
l_int|NULL
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Root inode, rbmip and rsumip have associated blocks */
r_if
c_cond
(paren
id|ip
op_eq
id|XFS_QI_UQIP
c_func
(paren
id|mp
)paren
op_logical_or
id|ip
op_eq
id|XFS_QI_GQIP
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vp
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vnode_refd
op_assign
id|B_FALSE
suffix:semicolon
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Sample vp mapping while holding the mplock, lest&n;&t;&t;&t; * we come across a non-existent vnode.&n;&t;&t;&t; */
id|VMAP
c_func
(paren
id|vp
comma
id|vmap
)paren
suffix:semicolon
id|ireclaims
op_assign
id|mp-&gt;m_ireclaims
suffix:semicolon
id|topino
op_assign
id|mp-&gt;m_inodes
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* XXX restart limit ? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|vp
op_assign
id|vn_get
c_func
(paren
id|vp
comma
op_amp
id|vmap
)paren
)paren
)paren
r_goto
id|again
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|vnode_refd
op_assign
id|B_TRUE
suffix:semicolon
)brace
r_else
(brace
id|ireclaims
op_assign
id|mp-&gt;m_ireclaims
suffix:semicolon
id|topino
op_assign
id|mp-&gt;m_inodes
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We don&squot;t keep the mountlock across the dqrele() call,&n;&t;&t; * since it can take a while..&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_UQUOTA_ACCT
)paren
op_logical_and
id|ip-&gt;i_udquot
)paren
(brace
id|xfs_qm_dqrele
c_func
(paren
id|ip-&gt;i_udquot
)paren
suffix:semicolon
id|ip-&gt;i_udquot
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_GQUOTA_ACCT
)paren
op_logical_and
id|ip-&gt;i_gdquot
)paren
(brace
id|xfs_qm_dqrele
c_func
(paren
id|ip-&gt;i_gdquot
)paren
suffix:semicolon
id|ip-&gt;i_gdquot
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait until we&squot;ve dropped the ilock and mountlock to&n;&t;&t; * do the vn_rele. Or be condemned to an eternity in the&n;&t;&t; * inactive code in hell.&n;&t;&t; */
r_if
c_cond
(paren
id|vnode_refd
)paren
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If an inode was inserted or removed, we gotta&n;&t;&t; * start over again.&n;&t;&t; */
r_if
c_cond
(paren
id|topino
op_ne
id|mp-&gt;m_inodes
op_logical_or
id|mp-&gt;m_ireclaims
op_ne
id|ireclaims
)paren
(brace
multiline_comment|/* XXX use a sentinel */
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ip
op_ne
id|mp-&gt;m_inodes
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*------------------------------------------------------------------------*/
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * This contains all the test functions for XFS disk quotas.&n; * Currently it does a quota accounting check. ie. it walks through&n; * all inodes in the file system, calculating the dquot accounting fields,&n; * and prints out any inconsistencies.&n; */
DECL|variable|qmtest_udqtab
id|xfs_dqhash_t
op_star
id|qmtest_udqtab
suffix:semicolon
DECL|variable|qmtest_gdqtab
id|xfs_dqhash_t
op_star
id|qmtest_gdqtab
suffix:semicolon
DECL|variable|qmtest_hashmask
r_int
id|qmtest_hashmask
suffix:semicolon
DECL|variable|qmtest_nfails
r_int
id|qmtest_nfails
suffix:semicolon
DECL|variable|qcheck_lock
id|mutex_t
id|qcheck_lock
suffix:semicolon
DECL|macro|DQTEST_HASHVAL
mdefine_line|#define DQTEST_HASHVAL(mp, id) (((__psunsigned_t)(mp) + &bslash;&n;&t;&t;&t;&t; (__psunsigned_t)(id)) &amp; &bslash;&n;&t;&t;&t;&t;(qmtest_hashmask - 1))
DECL|macro|DQTEST_HASH
mdefine_line|#define DQTEST_HASH(mp, id, type)   ((type &amp; XFS_DQ_USER) ? &bslash;&n;&t;&t;&t;&t;     (qmtest_udqtab + &bslash;&n;&t;&t;&t;&t;      DQTEST_HASHVAL(mp, id)) : &bslash;&n;&t;&t;&t;&t;     (qmtest_gdqtab + &bslash;&n;&t;&t;&t;&t;      DQTEST_HASHVAL(mp, id)))
DECL|macro|DQTEST_LIST_PRINT
mdefine_line|#define DQTEST_LIST_PRINT(l, NXT, title) &bslash;&n;{ &bslash;&n;&t;  xfs_dqtest_t&t;*dqp; int i = 0;&bslash;&n;&t;  cmn_err(CE_DEBUG, &quot;%s (#%d)&quot;, title, (int) (l)-&gt;qh_nelems); &bslash;&n;&t;  for (dqp = (xfs_dqtest_t *)(l)-&gt;qh_next; dqp != NULL; &bslash;&n;&t;       dqp = (xfs_dqtest_t *)dqp-&gt;NXT) { &bslash;&n;&t;&t;cmn_err(CE_DEBUG, &quot;  %d. &bslash;&quot;%d (%s)&bslash;&quot;  bcnt = %d, icnt = %d&quot;, &bslash;&n;&t;&t;&t; ++i, dqp-&gt;d_id, DQFLAGTO_TYPESTR(dqp),&t;     &bslash;&n;&t;&t;&t; dqp-&gt;d_bcount, dqp-&gt;d_icount); } &bslash;&n;}
DECL|struct|dqtest
r_typedef
r_struct
id|dqtest
(brace
DECL|member|q_lists
id|xfs_dqmarker_t
id|q_lists
suffix:semicolon
DECL|member|q_hash
id|xfs_dqhash_t
op_star
id|q_hash
suffix:semicolon
multiline_comment|/* the hashchain header */
DECL|member|q_mount
id|xfs_mount_t
op_star
id|q_mount
suffix:semicolon
multiline_comment|/* filesystem this relates to */
DECL|member|d_id
id|xfs_dqid_t
id|d_id
suffix:semicolon
multiline_comment|/* user id or group id */
DECL|member|d_bcount
id|xfs_qcnt_t
id|d_bcount
suffix:semicolon
multiline_comment|/* # disk blocks owned by the user */
DECL|member|d_icount
id|xfs_qcnt_t
id|d_icount
suffix:semicolon
multiline_comment|/* # inodes owned by the user */
DECL|typedef|xfs_dqtest_t
)brace
id|xfs_dqtest_t
suffix:semicolon
id|STATIC
r_void
DECL|function|xfs_qm_hashinsert
id|xfs_qm_hashinsert
c_func
(paren
id|xfs_dqhash_t
op_star
id|h
comma
id|xfs_dqtest_t
op_star
id|dqp
)paren
(brace
id|xfs_dquot_t
op_star
id|d
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|d
)paren
op_assign
(paren
id|h
)paren
op_member_access_from_pointer
id|qh_next
)paren
)paren
(paren
id|d
)paren
op_member_access_from_pointer
id|HL_PREVP
op_assign
op_amp
(paren
(paren
id|dqp
)paren
op_member_access_from_pointer
id|HL_NEXT
)paren
suffix:semicolon
(paren
id|dqp
)paren
op_member_access_from_pointer
id|HL_NEXT
op_assign
id|d
suffix:semicolon
(paren
id|dqp
)paren
op_member_access_from_pointer
id|HL_PREVP
op_assign
op_amp
(paren
(paren
id|h
)paren
op_member_access_from_pointer
id|qh_next
)paren
suffix:semicolon
(paren
id|h
)paren
op_member_access_from_pointer
id|qh_next
op_assign
(paren
id|xfs_dquot_t
op_star
)paren
id|dqp
suffix:semicolon
(paren
id|h
)paren
op_member_access_from_pointer
id|qh_version
op_increment
suffix:semicolon
(paren
id|h
)paren
op_member_access_from_pointer
id|qh_nelems
op_increment
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_qm_dqtest_print
id|xfs_qm_dqtest_print
c_func
(paren
id|xfs_dqtest_t
op_star
id|d
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;-----------DQTEST DQUOT----------------&quot;
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;---- dquot ID = %d&quot;
comma
id|d-&gt;d_id
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;---- type     = %s&quot;
comma
id|XFS_QM_ISUDQ
c_func
(paren
id|d
)paren
ques
c_cond
l_string|&quot;USR&quot;
suffix:colon
l_string|&quot;GRP&quot;
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;---- fs       = 0x%p&quot;
comma
id|d-&gt;q_mount
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;---- bcount   = %Lu (0x%x)&quot;
comma
id|d-&gt;d_bcount
comma
(paren
r_int
)paren
id|d-&gt;d_bcount
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;---- icount   = %Lu (0x%x)&quot;
comma
id|d-&gt;d_icount
comma
(paren
r_int
)paren
id|d-&gt;d_icount
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;---------------------------&quot;
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_qm_dqtest_failed
id|xfs_qm_dqtest_failed
c_func
(paren
id|xfs_dqtest_t
op_star
id|d
comma
id|xfs_dquot_t
op_star
id|dqp
comma
r_char
op_star
id|reason
comma
id|xfs_qcnt_t
id|a
comma
id|xfs_qcnt_t
id|b
comma
r_int
id|error
)paren
(brace
id|qmtest_nfails
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;quotacheck failed id=%d, err=%d&bslash;nreason: %s&quot;
comma
id|INT_GET
c_func
(paren
id|d-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
id|error
comma
id|reason
)paren
suffix:semicolon
r_else
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;quotacheck failed id=%d (%s) [%d != %d]&quot;
comma
id|INT_GET
c_func
(paren
id|d-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
id|reason
comma
(paren
r_int
)paren
id|a
comma
(paren
r_int
)paren
id|b
)paren
suffix:semicolon
id|xfs_qm_dqtest_print
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqp
)paren
id|xfs_qm_dqprint
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_dqtest_cmp2
id|xfs_dqtest_cmp2
c_func
(paren
id|xfs_dqtest_t
op_star
id|d
comma
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_icount
comma
id|ARCH_CONVERT
)paren
op_ne
id|d-&gt;d_icount
)paren
(brace
id|xfs_qm_dqtest_failed
c_func
(paren
id|d
comma
id|dqp
comma
l_string|&quot;icount mismatch&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_icount
comma
id|ARCH_CONVERT
)paren
comma
id|d-&gt;d_icount
comma
l_int|0
)paren
suffix:semicolon
id|err
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_bcount
comma
id|ARCH_CONVERT
)paren
op_ne
id|d-&gt;d_bcount
)paren
(brace
id|xfs_qm_dqtest_failed
c_func
(paren
id|d
comma
id|dqp
comma
l_string|&quot;bcount mismatch&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_bcount
comma
id|ARCH_CONVERT
)paren
comma
id|d-&gt;d_bcount
comma
l_int|0
)paren
suffix:semicolon
id|err
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_bcount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|dqp-&gt;q_core.d_btimer
comma
id|ARCH_CONVERT
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;%d [%s] [0x%p] BLK TIMER NOT STARTED&quot;
comma
id|d-&gt;d_id
comma
id|DQFLAGTO_TYPESTR
c_func
(paren
id|d
)paren
comma
id|d-&gt;q_mount
)paren
suffix:semicolon
id|err
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_icount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|dqp-&gt;q_core.d_itimer
comma
id|ARCH_CONVERT
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;%d [%s] [0x%p] INO TIMER NOT STARTED&quot;
comma
id|d-&gt;d_id
comma
id|DQFLAGTO_TYPESTR
c_func
(paren
id|d
)paren
comma
id|d-&gt;q_mount
)paren
suffix:semicolon
id|err
op_increment
suffix:semicolon
)brace
)brace
macro_line|#ifdef QUOTADEBUG
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;%d [%s] [0x%p] qchecked&quot;
comma
id|d-&gt;d_id
comma
id|XFS_QM_ISUDQ
c_func
(paren
id|d
)paren
ques
c_cond
l_string|&quot;USR&quot;
suffix:colon
l_string|&quot;GRP&quot;
comma
id|d-&gt;q_mount
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_dqtest_cmp
id|xfs_dqtest_cmp
c_func
(paren
id|xfs_dqtest_t
op_star
id|d
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* xfs_qm_dqtest_print(d); */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqget
c_func
(paren
id|d-&gt;q_mount
comma
l_int|NULL
comma
id|d-&gt;d_id
comma
id|d-&gt;dq_flags
comma
l_int|0
comma
op_amp
id|dqp
)paren
)paren
)paren
(brace
id|xfs_qm_dqtest_failed
c_func
(paren
id|d
comma
l_int|NULL
comma
l_string|&quot;dqget failed&quot;
comma
l_int|0
comma
l_int|0
comma
id|error
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|xfs_dqtest_cmp2
c_func
(paren
id|d
comma
id|dqp
)paren
suffix:semicolon
id|xfs_qm_dqput
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_internalqcheck_dqget
id|xfs_qm_internalqcheck_dqget
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
id|xfs_dqtest_t
op_star
op_star
id|O_dq
)paren
(brace
id|xfs_dqtest_t
op_star
id|d
suffix:semicolon
id|xfs_dqhash_t
op_star
id|h
suffix:semicolon
id|h
op_assign
id|DQTEST_HASH
c_func
(paren
id|mp
comma
id|id
comma
id|type
)paren
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
(paren
id|xfs_dqtest_t
op_star
)paren
id|h-&gt;qh_next
suffix:semicolon
id|d
op_ne
l_int|NULL
suffix:semicolon
id|d
op_assign
(paren
id|xfs_dqtest_t
op_star
)paren
id|d-&gt;HL_NEXT
)paren
(brace
multiline_comment|/* DQTEST_LIST_PRINT(h, HL_NEXT, &quot;@@@@@ dqtestlist @@@@@&quot;); */
r_if
c_cond
(paren
id|d-&gt;d_id
op_eq
id|id
op_logical_and
id|mp
op_eq
id|d-&gt;q_mount
)paren
(brace
op_star
id|O_dq
op_assign
id|d
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|d
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xfs_dqtest_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|d-&gt;dq_flags
op_assign
id|type
suffix:semicolon
id|d-&gt;d_id
op_assign
id|id
suffix:semicolon
id|d-&gt;q_mount
op_assign
id|mp
suffix:semicolon
id|d-&gt;q_hash
op_assign
id|h
suffix:semicolon
id|xfs_qm_hashinsert
c_func
(paren
id|h
comma
id|d
)paren
suffix:semicolon
op_star
id|O_dq
op_assign
id|d
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_qm_internalqcheck_get_dquots
id|xfs_qm_internalqcheck_get_dquots
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|uid
comma
id|xfs_dqid_t
id|gid
comma
id|xfs_dqtest_t
op_star
op_star
id|ud
comma
id|xfs_dqtest_t
op_star
op_star
id|gd
)paren
(brace
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
id|xfs_qm_internalqcheck_dqget
c_func
(paren
id|mp
comma
id|uid
comma
id|XFS_DQ_USER
comma
id|ud
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
id|xfs_qm_internalqcheck_dqget
c_func
(paren
id|mp
comma
id|gid
comma
id|XFS_DQ_GROUP
comma
id|gd
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_qm_internalqcheck_dqadjust
id|xfs_qm_internalqcheck_dqadjust
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_dqtest_t
op_star
id|d
)paren
(brace
id|d-&gt;d_icount
op_increment
suffix:semicolon
id|d-&gt;d_bcount
op_add_assign
(paren
id|xfs_qcnt_t
)paren
id|ip-&gt;i_d.di_nblocks
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_qm_internalqcheck_adjust
id|xfs_qm_internalqcheck_adjust
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point for filesystem */
id|xfs_ino_t
id|ino
comma
multiline_comment|/* inode number to get data for */
r_void
id|__user
op_star
id|buffer
comma
multiline_comment|/* not used */
r_int
id|ubsize
comma
multiline_comment|/* not used */
r_void
op_star
id|private_data
comma
multiline_comment|/* not used */
id|xfs_daddr_t
id|bno
comma
multiline_comment|/* starting block of inode cluster */
r_int
op_star
id|ubused
comma
multiline_comment|/* not used */
r_void
op_star
id|dip
comma
multiline_comment|/* not used */
r_int
op_star
id|res
)paren
multiline_comment|/* bulkstat result code */
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_dqtest_t
op_star
id|ud
comma
op_star
id|gd
suffix:semicolon
id|uint
id|lock_flags
suffix:semicolon
id|boolean_t
id|ipreleased
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
id|mp-&gt;m_sb.sb_uquotino
op_logical_or
id|ino
op_eq
id|mp-&gt;m_sb.sb_gquotino
)paren
(brace
op_star
id|res
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
id|qdprintk
c_func
(paren
l_string|&quot;internalqcheck: ino=%llu, uqino=%llu, gqino=%llu&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ino
comma
(paren
r_int
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_uquotino
comma
(paren
r_int
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_gquotino
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|ipreleased
op_assign
id|B_FALSE
suffix:semicolon
id|again
suffix:colon
id|lock_flags
op_assign
id|XFS_ILOCK_SHARED
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ino
comma
l_int|0
comma
id|lock_flags
comma
op_amp
id|ip
comma
id|bno
)paren
)paren
)paren
(brace
op_star
id|res
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
(brace
id|xfs_iput_new
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
op_star
id|res
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This inode can have blocks after eof which can get released&n;&t; * when we send it to inactive. Since we don&squot;t check the dquot&n;&t; * until the after all our calculations are done, we must get rid&n;&t; * of those now.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ipreleased
)paren
(brace
id|xfs_iput
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|ipreleased
op_assign
id|B_TRUE
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|xfs_qm_internalqcheck_get_dquots
c_func
(paren
id|mp
comma
(paren
id|xfs_dqid_t
)paren
id|ip-&gt;i_d.di_uid
comma
(paren
id|xfs_dqid_t
)paren
id|ip-&gt;i_d.di_gid
comma
op_amp
id|ud
comma
op_amp
id|gd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ud
)paren
suffix:semicolon
id|xfs_qm_internalqcheck_dqadjust
c_func
(paren
id|ip
comma
id|ud
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|gd
)paren
suffix:semicolon
id|xfs_qm_internalqcheck_dqadjust
c_func
(paren
id|ip
comma
id|gd
)paren
suffix:semicolon
)brace
id|xfs_iput
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
op_star
id|res
op_assign
id|BULKSTAT_RV_DIDONE
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* PRIVATE, debugging */
r_int
DECL|function|xfs_qm_internalqcheck
id|xfs_qm_internalqcheck
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_ino_t
id|lastino
suffix:semicolon
r_int
id|done
comma
id|count
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xfs_dqtest_t
op_star
id|d
comma
op_star
id|e
suffix:semicolon
id|xfs_dqhash_t
op_star
id|h1
suffix:semicolon
r_int
id|error
suffix:semicolon
id|lastino
op_assign
l_int|0
suffix:semicolon
id|qmtest_hashmask
op_assign
l_int|32
suffix:semicolon
id|count
op_assign
l_int|5
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
id|qmtest_nfails
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ESRCH
)paren
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|mutex_lock
c_func
(paren
op_amp
id|qcheck_lock
comma
id|PINOD
)paren
suffix:semicolon
multiline_comment|/* There should be absolutely no quota activity while this&n;&t;   is going on. */
id|qmtest_udqtab
op_assign
id|kmem_zalloc
c_func
(paren
id|qmtest_hashmask
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|qmtest_gdqtab
op_assign
id|kmem_zalloc
c_func
(paren
id|qmtest_hashmask
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Iterate thru all the inodes in the file system,&n;&t;&t; * adjusting the corresponding dquot counters&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bulkstat
c_func
(paren
id|mp
comma
op_amp
id|lastino
comma
op_amp
id|count
comma
id|xfs_qm_internalqcheck_adjust
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
id|BULKSTAT_FG_IGET
comma
op_amp
id|done
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;Bulkstat returned error 0x%x&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;Checking results against system dquots&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|qmtest_hashmask
suffix:semicolon
id|i
op_increment
)paren
(brace
id|h1
op_assign
op_amp
id|qmtest_udqtab
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
(paren
id|xfs_dqtest_t
op_star
)paren
id|h1-&gt;qh_next
suffix:semicolon
id|d
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
id|xfs_dqtest_cmp
c_func
(paren
id|d
)paren
suffix:semicolon
id|e
op_assign
(paren
id|xfs_dqtest_t
op_star
)paren
id|d-&gt;HL_NEXT
suffix:semicolon
id|kmem_free
c_func
(paren
id|d
comma
r_sizeof
(paren
id|xfs_dqtest_t
)paren
)paren
suffix:semicolon
id|d
op_assign
id|e
suffix:semicolon
)brace
id|h1
op_assign
op_amp
id|qmtest_gdqtab
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|d
op_assign
(paren
id|xfs_dqtest_t
op_star
)paren
id|h1-&gt;qh_next
suffix:semicolon
id|d
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
id|xfs_dqtest_cmp
c_func
(paren
id|d
)paren
suffix:semicolon
id|e
op_assign
(paren
id|xfs_dqtest_t
op_star
)paren
id|d-&gt;HL_NEXT
suffix:semicolon
id|kmem_free
c_func
(paren
id|d
comma
r_sizeof
(paren
id|xfs_dqtest_t
)paren
)paren
suffix:semicolon
id|d
op_assign
id|e
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|qmtest_nfails
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;******** quotacheck failed  ********&quot;
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;failures = %d&quot;
comma
id|qmtest_nfails
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;******** quotacheck successful! ********&quot;
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|qmtest_udqtab
comma
id|qmtest_hashmask
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|qmtest_gdqtab
comma
id|qmtest_hashmask
op_star
r_sizeof
(paren
id|xfs_dqhash_t
)paren
)paren
suffix:semicolon
id|mutex_unlock
c_func
(paren
op_amp
id|qcheck_lock
)paren
suffix:semicolon
r_return
(paren
id|qmtest_nfails
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
eof
