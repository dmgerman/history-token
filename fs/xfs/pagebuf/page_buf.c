multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; *&t;page_buf.c&n; *&n; *&t;The page_buf module provides an abstract buffer cache model on top of&n; *&t;the Linux page cache.  Cached metadata blocks for a file system are&n; *&t;hashed to the inode for the block device.  The page_buf module&n; *&t;assembles buffer (page_buf_t) objects on demand to aggregate such&n; *&t;cached pages for I/O.&n; *&n; *&n; *      Written by Steve Lord, Jim Mostek, Russell Cattelan&n; *&t;&t;    and Rajagopal Ananthanarayanan (&quot;ananth&quot;) at SGI.&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/bio.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/workqueue.h&gt;
macro_line|#include &lt;linux/suspend.h&gt;
macro_line|#include &lt;support/debug.h&gt;
macro_line|#include &lt;support/kmem.h&gt;
macro_line|#include &quot;page_buf_internal.h&quot;
DECL|macro|BBSHIFT
mdefine_line|#define BBSHIFT&t;&t;9
DECL|macro|BN_ALIGN_MASK
mdefine_line|#define BN_ALIGN_MASK&t;((1 &lt;&lt; (PAGE_CACHE_SHIFT - BBSHIFT)) - 1)
macro_line|#ifndef GFP_READAHEAD
DECL|macro|GFP_READAHEAD
mdefine_line|#define GFP_READAHEAD&t;(__GFP_NOWARN|__GFP_NORETRY)
macro_line|#endif
multiline_comment|/*&n; * Debug code&n; */
macro_line|#ifdef PAGEBUF_TRACE
DECL|variable|pb_trace_lock
r_static
id|spinlock_t
id|pb_trace_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|pb_trace
r_struct
id|pagebuf_trace_buf
id|pb_trace
suffix:semicolon
DECL|variable|pb_trace
id|EXPORT_SYMBOL
c_func
(paren
id|pb_trace
)paren
suffix:semicolon
DECL|variable|pb_trace_func
id|EXPORT_SYMBOL
c_func
(paren
id|pb_trace_func
)paren
suffix:semicolon
DECL|macro|CIRC_INC
mdefine_line|#define CIRC_INC(i)&t;(((i) + 1) &amp; (PB_TRACE_BUFSIZE - 1))
r_void
DECL|function|pb_trace_func
id|pb_trace_func
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_int
id|event
comma
r_void
op_star
id|misc
comma
r_void
op_star
id|ra
)paren
(brace
r_int
id|j
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pb_params.debug.val
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ra
op_eq
l_int|NULL
)paren
id|ra
op_assign
(paren
r_void
op_star
)paren
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pb_trace_lock
comma
id|flags
)paren
suffix:semicolon
id|j
op_assign
id|pb_trace.start
suffix:semicolon
id|pb_trace.start
op_assign
id|CIRC_INC
c_func
(paren
id|j
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pb_trace_lock
comma
id|flags
)paren
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|pb
op_assign
(paren
r_int
r_int
)paren
id|pb
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|event
op_assign
id|event
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|flags
op_assign
id|pb-&gt;pb_flags
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|hold
op_assign
id|pb-&gt;pb_hold.counter
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|lock_value
op_assign
id|pb-&gt;pb_sema.count.counter
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|task
op_assign
(paren
r_void
op_star
)paren
id|current
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|misc
op_assign
id|misc
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|ra
op_assign
id|ra
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|offset
op_assign
id|pb-&gt;pb_file_offset
suffix:semicolon
id|pb_trace.buf
(braket
id|j
)braket
dot
id|size
op_assign
id|pb-&gt;pb_buffer_length
suffix:semicolon
)brace
macro_line|#endif&t;/* PAGEBUF_TRACE */
multiline_comment|/*&n; *&t;File wide globals&n; */
DECL|variable|pagebuf_cache
id|STATIC
id|kmem_cache_t
op_star
id|pagebuf_cache
suffix:semicolon
id|STATIC
r_void
id|pagebuf_daemon_wakeup
c_func
(paren
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|pagebuf_delwri_queue
c_func
(paren
id|page_buf_t
op_star
comma
r_int
)paren
suffix:semicolon
DECL|variable|pagebuf_logio_workqueue
id|STATIC
r_struct
id|workqueue_struct
op_star
id|pagebuf_logio_workqueue
suffix:semicolon
DECL|variable|pagebuf_dataio_workqueue
id|STATIC
r_struct
id|workqueue_struct
op_star
id|pagebuf_dataio_workqueue
suffix:semicolon
multiline_comment|/*&n; * Pagebuf module configuration parameters, exported via&n; * /proc/sys/vm/pagebuf&n; */
DECL|variable|pb_params
id|pagebuf_param_t
id|pb_params
op_assign
(brace
multiline_comment|/*&t;MIN&t;DFLT&t;MAX&t;*/
dot
id|flush_interval
op_assign
(brace
id|HZ
op_div
l_int|2
comma
id|HZ
comma
l_int|30
op_star
id|HZ
)brace
comma
dot
id|age_buffer
op_assign
(brace
l_int|1
op_star
id|HZ
comma
l_int|15
op_star
id|HZ
comma
l_int|300
op_star
id|HZ
)brace
comma
dot
id|stats_clear
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|1
)brace
comma
dot
id|debug
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|1
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Pagebuf statistics variables&n; */
DECL|variable|pbstats
r_struct
id|pbstats
id|pbstats
suffix:semicolon
multiline_comment|/*&n; * Pagebuf allocation / freeing.&n; */
DECL|macro|pb_to_gfp
mdefine_line|#define pb_to_gfp(flags) &bslash;&n;&t;(((flags) &amp; PBF_READ_AHEAD) ? GFP_READAHEAD : &bslash;&n;&t; ((flags) &amp; PBF_DONT_BLOCK) ? GFP_NOFS : GFP_KERNEL)
DECL|macro|pagebuf_allocate
mdefine_line|#define pagebuf_allocate(flags) &bslash;&n;&t;kmem_cache_alloc(pagebuf_cache, pb_to_gfp(flags))
DECL|macro|pagebuf_deallocate
mdefine_line|#define pagebuf_deallocate(pb) &bslash;&n;&t;kmem_cache_free(pagebuf_cache, (pb));
multiline_comment|/*&n; * Pagebuf hashing&n; */
DECL|macro|NBITS
mdefine_line|#define NBITS&t;8
DECL|macro|NHASH
mdefine_line|#define NHASH&t;(1&lt;&lt;NBITS)
r_typedef
r_struct
(brace
DECL|member|pb_hash
r_struct
id|list_head
id|pb_hash
suffix:semicolon
DECL|member|pb_count
r_int
id|pb_count
suffix:semicolon
DECL|member|pb_hash_lock
id|spinlock_t
id|pb_hash_lock
suffix:semicolon
DECL|typedef|pb_hash_t
)brace
id|pb_hash_t
suffix:semicolon
DECL|variable|pbhash
id|STATIC
id|pb_hash_t
id|pbhash
(braket
id|NHASH
)braket
suffix:semicolon
DECL|macro|pb_hash
mdefine_line|#define pb_hash(pb)&t;&amp;pbhash[pb-&gt;pb_hash_index]
id|STATIC
r_int
DECL|function|_bhash
id|_bhash
c_func
(paren
id|dev_t
id|dev
comma
id|loff_t
id|base
)paren
(brace
r_int
id|bit
comma
id|hval
suffix:semicolon
id|base
op_rshift_assign
l_int|9
suffix:semicolon
multiline_comment|/*&n;&t; * dev_t is 16 bits, loff_t is always 64 bits&n;&t; */
id|base
op_xor_assign
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|bit
op_assign
id|hval
op_assign
l_int|0
suffix:semicolon
id|base
op_logical_and
id|bit
OL
r_sizeof
(paren
id|base
)paren
op_star
l_int|8
suffix:semicolon
id|bit
op_add_assign
id|NBITS
)paren
(brace
id|hval
op_xor_assign
(paren
r_int
)paren
id|base
op_amp
(paren
id|NHASH
op_minus
l_int|1
)paren
suffix:semicolon
id|base
op_rshift_assign
id|NBITS
suffix:semicolon
)brace
r_return
id|hval
suffix:semicolon
)brace
multiline_comment|/*&n; * Mapping of multi-page buffers into contiguous virtual space&n; */
id|STATIC
r_void
op_star
id|pagebuf_mapout_locked
c_func
(paren
id|page_buf_t
op_star
)paren
suffix:semicolon
DECL|struct|a_list
r_typedef
r_struct
id|a_list
(brace
DECL|member|vm_addr
r_void
op_star
id|vm_addr
suffix:semicolon
DECL|member|next
r_struct
id|a_list
op_star
id|next
suffix:semicolon
DECL|typedef|a_list_t
)brace
id|a_list_t
suffix:semicolon
DECL|variable|as_free_head
id|STATIC
id|a_list_t
op_star
id|as_free_head
suffix:semicolon
DECL|variable|as_list_len
id|STATIC
r_int
id|as_list_len
suffix:semicolon
DECL|variable|as_lock
id|STATIC
id|spinlock_t
id|as_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Try to batch vunmaps because they are costly.&n; */
id|STATIC
r_void
DECL|function|free_address
id|free_address
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
id|a_list_t
op_star
id|aentry
suffix:semicolon
id|aentry
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|a_list_t
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aentry
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
id|aentry-&gt;next
op_assign
id|as_free_head
suffix:semicolon
id|aentry-&gt;vm_addr
op_assign
id|addr
suffix:semicolon
id|as_free_head
op_assign
id|aentry
suffix:semicolon
id|as_list_len
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|vunmap
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
)brace
id|STATIC
r_void
DECL|function|purge_addresses
id|purge_addresses
c_func
(paren
r_void
)paren
(brace
id|a_list_t
op_star
id|aentry
comma
op_star
id|old
suffix:semicolon
r_if
c_cond
(paren
id|as_free_head
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
id|aentry
op_assign
id|as_free_head
suffix:semicolon
id|as_free_head
op_assign
l_int|NULL
suffix:semicolon
id|as_list_len
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|as_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|old
op_assign
id|aentry
)paren
op_ne
l_int|NULL
)paren
(brace
id|vunmap
c_func
(paren
id|aentry-&gt;vm_addr
)paren
suffix:semicolon
id|aentry
op_assign
id|aentry-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|old
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Locking model:&n; *&n; *&t;Buffers associated with inodes for which buffer locking&n; *&t;is not enabled are not protected by semaphores, and are&n; *&t;assumed to be exclusively owned by the caller.  There is&n; *&t;spinlock in the buffer, for use by the caller when concurrent&n; *&t;access is possible.&n; */
multiline_comment|/*&n; *&t;Internal pagebuf object manipulation&n; */
id|STATIC
r_void
DECL|function|_pagebuf_initialize
id|_pagebuf_initialize
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
id|pb_target_t
op_star
id|target
comma
id|loff_t
id|range_base
comma
r_int
id|range_length
comma
id|page_buf_flags_t
id|flags
)paren
(brace
multiline_comment|/*&n;&t; * We don&squot;t want certain flags to appear in pb-&gt;pb_flags.&n;&t; */
id|flags
op_and_assign
op_complement
(paren
id|PBF_LOCK
op_or
id|PBF_MAPPED
op_or
id|PBF_DONT_BLOCK
op_or
id|PBF_READ_AHEAD
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pb
comma
l_int|0
comma
r_sizeof
(paren
id|page_buf_t
)paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pb-&gt;pb_hold
comma
l_int|1
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|pb-&gt;pb_iodonesema
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
)paren
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
suffix:semicolon
multiline_comment|/* held, no waiters */
id|PB_SET_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pb-&gt;pb_target
op_assign
id|target
suffix:semicolon
id|pb-&gt;pb_file_offset
op_assign
id|range_base
suffix:semicolon
multiline_comment|/*&n;&t; * Set buffer_length and count_desired to the same value initially.&n;&t; * IO routines should use count_desired, which will be the same in&n;&t; * most cases but may be reset (e.g. XFS recovery).&n;&t; */
id|pb-&gt;pb_buffer_length
op_assign
id|pb-&gt;pb_count_desired
op_assign
id|range_length
suffix:semicolon
id|pb-&gt;pb_flags
op_assign
id|flags
op_or
id|PBF_NONE
suffix:semicolon
id|pb-&gt;pb_bn
op_assign
id|PAGE_BUF_DADDR_NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
)paren
suffix:semicolon
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_create
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|get
)paren
comma
id|target
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a page array capable of holding a specified number&n; * of pages, and point the page buf at it.&n; */
id|STATIC
r_int
DECL|function|_pagebuf_get_pages
id|_pagebuf_get_pages
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_int
id|page_count
comma
id|page_buf_flags_t
id|flags
)paren
(brace
r_int
id|gpf_mask
op_assign
id|pb_to_gfp
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Make sure that we have a page list */
r_if
c_cond
(paren
id|pb-&gt;pb_pages
op_eq
l_int|NULL
)paren
(brace
id|pb-&gt;pb_offset
op_assign
id|page_buf_poff
c_func
(paren
id|pb-&gt;pb_file_offset
)paren
suffix:semicolon
id|pb-&gt;pb_page_count
op_assign
id|page_count
suffix:semicolon
r_if
c_cond
(paren
id|page_count
op_le
id|PB_PAGES
)paren
(brace
id|pb-&gt;pb_pages
op_assign
id|pb-&gt;pb_page_array
suffix:semicolon
)brace
r_else
(brace
id|pb-&gt;pb_pages
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|page_count
comma
id|gpf_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_pages
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|pb-&gt;pb_pages
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|page
op_star
)paren
op_star
id|page_count
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Walk a pagebuf releasing all the pages contained within it.&n; */
id|STATIC
r_inline
r_void
DECL|function|_pagebuf_freepages
id|_pagebuf_freepages
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
r_int
id|buf_index
suffix:semicolon
r_for
c_loop
(paren
id|buf_index
op_assign
l_int|0
suffix:semicolon
id|buf_index
OL
id|pb-&gt;pb_page_count
suffix:semicolon
id|buf_index
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|buf_index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|pb-&gt;pb_pages
(braket
id|buf_index
)braket
op_assign
l_int|NULL
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_pages
op_ne
id|pb-&gt;pb_page_array
)paren
id|kfree
c_func
(paren
id|pb-&gt;pb_pages
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;_pagebuf_free_object&n; *&n; *&t;_pagebuf_free_object releases the contents specified buffer.&n; *&t;The modification state of any associated pages is left unchanged.&n; */
r_void
DECL|function|_pagebuf_free_object
id|_pagebuf_free_object
c_func
(paren
id|pb_hash_t
op_star
id|hash
comma
multiline_comment|/* hash bucket for buffer */
id|page_buf_t
op_star
id|pb
)paren
multiline_comment|/* buffer to deallocate&t;*/
(brace
id|page_buf_flags_t
id|pb_flags
op_assign
id|pb-&gt;pb_flags
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|free_obj
)paren
comma
l_int|0
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_FREED
suffix:semicolon
r_if
c_cond
(paren
id|hash
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
)paren
)paren
(brace
id|hash-&gt;pb_count
op_decrement
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|hash-&gt;pb_hash_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pb_flags
op_amp
id|PBF_FREED
)paren
)paren
(brace
multiline_comment|/* release any virtual mapping */
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_ADDR_ALLOCATED
)paren
(brace
r_void
op_star
id|vaddr
op_assign
id|pagebuf_mapout_locked
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vaddr
)paren
(brace
id|free_address
c_func
(paren
id|vaddr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_MEM_ALLOCATED
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_pages
)paren
(brace
multiline_comment|/* release the pages in the address list */
r_if
c_cond
(paren
id|pb-&gt;pb_pages
(braket
l_int|0
)braket
op_logical_and
id|PageSlab
c_func
(paren
id|pb-&gt;pb_pages
(braket
l_int|0
)braket
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * This came from the slab&n;&t;&t;&t;&t;&t; * allocator free it as such&n;&t;&t;&t;&t;&t; */
id|kfree
c_func
(paren
id|pb-&gt;pb_addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|_pagebuf_freepages
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
id|pb-&gt;pb_pages
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|_PBF_MEM_ALLOCATED
suffix:semicolon
)brace
)brace
id|pagebuf_deallocate
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;_pagebuf_lookup_pages&n; *&n; *&t;_pagebuf_lookup_pages finds all pages which match the buffer&n; *&t;in question and the range of file offsets supplied,&n; *&t;and builds the page list for the buffer, if the&n; *&t;page list is not already formed or if not all of the pages are&n; *&t;already in the list. Invalid pages (pages which have not yet been&n; *&t;read in from disk) are assigned for any pages which are not found.&n; */
id|STATIC
r_int
DECL|function|_pagebuf_lookup_pages
id|_pagebuf_lookup_pages
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_struct
id|address_space
op_star
id|aspace
comma
id|page_buf_flags_t
id|flags
)paren
(brace
id|loff_t
id|next_buffer_offset
suffix:semicolon
r_int
r_int
id|page_count
comma
id|pi
comma
id|index
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|gfp_mask
comma
id|retry_count
op_assign
l_int|5
comma
id|rval
op_assign
l_int|0
suffix:semicolon
r_int
id|all_mapped
comma
id|good_pages
comma
id|nbytes
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|sectorshift
suffix:semicolon
r_int
id|size
comma
id|offset
suffix:semicolon
multiline_comment|/* For pagebufs where we want to map an address, do not use&n;&t; * highmem pages - so that we do not need to use kmap resources&n;&t; * to access the data.&n;&t; *&n;&t; * For pages where the caller has indicated there may be resource&n;&t; * contention (e.g. called from a transaction) do not flush&n;&t; * delalloc pages to obtain memory.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_READ_AHEAD
)paren
(brace
id|gfp_mask
op_assign
id|GFP_READAHEAD
suffix:semicolon
id|retry_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_DONT_BLOCK
)paren
(brace
id|gfp_mask
op_assign
id|GFP_NOFS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_MAPPABLE
)paren
(brace
id|gfp_mask
op_assign
id|GFP_KERNEL
suffix:semicolon
)brace
r_else
(brace
id|gfp_mask
op_assign
id|GFP_HIGHUSER
suffix:semicolon
)brace
id|next_buffer_offset
op_assign
id|pb-&gt;pb_file_offset
op_plus
id|pb-&gt;pb_buffer_length
suffix:semicolon
id|good_pages
op_assign
id|page_count
op_assign
(paren
id|page_buf_btoc
c_func
(paren
id|next_buffer_offset
)paren
op_minus
id|page_buf_btoct
c_func
(paren
id|pb-&gt;pb_file_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_ALL_PAGES_MAPPED
)paren
(brace
multiline_comment|/* Bring pages forward in cache */
r_for
c_loop
(paren
id|pi
op_assign
l_int|0
suffix:semicolon
id|pi
OL
id|page_count
suffix:semicolon
id|pi
op_increment
)paren
(brace
id|mark_page_accessed
c_func
(paren
id|pb-&gt;pb_pages
(braket
id|pi
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|PBF_MAPPED
)paren
op_logical_and
op_logical_neg
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_MAPPED
)paren
)paren
(brace
id|all_mapped
op_assign
l_int|1
suffix:semicolon
r_goto
id|mapit
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Ensure pb_pages field has been initialised */
id|rval
op_assign
id|_pagebuf_get_pages
c_func
(paren
id|pb
comma
id|page_count
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
id|rval
op_assign
id|pi
op_assign
l_int|0
suffix:semicolon
id|blocksize
op_assign
id|pb-&gt;pb_target-&gt;pbr_bsize
suffix:semicolon
id|sectorshift
op_assign
id|pb-&gt;pb_target-&gt;pbr_sshift
suffix:semicolon
id|size
op_assign
id|pb-&gt;pb_count_desired
suffix:semicolon
id|offset
op_assign
id|pb-&gt;pb_offset
suffix:semicolon
multiline_comment|/* Enter the pages in the page list */
id|index
op_assign
(paren
id|pb-&gt;pb_file_offset
op_minus
id|pb-&gt;pb_offset
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_for
c_loop
(paren
id|all_mapped
op_assign
l_int|1
suffix:semicolon
id|pi
OL
id|page_count
suffix:semicolon
id|pi
op_increment
comma
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_pages
(braket
id|pi
)braket
op_eq
l_int|0
)paren
(brace
id|retry
suffix:colon
id|page
op_assign
id|find_or_create_page
c_func
(paren
id|aspace
comma
id|index
comma
id|gfp_mask
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|retry_count
OG
l_int|0
)paren
(brace
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_page_retries
)paren
suffix:semicolon
id|pagebuf_daemon_wakeup
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|rval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|all_mapped
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_page_found
)paren
suffix:semicolon
id|mark_page_accessed
c_func
(paren
id|page
)paren
suffix:semicolon
id|pb-&gt;pb_pages
(braket
id|pi
)braket
op_assign
id|page
suffix:semicolon
)brace
r_else
(brace
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|pi
)braket
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|nbytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OG
id|size
)paren
id|nbytes
op_assign
id|size
suffix:semicolon
id|size
op_sub_assign
id|nbytes
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|blocksize
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_READ
)paren
id|pb-&gt;pb_locked
op_assign
l_int|1
suffix:semicolon
id|good_pages
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
(brace
r_int
r_int
id|i
comma
id|range
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * In this case page-&gt;private holds a bitmap&n;&t;&t;&t;&t; * of uptodate sectors within the page&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|blocksize
OL
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|range
op_assign
(paren
id|offset
op_plus
id|nbytes
)paren
op_rshift
id|sectorshift
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|offset
op_rshift
id|sectorshift
suffix:semicolon
id|i
OL
id|range
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|page
op_member_access_from_pointer
r_private
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|range
)paren
id|good_pages
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|good_pages
op_decrement
suffix:semicolon
)brace
)brace
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pb-&gt;pb_locked
)paren
(brace
r_for
c_loop
(paren
id|pi
op_assign
l_int|0
suffix:semicolon
id|pi
OL
id|page_count
suffix:semicolon
id|pi
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_pages
(braket
id|pi
)braket
)paren
id|unlock_page
c_func
(paren
id|pb-&gt;pb_pages
(braket
id|pi
)braket
)paren
suffix:semicolon
)brace
)brace
id|mapit
suffix:colon
id|pb-&gt;pb_flags
op_or_assign
id|_PBF_MEM_ALLOCATED
suffix:semicolon
r_if
c_cond
(paren
id|all_mapped
)paren
(brace
id|pb-&gt;pb_flags
op_or_assign
id|_PBF_ALL_PAGES_MAPPED
suffix:semicolon
multiline_comment|/* A single page buffer is always mappable */
r_if
c_cond
(paren
id|page_count
op_eq
l_int|1
)paren
(brace
id|pb-&gt;pb_addr
op_assign
(paren
id|caddr_t
)paren
id|page_address
c_func
(paren
id|pb-&gt;pb_pages
(braket
l_int|0
)braket
)paren
op_plus
id|pb-&gt;pb_offset
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_MAPPED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_MAPPED
)paren
(brace
r_if
c_cond
(paren
id|as_list_len
OG
l_int|64
)paren
id|purge_addresses
c_func
(paren
)paren
suffix:semicolon
id|pb-&gt;pb_addr
op_assign
id|vmap
c_func
(paren
id|pb-&gt;pb_pages
comma
id|page_count
comma
id|VM_MAP
comma
id|PAGE_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_addr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pb-&gt;pb_addr
op_add_assign
id|pb-&gt;pb_offset
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_MAPPED
op_or
id|_PBF_ADDR_ALLOCATED
suffix:semicolon
)brace
)brace
multiline_comment|/* If some pages were found with data in them&n;&t; * we are not in PBF_NONE state.&n;&t; */
r_if
c_cond
(paren
id|good_pages
op_ne
l_int|0
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_NONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|good_pages
op_ne
id|page_count
)paren
(brace
id|pb-&gt;pb_flags
op_or_assign
id|PBF_PARTIAL
suffix:semicolon
)brace
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|look_pg
)paren
comma
id|good_pages
)paren
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Finding and Reading Buffers&n; */
multiline_comment|/*&n; *&t;_pagebuf_find&n; *&n; *&t;Looks up, and creates if absent, a lockable buffer for&n; *&t;a given range of an inode.  The buffer is returned&n; *&t;locked.&t; If other overlapping buffers exist, they are&n; *&t;released before the new buffer is created and locked,&n; *&t;which may imply that this call will block until those buffers&n; *&t;are unlocked.  No I/O is implied by this call.&n; */
id|STATIC
id|page_buf_t
op_star
DECL|function|_pagebuf_find
id|_pagebuf_find
c_func
(paren
multiline_comment|/* find buffer for block&t;*/
id|pb_target_t
op_star
id|target
comma
multiline_comment|/* target for block&t;&t;*/
id|loff_t
id|ioff
comma
multiline_comment|/* starting offset of range&t;*/
r_int
id|isize
comma
multiline_comment|/* length of range&t;&t;*/
id|page_buf_flags_t
id|flags
comma
multiline_comment|/* PBF_TRYLOCK&t;&t;&t;*/
id|page_buf_t
op_star
id|new_pb
)paren
multiline_comment|/* newly allocated buffer&t;*/
(brace
id|loff_t
id|range_base
suffix:semicolon
r_int
id|range_length
suffix:semicolon
r_int
id|hval
suffix:semicolon
id|pb_hash_t
op_star
id|h
suffix:semicolon
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|page_buf_t
op_star
id|pb
suffix:semicolon
r_int
id|not_locked
suffix:semicolon
id|range_base
op_assign
(paren
id|ioff
op_lshift
id|BBSHIFT
)paren
suffix:semicolon
id|range_length
op_assign
(paren
id|isize
op_lshift
id|BBSHIFT
)paren
suffix:semicolon
multiline_comment|/* Ensure we never do IOs smaller than the sector size */
id|BUG_ON
c_func
(paren
id|range_length
OL
(paren
l_int|1
op_lshift
id|target-&gt;pbr_sshift
)paren
)paren
suffix:semicolon
multiline_comment|/* Ensure we never do IOs that are not sector aligned */
id|BUG_ON
c_func
(paren
id|range_base
op_amp
(paren
id|loff_t
)paren
id|target-&gt;pbr_smask
)paren
suffix:semicolon
id|hval
op_assign
id|_bhash
c_func
(paren
id|target-&gt;pbr_bdev-&gt;bd_dev
comma
id|range_base
)paren
suffix:semicolon
id|h
op_assign
op_amp
id|pbhash
(braket
id|hval
)braket
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|p
comma
op_amp
id|h-&gt;pb_hash
)paren
(brace
id|pb
op_assign
id|list_entry
c_func
(paren
id|p
comma
id|page_buf_t
comma
id|pb_hash_list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|target
op_eq
id|pb-&gt;pb_target
)paren
op_logical_and
(paren
id|pb-&gt;pb_file_offset
op_eq
id|range_base
)paren
op_logical_and
(paren
id|pb-&gt;pb_buffer_length
op_eq
id|range_length
)paren
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_FREED
)paren
r_break
suffix:semicolon
multiline_comment|/* If we look at something bring it to the&n;&t;&t;&t; * front of the list for next time&n;&t;&t;&t; */
id|list_del
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|pb-&gt;pb_hash_list
comma
op_amp
id|h-&gt;pb_hash
)paren
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
)brace
multiline_comment|/* No match found */
r_if
c_cond
(paren
id|new_pb
)paren
(brace
id|_pagebuf_initialize
c_func
(paren
id|new_pb
comma
id|target
comma
id|range_base
comma
id|range_length
comma
id|flags
op_or
id|_PBF_LOCKABLE
)paren
suffix:semicolon
id|new_pb-&gt;pb_hash_index
op_assign
id|hval
suffix:semicolon
id|h-&gt;pb_count
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|new_pb-&gt;pb_hash_list
comma
op_amp
id|h-&gt;pb_hash
)paren
suffix:semicolon
)brace
r_else
(brace
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_miss_locked
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
r_return
(paren
id|new_pb
)paren
suffix:semicolon
id|found
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
multiline_comment|/* Attempt to get the semaphore without sleeping,&n;&t; * if this does not work then we need to drop the&n;&t; * spinlock and do a hard attempt on the semaphore.&n;&t; */
id|not_locked
op_assign
id|down_trylock
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
suffix:semicolon
r_if
c_cond
(paren
id|not_locked
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PBF_TRYLOCK
)paren
)paren
(brace
multiline_comment|/* wait for buffer ownership */
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|get_lk
)paren
comma
l_int|0
)paren
suffix:semicolon
id|pagebuf_lock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_get_locked_waited
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We asked for a trylock and failed, no need&n;&t;&t;&t; * to look at file offset and length here, we&n;&t;&t;&t; * know that this pagebuf at least overlaps our&n;&t;&t;&t; * pagebuf and is locked, therefore our buffer&n;&t;&t;&t; * either does not exist, or is this buffer&n;&t;&t;&t; */
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_busy_locked
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* trylock worked */
id|PB_SET_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_STALE
)paren
id|pb-&gt;pb_flags
op_and_assign
id|PBF_MAPPABLE
op_or
"&bslash;"
id|PBF_MAPPED
op_or
"&bslash;"
id|_PBF_LOCKABLE
op_or
"&bslash;"
id|_PBF_ALL_PAGES_MAPPED
op_or
"&bslash;"
id|_PBF_ADDR_ALLOCATED
op_or
"&bslash;"
id|_PBF_MEM_ALLOCATED
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|got_lk
)paren
comma
l_int|0
)paren
suffix:semicolon
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_get_locked
)paren
suffix:semicolon
r_return
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_find&n; *&n; *&t;pagebuf_find returns a buffer matching the specified range of&n; *&t;data for the specified target, if any of the relevant blocks&n; *&t;are in memory.  The buffer may have unallocated holes, if&n; *&t;some, but not all, of the blocks are in memory.  Even where&n; *&t;pages are present in the buffer, not all of every page may be&n; *&t;valid.&n; */
id|page_buf_t
op_star
DECL|function|pagebuf_find
id|pagebuf_find
c_func
(paren
multiline_comment|/* find buffer for block&t;*/
multiline_comment|/* if the block is in memory&t;*/
id|pb_target_t
op_star
id|target
comma
multiline_comment|/* target for block&t;&t;*/
id|loff_t
id|ioff
comma
multiline_comment|/* starting offset of range&t;*/
r_int
id|isize
comma
multiline_comment|/* length of range&t;&t;*/
id|page_buf_flags_t
id|flags
)paren
multiline_comment|/* PBF_TRYLOCK&t;&t;&t;*/
(brace
r_return
id|_pagebuf_find
c_func
(paren
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_get&n; *&n; *&t;pagebuf_get assembles a buffer covering the specified range.&n; *&t;Some or all of the blocks in the range may be valid.  Storage&n; *&t;in memory for all portions of the buffer will be allocated,&n; *&t;although backing storage may not be.  If PBF_READ is set in&n; *&t;flags, pagebuf_iostart is called also.&n; */
id|page_buf_t
op_star
DECL|function|pagebuf_get
id|pagebuf_get
c_func
(paren
multiline_comment|/* allocate a buffer&t;&t;*/
id|pb_target_t
op_star
id|target
comma
multiline_comment|/* target for buffer&t;&t;*/
id|loff_t
id|ioff
comma
multiline_comment|/* starting offset of range&t;*/
r_int
id|isize
comma
multiline_comment|/* length of range&t;&t;*/
id|page_buf_flags_t
id|flags
)paren
multiline_comment|/* PBF_TRYLOCK&t;&t;&t;*/
(brace
id|page_buf_t
op_star
id|pb
comma
op_star
id|new_pb
suffix:semicolon
r_int
id|error
suffix:semicolon
id|new_pb
op_assign
id|pagebuf_allocate
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|new_pb
)paren
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|pb
op_assign
id|_pagebuf_find
c_func
(paren
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
comma
id|new_pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb
op_ne
id|new_pb
)paren
(brace
id|pagebuf_deallocate
c_func
(paren
id|new_pb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|pb
)paren
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_get
)paren
suffix:semicolon
multiline_comment|/* fill in any missing pages */
id|error
op_assign
id|_pagebuf_lookup_pages
c_func
(paren
id|pb
comma
id|pb-&gt;pb_target-&gt;pbr_mapping
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
)paren
)paren
(brace
id|pagebuf_free
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Always fill in the block number now, the mapped cases can do&n;&t; * their own overlay of this later.&n;&t; */
id|pb-&gt;pb_bn
op_assign
id|ioff
suffix:semicolon
id|pb-&gt;pb_count_desired
op_assign
id|pb-&gt;pb_buffer_length
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_READ
)paren
(brace
r_if
c_cond
(paren
id|PBF_NOT_DONE
c_func
(paren
id|pb
)paren
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|get_read
)paren
comma
id|flags
)paren
suffix:semicolon
id|PB_STATS_INC
c_func
(paren
id|pbstats.pb_get_read
)paren
suffix:semicolon
id|pagebuf_iostart
c_func
(paren
id|pb
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_ASYNC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Read ahead call which is already satisfied,&n;&t;&t;&t; * drop the buffer&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|PBF_LOCK
op_or
id|PBF_TRYLOCK
)paren
)paren
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We do not want read in the flags */
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_READ
suffix:semicolon
)brace
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|get_obj
)paren
comma
id|flags
)paren
suffix:semicolon
r_return
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a skeletal pagebuf (no pages associated with it).&n; */
id|page_buf_t
op_star
DECL|function|pagebuf_lookup
id|pagebuf_lookup
c_func
(paren
r_struct
id|pb_target
op_star
id|target
comma
id|loff_t
id|ioff
comma
r_int
id|isize
comma
id|page_buf_flags_t
id|flags
)paren
(brace
id|page_buf_t
op_star
id|pb
suffix:semicolon
id|pb
op_assign
id|pagebuf_allocate
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb
)paren
(brace
id|_pagebuf_initialize
c_func
(paren
id|pb
comma
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|pb
suffix:semicolon
)brace
multiline_comment|/*&n; * If we are not low on memory then do the readahead in a deadlock&n; * safe manner.&n; */
r_void
DECL|function|pagebuf_readahead
id|pagebuf_readahead
c_func
(paren
id|pb_target_t
op_star
id|target
comma
id|loff_t
id|ioff
comma
r_int
id|isize
comma
id|page_buf_flags_t
id|flags
)paren
(brace
r_struct
id|backing_dev_info
op_star
id|bdi
suffix:semicolon
id|bdi
op_assign
id|target-&gt;pbr_mapping-&gt;backing_dev_info
suffix:semicolon
r_if
c_cond
(paren
id|bdi_read_congested
c_func
(paren
id|bdi
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|bdi_write_congested
c_func
(paren
id|bdi
)paren
)paren
r_return
suffix:semicolon
id|flags
op_or_assign
(paren
id|PBF_TRYLOCK
op_or
id|PBF_READ
op_or
id|PBF_ASYNC
op_or
id|PBF_MAPPABLE
op_or
id|PBF_READ_AHEAD
)paren
suffix:semicolon
id|pagebuf_get
c_func
(paren
id|target
comma
id|ioff
comma
id|isize
comma
id|flags
)paren
suffix:semicolon
)brace
id|page_buf_t
op_star
DECL|function|pagebuf_get_empty
id|pagebuf_get_empty
c_func
(paren
r_int
id|len
comma
id|pb_target_t
op_star
id|target
)paren
(brace
id|page_buf_t
op_star
id|pb
suffix:semicolon
id|pb
op_assign
id|pagebuf_allocate
c_func
(paren
id|_PBF_LOCKABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb
)paren
id|_pagebuf_initialize
c_func
(paren
id|pb
comma
id|target
comma
l_int|0
comma
id|len
comma
id|_PBF_LOCKABLE
)paren
suffix:semicolon
r_return
id|pb
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|page
op_star
DECL|function|mem_to_page
id|mem_to_page
c_func
(paren
r_void
op_star
id|addr
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|addr
OL
id|VMALLOC_START
)paren
op_logical_or
(paren
(paren
r_int
r_int
)paren
id|addr
op_ge
id|VMALLOC_END
)paren
)paren
(brace
r_return
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|vmalloc_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
)brace
)brace
r_int
DECL|function|pagebuf_associate_memory
id|pagebuf_associate_memory
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_void
op_star
id|mem
comma
r_int
id|len
)paren
(brace
r_int
id|rval
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|ptr
suffix:semicolon
r_int
id|end
comma
id|end_cur
suffix:semicolon
id|off_t
id|offset
suffix:semicolon
r_int
id|page_count
suffix:semicolon
id|page_count
op_assign
id|PAGE_CACHE_ALIGN
c_func
(paren
id|len
)paren
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|offset
op_assign
(paren
id|off_t
)paren
id|mem
op_minus
(paren
(paren
id|off_t
)paren
id|mem
op_amp
id|PAGE_CACHE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_logical_and
(paren
id|len
OG
id|PAGE_CACHE_SIZE
)paren
)paren
id|page_count
op_increment
suffix:semicolon
multiline_comment|/* Free any previous set of page pointers */
r_if
c_cond
(paren
id|pb-&gt;pb_pages
op_logical_and
(paren
id|pb-&gt;pb_pages
op_ne
id|pb-&gt;pb_page_array
)paren
)paren
(brace
id|kfree
c_func
(paren
id|pb-&gt;pb_pages
)paren
suffix:semicolon
)brace
id|pb-&gt;pb_pages
op_assign
l_int|NULL
suffix:semicolon
id|pb-&gt;pb_addr
op_assign
id|mem
suffix:semicolon
id|rval
op_assign
id|_pagebuf_get_pages
c_func
(paren
id|pb
comma
id|page_count
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
)paren
r_return
id|rval
suffix:semicolon
id|pb-&gt;pb_offset
op_assign
id|offset
suffix:semicolon
id|ptr
op_assign
(paren
r_int
)paren
id|mem
op_amp
id|PAGE_CACHE_MASK
suffix:semicolon
id|end
op_assign
id|PAGE_CACHE_ALIGN
c_func
(paren
(paren
r_int
)paren
id|mem
op_plus
id|len
)paren
suffix:semicolon
id|end_cur
op_assign
id|end
suffix:semicolon
multiline_comment|/* set up first page */
id|pb-&gt;pb_pages
(braket
l_int|0
)braket
op_assign
id|mem_to_page
c_func
(paren
id|mem
)paren
suffix:semicolon
id|ptr
op_add_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|pb-&gt;pb_page_count
op_assign
op_increment
id|i
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|end
)paren
(brace
id|pb-&gt;pb_pages
(braket
id|i
)braket
op_assign
id|mem_to_page
c_func
(paren
(paren
r_void
op_star
)paren
id|ptr
)paren
suffix:semicolon
id|pb-&gt;pb_page_count
op_assign
op_increment
id|i
suffix:semicolon
id|ptr
op_add_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
)brace
id|pb-&gt;pb_locked
op_assign
l_int|0
suffix:semicolon
id|pb-&gt;pb_count_desired
op_assign
id|pb-&gt;pb_buffer_length
op_assign
id|len
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_MAPPED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|page_buf_t
op_star
DECL|function|pagebuf_get_no_daddr
id|pagebuf_get_no_daddr
c_func
(paren
r_int
id|len
comma
id|pb_target_t
op_star
id|target
)paren
(brace
r_int
id|rval
suffix:semicolon
r_void
op_star
id|rmem
op_assign
l_int|NULL
suffix:semicolon
id|page_buf_flags_t
id|flags
op_assign
id|_PBF_LOCKABLE
op_or
id|PBF_FORCEIO
suffix:semicolon
id|page_buf_t
op_star
id|pb
suffix:semicolon
r_int
id|tlen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0x20000
)paren
r_return
l_int|NULL
suffix:semicolon
id|pb
op_assign
id|pagebuf_allocate
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pb
)paren
r_return
l_int|NULL
suffix:semicolon
id|_pagebuf_initialize
c_func
(paren
id|pb
comma
id|target
comma
l_int|0
comma
id|len
comma
id|flags
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tlen
op_eq
l_int|0
)paren
(brace
id|tlen
op_assign
id|len
suffix:semicolon
multiline_comment|/* first time */
)brace
r_else
(brace
id|kfree
c_func
(paren
id|rmem
)paren
suffix:semicolon
multiline_comment|/* free the mem from the previous try */
id|tlen
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* double the size and try again */
)brace
r_if
c_cond
(paren
(paren
id|rmem
op_assign
id|kmalloc
c_func
(paren
id|tlen
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|pagebuf_free
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
r_int
)paren
id|rmem
op_ne
(paren
(paren
r_int
)paren
id|rmem
op_amp
op_complement
id|target-&gt;pbr_smask
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rval
op_assign
id|pagebuf_associate_memory
c_func
(paren
id|pb
comma
id|rmem
comma
id|len
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|rmem
)paren
suffix:semicolon
id|pagebuf_free
c_func
(paren
id|pb
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* otherwise pagebuf_free just ignores it */
id|pb-&gt;pb_flags
op_or_assign
id|_PBF_MEM_ALLOCATED
suffix:semicolon
id|PB_CLEAR_OWNER
c_func
(paren
id|pb
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|pb-&gt;pb_sema
)paren
suffix:semicolon
multiline_comment|/* Return unlocked pagebuf */
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|no_daddr
)paren
comma
id|rmem
)paren
suffix:semicolon
r_return
id|pb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_hold&n; *&n; *&t;Increment reference count on buffer, to hold the buffer concurrently&n; *&t;with another thread which may release (free) the buffer asynchronously.&n; *&n; *&t;Must hold the buffer already to call this function.&n; */
r_void
DECL|function|pagebuf_hold
id|pagebuf_hold
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|hold
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_free&n; *&n; *&t;pagebuf_free releases the specified buffer.  The modification&n; *&t;state of any associated pages is left unchanged.&n; */
r_void
DECL|function|pagebuf_free
id|pagebuf_free
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_LOCKABLE
)paren
(brace
id|pb_hash_t
op_star
id|h
op_assign
id|pb_hash
c_func
(paren
id|pb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
id|_pagebuf_free_object
c_func
(paren
id|h
comma
id|pb
)paren
suffix:semicolon
)brace
r_else
(brace
id|_pagebuf_free_object
c_func
(paren
l_int|NULL
comma
id|pb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;pagebuf_rele&n; *&n; *&t;pagebuf_rele releases a hold on the specified buffer.  If the&n; *&t;the hold count is 1, pagebuf_rele calls pagebuf_free.&n; */
r_void
DECL|function|pagebuf_rele
id|pagebuf_rele
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
id|pb_hash_t
op_star
id|h
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|rele
)paren
comma
id|pb-&gt;pb_relse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_LOCKABLE
)paren
(brace
id|h
op_assign
id|pb_hash
c_func
(paren
id|pb
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|h
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
)paren
(brace
r_int
id|do_free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_relse
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
)paren
id|spin_unlock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
(paren
op_star
(paren
id|pb-&gt;pb_relse
)paren
)paren
(paren
id|pb
)paren
suffix:semicolon
id|do_free
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
(brace
id|pb-&gt;pb_flags
op_or_assign
id|PBF_ASYNC
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
r_if
c_cond
(paren
id|h
op_logical_and
id|do_free
)paren
id|spin_unlock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
id|pagebuf_delwri_queue
c_func
(paren
id|pb
comma
l_int|0
)paren
suffix:semicolon
id|do_free
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_FS_MANAGED
)paren
(brace
r_if
c_cond
(paren
id|h
)paren
id|spin_unlock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
id|do_free
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_free
)paren
(brace
id|_pagebuf_free_object
c_func
(paren
id|h
comma
id|pb
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|h
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|h-&gt;pb_hash_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Pinning Buffer Storage in Memory&n; */
multiline_comment|/*&n; *&t;pagebuf_pin&n; *&n; *&t;pagebuf_pin locks all of the memory represented by a buffer in&n; *&t;memory.  Multiple calls to pagebuf_pin and pagebuf_unpin, for&n; *&t;the same or different buffers affecting a given page, will&n; *&t;properly count the number of outstanding &quot;pin&quot; requests.  The&n; *&t;buffer may be released after the pagebuf_pin and a different&n; *&t;buffer used when calling pagebuf_unpin, if desired.&n; *&t;pagebuf_pin should be used by the file system when it wants be&n; *&t;assured that no attempt will be made to force the affected&n; *&t;memory to disk.&t; It does not assure that a given logical page&n; *&t;will not be moved to a different physical page.&n; */
r_void
DECL|function|pagebuf_pin
id|pagebuf_pin
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|pin
)paren
comma
id|pb-&gt;pb_pin_count.counter
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_unpin&n; *&n; *&t;pagebuf_unpin reverses the locking of memory performed by&n; *&t;pagebuf_pin.  Note that both functions affected the logical&n; *&t;pages associated with the buffer, not the buffer itself.&n; */
r_void
DECL|function|pagebuf_unpin
id|pagebuf_unpin
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
)paren
(brace
id|wake_up_all
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
)paren
suffix:semicolon
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|unpin
)paren
comma
id|pb-&gt;pb_pin_count.counter
)paren
suffix:semicolon
)brace
r_int
DECL|function|pagebuf_ispin
id|pagebuf_ispin
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
r_return
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_wait_unpin&n; *&n; *&t;pagebuf_wait_unpin waits until all of the memory associated&n; *&t;with the buffer is not longer locked in memory.  It returns&n; *&t;immediately if none of the affected pages are locked.&n; */
r_static
r_inline
r_void
DECL|function|_pagebuf_wait_unpin
id|_pagebuf_wait_unpin
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|pb-&gt;pb_pin_count
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|pagebuf_run_queues
c_func
(paren
id|pb
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|pb-&gt;pb_waiters
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Buffer Utility Routines&n; */
multiline_comment|/*&n; *&t;pagebuf_iodone&n; *&n; *&t;pagebuf_iodone marks a buffer for which I/O is in progress&n; *&t;done with respect to that I/O.&t;The pb_iodone routine, if&n; *&t;present, will be called as a side-effect.&n; */
r_void
DECL|function|pagebuf_iodone_work
id|pagebuf_iodone_work
c_func
(paren
r_void
op_star
id|v
)paren
(brace
id|page_buf_t
op_star
id|pb
op_assign
(paren
id|page_buf_t
op_star
)paren
id|v
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_iodone
)paren
(brace
(paren
op_star
(paren
id|pb-&gt;pb_iodone
)paren
)paren
(paren
id|pb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_ASYNC
)paren
(brace
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_LOCKABLE
)paren
op_logical_and
op_logical_neg
id|pb-&gt;pb_relse
)paren
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|pagebuf_iodone
id|pagebuf_iodone
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_int
id|dataio
comma
r_int
id|schedule
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_READ
op_or
id|PBF_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_error
op_eq
l_int|0
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_PARTIAL
op_or
id|PBF_NONE
)paren
suffix:semicolon
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|done
)paren
comma
id|pb-&gt;pb_iodone
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_iodone
)paren
op_logical_or
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_ASYNC
)paren
)paren
(brace
r_if
c_cond
(paren
id|schedule
)paren
(brace
id|INIT_WORK
c_func
(paren
op_amp
id|pb-&gt;pb_iodone_work
comma
id|pagebuf_iodone_work
comma
id|pb
)paren
suffix:semicolon
id|queue_work
c_func
(paren
id|dataio
ques
c_cond
id|pagebuf_dataio_workqueue
suffix:colon
id|pagebuf_logio_workqueue
comma
op_amp
id|pb-&gt;pb_iodone_work
)paren
suffix:semicolon
)brace
r_else
(brace
id|pagebuf_iodone_work
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|up
c_func
(paren
op_amp
id|pb-&gt;pb_iodonesema
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;pagebuf_ioerror&n; *&n; *&t;pagebuf_ioerror sets the error code for a buffer.&n; */
r_void
DECL|function|pagebuf_ioerror
id|pagebuf_ioerror
c_func
(paren
multiline_comment|/* mark/clear buffer error flag */
id|page_buf_t
op_star
id|pb
comma
multiline_comment|/* buffer to mark&t;&t;*/
r_int
r_int
id|error
)paren
multiline_comment|/* error to store (0 if none)&t;*/
(brace
id|pb-&gt;pb_error
op_assign
id|error
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|ioerror
)paren
comma
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_iostart&n; *&n; *&t;pagebuf_iostart initiates I/O on a buffer, based on the flags supplied.&n; *&t;If necessary, it will arrange for any disk space allocation required,&n; *&t;and it will break up the request if the block mappings require it.&n; *&t;The pb_iodone routine in the buffer supplied will only be called&n; *&t;when all of the subsidiary I/O requests, if any, have been completed.&n; *&t;pagebuf_iostart calls the pagebuf_ioinitiate routine or&n; *&t;pagebuf_iorequest, if the former routine is not defined, to start&n; *&t;the I/O on a given low-level request.&n; */
r_int
DECL|function|pagebuf_iostart
id|pagebuf_iostart
c_func
(paren
multiline_comment|/* start I/O on a buffer&t;  */
id|page_buf_t
op_star
id|pb
comma
multiline_comment|/* buffer to start&t;&t;  */
id|page_buf_flags_t
id|flags
)paren
multiline_comment|/* PBF_LOCK, PBF_ASYNC, PBF_READ, */
multiline_comment|/* PBF_WRITE, PBF_DELWRI,&t;  */
multiline_comment|/* PBF_SYNC, PBF_DONT_BLOCK&t;  */
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|iostart
)paren
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_DELWRI
)paren
(brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_READ
op_or
id|PBF_WRITE
op_or
id|PBF_ASYNC
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|flags
op_amp
(paren
id|PBF_DELWRI
op_or
id|PBF_ASYNC
op_or
id|PBF_SYNC
)paren
suffix:semicolon
id|pagebuf_delwri_queue
c_func
(paren
id|pb
comma
l_int|1
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_READ
op_or
id|PBF_WRITE
op_or
id|PBF_ASYNC
op_or
id|PBF_DELWRI
op_or
id|PBF_READ_AHEAD
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|flags
op_amp
(paren
id|PBF_READ
op_or
id|PBF_WRITE
op_or
id|PBF_ASYNC
op_or
id|PBF_SYNC
op_or
id|PBF_READ_AHEAD
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|pb-&gt;pb_bn
op_eq
id|PAGE_BUF_DADDR_NULL
)paren
suffix:semicolon
multiline_comment|/* For writes call internal function which checks for&n;&t; * filesystem specific callout function and execute it.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_WRITE
)paren
(brace
id|status
op_assign
id|__pagebuf_iorequest
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|pagebuf_iorequest
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for I/O if we are not an async request */
r_if
c_cond
(paren
(paren
id|status
op_eq
l_int|0
)paren
op_logical_and
(paren
id|flags
op_amp
id|PBF_ASYNC
)paren
op_eq
l_int|0
)paren
(brace
id|status
op_assign
id|pagebuf_iowait
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper routine for pagebuf_iorequest&n; */
id|STATIC
id|__inline__
r_int
DECL|function|_pagebuf_iolocked
id|_pagebuf_iolocked
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
id|ASSERT
c_func
(paren
id|pb-&gt;pb_flags
op_amp
(paren
id|PBF_READ
op_or
id|PBF_WRITE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_READ
)paren
r_return
id|pb-&gt;pb_locked
suffix:semicolon
r_return
(paren
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_LOCKABLE
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
id|STATIC
id|__inline__
r_void
DECL|function|_pagebuf_iodone
id|_pagebuf_iodone
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_int
id|schedule
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
op_eq
l_int|1
)paren
(brace
id|pb-&gt;pb_locked
op_assign
l_int|0
suffix:semicolon
id|pagebuf_iodone
c_func
(paren
id|pb
comma
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_FS_DATAIOD
)paren
comma
id|schedule
)paren
suffix:semicolon
)brace
)brace
id|STATIC
r_int
DECL|function|bio_end_io_pagebuf
id|bio_end_io_pagebuf
c_func
(paren
r_struct
id|bio
op_star
id|bio
comma
r_int
r_int
id|bytes_done
comma
r_int
id|error
)paren
(brace
id|page_buf_t
op_star
id|pb
op_assign
(paren
id|page_buf_t
op_star
)paren
id|bio-&gt;bi_private
suffix:semicolon
r_int
r_int
id|i
comma
id|blocksize
op_assign
id|pb-&gt;pb_target-&gt;pbr_bsize
suffix:semicolon
r_int
r_int
id|sectorshift
op_assign
id|pb-&gt;pb_target-&gt;pbr_sshift
suffix:semicolon
r_struct
id|bio_vec
op_star
id|bvec
op_assign
id|bio-&gt;bi_io_vec
suffix:semicolon
r_if
c_cond
(paren
id|bio-&gt;bi_size
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BIO_UPTODATE
comma
op_amp
id|bio-&gt;bi_flags
)paren
)paren
id|pb-&gt;pb_error
op_assign
id|EIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bio-&gt;bi_vcnt
suffix:semicolon
id|i
op_increment
comma
id|bvec
op_increment
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|bvec-&gt;bv_page
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_error
)paren
(brace
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|blocksize
op_eq
id|PAGE_CACHE_SIZE
)paren
(brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|PagePrivate
c_func
(paren
id|page
)paren
)paren
(brace
r_int
r_int
id|j
comma
id|range
suffix:semicolon
id|ASSERT
c_func
(paren
id|blocksize
OL
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|range
op_assign
(paren
id|bvec-&gt;bv_offset
op_plus
id|bvec-&gt;bv_len
)paren
op_rshift
id|sectorshift
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|bvec-&gt;bv_offset
op_rshift
id|sectorshift
suffix:semicolon
id|j
OL
id|range
suffix:semicolon
id|j
op_increment
)paren
id|set_bit
c_func
(paren
id|j
comma
op_amp
id|page
op_member_access_from_pointer
r_private
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
op_member_access_from_pointer
r_private
op_eq
(paren
r_int
r_int
)paren
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_pagebuf_iolocked
c_func
(paren
id|pb
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|_pagebuf_iodone
c_func
(paren
id|pb
comma
l_int|1
)paren
suffix:semicolon
id|bio_put
c_func
(paren
id|bio
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|_pagebuf_ioapply
id|_pagebuf_ioapply
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
r_int
id|i
comma
id|map_i
comma
id|total_nr_pages
comma
id|nr_pages
suffix:semicolon
r_struct
id|bio
op_star
id|bio
suffix:semicolon
r_int
id|offset
op_assign
id|pb-&gt;pb_offset
suffix:semicolon
r_int
id|size
op_assign
id|pb-&gt;pb_count_desired
suffix:semicolon
id|sector_t
id|sector
op_assign
id|pb-&gt;pb_bn
suffix:semicolon
r_int
r_int
id|blocksize
op_assign
id|pb-&gt;pb_target-&gt;pbr_bsize
suffix:semicolon
r_int
id|locking
op_assign
id|_pagebuf_iolocked
c_func
(paren
id|pb
)paren
suffix:semicolon
id|total_nr_pages
op_assign
id|pb-&gt;pb_page_count
suffix:semicolon
id|map_i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Special code path for reading a sub page size pagebuf in --&n;&t; * we populate up the whole page, and hence the other metadata&n;&t; * in the same page.  This optimization is only valid when the&n;&t; * filesystem block size and the page size are equal.&n;&t; */
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_buffer_length
OL
id|PAGE_CACHE_SIZE
)paren
op_logical_and
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_READ
)paren
op_logical_and
id|locking
op_logical_and
(paren
id|blocksize
op_eq
id|PAGE_CACHE_SIZE
)paren
)paren
(brace
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
l_int|1
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|pb-&gt;pb_target-&gt;pbr_bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|sector
op_minus
(paren
id|offset
op_rshift
id|BBSHIFT
)paren
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bio_end_io_pagebuf
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|pb
suffix:semicolon
id|bio_add_page
c_func
(paren
id|bio
comma
id|pb-&gt;pb_pages
(braket
l_int|0
)braket
comma
id|PAGE_CACHE_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|size
op_assign
l_int|0
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
suffix:semicolon
r_goto
id|submit_io
suffix:semicolon
)brace
multiline_comment|/* Lock down the pages which we need to for the request */
r_if
c_cond
(paren
id|locking
op_logical_and
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_WRITE
)paren
op_logical_and
(paren
id|pb-&gt;pb_locked
op_eq
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|nbytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OG
id|size
)paren
id|nbytes
op_assign
id|size
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|size
op_sub_assign
id|nbytes
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
id|offset
op_assign
id|pb-&gt;pb_offset
suffix:semicolon
id|size
op_assign
id|pb-&gt;pb_count_desired
suffix:semicolon
)brace
id|next_chunk
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
)paren
suffix:semicolon
id|nr_pages
op_assign
id|BIO_MAX_SECTORS
op_rshift
(paren
id|PAGE_SHIFT
op_minus
id|BBSHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_pages
OG
id|total_nr_pages
)paren
id|nr_pages
op_assign
id|total_nr_pages
suffix:semicolon
id|bio
op_assign
id|bio_alloc
c_func
(paren
id|GFP_NOIO
comma
id|nr_pages
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|bio
op_eq
l_int|NULL
)paren
suffix:semicolon
id|bio-&gt;bi_bdev
op_assign
id|pb-&gt;pb_target-&gt;pbr_bdev
suffix:semicolon
id|bio-&gt;bi_sector
op_assign
id|sector
suffix:semicolon
id|bio-&gt;bi_end_io
op_assign
id|bio_end_io_pagebuf
suffix:semicolon
id|bio-&gt;bi_private
op_assign
id|pb
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|size
op_logical_and
id|nr_pages
suffix:semicolon
id|nr_pages
op_decrement
comma
id|map_i
op_increment
)paren
(brace
r_int
id|nbytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OG
id|size
)paren
id|nbytes
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|bio_add_page
c_func
(paren
id|bio
comma
id|pb-&gt;pb_pages
(braket
id|map_i
)braket
comma
id|nbytes
comma
id|offset
)paren
OL
id|nbytes
)paren
r_break
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|sector
op_add_assign
id|nbytes
op_rshift
id|BBSHIFT
suffix:semicolon
id|size
op_sub_assign
id|nbytes
suffix:semicolon
id|total_nr_pages
op_decrement
suffix:semicolon
)brace
id|submit_io
suffix:colon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|bio-&gt;bi_size
)paren
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_READ
)paren
(brace
id|submit_bio
c_func
(paren
id|READ
comma
id|bio
)paren
suffix:semicolon
)brace
r_else
(brace
id|submit_bio
c_func
(paren
id|WRITE
comma
id|bio
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
)paren
r_goto
id|next_chunk
suffix:semicolon
)brace
r_else
(brace
id|pagebuf_ioerror
c_func
(paren
id|pb
comma
id|EIO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;pagebuf_iorequest&n; *&n; *&t;pagebuf_iorequest is the core I/O request routine.&n; *&t;It assumes that the buffer is well-formed and&n; *&t;mapped and ready for physical I/O, unlike&n; *&t;pagebuf_iostart() and pagebuf_iophysio().  Those&n; *&t;routines call the pagebuf_ioinitiate routine to start I/O,&n; *&t;if it is present, or else call pagebuf_iorequest()&n; *&t;directly if the pagebuf_ioinitiate routine is not present.&n; *&n; *&t;This function will be responsible for ensuring access to the&n; *&t;pages is restricted whilst I/O is in progress - for locking&n; *&t;pagebufs the pagebuf lock is the mediator, for non-locking&n; *&t;pagebufs the pages will be locked. In the locking case we&n; *&t;need to use the pagebuf lock as multiple meta-data buffers&n; *&t;will reference the same page.&n; */
r_int
DECL|function|pagebuf_iorequest
id|pagebuf_iorequest
c_func
(paren
multiline_comment|/* start real I/O&t;&t;*/
id|page_buf_t
op_star
id|pb
)paren
multiline_comment|/* buffer to convey to device&t;*/
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|ioreq
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
(brace
id|pagebuf_delwri_queue
c_func
(paren
id|pb
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_WRITE
)paren
(brace
id|_pagebuf_wait_unpin
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the count to 1 initially, this will stop an I/O&n;&t; * completion callout which happens before we have started&n;&t; * all the I/O from calling pagebuf_iodone too early.&n;&t; */
id|atomic_set
c_func
(paren
op_amp
id|pb-&gt;pb_io_remaining
comma
l_int|1
)paren
suffix:semicolon
id|_pagebuf_ioapply
c_func
(paren
id|pb
)paren
suffix:semicolon
id|_pagebuf_iodone
c_func
(paren
id|pb
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_iowait&n; *&n; *&t;pagebuf_iowait waits for I/O to complete on the buffer supplied.&n; *&t;It returns immediately if no I/O is pending.  In any case, it returns&n; *&t;the error code, if any, or 0 if there is no error.&n; */
r_int
DECL|function|pagebuf_iowait
id|pagebuf_iowait
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|iowait
)paren
comma
l_int|0
)paren
suffix:semicolon
id|pagebuf_run_queues
c_func
(paren
id|pb
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|pb-&gt;pb_iodonesema
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|iowaited
)paren
comma
(paren
r_int
)paren
id|pb-&gt;pb_error
)paren
suffix:semicolon
r_return
id|pb-&gt;pb_error
suffix:semicolon
)brace
id|STATIC
r_void
op_star
DECL|function|pagebuf_mapout_locked
id|pagebuf_mapout_locked
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
r_void
op_star
id|old_addr
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_MAPPED
)paren
(brace
r_if
c_cond
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_ADDR_ALLOCATED
)paren
id|old_addr
op_assign
id|pb-&gt;pb_addr
op_minus
id|pb-&gt;pb_offset
suffix:semicolon
id|pb-&gt;pb_addr
op_assign
l_int|NULL
suffix:semicolon
id|pb-&gt;pb_flags
op_and_assign
op_complement
(paren
id|PBF_MAPPED
op_or
id|_PBF_ADDR_ALLOCATED
)paren
suffix:semicolon
)brace
r_return
id|old_addr
suffix:semicolon
multiline_comment|/* Caller must free the address space,&n;&t;&t;&t;&t; * we are under a spin lock, probably&n;&t;&t;&t;&t; * not safe to do vfree here&n;&t;&t;&t;&t; */
)brace
id|caddr_t
DECL|function|pagebuf_offset
id|pagebuf_offset
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_int
id|offset
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
id|offset
op_add_assign
id|pb-&gt;pb_offset
suffix:semicolon
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|offset
op_rshift
id|PAGE_CACHE_SHIFT
)braket
suffix:semicolon
r_return
(paren
id|caddr_t
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
(paren
id|offset
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_iomove&n; *&n; *&t;Move data into or out of a buffer.&n; */
r_void
DECL|function|pagebuf_iomove
id|pagebuf_iomove
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
multiline_comment|/* buffer to process&t;&t;*/
r_int
id|boff
comma
multiline_comment|/* starting buffer offset&t;*/
r_int
id|bsize
comma
multiline_comment|/* length to copy&t;&t;*/
id|caddr_t
id|data
comma
multiline_comment|/* data address&t;&t;&t;*/
id|page_buf_rw_t
id|mode
)paren
multiline_comment|/* read/write flag&t;&t;*/
(brace
r_int
id|bend
comma
id|cpoff
comma
id|csize
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|bend
op_assign
id|boff
op_plus
id|bsize
suffix:semicolon
r_while
c_loop
(paren
id|boff
OL
id|bend
)paren
(brace
id|page
op_assign
id|pb-&gt;pb_pages
(braket
id|page_buf_btoct
c_func
(paren
id|boff
op_plus
id|pb-&gt;pb_offset
)paren
)braket
suffix:semicolon
id|cpoff
op_assign
id|page_buf_poff
c_func
(paren
id|boff
op_plus
id|pb-&gt;pb_offset
)paren
suffix:semicolon
id|csize
op_assign
id|min_t
c_func
(paren
r_int
comma
id|PAGE_CACHE_SIZE
op_minus
id|cpoff
comma
id|pb-&gt;pb_count_desired
op_minus
id|boff
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|csize
op_plus
id|cpoff
)paren
op_le
id|PAGE_CACHE_SIZE
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|PBRW_ZERO
suffix:colon
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cpoff
comma
l_int|0
comma
id|csize
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PBRW_READ
suffix:colon
id|memcpy
c_func
(paren
id|data
comma
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cpoff
comma
id|csize
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PBRW_WRITE
suffix:colon
id|memcpy
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|cpoff
comma
id|data
comma
id|csize
)paren
suffix:semicolon
)brace
id|boff
op_add_assign
id|csize
suffix:semicolon
id|data
op_add_assign
id|csize
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Pagebuf delayed write buffer handling&n; */
DECL|variable|pbd_active
id|STATIC
r_int
id|pbd_active
op_assign
l_int|1
suffix:semicolon
id|STATIC
id|LIST_HEAD
c_func
(paren
id|pbd_delwrite_queue
)paren
suffix:semicolon
DECL|variable|pbd_delwrite_lock
id|STATIC
id|spinlock_t
id|pbd_delwrite_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|STATIC
r_void
DECL|function|pagebuf_delwri_queue
id|pagebuf_delwri_queue
c_func
(paren
id|page_buf_t
op_star
id|pb
comma
r_int
id|unlock
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|delwri_q
)paren
comma
id|unlock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
multiline_comment|/* If already in the queue, dequeue and place at tail */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlock
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|pb-&gt;pb_hold
)paren
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|pb-&gt;pb_list
comma
op_amp
id|pbd_delwrite_queue
)paren
suffix:semicolon
id|pb-&gt;pb_flushtime
op_assign
id|jiffies
op_plus
id|pb_params.age_buffer.val
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlock
op_logical_and
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_LOCKABLE
)paren
)paren
(brace
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|pagebuf_delwri_dequeue
id|pagebuf_delwri_dequeue
c_func
(paren
id|page_buf_t
op_star
id|pb
)paren
(brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|delwri_uq
)paren
comma
l_int|0
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_DELWRI
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|pagebuf_runall_queues
id|pagebuf_runall_queues
c_func
(paren
r_struct
id|workqueue_struct
op_star
id|queue
)paren
(brace
id|flush_workqueue
c_func
(paren
id|queue
)paren
suffix:semicolon
)brace
multiline_comment|/* Defines for pagebuf daemon */
DECL|variable|pbd_waitq
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|pbd_waitq
)paren
suffix:semicolon
DECL|variable|force_flush
id|STATIC
r_int
id|force_flush
suffix:semicolon
id|STATIC
r_void
DECL|function|pagebuf_daemon_wakeup
id|pagebuf_daemon_wakeup
c_func
(paren
r_int
id|flag
)paren
(brace
id|force_flush
op_assign
id|flag
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|pbd_waitq
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|pbd_waitq
)paren
suffix:semicolon
)brace
)brace
DECL|typedef|timeout_fn
r_typedef
r_void
(paren
op_star
id|timeout_fn
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
id|STATIC
r_int
DECL|function|pagebuf_daemon
id|pagebuf_daemon
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_int
id|count
suffix:semicolon
id|page_buf_t
op_star
id|pb
suffix:semicolon
r_struct
id|list_head
op_star
id|curr
comma
op_star
id|next
comma
id|tmp
suffix:semicolon
r_struct
id|timer_list
id|pb_daemon_timer
op_assign
id|TIMER_INITIALIZER
c_func
(paren
(paren
id|timeout_fn
)paren
id|pagebuf_daemon_wakeup
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  Set up the thread  */
id|daemonize
c_func
(paren
l_string|&quot;pagebufd&quot;
)paren
suffix:semicolon
id|current-&gt;flags
op_or_assign
id|PF_MEMALLOC
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* swsusp */
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FREEZE
)paren
id|refrigerator
c_func
(paren
id|PF_IOTHREAD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pbd_active
op_eq
l_int|1
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|pb_daemon_timer
comma
id|jiffies
op_plus
id|pb_params.flush_interval.val
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|pbd_waitq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pbd_active
op_eq
l_int|0
)paren
(brace
id|del_timer_sync
c_func
(paren
op_amp
id|pb_daemon_timer
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|curr
comma
id|next
comma
op_amp
id|pbd_delwrite_queue
)paren
(brace
id|pb
op_assign
id|list_entry
c_func
(paren
id|curr
comma
id|page_buf_t
comma
id|pb_list
)paren
suffix:semicolon
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|walkq1
)paren
comma
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
op_logical_and
op_logical_neg
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
op_logical_and
(paren
(paren
(paren
id|pb-&gt;pb_flags
op_amp
id|_PBF_LOCKABLE
)paren
op_eq
l_int|0
)paren
op_logical_or
op_logical_neg
id|pagebuf_cond_lock
c_func
(paren
id|pb
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|force_flush
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|pb-&gt;pb_flushtime
)paren
)paren
(brace
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|pb-&gt;pb_list
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tmp
)paren
)paren
(brace
id|pb
op_assign
id|list_entry
c_func
(paren
id|tmp.next
comma
id|page_buf_t
comma
id|pb_list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_DELWRI
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_WRITE
suffix:semicolon
id|__pagebuf_iorequest
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|as_list_len
OG
l_int|0
)paren
id|purge_addresses
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
id|pagebuf_run_queues
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|force_flush
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|pbd_active
op_eq
l_int|1
)paren
suffix:semicolon
id|pbd_active
op_assign
op_minus
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pbd_waitq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|pagebuf_delwri_flush
id|pagebuf_delwri_flush
c_func
(paren
id|pb_target_t
op_star
id|target
comma
id|u_long
id|flags
comma
r_int
op_star
id|pinptr
)paren
(brace
id|page_buf_t
op_star
id|pb
suffix:semicolon
r_struct
id|list_head
op_star
id|curr
comma
op_star
id|next
comma
id|tmp
suffix:semicolon
r_int
id|pincount
op_assign
l_int|0
suffix:semicolon
r_int
id|flush_cnt
op_assign
l_int|0
suffix:semicolon
id|pagebuf_runall_queues
c_func
(paren
id|pagebuf_dataio_workqueue
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|curr
comma
id|next
comma
op_amp
id|pbd_delwrite_queue
)paren
(brace
id|pb
op_assign
id|list_entry
c_func
(paren
id|curr
comma
id|page_buf_t
comma
id|pb_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Skip other targets, markers and in progress buffers&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|pb-&gt;pb_flags
op_eq
l_int|0
)paren
op_logical_or
(paren
id|pb-&gt;pb_target
op_ne
id|target
)paren
op_logical_or
op_logical_neg
(paren
id|pb-&gt;pb_flags
op_amp
id|PBF_DELWRI
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|PB_TRACE
c_func
(paren
id|pb
comma
id|PB_TRACE_REC
c_func
(paren
id|walkq2
)paren
comma
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagebuf_ispin
c_func
(paren
id|pb
)paren
)paren
(brace
id|pincount
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|PBDF_TRYLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pagebuf_cond_lock
c_func
(paren
id|pb
)paren
)paren
(brace
id|pincount
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PBDF_WAIT
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|pb-&gt;pb_list
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_ASYNC
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|PBDF_TRYLOCK
)paren
op_eq
l_int|0
)paren
(brace
id|pagebuf_lock
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
id|pb-&gt;pb_flags
op_and_assign
op_complement
id|PBF_DELWRI
suffix:semicolon
id|pb-&gt;pb_flags
op_or_assign
id|PBF_WRITE
suffix:semicolon
id|__pagebuf_iorequest
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|flush_cnt
OG
l_int|32
)paren
(brace
id|pagebuf_run_queues
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|flush_cnt
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|pbd_delwrite_lock
)paren
suffix:semicolon
id|pagebuf_run_queues
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pinptr
)paren
op_star
id|pinptr
op_assign
id|pincount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|PBDF_WAIT
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tmp
)paren
)paren
(brace
id|pb
op_assign
id|list_entry
c_func
(paren
id|tmp.next
comma
id|page_buf_t
comma
id|pb_list
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|pb-&gt;pb_list
)paren
suffix:semicolon
id|pagebuf_iowait
c_func
(paren
id|pb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pb-&gt;pb_relse
)paren
id|pagebuf_unlock
c_func
(paren
id|pb
)paren
suffix:semicolon
id|pagebuf_rele
c_func
(paren
id|pb
)paren
suffix:semicolon
)brace
)brace
id|STATIC
r_int
DECL|function|pagebuf_daemon_start
id|pagebuf_daemon_start
c_func
(paren
r_void
)paren
(brace
r_int
id|rval
suffix:semicolon
id|pagebuf_logio_workqueue
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;xfslogd&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagebuf_logio_workqueue
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pagebuf_dataio_workqueue
op_assign
id|create_workqueue
c_func
(paren
l_string|&quot;xfsdatad&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pagebuf_dataio_workqueue
)paren
(brace
id|destroy_workqueue
c_func
(paren
id|pagebuf_logio_workqueue
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|rval
op_assign
id|kernel_thread
c_func
(paren
id|pagebuf_daemon
comma
l_int|NULL
comma
id|CLONE_FS
op_or
id|CLONE_FILES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rval
OL
l_int|0
)paren
(brace
id|destroy_workqueue
c_func
(paren
id|pagebuf_logio_workqueue
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|pagebuf_dataio_workqueue
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * pagebuf_daemon_stop&n; *&n; * Note: do not mark as __exit, it is called from pagebuf_terminate.&n; */
id|STATIC
r_void
DECL|function|pagebuf_daemon_stop
id|pagebuf_daemon_stop
c_func
(paren
r_void
)paren
(brace
id|pbd_active
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pbd_waitq
)paren
suffix:semicolon
id|wait_event_interruptible
c_func
(paren
id|pbd_waitq
comma
id|pbd_active
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|pagebuf_logio_workqueue
)paren
suffix:semicolon
id|destroy_workqueue
c_func
(paren
id|pagebuf_dataio_workqueue
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Pagebuf sysctl interface&n; */
id|STATIC
r_int
DECL|function|pb_stats_clear_handler
id|pb_stats_clear_handler
c_func
(paren
id|ctl_table
op_star
id|ctl
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
op_star
id|valp
op_assign
id|ctl-&gt;data
suffix:semicolon
id|ret
op_assign
id|proc_doulongvec_minmax
c_func
(paren
id|ctl
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
id|write
op_logical_and
op_star
id|valp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS Clearing pbstats&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pbstats
comma
l_int|0
comma
r_sizeof
(paren
id|pbstats
)paren
)paren
suffix:semicolon
id|pb_params.stats_clear.val
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|pagebuf_table_header
id|STATIC
r_struct
id|ctl_table_header
op_star
id|pagebuf_table_header
suffix:semicolon
DECL|variable|pagebuf_table
id|STATIC
id|ctl_table
id|pagebuf_table
(braket
)braket
op_assign
(brace
(brace
id|PB_FLUSH_INT
comma
l_string|&quot;flush_int&quot;
comma
op_amp
id|pb_params.flush_interval.val
comma
r_sizeof
(paren
id|ulong
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_doulongvec_ms_jiffies_minmax
comma
op_amp
id|sysctl_intvec
comma
l_int|NULL
comma
op_amp
id|pb_params.flush_interval.min
comma
op_amp
id|pb_params.flush_interval.max
)brace
comma
(brace
id|PB_FLUSH_AGE
comma
l_string|&quot;flush_age&quot;
comma
op_amp
id|pb_params.age_buffer.val
comma
r_sizeof
(paren
id|ulong
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_doulongvec_ms_jiffies_minmax
comma
op_amp
id|sysctl_intvec
comma
l_int|NULL
comma
op_amp
id|pb_params.age_buffer.min
comma
op_amp
id|pb_params.age_buffer.max
)brace
comma
(brace
id|PB_STATS_CLEAR
comma
l_string|&quot;stats_clear&quot;
comma
op_amp
id|pb_params.stats_clear.val
comma
r_sizeof
(paren
id|ulong
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|pb_stats_clear_handler
comma
op_amp
id|sysctl_intvec
comma
l_int|NULL
comma
op_amp
id|pb_params.stats_clear.min
comma
op_amp
id|pb_params.stats_clear.max
)brace
comma
macro_line|#ifdef PAGEBUF_TRACE
(brace
id|PB_DEBUG
comma
l_string|&quot;debug&quot;
comma
op_amp
id|pb_params.debug.val
comma
r_sizeof
(paren
id|ulong
)paren
comma
l_int|0644
comma
l_int|NULL
comma
op_amp
id|proc_doulongvec_minmax
comma
op_amp
id|sysctl_intvec
comma
l_int|NULL
comma
op_amp
id|pb_params.debug.min
comma
op_amp
id|pb_params.debug.max
)brace
comma
macro_line|#endif
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|pagebuf_dir_table
id|STATIC
id|ctl_table
id|pagebuf_dir_table
(braket
)braket
op_assign
(brace
(brace
id|VM_PAGEBUF
comma
l_string|&quot;pagebuf&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|pagebuf_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|pagebuf_root_table
id|STATIC
id|ctl_table
id|pagebuf_root_table
(braket
)braket
op_assign
(brace
(brace
id|CTL_VM
comma
l_string|&quot;vm&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|pagebuf_dir_table
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
id|STATIC
r_int
DECL|function|pagebuf_readstats
id|pagebuf_readstats
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|i
comma
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;pagebuf&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|pbstats
)paren
op_div
r_sizeof
(paren
id|u_int32_t
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot; %u&quot;
comma
op_star
(paren
(paren
(paren
id|u_int32_t
op_star
)paren
op_amp
id|pbstats
)paren
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|buffer
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|len
)paren
(brace
op_star
id|start
op_assign
id|buffer
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_sub_assign
id|offset
)paren
OG
id|count
)paren
r_return
id|count
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif  /* CONFIG_PROC_FS */
multiline_comment|/*&n; *&t;Initialization and Termination&n; */
r_int
id|__init
DECL|function|pagebuf_init
id|pagebuf_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|pagebuf_table_header
op_assign
id|register_sysctl_table
c_func
(paren
id|pagebuf_root_table
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
id|proc_mkdir
c_func
(paren
l_string|&quot;fs/pagebuf&quot;
comma
l_int|0
)paren
)paren
id|create_proc_read_entry
c_func
(paren
l_string|&quot;fs/pagebuf/stat&quot;
comma
l_int|0
comma
l_int|0
comma
id|pagebuf_readstats
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|pagebuf_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;page_buf_t&quot;
comma
r_sizeof
(paren
id|page_buf_t
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagebuf_cache
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pagebuf: couldn&squot;t init pagebuf cache&bslash;n&quot;
)paren
suffix:semicolon
id|pagebuf_terminate
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NHASH
suffix:semicolon
id|i
op_increment
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|pbhash
(braket
id|i
)braket
dot
id|pb_hash_lock
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|pbhash
(braket
id|i
)braket
dot
id|pb_hash
)paren
suffix:semicolon
)brace
macro_line|#ifdef PAGEBUF_TRACE
id|pb_trace.buf
op_assign
(paren
id|pagebuf_trace_t
op_star
)paren
id|kmalloc
c_func
(paren
id|PB_TRACE_BUFSIZE
op_star
r_sizeof
(paren
id|pagebuf_trace_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|pb_trace.buf
comma
l_int|0
comma
id|PB_TRACE_BUFSIZE
op_star
r_sizeof
(paren
id|pagebuf_trace_t
)paren
)paren
suffix:semicolon
id|pb_trace.start
op_assign
l_int|0
suffix:semicolon
id|pb_trace.end
op_assign
id|PB_TRACE_BUFSIZE
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|pagebuf_daemon_start
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;pagebuf_terminate.&n; *&n; *&t;Note: do not mark as __exit, this is also called from the __init code.&n; */
r_void
DECL|function|pagebuf_terminate
id|pagebuf_terminate
c_func
(paren
r_void
)paren
(brace
id|pagebuf_daemon_stop
c_func
(paren
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|pagebuf_cache
)paren
suffix:semicolon
id|unregister_sysctl_table
c_func
(paren
id|pagebuf_table_header
)paren
suffix:semicolon
macro_line|#ifdef  CONFIG_PROC_FS
id|remove_proc_entry
c_func
(paren
l_string|&quot;fs/pagebuf/stat&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;fs/pagebuf&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Module management (for kernel debugger module)&n; */
DECL|variable|pagebuf_offset
id|EXPORT_SYMBOL
c_func
(paren
id|pagebuf_offset
)paren
suffix:semicolon
eof
