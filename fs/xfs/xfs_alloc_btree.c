multiline_comment|/*&n; * Copyright (c) 2000-2001 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * Free space allocation for XFS.&n; */
macro_line|#include &lt;xfs.h&gt;
multiline_comment|/*&n; * Prototypes for internal functions.&n; */
id|STATIC
r_void
id|xfs_alloc_log_block
c_func
(paren
id|xfs_trans_t
op_star
comma
id|xfs_buf_t
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_alloc_log_keys
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
id|xfs_buf_t
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_alloc_log_ptrs
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
id|xfs_buf_t
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_alloc_log_recs
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
id|xfs_buf_t
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_lshift
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
r_int
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_newroot
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_rshift
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
r_int
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_split
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
r_int
comma
id|xfs_agblock_t
op_star
comma
id|xfs_alloc_key_t
op_star
comma
id|xfs_btree_cur_t
op_star
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_updkey
c_func
(paren
id|xfs_btree_cur_t
op_star
comma
id|xfs_alloc_key_t
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal functions.&n; */
multiline_comment|/*&n; * Single level of the xfs_alloc_delete record deletion routine.&n; * Delete record pointed to by cur/level.&n; * Remove the record from its block then rebalance the tree.&n; * Return 0 for error, 1 for done, 2 to go on to the next level.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_delrec
id|xfs_alloc_delrec
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level removing record from */
r_int
op_star
id|stat
)paren
multiline_comment|/* fail/done/go-on */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* allocation group freelist header */
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block record/key lives in */
id|xfs_agblock_t
id|bno
suffix:semicolon
multiline_comment|/* btree block number */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* loop index */
id|xfs_alloc_key_t
id|key
suffix:semicolon
multiline_comment|/* kp points here if block is level 0 */
id|xfs_agblock_t
id|lbno
suffix:semicolon
multiline_comment|/* left block&squot;s block number */
id|xfs_buf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* left block&squot;s buffer pointer */
id|xfs_alloc_block_t
op_star
id|left
suffix:semicolon
multiline_comment|/* left btree block */
id|xfs_alloc_key_t
op_star
id|lkp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* left block key pointer */
id|xfs_alloc_ptr_t
op_star
id|lpp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* left block address pointer */
r_int
id|lrecs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of records in left block */
id|xfs_alloc_rec_t
op_star
id|lrp
suffix:semicolon
multiline_comment|/* left block record pointer */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
r_int
id|ptr
suffix:semicolon
multiline_comment|/* index in btree block for this rec */
id|xfs_agblock_t
id|rbno
suffix:semicolon
multiline_comment|/* right block&squot;s block number */
id|xfs_buf_t
op_star
id|rbp
suffix:semicolon
multiline_comment|/* right block&squot;s buffer pointer */
id|xfs_alloc_block_t
op_star
id|right
suffix:semicolon
multiline_comment|/* right btree block */
id|xfs_alloc_key_t
op_star
id|rkp
suffix:semicolon
multiline_comment|/* right block key pointer */
id|xfs_alloc_ptr_t
op_star
id|rpp
suffix:semicolon
multiline_comment|/* right block address pointer */
r_int
id|rrecs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of records in right block */
id|xfs_alloc_rec_t
op_star
id|rrp
suffix:semicolon
multiline_comment|/* right block record pointer */
id|xfs_btree_cur_t
op_star
id|tcur
suffix:semicolon
multiline_comment|/* temporary btree cursor */
multiline_comment|/*&n;&t; * Get the index of the entry being deleted, check for nothing there.&n;&t; */
id|ptr
op_assign
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_eq
l_int|0
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the buffer &amp; block containing the record or key/ptr.&n;&t; */
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Fail if we&squot;re off the end of the block.&n;&t; */
r_if
c_cond
(paren
id|ptr
OG
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_abt_delrec
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It&squot;s a nonleaf.  Excise the key and ptr being deleted, by&n;&t; * sliding the entries past them down one.&n;&t; * Log the changed areas of the block.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
id|lkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|lpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
id|ptr
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
id|lpp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ptr
OL
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|memmove
c_func
(paren
op_amp
id|lkp
(braket
id|ptr
op_minus
l_int|1
)braket
comma
op_amp
id|lkp
(braket
id|ptr
)braket
comma
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
id|ptr
)paren
op_star
r_sizeof
(paren
op_star
id|lkp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: mem copy */
id|memmove
c_func
(paren
op_amp
id|lpp
(braket
id|ptr
op_minus
l_int|1
)braket
comma
op_amp
id|lpp
(braket
id|ptr
)braket
comma
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
id|ptr
)paren
op_star
r_sizeof
(paren
op_star
id|lpp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: mem copy */
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|bp
comma
id|ptr
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|bp
comma
id|ptr
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * It&squot;s a leaf.  Excise the record being deleted, by sliding the&n;&t; * entries past it down one.  Log the changed areas of the block.&n;&t; */
r_else
(brace
id|lrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
OL
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|memmove
c_func
(paren
op_amp
id|lrp
(braket
id|ptr
op_minus
l_int|1
)braket
comma
op_amp
id|lrp
(braket
id|ptr
)braket
comma
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
id|ptr
)paren
op_star
r_sizeof
(paren
op_star
id|lrp
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|bp
comma
id|ptr
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If it&squot;s the first record in the block, we&squot;ll need a key&n;&t;&t; * structure to pass up to the next level (updkey).&n;&t;&t; */
r_if
c_cond
(paren
id|ptr
op_eq
l_int|1
)paren
(brace
id|key.ar_startblock
op_assign
id|lrp-&gt;ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|key.ar_blockcount
op_assign
id|lrp-&gt;ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|lkp
op_assign
op_amp
id|key
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Decrement and log the number of entries in the block.&n;&t; */
id|INT_MOD
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|bp
comma
id|XFS_BB_NUMRECS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if the longest free extent in the allocation group was&n;&t; * changed by this operation.  True if it&squot;s the by-size btree, and&n;&t; * this is the leaf level, and there is no right sibling block,&n;&t; * and this was the last record.&n;&t; */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|cur-&gt;bc_private.a.agbp
)paren
suffix:semicolon
id|mp
op_assign
id|cur-&gt;bc_mp
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|0
op_logical_and
id|cur-&gt;bc_btnum
op_eq
id|XFS_BTNUM_CNT
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
op_logical_and
id|ptr
OG
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ptr
op_eq
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There are still records in the block.  Grab the size&n;&t;&t; * from the last one.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|rrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
comma
id|cur
)paren
suffix:semicolon
id|INT_COPY
c_func
(paren
id|agf-&gt;agf_longest
comma
id|rrp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No free extents left.&n;&t;&t; */
r_else
id|INT_ZERO
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
)braket
dot
id|pagf_longest
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
id|XFS_AGF_LONGEST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Is this the root level?  If so, we&squot;re almost done.&n;&t; */
r_if
c_cond
(paren
id|level
op_eq
id|cur-&gt;bc_nlevels
op_minus
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * If this is the root level,&n;&t;&t; * and there&squot;s only one entry left,&n;&t;&t; * and it&squot;s NOT the leaf level,&n;&t;&t; * then we can get rid of this level.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_eq
l_int|1
op_logical_and
id|level
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * lpp is still set to the first pointer in the block.&n;&t;&t;&t; * Make it the new root of the btree.&n;&t;&t;&t; */
id|bno
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_roots
(braket
id|cur-&gt;bc_btnum
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_COPY
c_func
(paren
id|agf-&gt;agf_roots
(braket
id|cur-&gt;bc_btnum
)braket
comma
op_star
id|lpp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|cur-&gt;bc_btnum
)braket
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
)braket
dot
id|pagf_levels
(braket
id|cur-&gt;bc_btnum
)braket
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Put this buffer/block on the ag&squot;s freelist.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_put_freelist
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
l_int|NULL
comma
id|bno
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since blocks move to the free list without the&n;&t;&t;&t; * coordination used in xfs_bmap_finish, we can&squot;t allow&n;&t;&t;&t; * block to be available for reallocation and&n;&t;&t;&t; * non-transaction writing (user data) until we know&n;&t;&t;&t; * that the transaction that moved it to the free list&n;&t;&t;&t; * is permanently on disk. We track the blocks by&n;&t;&t;&t; * declaring these blocks as &quot;busy&quot;; the busy list is&n;&t;&t;&t; * maintained on a per-ag basis and each transaction&n;&t;&t;&t; * records which entries should be removed when the&n;&t;&t;&t; * iclog commits to disk. If a busy block is&n;&t;&t;&t; * allocated, the iclog is pushed up to the LSN&n;&t;&t;&t; * that freed the block.&n;&t;&t;&t; */
id|xfs_alloc_mark_busy
c_func
(paren
id|cur-&gt;bc_tp
comma
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|bno
comma
l_int|1
)paren
suffix:semicolon
id|xfs_trans_agbtree_delta
c_func
(paren
id|cur-&gt;bc_tp
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
id|XFS_AGF_ROOTS
op_or
id|XFS_AGF_LEVELS
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Update the cursor so there&squot;s one fewer level.&n;&t;&t;&t; */
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|level
comma
l_int|0
)paren
suffix:semicolon
id|cur-&gt;bc_nlevels
op_decrement
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|level
OG
l_int|0
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we deleted the leftmost entry in the block, update the&n;&t; * key values above us in the tree.&n;&t; */
r_if
c_cond
(paren
id|ptr
op_eq
l_int|1
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_updkey
c_func
(paren
id|cur
comma
id|lkp
comma
id|level
op_plus
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * If the number of records remaining in the block is at least&n;&t; * the minimum, we&squot;re done.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_ge
id|XFS_ALLOC_BLOCK_MINRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
r_if
c_cond
(paren
id|level
OG
l_int|0
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Otherwise, we have to move some records around to keep the&n;&t; * tree balanced.  Look at the left and right sibling blocks to&n;&t; * see if we can re-balance by moving only one record.&n;&t; */
id|rbno
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|lbno
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bno
op_assign
id|NULLAGBLOCK
suffix:semicolon
id|ASSERT
c_func
(paren
id|rbno
op_ne
id|NULLAGBLOCK
op_logical_or
id|lbno
op_ne
id|NULLAGBLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Duplicate the cursor so our btree manipulations here won&squot;t&n;&t; * disrupt the next level up.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_dup_cursor
c_func
(paren
id|cur
comma
op_amp
id|tcur
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * If there&squot;s a right sibling, see if it&squot;s ok to shift an entry&n;&t; * out of it.&n;&t; */
r_if
c_cond
(paren
id|rbno
op_ne
id|NULLAGBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t; * Move the temp cursor to the last entry in the next block.&n;&t;&t; * Actually any entry but the first would suffice.&n;&t;&t; */
id|i
op_assign
id|xfs_btree_lastrec
c_func
(paren
id|tcur
comma
id|level
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|tcur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|i
op_assign
id|xfs_btree_lastrec
c_func
(paren
id|tcur
comma
id|level
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Grab a pointer to the block.&n;&t;&t; */
id|rbp
op_assign
id|tcur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|right
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rbp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|right
comma
id|level
comma
id|rbp
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Grab the current block number, for future use.&n;&t;&t; */
id|bno
op_assign
id|INT_GET
c_func
(paren
id|right-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If right block is full enough so that removing one entry&n;&t;&t; * won&squot;t make it too empty, and left-shifting an entry out&n;&t;&t; * of right to us works, we&squot;re done.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
op_ge
id|XFS_ALLOC_BLOCK_MINRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lshift
c_func
(paren
id|tcur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_ge
id|XFS_ALLOC_BLOCK_MINRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
OG
l_int|0
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Otherwise, grab the number of records in right for&n;&t;&t; * future reference, and fix up the temp cursor to point&n;&t;&t; * to our block again (last record).&n;&t;&t; */
id|rrecs
op_assign
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbno
op_ne
id|NULLAGBLOCK
)paren
(brace
id|i
op_assign
id|xfs_btree_firstrec
c_func
(paren
id|tcur
comma
id|level
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|tcur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If there&squot;s a left sibling, see if it&squot;s ok to shift an entry&n;&t; * out of it.&n;&t; */
r_if
c_cond
(paren
id|lbno
op_ne
id|NULLAGBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t; * Move the temp cursor to the first entry in the&n;&t;&t; * previous block.&n;&t;&t; */
id|i
op_assign
id|xfs_btree_firstrec
c_func
(paren
id|tcur
comma
id|level
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|tcur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|xfs_btree_firstrec
c_func
(paren
id|tcur
comma
id|level
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Grab a pointer to the block.&n;&t;&t; */
id|lbp
op_assign
id|tcur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|left
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|lbp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|left
comma
id|level
comma
id|lbp
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Grab the current block number, for future use.&n;&t;&t; */
id|bno
op_assign
id|INT_GET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If left block is full enough so that removing one entry&n;&t;&t; * won&squot;t make it too empty, and right-shifting an entry out&n;&t;&t; * of left to us works, we&squot;re done.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
op_ge
id|XFS_ALLOC_BLOCK_MINRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_rshift
c_func
(paren
id|tcur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_ge
id|XFS_ALLOC_BLOCK_MINRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|0
)paren
id|cur-&gt;bc_ptrs
(braket
l_int|0
)braket
op_increment
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Otherwise, grab the number of records in right for&n;&t;&t; * future reference.&n;&t;&t; */
id|lrecs
op_assign
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Delete the temp cursor, we&squot;re done with it.&n;&t; */
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If here, we need to do a join to keep the tree balanced.&n;&t; */
id|ASSERT
c_func
(paren
id|bno
op_ne
id|NULLAGBLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if we can join with the left neighbor block.&n;&t; */
r_if
c_cond
(paren
id|lbno
op_ne
id|NULLAGBLOCK
op_logical_and
id|lrecs
op_plus
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_le
id|XFS_ALLOC_BLOCK_MAXRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set &quot;right&quot; to be the starting block,&n;&t;&t; * &quot;left&quot; to be the left neighbor.&n;&t;&t; */
id|rbno
op_assign
id|bno
suffix:semicolon
id|right
op_assign
id|block
suffix:semicolon
id|rbp
op_assign
id|bp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|lbno
comma
l_int|0
comma
op_amp
id|lbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|left
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|lbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|left
comma
id|level
comma
id|lbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If that won&squot;t work, see if we can join with the right neighbor block.&n;&t; */
r_else
r_if
c_cond
(paren
id|rbno
op_ne
id|NULLAGBLOCK
op_logical_and
id|rrecs
op_plus
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_le
id|XFS_ALLOC_BLOCK_MAXRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set &quot;left&quot; to be the starting block,&n;&t;&t; * &quot;right&quot; to be the right neighbor.&n;&t;&t; */
id|lbno
op_assign
id|bno
suffix:semicolon
id|left
op_assign
id|block
suffix:semicolon
id|lbp
op_assign
id|bp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|rbno
comma
l_int|0
comma
op_amp
id|rbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|right
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|right
comma
id|level
comma
id|rbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Otherwise, we can&squot;t fix the imbalance.&n;&t; * Just return.  This is probably a logic error, but it&squot;s not fatal.&n;&t; */
r_else
(brace
r_if
c_cond
(paren
id|level
OG
l_int|0
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We&squot;re now going to join &quot;left&quot; and &quot;right&quot; by moving all the stuff&n;&t; * in &quot;right&quot; to &quot;left&quot; and deleting &quot;right&quot;.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s a non-leaf.  Move keys and pointers.&n;&t;&t; */
id|lkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|left
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|lpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|left
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|rkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|rpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
id|rpp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
id|memcpy
c_func
(paren
id|lkp
comma
id|rkp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|lkp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: structure copy */
id|memcpy
c_func
(paren
id|lpp
comma
id|rpp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|lpp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: structure copy */
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|lbp
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|lbp
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s a leaf.  Move records.&n;&t;&t; */
id|lrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|left
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|rrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|lrp
comma
id|rrp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|lrp
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|lbp
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we joined with the left neighbor, set the buffer in the&n;&t; * cursor to the left block, and fix up the index.&n;&t; */
r_if
c_cond
(paren
id|bp
op_ne
id|lbp
)paren
(brace
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|level
comma
id|lbp
)paren
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_add_assign
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we joined with the right neighbor and there&squot;s a level above&n;&t; * us, increment the cursor at that level.&n;&t; */
r_else
r_if
c_cond
(paren
id|level
op_plus
l_int|1
OL
id|cur-&gt;bc_nlevels
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|cur
comma
id|level
op_plus
l_int|1
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the number of records in the surviving block.&n;&t; */
id|INT_MOD
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the right block pointer in the surviving block, and log it.&n;&t; */
id|left-&gt;bb_rightsib
op_assign
id|right-&gt;bb_rightsib
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|lbp
comma
id|XFS_BB_NUMRECS
op_or
id|XFS_BB_RIGHTSIB
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there is a right sibling now, make it point to the&n;&t; * remaining block.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
id|xfs_alloc_block_t
op_star
id|rrblock
suffix:semicolon
id|xfs_buf_t
op_star
id|rrbp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|0
comma
op_amp
id|rrbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|rrblock
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rrbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|rrblock
comma
id|level
comma
id|rrbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|INT_SET
c_func
(paren
id|rrblock-&gt;bb_leftsib
comma
id|ARCH_CONVERT
comma
id|lbno
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|rrbp
comma
id|XFS_BB_LEFTSIB
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Free the deleting block by putting it on the freelist.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_put_freelist
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
l_int|NULL
comma
id|rbno
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Since blocks move to the free list without the coordination&n;&t; * used in xfs_bmap_finish, we can&squot;t allow block to be available&n;&t; * for reallocation and non-transaction writing (user data)&n;&t; * until we know that the transaction that moved it to the free&n;&t; * list is permanently on disk. We track the blocks by declaring&n;&t; * these blocks as &quot;busy&quot;; the busy list is maintained on a&n;&t; * per-ag basis and each transaction records which entries&n;&t; * should be removed when the iclog commits to disk. If a&n;&t; * busy block is allocated, the iclog is pushed up to the&n;&t; * LSN that freed the block.&n;&t; */
id|xfs_alloc_mark_busy
c_func
(paren
id|cur-&gt;bc_tp
comma
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|bno
comma
l_int|1
)paren
suffix:semicolon
id|xfs_trans_agbtree_delta
c_func
(paren
id|cur-&gt;bc_tp
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the current level&squot;s cursor so that we&squot;re left referring&n;&t; * to the right node, after we&squot;re done.&n;&t; * If this leaves the ptr value 0 our caller will fix it up.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * Return value means the next level up has something to do.&n;&t; */
op_star
id|stat
op_assign
l_int|2
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert one record/level.  Return information to the caller&n; * allowing the next level up to proceed if necessary.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_insrec
id|xfs_alloc_insrec
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level to insert record at */
id|xfs_agblock_t
op_star
id|bnop
comma
multiline_comment|/* i/o: block number inserted */
id|xfs_alloc_rec_t
op_star
id|recp
comma
multiline_comment|/* i/o: record data inserted */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* output: new cursor replacing cur */
r_int
op_star
id|stat
)paren
multiline_comment|/* output: success/failure */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* allocation group freelist header */
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block record/key lives in */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* loop index */
id|xfs_alloc_key_t
id|key
suffix:semicolon
multiline_comment|/* key value being inserted */
id|xfs_alloc_key_t
op_star
id|kp
suffix:semicolon
multiline_comment|/* pointer to btree keys */
id|xfs_agblock_t
id|nbno
suffix:semicolon
multiline_comment|/* block number of allocated block */
id|xfs_btree_cur_t
op_star
id|ncur
suffix:semicolon
multiline_comment|/* new cursor to be used at next lvl */
id|xfs_alloc_key_t
id|nkey
suffix:semicolon
multiline_comment|/* new key value, from split */
id|xfs_alloc_rec_t
id|nrec
suffix:semicolon
multiline_comment|/* new record value, for caller */
r_int
id|optr
suffix:semicolon
multiline_comment|/* old ptr value */
id|xfs_alloc_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* pointer to btree addresses */
r_int
id|ptr
suffix:semicolon
multiline_comment|/* index in btree block for this rec */
id|xfs_alloc_rec_t
op_star
id|rp
suffix:semicolon
multiline_comment|/* pointer to btree records */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|recp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we made it to the root level, allocate a new root block&n;&t; * and we&squot;re done.&n;&t; */
r_if
c_cond
(paren
id|level
op_ge
id|cur-&gt;bc_nlevels
)paren
(brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_abt_insrec
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_newroot
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
op_star
id|bnop
op_assign
id|NULLAGBLOCK
suffix:semicolon
op_star
id|stat
op_assign
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make a key out of the record data to be inserted, and save it.&n;&t; */
id|key.ar_startblock
op_assign
id|recp-&gt;ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|key.ar_blockcount
op_assign
id|recp-&gt;ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|optr
op_assign
id|ptr
op_assign
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re off the left edge, return failure.&n;&t; */
r_if
c_cond
(paren
id|ptr
op_eq
l_int|0
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_abt_insrec
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get pointers to the btree buffer and block.&n;&t; */
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Check that the new entry is being inserted in the right place.&n;&t; */
r_if
c_cond
(paren
id|ptr
op_le
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|level
op_eq
l_int|0
)paren
(brace
id|rp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
id|ptr
comma
id|cur
)paren
suffix:semicolon
id|xfs_btree_check_rec
c_func
(paren
id|cur-&gt;bc_btnum
comma
id|recp
comma
id|rp
)paren
suffix:semicolon
)brace
r_else
(brace
id|kp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|block
comma
id|ptr
comma
id|cur
)paren
suffix:semicolon
id|xfs_btree_check_key
c_func
(paren
id|cur-&gt;bc_btnum
comma
op_amp
id|key
comma
id|kp
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|nbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
id|ncur
op_assign
(paren
id|xfs_btree_cur_t
op_star
)paren
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If the block is full, we can&squot;t insert the new entry until we&n;&t; * make the block un-full.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ALLOC_BLOCK_MAXRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * First, try shifting an entry to the right neighbor.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_rshift
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
multiline_comment|/* nothing */
)brace
multiline_comment|/*&n;&t;&t; * Next, try shifting an entry to the left neighbor.&n;&t;&t; */
r_else
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lshift
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|optr
op_assign
id|ptr
op_assign
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Next, try splitting the current block in&n;&t;&t;&t;&t; * half. If this works we have to re-set our&n;&t;&t;&t;&t; * variables because we could be in a&n;&t;&t;&t;&t; * different block now.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_split
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|nbno
comma
op_amp
id|nkey
comma
op_amp
id|ncur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
id|ptr
op_assign
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
suffix:semicolon
id|nrec.ar_startblock
op_assign
id|nkey.ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|nrec.ar_blockcount
op_assign
id|nkey.ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Otherwise the insert fails.&n;&t;&t;&t;&t; */
r_else
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t; * At this point we know there&squot;s room for our new entry in the block&n;&t; * we&squot;re pointing at.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s a non-leaf entry.  Make a hole for the new data&n;&t;&t; * in the key and ptr regions of the block.&n;&t;&t; */
id|kp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|pp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_ge
id|ptr
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
id|pp
(braket
id|i
op_minus
l_int|1
)braket
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
id|memmove
c_func
(paren
op_amp
id|kp
(braket
id|ptr
)braket
comma
op_amp
id|kp
(braket
id|ptr
op_minus
l_int|1
)braket
comma
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
id|ptr
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|kp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: copy */
id|memmove
c_func
(paren
op_amp
id|pp
(braket
id|ptr
)braket
comma
op_amp
id|pp
(braket
id|ptr
op_minus
l_int|1
)braket
comma
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
id|ptr
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|pp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: copy */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
op_star
id|bnop
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Now stuff the new data in, bump numrecs and log the new data.&n;&t;&t; */
id|kp
(braket
id|ptr
op_minus
l_int|1
)braket
op_assign
id|key
suffix:semicolon
id|INT_SET
c_func
(paren
id|pp
(braket
id|ptr
op_minus
l_int|1
)braket
comma
id|ARCH_CONVERT
comma
op_star
id|bnop
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|bp
comma
id|ptr
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|bp
comma
id|ptr
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ptr
OL
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
id|xfs_btree_check_key
c_func
(paren
id|cur-&gt;bc_btnum
comma
id|kp
op_plus
id|ptr
op_minus
l_int|1
comma
id|kp
op_plus
id|ptr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s a leaf entry.  Make a hole for the new record.&n;&t;&t; */
id|rp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|rp
(braket
id|ptr
)braket
comma
op_amp
id|rp
(braket
id|ptr
op_minus
l_int|1
)braket
comma
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
id|ptr
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|rp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now stuff the new record in, bump numrecs&n;&t;&t; * and log the new data.&n;&t;&t; */
id|rp
(braket
id|ptr
op_minus
l_int|1
)braket
op_assign
op_star
id|recp
suffix:semicolon
multiline_comment|/* INT_: struct copy */
id|INT_MOD
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|bp
comma
id|ptr
comma
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ptr
OL
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
id|xfs_btree_check_rec
c_func
(paren
id|cur-&gt;bc_btnum
comma
id|rp
op_plus
id|ptr
op_minus
l_int|1
comma
id|rp
op_plus
id|ptr
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Log the new number of records in the btree header.&n;&t; */
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|bp
comma
id|XFS_BB_NUMRECS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we inserted at the start of a block, update the parents&squot; keys.&n;&t; */
r_if
c_cond
(paren
id|optr
op_eq
l_int|1
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_updkey
c_func
(paren
id|cur
comma
op_amp
id|key
comma
id|level
op_plus
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Look to see if the longest extent in the allocation group&n;&t; * needs to be updated.&n;&t; */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|cur-&gt;bc_private.a.agbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
l_int|0
op_logical_and
id|cur-&gt;bc_btnum
op_eq
id|XFS_BTNUM_CNT
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
op_logical_and
id|INT_GET
c_func
(paren
id|recp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If this is a leaf in the by-size btree and there&n;&t;&t; * is no right sibling block and this block is bigger&n;&t;&t; * than the previous longest block, update it.&n;&t;&t; */
id|INT_COPY
c_func
(paren
id|agf-&gt;agf_longest
comma
id|recp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|cur-&gt;bc_mp-&gt;m_perag
(braket
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
)braket
dot
id|pagf_longest
op_assign
id|INT_GET
c_func
(paren
id|recp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
id|XFS_AGF_LONGEST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return the new block number, if any.&n;&t; * If there is one, give back a record value and a cursor too.&n;&t; */
op_star
id|bnop
op_assign
id|nbno
suffix:semicolon
r_if
c_cond
(paren
id|nbno
op_ne
id|NULLAGBLOCK
)paren
(brace
op_star
id|recp
op_assign
id|nrec
suffix:semicolon
multiline_comment|/* INT_: struct copy */
op_star
id|curp
op_assign
id|ncur
suffix:semicolon
multiline_comment|/* INT_: struct copy */
)brace
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Log header fields from a btree block.&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_log_block
id|xfs_alloc_log_block
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|bp
comma
multiline_comment|/* buffer containing btree block */
r_int
id|fields
)paren
multiline_comment|/* mask of fields: XFS_BB_... */
(brace
r_int
id|first
suffix:semicolon
multiline_comment|/* first byte offset logged */
r_int
id|last
suffix:semicolon
multiline_comment|/* last byte offset logged */
r_static
r_const
r_int
id|offsets
(braket
)braket
op_assign
(brace
multiline_comment|/* table of offsets */
m_offsetof
(paren
id|xfs_alloc_block_t
comma
id|bb_magic
)paren
comma
m_offsetof
(paren
id|xfs_alloc_block_t
comma
id|bb_level
)paren
comma
m_offsetof
(paren
id|xfs_alloc_block_t
comma
id|bb_numrecs
)paren
comma
m_offsetof
(paren
id|xfs_alloc_block_t
comma
id|bb_leftsib
)paren
comma
m_offsetof
(paren
id|xfs_alloc_block_t
comma
id|bb_rightsib
)paren
comma
r_sizeof
(paren
id|xfs_alloc_block_t
)paren
)brace
suffix:semicolon
id|xfs_btree_offsets
c_func
(paren
id|fields
comma
id|offsets
comma
id|XFS_BB_NUM_BITS
comma
op_amp
id|first
comma
op_amp
id|last
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log keys from a btree block (nonleaf).&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_log_keys
id|xfs_alloc_log_keys
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_buf_t
op_star
id|bp
comma
multiline_comment|/* buffer containing btree block */
r_int
id|kfirst
comma
multiline_comment|/* index of first key to log */
r_int
id|klast
)paren
multiline_comment|/* index of last key to log */
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block to log from */
r_int
id|first
suffix:semicolon
multiline_comment|/* first byte offset logged */
id|xfs_alloc_key_t
op_star
id|kp
suffix:semicolon
multiline_comment|/* key pointer in btree block */
r_int
id|last
suffix:semicolon
multiline_comment|/* last byte offset logged */
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
id|kp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|first
op_assign
(paren
r_int
)paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|kp
(braket
id|kfirst
op_minus
l_int|1
)braket
op_minus
(paren
id|xfs_caddr_t
)paren
id|block
)paren
suffix:semicolon
id|last
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|kp
(braket
id|klast
)braket
op_minus
l_int|1
)paren
op_minus
(paren
id|xfs_caddr_t
)paren
id|block
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|bp
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log block pointer fields from a btree block (nonleaf).&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_log_ptrs
id|xfs_alloc_log_ptrs
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_buf_t
op_star
id|bp
comma
multiline_comment|/* buffer containing btree block */
r_int
id|pfirst
comma
multiline_comment|/* index of first pointer to log */
r_int
id|plast
)paren
multiline_comment|/* index of last pointer to log */
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block to log from */
r_int
id|first
suffix:semicolon
multiline_comment|/* first byte offset logged */
r_int
id|last
suffix:semicolon
multiline_comment|/* last byte offset logged */
id|xfs_alloc_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* block-pointer pointer in btree blk */
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
id|pp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|first
op_assign
(paren
r_int
)paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|pp
(braket
id|pfirst
op_minus
l_int|1
)braket
op_minus
(paren
id|xfs_caddr_t
)paren
id|block
)paren
suffix:semicolon
id|last
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|pp
(braket
id|plast
)braket
op_minus
l_int|1
)paren
op_minus
(paren
id|xfs_caddr_t
)paren
id|block
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|bp
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log records from a btree block (leaf).&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_log_recs
id|xfs_alloc_log_recs
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_buf_t
op_star
id|bp
comma
multiline_comment|/* buffer containing btree block */
r_int
id|rfirst
comma
multiline_comment|/* index of first record to log */
r_int
id|rlast
)paren
multiline_comment|/* index of last record to log */
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block to log from */
r_int
id|first
suffix:semicolon
multiline_comment|/* first byte offset logged */
r_int
id|last
suffix:semicolon
multiline_comment|/* last byte offset logged */
id|xfs_alloc_rec_t
op_star
id|rp
suffix:semicolon
multiline_comment|/* record pointer for btree block */
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
id|rp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
id|xfs_alloc_rec_t
op_star
id|p
suffix:semicolon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|cur-&gt;bc_private.a.agbp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|rp
(braket
id|rfirst
op_minus
l_int|1
)braket
suffix:semicolon
id|p
op_le
op_amp
id|rp
(braket
id|rlast
op_minus
l_int|1
)braket
suffix:semicolon
id|p
op_increment
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|p-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|p-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|first
op_assign
(paren
r_int
)paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|rp
(braket
id|rfirst
op_minus
l_int|1
)braket
op_minus
(paren
id|xfs_caddr_t
)paren
id|block
)paren
suffix:semicolon
id|last
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|rp
(braket
id|rlast
)braket
op_minus
l_int|1
)paren
op_minus
(paren
id|xfs_caddr_t
)paren
id|block
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|bp
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup the record.  The cursor is made to point to it, based on dir.&n; * Return 0 if can&squot;t find any such record, 1 for success.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_lookup
id|xfs_alloc_lookup
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_lookup_t
id|dir
comma
multiline_comment|/* &lt;=, ==, or &gt;= */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
id|xfs_agblock_t
id|agbno
suffix:semicolon
multiline_comment|/* a.g. relative btree block number */
id|xfs_agnumber_t
id|agno
suffix:semicolon
multiline_comment|/* allocation group number */
id|xfs_alloc_block_t
op_star
id|block
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* current btree block */
r_int
id|diff
suffix:semicolon
multiline_comment|/* difference for the current key */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|keyno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* current key number */
r_int
id|level
suffix:semicolon
multiline_comment|/* level in the btree */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount point */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_abt_lookup
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the allocation group header, and the root block number.&n;&t; */
id|mp
op_assign
id|cur-&gt;bc_mp
suffix:semicolon
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freespace header */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|cur-&gt;bc_private.a.agbp
)paren
suffix:semicolon
id|agno
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|agbno
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_roots
(braket
id|cur-&gt;bc_btnum
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Iterate over each level in the btree, starting at the root.&n;&t; * For each level above the leaves, find the key we need, based&n;&t; * on the lookup record, then follow the corresponding block&n;&t; * pointer down to the next level.&n;&t; */
r_for
c_loop
(paren
id|level
op_assign
id|cur-&gt;bc_nlevels
op_minus
l_int|1
comma
id|diff
op_assign
l_int|1
suffix:semicolon
id|level
op_ge
l_int|0
suffix:semicolon
id|level
op_decrement
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer pointer for btree block */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* disk address of btree block */
multiline_comment|/*&n;&t;&t; * Get the disk address we&squot;re looking for.&n;&t;&t; */
id|d
op_assign
id|XFS_AGB_TO_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the old buffer at this level is for a different block,&n;&t;&t; * throw it away, otherwise just use it.&n;&t;&t; */
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_logical_and
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_ne
id|d
)paren
id|bp
op_assign
(paren
id|xfs_buf_t
op_star
)paren
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Need to get a new buffer.  Read it, then&n;&t;&t;&t; * set it in the cursor, releasing the old one.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|mp
comma
id|cur-&gt;bc_tp
comma
id|agno
comma
id|agbno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|level
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Point to the btree block, now that we have the buffer&n;&t;&t;&t; */
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_else
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we already had a key match at a higher level, we know&n;&t;&t; * we need to use the first entry in this block.&n;&t;&t; */
r_if
c_cond
(paren
id|diff
op_eq
l_int|0
)paren
id|keyno
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Otherwise we need to search this block.  Do a binary search.&n;&t;&t; */
r_else
(brace
r_int
id|high
suffix:semicolon
multiline_comment|/* high entry number */
id|xfs_alloc_key_t
op_star
id|kkbase
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* base of keys in block */
id|xfs_alloc_rec_t
op_star
id|krbase
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* base of records in block */
r_int
id|low
suffix:semicolon
multiline_comment|/* low entry number */
multiline_comment|/*&n;&t;&t;&t; * Get a pointer to keys or records.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
id|kkbase
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
r_else
id|krbase
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set low and high entry numbers, 1-based.&n;&t;&t;&t; */
id|low
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|high
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If the block is empty, the tree must&n;&t;&t;&t;&t; * be an empty leaf.&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|level
op_eq
l_int|0
op_logical_and
id|cur-&gt;bc_nlevels
op_eq
l_int|1
)paren
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
l_int|0
)braket
op_assign
id|dir
op_ne
id|XFS_LOOKUP_LE
suffix:semicolon
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Binary search the block.&n;&t;&t;&t; */
r_while
c_loop
(paren
id|low
op_le
id|high
)paren
(brace
id|xfs_extlen_t
id|blockcount
suffix:semicolon
multiline_comment|/* key value */
id|xfs_agblock_t
id|startblock
suffix:semicolon
multiline_comment|/* key value */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_abt_compare
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * keyno is average of low and high.&n;&t;&t;&t;&t; */
id|keyno
op_assign
(paren
id|low
op_plus
id|high
)paren
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Get startblock &amp; blockcount.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
id|xfs_alloc_key_t
op_star
id|kkp
suffix:semicolon
id|kkp
op_assign
id|kkbase
op_plus
id|keyno
op_minus
l_int|1
suffix:semicolon
id|startblock
op_assign
id|INT_GET
c_func
(paren
id|kkp-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|blockcount
op_assign
id|INT_GET
c_func
(paren
id|kkp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_alloc_rec_t
op_star
id|krp
suffix:semicolon
id|krp
op_assign
id|krbase
op_plus
id|keyno
op_minus
l_int|1
suffix:semicolon
id|startblock
op_assign
id|INT_GET
c_func
(paren
id|krp-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|blockcount
op_assign
id|INT_GET
c_func
(paren
id|krp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Compute difference to get next direction.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|cur-&gt;bc_btnum
op_eq
id|XFS_BTNUM_BNO
)paren
id|diff
op_assign
(paren
r_int
)paren
id|startblock
op_minus
(paren
r_int
)paren
id|cur-&gt;bc_rec.a.ar_startblock
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|diff
op_assign
(paren
r_int
)paren
id|blockcount
op_minus
(paren
r_int
)paren
id|cur-&gt;bc_rec.a.ar_blockcount
)paren
)paren
id|diff
op_assign
(paren
r_int
)paren
id|startblock
op_minus
(paren
r_int
)paren
id|cur-&gt;bc_rec.a.ar_startblock
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Less than, move right.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|diff
OL
l_int|0
)paren
id|low
op_assign
id|keyno
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Greater than, move left.&n;&t;&t;&t;&t; */
r_else
r_if
c_cond
(paren
id|diff
OG
l_int|0
)paren
id|high
op_assign
id|keyno
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Equal, we&squot;re done.&n;&t;&t;&t;&t; */
r_else
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If there are more levels, set up for the next level&n;&t;&t; * by getting the block number and filling in the cursor.&n;&t;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we moved left, need the previous key number,&n;&t;&t;&t; * unless there isn&squot;t one.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|diff
OG
l_int|0
op_logical_and
op_decrement
id|keyno
OL
l_int|1
)paren
id|keyno
op_assign
l_int|1
suffix:semicolon
id|agbno
op_assign
id|INT_GET
c_func
(paren
op_star
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|block
comma
id|keyno
comma
id|cur
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|agbno
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_assign
id|keyno
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Done with the search.&n;&t; * See if we need to adjust the results.&n;&t; */
r_if
c_cond
(paren
id|dir
op_ne
id|XFS_LOOKUP_LE
op_logical_and
id|diff
OL
l_int|0
)paren
(brace
id|keyno
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If ge search and we went off the end of the block, but it&squot;s&n;&t;&t; * not the last block, we&squot;re in the wrong block.&n;&t;&t; */
r_if
c_cond
(paren
id|dir
op_eq
id|XFS_LOOKUP_GE
op_logical_and
id|keyno
OG
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
r_int
id|i
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
l_int|0
)braket
op_assign
id|keyno
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dir
op_eq
id|XFS_LOOKUP_LE
op_logical_and
id|diff
OG
l_int|0
)paren
id|keyno
op_decrement
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
l_int|0
)braket
op_assign
id|keyno
suffix:semicolon
multiline_comment|/*&n;&t; * Return if we succeeded or not.&n;&t; */
r_if
c_cond
(paren
id|keyno
op_eq
l_int|0
op_logical_or
id|keyno
OG
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_else
op_star
id|stat
op_assign
(paren
(paren
id|dir
op_ne
id|XFS_LOOKUP_EQ
)paren
op_logical_or
(paren
id|diff
op_eq
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move 1 record left from cur/level if possible.&n; * Update cur to reflect the new path.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_lshift
id|xfs_alloc_lshift
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level to shift record on */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#ifdef DEBUG
r_int
id|i
suffix:semicolon
multiline_comment|/* loop index */
macro_line|#endif
id|xfs_alloc_key_t
id|key
suffix:semicolon
multiline_comment|/* key value for leaf level upward */
id|xfs_buf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* buffer for left neighbor block */
id|xfs_alloc_block_t
op_star
id|left
suffix:semicolon
multiline_comment|/* left neighbor btree block */
r_int
id|nrec
suffix:semicolon
multiline_comment|/* new number of left block entries */
id|xfs_buf_t
op_star
id|rbp
suffix:semicolon
multiline_comment|/* buffer for right (current) block */
id|xfs_alloc_block_t
op_star
id|right
suffix:semicolon
multiline_comment|/* right (current) btree block */
id|xfs_alloc_key_t
op_star
id|rkp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* key pointer for right block */
id|xfs_alloc_ptr_t
op_star
id|rpp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* address pointer for right block */
id|xfs_alloc_rec_t
op_star
id|rrp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* record pointer for right block */
multiline_comment|/*&n;&t; * Set up variables for this block as &quot;right&quot;.&n;&t; */
id|rbp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|right
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rbp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|right
comma
id|level
comma
id|rbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If we&squot;ve got no left sibling then we can&squot;t shift an entry left.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|right-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the cursor entry is the one that would be moved, don&squot;t&n;&t; * do it... it&squot;s too complicated.&n;&t; */
r_if
c_cond
(paren
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_le
l_int|1
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set up the left neighbor as &quot;left&quot;.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|0
comma
op_amp
id|lbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|left
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|lbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|left
comma
id|level
comma
id|lbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s full, it can&squot;t take another entry.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ALLOC_BLOCK_MAXRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nrec
op_assign
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If non-leaf, copy a key and a ptr to the left block.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
id|xfs_alloc_key_t
op_star
id|lkp
suffix:semicolon
multiline_comment|/* key pointer for left block */
id|xfs_alloc_ptr_t
op_star
id|lpp
suffix:semicolon
multiline_comment|/* address pointer for left block */
id|lkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|left
comma
id|nrec
comma
id|cur
)paren
suffix:semicolon
id|rkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
op_star
id|lkp
op_assign
op_star
id|rkp
suffix:semicolon
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|lbp
comma
id|nrec
comma
id|nrec
)paren
suffix:semicolon
id|lpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|left
comma
id|nrec
comma
id|cur
)paren
suffix:semicolon
id|rpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
op_star
id|rpp
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
op_star
id|lpp
op_assign
op_star
id|rpp
suffix:semicolon
multiline_comment|/* INT_: copy */
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|lbp
comma
id|nrec
comma
id|nrec
)paren
suffix:semicolon
id|xfs_btree_check_key
c_func
(paren
id|cur-&gt;bc_btnum
comma
id|lkp
op_minus
l_int|1
comma
id|lkp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If leaf, copy a record to the left block.&n;&t; */
r_else
(brace
id|xfs_alloc_rec_t
op_star
id|lrp
suffix:semicolon
multiline_comment|/* record pointer for left block */
id|lrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|left
comma
id|nrec
comma
id|cur
)paren
suffix:semicolon
id|rrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
op_star
id|lrp
op_assign
op_star
id|rrp
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|lbp
comma
id|nrec
comma
id|nrec
)paren
suffix:semicolon
id|xfs_btree_check_rec
c_func
(paren
id|cur-&gt;bc_btnum
comma
id|lrp
op_minus
l_int|1
comma
id|lrp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Bump and log left&squot;s numrecs, decrement and log right&squot;s numrecs.&n;&t; */
id|INT_MOD
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|lbp
comma
id|XFS_BB_NUMRECS
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|rbp
comma
id|XFS_BB_NUMRECS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Slide the contents of right down one entry.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
id|rpp
(braket
id|i
op_plus
l_int|1
)braket
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
id|memmove
c_func
(paren
id|rkp
comma
id|rkp
op_plus
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rkp
)paren
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|rpp
comma
id|rpp
op_plus
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rpp
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|memmove
c_func
(paren
id|rrp
comma
id|rrp
op_plus
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rrp
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|key.ar_startblock
op_assign
id|rrp-&gt;ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|key.ar_blockcount
op_assign
id|rrp-&gt;ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|rkp
op_assign
op_amp
id|key
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the parent key values of right.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_updkey
c_func
(paren
id|cur
comma
id|rkp
comma
id|level
op_plus
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Slide the cursor value left one.&n;&t; */
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_decrement
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a new root block, fill it in.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_newroot
id|xfs_alloc_newroot
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_agblock_t
id|lbno
suffix:semicolon
multiline_comment|/* left block number */
id|xfs_buf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* left btree buffer */
id|xfs_alloc_block_t
op_star
id|left
suffix:semicolon
multiline_comment|/* left btree block */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
id|xfs_agblock_t
id|nbno
suffix:semicolon
multiline_comment|/* new block number */
id|xfs_buf_t
op_star
id|nbp
suffix:semicolon
multiline_comment|/* new (root) buffer */
id|xfs_alloc_block_t
op_star
r_new
suffix:semicolon
multiline_comment|/* new (root) btree block */
r_int
id|nptr
suffix:semicolon
multiline_comment|/* new value for key index, 1 or 2 */
id|xfs_agblock_t
id|rbno
suffix:semicolon
multiline_comment|/* right block number */
id|xfs_buf_t
op_star
id|rbp
suffix:semicolon
multiline_comment|/* right btree buffer */
id|xfs_alloc_block_t
op_star
id|right
suffix:semicolon
multiline_comment|/* right btree block */
id|mp
op_assign
id|cur-&gt;bc_mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|cur-&gt;bc_nlevels
OL
id|XFS_AG_MAXLEVELS
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get a buffer from the freelist blocks, for the new root.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_freelist
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
op_amp
id|nbno
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * None available, we fail.&n;&t; */
r_if
c_cond
(paren
id|nbno
op_eq
id|NULLAGBLOCK
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_trans_agbtree_delta
c_func
(paren
id|cur-&gt;bc_tp
comma
l_int|1
)paren
suffix:semicolon
id|nbp
op_assign
id|xfs_btree_get_bufs
c_func
(paren
id|mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|nbno
comma
l_int|0
)paren
suffix:semicolon
r_new
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|nbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the root data in the a.g. freespace structure.&n;&t; */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freespace header */
id|xfs_agnumber_t
id|seqno
suffix:semicolon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|cur-&gt;bc_private.a.agbp
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|agf-&gt;agf_roots
(braket
id|cur-&gt;bc_btnum
)braket
comma
id|ARCH_CONVERT
comma
id|nbno
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|cur-&gt;bc_btnum
)braket
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|seqno
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|seqno
)braket
dot
id|pagf_levels
(braket
id|cur-&gt;bc_btnum
)braket
op_increment
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
id|XFS_AGF_ROOTS
op_or
id|XFS_AGF_LEVELS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * At the previous root level there are now two blocks: the old&n;&t; * root, and the new block generated when it was split.&n;&t; * We don&squot;t know which one the cursor is pointing at, so we&n;&t; * set up variables &quot;left&quot; and &quot;right&quot; for each case.&n;&t; */
id|lbp
op_assign
id|cur-&gt;bc_bufs
(braket
id|cur-&gt;bc_nlevels
op_minus
l_int|1
)braket
suffix:semicolon
id|left
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|lbp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|left
comma
id|cur-&gt;bc_nlevels
op_minus
l_int|1
comma
id|lbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t; * Our block is left, pick up the right block.&n;&t;&t; */
id|lbno
op_assign
id|XFS_DADDR_TO_AGBNO
c_func
(paren
id|mp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|lbp
)paren
)paren
suffix:semicolon
id|rbno
op_assign
id|INT_GET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|rbno
comma
l_int|0
comma
op_amp
id|rbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|right
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|right
comma
id|cur-&gt;bc_nlevels
op_minus
l_int|1
comma
id|rbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|nptr
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Our block is right, pick up the left block.&n;&t;&t; */
id|rbp
op_assign
id|lbp
suffix:semicolon
id|right
op_assign
id|left
suffix:semicolon
id|rbno
op_assign
id|XFS_DADDR_TO_AGBNO
c_func
(paren
id|mp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|rbp
)paren
)paren
suffix:semicolon
id|lbno
op_assign
id|INT_GET
c_func
(paren
id|right-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|lbno
comma
l_int|0
comma
op_amp
id|lbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|left
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|lbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|left
comma
id|cur-&gt;bc_nlevels
op_minus
l_int|1
comma
id|lbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|nptr
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the new block&squot;s btree header and log it.&n;&t; */
id|INT_SET
c_func
(paren
r_new
op_member_access_from_pointer
id|bb_magic
comma
id|ARCH_CONVERT
comma
id|xfs_magics
(braket
id|cur-&gt;bc_btnum
)braket
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
r_new
op_member_access_from_pointer
id|bb_level
comma
id|ARCH_CONVERT
comma
(paren
id|__uint16_t
)paren
id|cur-&gt;bc_nlevels
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
r_new
op_member_access_from_pointer
id|bb_numrecs
comma
id|ARCH_CONVERT
comma
l_int|2
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
r_new
op_member_access_from_pointer
id|bb_leftsib
comma
id|ARCH_CONVERT
comma
id|NULLAGBLOCK
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
r_new
op_member_access_from_pointer
id|bb_rightsib
comma
id|ARCH_CONVERT
comma
id|NULLAGBLOCK
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|nbp
comma
id|XFS_BB_ALL_BITS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lbno
op_ne
id|NULLAGBLOCK
op_logical_and
id|rbno
op_ne
id|NULLAGBLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the key data in the new root.&n;&t; */
(brace
id|xfs_alloc_key_t
op_star
id|kp
suffix:semicolon
multiline_comment|/* btree key pointer */
id|kp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
r_new
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_level
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
(brace
id|kp
(braket
l_int|0
)braket
op_assign
op_star
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|left
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
multiline_comment|/* INT_: structure copy */
id|kp
(braket
l_int|1
)braket
op_assign
op_star
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
multiline_comment|/* INT_: structure copy */
)brace
r_else
(brace
id|xfs_alloc_rec_t
op_star
id|rp
suffix:semicolon
multiline_comment|/* btree record pointer */
id|rp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|left
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|kp
(braket
l_int|0
)braket
dot
id|ar_startblock
op_assign
id|rp-&gt;ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|kp
(braket
l_int|0
)braket
dot
id|ar_blockcount
op_assign
id|rp-&gt;ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|rp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|kp
(braket
l_int|1
)braket
dot
id|ar_startblock
op_assign
id|rp-&gt;ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|kp
(braket
l_int|1
)braket
dot
id|ar_blockcount
op_assign
id|rp-&gt;ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
)brace
)brace
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|nbp
comma
l_int|1
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the pointer data in the new root.&n;&t; */
(brace
id|xfs_alloc_ptr_t
op_star
id|pp
suffix:semicolon
multiline_comment|/* btree address pointer */
id|pp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
r_new
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|pp
(braket
l_int|0
)braket
comma
id|ARCH_CONVERT
comma
id|lbno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|pp
(braket
l_int|1
)braket
comma
id|ARCH_CONVERT
comma
id|rbno
)paren
suffix:semicolon
)brace
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|nbp
comma
l_int|1
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the cursor.&n;&t; */
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|cur-&gt;bc_nlevels
comma
id|nbp
)paren
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
id|cur-&gt;bc_nlevels
)braket
op_assign
id|nptr
suffix:semicolon
id|cur-&gt;bc_nlevels
op_increment
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move 1 record right from cur/level if possible.&n; * Update cur to reflect the new path.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_rshift
id|xfs_alloc_rshift
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level to shift record on */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* loop index */
id|xfs_alloc_key_t
id|key
suffix:semicolon
multiline_comment|/* key value for leaf level upward */
id|xfs_buf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* buffer for left (current) block */
id|xfs_alloc_block_t
op_star
id|left
suffix:semicolon
multiline_comment|/* left (current) btree block */
id|xfs_buf_t
op_star
id|rbp
suffix:semicolon
multiline_comment|/* buffer for right neighbor block */
id|xfs_alloc_block_t
op_star
id|right
suffix:semicolon
multiline_comment|/* right neighbor btree block */
id|xfs_alloc_key_t
op_star
id|rkp
suffix:semicolon
multiline_comment|/* key pointer for right block */
id|xfs_btree_cur_t
op_star
id|tcur
suffix:semicolon
multiline_comment|/* temporary cursor */
multiline_comment|/*&n;&t; * Set up variables for this block as &quot;left&quot;.&n;&t; */
id|lbp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|left
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|lbp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|left
comma
id|level
comma
id|lbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If we&squot;ve got no right sibling then we can&squot;t shift an entry right.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the cursor entry is the one that would be moved, don&squot;t&n;&t; * do it... it&squot;s too complicated.&n;&t; */
r_if
c_cond
(paren
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_ge
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set up the right neighbor as &quot;right&quot;.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|0
comma
op_amp
id|rbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|right
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|right
comma
id|level
comma
id|rbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s full, it can&squot;t take another entry.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ALLOC_BLOCK_MAXRECS
c_func
(paren
id|level
comma
id|cur
)paren
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make a hole at the start of the right neighbor block, then&n;&t; * copy the last left block entry to the hole.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
id|xfs_alloc_key_t
op_star
id|lkp
suffix:semicolon
multiline_comment|/* key pointer for left block */
id|xfs_alloc_ptr_t
op_star
id|lpp
suffix:semicolon
multiline_comment|/* address pointer for left block */
id|xfs_alloc_ptr_t
op_star
id|rpp
suffix:semicolon
multiline_comment|/* address pointer for right block */
id|lkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|left
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
comma
id|cur
)paren
suffix:semicolon
id|lpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|left
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
comma
id|cur
)paren
suffix:semicolon
id|rkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|rpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
id|rpp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
id|memmove
c_func
(paren
id|rkp
op_plus
l_int|1
comma
id|rkp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rkp
)paren
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|rpp
op_plus
l_int|1
comma
id|rpp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rpp
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
op_star
id|lpp
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
op_star
id|rkp
op_assign
op_star
id|lkp
suffix:semicolon
multiline_comment|/* INT_: copy */
op_star
id|rpp
op_assign
op_star
id|lpp
suffix:semicolon
multiline_comment|/* INT_: copy */
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_btree_check_key
c_func
(paren
id|cur-&gt;bc_btnum
comma
id|rkp
comma
id|rkp
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_alloc_rec_t
op_star
id|lrp
suffix:semicolon
multiline_comment|/* record pointer for left block */
id|xfs_alloc_rec_t
op_star
id|rrp
suffix:semicolon
multiline_comment|/* record pointer for right block */
id|lrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|left
comma
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
comma
id|cur
)paren
suffix:semicolon
id|rrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|rrp
op_plus
l_int|1
comma
id|rrp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rrp
)paren
)paren
suffix:semicolon
op_star
id|rrp
op_assign
op_star
id|lrp
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|key.ar_startblock
op_assign
id|rrp-&gt;ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|key.ar_blockcount
op_assign
id|rrp-&gt;ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|rkp
op_assign
op_amp
id|key
suffix:semicolon
id|xfs_btree_check_rec
c_func
(paren
id|cur-&gt;bc_btnum
comma
id|rrp
comma
id|rrp
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decrement and log left&squot;s numrecs, bump and log right&squot;s numrecs.&n;&t; */
id|INT_MOD
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|lbp
comma
id|XFS_BB_NUMRECS
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|rbp
comma
id|XFS_BB_NUMRECS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Using a temporary cursor, update the parent key values of the&n;&t; * block on the right.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_dup_cursor
c_func
(paren
id|cur
comma
op_amp
id|tcur
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|i
op_assign
id|xfs_btree_lastrec
c_func
(paren
id|tcur
comma
id|level
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|tcur
comma
id|level
comma
op_amp
id|i
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|xfs_alloc_updkey
c_func
(paren
id|tcur
comma
id|rkp
comma
id|level
op_plus
l_int|1
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Split cur/level block in half.&n; * Return new block number and its first record (to be inserted into parent).&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_split
id|xfs_alloc_split
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level to split */
id|xfs_agblock_t
op_star
id|bnop
comma
multiline_comment|/* output: block number allocated */
id|xfs_alloc_key_t
op_star
id|keyp
comma
multiline_comment|/* output: first key of new block */
id|xfs_btree_cur_t
op_star
op_star
id|curp
comma
multiline_comment|/* output: new cursor */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* loop index/record number */
id|xfs_agblock_t
id|lbno
suffix:semicolon
multiline_comment|/* left (current) block number */
id|xfs_buf_t
op_star
id|lbp
suffix:semicolon
multiline_comment|/* buffer for left block */
id|xfs_alloc_block_t
op_star
id|left
suffix:semicolon
multiline_comment|/* left (current) btree block */
id|xfs_agblock_t
id|rbno
suffix:semicolon
multiline_comment|/* right (new) block number */
id|xfs_buf_t
op_star
id|rbp
suffix:semicolon
multiline_comment|/* buffer for right block */
id|xfs_alloc_block_t
op_star
id|right
suffix:semicolon
multiline_comment|/* right (new) btree block */
multiline_comment|/*&n;&t; * Allocate the new block from the freelist.&n;&t; * If we can&squot;t do it, we&squot;re toast.  Give up.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_freelist
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
op_amp
id|rbno
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|rbno
op_eq
id|NULLAGBLOCK
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_trans_agbtree_delta
c_func
(paren
id|cur-&gt;bc_tp
comma
l_int|1
)paren
suffix:semicolon
id|rbp
op_assign
id|xfs_btree_get_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|rbno
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the new block as &quot;right&quot;.&n;&t; */
id|right
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;Left&quot; is the current (according to the cursor) block.&n;&t; */
id|lbp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|left
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|lbp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|left
comma
id|level
comma
id|lbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Fill in the btree header for the new block.&n;&t; */
id|INT_SET
c_func
(paren
id|right-&gt;bb_magic
comma
id|ARCH_CONVERT
comma
id|xfs_magics
(braket
id|cur-&gt;bc_btnum
)braket
)paren
suffix:semicolon
id|right-&gt;bb_level
op_assign
id|left-&gt;bb_level
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|INT_SET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
(paren
id|__uint16_t
)paren
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_div
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that if there&squot;s an odd number of entries now, that&n;&t; * each new block will have the same number of entries.&n;&t; */
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_amp
l_int|1
)paren
op_logical_and
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_le
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
id|INT_MOD
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_assign
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * For non-leaf blocks, copy keys and addresses over to the new block.&n;&t; */
r_if
c_cond
(paren
id|level
OG
l_int|0
)paren
(brace
id|xfs_alloc_key_t
op_star
id|lkp
suffix:semicolon
multiline_comment|/* left btree key pointer */
id|xfs_alloc_ptr_t
op_star
id|lpp
suffix:semicolon
multiline_comment|/* left btree address pointer */
id|xfs_alloc_key_t
op_star
id|rkp
suffix:semicolon
multiline_comment|/* right btree key pointer */
id|xfs_alloc_ptr_t
op_star
id|rpp
suffix:semicolon
multiline_comment|/* right btree address pointer */
id|lkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|left
comma
id|i
comma
id|cur
)paren
suffix:semicolon
id|lpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|left
comma
id|i
comma
id|cur
)paren
suffix:semicolon
id|rkp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|rpp
op_assign
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sptr
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
id|lpp
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
comma
id|level
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
id|memcpy
c_func
(paren
id|rkp
comma
id|lkp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rkp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: copy */
id|memcpy
c_func
(paren
id|rpp
comma
id|lpp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rpp
)paren
)paren
suffix:semicolon
multiline_comment|/* INT_: copy */
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_ptrs
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
op_star
id|keyp
op_assign
op_star
id|rkp
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For leaf blocks, copy records over to the new block.&n;&t; */
r_else
(brace
id|xfs_alloc_rec_t
op_star
id|lrp
suffix:semicolon
multiline_comment|/* left btree record pointer */
id|xfs_alloc_rec_t
op_star
id|rrp
suffix:semicolon
multiline_comment|/* right btree record pointer */
id|lrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|left
comma
id|i
comma
id|cur
)paren
suffix:semicolon
id|rrp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|right
comma
l_int|1
comma
id|cur
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|rrp
comma
id|lrp
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|rrp
)paren
)paren
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|rbp
comma
l_int|1
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|keyp-&gt;ar_startblock
op_assign
id|rrp-&gt;ar_startblock
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|keyp-&gt;ar_blockcount
op_assign
id|rrp-&gt;ar_blockcount
suffix:semicolon
multiline_comment|/* INT_: direct copy */
)brace
multiline_comment|/*&n;&t; * Find the left block number by looking in the buffer.&n;&t; * Adjust numrecs, sibling pointers.&n;&t; */
id|lbno
op_assign
id|XFS_DADDR_TO_AGBNO
c_func
(paren
id|cur-&gt;bc_mp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|lbp
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|INT_GET
c_func
(paren
id|right-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|right-&gt;bb_rightsib
op_assign
id|left-&gt;bb_rightsib
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|INT_SET
c_func
(paren
id|left-&gt;bb_rightsib
comma
id|ARCH_CONVERT
comma
id|rbno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|right-&gt;bb_leftsib
comma
id|ARCH_CONVERT
comma
id|lbno
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|rbp
comma
id|XFS_BB_ALL_BITS
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|lbp
comma
id|XFS_BB_NUMRECS
op_or
id|XFS_BB_RIGHTSIB
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there&squot;s a block to the new block&squot;s right, make that block&n;&t; * point back to right instead of to left.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|right-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGBLOCK
)paren
(brace
id|xfs_alloc_block_t
op_star
id|rrblock
suffix:semicolon
multiline_comment|/* rr btree block */
id|xfs_buf_t
op_star
id|rrbp
suffix:semicolon
multiline_comment|/* buffer for rrblock */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|INT_GET
c_func
(paren
id|right-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
comma
l_int|0
comma
op_amp
id|rrbp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|rrblock
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|rrbp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|rrblock
comma
id|level
comma
id|rrbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|INT_SET
c_func
(paren
id|rrblock-&gt;bb_leftsib
comma
id|ARCH_CONVERT
comma
id|rbno
)paren
suffix:semicolon
id|xfs_alloc_log_block
c_func
(paren
id|cur-&gt;bc_tp
comma
id|rrbp
comma
id|XFS_BB_LEFTSIB
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the cursor is really in the right block, move it there.&n;&t; * If it&squot;s just pointing past the last entry in left, then we&squot;ll&n;&t; * insert there, so don&squot;t change anything in that case.&n;&t; */
r_if
c_cond
(paren
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
OG
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
(brace
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|level
comma
id|rbp
)paren
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_sub_assign
id|INT_GET
c_func
(paren
id|left-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are more levels, we&squot;ll need another cursor which refers to&n;&t; * the right block, no matter where this cursor was.&n;&t; */
r_if
c_cond
(paren
id|level
op_plus
l_int|1
OL
id|cur-&gt;bc_nlevels
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_dup_cursor
c_func
(paren
id|cur
comma
id|curp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
(paren
op_star
id|curp
)paren
op_member_access_from_pointer
id|bc_ptrs
(braket
id|level
op_plus
l_int|1
)braket
op_increment
suffix:semicolon
)brace
op_star
id|bnop
op_assign
id|rbno
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Update keys at all levels from here to the root along the cursor&squot;s path.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_updkey
id|xfs_alloc_updkey
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_alloc_key_t
op_star
id|keyp
comma
multiline_comment|/* new key value to update to */
r_int
id|level
)paren
multiline_comment|/* starting level for update */
(brace
r_int
id|ptr
suffix:semicolon
multiline_comment|/* index of key in block */
multiline_comment|/*&n;&t; * Go up the tree from this level toward the root.&n;&t; * At each level, update the key value to the value input.&n;&t; * Stop when we reach a level where the cursor isn&squot;t pointing&n;&t; * at the first entry in the block.&n;&t; */
r_for
c_loop
(paren
id|ptr
op_assign
l_int|1
suffix:semicolon
id|ptr
op_eq
l_int|1
op_logical_and
id|level
OL
id|cur-&gt;bc_nlevels
suffix:semicolon
id|level
op_increment
)paren
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for block */
macro_line|#ifdef DEBUG
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#endif
id|xfs_alloc_key_t
op_star
id|kp
suffix:semicolon
multiline_comment|/* ptr to btree block keys */
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
id|ptr
op_assign
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
suffix:semicolon
id|kp
op_assign
id|XFS_ALLOC_KEY_ADDR
c_func
(paren
id|block
comma
id|ptr
comma
id|cur
)paren
suffix:semicolon
op_star
id|kp
op_assign
op_star
id|keyp
suffix:semicolon
id|xfs_alloc_log_keys
c_func
(paren
id|cur
comma
id|bp
comma
id|ptr
comma
id|ptr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Externally visible routines.&n; */
multiline_comment|/*&n; * Decrement cursor by one record at the level.&n; * For nonzero levels the leaf-ward information is untouched.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_decrement
id|xfs_alloc_decrement
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level in btree, 0 is leaf */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|lev
suffix:semicolon
multiline_comment|/* btree level */
id|ASSERT
c_func
(paren
id|level
OL
id|cur-&gt;bc_nlevels
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read-ahead to the left at this level.&n;&t; */
id|xfs_btree_readahead
c_func
(paren
id|cur
comma
id|level
comma
id|XFS_BTCUR_LEFTRA
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Decrement the ptr at this level.  If we&squot;re still in the block&n;&t; * then we&squot;re done.&n;&t; */
r_if
c_cond
(paren
op_decrement
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
OG
l_int|0
)paren
(brace
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get a pointer to the btree block.&n;&t; */
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|cur-&gt;bc_bufs
(braket
id|level
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|cur-&gt;bc_bufs
(braket
id|level
)braket
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If we just went off the left edge of the tree, return failure.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_leftsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * March up the tree decrementing pointers.&n;&t; * Stop when we don&squot;t go off the left edge of a block.&n;&t; */
r_for
c_loop
(paren
id|lev
op_assign
id|level
op_plus
l_int|1
suffix:semicolon
id|lev
OL
id|cur-&gt;bc_nlevels
suffix:semicolon
id|lev
op_increment
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|cur-&gt;bc_ptrs
(braket
id|lev
)braket
OG
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read-ahead the left block, we&squot;re going to read it&n;&t;&t; * in the next loop.&n;&t;&t; */
id|xfs_btree_readahead
c_func
(paren
id|cur
comma
id|lev
comma
id|XFS_BTCUR_LEFTRA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we went off the root then we are seriously confused.&n;&t; */
id|ASSERT
c_func
(paren
id|lev
OL
id|cur-&gt;bc_nlevels
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now walk back down the tree, fixing up the cursor&squot;s buffer&n;&t; * pointers and key numbers.&n;&t; */
r_for
c_loop
(paren
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
)paren
suffix:semicolon
id|lev
OG
id|level
suffix:semicolon
)paren
(brace
id|xfs_agblock_t
id|agbno
suffix:semicolon
multiline_comment|/* block number of btree block */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer pointer for block */
id|agbno
op_assign
id|INT_GET
c_func
(paren
op_star
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|block
comma
id|cur-&gt;bc_ptrs
(braket
id|lev
)braket
comma
id|cur
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|agbno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|lev
op_decrement
suffix:semicolon
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|lev
comma
id|bp
)paren
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|lev
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
id|lev
)braket
op_assign
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete the record pointed to by cur.&n; * The cursor refers to the place where the record was (could be inserted)&n; * when the operation returns.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_delete
id|xfs_alloc_delete
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* result code */
r_int
id|level
suffix:semicolon
multiline_comment|/* btree level */
multiline_comment|/*&n;&t; * Go up the tree, starting at leaf level.&n;&t; * If 2 is returned then a join was done; go to the next level.&n;&t; * Otherwise we are done.&n;&t; */
r_for
c_loop
(paren
id|level
op_assign
l_int|0
comma
id|i
op_assign
l_int|2
suffix:semicolon
id|i
op_eq
l_int|2
suffix:semicolon
id|level
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delrec
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|level
op_assign
l_int|1
suffix:semicolon
id|level
OL
id|cur-&gt;bc_nlevels
suffix:semicolon
id|level
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|cur
comma
id|level
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
op_star
id|stat
op_assign
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the data from the pointed-to record.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_get_rec
id|xfs_alloc_get_rec
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_agblock_t
op_star
id|bno
comma
multiline_comment|/* output: starting block of extent */
id|xfs_extlen_t
op_star
id|len
comma
multiline_comment|/* output: length of extent */
r_int
op_star
id|stat
)paren
multiline_comment|/* output: success/failure */
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block */
macro_line|#ifdef DEBUG
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#endif
r_int
id|ptr
suffix:semicolon
multiline_comment|/* record number */
id|ptr
op_assign
id|cur-&gt;bc_ptrs
(braket
l_int|0
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|cur-&gt;bc_bufs
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
l_int|0
comma
id|cur-&gt;bc_bufs
(braket
l_int|0
)braket
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Off the right end or left end, return failure.&n;&t; */
r_if
c_cond
(paren
id|ptr
OG
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|ptr
op_le
l_int|0
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Point to the record and extract its data.&n;&t; */
(brace
id|xfs_alloc_rec_t
op_star
id|rec
suffix:semicolon
multiline_comment|/* record data */
id|rec
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
id|ptr
comma
id|cur
)paren
suffix:semicolon
op_star
id|bno
op_assign
id|INT_GET
c_func
(paren
id|rec-&gt;ar_startblock
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
op_star
id|len
op_assign
id|INT_GET
c_func
(paren
id|rec-&gt;ar_blockcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Increment cursor by one record at the level.&n; * For nonzero levels the leaf-ward information is untouched.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_increment
id|xfs_alloc_increment
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
id|level
comma
multiline_comment|/* level in btree, 0 is leaf */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* tree block buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|lev
suffix:semicolon
multiline_comment|/* btree level */
id|ASSERT
c_func
(paren
id|level
OL
id|cur-&gt;bc_nlevels
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read-ahead to the right at this level.&n;&t; */
id|xfs_btree_readahead
c_func
(paren
id|cur
comma
id|level
comma
id|XFS_BTCUR_RIGHTRA
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get a pointer to the btree block.&n;&t; */
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|level
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|level
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Increment the ptr at this level.  If we&squot;re still in the block&n;&t; * then we&squot;re done.&n;&t; */
r_if
c_cond
(paren
op_increment
id|cur-&gt;bc_ptrs
(braket
id|level
)braket
op_le
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we just went off the right edge of the tree, return failure.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
)paren
(brace
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * March up the tree incrementing pointers.&n;&t; * Stop when we don&squot;t go off the right edge of a block.&n;&t; */
r_for
c_loop
(paren
id|lev
op_assign
id|level
op_plus
l_int|1
suffix:semicolon
id|lev
OL
id|cur-&gt;bc_nlevels
suffix:semicolon
id|lev
op_increment
)paren
(brace
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|lev
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_increment
id|cur-&gt;bc_ptrs
(braket
id|lev
)braket
op_le
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read-ahead the right block, we&squot;re going to read it&n;&t;&t; * in the next loop.&n;&t;&t; */
id|xfs_btree_readahead
c_func
(paren
id|cur
comma
id|lev
comma
id|XFS_BTCUR_RIGHTRA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we went off the root then we are seriously confused.&n;&t; */
id|ASSERT
c_func
(paren
id|lev
OL
id|cur-&gt;bc_nlevels
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now walk back down the tree, fixing up the cursor&squot;s buffer&n;&t; * pointers and key numbers.&n;&t; */
r_for
c_loop
(paren
id|bp
op_assign
id|cur-&gt;bc_bufs
(braket
id|lev
)braket
comma
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
id|lev
OG
id|level
suffix:semicolon
)paren
(brace
id|xfs_agblock_t
id|agbno
suffix:semicolon
multiline_comment|/* block number of btree block */
id|agbno
op_assign
id|INT_GET
c_func
(paren
op_star
id|XFS_ALLOC_PTR_ADDR
c_func
(paren
id|block
comma
id|cur-&gt;bc_ptrs
(braket
id|lev
)braket
comma
id|cur
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_read_bufs
c_func
(paren
id|cur-&gt;bc_mp
comma
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agno
comma
id|agbno
comma
l_int|0
comma
op_amp
id|bp
comma
id|XFS_ALLOC_BTREE_REF
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|lev
op_decrement
suffix:semicolon
id|xfs_btree_setbuf
c_func
(paren
id|cur
comma
id|lev
comma
id|bp
)paren
suffix:semicolon
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
id|lev
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|cur-&gt;bc_ptrs
(braket
id|lev
)braket
op_assign
l_int|1
suffix:semicolon
)brace
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert the current record at the point referenced by cur.&n; * The cursor may be inconsistent on return if splits have been done.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_insert
id|xfs_alloc_insert
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* result value, 0 for failure */
r_int
id|level
suffix:semicolon
multiline_comment|/* current level number in btree */
id|xfs_agblock_t
id|nbno
suffix:semicolon
multiline_comment|/* new block number (split result) */
id|xfs_btree_cur_t
op_star
id|ncur
suffix:semicolon
multiline_comment|/* new cursor (split result) */
id|xfs_alloc_rec_t
id|nrec
suffix:semicolon
multiline_comment|/* record being inserted this level */
id|xfs_btree_cur_t
op_star
id|pcur
suffix:semicolon
multiline_comment|/* previous level&squot;s cursor */
id|level
op_assign
l_int|0
suffix:semicolon
id|nbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
id|INT_SET
c_func
(paren
id|nrec.ar_startblock
comma
id|ARCH_CONVERT
comma
id|cur-&gt;bc_rec.a.ar_startblock
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|nrec.ar_blockcount
comma
id|ARCH_CONVERT
comma
id|cur-&gt;bc_rec.a.ar_blockcount
)paren
suffix:semicolon
id|ncur
op_assign
(paren
id|xfs_btree_cur_t
op_star
)paren
l_int|0
suffix:semicolon
id|pcur
op_assign
id|cur
suffix:semicolon
multiline_comment|/*&n;&t; * Loop going up the tree, starting at the leaf level.&n;&t; * Stop when we don&squot;t get a split block, that must mean that&n;&t; * the insert is finished with this level.&n;&t; */
r_do
(brace
multiline_comment|/*&n;&t;&t; * Insert nrec/nbno into this level of the tree.&n;&t;&t; * Note if we fail, nbno will be null.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_insrec
c_func
(paren
id|pcur
comma
id|level
op_increment
comma
op_amp
id|nbno
comma
op_amp
id|nrec
comma
op_amp
id|ncur
comma
op_amp
id|i
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|pcur
op_ne
id|cur
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|pcur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * See if the cursor we just used is trash.&n;&t;&t; * Can&squot;t trash the caller&squot;s cursor, but otherwise we should&n;&t;&t; * if ncur is a new cursor or we&squot;re about to be done.&n;&t;&t; */
r_if
c_cond
(paren
id|pcur
op_ne
id|cur
op_logical_and
(paren
id|ncur
op_logical_or
id|nbno
op_eq
id|NULLAGBLOCK
)paren
)paren
(brace
id|cur-&gt;bc_nlevels
op_assign
id|pcur-&gt;bc_nlevels
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|pcur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we got a new cursor, switch to it.&n;&t;&t; */
r_if
c_cond
(paren
id|ncur
)paren
(brace
id|pcur
op_assign
id|ncur
suffix:semicolon
id|ncur
op_assign
(paren
id|xfs_btree_cur_t
op_star
)paren
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|nbno
op_ne
id|NULLAGBLOCK
)paren
suffix:semicolon
op_star
id|stat
op_assign
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup the record equal to [bno, len] in the btree given by cur.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_lookup_eq
id|xfs_alloc_lookup_eq
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_agblock_t
id|bno
comma
multiline_comment|/* starting block of extent */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
id|cur-&gt;bc_rec.a.ar_startblock
op_assign
id|bno
suffix:semicolon
id|cur-&gt;bc_rec.a.ar_blockcount
op_assign
id|len
suffix:semicolon
r_return
id|xfs_alloc_lookup
c_func
(paren
id|cur
comma
id|XFS_LOOKUP_EQ
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup the first record greater than or equal to [bno, len]&n; * in the btree given by cur.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_lookup_ge
id|xfs_alloc_lookup_ge
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_agblock_t
id|bno
comma
multiline_comment|/* starting block of extent */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
id|cur-&gt;bc_rec.a.ar_startblock
op_assign
id|bno
suffix:semicolon
id|cur-&gt;bc_rec.a.ar_blockcount
op_assign
id|len
suffix:semicolon
r_return
id|xfs_alloc_lookup
c_func
(paren
id|cur
comma
id|XFS_LOOKUP_GE
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup the first record less than or equal to [bno, len]&n; * in the btree given by cur.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_lookup_le
id|xfs_alloc_lookup_le
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_agblock_t
id|bno
comma
multiline_comment|/* starting block of extent */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
op_star
id|stat
)paren
multiline_comment|/* success/failure */
(brace
id|cur-&gt;bc_rec.a.ar_startblock
op_assign
id|bno
suffix:semicolon
id|cur-&gt;bc_rec.a.ar_blockcount
op_assign
id|len
suffix:semicolon
r_return
id|xfs_alloc_lookup
c_func
(paren
id|cur
comma
id|XFS_LOOKUP_LE
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the record referred to by cur, to the value given by [bno, len].&n; * This either works (return 0) or gets an EFSCORRUPTED error.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_update
id|xfs_alloc_update
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cur
comma
multiline_comment|/* btree cursor */
id|xfs_agblock_t
id|bno
comma
multiline_comment|/* starting block of extent */
id|xfs_extlen_t
id|len
)paren
multiline_comment|/* length of extent */
(brace
id|xfs_alloc_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* btree block to update */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|ptr
suffix:semicolon
multiline_comment|/* current record number (updating) */
id|ASSERT
c_func
(paren
id|len
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pick up the a.g. freelist struct and the current block.&n;&t; */
id|block
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|cur-&gt;bc_bufs
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_check_sblock
c_func
(paren
id|cur
comma
id|block
comma
l_int|0
comma
id|cur-&gt;bc_bufs
(braket
l_int|0
)braket
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Get the address of the rec to be updated.&n;&t; */
id|ptr
op_assign
id|cur-&gt;bc_ptrs
(braket
l_int|0
)braket
suffix:semicolon
(brace
id|xfs_alloc_rec_t
op_star
id|rp
suffix:semicolon
multiline_comment|/* pointer to updated record */
id|rp
op_assign
id|XFS_ALLOC_REC_ADDR
c_func
(paren
id|block
comma
id|ptr
comma
id|cur
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fill in the new contents and log them.&n;&t;&t; */
id|INT_SET
c_func
(paren
id|rp-&gt;ar_startblock
comma
id|ARCH_CONVERT
comma
id|bno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|rp-&gt;ar_blockcount
comma
id|ARCH_CONVERT
comma
id|len
)paren
suffix:semicolon
id|xfs_alloc_log_recs
c_func
(paren
id|cur
comma
id|cur-&gt;bc_bufs
(braket
l_int|0
)braket
comma
id|ptr
comma
id|ptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If it&squot;s the by-size btree and it&squot;s the last leaf block and&n;&t; * it&squot;s the last record... then update the size of the longest&n;&t; * extent in the a.g., which we cache in the a.g. freelist header.&n;&t; */
r_if
c_cond
(paren
id|cur-&gt;bc_btnum
op_eq
id|XFS_BTNUM_CNT
op_logical_and
id|INT_GET
c_func
(paren
id|block-&gt;bb_rightsib
comma
id|ARCH_CONVERT
)paren
op_eq
id|NULLAGBLOCK
op_logical_and
id|ptr
op_eq
id|INT_GET
c_func
(paren
id|block-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freespace header */
id|xfs_agnumber_t
id|seqno
suffix:semicolon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|cur-&gt;bc_private.a.agbp
)paren
suffix:semicolon
id|seqno
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|cur-&gt;bc_mp-&gt;m_perag
(braket
id|seqno
)braket
dot
id|pagf_longest
op_assign
id|len
suffix:semicolon
id|INT_SET
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
comma
id|len
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|cur-&gt;bc_tp
comma
id|cur-&gt;bc_private.a.agbp
comma
id|XFS_AGF_LONGEST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Updating first record in leaf. Pass new key value up to our parent.&n;&t; */
r_if
c_cond
(paren
id|ptr
op_eq
l_int|1
)paren
(brace
id|xfs_alloc_key_t
id|key
suffix:semicolon
multiline_comment|/* key containing [bno, len] */
id|INT_SET
c_func
(paren
id|key.ar_startblock
comma
id|ARCH_CONVERT
comma
id|bno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|key.ar_blockcount
comma
id|ARCH_CONVERT
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_updkey
c_func
(paren
id|cur
comma
op_amp
id|key
comma
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
