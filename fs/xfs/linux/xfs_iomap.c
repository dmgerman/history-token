multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; *  fs/xfs/linux/xfs_lrw.c (Linux Read Write stuff)&n; *&n; */
macro_line|#include &lt;xfs.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
DECL|macro|XFS_WRITEIO_ALIGN
mdefine_line|#define XFS_WRITEIO_ALIGN(mp,off)&t;(((off) &gt;&gt; mp-&gt;m_writeio_log) &bslash;&n;&t;&t;&t;&t;&t;&t;&lt;&lt; mp-&gt;m_writeio_log)
DECL|macro|XFS_STRAT_WRITE_IMAPS
mdefine_line|#define XFS_STRAT_WRITE_IMAPS&t;2
id|STATIC
r_int
id|xfs_iomap_read
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
r_int
comma
id|page_buf_bmap_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iomap_write
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
id|page_buf_bmap_t
op_star
comma
r_int
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iomap_write_delay
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
id|page_buf_bmap_t
op_star
comma
r_int
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iomap_write_direct
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
id|page_buf_bmap_t
op_star
comma
r_int
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|_xfs_imap_to_bmap
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|xfs_off_t
comma
id|xfs_bmbt_irec_t
op_star
comma
id|page_buf_bmap_t
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_int
DECL|function|xfs_strategy
id|xfs_strategy
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|xfs_off_t
id|offset
comma
id|ssize_t
id|count
comma
r_int
id|flags
comma
id|page_buf_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
)paren
(brace
id|xfs_iocore_t
op_star
id|io
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|end_fsb
suffix:semicolon
id|xfs_fileoff_t
id|map_start_fsb
suffix:semicolon
id|xfs_fileoff_t
id|last_block
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_filblks_t
id|count_fsb
suffix:semicolon
r_int
id|committed
comma
id|i
comma
id|loops
comma
id|nimaps
suffix:semicolon
r_int
id|is_xfs
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* This will be a variable at some point */
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_MAX_RW_NBMAPS
)braket
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|io
op_assign
op_amp
id|ip-&gt;i_iocore
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
multiline_comment|/* is_xfs = IO_IS_XFS(io); */
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFREG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
l_int|0
)paren
op_eq
(paren
(paren
id|io-&gt;io_flags
op_amp
id|XFS_IOCORE_RT
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|nimaps
op_assign
id|min
c_func
(paren
id|XFS_MAX_RW_NBMAPS
comma
op_star
id|npbmaps
)paren
suffix:semicolon
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
id|first_block
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_SHARED
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|offset_fsb
comma
(paren
id|xfs_filblks_t
)paren
(paren
id|end_fsb
op_minus
id|offset_fsb
)paren
comma
id|XFS_BMAPI_ENTIRE
comma
op_amp
id|first_block
comma
l_int|0
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_SHARED
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nimaps
op_logical_and
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|imap
(braket
l_int|0
)braket
dot
id|br_startblock
)paren
)paren
(brace
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
op_amp
id|ip-&gt;i_iocore
comma
id|offset
comma
id|imap
comma
id|pbmapp
comma
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure that the dquots are there.&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|XFS_NOT_DQATTACHED
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqattach
c_func
(paren
id|ip
comma
l_int|0
)paren
)paren
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
id|XFS_STATS_ADD
c_func
(paren
id|xfsstats.xs_xstrat_bytes
comma
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap
(braket
l_int|0
)braket
dot
id|br_blockcount
)paren
)paren
suffix:semicolon
id|offset_fsb
op_assign
id|imap
(braket
l_int|0
)braket
dot
id|br_startoff
suffix:semicolon
id|count_fsb
op_assign
id|imap
(braket
l_int|0
)braket
dot
id|br_blockcount
suffix:semicolon
id|map_start_fsb
op_assign
id|offset_fsb
suffix:semicolon
r_while
c_loop
(paren
id|count_fsb
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set up a transaction with which to allocate the&n;&t;&t; * backing store for the file.&t;Do allocations in a&n;&t;&t; * loop until we get some space in the range we are&n;&t;&t; * interested in.  The other space that might be allocated&n;&t;&t; * is in the delayed allocation extent on which we sit&n;&t;&t; * but before our buffer starts.&n;&t;&t; */
id|nimaps
op_assign
l_int|0
suffix:semicolon
id|loops
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|is_xfs
)paren
(brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_STRAT_WRITE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_WRITE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
r_else
(brace
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Allocate the backing store for the file.&n;&t;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
(paren
id|free_list
)paren
comma
op_amp
(paren
id|first_block
)paren
)paren
suffix:semicolon
id|nimaps
op_assign
id|XFS_STRAT_WRITE_IMAPS
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Ensure we don&squot;t go beyond eof - it is possible&n;&t;&t;&t; * the extents changed since we did the read call,&n;&t;&t;&t; * we dropped the ilock in the interim.&n;&t;&t;&t; */
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
)paren
suffix:semicolon
id|xfs_bmap_last_offset
c_func
(paren
l_int|NULL
comma
id|ip
comma
op_amp
id|last_block
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|last_block
op_assign
id|XFS_FILEOFF_MAX
c_func
(paren
id|last_block
comma
id|end_fsb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|map_start_fsb
op_plus
id|count_fsb
)paren
OG
id|last_block
)paren
(brace
id|count_fsb
op_assign
id|last_block
op_minus
id|map_start_fsb
suffix:semicolon
r_if
c_cond
(paren
id|count_fsb
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|is_xfs
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
)brace
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EAGAIN
)paren
suffix:semicolon
)brace
)brace
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
id|tp
comma
id|io
comma
id|map_start_fsb
comma
id|count_fsb
comma
id|XFS_BMAPI_WRITE
comma
op_amp
id|first_block
comma
l_int|1
comma
id|imap
comma
op_amp
id|nimaps
comma
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_xfs
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
(paren
id|tp
)paren
comma
op_amp
(paren
id|free_list
)paren
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
)brace
multiline_comment|/* else hold &squot;till we maybe loop again below */
)brace
multiline_comment|/*&n;&t;&t; * See if we were able to allocate an extent that&n;&t;&t; * covers at least part of the user&squot;s requested size.&n;&t;&t; */
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nimaps
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|maps
suffix:semicolon
r_if
c_cond
(paren
id|offset_fsb
op_ge
id|imap
(braket
id|i
)braket
dot
id|br_startoff
op_logical_and
(paren
id|offset_fsb
OL
(paren
id|imap
(braket
id|i
)braket
dot
id|br_startoff
op_plus
id|imap
(braket
id|i
)braket
dot
id|br_blockcount
)paren
)paren
)paren
(brace
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
id|maps
op_assign
id|min
c_func
(paren
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
id|io
comma
id|offset
comma
op_amp
id|imap
(braket
id|i
)braket
comma
id|pbmapp
comma
id|maps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_xstrat_quick
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|count_fsb
op_sub_assign
id|imap
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
multiline_comment|/* for next bmapi,&n;&t;&t;&t;&t;&t;&t;&t;&t;if needed. */
)brace
multiline_comment|/*&n;&t;&t; * We didn&squot;t get an extent the caller can write into so&n;&t;&t; * loop around and try starting after the last imap we got back.&n;&t;&t; */
id|nimaps
op_decrement
suffix:semicolon
multiline_comment|/* Index of last entry  */
id|ASSERT
c_func
(paren
id|nimaps
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset_fsb
op_ge
id|imap
(braket
id|nimaps
)braket
dot
id|br_startoff
op_plus
id|imap
(braket
id|nimaps
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|count_fsb
)paren
suffix:semicolon
id|offset_fsb
op_assign
id|imap
(braket
id|nimaps
)braket
dot
id|br_startoff
op_plus
id|imap
(braket
id|nimaps
)braket
dot
id|br_blockcount
suffix:semicolon
id|map_start_fsb
op_assign
id|offset_fsb
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_xstrat_split
)paren
suffix:semicolon
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Should never get here */
id|error0
suffix:colon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|count_fsb
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|is_xfs
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_bmap() is the same as the irix xfs_bmap from xfs_rw.c&n; * execpt for slight changes to the params&n; */
r_int
DECL|function|xfs_bmap
id|xfs_bmap
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|xfs_off_t
id|offset
comma
id|ssize_t
id|count
comma
r_int
id|flags
comma
id|page_buf_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|lockmode
suffix:semicolon
r_int
id|fsynced
op_assign
l_int|0
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFREG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
l_int|0
)paren
op_eq
(paren
(paren
id|ip-&gt;i_iocore.io_flags
op_amp
id|XFS_IOCORE_RT
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_iocore.io_mount
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_READ
)paren
(brace
id|lockmode
op_assign
id|xfs_ilock_map_shared
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iomap_read
c_func
(paren
op_amp
id|ip-&gt;i_iocore
comma
id|offset
comma
id|count
comma
id|XFS_BMAPI_ENTIRE
comma
id|pbmapp
comma
id|npbmaps
)paren
suffix:semicolon
id|xfs_iunlock_map_shared
c_func
(paren
id|ip
comma
id|lockmode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_FILE_ALLOCATE
)paren
(brace
id|error
op_assign
id|xfs_strategy
c_func
(paren
id|ip
comma
id|offset
comma
id|count
comma
id|flags
comma
id|pbmapp
comma
id|npbmaps
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PBF_WRITE */
id|ASSERT
c_func
(paren
id|flags
op_amp
id|PBF_WRITE
)paren
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure that the dquots are there. This doesn&squot;t hold&n;&t;&t; * the ilock across a disk read.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
(brace
r_if
c_cond
(paren
id|XFS_NOT_DQATTACHED
c_func
(paren
id|ip-&gt;i_mount
comma
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqattach
c_func
(paren
id|ip
comma
id|XFS_QMOPT_ILOCKED
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
id|retry
suffix:colon
id|error
op_assign
id|xfs_iomap_write
c_func
(paren
op_amp
id|ip-&gt;i_iocore
comma
id|offset
comma
id|count
comma
id|pbmapp
comma
id|npbmaps
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* xfs_iomap_write unlocks/locks/unlocks */
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
r_switch
c_cond
(paren
id|fsynced
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|ip-&gt;i_delayed_blks
)paren
(brace
id|filemap_fdatawrite
c_func
(paren
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
op_member_access_from_pointer
id|i_mapping
)paren
suffix:semicolon
id|fsynced
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|fsynced
op_assign
l_int|2
suffix:semicolon
id|flags
op_or_assign
id|PBF_SYNC
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
r_case
l_int|1
suffix:colon
id|fsynced
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PBF_SYNC
)paren
)paren
(brace
id|flags
op_or_assign
id|PBF_SYNC
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
id|sync_blockdev
c_func
(paren
id|vp-&gt;v_vfsp-&gt;vfs_super-&gt;s_bdev
)paren
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|ip-&gt;i_mount
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/**&n;&t;&t;&t;&t;delay(HZ);&n;**/
id|fsynced
op_increment
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|_xfs_imap_to_bmap
id|_xfs_imap_to_bmap
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
id|xfs_bmbt_irec_t
op_star
id|imap
comma
id|page_buf_bmap_t
op_star
id|pbmapp
comma
r_int
id|imaps
comma
multiline_comment|/* Number of imap entries */
r_int
id|pbmaps
)paren
multiline_comment|/* Number of pbmap entries */
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_fsize_t
id|nisize
suffix:semicolon
r_int
id|im
comma
id|pbm
suffix:semicolon
id|xfs_fsblock_t
id|start_block
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|nisize
op_assign
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;io_new_size
OG
id|nisize
)paren
id|nisize
op_assign
id|io-&gt;io_new_size
suffix:semicolon
r_for
c_loop
(paren
id|im
op_assign
l_int|0
comma
id|pbm
op_assign
l_int|0
suffix:semicolon
id|im
OL
id|imaps
op_logical_and
id|pbm
OL
id|pbmaps
suffix:semicolon
id|im
op_increment
comma
id|pbmapp
op_increment
comma
id|imap
op_increment
comma
id|pbm
op_increment
)paren
(brace
id|pbmapp-&gt;pbm_target
op_assign
id|io-&gt;io_flags
op_amp
id|XFS_IOCORE_RT
ques
c_cond
id|mp-&gt;m_rtdev_targp
suffix:colon
id|mp-&gt;m_ddev_targp
suffix:semicolon
id|pbmapp-&gt;pbm_offset
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap-&gt;br_startoff
)paren
suffix:semicolon
id|pbmapp-&gt;pbm_delta
op_assign
id|offset
op_minus
id|pbmapp-&gt;pbm_offset
suffix:semicolon
id|pbmapp-&gt;pbm_bsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap-&gt;br_blockcount
)paren
suffix:semicolon
id|pbmapp-&gt;pbm_flags
op_assign
l_int|0
suffix:semicolon
id|start_block
op_assign
id|imap-&gt;br_startblock
suffix:semicolon
r_if
c_cond
(paren
id|start_block
op_eq
id|HOLESTARTBLOCK
)paren
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|PAGE_BUF_DADDR_NULL
suffix:semicolon
id|pbmapp-&gt;pbm_flags
op_assign
id|PBMF_HOLE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|start_block
op_eq
id|DELAYSTARTBLOCK
)paren
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|PAGE_BUF_DADDR_NULL
suffix:semicolon
id|pbmapp-&gt;pbm_flags
op_assign
id|PBMF_DELAY
suffix:semicolon
)brace
r_else
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|XFS_FSB_TO_DB_IO
c_func
(paren
id|io
comma
id|start_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap-&gt;br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
id|pbmapp-&gt;pbm_flags
op_or_assign
id|PBMF_UNWRITTEN
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pbmapp-&gt;pbm_offset
op_plus
id|pbmapp-&gt;pbm_bsize
)paren
op_ge
id|nisize
)paren
(brace
id|pbmapp-&gt;pbm_flags
op_or_assign
id|PBMF_EOF
suffix:semicolon
)brace
id|offset
op_add_assign
id|pbmapp-&gt;pbm_bsize
op_minus
id|pbmapp-&gt;pbm_delta
suffix:semicolon
)brace
r_return
id|pbm
suffix:semicolon
multiline_comment|/* Return the number filled */
)brace
id|STATIC
r_int
DECL|function|xfs_iomap_read
id|xfs_iomap_read
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
r_int
id|flags
comma
id|page_buf_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
)paren
(brace
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|end_fsb
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_MAX_RW_NBMAPS
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
op_or
id|MR_ACCESS
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|nimaps
op_assign
r_sizeof
(paren
id|imap
)paren
op_div
r_sizeof
(paren
id|imap
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|nimaps
op_assign
id|min
c_func
(paren
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t ask for more than caller has */
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|offset_fsb
comma
(paren
id|xfs_filblks_t
)paren
(paren
id|end_fsb
op_minus
id|offset_fsb
)paren
comma
id|flags
comma
l_int|NULL
comma
l_int|0
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nimaps
)paren
(brace
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
id|io
comma
id|offset
comma
id|imap
comma
id|pbmapp
comma
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
)brace
r_else
op_star
id|npbmaps
op_assign
l_int|0
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_iomap_write: return pagebuf_bmap_t&squot;s telling higher layers&n; *&t;where to write.&n; * There are 2 main cases:&n; *&t;1 the extents already exist&n; *&t;2 must allocate.&n; *&t;There are 3 cases when we allocate:&n; *&t;&t;delay allocation (doesn&squot;t really allocate or use transactions)&n; *&t;&t;direct allocation (no previous delay allocation&n; *&t;&t;convert delay to real allocations&n; */
id|STATIC
r_int
DECL|function|xfs_iomap_write
id|xfs_iomap_write
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
id|page_buf_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
comma
r_int
id|ioflag
)paren
(brace
r_int
id|maps
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|maps
op_assign
op_star
id|npbmaps
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|maps
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If we have extents that are allocated for this range,&n;&t; * return them.&n;&t; */
id|found
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_iomap_read
c_func
(paren
id|io
comma
id|offset
comma
id|count
comma
id|flags
comma
id|pbmapp
comma
id|npbmaps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If we found mappings and they can just have data written&n;&t; * without conversion,&n;&t; * let the caller write these and call us again.&n;&t; *&n;&t; * If we have a HOLE or UNWRITTEN, proceed down lower to&n;&t; * get the space or to convert to written.&n;&t; */
r_if
c_cond
(paren
op_star
id|npbmaps
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pbmapp-&gt;pbm_flags
op_amp
id|PBMF_HOLE
)paren
)paren
(brace
op_star
id|npbmaps
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Only checked the first one. */
multiline_comment|/* We could check more, ... */
r_goto
id|out
suffix:semicolon
)brace
)brace
id|found
op_assign
op_star
id|npbmaps
suffix:semicolon
op_star
id|npbmaps
op_assign
id|maps
suffix:semicolon
multiline_comment|/* Restore to original requested */
r_if
c_cond
(paren
id|ioflag
op_amp
id|PBF_DIRECT
)paren
(brace
id|error
op_assign
id|xfs_iomap_write_direct
c_func
(paren
id|io
comma
id|offset
comma
id|count
comma
id|pbmapp
comma
id|npbmaps
comma
id|ioflag
comma
id|found
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_iomap_write_delay
c_func
(paren
id|io
comma
id|offset
comma
id|count
comma
id|pbmapp
comma
id|npbmaps
comma
id|ioflag
comma
id|found
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|XFS_IUNLOCK
c_func
(paren
id|io-&gt;io_mount
comma
id|io
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_iomap_write_delay
id|xfs_iomap_write_delay
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
id|page_buf_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
comma
r_int
id|ioflag
comma
r_int
id|found
)paren
(brace
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|ioalign
suffix:semicolon
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_fileoff_t
id|start_fsb
suffix:semicolon
id|xfs_filblks_t
id|count_fsb
suffix:semicolon
id|xfs_off_t
id|aligned_offset
suffix:semicolon
id|xfs_fsize_t
id|isize
suffix:semicolon
id|xfs_fsblock_t
id|firstblock
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
r_int
id|iosize
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
DECL|macro|XFS_WRITE_IMAPS
mdefine_line|#define XFS_WRITE_IMAPS XFS_BMAP_MAX_NMAP
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_WRITE_IMAPS
)braket
suffix:semicolon
r_int
id|aeof
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|isize
op_assign
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;io_new_size
OG
id|isize
)paren
(brace
id|isize
op_assign
id|io-&gt;io_new_size
suffix:semicolon
)brace
id|aeof
op_assign
l_int|0
suffix:semicolon
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|last_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the caller is doing a write at the end of the file,&n;&t; * then extend the allocation (and the buffer used for the write)&n;&t; * out to the file system&squot;s write iosize.  We clean up any extra&n;&t; * space left over when the file is closed in xfs_inactive().&n;&t; * We can only do this if we are sure that we will create buffers&n;&t; * over all of the space we allocate beyond the end of the file.&n;&t; * Not doing so would allow us to create delalloc blocks with&n;&t; * no pages in memory covering them.  So, we need to check that&n;&t; * there are not any real blocks in the area beyond the end of&n;&t; * the file which we are optimistically going to preallocate. If&n;&t; * there are then our buffers will stop when they encounter them&n;&t; * and we may accidentally create delalloc blocks beyond them&n;&t; * that we never cover with a buffer.  All of this is because&n;&t; * we are not actually going to write the extra blocks preallocated&n;&t; * at this point.&n;&t; *&n;&t; * We don&squot;t bother with this for sync writes, because we need&n;&t; * to minimize the amount we write for good performance.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ioflag
op_amp
id|PBF_SYNC
)paren
op_logical_and
(paren
(paren
id|offset
op_plus
id|count
)paren
OG
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
)paren
)paren
(brace
id|start_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|count_fsb
op_assign
id|mp-&gt;m_writeio_blocks
suffix:semicolon
r_while
c_loop
(paren
id|count_fsb
OG
l_int|0
)paren
(brace
id|nimaps
op_assign
id|XFS_WRITE_IMAPS
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|start_fsb
comma
id|count_fsb
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|nimaps
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|imap
(braket
id|n
)braket
dot
id|br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
op_logical_and
(paren
id|imap
(braket
id|n
)braket
dot
id|br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
)paren
(brace
r_goto
id|write_map
suffix:semicolon
)brace
id|start_fsb
op_add_assign
id|imap
(braket
id|n
)braket
dot
id|br_blockcount
suffix:semicolon
id|count_fsb
op_sub_assign
id|imap
(braket
id|n
)braket
dot
id|br_blockcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|count_fsb
OL
l_int|0xffff000
)paren
suffix:semicolon
)brace
)brace
id|iosize
op_assign
id|mp-&gt;m_writeio_blocks
suffix:semicolon
id|aligned_offset
op_assign
id|XFS_WRITEIO_ALIGN
c_func
(paren
id|mp
comma
(paren
id|offset
op_plus
id|count
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|ioalign
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|aligned_offset
)paren
suffix:semicolon
id|last_fsb
op_assign
id|ioalign
op_plus
id|iosize
suffix:semicolon
id|aeof
op_assign
l_int|1
suffix:semicolon
)brace
id|write_map
suffix:colon
id|nimaps
op_assign
id|XFS_WRITE_IMAPS
suffix:semicolon
id|firstblock
op_assign
id|NULLFSBLOCK
suffix:semicolon
multiline_comment|/*&n;&t; * roundup the allocation request to m_dalign boundary if file size&n;&t; * is greater that 512K and we are allocating past the allocation eof&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_dalign
op_logical_and
(paren
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
op_ge
id|mp-&gt;m_dalign
)paren
op_logical_and
id|aeof
)paren
(brace
r_int
id|eof
suffix:semicolon
id|xfs_fileoff_t
id|new_last_fsb
suffix:semicolon
id|new_last_fsb
op_assign
id|roundup_64
c_func
(paren
id|last_fsb
comma
id|mp-&gt;m_dalign
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAP_EOF
c_func
(paren
id|mp
comma
id|io
comma
id|new_last_fsb
comma
id|XFS_DATA_FORK
comma
op_amp
id|eof
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eof
)paren
(brace
id|last_fsb
op_assign
id|new_last_fsb
suffix:semicolon
)brace
)brace
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|offset_fsb
comma
(paren
id|xfs_filblks_t
)paren
(paren
id|last_fsb
op_minus
id|offset_fsb
)paren
comma
id|XFS_BMAPI_DELAY
op_or
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_ENTIRE
comma
op_amp
id|firstblock
comma
l_int|1
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can be EDQUOT, if nimaps == 0&n;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If bmapi returned us nothing, and if we didn&squot;t get back EDQUOT,&n;&t; * then we must have run out of space.&n;&t; */
r_if
c_cond
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now map our desired I/O size and alignment over the&n;&t; * extents returned by xfs_bmapi().&n;&t; */
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
id|io
comma
id|offset
comma
id|imap
comma
id|pbmapp
comma
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_iomap_write_direct
id|xfs_iomap_write_direct
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
id|page_buf_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
comma
r_int
id|ioflag
comma
r_int
id|found
)paren
(brace
id|xfs_inode_t
op_star
id|ip
op_assign
id|XFS_IO_INODE
c_func
(paren
id|io
)paren
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_filblks_t
id|count_fsb
suffix:semicolon
id|xfs_fsize_t
id|isize
suffix:semicolon
id|xfs_fsblock_t
id|firstfsb
suffix:semicolon
r_int
id|nimaps
comma
id|maps
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
DECL|macro|XFS_WRITE_IMAPS
mdefine_line|#define XFS_WRITE_IMAPS XFS_BMAP_MAX_NMAP
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_WRITE_IMAPS
)braket
comma
op_star
id|imapp
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
r_int
id|aeof
suffix:semicolon
r_int
id|bmapi_flags
suffix:semicolon
id|xfs_filblks_t
id|datablocks
suffix:semicolon
r_int
id|rt
suffix:semicolon
r_int
id|committed
suffix:semicolon
r_int
id|numrtextents
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_int
id|rtextsize
suffix:semicolon
id|maps
op_assign
id|min
c_func
(paren
id|XFS_WRITE_IMAPS
comma
op_star
id|npbmaps
)paren
suffix:semicolon
id|nimaps
op_assign
id|maps
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|isize
op_assign
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;io_new_size
OG
id|isize
)paren
id|isize
op_assign
id|io-&gt;io_new_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|count
)paren
OG
id|isize
)paren
(brace
id|aeof
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|aeof
op_assign
l_int|0
suffix:semicolon
)brace
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|last_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
id|count_fsb
op_assign
id|last_fsb
op_minus
id|offset_fsb
suffix:semicolon
r_if
c_cond
(paren
id|found
op_logical_and
(paren
id|pbmapp-&gt;pbm_flags
op_amp
id|PBMF_HOLE
)paren
)paren
(brace
id|xfs_fileoff_t
id|map_last_fsb
suffix:semicolon
id|map_last_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|pbmapp-&gt;pbm_bsize
op_plus
id|pbmapp-&gt;pbm_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map_last_fsb
OL
id|last_fsb
)paren
(brace
id|last_fsb
op_assign
id|map_last_fsb
suffix:semicolon
id|count_fsb
op_assign
id|last_fsb
op_minus
id|offset_fsb
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|count_fsb
OG
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * roundup the allocation request to m_dalign boundary if file size&n;&t; * is greater that 512K and we are allocating past the allocation eof&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|mp-&gt;m_dalign
op_logical_and
(paren
id|isize
op_ge
l_int|524288
)paren
op_logical_and
id|aeof
)paren
(brace
r_int
id|eof
suffix:semicolon
id|xfs_fileoff_t
id|new_last_fsb
suffix:semicolon
id|new_last_fsb
op_assign
id|roundup_64
c_func
(paren
id|last_fsb
comma
id|mp-&gt;m_dalign
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xfs_iomap_write_direct: about to XFS_BMAP_EOF %Ld&bslash;n&quot;
comma
id|new_last_fsb
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAP_EOF
c_func
(paren
id|mp
comma
id|io
comma
id|new_last_fsb
comma
id|XFS_DATA_FORK
comma
op_amp
id|eof
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eof
)paren
id|last_fsb
op_assign
id|new_last_fsb
suffix:semicolon
)brace
id|bmapi_flags
op_assign
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_DIRECT_IO
op_or
id|XFS_BMAPI_ENTIRE
suffix:semicolon
id|bmapi_flags
op_and_assign
op_complement
id|XFS_BMAPI_DIRECT_IO
suffix:semicolon
multiline_comment|/*&n;&t; * determine if this is a realtime file&n;&t; */
r_if
c_cond
(paren
(paren
id|rt
op_assign
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|rtextsize
op_assign
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
)brace
r_else
id|rtextsize
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * allocate file space for the bmapp entries passed in.&n;&t; */
multiline_comment|/*&n;&t; * determine if reserving space on&n;&t; * the data or realtime partition.&n;&t; */
r_if
c_cond
(paren
id|rt
)paren
(brace
id|numrtextents
op_assign
(paren
id|count_fsb
op_plus
id|rtextsize
op_minus
l_int|1
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|numrtextents
comma
id|rtextsize
)paren
suffix:semicolon
id|datablocks
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|datablocks
op_assign
id|count_fsb
suffix:semicolon
id|numrtextents
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate and setup the transaction&n;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_DIOSTRAT
)paren
suffix:semicolon
id|resblks
op_assign
id|XFS_DIOSTRAT_SPACE_RES
c_func
(paren
id|mp
comma
id|datablocks
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
id|numrtextents
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_WRITE_LOG_COUNT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check for running out of space&n;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * Free the transaction structure.&n;&t;&t; */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error_out
suffix:semicolon
multiline_comment|/* Don&squot;t return in above if .. trans ..,&n;&t;&t;&t;&t;&t;need lock to return */
)brace
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_trans_reserve_quota
c_func
(paren
id|tp
comma
id|ip-&gt;i_udquot
comma
id|ip-&gt;i_gdquot
comma
id|resblks
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|error
op_assign
(paren
id|EDQUOT
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|nimaps
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|nimaps
op_assign
l_int|2
suffix:semicolon
)brace
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * issue the bmapi() call to allocate the blocks&n;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|firstfsb
)paren
suffix:semicolon
id|imapp
op_assign
op_amp
id|imap
(braket
l_int|0
)braket
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
id|tp
comma
id|io
comma
id|offset_fsb
comma
id|count_fsb
comma
id|bmapi_flags
comma
op_amp
id|firstfsb
comma
l_int|1
comma
id|imapp
comma
op_amp
id|nimaps
comma
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * complete the transaction&n;&t; */
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|firstfsb
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error_out
suffix:semicolon
)brace
multiline_comment|/* copy any maps to caller&squot;s array and return any error. */
r_if
c_cond
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
id|error
op_assign
(paren
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
id|maps
op_assign
id|min
c_func
(paren
id|nimaps
comma
id|maps
)paren
suffix:semicolon
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
id|io
comma
id|offset
comma
op_amp
id|imap
(braket
l_int|0
)braket
comma
id|pbmapp
comma
id|maps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|npbmaps
)paren
(brace
multiline_comment|/*&n;&t;&t; * this is new since xfs_iomap_read&n;&t;&t; * didn&squot;t find it.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|npbmaps
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NEED MORE WORK FOR MULTIPLE BMAPS (which are new)&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_goto
id|out
suffix:semicolon
id|error0
suffix:colon
multiline_comment|/* Cancel bmap, unlock inode, and cancel trans */
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|error1
suffix:colon
multiline_comment|/* Just cancel transaction */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
op_star
id|npbmaps
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nothing set-up here */
id|error_out
suffix:colon
id|out
suffix:colon
multiline_comment|/* Just return error and any tracing at end of routine */
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
eof
