multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; *  fs/xfs/linux/xfs_lrw.c (Linux Read Write stuff)&n; *&n; */
macro_line|#include &lt;xfs.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
DECL|macro|XFS_WRITEIO_ALIGN
mdefine_line|#define XFS_WRITEIO_ALIGN(mp,off)&t;(((off) &gt;&gt; mp-&gt;m_writeio_log) &bslash;&n;&t;&t;&t;&t;&t;&t;&lt;&lt; mp-&gt;m_writeio_log)
DECL|macro|XFS_STRAT_WRITE_IMAPS
mdefine_line|#define XFS_STRAT_WRITE_IMAPS&t;2
id|STATIC
r_int
id|xfs_iomap_read
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
r_int
comma
id|pb_bmap_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iomap_write
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
id|pb_bmap_t
op_star
comma
r_int
op_star
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iomap_write_delay
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
id|pb_bmap_t
op_star
comma
r_int
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_iomap_write_direct
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|loff_t
comma
r_int
comma
id|pb_bmap_t
op_star
comma
r_int
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_int
id|_xfs_imap_to_bmap
c_func
(paren
id|xfs_iocore_t
op_star
comma
id|xfs_off_t
comma
id|xfs_bmbt_irec_t
op_star
comma
id|pb_bmap_t
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;xfs_iozero&n; *&n; *&t;xfs_iozero clears the specified range of buffer supplied,&n; *&t;and marks all the affected blocks as valid and modified.  If&n; *&t;an affected block is not allocated, it will be allocated.  If&n; *&t;an affected block is not completely overwritten, and is not&n; *&t;valid before the operation, it will be read from disk before&n; *&t;being partially zeroed.&n; */
id|STATIC
r_int
DECL|function|xfs_iozero
id|xfs_iozero
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
multiline_comment|/* inode &t;&t;&t;*/
id|loff_t
id|pos
comma
multiline_comment|/* offset in file&t;&t;*/
r_int
id|count
comma
multiline_comment|/* size of data to zero&t;&t;*/
id|loff_t
id|end_size
)paren
multiline_comment|/* max file size to set */
(brace
r_int
id|bytes
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_int
id|status
suffix:semicolon
id|mapping
op_assign
id|ip-&gt;i_mapping
suffix:semicolon
r_do
(brace
r_int
r_int
id|index
comma
id|offset
suffix:semicolon
id|offset
op_assign
(paren
id|pos
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Within page */
id|index
op_assign
id|pos
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
id|bytes
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|count
)paren
id|bytes
op_assign
id|count
suffix:semicolon
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_break
suffix:semicolon
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|status
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|prepare_write
c_func
(paren
l_int|NULL
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_goto
id|unlock
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|kaddr
op_plus
id|offset
)paren
comma
l_int|0
comma
id|bytes
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|status
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|commit_write
c_func
(paren
l_int|NULL
comma
id|page
comma
id|offset
comma
id|offset
op_plus
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|pos
op_add_assign
id|bytes
suffix:semicolon
id|count
op_sub_assign
id|bytes
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|ip-&gt;i_size
)paren
id|ip-&gt;i_size
op_assign
id|pos
OL
id|end_size
ques
c_cond
id|pos
suffix:colon
id|end_size
suffix:semicolon
)brace
id|unlock
suffix:colon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
r_return
(paren
op_minus
id|status
)paren
suffix:semicolon
)brace
id|ssize_t
multiline_comment|/* bytes read, or (-)  error */
DECL|function|xfs_read
id|xfs_read
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_struct
id|file
op_star
id|filp
comma
r_const
r_struct
id|iovec
op_star
id|iovp
comma
r_int
r_int
id|segs
comma
id|loff_t
op_star
id|offp
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
id|xfs_fsize_t
id|n
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
r_int
r_int
id|seg
suffix:semicolon
r_int
id|direct
op_assign
id|filp-&gt;f_flags
op_amp
id|O_DIRECT
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
l_string|&quot;xfs_read&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_read_calls
)paren
suffix:semicolon
multiline_comment|/* START copy &amp; waste from filemap.c */
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
r_const
r_struct
id|iovec
op_star
id|iv
op_assign
op_amp
id|iovp
(braket
id|seg
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If any segment has a negative length, or the cumulative&n;&t;&t; * length ever wraps negative then return -EINVAL.&n;&t;&t; */
id|size
op_add_assign
id|iv-&gt;iov_len
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|ssize_t
)paren
(paren
id|size
op_or
id|iv-&gt;iov_len
)paren
OL
l_int|0
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direct
)paren
(brace
multiline_comment|/* XFS specific check */
r_if
c_cond
(paren
(paren
id|__psint_t
)paren
id|iv-&gt;iov_base
op_amp
id|BBMASK
)paren
(brace
r_if
c_cond
(paren
op_star
id|offp
op_eq
id|ip-&gt;i_d.di_size
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|iv-&gt;iov_base
comma
id|iv-&gt;iov_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|seg
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|segs
op_assign
id|seg
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* END copy &amp; waste from filemap.c */
r_if
c_cond
(paren
id|direct
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|offp
op_amp
id|mp-&gt;m_blockmask
)paren
op_logical_or
(paren
id|size
op_amp
id|mp-&gt;m_blockmask
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|offp
op_eq
id|ip-&gt;i_d.di_size
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
id|n
op_assign
id|XFS_MAX_FILE_OFFSET
op_minus
op_star
id|offp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_le
l_int|0
)paren
op_logical_or
(paren
id|size
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
id|size
)paren
id|size
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|ip
comma
id|DM_EVENT_READ
)paren
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FINVIS
)paren
)paren
(brace
r_int
id|error
suffix:semicolon
id|vrwlock_t
id|locktype
op_assign
id|VRWLOCK_READ
suffix:semicolon
id|error
op_assign
id|xfs_dm_send_data_event
c_func
(paren
id|DM_EVENT_READ
comma
id|bdp
comma
op_star
id|offp
comma
id|size
comma
id|FILP_DELAY_FLAG
c_func
(paren
id|filp
)paren
comma
op_amp
id|locktype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|generic_file_readv
c_func
(paren
id|filp
comma
id|iovp
comma
id|segs
comma
id|offp
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_SHARED
)paren
suffix:semicolon
id|XFS_STATS_ADD
c_func
(paren
id|xfsstats.xs_read_bytes
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FINVIS
)paren
)paren
id|xfs_ichgtime
c_func
(paren
id|ip
comma
id|XFS_ICHGTIME_ACC
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to handle zeroing any space in the last&n; * block of the file that is beyond the EOF.  We do this since the&n; * size is being increased without writing anything to that block&n; * and we don&squot;t want anyone to read the garbage on the disk.&n; */
id|STATIC
r_int
multiline_comment|/* error (positive) */
DECL|function|xfs_zero_last_block
id|xfs_zero_last_block
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
id|xfs_fsize_t
id|isize
comma
id|xfs_fsize_t
id|end_size
)paren
(brace
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|zero_offset
suffix:semicolon
r_int
id|zero_len
suffix:semicolon
r_int
id|isize_fsb_offset
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
suffix:semicolon
id|loff_t
id|loff
suffix:semicolon
r_int
id|lsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
OG
id|isize
)paren
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|isize_fsb_offset
op_assign
id|XFS_B_FSB_OFFSET
c_func
(paren
id|mp
comma
id|isize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isize_fsb_offset
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * There are no extra bytes in the last block on disk to&n;&t;&t; * zero, so return.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|last_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|isize
)paren
suffix:semicolon
id|nimaps
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|last_fsb
comma
l_int|1
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nimaps
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the block underlying isize is just a hole, then there&n;&t; * is nothing to zero.&n;&t; */
r_if
c_cond
(paren
id|imap.br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get a pagebuf for the last block, zero the part beyond the&n;&t; * EOF, and write it out sync.&t;We need to drop the ilock&n;&t; * while we do this so we don&squot;t deadlock when the buffer cache&n;&t; * calls back to us.&n;&t; */
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|loff
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|last_fsb
)paren
suffix:semicolon
id|lsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
l_int|1
)paren
suffix:semicolon
id|zero_offset
op_assign
id|isize_fsb_offset
suffix:semicolon
id|zero_len
op_assign
id|mp-&gt;m_sb.sb_blocksize
op_minus
id|isize_fsb_offset
suffix:semicolon
id|error
op_assign
id|xfs_iozero
c_func
(paren
id|ip
comma
id|loff
op_plus
id|zero_offset
comma
id|zero_len
comma
id|end_size
)paren
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ge
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Zero any on disk space between the current EOF and the new,&n; * larger EOF.&t;This handles the normal case of zeroing the remainder&n; * of the last block in the file and the unusual case of zeroing blocks&n; * out beyond the size of the file.  This second case only happens&n; * with fixed size extents and when the system crashes before the inode&n; * size was updated but after blocks were allocated.  If fill is set,&n; * then any holes in the range are filled and zeroed.  If not, the holes&n; * are left alone as holes.&n; */
r_int
multiline_comment|/* error (positive) */
DECL|function|xfs_zero_eof
id|xfs_zero_eof
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
multiline_comment|/* starting I/O offset */
id|xfs_fsize_t
id|isize
comma
multiline_comment|/* current inode size */
id|xfs_fsize_t
id|end_size
)paren
multiline_comment|/* terminal inode size */
(brace
r_struct
id|inode
op_star
id|ip
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
suffix:semicolon
id|xfs_fileoff_t
id|start_zero_fsb
suffix:semicolon
id|xfs_fileoff_t
id|end_zero_fsb
suffix:semicolon
id|xfs_fileoff_t
id|prev_zero_fsb
suffix:semicolon
id|xfs_fileoff_t
id|zero_count_fsb
suffix:semicolon
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_extlen_t
id|buf_len_fsb
suffix:semicolon
id|xfs_extlen_t
id|prev_zero_count
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
suffix:semicolon
id|loff_t
id|loff
suffix:semicolon
r_int
id|lsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
multiline_comment|/*&n;&t; * First handle zeroing the block on which isize resides.&n;&t; * We only zero a part of that block so it is handled specially.&n;&t; */
id|error
op_assign
id|xfs_zero_last_block
c_func
(paren
id|ip
comma
id|io
comma
id|offset
comma
id|isize
comma
id|end_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate the range between the new size and the old&n;&t; * where blocks needing to be zeroed may exist.&t; To get the&n;&t; * block where the last byte in the file currently resides,&n;&t; * we need to subtract one from the size and truncate back&n;&t; * to a block boundary.&t; We subtract 1 in case the size is&n;&t; * exactly on a block boundary.&n;&t; */
id|last_fsb
op_assign
id|isize
ques
c_cond
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|isize
op_minus
l_int|1
)paren
suffix:colon
(paren
id|xfs_fileoff_t
)paren
op_minus
l_int|1
suffix:semicolon
id|start_zero_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|xfs_ufsize_t
)paren
id|isize
)paren
suffix:semicolon
id|end_zero_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
op_minus
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|xfs_sfiloff_t
)paren
id|last_fsb
OL
(paren
id|xfs_sfiloff_t
)paren
id|start_zero_fsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_fsb
op_eq
id|end_zero_fsb
)paren
(brace
multiline_comment|/*&n;&t;&t; * The size was only incremented on its last block.&n;&t;&t; * We took care of that above, so just return.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|start_zero_fsb
op_le
id|end_zero_fsb
)paren
suffix:semicolon
id|prev_zero_fsb
op_assign
id|NULLFILEOFF
suffix:semicolon
id|prev_zero_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Maybe change this loop to do the bmapi call and&n;&t; * loop while we split the mappings into pagebufs?&n;&t; */
r_while
c_loop
(paren
id|start_zero_fsb
op_le
id|end_zero_fsb
)paren
(brace
id|nimaps
op_assign
l_int|1
suffix:semicolon
id|zero_count_fsb
op_assign
id|end_zero_fsb
op_minus
id|start_zero_fsb
op_plus
l_int|1
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|start_zero_fsb
comma
id|zero_count_fsb
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nimaps
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap.br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This loop handles initializing pages that were&n;&t;&t;&t; * partially initialized by the code below this&n;&t;&t;&t; * loop. It basically zeroes the part of the page&n;&t;&t;&t; * that sits on a hole and sets the page as P_HOLE&n;&t;&t;&t; * and calls remapf if it is a mapped file.&n;&t;&t;&t; */
id|prev_zero_fsb
op_assign
id|NULLFILEOFF
suffix:semicolon
id|prev_zero_count
op_assign
l_int|0
suffix:semicolon
id|start_zero_fsb
op_assign
id|imap.br_startoff
op_plus
id|imap.br_blockcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_zero_fsb
op_le
(paren
id|end_zero_fsb
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * There are blocks in the range requested.&n;&t;&t; * Zero them a single write at a time.&t;We actually&n;&t;&t; * don&squot;t zero the entire range returned if it is&n;&t;&t; * too big and simply loop around to get the rest.&n;&t;&t; * That is not the most efficient thing to do, but it&n;&t;&t; * is simple and this path should not be exercised often.&n;&t;&t; */
id|buf_len_fsb
op_assign
id|XFS_FILBLKS_MIN
c_func
(paren
id|imap.br_blockcount
comma
id|mp-&gt;m_writeio_blocks
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Drop the inode lock while we&squot;re doing the I/O.&n;&t;&t; * We&squot;ll still have the iolock to protect us.&n;&t;&t; */
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|loff
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|start_zero_fsb
)paren
suffix:semicolon
id|lsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|buf_len_fsb
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iozero
c_func
(paren
id|ip
comma
id|loff
comma
id|lsize
comma
id|end_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out_lock
suffix:semicolon
)brace
id|prev_zero_fsb
op_assign
id|start_zero_fsb
suffix:semicolon
id|prev_zero_count
op_assign
id|buf_len_fsb
suffix:semicolon
id|start_zero_fsb
op_assign
id|imap.br_startoff
op_plus
id|buf_len_fsb
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_zero_fsb
op_le
(paren
id|end_zero_fsb
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out_lock
suffix:colon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ge
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ssize_t
multiline_comment|/* bytes written, or (-) error */
DECL|function|xfs_write
id|xfs_write
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_struct
id|iovec
op_star
id|iovp
comma
r_int
r_int
id|segs
comma
id|loff_t
op_star
id|offset
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_int
id|size
op_assign
l_int|0
suffix:semicolon
id|xfs_inode_t
op_star
id|xip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_fsize_t
id|isize
comma
id|new_size
suffix:semicolon
id|xfs_fsize_t
id|n
comma
id|limit
op_assign
id|XFS_MAX_FILE_OFFSET
suffix:semicolon
id|xfs_iocore_t
op_star
id|io
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
r_int
r_int
id|seg
suffix:semicolon
r_int
id|iolock
suffix:semicolon
r_int
id|direct
op_assign
id|file-&gt;f_flags
op_amp
id|O_DIRECT
suffix:semicolon
r_int
id|eventsent
op_assign
l_int|0
suffix:semicolon
id|vrwlock_t
id|locktype
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_write_calls
)paren
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
l_string|&quot;xfs_write&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|xip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
multiline_comment|/* START copy &amp; waste from filemap.c */
r_for
c_loop
(paren
id|seg
op_assign
l_int|0
suffix:semicolon
id|seg
OL
id|segs
suffix:semicolon
id|seg
op_increment
)paren
(brace
r_const
r_struct
id|iovec
op_star
id|iv
op_assign
op_amp
id|iovp
(braket
id|seg
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If any segment has a negative length, or the cumulative&n;&t;&t; * length ever wraps negative then return -EINVAL.&n;&t;&t; */
id|size
op_add_assign
id|iv-&gt;iov_len
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|ssize_t
)paren
(paren
id|size
op_or
id|iv-&gt;iov_len
)paren
OL
l_int|0
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|direct
)paren
(brace
multiline_comment|/* XFS specific check */
r_if
c_cond
(paren
(paren
id|__psint_t
)paren
id|iv-&gt;iov_base
op_amp
id|BBMASK
)paren
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|iv-&gt;iov_base
comma
id|iv-&gt;iov_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|seg
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
id|segs
op_assign
id|seg
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* END copy &amp; waste from filemap.c */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|io
op_assign
op_amp
(paren
id|xip-&gt;i_iocore
)paren
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|xfs_check_frozen
c_func
(paren
id|mp
comma
id|bdp
comma
id|XFS_FREEZE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|xip-&gt;i_mount
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|direct
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|offset
op_amp
id|mp-&gt;m_blockmask
)paren
op_logical_or
(paren
id|size
op_amp
id|mp-&gt;m_blockmask
)paren
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
id|iolock
op_assign
id|XFS_IOLOCK_SHARED
suffix:semicolon
id|locktype
op_assign
id|VRWLOCK_WRITE_DIRECT
suffix:semicolon
)brace
r_else
(brace
id|iolock
op_assign
id|XFS_IOLOCK_EXCL
suffix:semicolon
id|locktype
op_assign
id|VRWLOCK_WRITE
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
op_or
id|iolock
)paren
suffix:semicolon
id|isize
op_assign
id|xip-&gt;i_d.di_size
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
op_star
id|offset
op_assign
id|isize
suffix:semicolon
id|start
suffix:colon
id|n
op_assign
id|limit
op_minus
op_star
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
op_or
id|iolock
)paren
suffix:semicolon
r_return
op_minus
id|EFBIG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OL
id|size
)paren
id|size
op_assign
id|n
suffix:semicolon
id|new_size
op_assign
op_star
id|offset
op_plus
id|size
suffix:semicolon
r_if
c_cond
(paren
id|new_size
OG
id|isize
)paren
(brace
id|io-&gt;io_new_size
op_assign
id|new_size
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|xip
comma
id|DM_EVENT_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FINVIS
)paren
op_logical_and
op_logical_neg
id|eventsent
)paren
)paren
(brace
id|loff_t
id|savedsize
op_assign
op_star
id|offset
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_dm_send_data_event
c_func
(paren
id|DM_EVENT_WRITE
comma
id|bdp
comma
op_star
id|offset
comma
id|size
comma
id|FILP_DELAY_FLAG
c_func
(paren
id|file
)paren
comma
op_amp
id|locktype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|iolock
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|eventsent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The iolock was dropped and reaquired in&n;&t;&t; * xfs_dm_send_data_event so we have to recheck the size&n;&t;&t; *  when appending.  We will only &quot;goto start;&quot; once,&n;&t;&t; *  since having sent the event prevents another call&n;&t;&t; *  to xfs_dm_send_data_event, which is what&n;&t;&t; *  allows the size to change in the first place.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_APPEND
)paren
op_logical_and
id|savedsize
op_ne
id|xip-&gt;i_d.di_size
)paren
(brace
op_star
id|offset
op_assign
id|isize
op_assign
id|xip-&gt;i_d.di_size
suffix:semicolon
r_goto
id|start
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * On Linux, generic_file_write updates the times even if&n;&t; * no data is copied in so long as the write had a size.&n;&t; *&n;&t; * We must update xfs&squot; times since revalidate will overcopy xfs.&n;&t; */
r_if
c_cond
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FINVIS
)paren
)paren
id|xfs_ichgtime
c_func
(paren
id|xip
comma
id|XFS_ICHGTIME_MOD
op_or
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the offset is beyond the size of the file, we have a couple&n;&t; * of things to do. First, if there is already space allocated&n;&t; * we need to either create holes or zero the disk or ...&n;&t; *&n;&t; * If there is a page where the previous size lands, we need&n;&t; * to zero it out up to the new size.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|direct
op_logical_and
(paren
op_star
id|offset
OG
id|isize
op_logical_and
id|isize
)paren
)paren
(brace
id|error
op_assign
id|xfs_zero_eof
c_func
(paren
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
id|io
comma
op_star
id|offset
comma
id|isize
comma
op_star
id|offset
op_plus
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
op_or
id|iolock
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
)brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re writing the file then make sure to clear the&n;&t; * setuid and setgid bits if the process is not being run&n;&t; * by root.  This keeps people from modifying setuid and&n;&t; * setgid binaries.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|xip-&gt;i_d.di_mode
op_amp
id|ISUID
)paren
op_logical_or
(paren
(paren
id|xip-&gt;i_d.di_mode
op_amp
(paren
id|ISGID
op_or
(paren
id|IEXEC
op_rshift
l_int|3
)paren
)paren
)paren
op_eq
(paren
id|ISGID
op_or
(paren
id|IEXEC
op_rshift
l_int|3
)paren
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_FSETID
)paren
)paren
(brace
id|error
op_assign
id|xfs_write_clear_setuid
c_func
(paren
id|xip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|iolock
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
)brace
id|retry
suffix:colon
r_if
c_cond
(paren
id|direct
)paren
(brace
id|xfs_inval_cached_pages
c_func
(paren
id|vp
comma
op_amp
id|xip-&gt;i_iocore
comma
op_star
id|offset
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|generic_file_write_nolock
c_func
(paren
id|file
comma
id|iovp
comma
id|segs
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ENOSPC
)paren
op_logical_and
id|DM_EVENT_ENABLED
c_func
(paren
id|vp-&gt;v_vfsp
comma
id|xip
comma
id|DM_EVENT_NOSPACE
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FINVIS
)paren
)paren
(brace
id|xfs_rwunlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
id|error
op_assign
id|dm_send_namesp_event
c_func
(paren
id|DM_EVENT_NOSPACE
comma
id|bdp
comma
id|DM_RIGHT_NULL
comma
id|bdp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Delay flag intentionally  unused */
r_if
c_cond
(paren
id|error
)paren
r_return
op_minus
id|error
suffix:semicolon
id|xfs_rwlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
op_star
id|offset
op_assign
id|xip-&gt;i_d.di_size
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_le
l_int|0
)paren
(brace
id|xfs_rwunlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|XFS_STATS_ADD
c_func
(paren
id|xfsstats.xs_write_bytes
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
OG
id|xip-&gt;i_d.di_size
)paren
(brace
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
OG
id|xip-&gt;i_d.di_size
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|xip-&gt;i_d.di_size
op_assign
op_star
id|offset
suffix:semicolon
id|xip-&gt;i_update_core
op_assign
l_int|1
suffix:semicolon
id|xip-&gt;i_update_size
op_assign
l_int|1
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle various SYNC-type writes */
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_SYNC
)paren
op_logical_or
id|IS_SYNC
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we&squot;re treating this as O_DSYNC and we have not updated the&n;&t;&t; * size, force the log.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_OSYNCISOSYNC
)paren
op_logical_and
op_logical_neg
(paren
id|xip-&gt;i_update_size
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If an allocation transaction occurred&n;&t;&t;&t; * without extending the size, then we have to force&n;&t;&t;&t; * the log up the proper point to ensure that the&n;&t;&t;&t; * allocation is permanent.  We can&squot;t count on&n;&t;&t;&t; * the fact that buffered writes lock out direct I/O&n;&t;&t;&t; * writes - the direct I/O write could have extended&n;&t;&t;&t; * the size nontransactionally, then finished before&n;&t;&t;&t; * we started.&t;xfs_write_file will think that the file&n;&t;&t;&t; * didn&squot;t grow but the update isn&squot;t safe unless the&n;&t;&t;&t; * size change is logged.&n;&t;&t;&t; *&n;&t;&t;&t; * Force the log if we&squot;ve committed a transaction&n;&t;&t;&t; * against the inode or if someone else has and&n;&t;&t;&t; * the commit record hasn&squot;t gone to disk (e.g.&n;&t;&t;&t; * the inode is pinned).  This guarantees that&n;&t;&t;&t; * all changes affecting the inode are permanent&n;&t;&t;&t; * when we return.&n;&t;&t;&t; */
id|xfs_inode_log_item_t
op_star
id|iip
suffix:semicolon
id|xfs_lsn_t
id|lsn
suffix:semicolon
id|iip
op_assign
id|xip-&gt;i_itemp
suffix:semicolon
r_if
c_cond
(paren
id|iip
op_logical_and
id|iip-&gt;ili_last_lsn
)paren
(brace
id|lsn
op_assign
id|iip-&gt;ili_last_lsn
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
id|lsn
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_ipincount
c_func
(paren
id|xip
)paren
OG
l_int|0
)paren
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * O_SYNC or O_DSYNC _with_ a size update are handled&n;&t;&t;&t; * the same way.&n;&t;&t;&t; *&n;&t;&t;&t; * If the write was synchronous then we need to make&n;&t;&t;&t; * sure that the inode modification time is permanent.&n;&t;&t;&t; * We&squot;ll have updated the timestamp above, so here&n;&t;&t;&t; * we use a synchronous transaction to log the inode.&n;&t;&t;&t; * It&squot;s not fast, but it&squot;s necessary.&n;&t;&t;&t; *&n;&t;&t;&t; * If this a dsync write and the size got changed&n;&t;&t;&t; * non-transactionally, then we need to ensure that&n;&t;&t;&t; * the size change gets logged in a synchronous&n;&t;&t;&t; * transaction.&n;&t;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_WRITE_SYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_SWRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* Transaction reserve failed */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transaction reserve successful */
id|xfs_ilock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|xip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|xip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|xip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* (ioflags &amp; O_SYNC) */
multiline_comment|/*&n;&t; * If we are coming from an nfsd thread then insert into the&n;&t; * reference cache.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;nfsd&quot;
)paren
)paren
id|xfs_refcache_insert
c_func
(paren
id|xip
)paren
suffix:semicolon
multiline_comment|/* Drop lock this way - the old refcache release is in here */
id|xfs_rwunlock
c_func
(paren
id|bdp
comma
id|locktype
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_bmap() is the same as the irix xfs_bmap from xfs_rw.c&n; * execpt for slight changes to the params&n; */
r_int
DECL|function|xfs_bmap
id|xfs_bmap
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|xfs_off_t
id|offset
comma
id|ssize_t
id|count
comma
r_int
id|flags
comma
r_struct
id|cred
op_star
id|cred
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|lockmode
suffix:semicolon
r_int
id|fsynced
op_assign
l_int|0
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFREG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
l_int|0
)paren
op_eq
(paren
(paren
id|ip-&gt;i_iocore.io_flags
op_amp
id|XFS_IOCORE_RT
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|PBF_READ
)paren
op_logical_or
(paren
id|flags
op_amp
id|PBF_WRITE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_iocore.io_mount
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|PBF_READ
)paren
(brace
id|lockmode
op_assign
id|xfs_ilock_map_shared
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iomap_read
c_func
(paren
op_amp
id|ip-&gt;i_iocore
comma
id|offset
comma
id|count
comma
id|XFS_BMAPI_ENTIRE
comma
id|pbmapp
comma
id|npbmaps
)paren
suffix:semicolon
id|xfs_iunlock_map_shared
c_func
(paren
id|ip
comma
id|lockmode
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PBF_WRITE */
id|ASSERT
c_func
(paren
id|flags
op_amp
id|PBF_WRITE
)paren
suffix:semicolon
id|vp
op_assign
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure that the dquots are there. This doesn&squot;t hold&n;&t;&t; * the ilock across a disk read.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
(brace
r_if
c_cond
(paren
id|XFS_NOT_DQATTACHED
c_func
(paren
id|ip-&gt;i_mount
comma
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqattach
c_func
(paren
id|ip
comma
id|XFS_QMOPT_ILOCKED
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
id|retry
suffix:colon
id|error
op_assign
id|xfs_iomap_write
c_func
(paren
op_amp
id|ip-&gt;i_iocore
comma
id|offset
comma
id|count
comma
id|pbmapp
comma
id|npbmaps
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* xfs_iomap_write unlocks/locks/unlocks */
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
r_switch
c_cond
(paren
id|fsynced
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|ip-&gt;i_delayed_blks
)paren
(brace
id|filemap_fdatawrite
c_func
(paren
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
op_member_access_from_pointer
id|i_mapping
)paren
suffix:semicolon
id|fsynced
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|fsynced
op_assign
l_int|2
suffix:semicolon
id|flags
op_or_assign
id|PBF_SYNC
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
r_case
l_int|1
suffix:colon
id|fsynced
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|PBF_SYNC
)paren
)paren
(brace
id|flags
op_or_assign
id|PBF_SYNC
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
r_case
l_int|2
suffix:colon
id|sync_blockdev
c_func
(paren
id|vp-&gt;v_vfsp-&gt;vfs_super-&gt;s_bdev
)paren
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|ip-&gt;i_mount
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/**&n;&t;&t;&t;&t;delay(HZ);&n;**/
id|fsynced
op_increment
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
)brace
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_strategy
id|xfs_strategy
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|xfs_off_t
id|offset
comma
id|ssize_t
id|count
comma
r_int
id|flags
comma
r_struct
id|cred
op_star
id|cred
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_iocore_t
op_star
id|io
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|end_fsb
suffix:semicolon
id|xfs_fileoff_t
id|map_start_fsb
suffix:semicolon
id|xfs_fileoff_t
id|last_block
suffix:semicolon
id|xfs_fsblock_t
id|first_block
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
id|xfs_filblks_t
id|count_fsb
suffix:semicolon
r_int
id|committed
comma
id|i
comma
id|loops
comma
id|nimaps
suffix:semicolon
r_int
id|is_xfs
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* This will be a variable at some point */
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_MAX_RW_NBMAPS
)braket
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|BHV_TO_VNODE
c_func
(paren
id|bdp
)paren
comma
l_string|&quot;xfs_strategy&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|io
op_assign
op_amp
id|ip-&gt;i_iocore
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
multiline_comment|/* is_xfs = IO_IS_XFS(io); */
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_d.di_mode
op_amp
id|IFMT
)paren
op_eq
id|IFREG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
l_int|0
)paren
op_eq
(paren
(paren
id|io-&gt;io_flags
op_amp
id|XFS_IOCORE_RT
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|PBF_READ
)paren
op_logical_or
(paren
id|flags
op_amp
id|PBF_WRITE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|flags
op_amp
id|PBF_WRITE
)paren
suffix:semicolon
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|nimaps
op_assign
id|min
c_func
(paren
id|XFS_MAX_RW_NBMAPS
comma
op_star
id|npbmaps
)paren
suffix:semicolon
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
id|first_block
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_SHARED
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|offset_fsb
comma
(paren
id|xfs_filblks_t
)paren
(paren
id|end_fsb
op_minus
id|offset_fsb
)paren
comma
id|XFS_BMAPI_ENTIRE
comma
op_amp
id|first_block
comma
l_int|0
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_SHARED
op_or
id|XFS_EXTSIZE_RD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nimaps
op_logical_and
op_logical_neg
id|ISNULLSTARTBLOCK
c_func
(paren
id|imap
(braket
l_int|0
)braket
dot
id|br_startblock
)paren
)paren
(brace
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
op_amp
id|ip-&gt;i_iocore
comma
id|offset
comma
id|imap
comma
id|pbmapp
comma
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure that the dquots are there.&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|XFS_NOT_DQATTACHED
c_func
(paren
id|mp
comma
id|ip
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqattach
c_func
(paren
id|ip
comma
l_int|0
)paren
)paren
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
id|XFS_STATS_ADD
c_func
(paren
id|xfsstats.xs_xstrat_bytes
comma
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap
(braket
l_int|0
)braket
dot
id|br_blockcount
)paren
)paren
suffix:semicolon
id|offset_fsb
op_assign
id|imap
(braket
l_int|0
)braket
dot
id|br_startoff
suffix:semicolon
id|count_fsb
op_assign
id|imap
(braket
l_int|0
)braket
dot
id|br_blockcount
suffix:semicolon
id|map_start_fsb
op_assign
id|offset_fsb
suffix:semicolon
r_while
c_loop
(paren
id|count_fsb
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set up a transaction with which to allocate the&n;&t;&t; * backing store for the file.&t;Do allocations in a&n;&t;&t; * loop until we get some space in the range we are&n;&t;&t; * interested in.  The other space that might be allocated&n;&t;&t; * is in the delayed allocation extent on which we sit&n;&t;&t; * but before our buffer starts.&n;&t;&t; */
id|nimaps
op_assign
l_int|0
suffix:semicolon
id|loops
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|is_xfs
)paren
(brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_STRAT_WRITE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_WRITE_LOG_COUNT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
)brace
r_else
(brace
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|XFS_ILOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Allocate the backing store for the file.&n;&t;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
(paren
id|free_list
)paren
comma
op_amp
(paren
id|first_block
)paren
)paren
suffix:semicolon
id|nimaps
op_assign
id|XFS_STRAT_WRITE_IMAPS
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Ensure we don&squot;t go beyond eof - it is possible&n;&t;&t;&t; * the extents changed since we did the read call,&n;&t;&t;&t; * we dropped the ilock in the interim.&n;&t;&t;&t; */
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
)paren
suffix:semicolon
id|xfs_bmap_last_offset
c_func
(paren
l_int|NULL
comma
id|ip
comma
op_amp
id|last_block
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|last_block
op_assign
id|XFS_FILEOFF_MAX
c_func
(paren
id|last_block
comma
id|end_fsb
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|map_start_fsb
op_plus
id|count_fsb
)paren
OG
id|last_block
)paren
(brace
id|count_fsb
op_assign
id|last_block
op_minus
id|map_start_fsb
suffix:semicolon
r_if
c_cond
(paren
id|count_fsb
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|is_xfs
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
)brace
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EAGAIN
)paren
suffix:semicolon
)brace
)brace
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
id|tp
comma
id|io
comma
id|map_start_fsb
comma
id|count_fsb
comma
id|XFS_BMAPI_WRITE
comma
op_amp
id|first_block
comma
l_int|1
comma
id|imap
comma
op_amp
id|nimaps
comma
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_xfs
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
(paren
id|tp
)paren
comma
op_amp
(paren
id|free_list
)paren
comma
id|first_block
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
(paren
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
)brace
multiline_comment|/* else hold &squot;till we maybe loop again below */
)brace
multiline_comment|/*&n;&t;&t; * See if we were able to allocate an extent that&n;&t;&t; * covers at least part of the user&squot;s requested size.&n;&t;&t; */
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nimaps
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|maps
suffix:semicolon
r_if
c_cond
(paren
id|offset_fsb
op_ge
id|imap
(braket
id|i
)braket
dot
id|br_startoff
op_logical_and
(paren
id|offset_fsb
OL
(paren
id|imap
(braket
id|i
)braket
dot
id|br_startoff
op_plus
id|imap
(braket
id|i
)braket
dot
id|br_blockcount
)paren
)paren
)paren
(brace
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
id|maps
op_assign
id|min
c_func
(paren
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
id|io
comma
id|offset
comma
op_amp
id|imap
(braket
id|i
)braket
comma
id|pbmapp
comma
id|maps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_xstrat_quick
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|count_fsb
op_sub_assign
id|imap
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
multiline_comment|/* for next bmapi,&n;&t;&t;&t;&t;&t;&t;&t;&t;if needed. */
)brace
multiline_comment|/*&n;&t;&t; * We didn&squot;t get an extent the caller can write into so&n;&t;&t; * loop around and try starting after the last imap we got back.&n;&t;&t; */
id|nimaps
op_decrement
suffix:semicolon
multiline_comment|/* Index of last entry  */
id|ASSERT
c_func
(paren
id|nimaps
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset_fsb
op_ge
id|imap
(braket
id|nimaps
)braket
dot
id|br_startoff
op_plus
id|imap
(braket
id|nimaps
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|count_fsb
)paren
suffix:semicolon
id|offset_fsb
op_assign
id|imap
(braket
id|nimaps
)braket
dot
id|br_startoff
op_plus
id|imap
(braket
id|nimaps
)braket
dot
id|br_blockcount
suffix:semicolon
id|map_start_fsb
op_assign
id|offset_fsb
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_xstrat_split
)paren
suffix:semicolon
id|XFS_IUNLOCK
c_func
(paren
id|mp
comma
id|io
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_EXTSIZE_WR
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Should never get here */
id|error0
suffix:colon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|count_fsb
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|is_xfs
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|_xfs_imap_to_bmap
id|_xfs_imap_to_bmap
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_off_t
id|offset
comma
id|xfs_bmbt_irec_t
op_star
id|imap
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
id|imaps
comma
multiline_comment|/* Number of imap entries */
r_int
id|pbmaps
)paren
multiline_comment|/* Number of pbmap entries */
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_fsize_t
id|nisize
suffix:semicolon
r_int
id|im
comma
id|pbm
suffix:semicolon
id|xfs_fsblock_t
id|start_block
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|nisize
op_assign
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;io_new_size
OG
id|nisize
)paren
id|nisize
op_assign
id|io-&gt;io_new_size
suffix:semicolon
r_for
c_loop
(paren
id|im
op_assign
l_int|0
comma
id|pbm
op_assign
l_int|0
suffix:semicolon
id|im
OL
id|imaps
op_logical_and
id|pbm
OL
id|pbmaps
suffix:semicolon
id|im
op_increment
comma
id|pbmapp
op_increment
comma
id|imap
op_increment
comma
id|pbm
op_increment
)paren
(brace
id|pbmapp-&gt;pbm_target
op_assign
id|io-&gt;io_flags
op_amp
id|XFS_IOCORE_RT
ques
c_cond
id|mp-&gt;m_rtdev_targp
suffix:colon
id|mp-&gt;m_ddev_targp
suffix:semicolon
id|pbmapp-&gt;pbm_offset
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap-&gt;br_startoff
)paren
suffix:semicolon
id|pbmapp-&gt;pbm_delta
op_assign
id|offset
op_minus
id|pbmapp-&gt;pbm_offset
suffix:semicolon
id|pbmapp-&gt;pbm_bsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imap-&gt;br_blockcount
)paren
suffix:semicolon
id|pbmapp-&gt;pbm_flags
op_assign
l_int|0
suffix:semicolon
id|start_block
op_assign
id|imap-&gt;br_startblock
suffix:semicolon
r_if
c_cond
(paren
id|start_block
op_eq
id|HOLESTARTBLOCK
)paren
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|PAGE_BUF_DADDR_NULL
suffix:semicolon
id|pbmapp-&gt;pbm_flags
op_assign
id|PBMF_HOLE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|start_block
op_eq
id|DELAYSTARTBLOCK
)paren
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|PAGE_BUF_DADDR_NULL
suffix:semicolon
id|pbmapp-&gt;pbm_flags
op_assign
id|PBMF_DELAY
suffix:semicolon
)brace
r_else
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|XFS_FSB_TO_DB_IO
c_func
(paren
id|io
comma
id|start_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imap-&gt;br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
id|pbmapp-&gt;pbm_flags
op_or_assign
id|PBMF_UNWRITTEN
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pbmapp-&gt;pbm_offset
op_plus
id|pbmapp-&gt;pbm_bsize
)paren
op_ge
id|nisize
)paren
(brace
id|pbmapp-&gt;pbm_flags
op_or_assign
id|PBMF_EOF
suffix:semicolon
)brace
id|offset
op_add_assign
id|pbmapp-&gt;pbm_bsize
op_minus
id|pbmapp-&gt;pbm_delta
suffix:semicolon
)brace
r_return
id|pbm
suffix:semicolon
multiline_comment|/* Return the number filled */
)brace
id|STATIC
r_int
DECL|function|xfs_iomap_read
id|xfs_iomap_read
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
r_int
id|flags
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
)paren
(brace
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|end_fsb
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_MAX_RW_NBMAPS
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
op_or
id|MR_ACCESS
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/**&t;ASSERT(ismrlocked(io-&gt;io_iolock, MR_UPDATE | MR_ACCESS) != 0); **/
multiline_comment|/*&t;xfs_iomap_enter_trace(XFS_IOMAP_READ_ENTER, io, offset, count); */
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|nimaps
op_assign
r_sizeof
(paren
id|imap
)paren
op_div
r_sizeof
(paren
id|imap
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|nimaps
op_assign
id|min
c_func
(paren
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t ask for more than caller has */
id|end_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|offset_fsb
comma
(paren
id|xfs_filblks_t
)paren
(paren
id|end_fsb
op_minus
id|offset_fsb
)paren
comma
id|flags
comma
l_int|NULL
comma
l_int|0
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nimaps
)paren
(brace
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
id|io
comma
id|offset
comma
id|imap
comma
id|pbmapp
comma
id|nimaps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
)brace
r_else
op_star
id|npbmaps
op_assign
l_int|0
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_iomap_write: return pagebuf_bmap_t&squot;s telling higher layers&n; *&t;where to write.&n; * There are 2 main cases:&n; *&t;1 the extents already exist&n; *&t;2 must allocate.&n; *&t;There are 3 cases when we allocate:&n; *&t;&t;delay allocation (doesn&squot;t really allocate or use transactions)&n; *&t;&t;direct allocation (no previous delay allocation&n; *&t;&t;convert delay to real allocations&n; */
id|STATIC
r_int
DECL|function|xfs_iomap_write
id|xfs_iomap_write
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
comma
r_int
id|ioflag
)paren
(brace
r_int
id|maps
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|maps
op_assign
op_star
id|npbmaps
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|maps
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If we have extents that are allocated for this range,&n;&t; * return them.&n;&t; */
id|found
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_iomap_read
c_func
(paren
id|io
comma
id|offset
comma
id|count
comma
id|flags
comma
id|pbmapp
comma
id|npbmaps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If we found mappings and they can just have data written&n;&t; * without conversion,&n;&t; * let the caller write these and call us again.&n;&t; *&n;&t; * If we have a HOLE or UNWRITTEN, proceed down lower to&n;&t; * get the space or to convert to written.&n;&t; */
r_if
c_cond
(paren
op_star
id|npbmaps
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pbmapp-&gt;pbm_flags
op_amp
id|PBMF_HOLE
)paren
)paren
(brace
op_star
id|npbmaps
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Only checked the first one. */
multiline_comment|/* We could check more, ... */
r_goto
id|out
suffix:semicolon
)brace
)brace
id|found
op_assign
op_star
id|npbmaps
suffix:semicolon
op_star
id|npbmaps
op_assign
id|maps
suffix:semicolon
multiline_comment|/* Restore to original requested */
r_if
c_cond
(paren
id|ioflag
op_amp
id|PBF_DIRECT
)paren
(brace
id|error
op_assign
id|xfs_iomap_write_direct
c_func
(paren
id|io
comma
id|offset
comma
id|count
comma
id|pbmapp
comma
id|npbmaps
comma
id|ioflag
comma
id|found
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_iomap_write_delay
c_func
(paren
id|io
comma
id|offset
comma
id|count
comma
id|pbmapp
comma
id|npbmaps
comma
id|ioflag
comma
id|found
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|XFS_IUNLOCK
c_func
(paren
id|io-&gt;io_mount
comma
id|io
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map the given I/O size and I/O alignment over the given extent.&n; * If we&squot;re at the end of the file and the underlying extent is&n; * delayed alloc, make sure we extend out to the&n; * next i_writeio_blocks boundary.  Otherwise make sure that we&n; * are confined to the given extent.&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_void
DECL|function|xfs_write_bmap
id|xfs_write_bmap
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_iocore_t
op_star
id|io
comma
id|xfs_bmbt_irec_t
op_star
id|imapp
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
id|iosize
comma
id|xfs_fileoff_t
id|ioalign
comma
id|xfs_fsize_t
id|isize
)paren
(brace
id|__int64_t
id|extra_blocks
suffix:semicolon
id|xfs_fileoff_t
id|size_diff
suffix:semicolon
id|xfs_fileoff_t
id|ext_offset
suffix:semicolon
id|xfs_fsblock_t
id|start_block
suffix:semicolon
r_int
id|length
suffix:semicolon
multiline_comment|/* length of this mapping in blocks */
id|xfs_off_t
id|offset
suffix:semicolon
multiline_comment|/* logical block offset of this mapping */
r_if
c_cond
(paren
id|ioalign
OL
id|imapp-&gt;br_startoff
)paren
(brace
multiline_comment|/*&n;&t;&t; * The desired alignment doesn&squot;t end up on this&n;&t;&t; * extent.  Move up to the beginning of the extent.&n;&t;&t; * Subtract whatever we drop from the iosize so that&n;&t;&t; * we stay aligned on iosize boundaries.&n;&t;&t; */
id|size_diff
op_assign
id|imapp-&gt;br_startoff
op_minus
id|ioalign
suffix:semicolon
id|iosize
op_sub_assign
(paren
r_int
)paren
id|size_diff
suffix:semicolon
id|ASSERT
c_func
(paren
id|iosize
OG
l_int|0
)paren
suffix:semicolon
id|ext_offset
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
id|imapp-&gt;br_startoff
suffix:semicolon
id|pbmapp-&gt;pbm_offset
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|imapp-&gt;br_startoff
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The alignment requested fits on this extent,&n;&t;&t; * so use it.&n;&t;&t; */
id|ext_offset
op_assign
id|ioalign
op_minus
id|imapp-&gt;br_startoff
suffix:semicolon
id|offset
op_assign
id|ioalign
suffix:semicolon
id|pbmapp-&gt;pbm_offset
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|ioalign
)paren
suffix:semicolon
)brace
id|start_block
op_assign
id|imapp-&gt;br_startblock
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_block
op_ne
id|HOLESTARTBLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_block
op_ne
id|DELAYSTARTBLOCK
)paren
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|XFS_FSB_TO_DB_IO
c_func
(paren
id|io
comma
id|start_block
op_plus
id|ext_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|imapp-&gt;br_state
op_eq
id|XFS_EXT_UNWRITTEN
)paren
(brace
id|pbmapp-&gt;pbm_flags
op_assign
id|PBMF_UNWRITTEN
suffix:semicolon
)brace
)brace
r_else
(brace
id|pbmapp-&gt;pbm_bn
op_assign
id|PAGE_BUF_DADDR_NULL
suffix:semicolon
id|pbmapp-&gt;pbm_flags
op_assign
id|PBMF_DELAY
suffix:semicolon
)brace
id|pbmapp-&gt;pbm_target
op_assign
id|io-&gt;io_flags
op_amp
id|XFS_IOCORE_RT
ques
c_cond
id|mp-&gt;m_rtdev_targp
suffix:colon
id|mp-&gt;m_ddev_targp
suffix:semicolon
id|length
op_assign
id|iosize
suffix:semicolon
multiline_comment|/*&n;&t; * If the iosize from our offset extends beyond the end of&n;&t; * the extent, then trim down length to match that of the extent.&n;&t; */
id|extra_blocks
op_assign
(paren
id|xfs_off_t
)paren
(paren
id|offset
op_plus
id|length
)paren
op_minus
(paren
id|__uint64_t
)paren
(paren
id|imapp-&gt;br_startoff
op_plus
id|imapp-&gt;br_blockcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|extra_blocks
OG
l_int|0
)paren
(brace
id|length
op_sub_assign
id|extra_blocks
suffix:semicolon
id|ASSERT
c_func
(paren
id|length
OG
l_int|0
)paren
suffix:semicolon
)brace
id|pbmapp-&gt;pbm_bsize
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|length
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_iomap_write_delay
id|xfs_iomap_write_delay
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
comma
r_int
id|ioflag
comma
r_int
id|found
)paren
(brace
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|ioalign
suffix:semicolon
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_fileoff_t
id|start_fsb
suffix:semicolon
id|xfs_filblks_t
id|count_fsb
suffix:semicolon
id|xfs_off_t
id|aligned_offset
suffix:semicolon
id|xfs_fsize_t
id|isize
suffix:semicolon
id|xfs_fsblock_t
id|firstblock
suffix:semicolon
id|__uint64_t
id|last_page_offset
suffix:semicolon
r_int
id|nimaps
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
r_int
id|iosize
suffix:semicolon
r_int
id|small_write
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
DECL|macro|XFS_WRITE_IMAPS
mdefine_line|#define XFS_WRITE_IMAPS XFS_BMAP_MAX_NMAP
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_WRITE_IMAPS
)braket
suffix:semicolon
r_int
id|aeof
suffix:semicolon
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
id|io-&gt;io_lock
comma
id|MR_UPDATE
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&t;xfs_iomap_enter_trace(XFS_IOMAP_WRITE_ENTER, io, offset, count); */
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
multiline_comment|/***&n;&t;ASSERT(! XFS_NOT_DQATTACHED(mp, ip));&n;***/
id|isize
op_assign
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;io_new_size
OG
id|isize
)paren
(brace
id|isize
op_assign
id|io-&gt;io_new_size
suffix:semicolon
)brace
id|aeof
op_assign
l_int|0
suffix:semicolon
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|last_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the caller is doing a write at the end of the file,&n;&t; * then extend the allocation (and the buffer used for the write)&n;&t; * out to the file system&squot;s write iosize.  We clean up any extra&n;&t; * space left over when the file is closed in xfs_inactive().&n;&t; * We can only do this if we are sure that we will create buffers&n;&t; * over all of the space we allocate beyond the end of the file.&n;&t; * Not doing so would allow us to create delalloc blocks with&n;&t; * no pages in memory covering them.  So, we need to check that&n;&t; * there are not any real blocks in the area beyond the end of&n;&t; * the file which we are optimistically going to preallocate. If&n;&t; * there are then our buffers will stop when they encounter them&n;&t; * and we may accidentally create delalloc blocks beyond them&n;&t; * that we never cover with a buffer.  All of this is because&n;&t; * we are not actually going to write the extra blocks preallocated&n;&t; * at this point.&n;&t; *&n;&t; * We don&squot;t bother with this for sync writes, because we need&n;&t; * to minimize the amount we write for good performance.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ioflag
op_amp
id|PBF_SYNC
)paren
op_logical_and
(paren
(paren
id|offset
op_plus
id|count
)paren
OG
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
)paren
)paren
(brace
id|start_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|count_fsb
op_assign
id|mp-&gt;m_writeio_blocks
suffix:semicolon
r_while
c_loop
(paren
id|count_fsb
OG
l_int|0
)paren
(brace
id|nimaps
op_assign
id|XFS_WRITE_IMAPS
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|start_fsb
comma
id|count_fsb
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|nimaps
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|imap
(braket
id|n
)braket
dot
id|br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
op_logical_and
(paren
id|imap
(braket
id|n
)braket
dot
id|br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
)paren
(brace
r_goto
id|write_map
suffix:semicolon
)brace
id|start_fsb
op_add_assign
id|imap
(braket
id|n
)braket
dot
id|br_blockcount
suffix:semicolon
id|count_fsb
op_sub_assign
id|imap
(braket
id|n
)braket
dot
id|br_blockcount
suffix:semicolon
id|ASSERT
c_func
(paren
id|count_fsb
OL
l_int|0xffff000
)paren
suffix:semicolon
)brace
)brace
id|iosize
op_assign
id|mp-&gt;m_writeio_blocks
suffix:semicolon
id|aligned_offset
op_assign
id|XFS_WRITEIO_ALIGN
c_func
(paren
id|mp
comma
(paren
id|offset
op_plus
id|count
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|ioalign
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|aligned_offset
)paren
suffix:semicolon
id|last_fsb
op_assign
id|ioalign
op_plus
id|iosize
suffix:semicolon
id|aeof
op_assign
l_int|1
suffix:semicolon
)brace
id|write_map
suffix:colon
id|nimaps
op_assign
id|XFS_WRITE_IMAPS
suffix:semicolon
id|firstblock
op_assign
id|NULLFSBLOCK
suffix:semicolon
multiline_comment|/*&n;&t; * roundup the allocation request to m_dalign boundary if file size&n;&t; * is greater that 512K and we are allocating past the allocation eof&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_dalign
op_logical_and
(paren
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
op_ge
id|mp-&gt;m_dalign
)paren
op_logical_and
id|aeof
)paren
(brace
r_int
id|eof
suffix:semicolon
id|xfs_fileoff_t
id|new_last_fsb
suffix:semicolon
id|new_last_fsb
op_assign
id|roundup_64
c_func
(paren
id|last_fsb
comma
id|mp-&gt;m_dalign
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAP_EOF
c_func
(paren
id|mp
comma
id|io
comma
id|new_last_fsb
comma
id|XFS_DATA_FORK
comma
op_amp
id|eof
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eof
)paren
(brace
id|last_fsb
op_assign
id|new_last_fsb
suffix:semicolon
)brace
)brace
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|io
comma
id|offset_fsb
comma
(paren
id|xfs_filblks_t
)paren
(paren
id|last_fsb
op_minus
id|offset_fsb
)paren
comma
id|XFS_BMAPI_DELAY
op_or
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_ENTIRE
comma
op_amp
id|firstblock
comma
l_int|1
comma
id|imap
comma
op_amp
id|nimaps
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can be EDQUOT, if nimaps == 0&n;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If bmapi returned us nothing, and if we didn&squot;t get back EDQUOT,&n;&t; * then we must have run out of space.&n;&t; */
r_if
c_cond
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&t;&t;xfs_iomap_enter_trace(XFS_IOMAP_WRITE_NOSPACE,&n;&t;&t;&t;&t;      io, offset, count); */
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ioflag
op_amp
id|PBF_SYNC
)paren
op_logical_or
(paren
(paren
id|last_fsb
op_minus
id|offset_fsb
)paren
op_ge
id|mp-&gt;m_writeio_blocks
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * For normal or large sync writes, align everything&n;&t;&t; * into i_writeio_blocks sized chunks.&n;&t;&t; */
id|iosize
op_assign
id|mp-&gt;m_writeio_blocks
suffix:semicolon
id|aligned_offset
op_assign
id|XFS_WRITEIO_ALIGN
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|ioalign
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|aligned_offset
)paren
suffix:semicolon
id|small_write
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX - Are we shrinking? XXXXX  */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * For small sync writes try to minimize the amount&n;&t;&t; * of I/O we do.  Round down and up to the larger of&n;&t;&t; * page or block boundaries.  Set the small_write&n;&t;&t; * variable to 1 to indicate to the code below that&n;&t;&t; * we are not using the normal buffer alignment scheme.&n;&t;&t; */
r_if
c_cond
(paren
id|NBPP
OG
id|mp-&gt;m_sb.sb_blocksize
)paren
(brace
id|aligned_offset
op_assign
id|ctooff
c_func
(paren
id|offtoct
c_func
(paren
id|offset
)paren
)paren
suffix:semicolon
id|ioalign
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|aligned_offset
)paren
suffix:semicolon
id|last_page_offset
op_assign
id|ctob64
c_func
(paren
id|btoc64
c_func
(paren
id|offset
op_plus
id|count
)paren
)paren
suffix:semicolon
id|iosize
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|last_page_offset
op_minus
id|aligned_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioalign
op_assign
id|offset_fsb
suffix:semicolon
id|iosize
op_assign
id|last_fsb
op_minus
id|offset_fsb
suffix:semicolon
)brace
id|small_write
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* XXX - Are we shrinking? XXXXX  */
)brace
multiline_comment|/*&n;&t; * Now map our desired I/O size and alignment over the&n;&t; * extents returned by xfs_bmapi().&n;&t; */
id|xfs_write_bmap
c_func
(paren
id|mp
comma
id|io
comma
id|imap
comma
id|pbmapp
comma
id|iosize
comma
id|ioalign
comma
id|isize
)paren
suffix:semicolon
id|pbmapp-&gt;pbm_delta
op_assign
id|offset
op_minus
id|pbmapp-&gt;pbm_offset
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|pbmapp-&gt;pbm_bsize
OG
l_int|0
)paren
op_logical_and
(paren
id|pbmapp-&gt;pbm_bsize
op_minus
id|pbmapp-&gt;pbm_delta
OG
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A bmap is the EOF bmap when it reaches to or beyond the new&n;&t; * inode size.&n;&t; */
r_if
c_cond
(paren
(paren
id|pbmapp-&gt;pbm_offset
op_plus
id|pbmapp-&gt;pbm_bsize
)paren
op_ge
id|isize
)paren
(brace
id|pbmapp-&gt;pbm_flags
op_or_assign
id|PBMF_EOF
suffix:semicolon
)brace
multiline_comment|/*&t;xfs_iomap_map_trace(XFS_IOMAP_WRITE_MAP,&n;&t;&t;&t;    io, offset, count, bmapp, imap);&t;     */
multiline_comment|/* On IRIX, we walk more imaps filling in more bmaps. On Linux&n;&t;&t;just handle one for now. To find the code on IRIX,&n;&t;&t;look in xfs_iomap_write() in xfs_rw.c. */
op_star
id|npbmaps
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_iomap_write_direct
id|xfs_iomap_write_direct
c_func
(paren
id|xfs_iocore_t
op_star
id|io
comma
id|loff_t
id|offset
comma
r_int
id|count
comma
id|pb_bmap_t
op_star
id|pbmapp
comma
r_int
op_star
id|npbmaps
comma
r_int
id|ioflag
comma
r_int
id|found
)paren
(brace
id|xfs_inode_t
op_star
id|ip
op_assign
id|XFS_IO_INODE
c_func
(paren
id|io
)paren
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_fileoff_t
id|offset_fsb
suffix:semicolon
id|xfs_fileoff_t
id|last_fsb
suffix:semicolon
id|xfs_filblks_t
id|count_fsb
suffix:semicolon
id|xfs_fsize_t
id|isize
suffix:semicolon
id|xfs_fsblock_t
id|firstfsb
suffix:semicolon
r_int
id|nimaps
comma
id|maps
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
DECL|macro|XFS_WRITE_IMAPS
mdefine_line|#define XFS_WRITE_IMAPS XFS_BMAP_MAX_NMAP
id|xfs_bmbt_irec_t
id|imap
(braket
id|XFS_WRITE_IMAPS
)braket
comma
op_star
id|imapp
suffix:semicolon
id|xfs_bmap_free_t
id|free_list
suffix:semicolon
r_int
id|aeof
suffix:semicolon
r_int
id|bmapi_flags
suffix:semicolon
id|xfs_filblks_t
id|datablocks
suffix:semicolon
r_int
id|rt
suffix:semicolon
r_int
id|committed
suffix:semicolon
r_int
id|numrtextents
suffix:semicolon
id|uint
id|resblks
suffix:semicolon
r_int
id|rtextsize
suffix:semicolon
id|maps
op_assign
id|min
c_func
(paren
id|XFS_WRITE_IMAPS
comma
op_star
id|npbmaps
)paren
suffix:semicolon
id|nimaps
op_assign
id|maps
suffix:semicolon
id|mp
op_assign
id|io-&gt;io_mount
suffix:semicolon
id|isize
op_assign
id|XFS_SIZE
c_func
(paren
id|mp
comma
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|io-&gt;io_new_size
OG
id|isize
)paren
id|isize
op_assign
id|io-&gt;io_new_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|count
)paren
OG
id|isize
)paren
(brace
id|aeof
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|aeof
op_assign
l_int|0
suffix:semicolon
)brace
id|offset_fsb
op_assign
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|offset
)paren
suffix:semicolon
id|last_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|xfs_ufsize_t
)paren
(paren
id|offset
op_plus
id|count
)paren
)paren
)paren
suffix:semicolon
id|count_fsb
op_assign
id|last_fsb
op_minus
id|offset_fsb
suffix:semicolon
r_if
c_cond
(paren
id|found
op_logical_and
(paren
id|pbmapp-&gt;pbm_flags
op_amp
id|PBMF_HOLE
)paren
)paren
(brace
id|xfs_fileoff_t
id|map_last_fsb
suffix:semicolon
id|map_last_fsb
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
(paren
id|pbmapp-&gt;pbm_bsize
op_plus
id|pbmapp-&gt;pbm_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map_last_fsb
OL
id|last_fsb
)paren
(brace
id|last_fsb
op_assign
id|map_last_fsb
suffix:semicolon
id|count_fsb
op_assign
id|last_fsb
op_minus
id|offset_fsb
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|count_fsb
OG
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * roundup the allocation request to m_dalign boundary if file size&n;&t; * is greater that 512K and we are allocating past the allocation eof&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|mp-&gt;m_dalign
op_logical_and
(paren
id|isize
op_ge
l_int|524288
)paren
op_logical_and
id|aeof
)paren
(brace
r_int
id|eof
suffix:semicolon
id|xfs_fileoff_t
id|new_last_fsb
suffix:semicolon
id|new_last_fsb
op_assign
id|roundup_64
c_func
(paren
id|last_fsb
comma
id|mp-&gt;m_dalign
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xfs_iomap_write_direct: about to XFS_BMAP_EOF %Ld&bslash;n&quot;
comma
id|new_last_fsb
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BMAP_EOF
c_func
(paren
id|mp
comma
id|io
comma
id|new_last_fsb
comma
id|XFS_DATA_FORK
comma
op_amp
id|eof
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eof
)paren
id|last_fsb
op_assign
id|new_last_fsb
suffix:semicolon
)brace
id|bmapi_flags
op_assign
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_DIRECT_IO
op_or
id|XFS_BMAPI_ENTIRE
suffix:semicolon
id|bmapi_flags
op_and_assign
op_complement
id|XFS_BMAPI_DIRECT_IO
suffix:semicolon
multiline_comment|/*&n;&t; * determine if this is a realtime file&n;&t; */
r_if
c_cond
(paren
(paren
id|rt
op_assign
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|rtextsize
op_assign
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
)brace
r_else
id|rtextsize
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * allocate file space for the bmapp entries passed in.&n;&t; */
multiline_comment|/*&n;&t; * determine if reserving space on&n;&t; * the data or realtime partition.&n;&t; */
r_if
c_cond
(paren
id|rt
)paren
(brace
id|numrtextents
op_assign
(paren
id|count_fsb
op_plus
id|rtextsize
op_minus
l_int|1
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|numrtextents
comma
id|rtextsize
)paren
suffix:semicolon
id|datablocks
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|datablocks
op_assign
id|count_fsb
suffix:semicolon
id|numrtextents
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * allocate and setup the transaction&n;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_DIOSTRAT
)paren
suffix:semicolon
id|resblks
op_assign
id|XFS_DIOSTRAT_SPACE_RES
c_func
(paren
id|mp
comma
id|datablocks
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|resblks
comma
id|XFS_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
comma
id|numrtextents
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_WRITE_LOG_COUNT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check for running out of space&n;&t; */
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * Free the transaction structure.&n;&t;&t; */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error_out
suffix:semicolon
multiline_comment|/* Don&squot;t return in above if .. trans ..,&n;&t;&t;&t;&t;&t;need lock to return */
)brace
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_trans_reserve_quota
c_func
(paren
id|tp
comma
id|ip-&gt;i_udquot
comma
id|ip-&gt;i_gdquot
comma
id|resblks
comma
l_int|0
comma
l_int|0
)paren
)paren
(brace
id|error
op_assign
(paren
id|EDQUOT
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|nimaps
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|nimaps
op_assign
l_int|2
suffix:semicolon
)brace
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * issue the bmapi() call to allocate the blocks&n;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|free_list
comma
op_amp
id|firstfsb
)paren
suffix:semicolon
id|imapp
op_assign
op_amp
id|imap
(braket
l_int|0
)braket
suffix:semicolon
id|error
op_assign
id|XFS_BMAPI
c_func
(paren
id|mp
comma
id|tp
comma
id|io
comma
id|offset_fsb
comma
id|count_fsb
comma
id|bmapi_flags
comma
op_amp
id|firstfsb
comma
l_int|1
comma
id|imapp
comma
op_amp
id|nimaps
comma
op_amp
id|free_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * complete the transaction&n;&t; */
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|free_list
comma
id|firstfsb
comma
op_amp
id|committed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|error_out
suffix:semicolon
)brace
multiline_comment|/* copy any maps to caller&squot;s array and return any error. */
r_if
c_cond
(paren
id|nimaps
op_eq
l_int|0
)paren
(brace
id|error
op_assign
(paren
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
id|maps
op_assign
id|min
c_func
(paren
id|nimaps
comma
id|maps
)paren
suffix:semicolon
op_star
id|npbmaps
op_assign
id|_xfs_imap_to_bmap
c_func
(paren
id|io
comma
id|offset
comma
op_amp
id|imap
(braket
l_int|0
)braket
comma
id|pbmapp
comma
id|maps
comma
op_star
id|npbmaps
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|npbmaps
)paren
(brace
multiline_comment|/*&n;&t;&t; * this is new since xfs_iomap_read&n;&t;&t; * didn&squot;t find it.&n;&t;&t; */
r_if
c_cond
(paren
op_star
id|npbmaps
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NEED MORE WORK FOR MULTIPLE BMAPS (which are new)&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_goto
id|out
suffix:semicolon
id|error0
suffix:colon
multiline_comment|/* Cancel bmap, unlock inode, and cancel trans */
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|free_list
)paren
suffix:semicolon
id|error1
suffix:colon
multiline_comment|/* Just cancel transaction */
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
op_star
id|npbmaps
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nothing set-up here */
id|error_out
suffix:colon
id|out
suffix:colon
multiline_comment|/* Just return error and any tracing at end of routine */
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * All xfs metadata buffers except log state machine buffers&n; * get this attached as their b_bdstrat callback function.&n; * This is so that we can catch a buffer&n; * after prematurely unpinning it to forcibly shutdown the filesystem.&n; */
r_int
DECL|function|xfs_bdstrat_cb
id|xfs_bdstrat_cb
c_func
(paren
r_struct
id|xfs_buf
op_star
id|bp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|XFS_BUF_FSPRIVATE3
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|pagebuf_iorequest
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFS__BDSTRAT IOERROR&quot;
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Metadata write that didn&squot;t get logged but&n;&t;&t; * written delayed anyway. These aren&squot;t associated&n;&t;&t; * with a transaction, and can be ignored.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_BUF_IODONE_FUNC
c_func
(paren
id|bp
)paren
op_eq
l_int|NULL
op_logical_and
(paren
id|XFS_BUF_ISREAD
c_func
(paren
id|bp
)paren
)paren
op_eq
l_int|0
)paren
r_return
(paren
id|xfs_bioerror_relse
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_else
r_return
(paren
id|xfs_bioerror
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Wrapper around bdstrat so that we can stop data&n; * from going to disk in case we are shutting down the filesystem.&n; * Typically user data goes thru this path; one of the exceptions&n; * is the superblock.&n; */
r_int
DECL|function|xfsbdstrat
id|xfsbdstrat
c_func
(paren
r_struct
id|xfs_mount
op_star
id|mp
comma
r_struct
id|xfs_buf
op_star
id|bp
)paren
(brace
id|ASSERT
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
multiline_comment|/* Grio redirection would go here&n;&t;&t; * if (XFS_BUF_IS_GRIO(bp)) {&n;&t;&t; */
id|pagebuf_iorequest
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;XFSBDSTRAT IOERROR&quot;
comma
id|bp
)paren
suffix:semicolon
r_return
(paren
id|xfs_bioerror_relse
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|XFS_bflush
id|XFS_bflush
c_func
(paren
id|xfs_buftarg_t
op_star
id|target
)paren
(brace
id|pagebuf_delwri_flush
c_func
(paren
id|target
comma
id|PBDF_WAIT
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Push all fs state out to disk&n; */
r_void
DECL|function|XFS_log_write_unmount_ro
id|XFS_log_write_unmount_ro
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|pincount
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_refcache_purge_mp
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_binval
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
r_do
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|VFS_SYNC
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
comma
id|SYNC_ATTR
op_or
id|SYNC_WAIT
comma
l_int|NULL
comma
id|error
)paren
suffix:semicolon
id|pagebuf_delwri_flush
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|PBDF_WAIT
comma
op_amp
id|pincount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pincount
op_eq
l_int|0
)paren
(brace
id|delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count
OL
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Ok now write out an unmount record */
id|xfs_log_unmount_write
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_unmountfs_writesb
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If the underlying (log or data) device is readonly, there are some&n; * operations that cannot proceed.&n; */
r_int
DECL|function|xfs_dev_is_read_only
id|xfs_dev_is_read_only
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_char
op_star
id|message
)paren
(brace
r_if
c_cond
(paren
id|bdev_read_only
c_func
(paren
id|mp-&gt;m_ddev_targp-&gt;pbr_bdev
)paren
op_logical_or
id|bdev_read_only
c_func
(paren
id|mp-&gt;m_logdev_targp-&gt;pbr_bdev
)paren
op_logical_or
(paren
id|mp-&gt;m_rtdev_targp
op_logical_and
id|bdev_read_only
c_func
(paren
id|mp-&gt;m_rtdev_targp-&gt;pbr_bdev
)paren
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;XFS: %s required on read-only device.&quot;
comma
id|message
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;XFS: write access unavailable, cannot proceed.&quot;
)paren
suffix:semicolon
r_return
id|EROFS
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
