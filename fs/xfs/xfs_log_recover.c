multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_imap.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_log_priv.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_log_recover.h&quot;
macro_line|#include &quot;xfs_extfree_item.h&quot;
macro_line|#include &quot;xfs_trans_priv.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
id|STATIC
r_int
id|xlog_find_zeroed
c_func
(paren
id|xlog_t
op_star
comma
id|xfs_daddr_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_clear_stale_blocks
c_func
(paren
id|xlog_t
op_star
comma
id|xfs_lsn_t
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_recover_insert_item_backq
c_func
(paren
id|xlog_recover_item_t
op_star
op_star
id|q
comma
id|xlog_recover_item_t
op_star
id|item
)paren
suffix:semicolon
macro_line|#if defined(DEBUG)
id|STATIC
r_void
id|xlog_recover_check_summary
c_func
(paren
id|xlog_t
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_recover_check_ail
c_func
(paren
id|xfs_mount_t
op_star
comma
id|xfs_log_item_t
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#else
DECL|macro|xlog_recover_check_summary
mdefine_line|#define&t;xlog_recover_check_summary(log)
DECL|macro|xlog_recover_check_ail
mdefine_line|#define&t;xlog_recover_check_ail(mp, lip, gen)
macro_line|#endif
multiline_comment|/*&n; * Sector aligned buffer routines for buffer create/read/write/access&n; */
DECL|macro|XLOG_SECTOR_ROUNDUP_BBCOUNT
mdefine_line|#define XLOG_SECTOR_ROUNDUP_BBCOUNT(log, bbs)&t;&bslash;&n;&t;( ((log)-&gt;l_sectbb_mask &amp;&amp; (bbs &amp; (log)-&gt;l_sectbb_mask)) ? &bslash;&n;&t;((bbs + (log)-&gt;l_sectbb_mask + 1) &amp; ~(log)-&gt;l_sectbb_mask) : (bbs) )
DECL|macro|XLOG_SECTOR_ROUNDDOWN_BLKNO
mdefine_line|#define XLOG_SECTOR_ROUNDDOWN_BLKNO(log, bno)&t;((bno) &amp; ~(log)-&gt;l_sectbb_mask)
id|xfs_buf_t
op_star
DECL|function|xlog_get_bp
id|xlog_get_bp
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|num_bblks
)paren
(brace
id|ASSERT
c_func
(paren
id|num_bblks
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_sectbb_log
)paren
(brace
r_if
c_cond
(paren
id|num_bblks
OG
l_int|1
)paren
id|num_bblks
op_add_assign
id|XLOG_SECTOR_ROUNDUP_BBCOUNT
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
id|num_bblks
op_assign
id|XLOG_SECTOR_ROUNDUP_BBCOUNT
c_func
(paren
id|log
comma
id|num_bblks
)paren
suffix:semicolon
)brace
r_return
id|xfs_buf_get_noaddr
c_func
(paren
id|BBTOB
c_func
(paren
id|num_bblks
)paren
comma
id|log-&gt;l_mp-&gt;m_logdev_targp
)paren
suffix:semicolon
)brace
r_void
DECL|function|xlog_put_bp
id|xlog_put_bp
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_buf_free
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * nbblks should be uint, but oh well.  Just want to catch that 32-bit length.&n; */
r_int
DECL|function|xlog_bread
id|xlog_bread
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|blk_no
comma
r_int
id|nbblks
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_sectbb_log
)paren
(brace
id|blk_no
op_assign
id|XLOG_SECTOR_ROUNDDOWN_BLKNO
c_func
(paren
id|log
comma
id|blk_no
)paren
suffix:semicolon
id|nbblks
op_assign
id|XLOG_SECTOR_ROUNDUP_BBCOUNT
c_func
(paren
id|log
comma
id|nbblks
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nbblks
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|BBTOB
c_func
(paren
id|nbblks
)paren
op_le
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SET_ADDR
c_func
(paren
id|bp
comma
id|log-&gt;l_logBBstart
op_plus
id|blk_no
)paren
suffix:semicolon
id|XFS_BUF_READ
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_BUSY
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_SET_COUNT
c_func
(paren
id|bp
comma
id|BBTOB
c_func
(paren
id|nbblks
)paren
)paren
suffix:semicolon
id|XFS_BUF_SET_TARGET
c_func
(paren
id|bp
comma
id|log-&gt;l_mp-&gt;m_logdev_targp
)paren
suffix:semicolon
id|xfsbdstrat
c_func
(paren
id|log-&gt;l_mp
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iowait
c_func
(paren
id|bp
)paren
)paren
)paren
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_bread&quot;
comma
id|log-&gt;l_mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Write out the buffer at the given block for the given number of blocks.&n; * The buffer is kept locked across the write and is returned locked.&n; * This can only be used for synchronous log writes.&n; */
r_int
DECL|function|xlog_bwrite
id|xlog_bwrite
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|blk_no
comma
r_int
id|nbblks
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_sectbb_log
)paren
(brace
id|blk_no
op_assign
id|XLOG_SECTOR_ROUNDDOWN_BLKNO
c_func
(paren
id|log
comma
id|blk_no
)paren
suffix:semicolon
id|nbblks
op_assign
id|XLOG_SECTOR_ROUNDUP_BBCOUNT
c_func
(paren
id|log
comma
id|nbblks
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nbblks
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|BBTOB
c_func
(paren
id|nbblks
)paren
op_le
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|XFS_BUF_SET_ADDR
c_func
(paren
id|bp
comma
id|log-&gt;l_logBBstart
op_plus
id|blk_no
)paren
suffix:semicolon
id|XFS_BUF_ZEROFLAGS
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_BUSY
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_HOLD
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_PSEMA
c_func
(paren
id|bp
comma
id|PRIBIO
)paren
suffix:semicolon
id|XFS_BUF_SET_COUNT
c_func
(paren
id|bp
comma
id|BBTOB
c_func
(paren
id|nbblks
)paren
)paren
suffix:semicolon
id|XFS_BUF_SET_TARGET
c_func
(paren
id|bp
comma
id|log-&gt;l_mp-&gt;m_logdev_targp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|log-&gt;l_mp
comma
id|bp
)paren
)paren
)paren
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_bwrite&quot;
comma
id|log-&gt;l_mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_caddr_t
DECL|function|xlog_align
id|xlog_align
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|blk_no
comma
r_int
id|nbblks
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_caddr_t
id|ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|log-&gt;l_sectbb_log
)paren
r_return
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ptr
op_assign
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
op_plus
id|BBTOB
c_func
(paren
(paren
r_int
)paren
id|blk_no
op_amp
id|log-&gt;l_sectbb_mask
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
op_ge
id|BBTOB
c_func
(paren
id|nbblks
op_plus
(paren
id|blk_no
op_amp
id|log-&gt;l_sectbb_mask
)paren
)paren
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * dump debug superblock and log record information&n; */
id|STATIC
r_void
DECL|function|xlog_header_check_dump
id|xlog_header_check_dump
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_rec_header_t
op_star
id|head
)paren
(brace
r_int
id|b
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s:  SB : uuid = &quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|16
suffix:semicolon
id|b
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|mp-&gt;m_sb.sb_uuid
)paren
(braket
id|b
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, fmt = %d&bslash;n&quot;
comma
id|XLOG_FMT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    log : uuid = &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
l_int|0
suffix:semicolon
id|b
OL
l_int|16
suffix:semicolon
id|b
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|head-&gt;h_fs_uuid
)paren
(braket
id|b
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, fmt = %d&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|head-&gt;h_fmt
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|xlog_header_check_dump
mdefine_line|#define xlog_header_check_dump(mp, head)
macro_line|#endif
multiline_comment|/*&n; * check log record header for recovery&n; */
id|STATIC
r_int
DECL|function|xlog_header_check_recover
id|xlog_header_check_recover
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_rec_header_t
op_star
id|head
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|head-&gt;h_magicno
comma
id|ARCH_CONVERT
)paren
op_eq
id|XLOG_HEADER_MAGIC_NUM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * IRIX doesn&squot;t write the h_fmt field and leaves it zeroed&n;&t; * (XLOG_FMT_UNKNOWN). This stops us from trying to recover&n;&t; * a dirty log created in IRIX.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|head-&gt;h_fmt
comma
id|ARCH_CONVERT
)paren
op_ne
id|XLOG_FMT
)paren
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: dirty log written in incompatible format - can&squot;t recover&quot;
)paren
suffix:semicolon
id|xlog_header_check_dump
c_func
(paren
id|mp
comma
id|head
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_header_check_recover(1)&quot;
comma
id|XFS_ERRLEVEL_HIGH
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|uuid_equal
c_func
(paren
op_amp
id|mp-&gt;m_sb.sb_uuid
comma
op_amp
id|head-&gt;h_fs_uuid
)paren
)paren
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: dirty log entry has mismatched uuid - can&squot;t recover&quot;
)paren
suffix:semicolon
id|xlog_header_check_dump
c_func
(paren
id|mp
comma
id|head
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_header_check_recover(2)&quot;
comma
id|XFS_ERRLEVEL_HIGH
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * read the head block of the log and check the header&n; */
id|STATIC
r_int
DECL|function|xlog_header_check_mount
id|xlog_header_check_mount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_rec_header_t
op_star
id|head
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|head-&gt;h_magicno
comma
id|ARCH_CONVERT
)paren
op_eq
id|XLOG_HEADER_MAGIC_NUM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uuid_is_nil
c_func
(paren
op_amp
id|head-&gt;h_fs_uuid
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * IRIX doesn&squot;t write the h_fs_uuid or h_fmt fields. If&n;&t;&t; * h_fs_uuid is nil, we assume this log was last mounted&n;&t;&t; * by IRIX and continue.&n;&t;&t; */
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: nil uuid in log - IRIX style log&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|uuid_equal
c_func
(paren
op_amp
id|mp-&gt;m_sb.sb_uuid
comma
op_amp
id|head-&gt;h_fs_uuid
)paren
)paren
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: log has mismatched uuid - can&squot;t recover&quot;
)paren
suffix:semicolon
id|xlog_header_check_dump
c_func
(paren
id|mp
comma
id|head
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_header_check_mount&quot;
comma
id|XFS_ERRLEVEL_HIGH
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xlog_recover_iodone
id|xlog_recover_iodone
c_func
(paren
r_struct
id|xfs_buf
op_star
id|bp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re not going to bother about retrying&n;&t;&t; * this during recovery. One strike!&n;&t;&t; */
id|mp
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
suffix:semicolon
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_iodone&quot;
comma
id|mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_METADATA_IO_ERROR
)paren
suffix:semicolon
)brace
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
l_int|NULL
)paren
suffix:semicolon
id|XFS_BUF_CLR_IODONE_FUNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_biodone
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine finds (to an approximation) the first block in the physical&n; * log which contains the given cycle.  It uses a binary search algorithm.&n; * Note that the algorithm can not be perfect because the disk will not&n; * necessarily be perfect.&n; */
r_int
DECL|function|xlog_find_cycle_start
id|xlog_find_cycle_start
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_daddr_t
id|first_blk
comma
id|xfs_daddr_t
op_star
id|last_blk
comma
id|uint
id|cycle
)paren
(brace
id|xfs_caddr_t
id|offset
suffix:semicolon
id|xfs_daddr_t
id|mid_blk
suffix:semicolon
id|uint
id|mid_cycle
suffix:semicolon
r_int
id|error
suffix:semicolon
id|mid_blk
op_assign
id|BLK_AVG
c_func
(paren
id|first_blk
comma
op_star
id|last_blk
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mid_blk
op_ne
id|first_blk
op_logical_and
id|mid_blk
op_ne
op_star
id|last_blk
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|mid_blk
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|mid_blk
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
id|mid_cycle
op_assign
id|GET_CYCLE
c_func
(paren
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mid_cycle
op_eq
id|cycle
)paren
(brace
op_star
id|last_blk
op_assign
id|mid_blk
suffix:semicolon
multiline_comment|/* last_half_cycle == mid_cycle */
)brace
r_else
(brace
id|first_blk
op_assign
id|mid_blk
suffix:semicolon
multiline_comment|/* first_half_cycle == mid_cycle */
)brace
id|mid_blk
op_assign
id|BLK_AVG
c_func
(paren
id|first_blk
comma
op_star
id|last_blk
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|mid_blk
op_eq
id|first_blk
op_logical_and
id|mid_blk
op_plus
l_int|1
op_eq
op_star
id|last_blk
)paren
op_logical_or
(paren
id|mid_blk
op_eq
op_star
id|last_blk
op_logical_and
id|mid_blk
op_minus
l_int|1
op_eq
id|first_blk
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check that the range of blocks does not contain the cycle number&n; * given.  The scan needs to occur from front to back and the ptr into the&n; * region must be updated since a later routine will need to perform another&n; * test.  If the region is completely good, we end up returning the same&n; * last block number.&n; *&n; * Set blkno to -1 if we encounter no errors.  This is an invalid block number&n; * since we don&squot;t ever expect logs to get this large.&n; */
id|STATIC
r_int
DECL|function|xlog_find_verify_cycle
id|xlog_find_verify_cycle
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|start_blk
comma
r_int
id|nbblks
comma
id|uint
id|stop_on_cycle_no
comma
id|xfs_daddr_t
op_star
id|new_blk
)paren
(brace
id|xfs_daddr_t
id|i
comma
id|j
suffix:semicolon
id|uint
id|cycle
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_daddr_t
id|bufblks
suffix:semicolon
id|xfs_caddr_t
id|buf
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|bufblks
op_assign
l_int|1
op_lshift
id|ffs
c_func
(paren
id|nbblks
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
id|bufblks
)paren
)paren
)paren
(brace
multiline_comment|/* can&squot;t get enough memory to do everything in one big buffer */
id|bufblks
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bufblks
op_le
id|log-&gt;l_sectbb_log
)paren
r_return
id|ENOMEM
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|start_blk
suffix:semicolon
id|i
OL
id|start_blk
op_plus
id|nbblks
suffix:semicolon
id|i
op_add_assign
id|bufblks
)paren
(brace
r_int
id|bcount
suffix:semicolon
id|bcount
op_assign
id|min
c_func
(paren
id|bufblks
comma
(paren
id|start_blk
op_plus
id|nbblks
op_minus
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|i
comma
id|bcount
comma
id|bp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|buf
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|i
comma
id|bcount
comma
id|bp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|bcount
suffix:semicolon
id|j
op_increment
)paren
(brace
id|cycle
op_assign
id|GET_CYCLE
c_func
(paren
id|buf
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cycle
op_eq
id|stop_on_cycle_no
)paren
(brace
op_star
id|new_blk
op_assign
id|i
op_plus
id|j
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|buf
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
)brace
op_star
id|new_blk
op_assign
op_minus
l_int|1
suffix:semicolon
id|out
suffix:colon
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Potentially backup over partial log record write.&n; *&n; * In the typical case, last_blk is the number of the block directly after&n; * a good log record.  Therefore, we subtract one to get the block number&n; * of the last block in the given buffer.  extra_bblks contains the number&n; * of blocks we would have read on a previous read.  This happens when the&n; * last log record is split over the end of the physical log.&n; *&n; * extra_bblks is the number of blocks potentially verified on a previous&n; * call to this routine.&n; */
id|STATIC
r_int
DECL|function|xlog_find_verify_log_record
id|xlog_find_verify_log_record
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|start_blk
comma
id|xfs_daddr_t
op_star
id|last_blk
comma
r_int
id|extra_bblks
)paren
(brace
id|xfs_daddr_t
id|i
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_caddr_t
id|offset
op_assign
l_int|NULL
suffix:semicolon
id|xlog_rec_header_t
op_star
id|head
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|smallmem
op_assign
l_int|0
suffix:semicolon
r_int
id|num_blks
op_assign
op_star
id|last_blk
op_minus
id|start_blk
suffix:semicolon
r_int
id|xhdrs
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_blk
op_ne
l_int|0
op_logical_or
op_star
id|last_blk
op_ne
id|start_blk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
id|num_blks
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
l_int|1
)paren
)paren
)paren
r_return
id|ENOMEM
suffix:semicolon
id|smallmem
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|start_blk
comma
id|num_blks
comma
id|bp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|start_blk
comma
id|num_blks
comma
id|bp
)paren
suffix:semicolon
id|offset
op_add_assign
(paren
(paren
id|num_blks
op_minus
l_int|1
)paren
op_lshift
id|BBSHIFT
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
(paren
op_star
id|last_blk
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|start_blk
)paren
(brace
multiline_comment|/* valid log record not found */
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: Log inconsistent (didn&squot;t find previous header)&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smallmem
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
)brace
id|head
op_assign
(paren
id|xlog_rec_header_t
op_star
)paren
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|XLOG_HEADER_MAGIC_NUM
op_eq
id|INT_GET
c_func
(paren
id|head-&gt;h_magicno
comma
id|ARCH_CONVERT
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smallmem
)paren
id|offset
op_sub_assign
id|BBSIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We hit the beginning of the physical log &amp; still no header.  Return&n;&t; * to caller.  If caller can handle a return of -1, then this routine&n;&t; * will be called again for the end of the physical log.&n;&t; */
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
(brace
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have the final block of the good log (the first block&n;&t; * of the log record _before_ the head. So we check the uuid.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_header_check_mount
c_func
(paren
id|log-&gt;l_mp
comma
id|head
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * We may have found a log record header before we expected one.&n;&t; * last_blk will be the 1st block # with a given cycle #.  We may end&n;&t; * up reading an entire log record.  In this case, we don&squot;t want to&n;&t; * reset last_blk.  Only when last_blk points in the middle of a log&n;&t; * record do we update last_blk.&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
)paren
(brace
id|uint
id|h_size
op_assign
id|INT_GET
c_func
(paren
id|head-&gt;h_size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xhdrs
op_assign
id|h_size
op_div
id|XLOG_HEADER_CYCLE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|h_size
op_mod
id|XLOG_HEADER_CYCLE_SIZE
)paren
id|xhdrs
op_increment
suffix:semicolon
)brace
r_else
(brace
id|xhdrs
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|last_blk
op_minus
id|i
op_plus
id|extra_bblks
op_ne
id|BTOBB
c_func
(paren
id|INT_GET
c_func
(paren
id|head-&gt;h_len
comma
id|ARCH_CONVERT
)paren
)paren
op_plus
id|xhdrs
)paren
op_star
id|last_blk
op_assign
id|i
suffix:semicolon
id|out
suffix:colon
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Head is defined to be the point of the log where the next log write&n; * write could go.  This means that incomplete LR writes at the end are&n; * eliminated when calculating the head.  We aren&squot;t guaranteed that previous&n; * LR have complete transactions.  We only know that a cycle number of&n; * current cycle number -1 won&squot;t be present in the log if we start writing&n; * from our current block number.&n; *&n; * last_blk contains the block number of the first block with a given&n; * cycle number.&n; *&n; * Return: zero if normal, non-zero if error.&n; */
r_int
DECL|function|xlog_find_head
id|xlog_find_head
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
op_star
id|return_head_blk
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_caddr_t
id|offset
suffix:semicolon
id|xfs_daddr_t
id|new_blk
comma
id|first_blk
comma
id|start_blk
comma
id|last_blk
comma
id|head_blk
suffix:semicolon
r_int
id|num_scan_bblks
suffix:semicolon
id|uint
id|first_half_cycle
comma
id|last_half_cycle
suffix:semicolon
id|uint
id|stop_on_cycle
suffix:semicolon
r_int
id|error
comma
id|log_bbnum
op_assign
id|log-&gt;l_logBBsize
suffix:semicolon
multiline_comment|/* Is the end of the log device zeroed? */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_zeroed
c_func
(paren
id|log
comma
op_amp
id|first_blk
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
op_star
id|return_head_blk
op_assign
id|first_blk
suffix:semicolon
multiline_comment|/* Is the whole lot zeroed? */
r_if
c_cond
(paren
op_logical_neg
id|first_blk
)paren
(brace
multiline_comment|/* Linux XFS shouldn&squot;t generate totally zeroed logs -&n;&t;&t;&t; * mkfs etc write a dummy unmount record to a fresh&n;&t;&t;&t; * log so we can store the uuid in there&n;&t;&t;&t; */
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: totally zeroed log&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: empty log check failed&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|first_blk
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* get cycle # of 1st block */
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
l_int|0
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
l_int|0
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
id|first_half_cycle
op_assign
id|GET_CYCLE
c_func
(paren
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|last_blk
op_assign
id|head_blk
op_assign
id|log_bbnum
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* get cycle # of last block */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|last_blk
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|last_blk
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
id|last_half_cycle
op_assign
id|GET_CYCLE
c_func
(paren
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|last_half_cycle
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the 1st half cycle number is equal to the last half cycle number,&n;&t; * then the entire log is stamped with the same cycle number.  In this&n;&t; * case, head_blk can&squot;t be set to zero (which makes sense).  The below&n;&t; * math doesn&squot;t work out properly with head_blk equal to zero.  Instead,&n;&t; * we set it to log_bbnum which is an invalid block number, but this&n;&t; * value makes the math correct.  If head_blk doesn&squot;t changed through&n;&t; * all the tests below, *head_blk is set to zero at the very end rather&n;&t; * than log_bbnum.  In a sense, log_bbnum and zero are the same block&n;&t; * in a circular file.&n;&t; */
r_if
c_cond
(paren
id|first_half_cycle
op_eq
id|last_half_cycle
)paren
(brace
multiline_comment|/*&n;&t;&t; * In this case we believe that the entire log should have&n;&t;&t; * cycle number last_half_cycle.  We need to scan backwards&n;&t;&t; * from the end verifying that there are no holes still&n;&t;&t; * containing last_half_cycle - 1.  If we find such a hole,&n;&t;&t; * then the start of that hole will be the new head.  The&n;&t;&t; * simple case looks like&n;&t;&t; *        x | x ... | x - 1 | x&n;&t;&t; * Another case that fits this picture would be&n;&t;&t; *        x | x + 1 | x ... | x&n;&t;&t; * In this case the head really is somwhere at the end of the&n;&t;&t; * log, as one of the latest writes at the beginning was&n;&t;&t; * incomplete.&n;&t;&t; * One more case is&n;&t;&t; *        x | x + 1 | x ... | x - 1 | x&n;&t;&t; * This is really the combination of the above two cases, and&n;&t;&t; * the head has to end up at the start of the x-1 hole at the&n;&t;&t; * end of the log.&n;&t;&t; *&n;&t;&t; * In the 256k log case, we will read from the beginning to the&n;&t;&t; * end of the log and search for cycle numbers equal to x-1.&n;&t;&t; * We don&squot;t worry about the x+1 blocks that we encounter,&n;&t;&t; * because we know that they cannot be the head since the log&n;&t;&t; * started with x.&n;&t;&t; */
id|head_blk
op_assign
id|log_bbnum
suffix:semicolon
id|stop_on_cycle
op_assign
id|last_half_cycle
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * In this case we want to find the first block with cycle&n;&t;&t; * number matching last_half_cycle.  We expect the log to be&n;&t;&t; * some variation on&n;&t;&t; *        x + 1 ... | x ...&n;&t;&t; * The first block with cycle number x (last_half_cycle) will&n;&t;&t; * be where the new head belongs.  First we do a binary search&n;&t;&t; * for the first occurrence of last_half_cycle.  The binary&n;&t;&t; * search may not be totally accurate, so then we scan back&n;&t;&t; * from there looking for occurrences of last_half_cycle before&n;&t;&t; * us.  If that backwards scan wraps around the beginning of&n;&t;&t; * the log, then we look for occurrences of last_half_cycle - 1&n;&t;&t; * at the end of the log.  The cases we&squot;re looking for look&n;&t;&t; * like&n;&t;&t; *        x + 1 ... | x | x + 1 | x ...&n;&t;&t; *                               ^ binary search stopped here&n;&t;&t; * or&n;&t;&t; *        x + 1 ... | x ... | x - 1 | x&n;&t;&t; *        &lt;---------&gt; less than scan distance&n;&t;&t; */
id|stop_on_cycle
op_assign
id|last_half_cycle
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_cycle_start
c_func
(paren
id|log
comma
id|bp
comma
id|first_blk
comma
op_amp
id|head_blk
comma
id|last_half_cycle
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now validate the answer.  Scan back some number of maximum possible&n;&t; * blocks and make sure each one has the expected cycle number.  The&n;&t; * maximum is determined by the total possible amount of buffering&n;&t; * in the in-core log.  The following number can be made tighter if&n;&t; * we actually look at the block size of the filesystem.&n;&t; */
id|num_scan_bblks
op_assign
id|XLOG_TOTAL_REC_SHIFT
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_blk
op_ge
id|num_scan_bblks
)paren
(brace
multiline_comment|/*&n;&t;&t; * We are guaranteed that the entire check can be performed&n;&t;&t; * in one buffer.&n;&t;&t; */
id|start_blk
op_assign
id|head_blk
op_minus
id|num_scan_bblks
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_cycle
c_func
(paren
id|log
comma
id|start_blk
comma
id|num_scan_bblks
comma
id|stop_on_cycle
comma
op_amp
id|new_blk
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
r_if
c_cond
(paren
id|new_blk
op_ne
op_minus
l_int|1
)paren
id|head_blk
op_assign
id|new_blk
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need to read 2 parts of log */
multiline_comment|/*&n;&t;&t; * We are going to scan backwards in the log in two parts.&n;&t;&t; * First we scan the physical end of the log.  In this part&n;&t;&t; * of the log, we are looking for blocks with cycle number&n;&t;&t; * last_half_cycle - 1.&n;&t;&t; * If we find one, then we know that the log starts there, as&n;&t;&t; * we&squot;ve found a hole that didn&squot;t get written in going around&n;&t;&t; * the end of the physical log.  The simple case for this is&n;&t;&t; *        x + 1 ... | x ... | x - 1 | x&n;&t;&t; *        &lt;---------&gt; less than scan distance&n;&t;&t; * If all of the blocks at the end of the log have cycle number&n;&t;&t; * last_half_cycle, then we check the blocks at the start of&n;&t;&t; * the log looking for occurrences of last_half_cycle.  If we&n;&t;&t; * find one, then our current estimate for the location of the&n;&t;&t; * first occurrence of last_half_cycle is wrong and we move&n;&t;&t; * back to the hole we&squot;ve found.  This case looks like&n;&t;&t; *        x + 1 ... | x | x + 1 | x ...&n;&t;&t; *                               ^ binary search stopped here&n;&t;&t; * Another case we need to handle that only occurs in 256k&n;&t;&t; * logs is&n;&t;&t; *        x + 1 ... | x ... | x+1 | x ...&n;&t;&t; *                   ^ binary search stops here&n;&t;&t; * In a 256k log, the scan at the end of the log will see the&n;&t;&t; * x + 1 blocks.  We need to skip past those since that is&n;&t;&t; * certainly not the head of the log.  By searching for&n;&t;&t; * last_half_cycle-1 we accomplish that.&n;&t;&t; */
id|start_blk
op_assign
id|log_bbnum
op_minus
id|num_scan_bblks
op_plus
id|head_blk
suffix:semicolon
id|ASSERT
c_func
(paren
id|head_blk
op_le
id|INT_MAX
op_logical_and
(paren
id|xfs_daddr_t
)paren
id|num_scan_bblks
op_minus
id|head_blk
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_cycle
c_func
(paren
id|log
comma
id|start_blk
comma
id|num_scan_bblks
op_minus
(paren
r_int
)paren
id|head_blk
comma
(paren
id|stop_on_cycle
op_minus
l_int|1
)paren
comma
op_amp
id|new_blk
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
r_if
c_cond
(paren
id|new_blk
op_ne
op_minus
l_int|1
)paren
(brace
id|head_blk
op_assign
id|new_blk
suffix:semicolon
r_goto
id|bad_blk
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Scan beginning of log now.  The last part of the physical&n;&t;&t; * log is good.  This scan needs to verify that it doesn&squot;t find&n;&t;&t; * the last_half_cycle.&n;&t;&t; */
id|start_blk
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|head_blk
op_le
id|INT_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_cycle
c_func
(paren
id|log
comma
id|start_blk
comma
(paren
r_int
)paren
id|head_blk
comma
id|stop_on_cycle
comma
op_amp
id|new_blk
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
r_if
c_cond
(paren
id|new_blk
op_ne
op_minus
l_int|1
)paren
id|head_blk
op_assign
id|new_blk
suffix:semicolon
)brace
id|bad_blk
suffix:colon
multiline_comment|/*&n;&t; * Now we need to make sure head_blk is not pointing to a block in&n;&t; * the middle of a log record.&n;&t; */
id|num_scan_bblks
op_assign
id|XLOG_REC_SHIFT
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_blk
op_ge
id|num_scan_bblks
)paren
(brace
id|start_blk
op_assign
id|head_blk
op_minus
id|num_scan_bblks
suffix:semicolon
multiline_comment|/* don&squot;t read head_blk */
multiline_comment|/* start ptr at last block ptr before head_blk */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_log_record
c_func
(paren
id|log
comma
id|start_blk
comma
op_amp
id|head_blk
comma
l_int|0
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_goto
id|bp_err
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bp_err
suffix:semicolon
)brace
r_else
(brace
id|start_blk
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|head_blk
op_le
id|INT_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_log_record
c_func
(paren
id|log
comma
id|start_blk
comma
op_amp
id|head_blk
comma
l_int|0
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* We hit the beginning of the log during our search */
id|start_blk
op_assign
id|log_bbnum
op_minus
id|num_scan_bblks
op_plus
id|head_blk
suffix:semicolon
id|new_blk
op_assign
id|log_bbnum
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_blk
op_le
id|INT_MAX
op_logical_and
(paren
id|xfs_daddr_t
)paren
id|log_bbnum
op_minus
id|start_blk
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|head_blk
op_le
id|INT_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_log_record
c_func
(paren
id|log
comma
id|start_blk
comma
op_amp
id|new_blk
comma
(paren
r_int
)paren
id|head_blk
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_goto
id|bp_err
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bp_err
suffix:semicolon
r_if
c_cond
(paren
id|new_blk
op_ne
id|log_bbnum
)paren
id|head_blk
op_assign
id|new_blk
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bp_err
suffix:semicolon
)brace
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head_blk
op_eq
id|log_bbnum
)paren
op_star
id|return_head_blk
op_assign
l_int|0
suffix:semicolon
r_else
op_star
id|return_head_blk
op_assign
id|head_blk
suffix:semicolon
multiline_comment|/*&n;&t; * When returning here, we have a good block number.  Bad block&n;&t; * means that during a previous crash, we didn&squot;t have a clean break&n;&t; * from cycle number N to cycle number N-1.  In this case, we need&n;&t; * to find the first block with cycle number N-1.&n;&t; */
r_return
l_int|0
suffix:semicolon
id|bp_err
suffix:colon
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: failed to find log head&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the sync block number or the tail of the log.&n; *&n; * This will be the block number of the last record to have its&n; * associated buffers synced to disk.  Every log record header has&n; * a sync lsn embedded in it.  LSNs hold block numbers, so it is easy&n; * to get a sync block number.  The only concern is to figure out which&n; * log record header to believe.&n; *&n; * The following algorithm uses the log record header with the largest&n; * lsn.  The entire log record does not need to be valid.  We only care&n; * that the header is valid.&n; *&n; * We could speed up search by using current head_blk buffer, but it is not&n; * available.&n; */
r_int
DECL|function|xlog_find_tail
id|xlog_find_tail
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
op_star
id|head_blk
comma
id|xfs_daddr_t
op_star
id|tail_blk
comma
r_int
id|readonly
)paren
(brace
id|xlog_rec_header_t
op_star
id|rhead
suffix:semicolon
id|xlog_op_header_t
op_star
id|op_head
suffix:semicolon
id|xfs_caddr_t
id|offset
op_assign
l_int|NULL
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
comma
id|i
comma
id|found
suffix:semicolon
id|xfs_daddr_t
id|umount_data_blk
suffix:semicolon
id|xfs_daddr_t
id|after_umount_blk
suffix:semicolon
id|xfs_lsn_t
id|tail_lsn
suffix:semicolon
r_int
id|hblks
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Find previous log record&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_head
c_func
(paren
id|log
comma
id|head_blk
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_star
id|head_blk
op_eq
l_int|0
)paren
(brace
multiline_comment|/* special case */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
l_int|0
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|bread_err
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
l_int|0
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GET_CYCLE
c_func
(paren
id|offset
comma
id|ARCH_CONVERT
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|tail_blk
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* leave all other log inited values alone */
r_goto
m_exit
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Search backwards looking for log record header block&n;&t; */
id|ASSERT
c_func
(paren
op_star
id|head_blk
OL
id|INT_MAX
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
r_int
)paren
(paren
op_star
id|head_blk
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|bread_err
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XLOG_HEADER_MAGIC_NUM
op_eq
id|INT_GET
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we haven&squot;t found the log record header block, start looking&n;&t; * again from the end of the physical log.  XXXmiken: There should be&n;&t; * a check here to make sure we didn&squot;t search more than N blocks in&n;&t; * the previous code.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|log-&gt;l_logBBsize
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
(paren
r_int
)paren
(paren
op_star
id|head_blk
)paren
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|bread_err
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XLOG_HEADER_MAGIC_NUM
op_eq
id|INT_GET
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|found
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_find_tail: couldn&squot;t find sync record&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* find blk_no of tail of log */
id|rhead
op_assign
(paren
id|xlog_rec_header_t
op_star
)paren
id|offset
suffix:semicolon
op_star
id|tail_blk
op_assign
id|BLOCK_LSN
c_func
(paren
id|rhead-&gt;h_tail_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset log values according to the state of the log when we&n;&t; * crashed.  In the case where head_blk == 0, we bump curr_cycle&n;&t; * one because the next write starts a new cycle rather than&n;&t; * continuing the cycle of the last good log record.  At this&n;&t; * point we have guaranteed that all partial log records have been&n;&t; * accounted for.  Therefore, we know that the last good log record&n;&t; * written was complete and ended exactly on the end boundary&n;&t; * of the physical log.&n;&t; */
id|log-&gt;l_prev_block
op_assign
id|i
suffix:semicolon
id|log-&gt;l_curr_block
op_assign
(paren
r_int
)paren
op_star
id|head_blk
suffix:semicolon
id|log-&gt;l_curr_cycle
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_cycle
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
op_eq
l_int|2
)paren
id|log-&gt;l_curr_cycle
op_increment
suffix:semicolon
id|log-&gt;l_tail_lsn
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_tail_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|log-&gt;l_last_sync_lsn
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|log-&gt;l_grant_reserve_cycle
op_assign
id|log-&gt;l_curr_cycle
suffix:semicolon
id|log-&gt;l_grant_reserve_bytes
op_assign
id|BBTOB
c_func
(paren
id|log-&gt;l_curr_block
)paren
suffix:semicolon
id|log-&gt;l_grant_write_cycle
op_assign
id|log-&gt;l_curr_cycle
suffix:semicolon
id|log-&gt;l_grant_write_bytes
op_assign
id|BBTOB
c_func
(paren
id|log-&gt;l_curr_block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look for unmount record.  If we find it, then we know there&n;&t; * was a clean unmount.  Since &squot;i&squot; could be the last block in&n;&t; * the physical log, we convert to a log block before comparing&n;&t; * to the head_blk.&n;&t; *&n;&t; * Save the current tail lsn to use to pass to&n;&t; * xlog_clear_stale_blocks() below.  We won&squot;t want to clear the&n;&t; * unmount record if there is one, so we pass the lsn of the&n;&t; * unmount record rather than the block after it.&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
)paren
(brace
r_int
id|h_size
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_int
id|h_version
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_version
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|h_version
op_amp
id|XLOG_VERSION_2
)paren
op_logical_and
(paren
id|h_size
OG
id|XLOG_HEADER_CYCLE_SIZE
)paren
)paren
(brace
id|hblks
op_assign
id|h_size
op_div
id|XLOG_HEADER_CYCLE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|h_size
op_mod
id|XLOG_HEADER_CYCLE_SIZE
)paren
id|hblks
op_increment
suffix:semicolon
)brace
r_else
(brace
id|hblks
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|hblks
op_assign
l_int|1
suffix:semicolon
)brace
id|after_umount_blk
op_assign
(paren
id|i
op_plus
id|hblks
op_plus
(paren
r_int
)paren
id|BTOBB
c_func
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
)paren
)paren
op_mod
id|log-&gt;l_logBBsize
suffix:semicolon
id|tail_lsn
op_assign
id|log-&gt;l_tail_lsn
suffix:semicolon
r_if
c_cond
(paren
op_star
id|head_blk
op_eq
id|after_umount_blk
op_logical_and
id|INT_GET
c_func
(paren
id|rhead-&gt;h_num_logops
comma
id|ARCH_CONVERT
)paren
op_eq
l_int|1
)paren
(brace
id|umount_data_blk
op_assign
(paren
id|i
op_plus
id|hblks
)paren
op_mod
id|log-&gt;l_logBBsize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|umount_data_blk
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
(brace
r_goto
id|bread_err
suffix:semicolon
)brace
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|umount_data_blk
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
id|op_head
op_assign
(paren
id|xlog_op_header_t
op_star
)paren
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|op_head-&gt;oh_flags
op_amp
id|XLOG_UNMOUNT_TRANS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Set tail and last sync so that newly written&n;&t;&t;&t; * log records will point recovery to after the&n;&t;&t;&t; * current unmount record.&n;&t;&t;&t; */
id|ASSIGN_ANY_LSN
c_func
(paren
id|log-&gt;l_tail_lsn
comma
id|log-&gt;l_curr_cycle
comma
id|after_umount_blk
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
id|ASSIGN_ANY_LSN
c_func
(paren
id|log-&gt;l_last_sync_lsn
comma
id|log-&gt;l_curr_cycle
comma
id|after_umount_blk
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
op_star
id|tail_blk
op_assign
id|after_umount_blk
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Make sure that there are no blocks in front of the head&n;&t; * with the same cycle number as the head.  This can happen&n;&t; * because we allow multiple outstanding log writes concurrently,&n;&t; * and the later writes might make it out before earlier ones.&n;&t; *&n;&t; * We use the lsn from before modifying it so that we&squot;ll never&n;&t; * overwrite the unmount record after a clean unmount.&n;&t; *&n;&t; * Do this only if we are going to recover the filesystem&n;&t; *&n;&t; * NOTE: This used to say &quot;if (!readonly)&quot;&n;&t; * However on Linux, we can &amp; do recover a read-only filesystem.&n;&t; * We only skip recovery if NORECOVERY is specified on mount,&n;&t; * in which case we would not be here.&n;&t; *&n;&t; * But... if the -device- itself is readonly, just skip this.&n;&t; * We can&squot;t recover this device anyway, so it won&squot;t matter.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_readonly_buftarg
c_func
(paren
id|log-&gt;l_mp-&gt;m_logdev_targp
)paren
)paren
(brace
id|error
op_assign
id|xlog_clear_stale_blocks
c_func
(paren
id|log
comma
id|tail_lsn
)paren
suffix:semicolon
)brace
id|bread_err
suffix:colon
m_exit
suffix:colon
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: failed to locate log tail&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Is the log zeroed at all?&n; *&n; * The last binary search should be changed to perform an X block read&n; * once X becomes small enough.  You can then search linearly through&n; * the X blocks.  This will cut down on the number of reads we need to do.&n; *&n; * If the log is partially zeroed, this routine will pass back the blkno&n; * of the first block with cycle number 0.  It won&squot;t have a complete LR&n; * preceding it.&n; *&n; * Return:&n; *&t;0  =&gt; the log is completely written to&n; *&t;-1 =&gt; use *blk_no as the first block of the log&n; *&t;&gt;0 =&gt; error has occurred&n; */
r_int
DECL|function|xlog_find_zeroed
id|xlog_find_zeroed
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
op_star
id|blk_no
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_caddr_t
id|offset
suffix:semicolon
id|uint
id|first_cycle
comma
id|last_cycle
suffix:semicolon
id|xfs_daddr_t
id|new_blk
comma
id|last_blk
comma
id|start_blk
suffix:semicolon
id|xfs_daddr_t
id|num_scan_bblks
suffix:semicolon
r_int
id|error
comma
id|log_bbnum
op_assign
id|log-&gt;l_logBBsize
suffix:semicolon
multiline_comment|/* check totally zeroed log */
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_return
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
l_int|0
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
l_int|0
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
id|first_cycle
op_assign
id|GET_CYCLE
c_func
(paren
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_cycle
op_eq
l_int|0
)paren
(brace
multiline_comment|/* completely zeroed log */
op_star
id|blk_no
op_assign
l_int|0
suffix:semicolon
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check partially zeroed log */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|log_bbnum
op_minus
l_int|1
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|log_bbnum
op_minus
l_int|1
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
id|last_cycle
op_assign
id|GET_CYCLE
c_func
(paren
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_cycle
op_ne
l_int|0
)paren
(brace
multiline_comment|/* log completely written to */
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|first_cycle
op_ne
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the cycle of the last block is zero, the cycle of&n;&t;&t; * the first block must be 1. If it&squot;s not, maybe we&squot;re&n;&t;&t; * not looking at a log... Bail out.&n;&t;&t; */
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: Log inconsistent or not a log (last==0, first!=1)&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* we have a partially zeroed log */
id|last_blk
op_assign
id|log_bbnum
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_cycle_start
c_func
(paren
id|log
comma
id|bp
comma
l_int|0
comma
op_amp
id|last_blk
comma
l_int|0
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
multiline_comment|/*&n;&t; * Validate the answer.  Because there is no way to guarantee that&n;&t; * the entire log is made up of log records which are the same size,&n;&t; * we scan over the defined maximum blocks.  At this point, the maximum&n;&t; * is not chosen to mean anything special.   XXXmiken&n;&t; */
id|num_scan_bblks
op_assign
id|XLOG_TOTAL_REC_SHIFT
c_func
(paren
id|log
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|num_scan_bblks
op_le
id|INT_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_blk
OL
id|num_scan_bblks
)paren
id|num_scan_bblks
op_assign
id|last_blk
suffix:semicolon
id|start_blk
op_assign
id|last_blk
op_minus
id|num_scan_bblks
suffix:semicolon
multiline_comment|/*&n;&t; * We search for any instances of cycle number 0 that occur before&n;&t; * our current estimate of the head.  What we&squot;re trying to detect is&n;&t; *        1 ... | 0 | 1 | 0...&n;&t; *                       ^ binary search ends here&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_cycle
c_func
(paren
id|log
comma
id|start_blk
comma
(paren
r_int
)paren
id|num_scan_bblks
comma
l_int|0
comma
op_amp
id|new_blk
)paren
)paren
)paren
r_goto
id|bp_err
suffix:semicolon
r_if
c_cond
(paren
id|new_blk
op_ne
op_minus
l_int|1
)paren
id|last_blk
op_assign
id|new_blk
suffix:semicolon
multiline_comment|/*&n;&t; * Potentially backup over partial log record write.  We don&squot;t need&n;&t; * to search the end of the log because we know it is zero.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_verify_log_record
c_func
(paren
id|log
comma
id|start_blk
comma
op_amp
id|last_blk
comma
l_int|0
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_goto
id|bp_err
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bp_err
suffix:semicolon
op_star
id|blk_no
op_assign
id|last_blk
suffix:semicolon
id|bp_err
suffix:colon
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * These are simple subroutines used by xlog_clear_stale_blocks() below&n; * to initialize a buffer full of empty log record headers and write&n; * them into the log.&n; */
id|STATIC
r_void
DECL|function|xlog_add_record
id|xlog_add_record
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_caddr_t
id|buf
comma
r_int
id|cycle
comma
r_int
id|block
comma
r_int
id|tail_cycle
comma
r_int
id|tail_block
)paren
(brace
id|xlog_rec_header_t
op_star
id|recp
op_assign
(paren
id|xlog_rec_header_t
op_star
)paren
id|buf
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0
comma
id|BBSIZE
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|recp-&gt;h_magicno
comma
id|ARCH_CONVERT
comma
id|XLOG_HEADER_MAGIC_NUM
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|recp-&gt;h_cycle
comma
id|ARCH_CONVERT
comma
id|cycle
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|recp-&gt;h_version
comma
id|ARCH_CONVERT
comma
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
suffix:semicolon
id|ASSIGN_ANY_LSN
c_func
(paren
id|recp-&gt;h_lsn
comma
id|cycle
comma
id|block
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSIGN_ANY_LSN
c_func
(paren
id|recp-&gt;h_tail_lsn
comma
id|tail_cycle
comma
id|tail_block
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|recp-&gt;h_fmt
comma
id|ARCH_CONVERT
comma
id|XLOG_FMT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|recp-&gt;h_fs_uuid
comma
op_amp
id|log-&gt;l_mp-&gt;m_sb.sb_uuid
comma
r_sizeof
(paren
id|uuid_t
)paren
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_write_log_records
id|xlog_write_log_records
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|cycle
comma
r_int
id|start_block
comma
r_int
id|blocks
comma
r_int
id|tail_cycle
comma
r_int
id|tail_block
)paren
(brace
id|xfs_caddr_t
id|offset
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|balign
comma
id|ealign
suffix:semicolon
r_int
id|sectbb
op_assign
id|XLOG_SECTOR_ROUNDUP_BBCOUNT
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
r_int
id|end_block
op_assign
id|start_block
op_plus
id|blocks
suffix:semicolon
r_int
id|bufblks
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|bufblks
op_assign
l_int|1
op_lshift
id|ffs
c_func
(paren
id|blocks
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
id|bufblks
)paren
)paren
)paren
(brace
id|bufblks
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bufblks
op_le
id|log-&gt;l_sectbb_log
)paren
r_return
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* We may need to do a read at the start to fill in part of&n;&t; * the buffer in the starting sector not covered by the first&n;&t; * write below.&n;&t; */
id|balign
op_assign
id|XLOG_SECTOR_ROUNDDOWN_BLKNO
c_func
(paren
id|log
comma
id|start_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|balign
op_ne
id|start_block
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|start_block
comma
l_int|1
comma
id|bp
)paren
)paren
)paren
(brace
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|j
op_assign
id|start_block
op_minus
id|balign
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|start_block
suffix:semicolon
id|i
OL
id|end_block
suffix:semicolon
id|i
op_add_assign
id|bufblks
)paren
(brace
r_int
id|bcount
comma
id|endcount
suffix:semicolon
id|bcount
op_assign
id|min
c_func
(paren
id|bufblks
comma
id|end_block
op_minus
id|start_block
)paren
suffix:semicolon
id|endcount
op_assign
id|bcount
op_minus
id|j
suffix:semicolon
multiline_comment|/* We may need to do a read at the end to fill in part of&n;&t;&t; * the buffer in the final sector not covered by the write.&n;&t;&t; * If this is the same sector as the above read, skip it.&n;&t;&t; */
id|ealign
op_assign
id|XLOG_SECTOR_ROUNDDOWN_BLKNO
c_func
(paren
id|log
comma
id|end_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|0
op_logical_and
(paren
id|start_block
op_plus
id|endcount
OG
id|ealign
)paren
)paren
(brace
id|offset
op_assign
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|balign
op_assign
id|BBTOB
c_func
(paren
id|ealign
op_minus
id|start_block
)paren
suffix:semicolon
id|XFS_BUF_SET_PTR
c_func
(paren
id|bp
comma
id|offset
op_plus
id|balign
comma
id|BBTOB
c_func
(paren
id|sectbb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|ealign
comma
id|sectbb
comma
id|bp
)paren
)paren
)paren
r_break
suffix:semicolon
id|XFS_BUF_SET_PTR
c_func
(paren
id|bp
comma
id|offset
comma
id|bufblks
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|start_block
comma
id|endcount
comma
id|bp
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|j
OL
id|endcount
suffix:semicolon
id|j
op_increment
)paren
(brace
id|xlog_add_record
c_func
(paren
id|log
comma
id|offset
comma
id|cycle
comma
id|i
op_plus
id|j
comma
id|tail_cycle
comma
id|tail_block
)paren
suffix:semicolon
id|offset
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
id|error
op_assign
id|xlog_bwrite
c_func
(paren
id|log
comma
id|start_block
comma
id|endcount
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_break
suffix:semicolon
id|start_block
op_add_assign
id|endcount
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
)brace
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to blow away any incomplete log writes out&n; * in front of the log head.  We do this so that we won&squot;t become confused&n; * if we come up, write only a little bit more, and then crash again.&n; * If we leave the partial log records out there, this situation could&n; * cause us to think those partial writes are valid blocks since they&n; * have the current cycle number.  We get rid of them by overwriting them&n; * with empty log records with the old cycle number rather than the&n; * current one.&n; *&n; * The tail lsn is passed in rather than taken from&n; * the log so that we will not write over the unmount record after a&n; * clean unmount in a 512 block log.  Doing so would leave the log without&n; * any valid log records in it until a new one was written.  If we crashed&n; * during that time we would not be able to recover.&n; */
id|STATIC
r_int
DECL|function|xlog_clear_stale_blocks
id|xlog_clear_stale_blocks
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_lsn_t
id|tail_lsn
)paren
(brace
r_int
id|tail_cycle
comma
id|head_cycle
suffix:semicolon
r_int
id|tail_block
comma
id|head_block
suffix:semicolon
r_int
id|tail_distance
comma
id|max_distance
suffix:semicolon
r_int
id|distance
suffix:semicolon
r_int
id|error
suffix:semicolon
id|tail_cycle
op_assign
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
id|tail_block
op_assign
id|BLOCK_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
id|head_cycle
op_assign
id|log-&gt;l_curr_cycle
suffix:semicolon
id|head_block
op_assign
id|log-&gt;l_curr_block
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out the distance between the new head of the log&n;&t; * and the tail.  We want to write over any blocks beyond the&n;&t; * head that we may have written just before the crash, but&n;&t; * we don&squot;t want to overwrite the tail of the log.&n;&t; */
r_if
c_cond
(paren
id|head_cycle
op_eq
id|tail_cycle
)paren
(brace
multiline_comment|/*&n;&t;&t; * The tail is behind the head in the physical log,&n;&t;&t; * so the distance from the head to the tail is the&n;&t;&t; * distance from the head to the end of the log plus&n;&t;&t; * the distance from the beginning of the log to the&n;&t;&t; * tail.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|head_block
OL
id|tail_block
op_logical_or
id|head_block
op_ge
id|log-&gt;l_logBBsize
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_clear_stale_blocks(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|log-&gt;l_mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|tail_distance
op_assign
id|tail_block
op_plus
(paren
id|log-&gt;l_logBBsize
op_minus
id|head_block
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The head is behind the tail in the physical log,&n;&t;&t; * so the distance from the head to the tail is just&n;&t;&t; * the tail block minus the head block.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|head_block
op_ge
id|tail_block
op_logical_or
id|head_cycle
op_ne
(paren
id|tail_cycle
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_clear_stale_blocks(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|log-&gt;l_mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|tail_distance
op_assign
id|tail_block
op_minus
id|head_block
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the head is right up against the tail, we can&squot;t clear&n;&t; * anything.&n;&t; */
r_if
c_cond
(paren
id|tail_distance
op_le
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|tail_distance
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|max_distance
op_assign
id|XLOG_TOTAL_REC_SHIFT
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Take the smaller of the maximum amount of outstanding I/O&n;&t; * we could have and the distance to the tail to clear out.&n;&t; * We take the smaller so that we don&squot;t overwrite the tail and&n;&t; * we don&squot;t waste all day writing from the head to the tail&n;&t; * for no reason.&n;&t; */
id|max_distance
op_assign
id|MIN
c_func
(paren
id|max_distance
comma
id|tail_distance
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|head_block
op_plus
id|max_distance
)paren
op_le
id|log-&gt;l_logBBsize
)paren
(brace
multiline_comment|/*&n;&t;&t; * We can stomp all the blocks we need to without&n;&t;&t; * wrapping around the end of the log.  Just do it&n;&t;&t; * in a single write.  Use the cycle number of the&n;&t;&t; * current cycle minus one so that the log will look like:&n;&t;&t; *     n ... | n - 1 ...&n;&t;&t; */
id|error
op_assign
id|xlog_write_log_records
c_func
(paren
id|log
comma
(paren
id|head_cycle
op_minus
l_int|1
)paren
comma
id|head_block
comma
id|max_distance
comma
id|tail_cycle
comma
id|tail_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We need to wrap around the end of the physical log in&n;&t;&t; * order to clear all the blocks.  Do it in two separate&n;&t;&t; * I/Os.  The first write should be from the head to the&n;&t;&t; * end of the physical log, and it should use the current&n;&t;&t; * cycle number minus one just like above.&n;&t;&t; */
id|distance
op_assign
id|log-&gt;l_logBBsize
op_minus
id|head_block
suffix:semicolon
id|error
op_assign
id|xlog_write_log_records
c_func
(paren
id|log
comma
(paren
id|head_cycle
op_minus
l_int|1
)paren
comma
id|head_block
comma
id|distance
comma
id|tail_cycle
comma
id|tail_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now write the blocks at the start of the physical log.&n;&t;&t; * This writes the remainder of the blocks we want to clear.&n;&t;&t; * It uses the current cycle number since we&squot;re now on the&n;&t;&t; * same cycle as the head so that we get:&n;&t;&t; *    n ... n ... | n - 1 ...&n;&t;&t; *    ^^^^^ blocks we&squot;re writing&n;&t;&t; */
id|distance
op_assign
id|max_distance
op_minus
(paren
id|log-&gt;l_logBBsize
op_minus
id|head_block
)paren
suffix:semicolon
id|error
op_assign
id|xlog_write_log_records
c_func
(paren
id|log
comma
id|head_cycle
comma
l_int|0
comma
id|distance
comma
id|tail_cycle
comma
id|tail_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; *&t;&t;Log recover routines&n; *&n; ******************************************************************************&n; */
id|STATIC
id|xlog_recover_t
op_star
DECL|function|xlog_recover_find_tid
id|xlog_recover_find_tid
c_func
(paren
id|xlog_recover_t
op_star
id|q
comma
id|xlog_tid_t
id|tid
)paren
(brace
id|xlog_recover_t
op_star
id|p
op_assign
id|q
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;r_log_tid
op_eq
id|tid
)paren
r_break
suffix:semicolon
id|p
op_assign
id|p-&gt;r_next
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xlog_recover_put_hashq
id|xlog_recover_put_hashq
c_func
(paren
id|xlog_recover_t
op_star
op_star
id|q
comma
id|xlog_recover_t
op_star
id|trans
)paren
(brace
id|trans-&gt;r_next
op_assign
op_star
id|q
suffix:semicolon
op_star
id|q
op_assign
id|trans
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xlog_recover_add_item
id|xlog_recover_add_item
c_func
(paren
id|xlog_recover_item_t
op_star
op_star
id|itemq
)paren
(brace
id|xlog_recover_item_t
op_star
id|item
suffix:semicolon
id|item
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xlog_recover_item_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|xlog_recover_insert_item_backq
c_func
(paren
id|itemq
comma
id|item
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_recover_add_to_cont_trans
id|xlog_recover_add_to_cont_trans
c_func
(paren
id|xlog_recover_t
op_star
id|trans
comma
id|xfs_caddr_t
id|dp
comma
r_int
id|len
)paren
(brace
id|xlog_recover_item_t
op_star
id|item
suffix:semicolon
id|xfs_caddr_t
id|ptr
comma
id|old_ptr
suffix:semicolon
r_int
id|old_len
suffix:semicolon
id|item
op_assign
id|trans-&gt;r_itemq
suffix:semicolon
r_if
c_cond
(paren
id|item
op_eq
l_int|0
)paren
(brace
multiline_comment|/* finish copying rest of trans header */
id|xlog_recover_add_item
c_func
(paren
op_amp
id|trans-&gt;r_itemq
)paren
suffix:semicolon
id|ptr
op_assign
(paren
id|xfs_caddr_t
)paren
op_amp
id|trans-&gt;r_theader
op_plus
r_sizeof
(paren
id|xfs_trans_header_t
)paren
op_minus
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|dp
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* d, s, l */
r_return
l_int|0
suffix:semicolon
)brace
id|item
op_assign
id|item-&gt;ri_prev
suffix:semicolon
id|old_ptr
op_assign
id|item-&gt;ri_buf
(braket
id|item-&gt;ri_cnt
op_minus
l_int|1
)braket
dot
id|i_addr
suffix:semicolon
id|old_len
op_assign
id|item-&gt;ri_buf
(braket
id|item-&gt;ri_cnt
op_minus
l_int|1
)braket
dot
id|i_len
suffix:semicolon
id|ptr
op_assign
id|kmem_realloc
c_func
(paren
id|old_ptr
comma
id|len
op_plus
id|old_len
comma
id|old_len
comma
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ptr
(braket
id|old_len
)braket
comma
id|dp
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* d, s, l */
id|item-&gt;ri_buf
(braket
id|item-&gt;ri_cnt
op_minus
l_int|1
)braket
dot
id|i_len
op_add_assign
id|len
suffix:semicolon
id|item-&gt;ri_buf
(braket
id|item-&gt;ri_cnt
op_minus
l_int|1
)braket
dot
id|i_addr
op_assign
id|ptr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The next region to add is the start of a new region.  It could be&n; * a whole region or it could be the first part of a new region.  Because&n; * of this, the assumption here is that the type and size fields of all&n; * format structures fit into the first 32 bits of the structure.&n; *&n; * This works because all regions must be 32 bit aligned.  Therefore, we&n; * either have both fields or we have neither field.  In the case we have&n; * neither field, the data part of the region is zero length.  We only have&n; * a log_op_header and can throw away the header since a new one will appear&n; * later.  If we have at least 4 bytes, then we can determine how many regions&n; * will appear in the current log item.&n; */
id|STATIC
r_int
DECL|function|xlog_recover_add_to_trans
id|xlog_recover_add_to_trans
c_func
(paren
id|xlog_recover_t
op_star
id|trans
comma
id|xfs_caddr_t
id|dp
comma
r_int
id|len
)paren
(brace
id|xfs_inode_log_format_t
op_star
id|in_f
suffix:semicolon
multiline_comment|/* any will do */
id|xlog_recover_item_t
op_star
id|item
suffix:semicolon
id|xfs_caddr_t
id|ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
l_int|0
suffix:semicolon
id|item
op_assign
id|trans-&gt;r_itemq
suffix:semicolon
r_if
c_cond
(paren
id|item
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|dp
op_eq
id|XFS_TRANS_HEADER_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
r_sizeof
(paren
id|xfs_trans_header_t
)paren
)paren
id|xlog_recover_add_item
c_func
(paren
op_amp
id|trans-&gt;r_itemq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|trans-&gt;r_theader
comma
id|dp
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* d, s, l */
r_return
l_int|0
suffix:semicolon
)brace
id|ptr
op_assign
id|kmem_alloc
c_func
(paren
id|len
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptr
comma
id|dp
comma
id|len
)paren
suffix:semicolon
id|in_f
op_assign
(paren
id|xfs_inode_log_format_t
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;ri_prev-&gt;ri_total
op_ne
l_int|0
op_logical_and
id|item-&gt;ri_prev-&gt;ri_total
op_eq
id|item-&gt;ri_prev-&gt;ri_cnt
)paren
(brace
id|xlog_recover_add_item
c_func
(paren
op_amp
id|trans-&gt;r_itemq
)paren
suffix:semicolon
)brace
id|item
op_assign
id|trans-&gt;r_itemq
suffix:semicolon
id|item
op_assign
id|item-&gt;ri_prev
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;ri_total
op_eq
l_int|0
)paren
(brace
multiline_comment|/* first region to be added */
id|item-&gt;ri_total
op_assign
id|in_f-&gt;ilf_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|item-&gt;ri_total
op_le
id|XLOG_MAX_REGIONS_IN_ITEM
)paren
suffix:semicolon
id|item-&gt;ri_buf
op_assign
id|kmem_zalloc
c_func
(paren
(paren
id|item-&gt;ri_total
op_star
r_sizeof
(paren
id|xfs_log_iovec_t
)paren
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|item-&gt;ri_total
OG
id|item-&gt;ri_cnt
)paren
suffix:semicolon
multiline_comment|/* Description region is ri_buf[0] */
id|item-&gt;ri_buf
(braket
id|item-&gt;ri_cnt
)braket
dot
id|i_addr
op_assign
id|ptr
suffix:semicolon
id|item-&gt;ri_buf
(braket
id|item-&gt;ri_cnt
)braket
dot
id|i_len
op_assign
id|len
suffix:semicolon
id|item-&gt;ri_cnt
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xlog_recover_new_tid
id|xlog_recover_new_tid
c_func
(paren
id|xlog_recover_t
op_star
op_star
id|q
comma
id|xlog_tid_t
id|tid
comma
id|xfs_lsn_t
id|lsn
)paren
(brace
id|xlog_recover_t
op_star
id|trans
suffix:semicolon
id|trans
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xlog_recover_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|trans-&gt;r_log_tid
op_assign
id|tid
suffix:semicolon
id|trans-&gt;r_lsn
op_assign
id|lsn
suffix:semicolon
id|xlog_recover_put_hashq
c_func
(paren
id|q
comma
id|trans
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_recover_unlink_tid
id|xlog_recover_unlink_tid
c_func
(paren
id|xlog_recover_t
op_star
op_star
id|q
comma
id|xlog_recover_t
op_star
id|trans
)paren
(brace
id|xlog_recover_t
op_star
id|tp
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|trans
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trans
op_eq
op_star
id|q
)paren
(brace
op_star
id|q
op_assign
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|r_next
suffix:semicolon
)brace
r_else
(brace
id|tp
op_assign
op_star
id|q
suffix:semicolon
r_while
c_loop
(paren
id|tp
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;r_next
op_eq
id|trans
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tp
op_assign
id|tp-&gt;r_next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_unlink_tid: trans not found&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|tp-&gt;r_next
op_assign
id|tp-&gt;r_next-&gt;r_next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xlog_recover_insert_item_backq
id|xlog_recover_insert_item_backq
c_func
(paren
id|xlog_recover_item_t
op_star
op_star
id|q
comma
id|xlog_recover_item_t
op_star
id|item
)paren
(brace
r_if
c_cond
(paren
op_star
id|q
op_eq
l_int|0
)paren
(brace
id|item-&gt;ri_prev
op_assign
id|item-&gt;ri_next
op_assign
id|item
suffix:semicolon
op_star
id|q
op_assign
id|item
suffix:semicolon
)brace
r_else
(brace
id|item-&gt;ri_next
op_assign
op_star
id|q
suffix:semicolon
id|item-&gt;ri_prev
op_assign
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|ri_prev
suffix:semicolon
(paren
op_star
id|q
)paren
op_member_access_from_pointer
id|ri_prev
op_assign
id|item
suffix:semicolon
id|item-&gt;ri_prev-&gt;ri_next
op_assign
id|item
suffix:semicolon
)brace
)brace
id|STATIC
r_void
DECL|function|xlog_recover_insert_item_frontq
id|xlog_recover_insert_item_frontq
c_func
(paren
id|xlog_recover_item_t
op_star
op_star
id|q
comma
id|xlog_recover_item_t
op_star
id|item
)paren
(brace
id|xlog_recover_insert_item_backq
c_func
(paren
id|q
comma
id|item
)paren
suffix:semicolon
op_star
id|q
op_assign
id|item
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_recover_reorder_trans
id|xlog_recover_reorder_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_t
op_star
id|trans
)paren
(brace
id|xlog_recover_item_t
op_star
id|first_item
comma
op_star
id|itemq
comma
op_star
id|itemq_next
suffix:semicolon
id|xfs_buf_log_format_t
op_star
id|buf_f
suffix:semicolon
id|xfs_buf_log_format_v1_t
op_star
id|obuf_f
suffix:semicolon
id|ushort
id|flags
op_assign
l_int|0
suffix:semicolon
id|first_item
op_assign
id|itemq
op_assign
id|trans-&gt;r_itemq
suffix:semicolon
id|trans-&gt;r_itemq
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
id|itemq_next
op_assign
id|itemq-&gt;ri_next
suffix:semicolon
id|buf_f
op_assign
(paren
id|xfs_buf_log_format_t
op_star
)paren
id|itemq-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_addr
suffix:semicolon
r_switch
c_cond
(paren
id|ITEM_TYPE
c_func
(paren
id|itemq
)paren
)paren
(brace
r_case
id|XFS_LI_BUF
suffix:colon
id|flags
op_assign
id|buf_f-&gt;blf_flags
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_LI_6_1_BUF
suffix:colon
r_case
id|XFS_LI_5_3_BUF
suffix:colon
id|obuf_f
op_assign
(paren
id|xfs_buf_log_format_v1_t
op_star
)paren
id|buf_f
suffix:semicolon
id|flags
op_assign
id|obuf_f-&gt;blf_flags
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ITEM_TYPE
c_func
(paren
id|itemq
)paren
)paren
(brace
r_case
id|XFS_LI_BUF
suffix:colon
r_case
id|XFS_LI_6_1_BUF
suffix:colon
r_case
id|XFS_LI_5_3_BUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
(brace
id|xlog_recover_insert_item_frontq
c_func
(paren
op_amp
id|trans-&gt;r_itemq
comma
id|itemq
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|XFS_LI_INODE
suffix:colon
r_case
id|XFS_LI_6_1_INODE
suffix:colon
r_case
id|XFS_LI_5_3_INODE
suffix:colon
r_case
id|XFS_LI_DQUOT
suffix:colon
r_case
id|XFS_LI_QUOTAOFF
suffix:colon
r_case
id|XFS_LI_EFD
suffix:colon
r_case
id|XFS_LI_EFI
suffix:colon
id|xlog_recover_insert_item_backq
c_func
(paren
op_amp
id|trans-&gt;r_itemq
comma
id|itemq
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_reorder_trans: unrecognized type of log operation&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|itemq
op_assign
id|itemq_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|first_item
op_ne
id|itemq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Build up the table of buf cancel records so that we don&squot;t replay&n; * cancelled data in the second pass.  For buffer records that are&n; * not cancel records, there is nothing to do here so we just return.&n; *&n; * If we get a cancel record which is already in the table, this indicates&n; * that the buffer was cancelled multiple times.  In order to ensure&n; * that during pass 2 we keep the record in the table until we reach its&n; * last occurrence in the log, we keep a reference count in the cancel&n; * record in the table to tell us how many times we expect to see this&n; * record during the second pass.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_do_buffer_pass1
id|xlog_recover_do_buffer_pass1
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_buf_log_format_t
op_star
id|buf_f
)paren
(brace
id|xfs_buf_cancel_t
op_star
id|bcp
suffix:semicolon
id|xfs_buf_cancel_t
op_star
id|nextp
suffix:semicolon
id|xfs_buf_cancel_t
op_star
id|prevp
suffix:semicolon
id|xfs_buf_cancel_t
op_star
op_star
id|bucket
suffix:semicolon
id|xfs_buf_log_format_v1_t
op_star
id|obuf_f
suffix:semicolon
id|xfs_daddr_t
id|blkno
op_assign
l_int|0
suffix:semicolon
id|uint
id|len
op_assign
l_int|0
suffix:semicolon
id|ushort
id|flags
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|buf_f-&gt;blf_type
)paren
(brace
r_case
id|XFS_LI_BUF
suffix:colon
id|blkno
op_assign
id|buf_f-&gt;blf_blkno
suffix:semicolon
id|len
op_assign
id|buf_f-&gt;blf_len
suffix:semicolon
id|flags
op_assign
id|buf_f-&gt;blf_flags
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_LI_6_1_BUF
suffix:colon
r_case
id|XFS_LI_5_3_BUF
suffix:colon
id|obuf_f
op_assign
(paren
id|xfs_buf_log_format_v1_t
op_star
)paren
id|buf_f
suffix:semicolon
id|blkno
op_assign
(paren
id|xfs_daddr_t
)paren
id|obuf_f-&gt;blf_blkno
suffix:semicolon
id|len
op_assign
id|obuf_f-&gt;blf_len
suffix:semicolon
id|flags
op_assign
id|obuf_f-&gt;blf_flags
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this isn&squot;t a cancel buffer item, then just return.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Insert an xfs_buf_cancel record into the hash table of&n;&t; * them.  If there is already an identical record, bump&n;&t; * its reference count.&n;&t; */
id|bucket
op_assign
op_amp
id|log-&gt;l_buf_cancel_table
(braket
(paren
id|__uint64_t
)paren
id|blkno
op_mod
id|XLOG_BC_TABLE_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * If the hash bucket is empty then just insert a new record into&n;&t; * the bucket.&n;&t; */
r_if
c_cond
(paren
op_star
id|bucket
op_eq
l_int|NULL
)paren
(brace
id|bcp
op_assign
(paren
id|xfs_buf_cancel_t
op_star
)paren
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
id|xfs_buf_cancel_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|bcp-&gt;bc_blkno
op_assign
id|blkno
suffix:semicolon
id|bcp-&gt;bc_len
op_assign
id|len
suffix:semicolon
id|bcp-&gt;bc_refcount
op_assign
l_int|1
suffix:semicolon
id|bcp-&gt;bc_next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|bucket
op_assign
id|bcp
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The hash bucket is not empty, so search for duplicates of our&n;&t; * record.  If we find one them just bump its refcount.  If not&n;&t; * then add us at the end of the list.&n;&t; */
id|prevp
op_assign
l_int|NULL
suffix:semicolon
id|nextp
op_assign
op_star
id|bucket
suffix:semicolon
r_while
c_loop
(paren
id|nextp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|nextp-&gt;bc_blkno
op_eq
id|blkno
op_logical_and
id|nextp-&gt;bc_len
op_eq
id|len
)paren
(brace
id|nextp-&gt;bc_refcount
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|prevp
op_assign
id|nextp
suffix:semicolon
id|nextp
op_assign
id|nextp-&gt;bc_next
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|prevp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bcp
op_assign
(paren
id|xfs_buf_cancel_t
op_star
)paren
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
id|xfs_buf_cancel_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|bcp-&gt;bc_blkno
op_assign
id|blkno
suffix:semicolon
id|bcp-&gt;bc_len
op_assign
id|len
suffix:semicolon
id|bcp-&gt;bc_refcount
op_assign
l_int|1
suffix:semicolon
id|bcp-&gt;bc_next
op_assign
l_int|NULL
suffix:semicolon
id|prevp-&gt;bc_next
op_assign
id|bcp
suffix:semicolon
)brace
multiline_comment|/*&n; * Check to see whether the buffer being recovered has a corresponding&n; * entry in the buffer cancel record table.  If it does then return 1&n; * so that it will be cancelled, otherwise return 0.  If the buffer is&n; * actually a buffer cancel item (XFS_BLI_CANCEL is set), then decrement&n; * the refcount on the entry in the table and remove it from the table&n; * if this is the last reference.&n; *&n; * We remove the cancel record from the table when we encounter its&n; * last occurrence in the log so that if the same buffer is re-used&n; * again after its last cancellation we actually replay the changes&n; * made at that point.&n; */
id|STATIC
r_int
DECL|function|xlog_check_buffer_cancelled
id|xlog_check_buffer_cancelled
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|blkno
comma
id|uint
id|len
comma
id|ushort
id|flags
)paren
(brace
id|xfs_buf_cancel_t
op_star
id|bcp
suffix:semicolon
id|xfs_buf_cancel_t
op_star
id|prevp
suffix:semicolon
id|xfs_buf_cancel_t
op_star
op_star
id|bucket
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_buf_cancel_table
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is nothing in the table built in pass one,&n;&t;&t; * so this buffer must not be cancelled.&n;&t;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bucket
op_assign
op_amp
id|log-&gt;l_buf_cancel_table
(braket
(paren
id|__uint64_t
)paren
id|blkno
op_mod
id|XLOG_BC_TABLE_SIZE
)braket
suffix:semicolon
id|bcp
op_assign
op_star
id|bucket
suffix:semicolon
r_if
c_cond
(paren
id|bcp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is no corresponding entry in the table built&n;&t;&t; * in pass one, so this buffer has not been cancelled.&n;&t;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Search for an entry in the buffer cancel table that&n;&t; * matches our buffer.&n;&t; */
id|prevp
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|bcp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|bcp-&gt;bc_blkno
op_eq
id|blkno
op_logical_and
id|bcp-&gt;bc_len
op_eq
id|len
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We&squot;ve go a match, so return 1 so that the&n;&t;&t;&t; * recovery of this buffer is cancelled.&n;&t;&t;&t; * If this buffer is actually a buffer cancel&n;&t;&t;&t; * log item, then decrement the refcount on the&n;&t;&t;&t; * one in the table and remove it if this is the&n;&t;&t;&t; * last reference.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_BLI_CANCEL
)paren
(brace
id|bcp-&gt;bc_refcount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bcp-&gt;bc_refcount
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|prevp
op_eq
l_int|NULL
)paren
(brace
op_star
id|bucket
op_assign
id|bcp-&gt;bc_next
suffix:semicolon
)brace
r_else
(brace
id|prevp-&gt;bc_next
op_assign
id|bcp-&gt;bc_next
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|bcp
comma
r_sizeof
(paren
id|xfs_buf_cancel_t
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|prevp
op_assign
id|bcp
suffix:semicolon
id|bcp
op_assign
id|bcp-&gt;bc_next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We didn&squot;t find a corresponding entry in the table, so&n;&t; * return 0 so that the buffer is NOT cancelled.&n;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_BLI_CANCEL
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_recover_do_buffer_pass2
id|xlog_recover_do_buffer_pass2
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_buf_log_format_t
op_star
id|buf_f
)paren
(brace
id|xfs_buf_log_format_v1_t
op_star
id|obuf_f
suffix:semicolon
id|xfs_daddr_t
id|blkno
op_assign
l_int|0
suffix:semicolon
id|ushort
id|flags
op_assign
l_int|0
suffix:semicolon
id|uint
id|len
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|buf_f-&gt;blf_type
)paren
(brace
r_case
id|XFS_LI_BUF
suffix:colon
id|blkno
op_assign
id|buf_f-&gt;blf_blkno
suffix:semicolon
id|flags
op_assign
id|buf_f-&gt;blf_flags
suffix:semicolon
id|len
op_assign
id|buf_f-&gt;blf_len
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_LI_6_1_BUF
suffix:colon
r_case
id|XFS_LI_5_3_BUF
suffix:colon
id|obuf_f
op_assign
(paren
id|xfs_buf_log_format_v1_t
op_star
)paren
id|buf_f
suffix:semicolon
id|blkno
op_assign
(paren
id|xfs_daddr_t
)paren
id|obuf_f-&gt;blf_blkno
suffix:semicolon
id|flags
op_assign
id|obuf_f-&gt;blf_flags
suffix:semicolon
id|len
op_assign
(paren
id|xfs_daddr_t
)paren
id|obuf_f-&gt;blf_len
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|xlog_check_buffer_cancelled
c_func
(paren
id|log
comma
id|blkno
comma
id|len
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform recovery for a buffer full of inodes.  In these buffers,&n; * the only data which should be recovered is that which corresponds&n; * to the di_next_unlinked pointers in the on disk inode structures.&n; * The rest of the data for the inodes is always logged through the&n; * inodes themselves rather than the inode buffer and is recovered&n; * in xlog_recover_do_inode_trans().&n; *&n; * The only time when buffers full of inodes are fully recovered is&n; * when the buffer is full of newly allocated inodes.  In this case&n; * the buffer will not be marked as an inode buffer and so will be&n; * sent to xlog_recover_do_reg_buffer() below during recovery.&n; */
id|STATIC
r_int
DECL|function|xlog_recover_do_inode_buffer
id|xlog_recover_do_inode_buffer
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_recover_item_t
op_star
id|item
comma
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_buf_log_format_t
op_star
id|buf_f
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|item_index
suffix:semicolon
r_int
id|bit
suffix:semicolon
r_int
id|nbits
suffix:semicolon
r_int
id|reg_buf_offset
suffix:semicolon
r_int
id|reg_buf_bytes
suffix:semicolon
r_int
id|next_unlinked_offset
suffix:semicolon
r_int
id|inodes_per_buf
suffix:semicolon
id|xfs_agino_t
op_star
id|logged_nextp
suffix:semicolon
id|xfs_agino_t
op_star
id|buffer_nextp
suffix:semicolon
id|xfs_buf_log_format_v1_t
op_star
id|obuf_f
suffix:semicolon
r_int
r_int
op_star
id|data_map
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|map_size
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|buf_f-&gt;blf_type
)paren
(brace
r_case
id|XFS_LI_BUF
suffix:colon
id|data_map
op_assign
id|buf_f-&gt;blf_data_map
suffix:semicolon
id|map_size
op_assign
id|buf_f-&gt;blf_map_size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_LI_6_1_BUF
suffix:colon
r_case
id|XFS_LI_5_3_BUF
suffix:colon
id|obuf_f
op_assign
(paren
id|xfs_buf_log_format_v1_t
op_star
)paren
id|buf_f
suffix:semicolon
id|data_map
op_assign
id|obuf_f-&gt;blf_data_map
suffix:semicolon
id|map_size
op_assign
id|obuf_f-&gt;blf_map_size
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set the variables corresponding to the current region to&n;&t; * 0 so that we&squot;ll initialize them on the first pass through&n;&t; * the loop.&n;&t; */
id|reg_buf_offset
op_assign
l_int|0
suffix:semicolon
id|reg_buf_bytes
op_assign
l_int|0
suffix:semicolon
id|bit
op_assign
l_int|0
suffix:semicolon
id|nbits
op_assign
l_int|0
suffix:semicolon
id|item_index
op_assign
l_int|0
suffix:semicolon
id|inodes_per_buf
op_assign
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_rshift
id|mp-&gt;m_sb.sb_inodelog
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inodes_per_buf
suffix:semicolon
id|i
op_increment
)paren
(brace
id|next_unlinked_offset
op_assign
(paren
id|i
op_star
id|mp-&gt;m_sb.sb_inodesize
)paren
op_plus
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_next_unlinked
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next_unlinked_offset
op_ge
(paren
id|reg_buf_offset
op_plus
id|reg_buf_bytes
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The next di_next_unlinked field is beyond&n;&t;&t;&t; * the current logged region.  Find the next&n;&t;&t;&t; * logged region that contains or is beyond&n;&t;&t;&t; * the current di_next_unlinked field.&n;&t;&t;&t; */
id|bit
op_add_assign
id|nbits
suffix:semicolon
id|bit
op_assign
id|xfs_next_bit
c_func
(paren
id|data_map
comma
id|map_size
comma
id|bit
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If there are no more logged regions in the&n;&t;&t;&t; * buffer, then we&squot;re done.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|bit
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|nbits
op_assign
id|xfs_contig_bits
c_func
(paren
id|data_map
comma
id|map_size
comma
id|bit
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nbits
OG
l_int|0
)paren
suffix:semicolon
id|reg_buf_offset
op_assign
id|bit
op_lshift
id|XFS_BLI_SHIFT
suffix:semicolon
id|reg_buf_bytes
op_assign
id|nbits
op_lshift
id|XFS_BLI_SHIFT
suffix:semicolon
id|item_index
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If the current logged region starts after the current&n;&t;&t; * di_next_unlinked field, then move on to the next&n;&t;&t; * di_next_unlinked field.&n;&t;&t; */
r_if
c_cond
(paren
id|next_unlinked_offset
OL
id|reg_buf_offset
)paren
(brace
r_continue
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|item-&gt;ri_buf
(braket
id|item_index
)braket
dot
id|i_addr
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|item-&gt;ri_buf
(braket
id|item_index
)braket
dot
id|i_len
op_mod
id|XFS_BLI_CHUNK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|reg_buf_offset
op_plus
id|reg_buf_bytes
)paren
op_le
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The current logged region contains a copy of the&n;&t;&t; * current di_next_unlinked field.  Extract its value&n;&t;&t; * and copy it to the buffer copy.&n;&t;&t; */
id|logged_nextp
op_assign
(paren
id|xfs_agino_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|item-&gt;ri_buf
(braket
id|item_index
)braket
dot
id|i_addr
)paren
op_plus
(paren
id|next_unlinked_offset
op_minus
id|reg_buf_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_star
id|logged_nextp
op_eq
l_int|0
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;bad inode buffer log record (ptr = 0x%p, bp = 0x%p).  XFS trying to replay bad (0) inode di_next_unlinked field&quot;
comma
id|item
comma
id|bp
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_recover_do_inode_buf&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|buffer_nextp
op_assign
(paren
id|xfs_agino_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|next_unlinked_offset
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|buffer_nextp
comma
id|ARCH_CONVERT
comma
op_star
id|logged_nextp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform a &squot;normal&squot; buffer recovery.  Each logged region of the&n; * buffer should be copied over the corresponding region in the&n; * given buffer.  The bitmap in the buf log format structure indicates&n; * where to place the logged data.&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_void
DECL|function|xlog_recover_do_reg_buffer
id|xlog_recover_do_reg_buffer
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_recover_item_t
op_star
id|item
comma
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_buf_log_format_t
op_star
id|buf_f
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|bit
suffix:semicolon
r_int
id|nbits
suffix:semicolon
id|xfs_buf_log_format_v1_t
op_star
id|obuf_f
suffix:semicolon
r_int
r_int
op_star
id|data_map
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|map_size
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_switch
c_cond
(paren
id|buf_f-&gt;blf_type
)paren
(brace
r_case
id|XFS_LI_BUF
suffix:colon
id|data_map
op_assign
id|buf_f-&gt;blf_data_map
suffix:semicolon
id|map_size
op_assign
id|buf_f-&gt;blf_map_size
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_LI_6_1_BUF
suffix:colon
r_case
id|XFS_LI_5_3_BUF
suffix:colon
id|obuf_f
op_assign
(paren
id|xfs_buf_log_format_v1_t
op_star
)paren
id|buf_f
suffix:semicolon
id|data_map
op_assign
id|obuf_f-&gt;blf_data_map
suffix:semicolon
id|map_size
op_assign
id|obuf_f-&gt;blf_map_size
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bit
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 0 is the buf format structure */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|bit
op_assign
id|xfs_next_bit
c_func
(paren
id|data_map
comma
id|map_size
comma
id|bit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
id|nbits
op_assign
id|xfs_contig_bits
c_func
(paren
id|data_map
comma
id|map_size
comma
id|bit
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nbits
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|item-&gt;ri_buf
(braket
id|i
)braket
dot
id|i_addr
op_ne
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|item-&gt;ri_buf
(braket
id|i
)braket
dot
id|i_len
op_mod
id|XFS_BLI_CHUNK
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_ge
(paren
(paren
id|uint
)paren
id|bit
op_lshift
id|XFS_BLI_SHIFT
)paren
op_plus
(paren
id|nbits
op_lshift
id|XFS_BLI_SHIFT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do a sanity check if this is a dquot buffer. Just checking&n;&t;&t; * the first dquot in the buffer should do. XXXThis is&n;&t;&t; * probably a good thing to do for other buf types also.&n;&t;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf_f-&gt;blf_flags
op_amp
(paren
id|XFS_BLI_UDQUOT_BUF
op_or
id|XFS_BLI_GDQUOT_BUF
)paren
)paren
(brace
id|error
op_assign
id|xfs_qm_dqcheck
c_func
(paren
(paren
id|xfs_disk_dquot_t
op_star
)paren
id|item-&gt;ri_buf
(braket
id|i
)braket
dot
id|i_addr
comma
op_minus
l_int|1
comma
l_int|0
comma
id|XFS_QMOPT_DOWARN
comma
l_string|&quot;dquot_buf_recover&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|memcpy
c_func
(paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
(paren
id|uint
)paren
id|bit
op_lshift
id|XFS_BLI_SHIFT
)paren
comma
multiline_comment|/* dest */
id|item-&gt;ri_buf
(braket
id|i
)braket
dot
id|i_addr
comma
multiline_comment|/* source */
id|nbits
op_lshift
id|XFS_BLI_SHIFT
)paren
suffix:semicolon
multiline_comment|/* length */
id|i
op_increment
suffix:semicolon
id|bit
op_add_assign
id|nbits
suffix:semicolon
)brace
multiline_comment|/* Shouldn&squot;t be any more regions */
id|ASSERT
c_func
(paren
id|i
op_eq
id|item-&gt;ri_total
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do some primitive error checking on ondisk dquot data structures.&n; */
r_int
DECL|function|xfs_qm_dqcheck
id|xfs_qm_dqcheck
c_func
(paren
id|xfs_disk_dquot_t
op_star
id|ddq
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
multiline_comment|/* used only when IO_dorepair is true */
id|uint
id|flags
comma
r_char
op_star
id|str
)paren
(brace
id|xfs_dqblk_t
op_star
id|d
op_assign
(paren
id|xfs_dqblk_t
op_star
)paren
id|ddq
suffix:semicolon
r_int
id|errs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We can encounter an uninitialized dquot buffer for 2 reasons:&n;&t; * 1. If we crash while deleting the quotainode(s), and those blks got&n;&t; *    used for user data. This is because we take the path of regular&n;&t; *    file deletion; however, the size field of quotainodes is never&n;&t; *    updated, so all the tricks that we play in itruncate_finish&n;&t; *    don&squot;t quite matter.&n;&t; *&n;&t; * 2. We don&squot;t play the quota buffers when there&squot;s a quotaoff logitem.&n;&t; *    But the allocation will be replayed so we&squot;ll end up with an&n;&t; *    uninitialized quota block.&n;&t; *&n;&t; * This is all fine; things are still consistent, and we haven&squot;t lost&n;&t; * any quota information. Just don&squot;t complain about bad dquot blks.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQUOT_MAGIC
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x&quot;
comma
id|str
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_magic
comma
id|ARCH_CONVERT
)paren
comma
id|XFS_DQUOT_MAGIC
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_version
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQUOT_VERSION
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : XFS dquot ID 0x%x, version 0x%x != 0x%x&quot;
comma
id|str
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_magic
comma
id|ARCH_CONVERT
)paren
comma
id|XFS_DQUOT_VERSION
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQ_USER
op_logical_and
id|INT_GET
c_func
(paren
id|ddq-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQ_GROUP
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : XFS dquot ID 0x%x, unknown flags 0x%x&quot;
comma
id|str
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|id
op_ne
op_minus
l_int|1
op_logical_and
id|id
op_ne
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : ondisk-dquot 0x%p, ID mismatch: &quot;
l_string|&quot;0x%x expected, found id 0x%x&quot;
comma
id|str
comma
id|ddq
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|errs
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|ddq-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|ddq-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_btimer
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : Dquot ID 0x%x (0x%p) &quot;
l_string|&quot;BLK TIMER NOT STARTED&quot;
comma
id|str
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
id|ddq
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|ddq-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|ddq-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_itimer
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : Dquot ID 0x%x (0x%p) &quot;
l_string|&quot;INODE TIMER NOT STARTED&quot;
comma
id|str
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
id|ddq
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_rtb_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|ddq-&gt;d_rtbcount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|ddq-&gt;d_rtb_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_rtbtimer
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : Dquot ID 0x%x (0x%p) &quot;
l_string|&quot;RTBLK TIMER NOT STARTED&quot;
comma
id|str
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
id|ddq
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|errs
op_logical_or
op_logical_neg
(paren
id|flags
op_amp
id|XFS_QMOPT_DQREPAIR
)paren
)paren
r_return
id|errs
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Re-initializing dquot ID 0x%x&quot;
comma
id|id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Typically, a repair is only requested by quotacheck.&n;&t; */
id|ASSERT
c_func
(paren
id|id
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|flags
op_amp
id|XFS_QMOPT_DQREPAIR
)paren
suffix:semicolon
id|memset
c_func
(paren
id|d
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_dqblk_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_magic
comma
id|ARCH_CONVERT
comma
id|XFS_DQUOT_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_version
comma
id|ARCH_CONVERT
comma
id|XFS_DQUOT_VERSION
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_id
comma
id|ARCH_CONVERT
comma
id|id
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_flags
comma
id|ARCH_CONVERT
comma
id|type
)paren
suffix:semicolon
r_return
id|errs
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform a dquot buffer recovery.&n; * Simple algorithm: if we have found a QUOTAOFF logitem of the same type&n; * (ie. USR or GRP), then just toss this buffer away; don&squot;t recover it.&n; * Else, treat it as a regular buffer and do recovery.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_do_dquot_buffer
id|xlog_recover_do_dquot_buffer
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_t
op_star
id|log
comma
id|xlog_recover_item_t
op_star
id|item
comma
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_buf_log_format_t
op_star
id|buf_f
)paren
(brace
id|uint
id|type
suffix:semicolon
multiline_comment|/*&n;&t; * Filesystems are required to send in quota flags at mount time.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_qflags
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
id|type
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf_f-&gt;blf_flags
op_amp
id|XFS_BLI_UDQUOT_BUF
)paren
id|type
op_or_assign
id|XFS_DQ_USER
suffix:semicolon
r_if
c_cond
(paren
id|buf_f-&gt;blf_flags
op_amp
id|XFS_BLI_GDQUOT_BUF
)paren
id|type
op_or_assign
id|XFS_DQ_GROUP
suffix:semicolon
multiline_comment|/*&n;&t; * This type of quotas was turned off, so ignore this buffer&n;&t; */
r_if
c_cond
(paren
id|log-&gt;l_quotaoffs_flag
op_amp
id|type
)paren
r_return
suffix:semicolon
id|xlog_recover_do_reg_buffer
c_func
(paren
id|mp
comma
id|item
comma
id|bp
comma
id|buf_f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine replays a modification made to a buffer at runtime.&n; * There are actually two types of buffer, regular and inode, which&n; * are handled differently.  Inode buffers are handled differently&n; * in that we only recover a specific set of data from them, namely&n; * the inode di_next_unlinked fields.  This is because all other inode&n; * data is actually logged via inode records and any data we replay&n; * here which overlaps that may be stale.&n; *&n; * When meta-data buffers are freed at run time we log a buffer item&n; * with the XFS_BLI_CANCEL bit set to indicate that previous copies&n; * of the buffer in the log should not be replayed at recovery time.&n; * This is so that if the blocks covered by the buffer are reused for&n; * file data before we crash we don&squot;t end up replaying old, freed&n; * meta-data into a user&squot;s file.&n; *&n; * To handle the cancellation of buffer log items, we make two passes&n; * over the log during recovery.  During the first we build a table of&n; * those buffers which have been cancelled, and during the second we&n; * only replay those buffers which do not have corresponding cancel&n; * records in the table.  See xlog_recover_do_buffer_pass[1,2] above&n; * for more details on the implementation of the table of cancel records.&n; */
id|STATIC
r_int
DECL|function|xlog_recover_do_buffer_trans
id|xlog_recover_do_buffer_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_item_t
op_star
id|item
comma
r_int
id|pass
)paren
(brace
id|xfs_buf_log_format_t
op_star
id|buf_f
suffix:semicolon
id|xfs_buf_log_format_v1_t
op_star
id|obuf_f
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|cancel
suffix:semicolon
id|xfs_daddr_t
id|blkno
suffix:semicolon
r_int
id|len
suffix:semicolon
id|ushort
id|flags
suffix:semicolon
id|buf_f
op_assign
(paren
id|xfs_buf_log_format_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_addr
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
id|XLOG_RECOVER_PASS1
)paren
(brace
multiline_comment|/*&n;&t;&t; * In this pass we&squot;re only looking for buf items&n;&t;&t; * with the XFS_BLI_CANCEL bit set.&n;&t;&t; */
id|xlog_recover_do_buffer_pass1
c_func
(paren
id|log
comma
id|buf_f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * In this pass we want to recover all the buffers&n;&t;&t; * which have not been cancelled and are not&n;&t;&t; * cancellation buffers themselves.  The routine&n;&t;&t; * we call here will tell us whether or not to&n;&t;&t; * continue with the replay of this buffer.&n;&t;&t; */
id|cancel
op_assign
id|xlog_recover_do_buffer_pass2
c_func
(paren
id|log
comma
id|buf_f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cancel
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|buf_f-&gt;blf_type
)paren
(brace
r_case
id|XFS_LI_BUF
suffix:colon
id|blkno
op_assign
id|buf_f-&gt;blf_blkno
suffix:semicolon
id|len
op_assign
id|buf_f-&gt;blf_len
suffix:semicolon
id|flags
op_assign
id|buf_f-&gt;blf_flags
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_LI_6_1_BUF
suffix:colon
r_case
id|XFS_LI_5_3_BUF
suffix:colon
id|obuf_f
op_assign
(paren
id|xfs_buf_log_format_v1_t
op_star
)paren
id|buf_f
suffix:semicolon
id|blkno
op_assign
id|obuf_f-&gt;blf_blkno
suffix:semicolon
id|len
op_assign
id|obuf_f-&gt;blf_len
suffix:semicolon
id|flags
op_assign
id|obuf_f-&gt;blf_flags
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|log-&gt;l_mp
comma
l_string|&quot;xfs_log_recover: unknown buffer type 0x%x, dev %s&quot;
comma
id|buf_f-&gt;blf_type
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|log-&gt;l_targ
)paren
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_recover_do_buffer_trans&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|log-&gt;l_mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_BLI_INODE_BUF
)paren
(brace
id|bp
op_assign
id|xfs_buf_read_flags
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|blkno
comma
id|len
comma
id|XFS_BUF_LOCK
)paren
suffix:semicolon
)brace
r_else
(brace
id|bp
op_assign
id|xfs_buf_read
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|blkno
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_BUF_ISERROR
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_do..(read#1)&quot;
comma
id|log-&gt;l_mp
comma
id|bp
comma
id|blkno
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_BLI_INODE_BUF
)paren
(brace
id|error
op_assign
id|xlog_recover_do_inode_buffer
c_func
(paren
id|mp
comma
id|item
comma
id|bp
comma
id|buf_f
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|XFS_BLI_UDQUOT_BUF
op_or
id|XFS_BLI_GDQUOT_BUF
)paren
)paren
(brace
id|xlog_recover_do_dquot_buffer
c_func
(paren
id|mp
comma
id|log
comma
id|item
comma
id|bp
comma
id|buf_f
)paren
suffix:semicolon
)brace
r_else
(brace
id|xlog_recover_do_reg_buffer
c_func
(paren
id|mp
comma
id|item
comma
id|bp
comma
id|buf_f
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Perform delayed write on the buffer.  Asynchronous writes will be&n;&t; * slower when taking into account all the buffers to be flushed.&n;&t; *&n;&t; * Also make sure that only inode buffers with good sizes stay in&n;&t; * the buffer cache.  The kernel moves inodes in buffers of 1 block&n;&t; * or XFS_INODE_CLUSTER_SIZE bytes, whichever is bigger.  The inode&n;&t; * buffers in the log can be a different size if the log was generated&n;&t; * by an older kernel using unclustered inode buffers or a newer kernel&n;&t; * running with a different inode cluster size.  Regardless, if the&n;&t; * the inode buffer size isn&squot;t MAX(blocksize, XFS_INODE_CLUSTER_SIZE)&n;&t; * for *our* value of XFS_INODE_CLUSTER_SIZE, then we need to keep&n;&t; * the buffer out of the buffer cache so that the buffer won&squot;t&n;&t; * overlap with future reads of those inodes.&n;&t; */
r_if
c_cond
(paren
id|XFS_DINODE_MAGIC
op_eq
id|INT_GET
c_func
(paren
op_star
(paren
(paren
id|__uint16_t
op_star
)paren
(paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
l_int|0
)paren
)paren
)paren
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_ne
id|MAX
c_func
(paren
id|log-&gt;l_mp-&gt;m_sb.sb_blocksize
comma
(paren
id|__uint32_t
)paren
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|log-&gt;l_mp
)paren
)paren
)paren
)paren
(brace
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_eq
l_int|NULL
op_logical_or
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
op_eq
id|mp
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|mp
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|bp
comma
id|xlog_recover_iodone
)paren
suffix:semicolon
id|xfs_bdwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_recover_do_inode_trans
id|xlog_recover_do_inode_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_item_t
op_star
id|item
comma
r_int
id|pass
)paren
(brace
id|xfs_inode_log_format_t
op_star
id|in_f
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_imap_t
id|imap
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_ino_t
id|ino
suffix:semicolon
r_int
id|len
suffix:semicolon
id|xfs_caddr_t
id|src
suffix:semicolon
id|xfs_caddr_t
id|dest
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|attr_index
suffix:semicolon
id|uint
id|fields
suffix:semicolon
id|xfs_dinode_core_t
op_star
id|dicp
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
id|XLOG_RECOVER_PASS1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|in_f
op_assign
(paren
id|xfs_inode_log_format_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_addr
suffix:semicolon
id|ino
op_assign
id|in_f-&gt;ilf_ino
suffix:semicolon
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
r_if
c_cond
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_INODE
)paren
(brace
id|imap.im_blkno
op_assign
(paren
id|xfs_daddr_t
)paren
id|in_f-&gt;ilf_blkno
suffix:semicolon
id|imap.im_len
op_assign
id|in_f-&gt;ilf_len
suffix:semicolon
id|imap.im_boffset
op_assign
id|in_f-&gt;ilf_boffset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s an old inode format record.  We don&squot;t know where&n;&t;&t; * its cluster is located on disk, and we can&squot;t allow&n;&t;&t; * xfs_imap() to figure it out because the inode btrees&n;&t;&t; * are not ready to be used.  Therefore do not pass the&n;&t;&t; * XFS_IMAP_LOOKUP flag to xfs_imap().  This will give&n;&t;&t; * us only the single block in which the inode lives&n;&t;&t; * rather than its cluster, so we must make sure to&n;&t;&t; * invalidate the buffer when we write it out below.&n;&t;&t; */
id|imap.im_blkno
op_assign
l_int|0
suffix:semicolon
id|xfs_imap
c_func
(paren
id|log-&gt;l_mp
comma
l_int|NULL
comma
id|ino
comma
op_amp
id|imap
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Inode buffers can be freed, look out for it,&n;&t; * and do not replay the inode.&n;&t; */
r_if
c_cond
(paren
id|xlog_check_buffer_cancelled
c_func
(paren
id|log
comma
id|imap.im_blkno
comma
id|imap.im_len
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|bp
op_assign
id|xfs_buf_read_flags
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|imap.im_blkno
comma
id|imap.im_len
comma
id|XFS_BUF_LOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISERROR
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_do..(read#2)&quot;
comma
id|mp
comma
id|bp
comma
id|imap.im_blkno
)paren
suffix:semicolon
id|error
op_assign
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|in_f-&gt;ilf_fields
op_amp
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|imap.im_boffset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the place we&squot;re flushing out to really looks&n;&t; * like an inode!&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DINODE_MAGIC
)paren
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_inode_recover: Bad inode magic number, dino ptr = 0x%p, dino bp = 0x%p, ino = %Ld&quot;
comma
id|dip
comma
id|bp
comma
id|ino
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_recover_do_inode_trans(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|dicp
op_assign
(paren
id|xfs_dinode_core_t
op_star
)paren
(paren
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dicp-&gt;di_magic
op_ne
id|XFS_DINODE_MAGIC
)paren
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_inode_recover: Bad inode log record, rec ptr 0x%p, ino %Ld&quot;
comma
id|item
comma
id|ino
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_recover_do_inode_trans(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/* Skip replay when the on disk inode is newer than the log one */
r_if
c_cond
(paren
id|dicp-&gt;di_flushiter
OL
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_flushiter
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Deal with the wrap case, DI_MAX_FLUSH is less&n;&t;&t; * than smaller numbers&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_flushiter
comma
id|ARCH_CONVERT
)paren
op_eq
id|DI_MAX_FLUSH
)paren
op_logical_and
(paren
id|dicp-&gt;di_flushiter
OL
(paren
id|DI_MAX_FLUSH
op_rshift
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* do nothing */
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Take the opportunity to reset the flush iteration count */
id|dicp-&gt;di_flushiter
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|dicp-&gt;di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFREG
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dicp-&gt;di_format
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
op_logical_and
(paren
id|dicp-&gt;di_format
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xlog_recover_do_inode_trans(3)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|dicp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_inode_recover: Bad regular inode log record, rec ptr 0x%p, ino ptr = 0x%p, ino bp = 0x%p, ino %Ld&quot;
comma
id|item
comma
id|dip
comma
id|bp
comma
id|ino
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|dicp-&gt;di_mode
op_amp
id|S_IFMT
)paren
op_eq
id|S_IFDIR
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dicp-&gt;di_format
op_ne
id|XFS_DINODE_FMT_EXTENTS
)paren
op_logical_and
(paren
id|dicp-&gt;di_format
op_ne
id|XFS_DINODE_FMT_BTREE
)paren
op_logical_and
(paren
id|dicp-&gt;di_format
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xlog_recover_do_inode_trans(4)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|dicp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_inode_recover: Bad dir inode log record, rec ptr 0x%p, ino ptr = 0x%p, ino bp = 0x%p, ino %Ld&quot;
comma
id|item
comma
id|dip
comma
id|bp
comma
id|ino
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dicp-&gt;di_nextents
op_plus
id|dicp-&gt;di_anextents
OG
id|dicp-&gt;di_nblocks
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xlog_recover_do_inode_trans(5)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|dicp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_inode_recover: Bad inode log record, rec ptr 0x%p, dino ptr 0x%p, dino bp 0x%p, ino %Ld, total extents = %d, nblocks = %Ld&quot;
comma
id|item
comma
id|dip
comma
id|bp
comma
id|ino
comma
id|dicp-&gt;di_nextents
op_plus
id|dicp-&gt;di_anextents
comma
id|dicp-&gt;di_nblocks
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|dicp-&gt;di_forkoff
OG
id|mp-&gt;m_sb.sb_inodesize
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xlog_recover_do_inode_trans(6)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|dicp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_inode_recover: Bad inode log rec ptr 0x%p, dino ptr 0x%p, dino bp 0x%p, ino %Ld, forkoff 0x%x&quot;
comma
id|item
comma
id|dip
comma
id|bp
comma
id|ino
comma
id|dicp-&gt;di_forkoff
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_len
OG
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xlog_recover_do_inode_trans(7)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|dicp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_inode_recover: Bad inode log record length %d, rec ptr 0x%p&quot;
comma
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_len
comma
id|item
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/* The core is in in-core format */
id|xfs_xlate_dinode_core
c_func
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
id|dip-&gt;di_core
comma
(paren
id|xfs_dinode_core_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_addr
comma
op_minus
l_int|1
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* the rest is in on-disk format */
r_if
c_cond
(paren
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_len
OG
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
)paren
(brace
id|memcpy
c_func
(paren
(paren
id|xfs_caddr_t
)paren
id|dip
op_plus
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
comma
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_addr
op_plus
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
comma
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_len
op_minus
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
)paren
suffix:semicolon
)brace
id|fields
op_assign
id|in_f-&gt;ilf_fields
suffix:semicolon
r_switch
c_cond
(paren
id|fields
op_amp
(paren
id|XFS_ILOG_DEV
op_or
id|XFS_ILOG_UUID
)paren
)paren
(brace
r_case
id|XFS_ILOG_DEV
suffix:colon
id|INT_SET
c_func
(paren
id|dip-&gt;di_u.di_dev
comma
id|ARCH_CONVERT
comma
id|in_f-&gt;ilf_u.ilfu_rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ILOG_UUID
suffix:colon
id|dip-&gt;di_u.di_muuid
op_assign
id|in_f-&gt;ilf_u.ilfu_uuid
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in_f-&gt;ilf_size
op_eq
l_int|2
)paren
r_goto
id|write_inode_buffer
suffix:semicolon
id|len
op_assign
id|item-&gt;ri_buf
(braket
l_int|2
)braket
dot
id|i_len
suffix:semicolon
id|src
op_assign
id|item-&gt;ri_buf
(braket
l_int|2
)braket
dot
id|i_addr
suffix:semicolon
id|ASSERT
c_func
(paren
id|in_f-&gt;ilf_size
op_le
l_int|4
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|in_f-&gt;ilf_size
op_eq
l_int|3
)paren
op_logical_or
(paren
id|fields
op_amp
id|XFS_ILOG_AFORK
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|fields
op_amp
id|XFS_ILOG_DFORK
)paren
op_logical_or
(paren
id|len
op_eq
id|in_f-&gt;ilf_dsize
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|fields
op_amp
id|XFS_ILOG_DFORK
)paren
(brace
r_case
id|XFS_ILOG_DDATA
suffix:colon
r_case
id|XFS_ILOG_DEXT
suffix:colon
id|memcpy
c_func
(paren
op_amp
id|dip-&gt;di_u
comma
id|src
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ILOG_DBROOT
suffix:colon
id|xfs_bmbt_to_bmdr
c_func
(paren
(paren
id|xfs_bmbt_block_t
op_star
)paren
id|src
comma
id|len
comma
op_amp
(paren
id|dip-&gt;di_u.di_bmbt
)paren
comma
id|XFS_DFORK_DSIZE
c_func
(paren
id|dip
comma
id|mp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t; * There are no data fork flags set.&n;&t;&t; */
id|ASSERT
c_func
(paren
(paren
id|fields
op_amp
id|XFS_ILOG_DFORK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we logged any attribute data, recover it.  There may or&n;&t; * may not have been any other non-core data logged in this&n;&t; * transaction.&n;&t; */
r_if
c_cond
(paren
id|in_f-&gt;ilf_fields
op_amp
id|XFS_ILOG_AFORK
)paren
(brace
r_if
c_cond
(paren
id|in_f-&gt;ilf_fields
op_amp
id|XFS_ILOG_DFORK
)paren
(brace
id|attr_index
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|attr_index
op_assign
l_int|2
suffix:semicolon
)brace
id|len
op_assign
id|item-&gt;ri_buf
(braket
id|attr_index
)braket
dot
id|i_len
suffix:semicolon
id|src
op_assign
id|item-&gt;ri_buf
(braket
id|attr_index
)braket
dot
id|i_addr
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
op_eq
id|in_f-&gt;ilf_asize
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|in_f-&gt;ilf_fields
op_amp
id|XFS_ILOG_AFORK
)paren
(brace
r_case
id|XFS_ILOG_ADATA
suffix:colon
r_case
id|XFS_ILOG_AEXT
suffix:colon
id|dest
op_assign
id|XFS_DFORK_APTR
c_func
(paren
id|dip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
op_le
id|XFS_DFORK_ASIZE
c_func
(paren
id|dip
comma
id|mp
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|src
comma
id|len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ILOG_ABROOT
suffix:colon
id|dest
op_assign
id|XFS_DFORK_APTR
c_func
(paren
id|dip
)paren
suffix:semicolon
id|xfs_bmbt_to_bmdr
c_func
(paren
(paren
id|xfs_bmbt_block_t
op_star
)paren
id|src
comma
id|len
comma
(paren
id|xfs_bmdr_block_t
op_star
)paren
id|dest
comma
id|XFS_DFORK_ASIZE
c_func
(paren
id|dip
comma
id|mp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_do_inode_trans: Invalid flag&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
id|write_inode_buffer
suffix:colon
r_if
c_cond
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_INODE
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_eq
l_int|NULL
op_logical_or
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
op_eq
id|mp
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|mp
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|bp
comma
id|xlog_recover_iodone
)paren
suffix:semicolon
id|xfs_bdwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Recover QUOTAOFF records. We simply make a note of it in the xlog_t&n; * structure, so that we know not to do any dquot item or dquot buffer recovery,&n; * of that type.&n; */
id|STATIC
r_int
DECL|function|xlog_recover_do_quotaoff_trans
id|xlog_recover_do_quotaoff_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_item_t
op_star
id|item
comma
r_int
id|pass
)paren
(brace
id|xfs_qoff_logformat_t
op_star
id|qoff_f
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
id|XLOG_RECOVER_PASS2
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|qoff_f
op_assign
(paren
id|xfs_qoff_logformat_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_addr
suffix:semicolon
id|ASSERT
c_func
(paren
id|qoff_f
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The logitem format&squot;s flag tells us if this was user quotaoff,&n;&t; * group quotaoff or both.&n;&t; */
r_if
c_cond
(paren
id|qoff_f-&gt;qf_flags
op_amp
id|XFS_UQUOTA_ACCT
)paren
id|log-&gt;l_quotaoffs_flag
op_or_assign
id|XFS_DQ_USER
suffix:semicolon
r_if
c_cond
(paren
id|qoff_f-&gt;qf_flags
op_amp
id|XFS_GQUOTA_ACCT
)paren
id|log-&gt;l_quotaoffs_flag
op_or_assign
id|XFS_DQ_GROUP
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Recover a dquot record&n; */
id|STATIC
r_int
DECL|function|xlog_recover_do_dquot_trans
id|xlog_recover_do_dquot_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_item_t
op_star
id|item
comma
r_int
id|pass
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_struct
id|xfs_disk_dquot
op_star
id|ddq
comma
op_star
id|recddq
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_dq_logformat_t
op_star
id|dq_f
suffix:semicolon
id|uint
id|type
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
id|XLOG_RECOVER_PASS1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
multiline_comment|/*&n;&t; * Filesystems are required to send in quota flags at mount time.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_qflags
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|recddq
op_assign
(paren
id|xfs_disk_dquot_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_addr
suffix:semicolon
id|ASSERT
c_func
(paren
id|recddq
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This type of quotas was turned off, so ignore this record.&n;&t; */
id|type
op_assign
id|INT_GET
c_func
(paren
id|recddq-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
op_amp
(paren
id|XFS_DQ_USER
op_or
id|XFS_DQ_GROUP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_quotaoffs_flag
op_amp
id|type
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point we know that quota was _not_ turned off.&n;&t; * Since the mount flags are not indicating to us otherwise, this&n;&t; * must mean that quota is on, and the dquot needs to be replayed.&n;&t; * Remember that we may not have fully recovered the superblock yet,&n;&t; * so we can&squot;t do the usual trick of looking at the SB quota bits.&n;&t; *&n;&t; * The other possibility, of course, is that the quota subsystem was&n;&t; * removed since the last mount - ENOSYS.&n;&t; */
id|dq_f
op_assign
(paren
id|xfs_dq_logformat_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_addr
suffix:semicolon
id|ASSERT
c_func
(paren
id|dq_f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqcheck
c_func
(paren
id|recddq
comma
id|dq_f-&gt;qlf_id
comma
l_int|0
comma
id|XFS_QMOPT_DOWARN
comma
l_string|&quot;xlog_recover_do_dquot_trans (log copy)&quot;
)paren
)paren
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dq_f-&gt;qlf_len
op_eq
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|xfs_read_buf
c_func
(paren
id|mp
comma
id|mp-&gt;m_ddev_targp
comma
id|dq_f-&gt;qlf_blkno
comma
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|dq_f-&gt;qlf_len
)paren
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_do..(read#3)&quot;
comma
id|mp
comma
id|bp
comma
id|dq_f-&gt;qlf_blkno
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ddq
op_assign
(paren
id|xfs_disk_dquot_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
id|dq_f-&gt;qlf_boffset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At least the magic num portion should be on disk because this&n;&t; * was among a chunk of dquots created earlier, and we did some&n;&t; * minimal initialization then.&n;&t; */
r_if
c_cond
(paren
id|xfs_qm_dqcheck
c_func
(paren
id|ddq
comma
id|dq_f-&gt;qlf_id
comma
l_int|0
comma
id|XFS_QMOPT_DOWARN
comma
l_string|&quot;xlog_recover_do_dquot_trans&quot;
)paren
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ddq
comma
id|recddq
comma
id|item-&gt;ri_buf
(braket
l_int|1
)braket
dot
id|i_len
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dq_f-&gt;qlf_size
op_eq
l_int|2
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
r_void
op_star
)paren
op_eq
l_int|NULL
op_logical_or
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_mount_t
op_star
)paren
op_eq
id|mp
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|mp
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|bp
comma
id|xlog_recover_iodone
)paren
suffix:semicolon
id|xfs_bdwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to create an in-core extent free intent&n; * item from the efi format structure which was logged on disk.&n; * It allocates an in-core efi, copies the extents from the format&n; * structure into it, and adds the efi to the AIL with the given&n; * LSN.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_do_efi_trans
id|xlog_recover_do_efi_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_item_t
op_star
id|item
comma
id|xfs_lsn_t
id|lsn
comma
r_int
id|pass
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_efi_log_item_t
op_star
id|efip
suffix:semicolon
id|xfs_efi_log_format_t
op_star
id|efi_formatp
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
id|XLOG_RECOVER_PASS1
)paren
(brace
r_return
suffix:semicolon
)brace
id|efi_formatp
op_assign
(paren
id|xfs_efi_log_format_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_addr
suffix:semicolon
id|ASSERT
c_func
(paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_len
op_eq
(paren
r_sizeof
(paren
id|xfs_efi_log_format_t
)paren
op_plus
(paren
(paren
id|efi_formatp-&gt;efi_nextents
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
id|efip
op_assign
id|xfs_efi_init
c_func
(paren
id|mp
comma
id|efi_formatp-&gt;efi_nextents
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
(paren
id|efip-&gt;efi_format
)paren
comma
(paren
r_char
op_star
)paren
id|efi_formatp
comma
r_sizeof
(paren
id|xfs_efi_log_format_t
)paren
op_plus
(paren
(paren
id|efi_formatp-&gt;efi_nextents
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
suffix:semicolon
id|efip-&gt;efi_next_extent
op_assign
id|efi_formatp-&gt;efi_nextents
suffix:semicolon
id|efip-&gt;efi_flags
op_or_assign
id|XFS_EFI_COMMITTED
suffix:semicolon
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * xfs_trans_update_ail() drops the AIL lock.&n;&t; */
id|xfs_trans_update_ail
c_func
(paren
id|mp
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|efip
comma
id|lsn
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called when an efd format structure is found in&n; * a committed transaction in the log.  It&squot;s purpose is to cancel&n; * the corresponding efi if it was still in the log.  To do this&n; * it searches the AIL for the efi with an id equal to that in the&n; * efd format structure.  If we find it, we remove the efi from the&n; * AIL and free it.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_do_efd_trans
id|xlog_recover_do_efd_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_item_t
op_star
id|item
comma
r_int
id|pass
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_efd_log_format_t
op_star
id|efd_formatp
suffix:semicolon
id|xfs_efi_log_item_t
op_star
id|efip
op_assign
l_int|NULL
suffix:semicolon
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
r_int
id|gen
suffix:semicolon
r_int
id|nexts
suffix:semicolon
id|__uint64_t
id|efi_id
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
id|XLOG_RECOVER_PASS1
)paren
(brace
r_return
suffix:semicolon
)brace
id|efd_formatp
op_assign
(paren
id|xfs_efd_log_format_t
op_star
)paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_addr
suffix:semicolon
id|ASSERT
c_func
(paren
id|item-&gt;ri_buf
(braket
l_int|0
)braket
dot
id|i_len
op_eq
(paren
r_sizeof
(paren
id|xfs_efd_log_format_t
)paren
op_plus
(paren
(paren
id|efd_formatp-&gt;efd_nextents
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
)paren
suffix:semicolon
id|efi_id
op_assign
id|efd_formatp-&gt;efd_efi_id
suffix:semicolon
multiline_comment|/*&n;&t; * Search for the efi with the id in the efd format structure&n;&t; * in the AIL.&n;&t; */
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|lip
op_assign
id|xfs_trans_first_ail
c_func
(paren
id|mp
comma
op_amp
id|gen
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lip
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|lip-&gt;li_type
op_eq
id|XFS_LI_EFI
)paren
(brace
id|efip
op_assign
(paren
id|xfs_efi_log_item_t
op_star
)paren
id|lip
suffix:semicolon
r_if
c_cond
(paren
id|efip-&gt;efi_format.efi_id
op_eq
id|efi_id
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * xfs_trans_delete_ail() drops the&n;&t;&t;&t;&t; * AIL lock.&n;&t;&t;&t;&t; */
id|xfs_trans_delete_ail
c_func
(paren
id|mp
comma
id|lip
comma
id|s
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|lip
op_assign
id|xfs_trans_next_ail
c_func
(paren
id|mp
comma
id|lip
comma
op_amp
id|gen
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lip
op_eq
l_int|NULL
)paren
(brace
id|AIL_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we found it, then free it up.  If it wasn&squot;t there, it&n;&t; * must have been overwritten in the log.  Oh well.&n;&t; */
r_if
c_cond
(paren
id|lip
op_ne
l_int|NULL
)paren
(brace
id|nexts
op_assign
id|efip-&gt;efi_format.efi_nextents
suffix:semicolon
r_if
c_cond
(paren
id|nexts
OG
id|XFS_EFI_MAX_FAST_EXTENTS
)paren
(brace
id|kmem_free
c_func
(paren
id|lip
comma
r_sizeof
(paren
id|xfs_efi_log_item_t
)paren
op_plus
(paren
(paren
id|nexts
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|kmem_zone_free
c_func
(paren
id|xfs_efi_zone
comma
id|efip
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Perform the transaction&n; *&n; * If the transaction modifies a buffer or inode, do it now.  Otherwise,&n; * EFIs and EFDs get queued up by adding entries into the AIL for them.&n; */
id|STATIC
r_int
DECL|function|xlog_recover_do_trans
id|xlog_recover_do_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_t
op_star
id|trans
comma
r_int
id|pass
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xlog_recover_item_t
op_star
id|item
comma
op_star
id|first_item
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_reorder_trans
c_func
(paren
id|log
comma
id|trans
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|first_item
op_assign
id|item
op_assign
id|trans-&gt;r_itemq
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * we don&squot;t need to worry about the block number being&n;&t;&t; * truncated in &gt; 1 TB buffers because in user-land,&n;&t;&t; * we&squot;re now n32 or 64-bit so xfs_daddr_t is 64-bits so&n;&t;&t; * the blkno&squot;s will get through the user-mode buffer&n;&t;&t; * cache properly.  The only bad case is o32 kernels&n;&t;&t; * where xfs_daddr_t is 32-bits but mount will warn us&n;&t;&t; * off a &gt; 1 TB filesystem before we get here.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_BUF
)paren
op_logical_or
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_6_1_BUF
)paren
op_logical_or
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_5_3_BUF
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_do_buffer_trans
c_func
(paren
id|log
comma
id|item
comma
id|pass
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_INODE
)paren
op_logical_or
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_6_1_INODE
)paren
op_logical_or
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_5_3_INODE
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_do_inode_trans
c_func
(paren
id|log
comma
id|item
comma
id|pass
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_EFI
)paren
(brace
id|xlog_recover_do_efi_trans
c_func
(paren
id|log
comma
id|item
comma
id|trans-&gt;r_lsn
comma
id|pass
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_EFD
)paren
(brace
id|xlog_recover_do_efd_trans
c_func
(paren
id|log
comma
id|item
comma
id|pass
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_DQUOT
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_do_dquot_trans
c_func
(paren
id|log
comma
id|item
comma
id|pass
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ITEM_TYPE
c_func
(paren
id|item
)paren
op_eq
id|XFS_LI_QUOTAOFF
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_do_quotaoff_trans
c_func
(paren
id|log
comma
id|item
comma
id|pass
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_do_trans&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|item
op_assign
id|item-&gt;ri_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|first_item
op_ne
id|item
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Free up any resources allocated by the transaction&n; *&n; * Remember that EFIs, EFDs, and IUNLINKs are handled later.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_free_trans
id|xlog_recover_free_trans
c_func
(paren
id|xlog_recover_t
op_star
id|trans
)paren
(brace
id|xlog_recover_item_t
op_star
id|first_item
comma
op_star
id|item
comma
op_star
id|free_item
suffix:semicolon
r_int
id|i
suffix:semicolon
id|item
op_assign
id|first_item
op_assign
id|trans-&gt;r_itemq
suffix:semicolon
r_do
(brace
id|free_item
op_assign
id|item
suffix:semicolon
id|item
op_assign
id|item-&gt;ri_next
suffix:semicolon
multiline_comment|/* Free the regions in the item. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|free_item-&gt;ri_cnt
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kmem_free
c_func
(paren
id|free_item-&gt;ri_buf
(braket
id|i
)braket
dot
id|i_addr
comma
id|free_item-&gt;ri_buf
(braket
id|i
)braket
dot
id|i_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the item itself */
id|kmem_free
c_func
(paren
id|free_item-&gt;ri_buf
comma
(paren
id|free_item-&gt;ri_total
op_star
r_sizeof
(paren
id|xfs_log_iovec_t
)paren
)paren
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|free_item
comma
r_sizeof
(paren
id|xlog_recover_item_t
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|first_item
op_ne
id|item
)paren
suffix:semicolon
multiline_comment|/* Free the transaction recover structure */
id|kmem_free
c_func
(paren
id|trans
comma
r_sizeof
(paren
id|xlog_recover_t
)paren
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_recover_commit_trans
id|xlog_recover_commit_trans
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_t
op_star
op_star
id|q
comma
id|xlog_recover_t
op_star
id|trans
comma
r_int
id|pass
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_unlink_tid
c_func
(paren
id|q
comma
id|trans
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_do_trans
c_func
(paren
id|log
comma
id|trans
comma
id|pass
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|xlog_recover_free_trans
c_func
(paren
id|trans
)paren
suffix:semicolon
multiline_comment|/* no error */
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_recover_unmount_trans
id|xlog_recover_unmount_trans
c_func
(paren
id|xlog_recover_t
op_star
id|trans
)paren
(brace
multiline_comment|/* Do nothing now */
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_unmount_trans: Unmount LR&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * There are two valid states of the r_state field.  0 indicates that the&n; * transaction structure is in a normal state.  We have either seen the&n; * start of the transaction or the last operation we added was not a partial&n; * operation.  If the last operation we added to the transaction was a&n; * partial operation, we need to mark r_state with XLOG_WAS_CONT_TRANS.&n; *&n; * NOTE: skip LRs with 0 data length.&n; */
id|STATIC
r_int
DECL|function|xlog_recover_process_data
id|xlog_recover_process_data
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_recover_t
op_star
id|rhash
(braket
)braket
comma
id|xlog_rec_header_t
op_star
id|rhead
comma
id|xfs_caddr_t
id|dp
comma
r_int
id|pass
)paren
(brace
id|xfs_caddr_t
id|lp
suffix:semicolon
r_int
id|num_logops
suffix:semicolon
id|xlog_op_header_t
op_star
id|ohead
suffix:semicolon
id|xlog_recover_t
op_star
id|trans
suffix:semicolon
id|xlog_tid_t
id|tid
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
id|uint
id|flags
suffix:semicolon
id|lp
op_assign
id|dp
op_plus
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|num_logops
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_num_logops
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* check the log format matches our own - else we can&squot;t recover */
r_if
c_cond
(paren
id|xlog_header_check_recover
c_func
(paren
id|log-&gt;l_mp
comma
id|rhead
)paren
)paren
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dp
OL
id|lp
)paren
op_logical_and
id|num_logops
)paren
(brace
id|ASSERT
c_func
(paren
id|dp
op_plus
r_sizeof
(paren
id|xlog_op_header_t
)paren
op_le
id|lp
)paren
suffix:semicolon
id|ohead
op_assign
(paren
id|xlog_op_header_t
op_star
)paren
id|dp
suffix:semicolon
id|dp
op_add_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ohead-&gt;oh_clientid
op_ne
id|XFS_TRANSACTION
op_logical_and
id|ohead-&gt;oh_clientid
op_ne
id|XFS_LOG
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_process_data: bad clientid&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
)paren
suffix:semicolon
)brace
id|tid
op_assign
id|INT_GET
c_func
(paren
id|ohead-&gt;oh_tid
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|hash
op_assign
id|XLOG_RHASH
c_func
(paren
id|tid
)paren
suffix:semicolon
id|trans
op_assign
id|xlog_recover_find_tid
c_func
(paren
id|rhash
(braket
id|hash
)braket
comma
id|tid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|trans
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* not found; add new tid */
r_if
c_cond
(paren
id|ohead-&gt;oh_flags
op_amp
id|XLOG_START_TRANS
)paren
id|xlog_recover_new_tid
c_func
(paren
op_amp
id|rhash
(braket
id|hash
)braket
comma
id|tid
comma
id|INT_GET
c_func
(paren
id|rhead-&gt;h_lsn
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|dp
op_plus
id|INT_GET
c_func
(paren
id|ohead-&gt;oh_len
comma
id|ARCH_CONVERT
)paren
op_le
id|lp
)paren
suffix:semicolon
id|flags
op_assign
id|ohead-&gt;oh_flags
op_amp
op_complement
id|XLOG_END_TRANS
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XLOG_WAS_CONT_TRANS
)paren
id|flags
op_and_assign
op_complement
id|XLOG_CONTINUE_TRANS
suffix:semicolon
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|XLOG_COMMIT_TRANS
suffix:colon
id|error
op_assign
id|xlog_recover_commit_trans
c_func
(paren
id|log
comma
op_amp
id|rhash
(braket
id|hash
)braket
comma
id|trans
comma
id|pass
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XLOG_UNMOUNT_TRANS
suffix:colon
id|error
op_assign
id|xlog_recover_unmount_trans
c_func
(paren
id|trans
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XLOG_WAS_CONT_TRANS
suffix:colon
id|error
op_assign
id|xlog_recover_add_to_cont_trans
c_func
(paren
id|trans
comma
id|dp
comma
id|INT_GET
c_func
(paren
id|ohead-&gt;oh_len
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XLOG_START_TRANS
suffix:colon
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_process_data: bad transaction&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_case
id|XLOG_CONTINUE_TRANS
suffix:colon
id|error
op_assign
id|xlog_recover_add_to_trans
c_func
(paren
id|trans
comma
id|dp
comma
id|INT_GET
c_func
(paren
id|ohead-&gt;oh_len
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_recover_process_data: bad flag&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
id|dp
op_add_assign
id|INT_GET
c_func
(paren
id|ohead-&gt;oh_len
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|num_logops
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Process an extent free intent item that was recovered from&n; * the log.  We need to free the extents that it describes.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_process_efi
id|xlog_recover_process_efi
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_efi_log_item_t
op_star
id|efip
)paren
(brace
id|xfs_efd_log_item_t
op_star
id|efdp
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xfs_extent_t
op_star
id|extp
suffix:semicolon
id|xfs_fsblock_t
id|startblock_fsb
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|efip-&gt;efi_flags
op_amp
id|XFS_EFI_RECOVERED
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First check the validity of the extents described by the&n;&t; * EFI.  If any are bad, then assume that all are bad and&n;&t; * just toss the EFI.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|efip-&gt;efi_format.efi_nextents
suffix:semicolon
id|i
op_increment
)paren
(brace
id|extp
op_assign
op_amp
(paren
id|efip-&gt;efi_format.efi_extents
(braket
id|i
)braket
)paren
suffix:semicolon
id|startblock_fsb
op_assign
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|extp-&gt;ext_start
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|startblock_fsb
op_eq
l_int|0
)paren
op_logical_or
(paren
id|extp-&gt;ext_len
op_eq
l_int|0
)paren
op_logical_or
(paren
id|startblock_fsb
op_ge
id|mp-&gt;m_sb.sb_dblocks
)paren
op_logical_or
(paren
id|extp-&gt;ext_len
op_ge
id|mp-&gt;m_sb.sb_agblocks
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This will pull the EFI from the AIL and&n;&t;&t;&t; * free the memory associated with it.&n;&t;&t;&t; */
id|xfs_efi_release
c_func
(paren
id|efip
comma
id|efip-&gt;efi_format.efi_nextents
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ITRUNCATE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|efdp
op_assign
id|xfs_trans_get_efd
c_func
(paren
id|tp
comma
id|efip
comma
id|efip-&gt;efi_format.efi_nextents
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|efip-&gt;efi_format.efi_nextents
suffix:semicolon
id|i
op_increment
)paren
(brace
id|extp
op_assign
op_amp
(paren
id|efip-&gt;efi_format.efi_extents
(braket
id|i
)braket
)paren
suffix:semicolon
id|xfs_free_extent
c_func
(paren
id|tp
comma
id|extp-&gt;ext_start
comma
id|extp-&gt;ext_len
)paren
suffix:semicolon
id|xfs_trans_log_efd_extent
c_func
(paren
id|tp
comma
id|efdp
comma
id|extp-&gt;ext_start
comma
id|extp-&gt;ext_len
)paren
suffix:semicolon
)brace
id|efip-&gt;efi_flags
op_or_assign
id|XFS_EFI_RECOVERED
suffix:semicolon
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that once we&squot;ve encountered something other than an EFI&n; * in the AIL that there are no more EFIs in the AIL.&n; */
macro_line|#if defined(DEBUG)
id|STATIC
r_void
DECL|function|xlog_recover_check_ail
id|xlog_recover_check_ail
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_log_item_t
op_star
id|lip
comma
r_int
id|gen
)paren
(brace
r_int
id|orig_gen
op_assign
id|gen
suffix:semicolon
r_do
(brace
id|ASSERT
c_func
(paren
id|lip-&gt;li_type
op_ne
id|XFS_LI_EFI
)paren
suffix:semicolon
id|lip
op_assign
id|xfs_trans_next_ail
c_func
(paren
id|mp
comma
id|lip
comma
op_amp
id|gen
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The check will be bogus if we restart from the&n;&t;&t; * beginning of the AIL, so ASSERT that we don&squot;t.&n;&t;&t; * We never should since we&squot;re holding the AIL lock&n;&t;&t; * the entire time.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|gen
op_eq
id|orig_gen
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lip
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/*&n; * When this is called, all of the EFIs which did not have&n; * corresponding EFDs should be in the AIL.  What we do now&n; * is free the extents associated with each one.&n; *&n; * Since we process the EFIs in normal transactions, they&n; * will be removed at some point after the commit.  This prevents&n; * us from just walking down the list processing each one.&n; * We&squot;ll use a flag in the EFI to skip those that we&squot;ve already&n; * processed and use the AIL iteration mechanism&squot;s generation&n; * count to try to speed this up at least a bit.&n; *&n; * When we start, we know that the EFIs are the only things in&n; * the AIL.  As we process them, however, other items are added&n; * to the AIL.  Since everything added to the AIL must come after&n; * everything already in the AIL, we stop processing as soon as&n; * we see something other than an EFI in the AIL.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_process_efis
id|xlog_recover_process_efis
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xfs_log_item_t
op_star
id|lip
suffix:semicolon
id|xfs_efi_log_item_t
op_star
id|efip
suffix:semicolon
r_int
id|gen
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|lip
op_assign
id|xfs_trans_first_ail
c_func
(paren
id|mp
comma
op_amp
id|gen
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lip
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re done when we see something other than an EFI.&n;&t;&t; */
r_if
c_cond
(paren
id|lip-&gt;li_type
op_ne
id|XFS_LI_EFI
)paren
(brace
id|xlog_recover_check_ail
c_func
(paren
id|mp
comma
id|lip
comma
id|gen
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Skip EFIs that we&squot;ve already processed.&n;&t;&t; */
id|efip
op_assign
(paren
id|xfs_efi_log_item_t
op_star
)paren
id|lip
suffix:semicolon
r_if
c_cond
(paren
id|efip-&gt;efi_flags
op_amp
id|XFS_EFI_RECOVERED
)paren
(brace
id|lip
op_assign
id|xfs_trans_next_ail
c_func
(paren
id|mp
comma
id|lip
comma
op_amp
id|gen
comma
l_int|NULL
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|AIL_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|xlog_recover_process_efi
c_func
(paren
id|mp
comma
id|efip
)paren
suffix:semicolon
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|lip
op_assign
id|xfs_trans_next_ail
c_func
(paren
id|mp
comma
id|lip
comma
op_amp
id|gen
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|AIL_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine performs a transaction to null out a bad inode pointer&n; * in an agi unlinked inode hash bucket.&n; */
id|STATIC
r_void
DECL|function|xlog_recover_clear_agi_bucket
id|xlog_recover_clear_agi_bucket
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_agnumber_t
id|agno
comma
r_int
id|bucket
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
id|xfs_buf_t
op_star
id|agibp
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|error
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_CLEAR_AGI_BUCKET
)paren
suffix:semicolon
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_CLEAR_AGI_BUCKET_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
comma
op_amp
id|agibp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agibp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_AGI_MAGIC
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket
)braket
comma
id|ARCH_CONVERT
comma
id|NULLAGINO
)paren
suffix:semicolon
id|offset
op_assign
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_unlinked
)paren
op_plus
(paren
r_sizeof
(paren
id|xfs_agino_t
)paren
op_star
id|bucket
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|agibp
comma
id|offset
comma
(paren
id|offset
op_plus
r_sizeof
(paren
id|xfs_agino_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xlog_iunlink_recover&n; *&n; * This is called during recovery to process any inodes which&n; * we unlinked but not freed when the system crashed.  These&n; * inodes will be on the lists in the AGI blocks.  What we do&n; * here is scan all the AGIs and fully truncate and free any&n; * inodes found on the lists.  Each inode is removed from the&n; * lists when it has been fully truncated and is freed.  The&n; * freeing of the inode and its removal from the list must be&n; * atomic.&n; */
r_void
DECL|function|xlog_recover_process_iunlinks
id|xlog_recover_process_iunlinks
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_agnumber_t
id|agno
suffix:semicolon
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
id|xfs_buf_t
op_star
id|agibp
suffix:semicolon
id|xfs_buf_t
op_star
id|ibp
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_agino_t
id|agino
suffix:semicolon
id|xfs_ino_t
id|ino
suffix:semicolon
r_int
id|bucket
suffix:semicolon
r_int
id|error
suffix:semicolon
id|uint
id|mp_dmevmask
suffix:semicolon
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
multiline_comment|/*&n;&t; * Prevent any DMAPI event from being sent while in this function.&n;&t; */
id|mp_dmevmask
op_assign
id|mp-&gt;m_dmevmask
suffix:semicolon
id|mp-&gt;m_dmevmask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|agno
op_assign
l_int|0
suffix:semicolon
id|agno
OL
id|mp-&gt;m_sb.sb_agcount
suffix:semicolon
id|agno
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Find the agi for this ag.&n;&t;&t; */
id|agibp
op_assign
id|xfs_buf_read
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISERROR
c_func
(paren
id|agibp
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_process_iunlinks(#1)&quot;
comma
id|log-&gt;l_mp
comma
id|agibp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
)brace
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agibp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_AGI_MAGIC
op_eq
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bucket
op_assign
l_int|0
suffix:semicolon
id|bucket
OL
id|XFS_AGI_UNLINKED_BUCKETS
suffix:semicolon
id|bucket
op_increment
)paren
(brace
id|agino
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|bucket
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_while
c_loop
(paren
id|agino
op_ne
id|NULLAGINO
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Release the agi buffer so that it can&n;&t;&t;&t;&t; * be acquired in the normal course of the&n;&t;&t;&t;&t; * transaction to truncate and free the inode.&n;&t;&t;&t;&t; */
id|xfs_buf_relse
c_func
(paren
id|agibp
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|ip
comma
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_logical_or
(paren
id|ip
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Get the on disk inode to find the&n;&t;&t;&t;&t;&t; * next inode in the bucket.&n;&t;&t;&t;&t;&t; */
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|ibp
comma
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_logical_or
(paren
id|dip
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_d.di_nlink
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* setup for the next pass */
id|agino
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|ibp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Prevent any DMAPI event from&n;&t;&t;&t;&t;&t; * being sent when the&n;&t;&t;&t;&t;&t; * reference on the inode is&n;&t;&t;&t;&t;&t; * dropped.&n;&t;&t;&t;&t;&t; */
id|ip-&gt;i_d.di_dmevmask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If this is a new inode, handle&n;&t;&t;&t;&t;&t; * it specially.  Otherwise,&n;&t;&t;&t;&t;&t; * just drop our reference to the&n;&t;&t;&t;&t;&t; * inode.  If there are no&n;&t;&t;&t;&t;&t; * other references, this will&n;&t;&t;&t;&t;&t; * send the inode to&n;&t;&t;&t;&t;&t; * xfs_inactive() which will&n;&t;&t;&t;&t;&t; * truncate the file and free&n;&t;&t;&t;&t;&t; * the inode.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
id|xfs_iput_new
c_func
(paren
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_else
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We can&squot;t read in the inode&n;&t;&t;&t;&t;&t; * this bucket points to, or&n;&t;&t;&t;&t;&t; * this inode is messed up.  Just&n;&t;&t;&t;&t;&t; * ditch this bucket of inodes.  We&n;&t;&t;&t;&t;&t; * will lose some inodes and space,&n;&t;&t;&t;&t;&t; * but at least we won&squot;t hang.  Call&n;&t;&t;&t;&t;&t; * xlog_recover_clear_agi_bucket()&n;&t;&t;&t;&t;&t; * to perform a transaction to clear&n;&t;&t;&t;&t;&t; * the inode pointer in the bucket.&n;&t;&t;&t;&t;&t; */
id|xlog_recover_clear_agi_bucket
c_func
(paren
id|mp
comma
id|agno
comma
id|bucket
)paren
suffix:semicolon
id|agino
op_assign
id|NULLAGINO
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Reacquire the agibuffer and continue around&n;&t;&t;&t;&t; * the loop.&n;&t;&t;&t;&t; */
id|agibp
op_assign
id|xfs_buf_read
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISERROR
c_func
(paren
id|agibp
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_process_iunlinks(#2)&quot;
comma
id|log-&gt;l_mp
comma
id|agibp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
)brace
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agibp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_AGI_MAGIC
op_eq
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Release the buffer for the current agi so we can&n;&t;&t; * go on to the next one.&n;&t;&t; */
id|xfs_buf_relse
c_func
(paren
id|agibp
)paren
suffix:semicolon
)brace
id|mp-&gt;m_dmevmask
op_assign
id|mp_dmevmask
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|STATIC
r_void
DECL|function|xlog_pack_data_checksum
id|xlog_pack_data_checksum
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
id|uint
op_star
id|up
suffix:semicolon
id|uint
id|chksum
op_assign
l_int|0
suffix:semicolon
id|up
op_assign
(paren
id|uint
op_star
)paren
id|iclog-&gt;ic_datap
suffix:semicolon
multiline_comment|/* divide length by 4 to get # words */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|size
op_rshift
l_int|2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|chksum
op_xor_assign
id|INT_GET
c_func
(paren
op_star
id|up
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|up
op_increment
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|iclog-&gt;ic_header.h_chksum
comma
id|ARCH_CONVERT
comma
id|chksum
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|xlog_pack_data_checksum
mdefine_line|#define xlog_pack_data_checksum(log, iclog, size)
macro_line|#endif
multiline_comment|/*&n; * Stamp cycle number in every block&n; */
r_void
DECL|function|xlog_pack_data
id|xlog_pack_data
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_int
id|size
op_assign
id|iclog-&gt;ic_offset
op_plus
id|iclog-&gt;ic_roundoff
suffix:semicolon
id|uint
id|cycle_lsn
suffix:semicolon
id|xfs_caddr_t
id|dp
suffix:semicolon
id|xlog_in_core_2_t
op_star
id|xhdr
suffix:semicolon
id|xlog_pack_data_checksum
c_func
(paren
id|log
comma
id|iclog
comma
id|size
)paren
suffix:semicolon
id|cycle_lsn
op_assign
id|CYCLE_LSN_NOCONV
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dp
op_assign
id|iclog-&gt;ic_datap
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BTOBB
c_func
(paren
id|size
)paren
op_logical_and
id|i
OL
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iclog-&gt;ic_header.h_cycle_data
(braket
id|i
)braket
op_assign
op_star
(paren
id|uint
op_star
)paren
id|dp
suffix:semicolon
op_star
(paren
id|uint
op_star
)paren
id|dp
op_assign
id|cycle_lsn
suffix:semicolon
id|dp
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
)paren
(brace
id|xhdr
op_assign
(paren
id|xlog_in_core_2_t
op_star
)paren
op_amp
id|iclog-&gt;ic_header
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|BTOBB
c_func
(paren
id|size
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|i
op_div
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|k
op_assign
id|i
op_mod
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|xhdr
(braket
id|j
)braket
dot
id|hic_xheader.xh_cycle_data
(braket
id|k
)braket
op_assign
op_star
(paren
id|uint
op_star
)paren
id|dp
suffix:semicolon
op_star
(paren
id|uint
op_star
)paren
id|dp
op_assign
id|cycle_lsn
suffix:semicolon
id|dp
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|log-&gt;l_iclog_heads
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xhdr
(braket
id|i
)braket
dot
id|hic_xheader.xh_cycle
op_assign
id|cycle_lsn
suffix:semicolon
)brace
)brace
)brace
macro_line|#if defined(DEBUG) &amp;&amp; defined(XFS_LOUD_RECOVERY)
id|STATIC
r_void
DECL|function|xlog_unpack_data_checksum
id|xlog_unpack_data_checksum
c_func
(paren
id|xlog_rec_header_t
op_star
id|rhead
comma
id|xfs_caddr_t
id|dp
comma
id|xlog_t
op_star
id|log
)paren
(brace
id|uint
op_star
id|up
op_assign
(paren
id|uint
op_star
)paren
id|dp
suffix:semicolon
id|uint
id|chksum
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* divide length by 4 to get # words */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
op_rshift
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|chksum
op_xor_assign
id|INT_GET
c_func
(paren
op_star
id|up
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|up
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chksum
op_ne
id|INT_GET
c_func
(paren
id|rhead-&gt;h_chksum
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|rhead-&gt;h_chksum
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
(paren
id|log-&gt;l_flags
op_amp
id|XLOG_CHKSUM_MISMATCH
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;XFS: LogR chksum mismatch: was (0x%x) is (0x%x)&quot;
comma
id|INT_GET
c_func
(paren
id|rhead-&gt;h_chksum
comma
id|ARCH_CONVERT
)paren
comma
id|chksum
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;XFS: Disregard message if filesystem was created with non-DEBUG kernel&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;XFS: LogR this is a LogV2 filesystem&quot;
)paren
suffix:semicolon
)brace
id|log-&gt;l_flags
op_or_assign
id|XLOG_CHKSUM_MISMATCH
suffix:semicolon
)brace
)brace
)brace
macro_line|#else
DECL|macro|xlog_unpack_data_checksum
mdefine_line|#define xlog_unpack_data_checksum(rhead, dp, log)
macro_line|#endif
id|STATIC
r_void
DECL|function|xlog_unpack_data
id|xlog_unpack_data
c_func
(paren
id|xlog_rec_header_t
op_star
id|rhead
comma
id|xfs_caddr_t
id|dp
comma
id|xlog_t
op_star
id|log
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
id|xlog_in_core_2_t
op_star
id|xhdr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BTOBB
c_func
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_and
id|i
OL
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
id|uint
op_star
)paren
id|dp
op_assign
op_star
(paren
id|uint
op_star
)paren
op_amp
id|rhead-&gt;h_cycle_data
(braket
id|i
)braket
suffix:semicolon
id|dp
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
)paren
(brace
id|xhdr
op_assign
(paren
id|xlog_in_core_2_t
op_star
)paren
id|rhead
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|BTOBB
c_func
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|i
op_div
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|k
op_assign
id|i
op_mod
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
op_star
(paren
id|uint
op_star
)paren
id|dp
op_assign
id|xhdr
(braket
id|j
)braket
dot
id|hic_xheader.xh_cycle_data
(braket
id|k
)braket
suffix:semicolon
id|dp
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
)brace
id|xlog_unpack_data_checksum
c_func
(paren
id|rhead
comma
id|dp
comma
id|log
)paren
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xlog_valid_rec_header
id|xlog_valid_rec_header
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_rec_header_t
op_star
id|rhead
comma
id|xfs_daddr_t
id|blkno
)paren
(brace
r_int
id|hlen
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_magicno
comma
id|ARCH_CONVERT
)paren
op_ne
id|XLOG_HEADER_MAGIC_NUM
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_valid_rec_header(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|log-&gt;l_mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|INT_ISZERO
c_func
(paren
id|rhead-&gt;h_version
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_version
comma
id|ARCH_CONVERT
)paren
op_amp
(paren
op_complement
id|XLOG_VERSION_OKBITS
)paren
)paren
op_ne
l_int|0
)paren
)paren
)paren
(brace
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: %s: unrecognised log version (%d).&quot;
comma
id|__FUNCTION__
comma
id|INT_GET
c_func
(paren
id|rhead-&gt;h_version
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* LR body must have data or it wouldn&squot;t have been written */
id|hlen
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|hlen
op_le
l_int|0
op_logical_or
id|hlen
OG
id|INT_MAX
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_valid_rec_header(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|log-&gt;l_mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|blkno
OG
id|log-&gt;l_logBBsize
op_logical_or
id|blkno
OG
id|INT_MAX
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xlog_valid_rec_header(3)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|log-&gt;l_mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the log from tail to head and process the log records found.&n; * Handle the two cases where the tail and head are in the same cycle&n; * and where the active portion of the log wraps around the end of&n; * the physical log separately.  The pass parameter is passed through&n; * to the routines called to process the data and is not looked at&n; * here.&n; */
id|STATIC
r_int
DECL|function|xlog_do_recovery_pass
id|xlog_do_recovery_pass
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|head_blk
comma
id|xfs_daddr_t
id|tail_blk
comma
r_int
id|pass
)paren
(brace
id|xlog_rec_header_t
op_star
id|rhead
suffix:semicolon
id|xfs_daddr_t
id|blk_no
suffix:semicolon
id|xfs_caddr_t
id|bufaddr
comma
id|offset
suffix:semicolon
id|xfs_buf_t
op_star
id|hbp
comma
op_star
id|dbp
suffix:semicolon
r_int
id|error
op_assign
l_int|0
comma
id|h_size
suffix:semicolon
r_int
id|bblks
comma
id|split_bblks
suffix:semicolon
r_int
id|hblks
comma
id|split_hblks
comma
id|wrapped_hblks
suffix:semicolon
id|xlog_recover_t
op_star
id|rhash
(braket
id|XLOG_RHASH_SIZE
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|head_blk
op_ne
id|tail_blk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the header of the tail block and get the iclog buffer size from&n;&t; * h_size.  Use this to tell how many sectors make up the log header.&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * When using variable length iclogs, read first sector of&n;&t;&t; * iclog header and extract the header size from it.  Get a&n;&t;&t; * new hbp that is the correct size.&n;&t;&t; */
id|hbp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hbp
)paren
r_return
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|tail_blk
comma
l_int|1
comma
id|hbp
)paren
)paren
)paren
r_goto
id|bread_err1
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|tail_blk
comma
l_int|1
comma
id|hbp
)paren
suffix:semicolon
id|rhead
op_assign
(paren
id|xlog_rec_header_t
op_star
)paren
id|offset
suffix:semicolon
id|error
op_assign
id|xlog_valid_rec_header
c_func
(paren
id|log
comma
id|rhead
comma
id|tail_blk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err1
suffix:semicolon
id|h_size
op_assign
id|INT_GET
c_func
(paren
id|rhead-&gt;h_size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_version
comma
id|ARCH_CONVERT
)paren
op_amp
id|XLOG_VERSION_2
)paren
op_logical_and
(paren
id|h_size
OG
id|XLOG_HEADER_CYCLE_SIZE
)paren
)paren
(brace
id|hblks
op_assign
id|h_size
op_div
id|XLOG_HEADER_CYCLE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|h_size
op_mod
id|XLOG_HEADER_CYCLE_SIZE
)paren
id|hblks
op_increment
suffix:semicolon
id|xlog_put_bp
c_func
(paren
id|hbp
)paren
suffix:semicolon
id|hbp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
id|hblks
)paren
suffix:semicolon
)brace
r_else
(brace
id|hblks
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|log-&gt;l_sectbb_log
op_eq
l_int|0
)paren
suffix:semicolon
id|hblks
op_assign
l_int|1
suffix:semicolon
id|hbp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
id|h_size
op_assign
id|XLOG_BIG_RECORD_BSIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|hbp
)paren
r_return
id|ENOMEM
suffix:semicolon
id|dbp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
id|BTOBB
c_func
(paren
id|h_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dbp
)paren
(brace
id|xlog_put_bp
c_func
(paren
id|hbp
)paren
suffix:semicolon
r_return
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|rhash
comma
l_int|0
comma
r_sizeof
(paren
id|rhash
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail_blk
op_le
id|head_blk
)paren
(brace
r_for
c_loop
(paren
id|blk_no
op_assign
id|tail_blk
suffix:semicolon
id|blk_no
OL
id|head_blk
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
comma
id|hblks
comma
id|hbp
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
comma
id|hblks
comma
id|hbp
)paren
suffix:semicolon
id|rhead
op_assign
(paren
id|xlog_rec_header_t
op_star
)paren
id|offset
suffix:semicolon
id|error
op_assign
id|xlog_valid_rec_header
c_func
(paren
id|log
comma
id|rhead
comma
id|blk_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err2
suffix:semicolon
multiline_comment|/* blocks in data section */
id|bblks
op_assign
(paren
r_int
)paren
id|BTOBB
c_func
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
op_plus
id|hblks
comma
id|bblks
comma
id|dbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
op_plus
id|hblks
comma
id|bblks
comma
id|dbp
)paren
suffix:semicolon
id|xlog_unpack_data
c_func
(paren
id|rhead
comma
id|offset
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_process_data
c_func
(paren
id|log
comma
id|rhash
comma
id|rhead
comma
id|offset
comma
id|pass
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|blk_no
op_add_assign
id|bblks
op_plus
id|hblks
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Perform recovery around the end of the physical log.&n;&t;&t; * When the head is not on the same cycle number as the tail,&n;&t;&t; * we can&squot;t do a sequential recovery as above.&n;&t;&t; */
id|blk_no
op_assign
id|tail_blk
suffix:semicolon
r_while
c_loop
(paren
id|blk_no
OL
id|log-&gt;l_logBBsize
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Check for header wrapping around physical end-of-log&n;&t;&t;&t; */
id|offset
op_assign
l_int|NULL
suffix:semicolon
id|split_hblks
op_assign
l_int|0
suffix:semicolon
id|wrapped_hblks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_no
op_plus
id|hblks
op_le
id|log-&gt;l_logBBsize
)paren
(brace
multiline_comment|/* Read header in one read */
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
comma
id|hblks
comma
id|hbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
comma
id|hblks
comma
id|hbp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This LR is split across physical log end */
r_if
c_cond
(paren
id|blk_no
op_ne
id|log-&gt;l_logBBsize
)paren
(brace
multiline_comment|/* some data before physical log end */
id|ASSERT
c_func
(paren
id|blk_no
op_le
id|INT_MAX
)paren
suffix:semicolon
id|split_hblks
op_assign
id|log-&gt;l_logBBsize
op_minus
(paren
r_int
)paren
id|blk_no
suffix:semicolon
id|ASSERT
c_func
(paren
id|split_hblks
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
comma
id|split_hblks
comma
id|hbp
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
comma
id|split_hblks
comma
id|hbp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Note: this black magic still works with&n;&t;&t;&t;&t; * large sector sizes (non-512) only because:&n;&t;&t;&t;&t; * - we increased the buffer size originally&n;&t;&t;&t;&t; *   by 1 sector giving us enough extra space&n;&t;&t;&t;&t; *   for the second read;&n;&t;&t;&t;&t; * - the log start is guaranteed to be sector&n;&t;&t;&t;&t; *   aligned;&n;&t;&t;&t;&t; * - we read the log end (LR header start)&n;&t;&t;&t;&t; *   _first_, then the log start (LR header end)&n;&t;&t;&t;&t; *   - order is important.&n;&t;&t;&t;&t; */
id|bufaddr
op_assign
id|XFS_BUF_PTR
c_func
(paren
id|hbp
)paren
suffix:semicolon
id|XFS_BUF_SET_PTR
c_func
(paren
id|hbp
comma
id|bufaddr
op_plus
id|BBTOB
c_func
(paren
id|split_hblks
)paren
comma
id|BBTOB
c_func
(paren
id|hblks
op_minus
id|split_hblks
)paren
)paren
suffix:semicolon
id|wrapped_hblks
op_assign
id|hblks
op_minus
id|split_hblks
suffix:semicolon
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
l_int|0
comma
id|wrapped_hblks
comma
id|hbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err2
suffix:semicolon
id|XFS_BUF_SET_PTR
c_func
(paren
id|hbp
comma
id|bufaddr
comma
id|BBTOB
c_func
(paren
id|hblks
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
l_int|0
comma
id|wrapped_hblks
comma
id|hbp
)paren
suffix:semicolon
)brace
id|rhead
op_assign
(paren
id|xlog_rec_header_t
op_star
)paren
id|offset
suffix:semicolon
id|error
op_assign
id|xlog_valid_rec_header
c_func
(paren
id|log
comma
id|rhead
comma
id|split_hblks
ques
c_cond
id|blk_no
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err2
suffix:semicolon
id|bblks
op_assign
(paren
r_int
)paren
id|BTOBB
c_func
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|blk_no
op_add_assign
id|hblks
suffix:semicolon
multiline_comment|/* Read in data for log record */
r_if
c_cond
(paren
id|blk_no
op_plus
id|bblks
op_le
id|log-&gt;l_logBBsize
)paren
(brace
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
comma
id|bblks
comma
id|dbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
comma
id|bblks
comma
id|dbp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This log record is split across the&n;&t;&t;&t;&t; * physical end of log */
id|offset
op_assign
l_int|NULL
suffix:semicolon
id|split_bblks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blk_no
op_ne
id|log-&gt;l_logBBsize
)paren
(brace
multiline_comment|/* some data is before the physical&n;&t;&t;&t;&t;&t; * end of log */
id|ASSERT
c_func
(paren
op_logical_neg
id|wrapped_hblks
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk_no
op_le
id|INT_MAX
)paren
suffix:semicolon
id|split_bblks
op_assign
id|log-&gt;l_logBBsize
op_minus
(paren
r_int
)paren
id|blk_no
suffix:semicolon
id|ASSERT
c_func
(paren
id|split_bblks
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
comma
id|split_bblks
comma
id|dbp
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
comma
id|split_bblks
comma
id|dbp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Note: this black magic still works with&n;&t;&t;&t;&t; * large sector sizes (non-512) only because:&n;&t;&t;&t;&t; * - we increased the buffer size originally&n;&t;&t;&t;&t; *   by 1 sector giving us enough extra space&n;&t;&t;&t;&t; *   for the second read;&n;&t;&t;&t;&t; * - the log start is guaranteed to be sector&n;&t;&t;&t;&t; *   aligned;&n;&t;&t;&t;&t; * - we read the log end (LR header start)&n;&t;&t;&t;&t; *   _first_, then the log start (LR header end)&n;&t;&t;&t;&t; *   - order is important.&n;&t;&t;&t;&t; */
id|bufaddr
op_assign
id|XFS_BUF_PTR
c_func
(paren
id|dbp
)paren
suffix:semicolon
id|XFS_BUF_SET_PTR
c_func
(paren
id|dbp
comma
id|bufaddr
op_plus
id|BBTOB
c_func
(paren
id|split_bblks
)paren
comma
id|BBTOB
c_func
(paren
id|bblks
op_minus
id|split_bblks
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|wrapped_hblks
comma
id|bblks
op_minus
id|split_bblks
comma
id|dbp
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|XFS_BUF_SET_PTR
c_func
(paren
id|dbp
comma
id|bufaddr
comma
id|h_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|wrapped_hblks
comma
id|bblks
op_minus
id|split_bblks
comma
id|dbp
)paren
suffix:semicolon
)brace
id|xlog_unpack_data
c_func
(paren
id|rhead
comma
id|offset
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_process_data
c_func
(paren
id|log
comma
id|rhash
comma
id|rhead
comma
id|offset
comma
id|pass
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|blk_no
op_add_assign
id|bblks
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|blk_no
op_ge
id|log-&gt;l_logBBsize
)paren
suffix:semicolon
id|blk_no
op_sub_assign
id|log-&gt;l_logBBsize
suffix:semicolon
multiline_comment|/* read first part of physical log */
r_while
c_loop
(paren
id|blk_no
OL
id|head_blk
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
comma
id|hblks
comma
id|hbp
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
comma
id|hblks
comma
id|hbp
)paren
suffix:semicolon
id|rhead
op_assign
(paren
id|xlog_rec_header_t
op_star
)paren
id|offset
suffix:semicolon
id|error
op_assign
id|xlog_valid_rec_header
c_func
(paren
id|log
comma
id|rhead
comma
id|blk_no
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|bread_err2
suffix:semicolon
id|bblks
op_assign
(paren
r_int
)paren
id|BTOBB
c_func
(paren
id|INT_GET
c_func
(paren
id|rhead-&gt;h_len
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_bread
c_func
(paren
id|log
comma
id|blk_no
op_plus
id|hblks
comma
id|bblks
comma
id|dbp
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|offset
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|blk_no
op_plus
id|hblks
comma
id|bblks
comma
id|dbp
)paren
suffix:semicolon
id|xlog_unpack_data
c_func
(paren
id|rhead
comma
id|offset
comma
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_recover_process_data
c_func
(paren
id|log
comma
id|rhash
comma
id|rhead
comma
id|offset
comma
id|pass
)paren
)paren
)paren
r_goto
id|bread_err2
suffix:semicolon
id|blk_no
op_add_assign
id|bblks
op_plus
id|hblks
suffix:semicolon
)brace
)brace
id|bread_err2
suffix:colon
id|xlog_put_bp
c_func
(paren
id|dbp
)paren
suffix:semicolon
id|bread_err1
suffix:colon
id|xlog_put_bp
c_func
(paren
id|hbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the recovery of the log.  We actually do this in two phases.&n; * The two passes are necessary in order to implement the function&n; * of cancelling a record written into the log.  The first pass&n; * determines those things which have been cancelled, and the&n; * second pass replays log items normally except for those which&n; * have been cancelled.  The handling of the replay and cancellations&n; * takes place in the log item type specific routines.&n; *&n; * The table of items which have cancel records in the log is allocated&n; * and freed at this level, since only here do we know when all of&n; * the log recovery has been completed.&n; */
id|STATIC
r_int
DECL|function|xlog_do_log_recovery
id|xlog_do_log_recovery
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|head_blk
comma
id|xfs_daddr_t
id|tail_blk
)paren
(brace
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|head_blk
op_ne
id|tail_blk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First do a pass to find all of the cancelled buf log items.&n;&t; * Store them in the buf_cancel_table for use in the second pass.&n;&t; */
id|log-&gt;l_buf_cancel_table
op_assign
(paren
id|xfs_buf_cancel_t
op_star
op_star
)paren
id|kmem_zalloc
c_func
(paren
id|XLOG_BC_TABLE_SIZE
op_star
r_sizeof
(paren
id|xfs_buf_cancel_t
op_star
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|error
op_assign
id|xlog_do_recovery_pass
c_func
(paren
id|log
comma
id|head_blk
comma
id|tail_blk
comma
id|XLOG_RECOVER_PASS1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|kmem_free
c_func
(paren
id|log-&gt;l_buf_cancel_table
comma
id|XLOG_BC_TABLE_SIZE
op_star
r_sizeof
(paren
id|xfs_buf_cancel_t
op_star
)paren
)paren
suffix:semicolon
id|log-&gt;l_buf_cancel_table
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Then do a second pass to actually recover the items in the log.&n;&t; * When it is complete free the table of buf cancel items.&n;&t; */
id|error
op_assign
id|xlog_do_recovery_pass
c_func
(paren
id|log
comma
id|head_blk
comma
id|tail_blk
comma
id|XLOG_RECOVER_PASS2
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XLOG_BC_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|ASSERT
c_func
(paren
id|log-&gt;l_buf_cancel_table
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
id|kmem_free
c_func
(paren
id|log-&gt;l_buf_cancel_table
comma
id|XLOG_BC_TABLE_SIZE
op_star
r_sizeof
(paren
id|xfs_buf_cancel_t
op_star
)paren
)paren
suffix:semicolon
id|log-&gt;l_buf_cancel_table
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the actual recovery&n; */
id|STATIC
r_int
DECL|function|xlog_do_recover
id|xlog_do_recover
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_daddr_t
id|head_blk
comma
id|xfs_daddr_t
id|tail_blk
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
multiline_comment|/*&n;&t; * First replay the images in the log.&n;&t; */
id|error
op_assign
id|xlog_do_log_recovery
c_func
(paren
id|log
comma
id|head_blk
comma
id|tail_blk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|XFS_bflush
c_func
(paren
id|log-&gt;l_mp-&gt;m_ddev_targp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If IO errors happened during recovery, bail out.&n;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|log-&gt;l_mp
)paren
)paren
(brace
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We now update the tail_lsn since much of the recovery has completed&n;&t; * and there may be space available to use.  If there were no extent&n;&t; * or iunlinks, we can free up the entire log and set the tail_lsn to&n;&t; * be the last_sync_lsn.  This was set in xlog_find_tail to be the&n;&t; * lsn of the last known good LR on disk.  If there are extent frees&n;&t; * or iunlinks they will have some entries in the AIL; so we look at&n;&t; * the AIL to determine how to set the tail_lsn.&n;&t; */
id|xlog_assign_tail_lsn
c_func
(paren
id|log-&gt;l_mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that we&squot;ve finished replaying all buffer and inode&n;&t; * updates, re-read in the superblock.&n;&t; */
id|bp
op_assign
id|xfs_getsb
c_func
(paren
id|log-&gt;l_mp
comma
l_int|0
)paren
suffix:semicolon
id|XFS_BUF_UNDONE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_READ
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfsbdstrat
c_func
(paren
id|log-&gt;l_mp
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iowait
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_do_recover&quot;
comma
id|log-&gt;l_mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Convert superblock from on-disk format */
id|sbp
op_assign
op_amp
id|log-&gt;l_mp-&gt;m_sb
suffix:semicolon
id|xfs_xlatesb
c_func
(paren
id|XFS_BUF_TO_SBP
c_func
(paren
id|bp
)paren
comma
id|sbp
comma
l_int|1
comma
id|ARCH_CONVERT
comma
id|XFS_SB_ALL_BITS
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|sbp-&gt;sb_magicnum
op_eq
id|XFS_SB_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_SB_GOOD_VERSION
c_func
(paren
id|sbp
)paren
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xlog_recover_check_summary
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* Normal transactions can now occur */
id|log-&gt;l_flags
op_and_assign
op_complement
id|XLOG_ACTIVE_RECOVERY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform recovery and re-initialize some log variables in xlog_find_tail.&n; *&n; * Return error or zero.&n; */
r_int
DECL|function|xlog_recover
id|xlog_recover
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|readonly
)paren
(brace
id|xfs_daddr_t
id|head_blk
comma
id|tail_blk
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* find the tail of the log */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_find_tail
c_func
(paren
id|log
comma
op_amp
id|head_blk
comma
op_amp
id|tail_blk
comma
id|readonly
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|tail_blk
op_ne
id|head_blk
)paren
(brace
multiline_comment|/* There used to be a comment here:&n;&t;&t; *&n;&t;&t; * disallow recovery on read-only mounts.  note -- mount&n;&t;&t; * checks for ENOSPC and turns it into an intelligent&n;&t;&t; * error message.&n;&t;&t; * ...but this is no longer true.  Now, unless you specify&n;&t;&t; * NORECOVERY (in which case this function would never be&n;&t;&t; * called), we just go ahead and recover.  We do this all&n;&t;&t; * under the vfs layer, so we can get away with it unless&n;&t;&t; * the device itself is read-only, in which case we fail.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dev_is_read_only
c_func
(paren
id|log-&gt;l_mp
comma
l_string|&quot;recovery required&quot;
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Starting XFS recovery on filesystem: %s (dev: %s)&quot;
comma
id|log-&gt;l_mp-&gt;m_fsname
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|log-&gt;l_targ
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xlog_do_recover
c_func
(paren
id|log
comma
id|head_blk
comma
id|tail_blk
)paren
suffix:semicolon
id|log-&gt;l_flags
op_or_assign
id|XLOG_RECOVERY_NEEDED
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * In the first part of recovery we replay inodes and buffers and build&n; * up the list of extent free items which need to be processed.  Here&n; * we process the extent free items and clean up the on disk unlinked&n; * inode lists.  This is separated from the first part of recovery so&n; * that the root and real-time bitmap inodes can be read in from disk in&n; * between the two stages.  This is necessary so that we can free space&n; * in the real-time portion of the file system.&n; */
r_int
DECL|function|xlog_recover_finish
id|xlog_recover_finish
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|mfsi_flags
)paren
(brace
multiline_comment|/*&n;&t; * Now we&squot;re ready to do the transactions needed for the&n;&t; * rest of recovery.  Start with completing all the extent&n;&t; * free intent records and then process the unlinked inode&n;&t; * lists.  At this point, we essentially run in normal mode&n;&t; * except that we&squot;re still performing recovery actions&n;&t; * rather than accepting new requests.&n;&t; */
r_if
c_cond
(paren
id|log-&gt;l_flags
op_amp
id|XLOG_RECOVERY_NEEDED
)paren
(brace
id|xlog_recover_process_efis
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Sync the log to get all the EFIs out of the AIL.&n;&t;&t; * This isn&squot;t absolutely necessary, but it helps in&n;&t;&t; * case the unlink transactions would have problems&n;&t;&t; * pushing the EFIs out of the way.&n;&t;&t; */
id|xfs_log_force
c_func
(paren
id|log-&gt;l_mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
(paren
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mfsi_flags
op_amp
id|XFS_MFSI_NOUNLINK
)paren
op_eq
l_int|0
)paren
(brace
id|xlog_recover_process_iunlinks
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
id|xlog_recover_check_summary
c_func
(paren
id|log
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Ending XFS recovery on filesystem: %s (dev: %s)&quot;
comma
id|log-&gt;l_mp-&gt;m_fsname
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|log-&gt;l_targ
)paren
)paren
suffix:semicolon
id|log-&gt;l_flags
op_and_assign
op_complement
id|XLOG_RECOVERY_NEEDED
suffix:semicolon
)brace
r_else
(brace
id|cmn_err
c_func
(paren
id|CE_DEBUG
comma
l_string|&quot;!Ending clean XFS mount for filesystem: %s&quot;
comma
id|log-&gt;l_mp-&gt;m_fsname
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(DEBUG)
multiline_comment|/*&n; * Read all of the agf and agi counters and check that they&n; * are consistent with the superblock counters.&n; */
r_void
DECL|function|xlog_recover_check_summary
id|xlog_recover_check_summary
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_agf_t
op_star
id|agfp
suffix:semicolon
id|xfs_agi_t
op_star
id|agip
suffix:semicolon
id|xfs_buf_t
op_star
id|agfbp
suffix:semicolon
id|xfs_buf_t
op_star
id|agibp
suffix:semicolon
id|xfs_daddr_t
id|agfdaddr
suffix:semicolon
id|xfs_daddr_t
id|agidaddr
suffix:semicolon
id|xfs_buf_t
op_star
id|sbbp
suffix:semicolon
macro_line|#ifdef XFS_LOUD_RECOVERY
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
macro_line|#endif
id|xfs_agnumber_t
id|agno
suffix:semicolon
id|__uint64_t
id|freeblks
suffix:semicolon
id|__uint64_t
id|itotal
suffix:semicolon
id|__uint64_t
id|ifree
suffix:semicolon
id|mp
op_assign
id|log-&gt;l_mp
suffix:semicolon
id|freeblks
op_assign
l_int|0LL
suffix:semicolon
id|itotal
op_assign
l_int|0LL
suffix:semicolon
id|ifree
op_assign
l_int|0LL
suffix:semicolon
r_for
c_loop
(paren
id|agno
op_assign
l_int|0
suffix:semicolon
id|agno
OL
id|mp-&gt;m_sb.sb_agcount
suffix:semicolon
id|agno
op_increment
)paren
(brace
id|agfdaddr
op_assign
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGF_DADDR
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|agfbp
op_assign
id|xfs_buf_read
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|agfdaddr
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISERROR
c_func
(paren
id|agfbp
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_check_summary(agf)&quot;
comma
id|mp
comma
id|agfbp
comma
id|agfdaddr
)paren
suffix:semicolon
)brace
id|agfp
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agfbp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_AGF_MAGIC
op_eq
id|INT_GET
c_func
(paren
id|agfp-&gt;agf_magicnum
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_AGF_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|agfp-&gt;agf_versionnum
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agfp-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
op_eq
id|agno
)paren
suffix:semicolon
id|freeblks
op_add_assign
id|INT_GET
c_func
(paren
id|agfp-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|agfp-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|agfbp
)paren
suffix:semicolon
id|agidaddr
op_assign
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|agibp
op_assign
id|xfs_buf_read
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|agidaddr
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BUF_ISERROR
c_func
(paren
id|agibp
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_recover_check_summary(agi)&quot;
comma
id|mp
comma
id|agibp
comma
id|agidaddr
)paren
suffix:semicolon
)brace
id|agip
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agibp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_AGI_MAGIC
op_eq
id|INT_GET
c_func
(paren
id|agip-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_AGI_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|agip-&gt;agi_versionnum
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agip-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
op_eq
id|agno
)paren
suffix:semicolon
id|itotal
op_add_assign
id|INT_GET
c_func
(paren
id|agip-&gt;agi_count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ifree
op_add_assign
id|INT_GET
c_func
(paren
id|agip-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|agibp
)paren
suffix:semicolon
)brace
id|sbbp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef XFS_LOUD_RECOVERY
id|sbp
op_assign
op_amp
id|mp-&gt;m_sb
suffix:semicolon
id|xfs_xlatesb
c_func
(paren
id|XFS_BUF_TO_SBP
c_func
(paren
id|sbbp
)paren
comma
id|sbp
comma
l_int|1
comma
id|ARCH_CONVERT
comma
id|XFS_SB_ALL_BITS
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;xlog_recover_check_summary: sb_icount %Lu itotal %Lu&quot;
comma
id|sbp-&gt;sb_icount
comma
id|itotal
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;xlog_recover_check_summary: sb_ifree %Lu itotal %Lu&quot;
comma
id|sbp-&gt;sb_ifree
comma
id|ifree
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;xlog_recover_check_summary: sb_fdblocks %Lu freeblks %Lu&quot;
comma
id|sbp-&gt;sb_fdblocks
comma
id|freeblks
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * This is turned off until I account for the allocation&n;&t; * btree blocks which live in free space.&n;&t; */
id|ASSERT
c_func
(paren
id|sbp-&gt;sb_icount
op_eq
id|itotal
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|sbp-&gt;sb_ifree
op_eq
id|ifree
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|sbp-&gt;sb_fdblocks
op_eq
id|freeblks
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|xfs_buf_relse
c_func
(paren
id|sbbp
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
eof
