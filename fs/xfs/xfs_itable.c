multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_itable.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#ifndef HAVE_USERACC
DECL|macro|useracc
mdefine_line|#define useracc(ubuffer, size, flags, foo) (0)
DECL|macro|unuseracc
mdefine_line|#define unuseracc(ubuffer, size, flags)
macro_line|#endif
multiline_comment|/*&n; * Return stat information for one inode.&n; * Return 0 if ok, else errno.&n; */
r_int
multiline_comment|/* error status */
DECL|function|xfs_bulkstat_one
id|xfs_bulkstat_one
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point for filesystem */
id|xfs_ino_t
id|ino
comma
multiline_comment|/* inode number to get data for */
r_void
id|__user
op_star
id|buffer
comma
multiline_comment|/* buffer to place output in */
r_int
id|ubsize
comma
multiline_comment|/* size of buffer */
r_void
op_star
id|private_data
comma
multiline_comment|/* my private data */
id|xfs_daddr_t
id|bno
comma
multiline_comment|/* starting bno of inode cluster */
r_int
op_star
id|ubused
comma
multiline_comment|/* bytes used by me */
r_void
op_star
id|dibuff
comma
multiline_comment|/* on-disk inode buffer */
r_int
op_star
id|stat
)paren
multiline_comment|/* BULKSTAT_RV_... */
(brace
id|xfs_bstat_t
op_star
id|buf
suffix:semicolon
multiline_comment|/* return buffer */
r_int
id|error
suffix:semicolon
multiline_comment|/* error value */
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
multiline_comment|/* dinode inode pointer */
id|xfs_dinode_core_t
op_star
id|dic
suffix:semicolon
multiline_comment|/* dinode core info pointer */
id|xfs_inode_t
op_star
id|ip
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* incore inode pointer */
id|xfs_arch_t
id|arch
suffix:semicolon
multiline_comment|/* these are set according to      */
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|dibuff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
id|ino
op_eq
id|mp-&gt;m_sb.sb_rbmino
op_logical_or
id|ino
op_eq
id|mp-&gt;m_sb.sb_rsumino
op_logical_or
(paren
id|XFS_SB_VERSION_HASQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
op_logical_and
(paren
id|ino
op_eq
id|mp-&gt;m_sb.sb_uquotino
op_logical_or
id|ino
op_eq
id|mp-&gt;m_sb.sb_gquotino
)paren
)paren
)paren
(brace
op_star
id|stat
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ubsize
OL
r_sizeof
(paren
op_star
id|buf
)paren
)paren
(brace
op_star
id|stat
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOMEM
)paren
suffix:semicolon
)brace
id|buf
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|buf
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dip
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* We&squot;re not being passed a pointer to a dinode.  This happens&n;&t;&t; * if BULKSTAT_FG_IGET is selected.  Do the iget.&n;&t;&t; */
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ino
comma
l_int|0
comma
id|XFS_ILOCK_SHARED
comma
op_amp
id|ip
comma
id|bno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
op_star
id|stat
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_blkno
op_ne
(paren
id|xfs_daddr_t
)paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
(brace
id|xfs_iput_new
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
op_star
id|stat
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
id|kmem_free
c_func
(paren
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
id|dic
op_assign
op_amp
id|ip-&gt;i_d
suffix:semicolon
id|arch
op_assign
id|ARCH_NOCONVERT
suffix:semicolon
multiline_comment|/* in-core! */
id|ASSERT
c_func
(paren
id|dic
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* xfs_iget returns the following without needing&n;&t;&t; * further change.&n;&t;&t; */
id|buf-&gt;bs_nlink
op_assign
id|dic-&gt;di_nlink
suffix:semicolon
id|buf-&gt;bs_projid
op_assign
id|dic-&gt;di_projid
suffix:semicolon
)brace
r_else
(brace
id|dic
op_assign
op_amp
id|dip-&gt;di_core
suffix:semicolon
id|ASSERT
c_func
(paren
id|dic
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* buffer dinode_core is in on-disk arch */
id|arch
op_assign
id|ARCH_CONVERT
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The inode format changed when we moved the link count and&n;&t;&t; * made it 32 bits long.  If this is an old format inode,&n;&t;&t; * convert it in memory to look like a new one.  If it gets&n;&t;&t; * flushed to disk we will convert back before flushing or&n;&t;&t; * logging it.  We zero out the new projid field and the old link&n;&t;&t; * count field.  We&squot;ll handle clearing the pad field (the remains&n;&t;&t; * of the old uuid field) when we actually convert the inode to&n;&t;&t; * the new format. We don&squot;t change the version number so that we&n;&t;&t; * can distinguish this from a real new format inode.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dic-&gt;di_version
comma
id|arch
)paren
op_eq
id|XFS_DINODE_VERSION_1
)paren
(brace
id|buf-&gt;bs_nlink
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_onlink
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_projid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|buf-&gt;bs_nlink
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_nlink
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_projid
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_projid
comma
id|arch
)paren
suffix:semicolon
)brace
)brace
id|buf-&gt;bs_ino
op_assign
id|ino
suffix:semicolon
id|buf-&gt;bs_mode
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_mode
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_uid
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_uid
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_gid
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_gid
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_size
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_size
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_atime.tv_sec
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_atime.t_sec
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_atime.tv_nsec
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_atime.t_nsec
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_mtime.tv_sec
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_mtime.t_sec
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_mtime.tv_nsec
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_mtime.t_nsec
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_ctime.tv_sec
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_ctime.t_sec
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_ctime.tv_nsec
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_ctime.t_nsec
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_xflags
op_assign
id|xfs_dic2xflags
c_func
(paren
id|dic
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_extsize
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_extsize
comma
id|arch
)paren
op_lshift
id|mp-&gt;m_sb.sb_blocklog
suffix:semicolon
id|buf-&gt;bs_extents
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_nextents
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_gen
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_gen
comma
id|arch
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buf-&gt;bs_pad
comma
l_int|0
comma
r_sizeof
(paren
id|buf-&gt;bs_pad
)paren
)paren
suffix:semicolon
id|buf-&gt;bs_dmevmask
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_dmevmask
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_dmstate
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_dmstate
comma
id|arch
)paren
suffix:semicolon
id|buf-&gt;bs_aextents
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_anextents
comma
id|arch
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|INT_GET
c_func
(paren
id|dic-&gt;di_format
comma
id|arch
)paren
)paren
(brace
r_case
id|XFS_DINODE_FMT_DEV
suffix:colon
r_if
c_cond
(paren
id|ip
)paren
(brace
id|buf-&gt;bs_rdev
op_assign
id|ip-&gt;i_df.if_u2.if_rdev
suffix:semicolon
)brace
r_else
(brace
id|buf-&gt;bs_rdev
op_assign
id|INT_GET
c_func
(paren
id|dip-&gt;di_u.di_dev
comma
id|arch
)paren
suffix:semicolon
)brace
id|buf-&gt;bs_blksize
op_assign
id|BLKDEV_IOSIZE
suffix:semicolon
id|buf-&gt;bs_blocks
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_LOCAL
suffix:colon
r_case
id|XFS_DINODE_FMT_UUID
suffix:colon
id|buf-&gt;bs_rdev
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;bs_blksize
op_assign
id|mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|buf-&gt;bs_blocks
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|buf-&gt;bs_rdev
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;bs_blksize
op_assign
id|mp-&gt;m_sb.sb_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|ip
)paren
(brace
id|buf-&gt;bs_blocks
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_nblocks
comma
id|arch
)paren
op_plus
id|ip-&gt;i_delayed_blks
suffix:semicolon
)brace
r_else
(brace
id|buf-&gt;bs_blocks
op_assign
id|INT_GET
c_func
(paren
id|dic-&gt;di_nblocks
comma
id|arch
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip
)paren
(brace
id|xfs_iput
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
)paren
(brace
id|kmem_free
c_func
(paren
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
op_star
id|stat
op_assign
id|BULKSTAT_RV_NOTHING
suffix:semicolon
r_return
id|EFAULT
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
op_star
id|stat
op_assign
id|BULKSTAT_RV_DIDONE
suffix:semicolon
r_if
c_cond
(paren
id|ubused
)paren
op_star
id|ubused
op_assign
r_sizeof
(paren
op_star
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return stat information in bulk (by-inode) for the filesystem.&n; */
r_int
multiline_comment|/* error status */
DECL|function|xfs_bulkstat
id|xfs_bulkstat
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point for filesystem */
id|xfs_ino_t
op_star
id|lastinop
comma
multiline_comment|/* last inode returned */
r_int
op_star
id|ubcountp
comma
multiline_comment|/* size of buffer/count returned */
id|bulkstat_one_pf
id|formatter
comma
multiline_comment|/* func that&squot;d fill a single buf */
r_void
op_star
id|private_data
comma
multiline_comment|/* private data for formatter */
r_int
id|statstruct_size
comma
multiline_comment|/* sizeof struct filling */
r_char
id|__user
op_star
id|ubuffer
comma
multiline_comment|/* buffer with inode stats */
r_int
id|flags
comma
multiline_comment|/* defined in xfs_itable.h */
r_int
op_star
id|done
)paren
multiline_comment|/* 1 if there&squot;re more stats to get */
(brace
id|xfs_agblock_t
id|agbno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* allocation group block number */
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* agi header buffer */
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
multiline_comment|/* agi header data */
id|xfs_agino_t
id|agino
suffix:semicolon
multiline_comment|/* inode # in allocation group */
id|xfs_agnumber_t
id|agno
suffix:semicolon
multiline_comment|/* allocation group number */
id|xfs_daddr_t
id|bno
suffix:semicolon
multiline_comment|/* inode cluster start daddr */
r_int
id|chunkidx
suffix:semicolon
multiline_comment|/* current index into inode chunk */
r_int
id|clustidx
suffix:semicolon
multiline_comment|/* current index into inode cluster */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* btree cursor for ialloc btree */
r_int
id|end_of_ag
suffix:semicolon
multiline_comment|/* set if we&squot;ve seen the ag end */
r_int
id|error
suffix:semicolon
multiline_comment|/* error code */
r_int
id|fmterror
suffix:semicolon
multiline_comment|/* bulkstat formatter result */
id|__int32_t
id|gcnt
suffix:semicolon
multiline_comment|/* current btree rec&squot;s count */
id|xfs_inofree_t
id|gfree
suffix:semicolon
multiline_comment|/* current btree rec&squot;s free mask */
id|xfs_agino_t
id|gino
suffix:semicolon
multiline_comment|/* current btree rec&squot;s start inode */
r_int
id|i
suffix:semicolon
multiline_comment|/* loop index */
r_int
id|icount
suffix:semicolon
multiline_comment|/* count of inodes good in irbuf */
id|xfs_ino_t
id|ino
suffix:semicolon
multiline_comment|/* inode number (filesystem) */
id|xfs_inobt_rec_t
op_star
id|irbp
suffix:semicolon
multiline_comment|/* current irec buffer pointer */
id|xfs_inobt_rec_t
op_star
id|irbuf
suffix:semicolon
multiline_comment|/* start of irec buffer */
id|xfs_inobt_rec_t
op_star
id|irbufend
suffix:semicolon
multiline_comment|/* end of good irec buffer entries */
id|xfs_ino_t
id|lastino
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* last inode number returned */
r_int
id|nbcluster
suffix:semicolon
multiline_comment|/* # of blocks in a cluster */
r_int
id|nicluster
suffix:semicolon
multiline_comment|/* # of inodes in a cluster */
r_int
id|nimask
suffix:semicolon
multiline_comment|/* mask for inode clusters */
r_int
id|nirbuf
suffix:semicolon
multiline_comment|/* size of irbuf */
r_int
id|rval
suffix:semicolon
multiline_comment|/* return value error code */
r_int
id|tmp
suffix:semicolon
multiline_comment|/* result value from btree calls */
r_int
id|ubcount
suffix:semicolon
multiline_comment|/* size of user&squot;s buffer */
r_int
id|ubleft
suffix:semicolon
multiline_comment|/* bytes left in user&squot;s buffer */
r_char
id|__user
op_star
id|ubufp
suffix:semicolon
multiline_comment|/* pointer into user&squot;s buffer */
r_int
id|ubelem
suffix:semicolon
multiline_comment|/* spaces used in user&squot;s buffer */
r_int
id|ubused
suffix:semicolon
multiline_comment|/* bytes used by formatter */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* ptr to on-disk inode cluster buf */
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
multiline_comment|/* ptr into bp for specific inode */
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/* ptr to in-core inode struct */
multiline_comment|/*&n;&t; * Get the last inode value, see if there&squot;s nothing to do.&n;&t; */
id|ino
op_assign
(paren
id|xfs_ino_t
)paren
op_star
id|lastinop
suffix:semicolon
id|dip
op_assign
l_int|NULL
suffix:semicolon
id|agno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|agino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agno
op_ge
id|mp-&gt;m_sb.sb_agcount
op_logical_or
id|ino
op_ne
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
)paren
(brace
op_star
id|done
op_assign
l_int|1
suffix:semicolon
op_star
id|ubcountp
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ubcount
op_assign
op_star
id|ubcountp
suffix:semicolon
multiline_comment|/* statstruct&squot;s */
id|ubleft
op_assign
id|ubcount
op_star
id|statstruct_size
suffix:semicolon
multiline_comment|/* bytes */
op_star
id|ubcountp
op_assign
id|ubelem
op_assign
l_int|0
suffix:semicolon
op_star
id|done
op_assign
l_int|0
suffix:semicolon
id|fmterror
op_assign
l_int|0
suffix:semicolon
id|ubufp
op_assign
id|ubuffer
suffix:semicolon
id|nicluster
op_assign
id|mp-&gt;m_sb.sb_blocksize
op_ge
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|mp
)paren
ques
c_cond
id|mp-&gt;m_sb.sb_inopblock
suffix:colon
(paren
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|mp
)paren
op_rshift
id|mp-&gt;m_sb.sb_inodelog
)paren
suffix:semicolon
id|nimask
op_assign
op_complement
(paren
id|nicluster
op_minus
l_int|1
)paren
suffix:semicolon
id|nbcluster
op_assign
id|nicluster
op_rshift
id|mp-&gt;m_sb.sb_inopblog
suffix:semicolon
multiline_comment|/*&n;&t; * Lock down the user&squot;s buffer. If a buffer was not sent, as in the case&n;&t; * disk quota code calls here, we skip this.&n;&t; */
r_if
c_cond
(paren
id|ubuffer
op_logical_and
(paren
id|error
op_assign
id|useracc
c_func
(paren
id|ubuffer
comma
id|ubcount
op_star
id|statstruct_size
comma
(paren
id|B_READ
op_or
id|B_PHYS
)paren
comma
l_int|NULL
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a page-sized buffer for inode btree records.&n;&t; * We could try allocating something smaller, but for normal&n;&t; * calls we&squot;ll always (potentially) need the whole page.&n;&t; */
id|irbuf
op_assign
id|kmem_alloc
c_func
(paren
id|NBPC
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|nirbuf
op_assign
id|NBPC
op_div
r_sizeof
(paren
op_star
id|irbuf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the allocation groups, starting from the last&n;&t; * inode returned; 0 means start of the allocation group.&n;&t; */
id|rval
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|ubleft
op_ge
id|statstruct_size
op_logical_and
id|agno
OL
id|mp-&gt;m_sb.sb_agcount
)paren
(brace
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|agno
comma
op_amp
id|agbp
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Skip this allocation group and go to the next one.&n;&t;&t;&t; */
id|agno
op_increment
suffix:semicolon
id|agino
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate and initialize a btree cursor for ialloc btree.&n;&t;&t; */
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|agbp
comma
id|agno
comma
id|XFS_BTNUM_INO
comma
(paren
id|xfs_inode_t
op_star
)paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|irbp
op_assign
id|irbuf
suffix:semicolon
id|irbufend
op_assign
id|irbuf
op_plus
id|nirbuf
suffix:semicolon
id|end_of_ag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re returning in the middle of an allocation group,&n;&t;&t; * we need to get the remainder of the chunk we&squot;re in.&n;&t;&t; */
r_if
c_cond
(paren
id|agino
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Lookup the inode chunk that this inode lives in.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_inobt_lookup_le
c_func
(paren
id|cur
comma
id|agino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
multiline_comment|/* no I/O error */
id|tmp
op_logical_and
multiline_comment|/* lookup succeeded */
multiline_comment|/* got the record, should always work */
op_logical_neg
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|gino
comma
op_amp
id|gcnt
comma
op_amp
id|gfree
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
op_logical_and
id|i
op_eq
l_int|1
op_logical_and
multiline_comment|/* this is the right chunk */
id|agino
OL
id|gino
op_plus
id|XFS_INODES_PER_CHUNK
op_logical_and
multiline_comment|/* lastino was not last in chunk */
(paren
id|chunkidx
op_assign
id|agino
op_minus
id|gino
op_plus
l_int|1
)paren
OL
id|XFS_INODES_PER_CHUNK
op_logical_and
multiline_comment|/* there are some left allocated */
id|XFS_INOBT_MASKN
c_func
(paren
id|chunkidx
comma
id|XFS_INODES_PER_CHUNK
op_minus
id|chunkidx
)paren
op_amp
op_complement
id|gfree
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Grab the chunk record.  Mark all the&n;&t;&t;&t;&t; * uninteresting inodes (because they&squot;re&n;&t;&t;&t;&t; * before our start point) free.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|chunkidx
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|XFS_INOBT_MASK
c_func
(paren
id|i
)paren
op_amp
op_complement
id|gfree
)paren
id|gcnt
op_increment
suffix:semicolon
)brace
id|gfree
op_or_assign
id|XFS_INOBT_MASKN
c_func
(paren
l_int|0
comma
id|chunkidx
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|irbp-&gt;ir_startino
comma
id|ARCH_CONVERT
comma
id|gino
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|irbp-&gt;ir_freecount
comma
id|ARCH_CONVERT
comma
id|gcnt
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|irbp-&gt;ir_free
comma
id|ARCH_CONVERT
comma
id|gfree
)paren
suffix:semicolon
id|irbp
op_increment
suffix:semicolon
id|agino
op_assign
id|gino
op_plus
id|XFS_INODES_PER_CHUNK
suffix:semicolon
id|icount
op_assign
id|XFS_INODES_PER_CHUNK
op_minus
id|gcnt
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If any of those tests failed, bump the&n;&t;&t;&t;&t; * inode number (just in case).&n;&t;&t;&t;&t; */
id|agino
op_increment
suffix:semicolon
id|icount
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * In any case, increment to the next record.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Start of ag.  Lookup the first inode chunk.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|icount
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Loop through inode btree records in this ag,&n;&t;&t; * until we run out of inodes or space in the buffer.&n;&t;&t; */
r_while
c_loop
(paren
id|irbp
OL
id|irbufend
op_logical_and
id|icount
OL
id|ubcount
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Loop as long as we&squot;re unable to read the&n;&t;&t;&t; * inode btree.&n;&t;&t;&t; */
r_while
c_loop
(paren
id|error
)paren
(brace
id|agino
op_add_assign
id|XFS_INODES_PER_CHUNK
suffix:semicolon
r_if
c_cond
(paren
id|XFS_AGINO_TO_AGBNO
c_func
(paren
id|mp
comma
id|agino
)paren
op_ge
id|INT_GET
c_func
(paren
id|agi-&gt;agi_length
comma
id|ARCH_CONVERT
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
id|agino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If ran off the end of the ag either with an error,&n;&t;&t;&t; * or the normal way, set end and stop collecting.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|gino
comma
op_amp
id|gcnt
comma
op_amp
id|gfree
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
op_logical_or
id|i
op_eq
l_int|0
)paren
(brace
id|end_of_ag
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If this chunk has any allocated inodes, save it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|gcnt
OL
id|XFS_INODES_PER_CHUNK
)paren
(brace
id|INT_SET
c_func
(paren
id|irbp-&gt;ir_startino
comma
id|ARCH_CONVERT
comma
id|gino
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|irbp-&gt;ir_freecount
comma
id|ARCH_CONVERT
comma
id|gcnt
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|irbp-&gt;ir_free
comma
id|ARCH_CONVERT
comma
id|gfree
)paren
suffix:semicolon
id|irbp
op_increment
suffix:semicolon
id|icount
op_add_assign
id|XFS_INODES_PER_CHUNK
op_minus
id|gcnt
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Set agino to after this chunk and bump the cursor.&n;&t;&t;&t; */
id|agino
op_assign
id|gino
op_plus
id|XFS_INODES_PER_CHUNK
suffix:semicolon
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Drop the btree buffers and the agi buffer.&n;&t;&t; * We can&squot;t hold any of the locks these represent&n;&t;&t; * when calling iget.&n;&t;&t; */
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|agbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now format all the good inodes into the user&squot;s buffer.&n;&t;&t; */
id|irbufend
op_assign
id|irbp
suffix:semicolon
r_for
c_loop
(paren
id|irbp
op_assign
id|irbuf
suffix:semicolon
id|irbp
OL
id|irbufend
op_logical_and
id|ubleft
op_ge
id|statstruct_size
suffix:semicolon
id|irbp
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Read-ahead the next chunk&squot;s worth of inodes.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_amp
id|irbp
(braket
l_int|1
)braket
OL
id|irbufend
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Loop over all clusters in the next chunk.&n;&t;&t;&t;&t; * Do a readahead if there are any allocated&n;&t;&t;&t;&t; * inodes in that cluster.&n;&t;&t;&t;&t; */
r_for
c_loop
(paren
id|agbno
op_assign
id|XFS_AGINO_TO_AGBNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|irbp
(braket
l_int|1
)braket
dot
id|ir_startino
comma
id|ARCH_CONVERT
)paren
)paren
comma
id|chunkidx
op_assign
l_int|0
suffix:semicolon
id|chunkidx
OL
id|XFS_INODES_PER_CHUNK
suffix:semicolon
id|chunkidx
op_add_assign
id|nicluster
comma
id|agbno
op_add_assign
id|nbcluster
)paren
(brace
r_if
c_cond
(paren
id|XFS_INOBT_MASKN
c_func
(paren
id|chunkidx
comma
id|nicluster
)paren
op_amp
op_complement
(paren
id|INT_GET
c_func
(paren
id|irbp
(braket
l_int|1
)braket
dot
id|ir_free
comma
id|ARCH_CONVERT
)paren
)paren
)paren
id|xfs_btree_reada_bufs
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
comma
id|nbcluster
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Now process this chunk of inodes.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|agino
op_assign
id|INT_GET
c_func
(paren
id|irbp-&gt;ir_startino
comma
id|ARCH_CONVERT
)paren
comma
id|chunkidx
op_assign
l_int|0
comma
id|clustidx
op_assign
l_int|0
suffix:semicolon
id|ubleft
OG
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|irbp-&gt;ir_freecount
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_INODES_PER_CHUNK
suffix:semicolon
id|chunkidx
op_increment
comma
id|clustidx
op_increment
comma
id|agino
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|chunkidx
OL
id|XFS_INODES_PER_CHUNK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Recompute agbno if this is the&n;&t;&t;&t;&t; * first inode of the cluster.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Careful with clustidx.   There can be&n;&t;&t;&t;&t; * multple clusters per chunk, a single&n;&t;&t;&t;&t; * cluster per chunk or a cluster that has&n;&t;&t;&t;&t; * inodes represented from several different&n;&t;&t;&t;&t; * chunks (if blocksize is large).&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Because of this, the starting clustidx is&n;&t;&t;&t;&t; * initialized to zero in this loop but must&n;&t;&t;&t;&t; * later be reset after reading in the cluster&n;&t;&t;&t;&t; * buffer.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|chunkidx
op_amp
(paren
id|nicluster
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|agbno
op_assign
id|XFS_AGINO_TO_AGBNO
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|irbp-&gt;ir_startino
comma
id|ARCH_CONVERT
)paren
)paren
op_plus
(paren
(paren
id|chunkidx
op_amp
id|nimask
)paren
op_rshift
id|mp-&gt;m_sb.sb_inopblog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|BULKSTAT_FG_QUICK
)paren
(brace
id|ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
suffix:semicolon
id|bno
op_assign
id|XFS_AGB_TO_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Get the inode cluster buffer&n;&t;&t;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|xfs_inode_zone
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ip
op_assign
id|kmem_zone_zalloc
c_func
(paren
id|xfs_inode_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ip-&gt;i_ino
op_assign
id|ino
suffix:semicolon
id|ip-&gt;i_mount
op_assign
id|mp
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|bp
comma
id|bno
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|clustidx
op_assign
id|ip-&gt;i_boffset
op_div
id|mp-&gt;m_sb.sb_inodesize
suffix:semicolon
id|kmem_zone_free
c_func
(paren
id|xfs_inode_zone
comma
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
id|error
op_ne
l_int|0
comma
id|mp
comma
id|XFS_ERRTAG_BULKSTAT_READ_CHUNK
comma
id|XFS_RANDOM_BULKSTAT_READ_CHUNK
)paren
)paren
(brace
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Skip if this inode is free.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_INOBT_MASK
c_func
(paren
id|chunkidx
)paren
op_amp
id|INT_GET
c_func
(paren
id|irbp-&gt;ir_free
comma
id|ARCH_CONVERT
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Count used inodes as free so we can tell&n;&t;&t;&t;&t; * when the chunk is used up.&n;&t;&t;&t;&t; */
id|INT_MOD
c_func
(paren
id|irbp-&gt;ir_freecount
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
suffix:semicolon
id|bno
op_assign
id|XFS_AGB_TO_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|BULKSTAT_FG_QUICK
)paren
(brace
id|dip
op_assign
(paren
id|xfs_dinode_t
op_star
)paren
id|xfs_buf_offset
c_func
(paren
id|bp
comma
(paren
id|clustidx
op_lshift
id|mp-&gt;m_sb.sb_inodelog
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DINODE_MAGIC
op_logical_or
op_logical_neg
id|XFS_DINODE_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|dip-&gt;di_core.di_version
comma
id|ARCH_CONVERT
)paren
)paren
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Get the inode and fill in a single buffer.&n;&t;&t;&t;&t; * BULKSTAT_FG_QUICK uses dip to fill it in.&n;&t;&t;&t;&t; * BULKSTAT_FG_IGET uses igets.&n;&t;&t;&t;&t; * See: xfs_bulkstat_one &amp; xfs_dm_bulkstat_one.&n;&t;&t;&t;&t; * This is also used to count inodes/blks, etc&n;&t;&t;&t;&t; * in xfs_qm_quotacheck.&n;&t;&t;&t;&t; */
id|ubused
op_assign
id|statstruct_size
suffix:semicolon
id|error
op_assign
id|formatter
c_func
(paren
id|mp
comma
id|ino
comma
id|ubufp
comma
id|ubleft
comma
id|private_data
comma
id|bno
comma
op_amp
id|ubused
comma
id|dip
comma
op_amp
id|fmterror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmterror
op_eq
id|BULKSTAT_RV_NOTHING
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
id|ENOMEM
)paren
id|ubleft
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmterror
op_eq
id|BULKSTAT_RV_GIVEUP
)paren
(brace
id|ubleft
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
)paren
suffix:semicolon
id|rval
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ubufp
)paren
id|ubufp
op_add_assign
id|ubused
suffix:semicolon
id|ubleft
op_sub_assign
id|ubused
suffix:semicolon
id|ubelem
op_increment
suffix:semicolon
id|lastino
op_assign
id|ino
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bp
)paren
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up for the next loop iteration.&n;&t;&t; */
r_if
c_cond
(paren
id|ubleft
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|end_of_ag
)paren
(brace
id|agno
op_increment
suffix:semicolon
id|agino
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|agino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|lastino
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Done, we&squot;re either out of filesystem or space to put the data.&n;&t; */
id|kmem_free
c_func
(paren
id|irbuf
comma
id|NBPC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ubuffer
)paren
id|unuseracc
c_func
(paren
id|ubuffer
comma
id|ubcount
op_star
id|statstruct_size
comma
(paren
id|B_READ
op_or
id|B_PHYS
)paren
)paren
suffix:semicolon
op_star
id|ubcountp
op_assign
id|ubelem
suffix:semicolon
r_if
c_cond
(paren
id|agno
op_ge
id|mp-&gt;m_sb.sb_agcount
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we ran out of filesystem, mark lastino as off&n;&t;&t; * the end of the filesystem, so the next call&n;&t;&t; * will return immediately.&n;&t;&t; */
op_star
id|lastinop
op_assign
(paren
id|xfs_ino_t
)paren
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
l_int|0
)paren
suffix:semicolon
op_star
id|done
op_assign
l_int|1
suffix:semicolon
)brace
r_else
op_star
id|lastinop
op_assign
(paren
id|xfs_ino_t
)paren
id|lastino
suffix:semicolon
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Return stat information in bulk (by-inode) for the filesystem.&n; * Special case for non-sequential one inode bulkstat.&n; */
r_int
multiline_comment|/* error status */
DECL|function|xfs_bulkstat_single
id|xfs_bulkstat_single
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point for filesystem */
id|xfs_ino_t
op_star
id|lastinop
comma
multiline_comment|/* inode to return */
r_char
id|__user
op_star
id|buffer
comma
multiline_comment|/* buffer with inode stats */
r_int
op_star
id|done
)paren
multiline_comment|/* 1 if there&squot;re more stats to get */
(brace
r_int
id|count
suffix:semicolon
multiline_comment|/* count value for bulkstat call */
r_int
id|error
suffix:semicolon
multiline_comment|/* return value */
id|xfs_ino_t
id|ino
suffix:semicolon
multiline_comment|/* filesystem inode number */
r_int
id|res
suffix:semicolon
multiline_comment|/* result from bs1 */
multiline_comment|/*&n;&t; * note that requesting valid inode numbers which are not allocated&n;&t; * to inodes will most likely cause xfs_itobp to generate warning&n;&t; * messages about bad magic numbers. This is ok. The fact that&n;&t; * the inode isn&squot;t actually an inode is handled by the&n;&t; * error check below. Done this way to make the usual case faster&n;&t; * at the expense of the error case.&n;&t; */
id|ino
op_assign
(paren
id|xfs_ino_t
)paren
op_star
id|lastinop
suffix:semicolon
id|error
op_assign
id|xfs_bulkstat_one
c_func
(paren
id|mp
comma
id|ino
comma
id|buffer
comma
r_sizeof
(paren
id|xfs_bstat_t
)paren
comma
l_int|NULL
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * Special case way failed, do it the &quot;long&quot; way&n;&t;&t; * to see if that works.&n;&t;&t; */
(paren
op_star
id|lastinop
)paren
op_decrement
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|xfs_bulkstat
c_func
(paren
id|mp
comma
id|lastinop
comma
op_amp
id|count
comma
id|xfs_bulkstat_one
comma
l_int|NULL
comma
r_sizeof
(paren
id|xfs_bstat_t
)paren
comma
id|buffer
comma
id|BULKSTAT_FG_IGET
comma
id|done
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
op_logical_or
(paren
id|xfs_ino_t
)paren
op_star
id|lastinop
op_ne
id|ino
)paren
r_return
id|error
op_eq
id|EFSCORRUPTED
ques
c_cond
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:colon
id|error
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|done
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return inode number table for the filesystem.&n; */
r_int
multiline_comment|/* error status */
DECL|function|xfs_inumbers
id|xfs_inumbers
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point for filesystem */
id|xfs_ino_t
op_star
id|lastino
comma
multiline_comment|/* last inode returned */
r_int
op_star
id|count
comma
multiline_comment|/* size of buffer/count returned */
id|xfs_inogrp_t
id|__user
op_star
id|ubuffer
)paren
multiline_comment|/* buffer with inode descriptions */
(brace
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
id|xfs_agino_t
id|agino
suffix:semicolon
id|xfs_agnumber_t
id|agno
suffix:semicolon
r_int
id|bcount
suffix:semicolon
id|xfs_inogrp_t
op_star
id|buffer
suffix:semicolon
r_int
id|bufidx
suffix:semicolon
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
r_int
id|error
suffix:semicolon
id|__int32_t
id|gcnt
suffix:semicolon
id|xfs_inofree_t
id|gfree
suffix:semicolon
id|xfs_agino_t
id|gino
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xfs_ino_t
id|ino
suffix:semicolon
r_int
id|left
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|ino
op_assign
(paren
id|xfs_ino_t
)paren
op_star
id|lastino
suffix:semicolon
id|agno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|agino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|left
op_assign
op_star
id|count
suffix:semicolon
op_star
id|count
op_assign
l_int|0
suffix:semicolon
id|bcount
op_assign
id|MIN
c_func
(paren
id|left
comma
(paren
r_int
)paren
(paren
id|NBPP
op_div
r_sizeof
(paren
op_star
id|buffer
)paren
)paren
)paren
suffix:semicolon
id|buffer
op_assign
id|kmem_alloc
c_func
(paren
id|bcount
op_star
r_sizeof
(paren
op_star
id|buffer
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|error
op_assign
id|bufidx
op_assign
l_int|0
suffix:semicolon
id|cur
op_assign
l_int|NULL
suffix:semicolon
id|agbp
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|left
OG
l_int|0
op_logical_and
id|agno
OL
id|mp-&gt;m_sb.sb_agcount
)paren
(brace
r_if
c_cond
(paren
id|agbp
op_eq
l_int|NULL
)paren
(brace
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|agno
comma
op_amp
id|agbp
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If we can&squot;t read the AGI of this ag,&n;&t;&t;&t;&t; * then just skip to the next one.&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|cur
op_eq
l_int|NULL
)paren
suffix:semicolon
id|agbp
op_assign
l_int|NULL
suffix:semicolon
id|agno
op_increment
suffix:semicolon
id|agino
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|agbp
comma
id|agno
comma
id|XFS_BTNUM_INO
comma
(paren
id|xfs_inode_t
op_star
)paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
id|agino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
id|cur
op_assign
l_int|NULL
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|agbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Move up the the last inode in the current&n;&t;&t;&t;&t; * chunk.  The lookup_ge will always get&n;&t;&t;&t;&t; * us the first inode in the next chunk.&n;&t;&t;&t;&t; */
id|agino
op_add_assign
id|XFS_INODES_PER_CHUNK
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|gino
comma
op_amp
id|gcnt
comma
op_amp
id|gfree
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
op_logical_or
id|i
op_eq
l_int|0
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|agbp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|cur
op_assign
l_int|NULL
suffix:semicolon
id|agno
op_increment
suffix:semicolon
id|agino
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|agino
op_assign
id|gino
op_plus
id|XFS_INODES_PER_CHUNK
op_minus
l_int|1
suffix:semicolon
id|buffer
(braket
id|bufidx
)braket
dot
id|xi_startino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|gino
)paren
suffix:semicolon
id|buffer
(braket
id|bufidx
)braket
dot
id|xi_alloccount
op_assign
id|XFS_INODES_PER_CHUNK
op_minus
id|gcnt
suffix:semicolon
id|buffer
(braket
id|bufidx
)braket
dot
id|xi_allocmask
op_assign
op_complement
id|gfree
suffix:semicolon
id|bufidx
op_increment
suffix:semicolon
id|left
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bufidx
op_eq
id|bcount
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ubuffer
comma
id|buffer
comma
id|bufidx
op_star
r_sizeof
(paren
op_star
id|buffer
)paren
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ubuffer
op_add_assign
id|bufidx
suffix:semicolon
op_star
id|count
op_add_assign
id|bufidx
suffix:semicolon
id|bufidx
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
)paren
(brace
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
id|cur
op_assign
l_int|NULL
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|agbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * The agino value has already been bumped.&n;&t;&t;&t;&t; * Just try to skip up to it.&n;&t;&t;&t;&t; */
id|agino
op_add_assign
id|XFS_INODES_PER_CHUNK
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|bufidx
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ubuffer
comma
id|buffer
comma
id|bufidx
op_star
r_sizeof
(paren
op_star
id|buffer
)paren
)paren
)paren
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:semicolon
r_else
op_star
id|count
op_add_assign
id|bufidx
suffix:semicolon
)brace
op_star
id|lastino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|buffer
comma
id|bcount
op_star
r_sizeof
(paren
op_star
id|buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
(paren
id|error
ques
c_cond
id|XFS_BTREE_ERROR
suffix:colon
id|XFS_BTREE_NOERROR
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agbp
)paren
id|xfs_buf_relse
c_func
(paren
id|agbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
