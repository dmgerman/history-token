multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &lt;xfs.h&gt;
macro_line|#include &lt;xfs_quota_priv.h&gt;
multiline_comment|/*&n;   LOCK ORDER&n;&n;   inode lock&t;&t;    (ilock)&n;   dquot hash-chain lock    (hashlock)&n;   xqm dquot freelist lock  (freelistlock&n;   mount&squot;s dquot list lock  (mplistlock)&n;   user dquot lock - lock ordering among dquots is based on the uid or gid&n;   group dquot lock - similar to udquots. Between the two dquots, the udquot&n;&t;&t;      has to be locked first.&n;   pin lock - the dquot lock must be held to take this lock.&n;   flush lock - ditto.&n;*/
id|STATIC
r_void
id|xfs_qm_dqflush_done
c_func
(paren
id|xfs_buf_t
op_star
comma
id|xfs_dq_logitem_t
op_star
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|variable|xfs_dqerror_dev
id|dev_t
id|xfs_dqerror_dev
op_assign
l_int|0
suffix:semicolon
DECL|variable|xfs_do_dqerror
r_int
id|xfs_do_dqerror
op_assign
l_int|0
suffix:semicolon
DECL|variable|xfs_dqreq_num
r_int
id|xfs_dqreq_num
op_assign
l_int|0
suffix:semicolon
DECL|variable|xfs_dqerror_mod
r_int
id|xfs_dqerror_mod
op_assign
l_int|33
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Allocate and initialize a dquot. We don&squot;t always allocate fresh memory;&n; * we try to reclaim a free dquot if the number of incore dquots are above&n; * a threshold.&n; * The only field inside the core that gets initialized at this point&n; * is the d_id field. The idea is to fill in the entire q_core&n; * when we read in the on disk dquot.&n; */
id|xfs_dquot_t
op_star
DECL|function|xfs_qm_dqinit
id|xfs_qm_dqinit
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|boolean_t
id|brandnewdquot
suffix:semicolon
id|brandnewdquot
op_assign
id|xfs_qm_dqalloc_incore
c_func
(paren
op_amp
id|dqp
)paren
suffix:semicolon
id|dqp-&gt;dq_flags
op_assign
id|type
suffix:semicolon
id|INT_SET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
comma
id|id
)paren
suffix:semicolon
id|dqp-&gt;q_mount
op_assign
id|mp
suffix:semicolon
multiline_comment|/*&n;&t; * No need to re-initialize these if this is a reclaimed dquot.&n;&t; */
r_if
c_cond
(paren
id|brandnewdquot
)paren
(brace
id|dqp-&gt;dq_flnext
op_assign
id|dqp-&gt;dq_flprev
op_assign
id|dqp
suffix:semicolon
id|mutex_init
c_func
(paren
op_amp
id|dqp-&gt;q_qlock
comma
id|MUTEX_DEFAULT
comma
l_string|&quot;xdq&quot;
)paren
suffix:semicolon
id|initnsema
c_func
(paren
op_amp
id|dqp-&gt;q_flock
comma
l_int|1
comma
l_string|&quot;fdq&quot;
)paren
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
id|dqp-&gt;q_pinwait
comma
id|SV_DEFAULT
comma
l_string|&quot;pdq&quot;
)paren
suffix:semicolon
macro_line|#ifdef DQUOT_TRACING
id|dqp-&gt;q_trace
op_assign
id|ktrace_alloc
c_func
(paren
id|DQUOT_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQINIT&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Only the q_core portion was zeroed in dqreclaim_one().&n;&t;&t; * So, we need to reset others.&n;&t;&t; */
id|dqp-&gt;q_nrefs
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;q_blkno
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;MPL_NEXT
op_assign
id|dqp-&gt;HL_NEXT
op_assign
l_int|NULL
suffix:semicolon
id|dqp-&gt;HL_PREVP
op_assign
id|dqp-&gt;MPL_PREVP
op_assign
l_int|NULL
suffix:semicolon
id|dqp-&gt;q_bufoffset
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;q_fileoffset
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;q_transp
op_assign
l_int|NULL
suffix:semicolon
id|dqp-&gt;q_gdquot
op_assign
l_int|NULL
suffix:semicolon
id|dqp-&gt;q_res_bcount
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;q_res_icount
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;q_res_rtbcount
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;q_pincount
op_assign
l_int|0
suffix:semicolon
id|dqp-&gt;q_hash
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;dq_flnext
op_eq
id|dqp-&gt;dq_flprev
)paren
suffix:semicolon
macro_line|#ifdef DQUOT_TRACING
id|ASSERT
c_func
(paren
id|dqp-&gt;q_trace
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQRECLAIMED_INIT&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * log item gets initialized later&n;&t; */
r_return
(paren
id|dqp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called to free all the memory associated with a dquot&n; */
r_void
DECL|function|xfs_qm_dqdestroy
id|xfs_qm_dqdestroy
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_DQ_IS_ON_FREELIST
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|mutex_destroy
c_func
(paren
op_amp
id|dqp-&gt;q_qlock
)paren
suffix:semicolon
id|freesema
c_func
(paren
op_amp
id|dqp-&gt;q_flock
)paren
suffix:semicolon
id|sv_destroy
c_func
(paren
op_amp
id|dqp-&gt;q_pinwait
)paren
suffix:semicolon
macro_line|#ifdef DQUOT_TRACING
r_if
c_cond
(paren
id|dqp-&gt;q_trace
)paren
id|ktrace_free
c_func
(paren
id|dqp-&gt;q_trace
)paren
suffix:semicolon
id|dqp-&gt;q_trace
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
id|kmem_zone_free
c_func
(paren
id|xfs_Gqm-&gt;qm_dqzone
comma
id|dqp
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|xfs_Gqm-&gt;qm_totaldquots
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is what a &squot;fresh&squot; dquot inside a dquot chunk looks like on disk.&n; */
id|STATIC
r_void
DECL|function|xfs_qm_dqinit_core
id|xfs_qm_dqinit_core
c_func
(paren
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
id|xfs_dqblk_t
op_star
id|d
)paren
(brace
multiline_comment|/*&n;&t; * Caller has zero&squot;d the entire dquot &squot;chunk&squot; already.&n;&t; */
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_magic
comma
id|ARCH_CONVERT
comma
id|XFS_DQUOT_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_version
comma
id|ARCH_CONVERT
comma
id|XFS_DQUOT_VERSION
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_id
comma
id|ARCH_CONVERT
comma
id|id
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|d-&gt;dd_diskdq.d_flags
comma
id|ARCH_CONVERT
comma
id|type
)paren
suffix:semicolon
)brace
macro_line|#ifdef DQUOT_TRACING
multiline_comment|/*&n; * Dquot tracing for debugging.&n; */
multiline_comment|/* ARGSUSED */
r_void
DECL|function|xfs_dqtrace_entry__
id|xfs_dqtrace_entry__
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
comma
r_char
op_star
id|func
comma
r_void
op_star
id|retaddr
comma
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_dquot_t
op_star
id|udqp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ino
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;q_trace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
)paren
(brace
id|ino
op_assign
id|ip-&gt;i_ino
suffix:semicolon
id|udqp
op_assign
id|ip-&gt;i_udquot
suffix:semicolon
)brace
id|ktrace_enter
c_func
(paren
id|dqp-&gt;q_trace
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|DQUOT_KTRACE_ENTRY
comma
(paren
r_void
op_star
)paren
id|func
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|dqp-&gt;q_nrefs
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|dqp-&gt;dq_flags
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|dqp-&gt;q_res_bcount
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_bcount
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_icount
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
comma
multiline_comment|/* 11 */
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|current_pid
c_func
(paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|ino
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|retaddr
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|udqp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Check the limits and timers of a dquot and start or reset timers&n; * if necessary.&n; * This gets called even when quota enforcement is OFF, which makes our&n; * life a little less complicated. (We just don&squot;t reject any quota&n; * reservations in that case, when enforcement is off).&n; * We also return 0 as the values of the timers in Q_GETQUOTA calls, when&n; * enforcement&squot;s off.&n; * In contrast, warnings are a little different in that they don&squot;t&n; * &squot;automatically&squot; get started when limits get exceeded.&n; */
r_void
DECL|function|xfs_qm_adjust_dqtimers
id|xfs_qm_adjust_dqtimers
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_disk_dquot_t
op_star
id|d
)paren
(brace
multiline_comment|/*&n;&t; * The dquot had better be locked. We are modifying it here.&n;&t; */
multiline_comment|/*&n;&t; * root&squot;s limits are not real limits.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef QUOTADEBUG
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_btimer
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
id|INT_SET
c_func
(paren
id|d-&gt;d_btimer
comma
id|ARCH_CONVERT
comma
id|get_seconds
c_func
(paren
)paren
op_plus
id|XFS_QI_BTIMELIMIT
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
op_logical_and
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
id|INT_ZERO
c_func
(paren
id|d-&gt;d_btimer
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_itimer
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
id|INT_SET
c_func
(paren
id|d-&gt;d_itimer
comma
id|ARCH_CONVERT
comma
id|get_seconds
c_func
(paren
)paren
op_plus
id|XFS_QI_ITIMELIMIT
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
op_logical_and
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
id|INT_ZERO
c_func
(paren
id|d-&gt;d_itimer
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Increment or reset warnings of a given dquot.&n; */
r_int
DECL|function|xfs_qm_dqwarn
id|xfs_qm_dqwarn
c_func
(paren
id|xfs_disk_dquot_t
op_star
id|d
comma
id|uint
id|flags
)paren
(brace
r_int
id|warned
suffix:semicolon
multiline_comment|/*&n;&t; * root&squot;s limits are not real limits.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|warned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
(brace
id|INT_MOD
c_func
(paren
id|d-&gt;d_bwarns
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|warned
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|INT_ZERO
c_func
(paren
id|d-&gt;d_bwarns
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
(brace
id|INT_MOD
c_func
(paren
id|d-&gt;d_iwarns
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|warned
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|INT_ISZERO
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|INT_ZERO
c_func
(paren
id|d-&gt;d_iwarns
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef QUOTADEBUG
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_iwarns
comma
id|ARCH_CONVERT
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;--------@@Inode warnings running : %Lu &gt;= %Lu&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|d-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
comma
id|INT_GET
c_func
(paren
id|d-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d-&gt;d_bwarns
comma
id|ARCH_CONVERT
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;--------@@Blks warnings running : %Lu &gt;= %Lu&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|d-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
comma
id|INT_GET
c_func
(paren
id|d-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|warned
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * initialize a buffer full of dquots and log the whole thing&n; */
id|STATIC
r_void
DECL|function|xfs_qm_init_dquot_blk
id|xfs_qm_init_dquot_blk
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xfs_dqblk_t
op_star
id|d
suffix:semicolon
r_int
id|curid
comma
id|i
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|d
op_assign
(paren
id|xfs_dqblk_t
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ID of the first dquot in the block - id&squot;s are zero based.&n;&t; */
id|curid
op_assign
id|id
op_minus
(paren
id|id
op_mod
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|curid
op_ge
l_int|0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|d
comma
l_int|0
comma
id|BBTOB
c_func
(paren
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|i
op_increment
comma
id|d
op_increment
comma
id|curid
op_increment
)paren
id|xfs_qm_dqinit_core
c_func
(paren
id|curid
comma
id|type
comma
id|d
)paren
suffix:semicolon
id|xfs_trans_dquot_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|type
op_amp
id|XFS_DQ_USER
ques
c_cond
id|XFS_BLI_UDQUOT_BUF
suffix:colon
id|XFS_BLI_GDQUOT_BUF
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
l_int|0
comma
id|BBTOB
c_func
(paren
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|mp
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a block and fill it with dquots.&n; * This is called when the bmapi finds a hole.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_dqalloc
id|xfs_qm_dqalloc
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dquot_t
op_star
id|dqp
comma
id|xfs_inode_t
op_star
id|quotip
comma
id|xfs_fileoff_t
id|offset_fsb
comma
id|xfs_buf_t
op_star
op_star
id|O_bpp
)paren
(brace
id|xfs_fsblock_t
id|firstblock
suffix:semicolon
id|xfs_bmap_free_t
id|flist
suffix:semicolon
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
r_int
id|nmaps
comma
id|error
comma
id|committed
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQALLOC&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the bmap freelist prior to calling bmapi code.&n;&t; */
id|XFS_BMAP_INIT
c_func
(paren
op_amp
id|flist
comma
op_amp
id|firstblock
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|quotip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return if this type of quotas is turned off while we didn&squot;t&n;&t; * have an inode lock&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_THIS_QUOTA_OFF
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|quotip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|ESRCH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * xfs_trans_commit normally decrements the vnode ref count&n;&t; * when it unlocks the inode. Since we want to keep the quota&n;&t; * inode around, we bump the vnode ref count now.&n;&t; */
id|VN_HOLD
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|quotip
)paren
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|quotip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|nmaps
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|quotip
comma
id|offset_fsb
comma
id|XFS_DQUOT_CLUSTER_SIZE_FSB
comma
id|XFS_BMAPI_METADATA
op_or
id|XFS_BMAPI_WRITE
comma
op_amp
id|firstblock
comma
id|XFS_QM_DQALLOC_SPACE_RES
c_func
(paren
id|mp
)paren
comma
op_amp
id|map
comma
op_amp
id|nmaps
comma
op_amp
id|flist
)paren
)paren
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|map.br_blockcount
op_eq
id|XFS_DQUOT_CLUSTER_SIZE_FSB
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nmaps
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|map.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
op_logical_and
(paren
id|map.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Keep track of the blkno to save a lookup later&n;&t; */
id|dqp-&gt;q_blkno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|map.br_startblock
)paren
suffix:semicolon
multiline_comment|/* now we can just get the buffer (there&squot;s nothing to read yet) */
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|dqp-&gt;q_blkno
comma
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|mp
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
op_logical_or
(paren
id|error
op_assign
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
multiline_comment|/*&n;&t; * Make a chunk of dquots out of this buffer and log&n;&t; * the entire thing.&n;&t; */
id|xfs_qm_init_dquot_blk
c_func
(paren
id|tp
comma
id|mp
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
comma
id|dqp-&gt;dq_flags
op_amp
(paren
id|XFS_DQ_USER
op_or
id|XFS_DQ_GROUP
)paren
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|tp
comma
op_amp
id|flist
comma
id|firstblock
comma
op_amp
id|committed
)paren
)paren
)paren
(brace
r_goto
id|error1
suffix:semicolon
)brace
op_star
id|O_bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error1
suffix:colon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|flist
)paren
suffix:semicolon
id|error0
suffix:colon
id|xfs_iunlock
c_func
(paren
id|quotip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Maps a dquot to the buffer containing its on-disk version.&n; * This returns a ptr to the buffer containing the on-disk dquot&n; * in the bpp param, and a ptr to the on-disk dquot within that buffer&n; */
id|STATIC
r_int
DECL|function|xfs_qm_dqtobp
id|xfs_qm_dqtobp
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dquot_t
op_star
id|dqp
comma
id|xfs_disk_dquot_t
op_star
op_star
id|O_ddpp
comma
id|xfs_buf_t
op_star
op_star
id|O_bpp
comma
id|uint
id|flags
)paren
(brace
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
r_int
id|nmaps
comma
id|error
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_inode_t
op_star
id|quotip
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_disk_dquot_t
op_star
id|ddq
suffix:semicolon
id|xfs_dqid_t
id|id
suffix:semicolon
id|boolean_t
id|newdquot
suffix:semicolon
id|mp
op_assign
id|dqp-&gt;q_mount
suffix:semicolon
id|id
op_assign
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|nmaps
op_assign
l_int|1
suffix:semicolon
id|newdquot
op_assign
id|B_FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t know where the dquot lives, find out.&n;&t; */
r_if
c_cond
(paren
id|dqp-&gt;q_blkno
op_eq
(paren
id|xfs_daddr_t
)paren
l_int|0
)paren
(brace
multiline_comment|/* We use the id as an index */
id|dqp-&gt;q_fileoffset
op_assign
(paren
id|xfs_fileoff_t
)paren
(paren
(paren
id|uint
)paren
id|id
op_div
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|nmaps
op_assign
l_int|1
suffix:semicolon
id|quotip
op_assign
id|XFS_DQ_TO_QIP
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|quotip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Return if this type of quotas is turned off while we didn&squot;t&n;&t;&t; * have an inode lock&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_IS_THIS_QUOTA_OFF
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|quotip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
(paren
id|ESRCH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Find the block map; no allocations yet&n;&t;&t; */
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|quotip
comma
id|dqp-&gt;q_fileoffset
comma
id|XFS_DQUOT_CLUSTER_SIZE_FSB
comma
id|XFS_BMAPI_METADATA
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|map
comma
op_amp
id|nmaps
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|quotip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|nmaps
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|map.br_blockcount
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * offset of dquot in the (fixed sized) dquot chunk.&n;&t;&t; */
id|dqp-&gt;q_bufoffset
op_assign
(paren
id|id
op_mod
id|XFS_QM_DQPERBLK
c_func
(paren
id|mp
)paren
)paren
op_star
r_sizeof
(paren
id|xfs_dqblk_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map.br_startblock
op_eq
id|HOLESTARTBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t allocate unless we&squot;re asked to&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_QMOPT_DQALLOC
)paren
)paren
r_return
(paren
id|ENOENT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqalloc
c_func
(paren
id|tp
comma
id|mp
comma
id|dqp
comma
id|quotip
comma
id|dqp-&gt;q_fileoffset
comma
op_amp
id|bp
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|newdquot
op_assign
id|B_TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * store the blkno etc so that we don&squot;t have to do the&n;&t;&t;&t; * mapping all the time&n;&t;&t;&t; */
id|dqp-&gt;q_blkno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|map.br_startblock
)paren
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
id|dqp-&gt;q_blkno
op_ne
id|DELAYSTARTBLOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;q_blkno
op_ne
id|HOLESTARTBLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read in the buffer, unless we&squot;ve just done the allocation&n;&t; * (in which case we already have the buf).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|newdquot
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQTOBP READBUF&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|dqp-&gt;q_blkno
comma
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
op_amp
id|bp
)paren
)paren
)paren
(brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_logical_or
op_logical_neg
id|bp
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * calculate the location of the dquot inside the buffer.&n;&t; */
id|ddq
op_assign
(paren
id|xfs_disk_dquot_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
op_plus
id|dqp-&gt;q_bufoffset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A simple sanity check in case we got a corrupted dquot...&n;&t; */
r_if
c_cond
(paren
id|xfs_qm_dqcheck
c_func
(paren
id|ddq
comma
id|id
comma
id|dqp-&gt;dq_flags
op_amp
(paren
id|XFS_DQ_USER
op_or
id|XFS_DQ_GROUP
)paren
comma
id|flags
op_amp
(paren
id|XFS_QMOPT_DQREPAIR
op_or
id|XFS_QMOPT_DOWARN
)paren
comma
l_string|&quot;dqtobp&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|XFS_QMOPT_DQREPAIR
)paren
)paren
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|XFS_BUF_BUSY
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* We dirtied this */
)brace
op_star
id|O_bpp
op_assign
id|bp
suffix:semicolon
op_star
id|O_ddpp
op_assign
id|ddq
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in the ondisk dquot using dqtobp() then copy it to an incore version,&n; * and release the buffer immediately.&n; *&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
r_int
DECL|function|xfs_qm_dqread
id|xfs_qm_dqread
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dqid_t
id|id
comma
id|xfs_dquot_t
op_star
id|dqp
comma
multiline_comment|/* dquot to get filled in */
id|uint
id|flags
)paren
(brace
id|xfs_disk_dquot_t
op_star
id|ddqp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * get a pointer to the on-disk dquot and the buffer containing it&n;&t; * dqp already knows its own type (GROUP/USER).&n;&t; */
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQREAD&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqtobp
c_func
(paren
id|tp
comma
id|dqp
comma
op_amp
id|ddqp
comma
op_amp
id|bp
comma
id|flags
)paren
)paren
)paren
(brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* copy everything from disk dquot to the incore dquot */
id|memcpy
c_func
(paren
op_amp
id|dqp-&gt;q_core
comma
id|ddqp
comma
r_sizeof
(paren
id|xfs_disk_dquot_t
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
op_eq
id|id
)paren
suffix:semicolon
id|xfs_qm_dquot_logitem_init
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reservation counters are defined as reservation plus current usage&n;&t; * to avoid having to add everytime.&n;&t; */
id|dqp-&gt;q_res_bcount
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dqp-&gt;q_res_icount
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dqp-&gt;q_res_rtbcount
op_assign
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_rtbcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* Mark the buf so that this will stay incore a little longer */
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_DQUOT
comma
id|XFS_DQUOT_REF
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We got the buffer with a xfs_trans_read_buf() (in dqtobp())&n;&t; * So we need to release with xfs_trans_brelse().&n;&t; * The strategy here is identical to that of inodes; we lock&n;&t; * the dquot in xfs_qm_dqget() before making it accessible to&n;&t; * others. This is because dquots, like inodes, need a good level of&n;&t; * concurrency, and we don&squot;t want to take locks on the entire buffers&n;&t; * for dquot accesses.&n;&t; * Note also that the dquot buffer may even be dirty at this point, if&n;&t; * this particular dquot was repaired. We still aren&squot;t afraid to&n;&t; * brelse it because we have the changes incore.&n;&t; */
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * allocate an incore dquot from the kernel heap,&n; * and fill its core with quota information kept on disk.&n; * If XFS_QMOPT_DQALLOC is set, it&squot;ll allocate a dquot on disk&n; * if it wasn&squot;t already allocated.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_idtodq
id|xfs_qm_idtodq
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|id
comma
multiline_comment|/* gid or uid, depending on type */
id|uint
id|type
comma
multiline_comment|/* UDQUOT or GDQUOT */
id|uint
id|flags
comma
multiline_comment|/* DQALLOC, DQREPAIR */
id|xfs_dquot_t
op_star
op_star
id|O_dqpp
)paren
multiline_comment|/* OUT : incore dquot, not locked */
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
r_int
id|cancelflags
op_assign
l_int|0
suffix:semicolon
id|dqp
op_assign
id|xfs_qm_dqinit
c_func
(paren
id|mp
comma
id|id
comma
id|type
)paren
suffix:semicolon
id|tp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DQALLOC
)paren
(brace
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_QM_DQALLOC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
id|XFS_QM_DQALLOC_SPACE_RES
c_func
(paren
id|mp
)paren
comma
id|XFS_WRITE_LOG_RES
c_func
(paren
id|mp
)paren
op_plus
id|BBTOB
c_func
(paren
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|mp
)paren
)paren
op_minus
l_int|1
op_plus
l_int|128
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_WRITE_LOG_COUNT
)paren
)paren
)paren
(brace
id|cancelflags
op_assign
l_int|0
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|cancelflags
op_assign
id|XFS_TRANS_RELEASE_LOG_RES
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read it from disk; xfs_dqread() takes care of&n;&t; * all the necessary initialization of dquot&squot;s fields (locks, etc)&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqread
c_func
(paren
id|tp
comma
id|id
comma
id|dqp
comma
id|flags
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * This can happen if quotas got turned off (ESRCH),&n;&t;&t; * or if the dquot didn&squot;t exist on disk and we ask to&n;&t;&t; * allocate (ENOENT).&n;&t;&t; */
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQREAD FAIL&quot;
)paren
suffix:semicolon
id|cancelflags
op_or_assign
id|XFS_TRANS_ABORT
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
)brace
op_star
id|O_dqpp
op_assign
id|dqp
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error0
suffix:colon
id|ASSERT
c_func
(paren
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
id|cancelflags
)paren
suffix:semicolon
id|error1
suffix:colon
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
op_star
id|O_dqpp
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup a dquot in the incore dquot hashtable. We keep two separate&n; * hashtables for user and group dquots; and, these are global tables&n; * inside the XQM, not per-filesystem tables.&n; * The hash chain must be locked by caller, and it is left locked&n; * on return. Returning dquot is locked.&n; */
id|STATIC
r_int
DECL|function|xfs_qm_dqlookup
id|xfs_qm_dqlookup
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_dqid_t
id|id
comma
id|xfs_dqhash_t
op_star
id|qh
comma
id|xfs_dquot_t
op_star
op_star
id|O_dqpp
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|uint
id|flist_locked
suffix:semicolon
id|xfs_dquot_t
op_star
id|d
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_HASH_LOCKED
c_func
(paren
id|qh
)paren
)paren
suffix:semicolon
id|flist_locked
op_assign
id|B_FALSE
suffix:semicolon
multiline_comment|/*&n;&t; * Traverse the hashchain looking for a match&n;&t; */
r_for
c_loop
(paren
id|dqp
op_assign
id|qh-&gt;qh_next
suffix:semicolon
id|dqp
op_ne
l_int|NULL
suffix:semicolon
id|dqp
op_assign
id|dqp-&gt;HL_NEXT
)paren
(brace
multiline_comment|/*&n;&t;&t; * We already have the hashlock. We don&squot;t need the&n;&t;&t; * dqlock to look at the id field of the dquot, since the&n;&t;&t; * id can&squot;t be modified without the hashlock anyway.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
op_eq
id|id
op_logical_and
id|dqp-&gt;q_mount
op_eq
id|mp
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQFOUND BY LOOKUP&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * All in core dquots must be on the dqlist of mp&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|dqp-&gt;MPL_PREVP
op_ne
l_int|NULL
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqp-&gt;q_nrefs
op_eq
l_int|0
)paren
(brace
id|ASSERT
(paren
id|XFS_DQ_IS_ON_FREELIST
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_freelist_lock_nowait
c_func
(paren
id|xfs_Gqm
)paren
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQLOOKUP: WANT&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * We may have raced with dqreclaim_one()&n;&t;&t;&t;&t;&t; * (and lost). So, flag that we don&squot;t&n;&t;&t;&t;&t;&t; * want the dquot to be reclaimed.&n;&t;&t;&t;&t;&t; */
id|dqp-&gt;dq_flags
op_or_assign
id|XFS_DQ_WANT
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_freelist_lock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp-&gt;dq_flags
op_and_assign
op_complement
(paren
id|XFS_DQ_WANT
)paren
suffix:semicolon
)brace
id|flist_locked
op_assign
id|B_TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * id couldn&squot;t have changed; we had the hashlock all&n;&t;&t;&t; * along&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
op_eq
id|id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flist_locked
)paren
(brace
r_if
c_cond
(paren
id|dqp-&gt;q_nrefs
op_ne
l_int|0
)paren
(brace
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|flist_locked
op_assign
id|B_FALSE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * take it off the freelist&n;&t;&t;&t;&t;&t; */
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQLOOKUP: TAKEOFF FL&quot;
)paren
suffix:semicolon
id|XQM_FREELIST_REMOVE
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/* xfs_qm_freelist_print(&amp;(xfs_Gqm-&gt;&n;&t;&t;&t;&t;&t;&t;&t;qm_dqfreelist),&n;&t;&t;&t;&t;&t;&t;&t;&quot;after removal&quot;); */
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * grab a reference&n;&t;&t;&t; */
id|XFS_DQHOLD
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flist_locked
)paren
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * move the dquot to the front of the hashchain&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_HASH_LOCKED
c_func
(paren
id|qh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqp-&gt;HL_PREVP
op_ne
op_amp
id|qh-&gt;qh_next
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQLOOKUP: HASH MOVETOFRONT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_assign
id|dqp-&gt;HL_NEXT
)paren
)paren
id|d-&gt;HL_PREVP
op_assign
id|dqp-&gt;HL_PREVP
suffix:semicolon
op_star
(paren
id|dqp-&gt;HL_PREVP
)paren
op_assign
id|d
suffix:semicolon
id|d
op_assign
id|qh-&gt;qh_next
suffix:semicolon
id|d-&gt;HL_PREVP
op_assign
op_amp
id|dqp-&gt;HL_NEXT
suffix:semicolon
id|dqp-&gt;HL_NEXT
op_assign
id|d
suffix:semicolon
id|dqp-&gt;HL_PREVP
op_assign
op_amp
id|qh-&gt;qh_next
suffix:semicolon
id|qh-&gt;qh_next
op_assign
id|dqp
suffix:semicolon
)brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;LOOKUP END&quot;
)paren
suffix:semicolon
op_star
id|O_dqpp
op_assign
id|dqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_HASH_LOCKED
c_func
(paren
id|qh
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
op_star
id|O_dqpp
op_assign
l_int|NULL
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_HASH_LOCKED
c_func
(paren
id|qh
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Given the file system, inode OR id, and type (UDQUOT/GDQUOT), return a&n; * a locked dquot, doing an allocation (if requested) as needed.&n; * When both an inode and an id are given, the inode&squot;s id takes precedence.&n; * That is, if the id changes while we don&squot;t hold the ilock inside this&n; * function, the new dquot is returned, not necessarily the one requested&n; * in the id argument.&n; */
r_int
DECL|function|xfs_qm_dqget
id|xfs_qm_dqget
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_inode_t
op_star
id|ip
comma
multiline_comment|/* locked inode (optional) */
id|xfs_dqid_t
id|id
comma
multiline_comment|/* gid or uid, depending on type */
id|uint
id|type
comma
multiline_comment|/* UDQUOT or GDQUOT */
id|uint
id|flags
comma
multiline_comment|/* DQALLOC, DQSUSER, DQREPAIR, DOWARN */
id|xfs_dquot_t
op_star
op_star
id|O_dqpp
)paren
multiline_comment|/* OUT : locked incore dquot */
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|xfs_dqhash_t
op_star
id|h
suffix:semicolon
id|uint
id|version
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_IS_QUOTA_RUNNING
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|XFS_IS_UQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|type
op_eq
id|XFS_DQ_USER
)paren
op_logical_or
(paren
op_logical_neg
id|XFS_IS_GQUOTA_ON
c_func
(paren
id|mp
)paren
op_logical_and
id|type
op_eq
id|XFS_DQ_GROUP
)paren
)paren
(brace
r_return
(paren
id|ESRCH
)paren
suffix:semicolon
)brace
id|h
op_assign
id|XFS_DQ_HASH
c_func
(paren
id|mp
comma
id|id
comma
id|type
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|xfs_do_dqerror
)paren
(brace
r_if
c_cond
(paren
(paren
id|xfs_dqerror_dev
op_eq
id|mp-&gt;m_dev
)paren
op_logical_and
(paren
id|xfs_dqreq_num
op_increment
op_mod
id|xfs_dqerror_mod
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Returning error in dqget&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|EIO
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|again
suffix:colon
macro_line|#ifdef DEBUG
id|ASSERT
c_func
(paren
id|type
op_eq
id|XFS_DQ_USER
op_logical_or
id|type
op_eq
id|XFS_DQ_GROUP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|XFS_DQ_USER
)paren
id|ASSERT
c_func
(paren
id|ip-&gt;i_udquot
op_eq
l_int|NULL
)paren
suffix:semicolon
r_else
id|ASSERT
c_func
(paren
id|ip-&gt;i_gdquot
op_eq
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif
id|XFS_DQ_HASH_LOCK
c_func
(paren
id|h
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look in the cache (hashtable).&n;&t; * The chain is kept locked during lookup.&n;&t; */
r_if
c_cond
(paren
id|xfs_qm_dqlookup
c_func
(paren
id|mp
comma
id|id
comma
id|h
comma
id|O_dqpp
)paren
op_eq
l_int|0
)paren
(brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_qm_dqcachehits
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The dquot was found, moved to the front of the chain,&n;&t;&t; * taken off the freelist if it was on it, and locked&n;&t;&t; * at this point. Just unlock the hashchain and return.&n;&t;&t; */
id|ASSERT
c_func
(paren
op_star
id|O_dqpp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
op_star
id|O_dqpp
)paren
)paren
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|h
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
op_star
id|O_dqpp
comma
l_string|&quot;DQGET DONE (FROM CACHE)&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* success */
)brace
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_qm_dqcachemisses
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Dquot cache miss. We don&squot;t want to keep the inode lock across&n;&t; * a (potential) disk read. Also we don&squot;t want to deal with the lock&n;&t; * ordering between quotainode and this inode. OTOH, dropping the inode&n;&t; * lock here means dealing with a chown that can happen before&n;&t; * we re-acquire the lock.&n;&t; */
r_if
c_cond
(paren
id|ip
)paren
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save the hashchain version stamp, and unlock the chain, so that&n;&t; * we don&squot;t keep the lock across a disk read&n;&t; */
id|version
op_assign
id|h-&gt;qh_version
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|h
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the dquot on the kernel heap, and read the ondisk&n;&t; * portion off the disk. Also, do all the necessary initialization&n;&t; * This can return ENOENT if dquot didn&squot;t exist on disk and we didn&squot;t&n;&t; * ask it to allocate; ESRCH if quotas got turned off suddenly.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_idtodq
c_func
(paren
id|mp
comma
id|id
comma
id|type
comma
id|flags
op_amp
(paren
id|XFS_QMOPT_DQALLOC
op_or
id|XFS_QMOPT_DQREPAIR
op_or
id|XFS_QMOPT_DOWARN
)paren
comma
op_amp
id|dqp
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ip
)paren
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * See if this is mount code calling to look at the overall quota limits&n;&t; * which are stored in the id == 0 user or group&squot;s dquot.&n;&t; * Since we may not have done a quotacheck by this point, just return&n;&t; * the dquot without attaching it to any hashtables, lists, etc, or even&n;&t; * taking a reference.&n;&t; * The caller must dqdestroy this once done.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DQSUSER
)paren
(brace
id|ASSERT
c_func
(paren
id|id
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|ip
)paren
suffix:semicolon
r_goto
id|dqret
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Dquot lock comes after hashlock in the lock ordering&n;&t; */
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip
)paren
(brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_IS_DQTYPE_ON
c_func
(paren
id|mp
comma
id|type
)paren
)paren
(brace
multiline_comment|/* inode stays locked on return */
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ESRCH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * A dquot could be attached to this inode by now, since&n;&t;&t; * we had dropped the ilock.&n;&t;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|XFS_DQ_USER
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_udquot
)paren
(brace
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp
op_assign
id|ip-&gt;i_udquot
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_goto
id|dqret
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ip-&gt;i_gdquot
)paren
(brace
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp
op_assign
id|ip-&gt;i_gdquot
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_goto
id|dqret
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Hashlock comes after ilock in lock order&n;&t; */
id|XFS_DQ_HASH_LOCK
c_func
(paren
id|h
)paren
suffix:semicolon
r_if
c_cond
(paren
id|version
op_ne
id|h-&gt;qh_version
)paren
(brace
id|xfs_dquot_t
op_star
id|tmpdqp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Now, see if somebody else put the dquot in the&n;&t;&t; * hashtable before us. This can happen because we didn&squot;t&n;&t;&t; * keep the hashchain lock. We don&squot;t have to worry about&n;&t;&t; * lock order between the two dquots here since dqp isn&squot;t&n;&t;&t; * on any findable lists yet.&n;&t;&t; */
r_if
c_cond
(paren
id|xfs_qm_dqlookup
c_func
(paren
id|mp
comma
id|id
comma
id|h
comma
op_amp
id|tmpdqp
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Duplicate found. Just throw away the new dquot&n;&t;&t;&t; * and start over.&n;&t;&t;&t; */
id|xfs_qm_dqput
c_func
(paren
id|tmpdqp
)paren
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|h
)paren
suffix:semicolon
id|xfs_qm_dqdestroy
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_qm_dquot_dups
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Put the dquot at the beginning of the hash-chain and mp&squot;s list&n;&t; * LOCK ORDER: hashlock, freelistlock, mplistlock, udqlock, gdqlock ..&n;&t; */
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_HASH_LOCKED
c_func
(paren
id|h
)paren
)paren
suffix:semicolon
id|dqp-&gt;q_hash
op_assign
id|h
suffix:semicolon
id|XQM_HASHLIST_INSERT
c_func
(paren
id|h
comma
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attach this dquot to this filesystem&squot;s list of all dquots,&n;&t; * kept inside the mount structure in m_quotainfo field&n;&t; */
id|xfs_qm_mplist_lock
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We return a locked dquot to the caller, with a reference taken&n;&t; */
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|dqp-&gt;q_nrefs
op_assign
l_int|1
suffix:semicolon
id|XQM_MPLIST_INSERT
c_func
(paren
op_amp
(paren
id|XFS_QI_MPL_LIST
c_func
(paren
id|mp
)paren
)paren
comma
id|dqp
)paren
suffix:semicolon
id|xfs_qm_mplist_unlock
c_func
(paren
id|mp
)paren
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|h
)paren
suffix:semicolon
id|dqret
suffix:colon
id|ASSERT
c_func
(paren
(paren
id|ip
op_eq
l_int|NULL
)paren
op_logical_or
id|XFS_ISLOCKED_INODE_EXCL
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQGET DONE&quot;
)paren
suffix:semicolon
op_star
id|O_dqpp
op_assign
id|dqp
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release a reference to the dquot (decrement ref-count)&n; * and unlock it. If there is a group quota attached to this&n; * dquot, carefully release that too without tripping over&n; * deadlocks&squot;n&squot;stuff.&n; */
r_void
DECL|function|xfs_qm_dqput
id|xfs_qm_dqput
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|xfs_dquot_t
op_star
id|gdqp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dqp-&gt;q_nrefs
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQPUT&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqp-&gt;q_nrefs
op_ne
l_int|1
)paren
(brace
id|dqp-&gt;q_nrefs
op_decrement
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * drop the dqlock and acquire the freelist and dqlock&n;&t; * in the right order; but try to get it out-of-order first&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_freelist_lock_nowait
c_func
(paren
id|xfs_Gqm
)paren
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQPUT: FLLOCK-WAIT&quot;
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_qm_freelist_lock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|gdqp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We can&squot;t depend on nrefs being == 1 here */
r_if
c_cond
(paren
op_decrement
id|dqp-&gt;q_nrefs
op_eq
l_int|0
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQPUT: ON FREELIST&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * insert at end of the freelist.&n;&t;&t;&t; */
id|XQM_FREELIST_INSERT
c_func
(paren
op_amp
(paren
id|xfs_Gqm-&gt;qm_dqfreelist
)paren
comma
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we just added a udquot to the freelist, then&n;&t;&t;&t; * we want to release the gdquot reference that&n;&t;&t;&t; * it (probably) has. Otherwise it&squot;ll keep the&n;&t;&t;&t; * gdquot from getting reclaimed.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|gdqp
op_assign
id|dqp-&gt;q_gdquot
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Avoid a recursive dqput call&n;&t;&t;&t;&t; */
id|xfs_dqlock
c_func
(paren
id|gdqp
)paren
suffix:semicolon
id|dqp-&gt;q_gdquot
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* xfs_qm_freelist_print(&amp;(xfs_Gqm-&gt;qm_dqfreelist),&n;&t;&t;&t;   &quot;@@@@@++ Free list (after append) @@@@@+&quot;);&n;&t;&t;&t;   */
)brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we had a group quota inside the user quota as a hint,&n;&t;&t; * release it now.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|gdqp
)paren
r_break
suffix:semicolon
id|dqp
op_assign
id|gdqp
suffix:semicolon
)brace
id|xfs_qm_freelist_unlock
c_func
(paren
id|xfs_Gqm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release a dquot. Flush it if dirty, then dqput() it.&n; * dquot must not be locked.&n; */
r_void
DECL|function|xfs_qm_dqrele
id|xfs_qm_dqrele
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|ASSERT
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQRELE&quot;
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t care to flush it if the dquot is dirty here.&n;&t; * That will create stutters that we want to avoid.&n;&t; * Instead we do a delayed write when we try to reclaim&n;&t; * a dirty dquot. Also xfs_sync will take part of the burden...&n;&t; */
id|xfs_qm_dqput
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a modified dquot to disk.&n; * The dquot must be locked and the flush lock too taken by caller.&n; * The flush lock will not be unlocked until the dquot reaches the disk,&n; * but the dquot is free to be unlocked and modified by the caller&n; * in the interim. Dquot is still locked on return. This behavior is&n; * identical to that of inodes.&n; */
r_int
DECL|function|xfs_qm_dqflush
id|xfs_qm_dqflush
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
comma
id|uint
id|flags
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_disk_dquot_t
op_star
id|ddqp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_FLUSH_LOCKED
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQFLUSH&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If not dirty, nada.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Cant flush a pinned dquot. Wait for it.&n;&t; */
id|xfs_qm_dqunpin_wait
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This may have been unpinned because the filesystem is shutting&n;&t; * down forcibly. If that&squot;s the case we must not write this dquot&n;&t; * to disk, because the log record didn&squot;t make it to disk!&n;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dqp-&gt;q_mount
)paren
)paren
(brace
id|dqp-&gt;dq_flags
op_and_assign
op_complement
(paren
id|XFS_DQ_DIRTY
)paren
suffix:semicolon
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the buffer containing the on-disk dquot&n;&t; * We don&squot;t need a transaction envelope because we know that the&n;&t; * the ondisk-dquot has already been allocated for.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_dqtobp
c_func
(paren
l_int|NULL
comma
id|dqp
comma
op_amp
id|ddqp
comma
op_amp
id|bp
comma
id|XFS_QMOPT_DOWARN
)paren
)paren
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQTOBP FAIL&quot;
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOENT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Quotas could have gotten turned off (ESRCH)&n;&t;&t; */
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfs_qm_dqcheck
c_func
(paren
op_amp
id|dqp-&gt;q_core
comma
id|INT_GET
c_func
(paren
id|ddqp-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
l_int|0
comma
id|XFS_QMOPT_DOWARN
comma
l_string|&quot;dqflush (incore copy)&quot;
)paren
)paren
(brace
id|xfs_force_shutdown
c_func
(paren
id|dqp-&gt;q_mount
comma
id|XFS_CORRUPT_INCORE
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* This is the only portion of data that needs to persist */
id|memcpy
c_func
(paren
id|ddqp
comma
op_amp
(paren
id|dqp-&gt;q_core
)paren
comma
r_sizeof
(paren
id|xfs_disk_dquot_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the dirty field and remember the flush lsn for later use.&n;&t; */
id|dqp-&gt;dq_flags
op_and_assign
op_complement
(paren
id|XFS_DQ_DIRTY
)paren
suffix:semicolon
id|mp
op_assign
id|dqp-&gt;q_mount
suffix:semicolon
multiline_comment|/* lsn is 64 bits */
id|AIL_LOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|dqp-&gt;q_logitem.qli_flush_lsn
op_assign
id|dqp-&gt;q_logitem.qli_item.li_lsn
suffix:semicolon
id|AIL_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attach an iodone routine so that we can remove this dquot from the&n;&t; * AIL and release the flush lock once the dquot is synced to disk.&n;&t; */
id|xfs_buf_attach_iodone
c_func
(paren
id|bp
comma
(paren
r_void
(paren
op_star
)paren
(paren
id|xfs_buf_t
op_star
comma
id|xfs_log_item_t
op_star
)paren
)paren
id|xfs_qm_dqflush_done
comma
op_amp
(paren
id|dqp-&gt;q_logitem.qli_item
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the buffer is pinned then push on the log so we won&squot;t&n;&t; * get stuck waiting in the write for too long.&n;&t; */
r_if
c_cond
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQFLUSH LOG FORCE&quot;
)paren
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DELWRI
)paren
(brace
id|xfs_bdwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_ASYNC
)paren
(brace
id|xfs_bawrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQFLUSH END&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dqp is still locked, but caller is free to unlock it now.&n;&t; */
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the dquot flushing I/O completion routine.  It is called&n; * from interrupt level when the buffer containing the dquot is&n; * flushed to disk.  It is responsible for removing the dquot logitem&n; * from the AIL if it has not been re-logged, and unlocking the dquot&squot;s&n; * flush lock. This behavior is very similar to that of inodes..&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_void
DECL|function|xfs_qm_dqflush_done
id|xfs_qm_dqflush_done
c_func
(paren
id|xfs_buf_t
op_star
id|bp
comma
id|xfs_dq_logitem_t
op_star
id|qip
)paren
(brace
id|xfs_dquot_t
op_star
id|dqp
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|dqp
op_assign
id|qip-&gt;qli_dquot
suffix:semicolon
multiline_comment|/*&n;&t; * We only want to pull the item from the AIL if its&n;&t; * location in the log has not changed since we started the flush.&n;&t; * Thus, we only bother if the dquot&squot;s lsn has&n;&t; * not changed. First we check the lsn outside the lock&n;&t; * since it&squot;s cheaper, and then we recheck while&n;&t; * holding the lock before removing the dquot from the AIL.&n;&t; */
r_if
c_cond
(paren
(paren
id|qip-&gt;qli_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
op_logical_and
id|qip-&gt;qli_item.li_lsn
op_eq
id|qip-&gt;qli_flush_lsn
)paren
(brace
id|AIL_LOCK
c_func
(paren
id|dqp-&gt;q_mount
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * xfs_trans_delete_ail() drops the AIL lock.&n;&t;&t; */
r_if
c_cond
(paren
id|qip-&gt;qli_item.li_lsn
op_eq
id|qip-&gt;qli_flush_lsn
)paren
id|xfs_trans_delete_ail
c_func
(paren
id|dqp-&gt;q_mount
comma
(paren
id|xfs_log_item_t
op_star
)paren
id|qip
comma
id|s
)paren
suffix:semicolon
r_else
id|AIL_UNLOCK
c_func
(paren
id|dqp-&gt;q_mount
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release the dq&squot;s flush lock since we&squot;re done with it.&n;&t; */
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_qm_dqflock_nowait
id|xfs_qm_dqflock_nowait
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
r_int
id|locked
suffix:semicolon
id|locked
op_assign
id|cpsema
c_func
(paren
op_amp
(paren
(paren
id|dqp
)paren
op_member_access_from_pointer
id|q_flock
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX ifdef these out */
r_if
c_cond
(paren
id|locked
)paren
(paren
id|dqp
)paren
op_member_access_from_pointer
id|dq_flags
op_or_assign
id|XFS_DQ_FLOCKED
suffix:semicolon
r_return
(paren
id|locked
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_qm_dqlock_nowait
id|xfs_qm_dqlock_nowait
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
r_return
(paren
id|mutex_trylock
c_func
(paren
op_amp
(paren
(paren
id|dqp
)paren
op_member_access_from_pointer
id|q_qlock
)paren
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_dqlock
id|xfs_dqlock
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|mutex_lock
c_func
(paren
op_amp
(paren
id|dqp-&gt;q_qlock
)paren
comma
id|PINOD
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_dqunlock
id|xfs_dqunlock
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|dqp-&gt;q_qlock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dqp-&gt;q_logitem.qli_dquot
op_eq
id|dqp
)paren
(brace
multiline_comment|/* Once was dqp-&gt;q_mount, but might just have been cleared */
id|xfs_trans_unlocked_item
c_func
(paren
id|dqp-&gt;q_logitem.qli_item.li_mountp
comma
(paren
id|xfs_log_item_t
op_star
)paren
op_amp
(paren
id|dqp-&gt;q_logitem
)paren
)paren
suffix:semicolon
)brace
)brace
r_void
DECL|function|xfs_dqunlock_nonotify
id|xfs_dqunlock_nonotify
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|mutex_unlock
c_func
(paren
op_amp
(paren
id|dqp-&gt;q_qlock
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_dqlock2
id|xfs_dqlock2
c_func
(paren
id|xfs_dquot_t
op_star
id|d1
comma
id|xfs_dquot_t
op_star
id|d2
)paren
(brace
r_if
c_cond
(paren
id|d1
op_logical_and
id|d2
)paren
(brace
id|ASSERT
c_func
(paren
id|d1
op_ne
id|d2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|d1-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|d2-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|d2
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|d1
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_dqlock
c_func
(paren
id|d1
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|d2
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|d1
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|d1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|d2
)paren
(brace
id|xfs_dqlock
c_func
(paren
id|d2
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * A rarely used accessor. This exists because we don&squot;t really want&n; * to expose the internals of a dquot to the outside world.&n; */
id|xfs_dqid_t
DECL|function|xfs_qm_dqid
id|xfs_qm_dqid
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
r_return
(paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Take a dquot out of the mount&squot;s dqlist as well as the hashlist.&n; * This is called via unmount as well as quotaoff, and the purge&n; * will always succeed unless there are soft (temp) references&n; * outstanding.&n; *&n; * This returns 0 if it was purged, 1 if it wasn&squot;t. It&squot;s not an error code&n; * that we&squot;re returning! XXXsup - not cool.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|xfs_qm_dqpurge
id|xfs_qm_dqpurge
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
comma
id|uint
id|flags
)paren
(brace
id|xfs_dqhash_t
op_star
id|thishash
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|dqp-&gt;q_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_QM_IS_MPLIST_LOCKED
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_HASH_LOCKED
c_func
(paren
id|dqp-&gt;q_hash
)paren
)paren
suffix:semicolon
id|xfs_dqlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We really can&squot;t afford to purge a dquot that is&n;&t; * referenced, because these are hard refs.&n;&t; * It shouldn&squot;t happen in general because we went thru _all_ inodes in&n;&t; * dqrele_all_inodes before calling this and didn&squot;t let the mountlock go.&n;&t; * However it is possible that we have dquots with temporary&n;&t; * references that are not attached to an inode. e.g. see xfs_setattr().&n;&t; */
r_if
c_cond
(paren
id|dqp-&gt;q_nrefs
op_ne
l_int|0
)paren
(brace
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|dqp-&gt;q_hash
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_ON_FREELIST
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re turning off quotas, we have to make sure that, for&n;&t; * example, we don&squot;t delete quota disk blocks while dquots are&n;&t; * in the process of getting written to those disk blocks.&n;&t; * This dquot might well be on AIL, and we can&squot;t leave it there&n;&t; * if we&squot;re turning off quotas. Basically, we need this flush&n;&t; * lock, and are willing to block on it.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|xfs_qm_dqflock_nowait
c_func
(paren
id|dqp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Block on the flush lock after nudging dquot buffer,&n;&t;&t; * if it is incore.&n;&t;&t; */
id|xfs_qm_dqflock_pushbuf_wait
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * XXXIf we&squot;re turning this type of quotas off, we don&squot;t care&n;&t; * about the dirty metadata sitting in this dquot. OTOH, if&n;&t; * we&squot;re unmounting, we do care, so we flush it and wait.&n;&t; */
r_if
c_cond
(paren
id|XFS_DQ_IS_DIRTY
c_func
(paren
id|dqp
)paren
)paren
(brace
id|xfs_dqtrace_entry
c_func
(paren
id|dqp
comma
l_string|&quot;DQPURGE -&gt;DQFLUSH: DQDIRTY&quot;
)paren
suffix:semicolon
multiline_comment|/* dqflush unlocks dqflock */
multiline_comment|/*&n;&t;&t; * Given that dqpurge is a very rare occurrence, it is OK&n;&t;&t; * that we&squot;re holding the hashlist and mplist locks&n;&t;&t; * across the disk write. But, ... XXXsup&n;&t;&t; *&n;&t;&t; * We don&squot;t care about getting disk errors here. We need&n;&t;&t; * to purge this dquot anyway, so we go ahead regardless.&n;&t;&t; */
(paren
r_void
)paren
id|xfs_qm_dqflush
c_func
(paren
id|dqp
comma
id|XFS_QMOPT_SYNC
)paren
suffix:semicolon
id|xfs_dqflock
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dqp-&gt;q_pincount
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
op_logical_or
op_logical_neg
(paren
id|dqp-&gt;q_logitem.qli_item.li_flags
op_amp
id|XFS_LI_IN_AIL
)paren
)paren
suffix:semicolon
id|thishash
op_assign
id|dqp-&gt;q_hash
suffix:semicolon
id|XQM_HASHLIST_REMOVE
c_func
(paren
id|thishash
comma
id|dqp
)paren
suffix:semicolon
id|XQM_MPLIST_REMOVE
c_func
(paren
op_amp
(paren
id|XFS_QI_MPL_LIST
c_func
(paren
id|mp
)paren
)paren
comma
id|dqp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Move this to the front of the freelist, if we can get the&n;&t; * freelist lock.&n;&t; */
id|ASSERT
c_func
(paren
id|XFS_DQ_IS_ON_FREELIST
c_func
(paren
id|dqp
)paren
)paren
suffix:semicolon
id|dqp-&gt;q_mount
op_assign
l_int|NULL
suffix:semicolon
suffix:semicolon
id|dqp-&gt;q_hash
op_assign
l_int|NULL
suffix:semicolon
id|dqp-&gt;dq_flags
op_assign
id|XFS_DQ_INACTIVE
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dqp-&gt;q_core
comma
l_int|0
comma
r_sizeof
(paren
id|dqp-&gt;q_core
)paren
)paren
suffix:semicolon
id|xfs_dqfunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|xfs_dqunlock
c_func
(paren
id|dqp
)paren
suffix:semicolon
id|XFS_DQ_HASH_UNLOCK
c_func
(paren
id|thishash
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Do some primitive error checking on ondisk dquot&n; * data structures. Not just for debugging, actually;&n; * this can be useful for detecting data corruption mainly due to&n; * disk failures.&n; */
multiline_comment|/* ARGSUSED */
r_int
DECL|function|xfs_qm_dqcheck
id|xfs_qm_dqcheck
c_func
(paren
id|xfs_disk_dquot_t
op_star
id|ddq
comma
id|xfs_dqid_t
id|id
comma
id|uint
id|type
comma
multiline_comment|/* used only when IO_dorepair is true */
id|uint
id|flags
comma
r_char
op_star
id|str
)paren
(brace
r_int
id|errs
suffix:semicolon
id|errs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ASSERT(flags &amp; (XFS_QMOPT_DQREPAIR|XFS_QMOPT_DOWARN)); */
multiline_comment|/*&n;&t; * We can encounter an uninitialized dquot buffer for 2 reasons:&n;&t; * 1. If we crash while deleting the quotainode(s), and those blks get used&n;&t; *    for some user data. This is because we take the path of regular&n;&t; *    file deletion; however, the size field of quotainodes is never&n;&t; *    updated, so all the tricks that we play in itruncate_finish&n;&t; *    don&squot;t quite matter.&n;&t; *&n;&t; * 2. We don&squot;t play the quota buffers when there&squot;s a quotaoff logitem.&n;&t; *    But the allocation will be replayed so we&squot;ll end up with an&n;&t; *    uninitialized quota block.&n;&t; *&n;&t; * This is all fine; things are still consistent, and we haven&squot;t lost&n;&t; * any quota information. Just don&squot;t complain about bad dquot blks.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQUOT_MAGIC
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x&quot;
comma
id|str
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_magic
comma
id|ARCH_CONVERT
)paren
comma
id|XFS_DQUOT_MAGIC
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_version
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQUOT_VERSION
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : XFS dquot ID 0x%x, version 0x%x != 0x%x&quot;
comma
id|str
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_magic
comma
id|ARCH_CONVERT
)paren
comma
id|XFS_DQUOT_VERSION
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQ_USER
op_logical_and
id|INT_GET
c_func
(paren
id|ddq-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DQ_GROUP
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : XFS dquot ID 0x%x, unknown flags 0x%x&quot;
comma
id|str
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_flags
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|id
op_ne
op_minus
l_int|1
op_logical_and
id|id
op_ne
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : ondisk-dquot 0x%x, ID mismatch: &quot;
l_string|&quot;0x%x expected, found id 0x%x&quot;
comma
id|str
comma
id|ddq
comma
id|id
comma
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|errs
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|ddq-&gt;d_bcount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|ddq-&gt;d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_btimer
comma
id|ARCH_CONVERT
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : Dquot ID 0x%x (0x%x) &quot;
l_string|&quot;BLK TIMER NOT STARTED&quot;
comma
id|str
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
id|ddq
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|ddq-&gt;d_icount
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|ddq-&gt;d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_itimer
comma
id|ARCH_CONVERT
)paren
op_logical_and
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;%s : Dquot ID 0x%x (0x%x) &quot;
l_string|&quot;INODE TIMER NOT STARTED&quot;
comma
id|str
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|ddq-&gt;d_id
comma
id|ARCH_CONVERT
)paren
comma
id|ddq
)paren
suffix:semicolon
id|errs
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|errs
op_logical_or
op_logical_neg
(paren
id|flags
op_amp
id|XFS_QMOPT_DQREPAIR
)paren
)paren
r_return
(paren
id|errs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_QMOPT_DOWARN
)paren
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;Re-initializing dquot ID 0x%x&quot;
comma
id|id
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Typically, a repair is only requested by quotacheck.&n;&t; */
id|ASSERT
c_func
(paren
id|id
op_ne
op_minus
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|flags
op_amp
id|XFS_QMOPT_DQREPAIR
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ddq
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_dqblk_t
)paren
)paren
suffix:semicolon
id|xfs_qm_dqinit_core
c_func
(paren
id|id
comma
id|type
comma
(paren
id|xfs_dqblk_t
op_star
)paren
id|ddq
)paren
suffix:semicolon
r_return
(paren
id|errs
)paren
suffix:semicolon
)brace
macro_line|#ifdef QUOTADEBUG
r_void
DECL|function|xfs_qm_dqprint
id|xfs_qm_dqprint
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;-----------KERNEL DQUOT----------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- dquot ID&t;=  %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_id
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- type&t;=  %s&bslash;n&quot;
comma
id|XFS_QM_ISUDQ
c_func
(paren
id|dqp
)paren
ques
c_cond
l_string|&quot;USR&quot;
suffix:colon
l_string|&quot;GRP&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- fs&t;=  0x%p&bslash;n&quot;
comma
id|dqp-&gt;q_mount
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- blkno&t;=  0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|dqp-&gt;q_blkno
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- boffset&t;=  0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|dqp-&gt;q_bufoffset
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- blkhlimit =  %Lu (0x%x)&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- blkslimit =  %Lu (0x%x)&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_blk_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- inohlimit =  %Lu (0x%x)&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_hardlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- inoslimit =  %Lu (0x%x)&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_ino_softlimit
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- bcount&t;=  %Lu (0x%x)&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_bcount
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_bcount
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- icount&t;=  %Lu (0x%x)&bslash;n&quot;
comma
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_icount
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_icount
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- btimer&t;=  %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_btimer
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---- itimer&t;=  %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|dqp-&gt;q_core.d_itimer
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---------------------------&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Give the buffer a little push if it is incore and&n; * wait on the flush lock.&n; */
r_void
DECL|function|xfs_qm_dqflock_pushbuf_wait
id|xfs_qm_dqflock_pushbuf_wait
c_func
(paren
id|xfs_dquot_t
op_star
id|dqp
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if the dquot has been flushed delayed&n;&t; * write.  If so, grab its buffer and send it&n;&t; * out immediately.  We&squot;ll be able to acquire&n;&t; * the flush lock when the I/O completes.&n;&t; */
id|bp
op_assign
id|xfs_incore
c_func
(paren
id|dqp-&gt;q_mount-&gt;m_ddev_targp
comma
id|dqp-&gt;q_blkno
comma
id|XFS_QI_DQCHUNKLEN
c_func
(paren
id|dqp-&gt;q_mount
)paren
comma
id|XFS_INCORE_TRYLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|XFS_BUF_ISDELAYWRITE
c_func
(paren
id|bp
)paren
)paren
(brace
r_if
c_cond
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_log_force
c_func
(paren
id|dqp-&gt;q_mount
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
)brace
id|xfs_bawrite
c_func
(paren
id|dqp-&gt;q_mount
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
id|xfs_dqflock
c_func
(paren
id|dqp
)paren
suffix:semicolon
)brace
eof
