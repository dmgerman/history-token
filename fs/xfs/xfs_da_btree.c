multiline_comment|/*&n; * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_attr_leaf.h&quot;
macro_line|#include &quot;xfs_dir_leaf.h&quot;
macro_line|#include &quot;xfs_dir2_data.h&quot;
macro_line|#include &quot;xfs_dir2_leaf.h&quot;
macro_line|#include &quot;xfs_dir2_block.h&quot;
macro_line|#include &quot;xfs_dir2_node.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
multiline_comment|/*&n; * xfs_da_btree.c&n; *&n; * Routines to implement directories as Btrees of hashed names.&n; */
multiline_comment|/*========================================================================&n; * Function prototypes for the kernel.&n; *========================================================================*/
multiline_comment|/*&n; * Routines used for growing the Btree.&n; */
id|STATIC
r_int
id|xfs_da_root_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|existing_root
comma
id|xfs_da_state_blk_t
op_star
id|new_child
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_da_node_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|existing_blk
comma
id|xfs_da_state_blk_t
op_star
id|split_blk
comma
id|xfs_da_state_blk_t
op_star
id|blk_to_add
comma
r_int
id|treelevel
comma
r_int
op_star
id|result
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_da_node_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|node_blk_1
comma
id|xfs_da_state_blk_t
op_star
id|node_blk_2
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_da_node_add
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|old_node_blk
comma
id|xfs_da_state_blk_t
op_star
id|new_node_blk
)paren
suffix:semicolon
multiline_comment|/*&n; * Routines used for shrinking the Btree.&n; */
id|STATIC
r_int
id|xfs_da_root_join
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|root_blk
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_da_node_toosmall
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
r_int
op_star
id|retval
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_da_node_remove
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|drop_blk
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_da_node_unbalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|src_node_blk
comma
id|xfs_da_state_blk_t
op_star
id|dst_node_blk
)paren
suffix:semicolon
multiline_comment|/*&n; * Utility routines.&n; */
id|STATIC
id|uint
id|xfs_da_node_lasthash
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
op_star
id|count
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_da_node_order
c_func
(paren
id|xfs_dabuf_t
op_star
id|node1_bp
comma
id|xfs_dabuf_t
op_star
id|node2_bp
)paren
suffix:semicolon
id|STATIC
id|xfs_dabuf_t
op_star
id|xfs_da_buf_make
c_func
(paren
r_int
id|nbuf
comma
id|xfs_buf_t
op_star
op_star
id|bps
comma
id|inst_t
op_star
id|ra
)paren
suffix:semicolon
multiline_comment|/*========================================================================&n; * Routines used for growing the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Create the initial contents of an intermediate node.&n; */
r_int
DECL|function|xfs_da_node_create
id|xfs_da_node_create
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dablk_t
id|blkno
comma
r_int
id|level
comma
id|xfs_dabuf_t
op_star
op_star
id|bpp
comma
r_int
id|whichfork
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|tp
comma
id|args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|node-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|node-&gt;hdr.info.back
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|node-&gt;hdr.info.pad
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;hdr.level
comma
id|ARCH_CONVERT
comma
id|level
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
op_amp
id|node-&gt;hdr
comma
r_sizeof
(paren
id|node-&gt;hdr
)paren
)paren
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Split a leaf node, rebalance, then possibly split&n; * intermediate nodes, rebalance, etc.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_da_split
id|xfs_da_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
(brace
id|xfs_da_state_blk_t
op_star
id|oldblk
comma
op_star
id|newblk
comma
op_star
id|addblk
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|max
comma
id|action
comma
id|error
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Walk back up the tree splitting/inserting/adjusting as necessary.&n;&t; * If we need to insert and there isn&squot;t room, split the node, then&n;&t; * decide which fragment to insert the new block from below into.&n;&t; * Note that we may split the root this way, but we need more fixup.&n;&t; */
id|max
op_assign
id|state-&gt;path.active
op_minus
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|max
op_ge
l_int|0
)paren
op_logical_and
(paren
id|max
OL
id|XFS_DA_NODE_MAXDEPTH
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|state-&gt;path.blk
(braket
id|max
)braket
dot
id|magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
op_logical_or
id|state-&gt;path.blk
(braket
id|max
)braket
dot
id|magic
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|addblk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|max
)braket
suffix:semicolon
multiline_comment|/* initial dummy value */
r_for
c_loop
(paren
id|i
op_assign
id|max
suffix:semicolon
(paren
id|i
op_ge
l_int|0
)paren
op_logical_and
id|addblk
suffix:semicolon
id|state-&gt;path.active
op_decrement
comma
id|i
op_decrement
)paren
(brace
id|oldblk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|i
)braket
suffix:semicolon
id|newblk
op_assign
op_amp
id|state-&gt;altpath.blk
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If a leaf node then&n;&t;&t; *     Allocate a new leaf node, then rebalance across them.&n;&t;&t; * else if an intermediate node then&n;&t;&t; *     We split on the last layer, must we split the node?&n;&t;&t; */
r_switch
c_cond
(paren
id|oldblk-&gt;magic
)paren
(brace
r_case
id|XFS_ATTR_LEAF_MAGIC
suffix:colon
macro_line|#ifndef __KERNEL__
r_return
id|ENOTTY
suffix:semicolon
macro_line|#else
id|error
op_assign
id|xfs_attr_leaf_split
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_ne
l_int|0
)paren
op_logical_and
(paren
id|error
op_ne
id|ENOSPC
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: attr is inconsistent */
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|addblk
op_assign
id|newblk
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Entry wouldn&squot;t fit, split the leaf again.&n;&t;&t;&t; */
id|state-&gt;extravalid
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;inleaf
)paren
(brace
id|state-&gt;extraafter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* before newblk */
id|error
op_assign
id|xfs_attr_leaf_split
c_func
(paren
id|state
comma
id|oldblk
comma
op_amp
id|state-&gt;extrablk
)paren
suffix:semicolon
)brace
r_else
(brace
id|state-&gt;extraafter
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* after newblk */
id|error
op_assign
id|xfs_attr_leaf_split
c_func
(paren
id|state
comma
id|newblk
comma
op_amp
id|state-&gt;extrablk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: attr inconsistent */
id|addblk
op_assign
id|newblk
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|XFS_DIR_LEAF_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V1
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_dir_leaf_split
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_ne
l_int|0
)paren
op_logical_and
(paren
id|error
op_ne
id|ENOSPC
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: dir is inconsistent */
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|addblk
op_assign
id|newblk
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Entry wouldn&squot;t fit, split the leaf again.&n;&t;&t;&t; */
id|state-&gt;extravalid
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;inleaf
)paren
(brace
id|state-&gt;extraafter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* before newblk */
id|error
op_assign
id|xfs_dir_leaf_split
c_func
(paren
id|state
comma
id|oldblk
comma
op_amp
id|state-&gt;extrablk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: dir incon. */
id|addblk
op_assign
id|newblk
suffix:semicolon
)brace
r_else
(brace
id|state-&gt;extraafter
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* after newblk */
id|error
op_assign
id|xfs_dir_leaf_split
c_func
(paren
id|state
comma
id|newblk
comma
op_amp
id|state-&gt;extrablk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: dir incon. */
id|addblk
op_assign
id|newblk
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|XFS_DIR2_LEAFN_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_dir2_leafn_split
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|addblk
op_assign
id|newblk
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DA_NODE_MAGIC
suffix:colon
id|error
op_assign
id|xfs_da_node_split
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
comma
id|addblk
comma
id|max
op_minus
id|i
comma
op_amp
id|action
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|addblk-&gt;bp
)paren
suffix:semicolon
id|addblk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: dir is inconsistent */
multiline_comment|/*&n;&t;&t;&t; * Record the newly split block for the next time thru?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|action
)paren
id|addblk
op_assign
id|newblk
suffix:semicolon
r_else
id|addblk
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Update the btree to show the new hashval for this child.&n;&t;&t; */
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we won&squot;t need this block again, it&squot;s getting dropped&n;&t;&t; * from the active path by the loop control, so we need&n;&t;&t; * to mark it done now.&n;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_or
op_logical_neg
id|addblk
)paren
id|xfs_da_buf_done
c_func
(paren
id|oldblk-&gt;bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|addblk
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Split the root node.&n;&t; */
id|ASSERT
c_func
(paren
id|state-&gt;path.active
op_eq
l_int|0
)paren
suffix:semicolon
id|oldblk
op_assign
op_amp
id|state-&gt;path.blk
(braket
l_int|0
)braket
suffix:semicolon
id|error
op_assign
id|xfs_da_root_split
c_func
(paren
id|state
comma
id|oldblk
comma
id|addblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|oldblk-&gt;bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|addblk-&gt;bp
)paren
suffix:semicolon
id|addblk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: dir is inconsistent */
)brace
multiline_comment|/*&n;&t; * Update pointers to the node which used to be block 0 and&n;&t; * just got bumped because of the addition of a new root node.&n;&t; * There might be three blocks involved if a double split occurred,&n;&t; * and the original block 0 could be at any position in the list.&n;&t; */
id|node
op_assign
id|oldblk-&gt;bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|node-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
op_eq
id|addblk-&gt;blkno
)paren
(brace
id|bp
op_assign
id|addblk-&gt;bp
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|state-&gt;extravalid
)paren
suffix:semicolon
id|bp
op_assign
id|state-&gt;extrablk.bp
suffix:semicolon
)brace
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;hdr.info.back
comma
id|ARCH_CONVERT
comma
id|oldblk-&gt;blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
op_amp
id|node-&gt;hdr.info
comma
r_sizeof
(paren
id|node-&gt;hdr.info
)paren
)paren
)paren
suffix:semicolon
)brace
id|node
op_assign
id|oldblk-&gt;bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.back
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.back
comma
id|ARCH_CONVERT
)paren
op_eq
id|addblk-&gt;blkno
)paren
(brace
id|bp
op_assign
id|addblk-&gt;bp
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|state-&gt;extravalid
)paren
suffix:semicolon
id|bp
op_assign
id|state-&gt;extrablk.bp
suffix:semicolon
)brace
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
comma
id|oldblk-&gt;blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
op_amp
id|node-&gt;hdr.info
comma
r_sizeof
(paren
id|node-&gt;hdr.info
)paren
)paren
)paren
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|oldblk-&gt;bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|addblk-&gt;bp
)paren
suffix:semicolon
id|addblk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Split the root.  We have to create a new root and point to the two&n; * parts (the split old root) that we just created.  Copy block zero to&n; * the EOF, extending the inode in process.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_da_root_split
id|xfs_da_root_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
comma
op_star
id|oldroot
suffix:semicolon
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
comma
id|size
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the existing (incorrect) block from the root node position&n;&t; * to a free space somewhere.&n;&t; */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|ASSERT
c_func
(paren
id|args
op_ne
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|args
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|state-&gt;mp
suffix:semicolon
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|oldroot
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|oldroot-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
(brace
id|size
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|oldroot-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|oldroot-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
op_minus
(paren
r_char
op_star
)paren
id|oldroot
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|oldroot-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_dir2_leaf_t
op_star
)paren
id|oldroot
suffix:semicolon
id|size
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|leaf-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
op_minus
(paren
r_char
op_star
)paren
id|leaf
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|node
comma
id|oldroot
comma
id|size
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
l_int|0
comma
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|blk1-&gt;bp
)paren
suffix:semicolon
id|blk1-&gt;bp
op_assign
id|bp
suffix:semicolon
id|blk1-&gt;blkno
op_assign
id|blkno
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the new root node.&n;&t; */
id|error
op_assign
id|xfs_da_node_create
c_func
(paren
id|args
comma
id|args-&gt;whichfork
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
ques
c_cond
id|mp-&gt;m_dirleafblk
suffix:colon
l_int|0
comma
id|INT_GET
c_func
(paren
id|node-&gt;hdr.level
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
comma
op_amp
id|bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
comma
id|blk1-&gt;hashval
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|before
comma
id|ARCH_CONVERT
comma
id|blk1-&gt;blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;btree
(braket
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
comma
id|blk2-&gt;hashval
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;btree
(braket
l_int|1
)braket
dot
id|before
comma
id|ARCH_CONVERT
comma
id|blk2-&gt;blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|oldroot-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
(brace
id|ASSERT
c_func
(paren
id|blk1-&gt;blkno
op_ge
id|mp-&gt;m_dirleafblk
op_logical_and
id|blk1-&gt;blkno
OL
id|mp-&gt;m_dirfreeblk
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk2-&gt;blkno
op_ge
id|mp-&gt;m_dirleafblk
op_logical_and
id|blk2-&gt;blkno
OL
id|mp-&gt;m_dirfreeblk
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Header is already logged by xfs_da_node_create */
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
id|node-&gt;btree
comma
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
op_star
l_int|2
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Split the node, rebalance, then add the new entry.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_da_node_split
id|xfs_da_node_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|oldblk
comma
id|xfs_da_state_blk_t
op_star
id|newblk
comma
id|xfs_da_state_blk_t
op_star
id|addblk
comma
r_int
id|treelevel
comma
r_int
op_star
id|result
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
r_int
id|newcount
comma
id|error
suffix:semicolon
r_int
id|useextra
suffix:semicolon
id|node
op_assign
id|oldblk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * With V2 the extra block is data or freespace.&n;&t; */
id|useextra
op_assign
id|state-&gt;extravalid
op_logical_and
id|XFS_DIR_IS_V1
c_func
(paren
id|state-&gt;mp
)paren
suffix:semicolon
id|newcount
op_assign
l_int|1
op_plus
id|useextra
suffix:semicolon
multiline_comment|/*&n;&t; * Do we have to split the node?&n;&t; */
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
id|newcount
)paren
OG
id|state-&gt;node_ents
)paren
(brace
multiline_comment|/*&n;&t;&t; * Allocate a new node, add to the doubly linked chain of&n;&t;&t; * nodes, then move some of our excess entries into it.&n;&t;&t; */
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|state-&gt;args
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: dir is inconsistent */
id|error
op_assign
id|xfs_da_node_create
c_func
(paren
id|state-&gt;args
comma
id|blkno
comma
id|treelevel
comma
op_amp
id|newblk-&gt;bp
comma
id|state-&gt;args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* GROT: dir is inconsistent */
id|newblk-&gt;blkno
op_assign
id|blkno
suffix:semicolon
id|newblk-&gt;magic
op_assign
id|XFS_DA_NODE_MAGIC
suffix:semicolon
id|xfs_da_node_rebalance
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_blk_link
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
op_star
id|result
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
op_star
id|result
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Insert the new entry(s) into the correct block&n;&t; * (updating last hashval in the process).&n;&t; *&n;&t; * xfs_da_node_add() inserts BEFORE the given index,&n;&t; * and as a result of using node_lookup_int() we always&n;&t; * point to a valid entry (not after one), but a split&n;&t; * operation always results in a new block whose hashvals&n;&t; * FOLLOW the current block.&n;&t; *&n;&t; * If we had double-split op below us, then add the extra block too.&n;&t; */
id|node
op_assign
id|oldblk-&gt;bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|oldblk-&gt;index
op_le
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|oldblk-&gt;index
op_increment
suffix:semicolon
id|xfs_da_node_add
c_func
(paren
id|state
comma
id|oldblk
comma
id|addblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|useextra
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;extraafter
)paren
id|oldblk-&gt;index
op_increment
suffix:semicolon
id|xfs_da_node_add
c_func
(paren
id|state
comma
id|oldblk
comma
op_amp
id|state-&gt;extrablk
)paren
suffix:semicolon
id|state-&gt;extravalid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|newblk-&gt;index
op_increment
suffix:semicolon
id|xfs_da_node_add
c_func
(paren
id|state
comma
id|newblk
comma
id|addblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|useextra
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;extraafter
)paren
id|newblk-&gt;index
op_increment
suffix:semicolon
id|xfs_da_node_add
c_func
(paren
id|state
comma
id|newblk
comma
op_amp
id|state-&gt;extrablk
)paren
suffix:semicolon
id|state-&gt;extravalid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Balance the btree elements between two intermediate nodes,&n; * usually one full and one empty.&n; *&n; * NOTE: if blk2 is empty, then it will get the upper half of blk1.&n; */
id|STATIC
r_void
DECL|function|xfs_da_node_rebalance
id|xfs_da_node_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node1
comma
op_star
id|node2
comma
op_star
id|tmpnode
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree_s
comma
op_star
id|btree_d
suffix:semicolon
r_int
id|count
comma
id|tmp
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|node1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|node2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Figure out how many entries need to move, and in which direction.&n;&t; * Swap the nodes around if that makes it simpler.&n;&t; */
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|node1-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|node1-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
id|tmpnode
op_assign
id|node1
suffix:semicolon
id|node1
op_assign
id|node2
suffix:semicolon
id|node2
op_assign
id|tmpnode
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|count
op_assign
(paren
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|tp
op_assign
id|state-&gt;args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * Two cases: high-to-low and low-to-high.&n;&t; */
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Move elements in node2 up to make a hole.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
OG
l_int|0
)paren
(brace
id|tmp
op_mul_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|btree_s
op_assign
op_amp
id|node2-&gt;btree
(braket
l_int|0
)braket
suffix:semicolon
id|btree_d
op_assign
op_amp
id|node2-&gt;btree
(braket
id|count
)braket
suffix:semicolon
id|memmove
c_func
(paren
id|btree_d
comma
id|btree_s
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move the req&squot;d B-tree elements from high in node1 to&n;&t;&t; * low in node2.&n;&t;&t; */
id|INT_MOD
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
id|count
)paren
suffix:semicolon
id|tmp
op_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|btree_s
op_assign
op_amp
id|node1-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
)braket
suffix:semicolon
id|btree_d
op_assign
op_amp
id|node2-&gt;btree
(braket
l_int|0
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|btree_d
comma
id|btree_s
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|count
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Move the req&squot;d B-tree elements from low in node2 to&n;&t;&t; * high in node1.&n;&t;&t; */
id|count
op_assign
op_minus
id|count
suffix:semicolon
id|tmp
op_assign
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|btree_s
op_assign
op_amp
id|node2-&gt;btree
(braket
l_int|0
)braket
suffix:semicolon
id|btree_d
op_assign
op_amp
id|node1-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|btree_d
comma
id|btree_s
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
id|count
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|blk1-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node1
comma
id|btree_d
comma
id|tmp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move elements in node2 down to fill the hole.&n;&t;&t; */
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
suffix:semicolon
id|tmp
op_mul_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|btree_s
op_assign
op_amp
id|node2-&gt;btree
(braket
id|count
)braket
suffix:semicolon
id|btree_d
op_assign
op_amp
id|node2-&gt;btree
(braket
l_int|0
)braket
suffix:semicolon
id|memmove
c_func
(paren
id|btree_d
comma
id|btree_s
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|count
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Log header of node 1 and all current bits of node 2.&n;&t; */
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|blk1-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node1
comma
op_amp
id|node1-&gt;hdr
comma
r_sizeof
(paren
id|node1-&gt;hdr
)paren
)paren
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|blk2-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node2
comma
op_amp
id|node2-&gt;hdr
comma
r_sizeof
(paren
id|node2-&gt;hdr
)paren
op_plus
r_sizeof
(paren
id|node2-&gt;btree
(braket
l_int|0
)braket
)paren
op_star
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Record the last hashval from each block for upward propagation.&n;&t; * (note: don&squot;t use the swapped node pointers)&n;&t; */
id|node1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|node2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|blk1-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|node1-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|blk2-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|node2-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the expected index for insertion.&n;&t; */
r_if
c_cond
(paren
id|blk1-&gt;index
op_ge
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|blk2-&gt;index
op_assign
id|blk1-&gt;index
op_minus
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|blk1-&gt;index
op_assign
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* make it invalid */
)brace
)brace
multiline_comment|/*&n; * Add a new entry to an intermediate node.&n; */
id|STATIC
r_void
DECL|function|xfs_da_node_add
id|xfs_da_node_add
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|oldblk
comma
id|xfs_da_state_blk_t
op_star
id|newblk
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|node
op_assign
id|oldblk-&gt;bp-&gt;data
suffix:semicolon
id|mp
op_assign
id|state-&gt;mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|oldblk-&gt;index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|oldblk-&gt;index
op_le
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|newblk-&gt;blkno
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state-&gt;args-&gt;whichfork
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
id|ASSERT
c_func
(paren
id|newblk-&gt;blkno
op_ge
id|mp-&gt;m_dirleafblk
op_logical_and
id|newblk-&gt;blkno
OL
id|mp-&gt;m_dirfreeblk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We may need to make some room before we insert the new node.&n;&t; */
id|tmp
op_assign
l_int|0
suffix:semicolon
id|btree
op_assign
op_amp
id|node-&gt;btree
(braket
id|oldblk-&gt;index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|oldblk-&gt;index
OL
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|tmp
op_assign
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|oldblk-&gt;index
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|btree
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|btree
op_plus
l_int|1
comma
id|btree
comma
id|tmp
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
comma
id|newblk-&gt;hashval
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|btree-&gt;before
comma
id|ARCH_CONVERT
comma
id|newblk-&gt;blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|oldblk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
id|btree
comma
id|tmp
op_plus
r_sizeof
(paren
op_star
id|btree
)paren
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|oldblk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
op_amp
id|node-&gt;hdr
comma
r_sizeof
(paren
id|node-&gt;hdr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the last hash value from the oldblk to propagate upwards.&n;&t; */
id|oldblk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for shrinking the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Deallocate an empty leaf node, remove it from its parent,&n; * possibly deallocating that block, etc...&n; */
r_int
DECL|function|xfs_da_join
id|xfs_da_join
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
(brace
id|xfs_da_state_blk_t
op_star
id|drop_blk
comma
op_star
id|save_blk
suffix:semicolon
r_int
id|action
comma
id|error
suffix:semicolon
id|action
op_assign
l_int|0
suffix:semicolon
id|drop_blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|save_blk
op_assign
op_amp
id|state-&gt;altpath.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|state-&gt;path.blk
(braket
l_int|0
)braket
dot
id|magic
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|drop_blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
op_logical_or
id|drop_blk-&gt;magic
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Walk back up the tree joining/deallocating as necessary.&n;&t; * When we stop dropping blocks, break out.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|state-&gt;path.active
op_ge
l_int|2
suffix:semicolon
id|drop_blk
op_decrement
comma
id|save_blk
op_decrement
comma
id|state-&gt;path.active
op_decrement
)paren
(brace
multiline_comment|/*&n;&t;&t; * See if we can combine the block with a neighbor.&n;&t;&t; *   (action == 0) =&gt; no options, just leave&n;&t;&t; *   (action == 1) =&gt; coalesce, then unlink&n;&t;&t; *   (action == 2) =&gt; block empty, unlink it&n;&t;&t; */
r_switch
c_cond
(paren
id|drop_blk-&gt;magic
)paren
(brace
r_case
id|XFS_ATTR_LEAF_MAGIC
suffix:colon
macro_line|#ifndef __KERNEL__
id|error
op_assign
id|ENOTTY
suffix:semicolon
macro_line|#else
id|error
op_assign
id|xfs_attr_leaf_toosmall
c_func
(paren
id|state
comma
op_amp
id|action
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef __KERNEL__
id|xfs_attr_leaf_unbalance
c_func
(paren
id|state
comma
id|drop_blk
comma
id|save_blk
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|XFS_DIR_LEAF_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V1
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_dir_leaf_toosmall
c_func
(paren
id|state
comma
op_amp
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|xfs_dir_leaf_unbalance
c_func
(paren
id|state
comma
id|drop_blk
comma
id|save_blk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DIR2_LEAFN_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_dir2_leafn_toosmall
c_func
(paren
id|state
comma
op_amp
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|xfs_dir2_leafn_unbalance
c_func
(paren
id|state
comma
id|drop_blk
comma
id|save_blk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DA_NODE_MAGIC
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Remove the offending node, fixup hashvals,&n;&t;&t;&t; * check for a toosmall neighbor.&n;&t;&t;&t; */
id|xfs_da_node_remove
c_func
(paren
id|state
comma
id|drop_blk
)paren
suffix:semicolon
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_node_toosmall
c_func
(paren
id|state
comma
op_amp
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|xfs_da_node_unbalance
c_func
(paren
id|state
comma
id|drop_blk
comma
id|save_blk
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_blk_unlink
c_func
(paren
id|state
comma
id|drop_blk
comma
id|save_blk
)paren
suffix:semicolon
id|xfs_da_state_kill_altpath
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|xfs_da_shrink_inode
c_func
(paren
id|state-&gt;args
comma
id|drop_blk-&gt;blkno
comma
id|drop_blk-&gt;bp
)paren
suffix:semicolon
id|drop_blk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We joined all the way to the top.  If it turns out that&n;&t; * we only have one entry in the root, make the child block&n;&t; * the new root.&n;&t; */
id|xfs_da_node_remove
c_func
(paren
id|state
comma
id|drop_blk
)paren
suffix:semicolon
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_root_join
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path.blk
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * We have only one entry in the root.  Copy the only remaining child of&n; * the old root to block 0 as the new root node.&n; */
id|STATIC
r_int
DECL|function|xfs_da_root_join
id|xfs_da_root_join
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|root_blk
)paren
(brace
id|xfs_da_intnode_t
op_star
id|oldroot
suffix:semicolon
multiline_comment|/* REFERENCED */
id|xfs_da_blkinfo_t
op_star
id|blkinfo
suffix:semicolon
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
id|xfs_dablk_t
id|child
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|ASSERT
c_func
(paren
id|args
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|root_blk-&gt;magic
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|oldroot
op_assign
id|root_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|oldroot-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|oldroot-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|oldroot-&gt;hdr.info.back
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the root has more than one child, then don&squot;t do anything.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|oldroot-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Read in the (only) child block, then copy those bytes into&n;&t; * the root block&squot;s buffer and free the original child block.&n;&t; */
id|child
op_assign
id|INT_GET
c_func
(paren
id|oldroot-&gt;btree
(braket
l_int|0
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|child
op_ne
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|child
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|blkinfo
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|oldroot-&gt;hdr.level
comma
id|ARCH_CONVERT
)paren
op_eq
l_int|1
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|blkinfo-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
op_logical_or
id|INT_GET
c_func
(paren
id|blkinfo-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|blkinfo-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|blkinfo-&gt;forw
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_ISZERO
c_func
(paren
id|blkinfo-&gt;back
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|root_blk-&gt;bp-&gt;data
comma
id|bp-&gt;data
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|root_blk-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_shrink_inode
c_func
(paren
id|args
comma
id|child
comma
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Check a node block and its neighbors to see if the block should be&n; * collapsed into one or the other neighbor.  Always keep the block&n; * with the smaller block number.&n; * If the current block is over 50% full, don&squot;t try to join it, return 0.&n; * If the block is empty, fill in the state structure and return 2.&n; * If it can be collapsed, fill in the state structure and return 1.&n; * If nothing can be done, return 0.&n; */
id|STATIC
r_int
DECL|function|xfs_da_node_toosmall
id|xfs_da_node_toosmall
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
r_int
op_star
id|action
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
r_int
id|count
comma
id|forward
comma
id|error
comma
id|retval
comma
id|i
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being over 50% full.&n;&t; * If so, it&squot;s not worth even looking to see if we might be able&n;&t; * to coalesce with a sibling.&n;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|info
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|node
op_assign
(paren
id|xfs_da_intnode_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
(paren
id|state-&gt;node_ents
op_rshift
l_int|1
)paren
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* blk over 50%, don&squot;t try to join */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* blk over 50%, don&squot;t try to join */
)brace
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being empty.&n;&t; * If the block is empty, we&squot;ll simply delete it, no need to&n;&t; * coalesce it with a sibling block.  We choose (aribtrarily)&n;&t; * to merge with the forward block unless it is NULL.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make altpath point to the block we want to keep and&n;&t;&t; * path point to the block we want to drop (this one).&n;&t;&t; */
id|forward
op_assign
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|action
op_assign
l_int|2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Examine each sibling block to see if we can coalesce with&n;&t; * at least 25% free space to spare.  We need to figure out&n;&t; * whether to merge with the forward or the backward block.&n;&t; * We prefer coalescing with the lower numbered sibling so as&n;&t; * to shrink a directory over time.&n;&t; */
multiline_comment|/* start with smaller blk num */
id|forward
op_assign
(paren
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|forward
op_assign
op_logical_neg
id|forward
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|forward
)paren
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_else
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|state-&gt;args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|state-&gt;args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|node
op_assign
(paren
id|xfs_da_intnode_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|state-&gt;node_ents
suffix:semicolon
id|count
op_sub_assign
id|state-&gt;node_ents
op_rshift
l_int|2
suffix:semicolon
id|count
op_sub_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|count
op_sub_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* fits with at least 25% to spare */
)brace
r_if
c_cond
(paren
id|i
op_ge
l_int|2
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make altpath point to the block we want to keep (the lower&n;&t; * numbered block) and path point to the block we want to drop.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
OL
id|blk-&gt;blkno
)paren
(brace
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
op_star
id|action
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Walk back up the tree adjusting hash values as necessary,&n; * when we stop making changes, return.&n; */
r_void
DECL|function|xfs_da_fixhashpath
id|xfs_da_fixhashpath
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_path_t
op_star
id|path
)paren
(brace
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree
suffix:semicolon
id|xfs_dahash_t
id|lasthash
op_assign
l_int|0
suffix:semicolon
r_int
id|level
comma
id|count
suffix:semicolon
id|level
op_assign
id|path-&gt;active
op_minus
l_int|1
suffix:semicolon
id|blk
op_assign
op_amp
id|path-&gt;blk
(braket
id|level
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|blk-&gt;magic
)paren
(brace
macro_line|#ifdef __KERNEL__
r_case
id|XFS_ATTR_LEAF_MAGIC
suffix:colon
id|lasthash
op_assign
id|xfs_attr_leaf_lasthash
c_func
(paren
id|blk-&gt;bp
comma
op_amp
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|XFS_DIR_LEAF_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V1
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|lasthash
op_assign
id|xfs_dir_leaf_lasthash
c_func
(paren
id|blk-&gt;bp
comma
op_amp
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DIR2_LEAFN_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|lasthash
op_assign
id|xfs_dir2_leafn_lasthash
c_func
(paren
id|blk-&gt;bp
comma
op_amp
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DA_NODE_MAGIC
suffix:colon
id|lasthash
op_assign
id|xfs_da_node_lasthash
c_func
(paren
id|blk-&gt;bp
comma
op_amp
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|blk
op_decrement
comma
id|level
op_decrement
suffix:semicolon
id|level
op_ge
l_int|0
suffix:semicolon
id|blk
op_decrement
comma
id|level
op_decrement
)paren
(brace
id|node
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|btree
op_assign
op_amp
id|node-&gt;btree
(braket
id|blk-&gt;index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|lasthash
)paren
r_break
suffix:semicolon
id|blk-&gt;hashval
op_assign
id|lasthash
suffix:semicolon
id|INT_SET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
comma
id|lasthash
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|blk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
id|btree
comma
r_sizeof
(paren
op_star
id|btree
)paren
)paren
)paren
suffix:semicolon
id|lasthash
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove an entry from an intermediate node.&n; */
id|STATIC
r_void
DECL|function|xfs_da_node_remove
id|xfs_da_node_remove
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|drop_blk
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|node
op_assign
id|drop_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|drop_blk-&gt;index
OL
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|drop_blk-&gt;index
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy over the offending entry, or just zero it out.&n;&t; */
id|btree
op_assign
op_amp
id|node-&gt;btree
(braket
id|drop_blk-&gt;index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drop_blk-&gt;index
OL
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|drop_blk-&gt;index
op_minus
l_int|1
suffix:semicolon
id|tmp
op_mul_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|btree
comma
id|btree
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|drop_blk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
id|btree
comma
id|tmp
)paren
)paren
suffix:semicolon
id|btree
op_assign
op_amp
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|btree
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|drop_blk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
id|btree
comma
r_sizeof
(paren
op_star
id|btree
)paren
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|drop_blk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|node
comma
op_amp
id|node-&gt;hdr
comma
r_sizeof
(paren
id|node-&gt;hdr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the last hash value from the block to propagate upwards.&n;&t; */
id|btree
op_decrement
suffix:semicolon
id|drop_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unbalance the btree elements between two intermediate nodes,&n; * move all Btree elements from one node into another.&n; */
id|STATIC
r_void
DECL|function|xfs_da_node_unbalance
id|xfs_da_node_unbalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|drop_blk
comma
id|xfs_da_state_blk_t
op_star
id|save_blk
)paren
(brace
id|xfs_da_intnode_t
op_star
id|drop_node
comma
op_star
id|save_node
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|drop_node
op_assign
id|drop_blk-&gt;bp-&gt;data
suffix:semicolon
id|save_node
op_assign
id|save_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|drop_node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|save_node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|tp
op_assign
id|state-&gt;args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * If the dying block has lower hashvals, then move all the&n;&t; * elements in the remaining block up to make a hole.&n;&t; */
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|drop_node-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|save_node-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|drop_node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|drop_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|save_node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|save_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|btree
op_assign
op_amp
id|save_node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|drop_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|save_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|btree
comma
op_amp
id|save_node-&gt;btree
(braket
l_int|0
)braket
comma
id|tmp
)paren
suffix:semicolon
id|btree
op_assign
op_amp
id|save_node-&gt;btree
(braket
l_int|0
)braket
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|save_blk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|save_node
comma
id|btree
comma
(paren
id|INT_GET
c_func
(paren
id|save_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|drop_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_star
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|btree
op_assign
op_amp
id|save_node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|save_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|save_blk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|save_node
comma
id|btree
comma
id|INT_GET
c_func
(paren
id|drop_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Move all the B-tree elements from drop_blk to save_blk.&n;&t; */
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|drop_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_da_node_entry_t
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|btree
comma
op_amp
id|drop_node-&gt;btree
(braket
l_int|0
)braket
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|save_node-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|drop_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|save_blk-&gt;bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|save_node
comma
op_amp
id|save_node-&gt;hdr
comma
r_sizeof
(paren
id|save_node-&gt;hdr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save the last hashval in the remaining block for upward propagation.&n;&t; */
id|save_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|save_node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|save_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for finding things in the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Walk down the Btree looking for a particular filename, filling&n; * in the state structure as we go.&n; *&n; * We will set the state structure to point to each of the elements&n; * in each of the nodes where either the hashval is or should be.&n; *&n; * We support duplicate hashval&squot;s so for each entry in the current&n; * node that could contain the desired hashval, descend.  This is a&n; * pruned depth-first tree search.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_da_node_lookup_int
id|xfs_da_node_lookup_int
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
r_int
op_star
id|result
)paren
(brace
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_da_blkinfo_t
op_star
id|curr
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
r_int
id|probe
comma
id|span
comma
id|max
comma
id|error
comma
id|retval
suffix:semicolon
id|xfs_dahash_t
id|hashval
suffix:semicolon
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
id|args
op_assign
id|state-&gt;args
suffix:semicolon
multiline_comment|/*&n;&t; * Descend thru the B-tree searching each level for the right&n;&t; * node to use, until the right hashval is found.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;whichfork
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V2
c_func
(paren
id|state-&gt;mp
)paren
)paren
id|blkno
op_assign
id|state-&gt;mp-&gt;m_dirleafblk
suffix:semicolon
r_else
id|blkno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
l_int|0
)braket
comma
id|state-&gt;path.active
op_assign
l_int|1
suffix:semicolon
id|state-&gt;path.active
op_le
id|XFS_DA_NODE_MAXDEPTH
suffix:semicolon
id|blk
op_increment
comma
id|state-&gt;path.active
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Read the next node down in the tree.&n;&t;&t; */
id|blk-&gt;blkno
op_assign
id|blkno
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|blk-&gt;bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|blk-&gt;blkno
op_assign
l_int|0
suffix:semicolon
id|state-&gt;path.active
op_decrement
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|curr
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
op_logical_or
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Search an intermediate node for a match.&n;&t;&t; */
id|blk-&gt;magic
op_assign
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
(brace
id|node
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Binary search.  (note: small blocks will skip loop)&n;&t;&t;&t; */
id|max
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|probe
op_assign
id|span
op_assign
id|max
op_div
l_int|2
suffix:semicolon
id|hashval
op_assign
id|args-&gt;hashval
suffix:semicolon
r_for
c_loop
(paren
id|btree
op_assign
op_amp
id|node-&gt;btree
(braket
id|probe
)braket
suffix:semicolon
id|span
OG
l_int|4
suffix:semicolon
id|btree
op_assign
op_amp
id|node-&gt;btree
(braket
id|probe
)braket
)paren
(brace
id|span
op_div_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OL
id|hashval
)paren
id|probe
op_add_assign
id|span
suffix:semicolon
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OG
id|hashval
)paren
id|probe
op_sub_assign
id|span
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|probe
op_ge
l_int|0
)paren
op_logical_and
(paren
id|probe
OL
id|max
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|span
op_le
l_int|4
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hashval
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Since we may have duplicate hashval&squot;s, find the first&n;&t;&t;&t; * matching hashval in the node.&n;&t;&t;&t; */
r_while
c_loop
(paren
(paren
id|probe
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|hashval
)paren
)paren
(brace
id|btree
op_decrement
suffix:semicolon
id|probe
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|probe
OL
id|max
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OL
id|hashval
)paren
)paren
(brace
id|btree
op_increment
suffix:semicolon
id|probe
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Pick the right block to descend on.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|probe
op_eq
id|max
)paren
(brace
id|blk-&gt;index
op_assign
id|max
op_minus
l_int|1
suffix:semicolon
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|max
op_minus
l_int|1
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
(brace
id|blk-&gt;index
op_assign
id|probe
suffix:semicolon
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|btree-&gt;before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef __KERNEL__
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
(brace
id|blk-&gt;hashval
op_assign
id|xfs_attr_leaf_lasthash
c_func
(paren
id|blk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
(brace
id|blk-&gt;hashval
op_assign
id|xfs_dir_leaf_lasthash
c_func
(paren
id|blk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|curr-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
(brace
id|blk-&gt;hashval
op_assign
id|xfs_dir2_leafn_lasthash
c_func
(paren
id|blk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * A leaf block that ends in the hashval that we are interested in&n;&t; * (final hashval == search hashval) means that the next block may&n;&t; * contain more entries with the same hashval, shift upward to the&n;&t; * next leaf and keep searching.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V1
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir_leaf_lookup_int
c_func
(paren
id|blk-&gt;bp
comma
id|args
comma
op_amp
id|blk-&gt;index
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|blk-&gt;magic
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_dir2_leafn_lookup_int
c_func
(paren
id|blk-&gt;bp
comma
id|args
comma
op_amp
id|blk-&gt;index
comma
id|state
)paren
suffix:semicolon
)brace
macro_line|#ifdef __KERNEL__
r_else
r_if
c_cond
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
(brace
id|retval
op_assign
id|xfs_attr_leaf_lookup_int
c_func
(paren
id|blk-&gt;bp
comma
id|args
)paren
suffix:semicolon
id|blk-&gt;index
op_assign
id|args-&gt;index
suffix:semicolon
id|args-&gt;blkno
op_assign
id|blk-&gt;blkno
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
(paren
id|retval
op_eq
id|ENOENT
)paren
op_logical_or
(paren
id|retval
op_eq
id|ENOATTR
)paren
)paren
op_logical_and
(paren
id|blk-&gt;hashval
op_eq
id|args-&gt;hashval
)paren
)paren
(brace
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
comma
l_int|1
comma
l_int|1
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
macro_line|#ifdef __KERNEL__
r_else
r_if
c_cond
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
(brace
multiline_comment|/* path_shift() gives ENOENT */
id|retval
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_break
suffix:semicolon
)brace
op_star
id|result
op_assign
id|retval
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Utility routines.&n; *========================================================================*/
multiline_comment|/*&n; * Link a new block into a doubly linked list of blocks (of whatever type).&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_da_blk_link
id|xfs_da_blk_link
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|old_blk
comma
id|xfs_da_state_blk_t
op_star
id|new_blk
)paren
(brace
id|xfs_da_blkinfo_t
op_star
id|old_info
comma
op_star
id|new_info
comma
op_star
id|tmp_info
suffix:semicolon
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
r_int
id|before
op_assign
l_int|0
comma
id|error
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|ASSERT
c_func
(paren
id|args
op_ne
l_int|NULL
)paren
suffix:semicolon
id|old_info
op_assign
id|old_blk-&gt;bp-&gt;data
suffix:semicolon
id|new_info
op_assign
id|new_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|old_blk-&gt;magic
op_eq
id|XFS_DA_NODE_MAGIC
op_logical_or
id|old_blk-&gt;magic
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
op_logical_or
id|old_blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|old_blk-&gt;magic
op_eq
id|INT_GET
c_func
(paren
id|old_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|new_blk-&gt;magic
op_eq
id|INT_GET
c_func
(paren
id|new_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|old_blk-&gt;magic
op_eq
id|new_blk-&gt;magic
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|old_blk-&gt;magic
)paren
(brace
macro_line|#ifdef __KERNEL__
r_case
id|XFS_ATTR_LEAF_MAGIC
suffix:colon
id|before
op_assign
id|xfs_attr_leaf_order
c_func
(paren
id|old_blk-&gt;bp
comma
id|new_blk-&gt;bp
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|XFS_DIR_LEAF_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V1
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|before
op_assign
id|xfs_dir_leaf_order
c_func
(paren
id|old_blk-&gt;bp
comma
id|new_blk-&gt;bp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DIR2_LEAFN_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|before
op_assign
id|xfs_dir2_leafn_order
c_func
(paren
id|old_blk-&gt;bp
comma
id|new_blk-&gt;bp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DA_NODE_MAGIC
suffix:colon
id|before
op_assign
id|xfs_da_node_order
c_func
(paren
id|old_blk-&gt;bp
comma
id|new_blk-&gt;bp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Link blocks in appropriate order.&n;&t; */
r_if
c_cond
(paren
id|before
)paren
(brace
multiline_comment|/*&n;&t;&t; * Link new block in before existing block.&n;&t;&t; */
id|INT_SET
c_func
(paren
id|new_info-&gt;forw
comma
id|ARCH_CONVERT
comma
id|old_blk-&gt;blkno
)paren
suffix:semicolon
id|new_info-&gt;back
op_assign
id|old_info-&gt;back
suffix:semicolon
multiline_comment|/* INT_: direct copy */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|old_info-&gt;back
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|INT_GET
c_func
(paren
id|old_info-&gt;back
comma
id|ARCH_CONVERT
)paren
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|tmp_info
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|old_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
op_eq
id|old_blk-&gt;blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|tmp_info-&gt;forw
comma
id|ARCH_CONVERT
comma
id|new_blk-&gt;blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|old_info-&gt;back
comma
id|ARCH_CONVERT
comma
id|new_blk-&gt;blkno
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Link new block in after existing block.&n;&t;&t; */
id|new_info-&gt;forw
op_assign
id|old_info-&gt;forw
suffix:semicolon
multiline_comment|/* INT_: direct copy */
id|INT_SET
c_func
(paren
id|new_info-&gt;back
comma
id|ARCH_CONVERT
comma
id|old_blk-&gt;blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|old_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|INT_GET
c_func
(paren
id|old_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|tmp_info
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|old_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;back
comma
id|ARCH_CONVERT
)paren
op_eq
id|old_blk-&gt;blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|tmp_info-&gt;back
comma
id|ARCH_CONVERT
comma
id|new_blk-&gt;blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|old_info-&gt;forw
comma
id|ARCH_CONVERT
comma
id|new_blk-&gt;blkno
)paren
suffix:semicolon
)brace
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|old_blk-&gt;bp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|new_blk-&gt;bp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Compare two intermediate nodes for &quot;order&quot;.&n; */
id|STATIC
r_int
DECL|function|xfs_da_node_order
id|xfs_da_node_order
c_func
(paren
id|xfs_dabuf_t
op_star
id|node1_bp
comma
id|xfs_dabuf_t
op_star
id|node2_bp
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node1
comma
op_star
id|node2
suffix:semicolon
id|node1
op_assign
id|node1_bp-&gt;data
suffix:semicolon
id|node2
op_assign
id|node2_bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|node1-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|node2-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|node1-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick up the last hashvalue from an intermediate node.&n; */
id|STATIC
id|uint
DECL|function|xfs_da_node_lasthash
id|xfs_da_node_lasthash
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
op_star
id|count
)paren
(brace
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
op_star
id|count
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlink a block from a doubly linked list of blocks.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_da_blk_unlink
id|xfs_da_blk_unlink
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|drop_blk
comma
id|xfs_da_state_blk_t
op_star
id|save_blk
)paren
(brace
id|xfs_da_blkinfo_t
op_star
id|drop_info
comma
op_star
id|save_info
comma
op_star
id|tmp_info
suffix:semicolon
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|ASSERT
c_func
(paren
id|args
op_ne
l_int|NULL
)paren
suffix:semicolon
id|save_info
op_assign
id|save_blk-&gt;bp-&gt;data
suffix:semicolon
id|drop_info
op_assign
id|drop_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|save_blk-&gt;magic
op_eq
id|XFS_DA_NODE_MAGIC
op_logical_or
id|save_blk-&gt;magic
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
op_logical_or
id|save_blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|save_blk-&gt;magic
op_eq
id|INT_GET
c_func
(paren
id|save_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|drop_blk-&gt;magic
op_eq
id|INT_GET
c_func
(paren
id|drop_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|save_blk-&gt;magic
op_eq
id|drop_blk-&gt;magic
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|save_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
op_eq
id|drop_blk-&gt;blkno
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|save_info-&gt;back
comma
id|ARCH_CONVERT
)paren
op_eq
id|drop_blk-&gt;blkno
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|drop_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
op_eq
id|save_blk-&gt;blkno
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|drop_info-&gt;back
comma
id|ARCH_CONVERT
)paren
op_eq
id|save_blk-&gt;blkno
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Unlink the leaf block from the doubly linked chain of leaves.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|save_info-&gt;back
comma
id|ARCH_CONVERT
)paren
op_eq
id|drop_blk-&gt;blkno
)paren
(brace
id|save_info-&gt;back
op_assign
id|drop_info-&gt;back
suffix:semicolon
multiline_comment|/* INT_: direct copy */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|drop_info-&gt;back
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|INT_GET
c_func
(paren
id|drop_info-&gt;back
comma
id|ARCH_CONVERT
)paren
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|tmp_info
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|save_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
op_eq
id|drop_blk-&gt;blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|tmp_info-&gt;forw
comma
id|ARCH_CONVERT
comma
id|save_blk-&gt;blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|save_info-&gt;forw
op_assign
id|drop_info-&gt;forw
suffix:semicolon
multiline_comment|/* INT_: direct copy */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|drop_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|INT_GET
c_func
(paren
id|drop_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|tmp_info
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|save_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|tmp_info-&gt;back
comma
id|ARCH_CONVERT
)paren
op_eq
id|drop_blk-&gt;blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|tmp_info-&gt;back
comma
id|ARCH_CONVERT
comma
id|save_blk-&gt;blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|save_blk-&gt;bp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|save_info
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Move a path &quot;forward&quot; or &quot;!forward&quot; one block at the current level.&n; *&n; * This routine will adjust a &quot;path&quot; to point to the next block&n; * &quot;forward&quot; (higher hashvalues) or &quot;!forward&quot; (lower hashvals) in the&n; * Btree, including updating pointers to the intermediate nodes between&n; * the new bottom and the root.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_da_path_shift
id|xfs_da_path_shift
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_path_t
op_star
id|path
comma
r_int
id|forward
comma
r_int
id|release
comma
r_int
op_star
id|result
)paren
(brace
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
id|xfs_dablk_t
id|blkno
op_assign
l_int|0
suffix:semicolon
r_int
id|level
comma
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Roll up the Btree looking for the first block where our&n;&t; * current index is not at the edge of the block.  Note that&n;&t; * we skip the bottom layer because we want the sibling block.&n;&t; */
id|args
op_assign
id|state-&gt;args
suffix:semicolon
id|ASSERT
c_func
(paren
id|args
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|path
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|path-&gt;active
OG
l_int|0
)paren
op_logical_and
(paren
id|path-&gt;active
OL
id|XFS_DA_NODE_MAXDEPTH
)paren
)paren
suffix:semicolon
id|level
op_assign
(paren
id|path-&gt;active
op_minus
l_int|1
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* skip bottom layer in path */
r_for
c_loop
(paren
id|blk
op_assign
op_amp
id|path-&gt;blk
(braket
id|level
)braket
suffix:semicolon
id|level
op_ge
l_int|0
suffix:semicolon
id|blk
op_decrement
comma
id|level
op_decrement
)paren
(brace
id|ASSERT
c_func
(paren
id|blk-&gt;bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|node
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|forward
op_logical_and
(paren
id|blk-&gt;index
OL
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|blk-&gt;index
op_increment
suffix:semicolon
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|blk-&gt;index
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|forward
op_logical_and
(paren
id|blk-&gt;index
OG
l_int|0
)paren
)paren
(brace
id|blk-&gt;index
op_decrement
suffix:semicolon
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|blk-&gt;index
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|level
OL
l_int|0
)paren
(brace
op_star
id|result
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
multiline_comment|/* we&squot;re out of our tree */
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Roll down the edge of the subtree until we reach the&n;&t; * same depth we were at originally.&n;&t; */
r_for
c_loop
(paren
id|blk
op_increment
comma
id|level
op_increment
suffix:semicolon
id|level
OL
id|path-&gt;active
suffix:semicolon
id|blk
op_increment
comma
id|level
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Release the old block.&n;&t;&t; * (if it&squot;s dirty, trans won&squot;t actually let go)&n;&t;&t; */
r_if
c_cond
(paren
id|release
)paren
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|blk-&gt;bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the next child block.&n;&t;&t; */
id|blk-&gt;blkno
op_assign
id|blkno
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|blk-&gt;bp
comma
id|args-&gt;whichfork
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|info
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
op_logical_or
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
op_logical_or
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|blk-&gt;magic
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
(brace
id|node
op_assign
(paren
id|xfs_da_intnode_t
op_star
)paren
id|info
suffix:semicolon
id|blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|forward
)paren
id|blk-&gt;index
op_assign
l_int|0
suffix:semicolon
r_else
id|blk-&gt;index
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|blk-&gt;index
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|level
op_eq
id|path-&gt;active
op_minus
l_int|1
)paren
suffix:semicolon
id|blk-&gt;index
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|blk-&gt;magic
)paren
(brace
macro_line|#ifdef __KERNEL__
r_case
id|XFS_ATTR_LEAF_MAGIC
suffix:colon
id|blk-&gt;hashval
op_assign
id|xfs_attr_leaf_lasthash
c_func
(paren
id|blk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|XFS_DIR_LEAF_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V1
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|blk-&gt;hashval
op_assign
id|xfs_dir_leaf_lasthash
c_func
(paren
id|blk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DIR2_LEAFN_MAGIC
suffix:colon
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
id|blk-&gt;hashval
op_assign
id|xfs_dir2_leafn_lasthash
c_func
(paren
id|blk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
op_logical_or
id|blk-&gt;magic
op_eq
id|XFS_DIRX_LEAF_MAGIC
c_func
(paren
id|state-&gt;mp
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
op_star
id|result
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Utility routines.&n; *========================================================================*/
multiline_comment|/*&n; * Implement a simple hash on a character string.&n; * Rotate the hash value by 7 bits, then XOR each character in.&n; * This is implemented with some source-level loop unrolling.&n; */
id|xfs_dahash_t
DECL|function|xfs_da_hashname
id|xfs_da_hashname
c_func
(paren
id|uchar_t
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
id|xfs_dahash_t
id|hash
suffix:semicolon
macro_line|#ifdef SLOWVERSION
multiline_comment|/*&n;&t; * This is the old one-byte-at-a-time version.&n;&t; */
r_for
c_loop
(paren
id|hash
op_assign
l_int|0
suffix:semicolon
id|namelen
OG
l_int|0
suffix:semicolon
id|namelen
op_decrement
)paren
id|hash
op_assign
op_star
id|name
op_increment
op_xor
id|rol32
c_func
(paren
id|hash
comma
l_int|7
)paren
suffix:semicolon
r_return
id|hash
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;&t; * Do four characters at a time as long as we can.&n;&t; */
r_for
c_loop
(paren
id|hash
op_assign
l_int|0
suffix:semicolon
id|namelen
op_ge
l_int|4
suffix:semicolon
id|namelen
op_sub_assign
l_int|4
comma
id|name
op_add_assign
l_int|4
)paren
id|hash
op_assign
(paren
id|name
(braket
l_int|0
)braket
op_lshift
l_int|21
)paren
op_xor
(paren
id|name
(braket
l_int|1
)braket
op_lshift
l_int|14
)paren
op_xor
(paren
id|name
(braket
l_int|2
)braket
op_lshift
l_int|7
)paren
op_xor
(paren
id|name
(braket
l_int|3
)braket
op_lshift
l_int|0
)paren
op_xor
id|rol32
c_func
(paren
id|hash
comma
l_int|7
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now do the rest of the characters.&n;&t; */
r_switch
c_cond
(paren
id|namelen
)paren
(brace
r_case
l_int|3
suffix:colon
r_return
(paren
id|name
(braket
l_int|0
)braket
op_lshift
l_int|14
)paren
op_xor
(paren
id|name
(braket
l_int|1
)braket
op_lshift
l_int|7
)paren
op_xor
(paren
id|name
(braket
l_int|2
)braket
op_lshift
l_int|0
)paren
op_xor
id|rol32
c_func
(paren
id|hash
comma
l_int|7
op_star
l_int|3
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_return
(paren
id|name
(braket
l_int|0
)braket
op_lshift
l_int|7
)paren
op_xor
(paren
id|name
(braket
l_int|1
)braket
op_lshift
l_int|0
)paren
op_xor
id|rol32
c_func
(paren
id|hash
comma
l_int|7
op_star
l_int|2
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
r_return
(paren
id|name
(braket
l_int|0
)braket
op_lshift
l_int|0
)paren
op_xor
id|rol32
c_func
(paren
id|hash
comma
l_int|7
op_star
l_int|1
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
id|hash
suffix:semicolon
)brace
multiline_comment|/* NOTREACHED */
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* keep gcc happy */
)brace
multiline_comment|/*&n; * Add a block to the btree ahead of the file.&n; * Return the new block number to the caller.&n; */
r_int
DECL|function|xfs_da_grow_inode
id|xfs_da_grow_inode
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dablk_t
op_star
id|new_blkno
)paren
(brace
id|xfs_fileoff_t
id|bno
comma
id|b
suffix:semicolon
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
id|xfs_bmbt_irec_t
op_star
id|mapp
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
r_int
id|nmap
comma
id|error
comma
id|w
comma
id|count
comma
id|c
comma
id|got
comma
id|i
comma
id|mapi
suffix:semicolon
id|xfs_fsize_t
id|size
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|w
op_assign
id|args-&gt;whichfork
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
multiline_comment|/*&n;&t; * For new directories adjust the file offset and block count.&n;&t; */
r_if
c_cond
(paren
id|w
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
(brace
id|bno
op_assign
id|mp-&gt;m_dirleafblk
suffix:semicolon
id|count
op_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
)brace
r_else
(brace
id|bno
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find a spot in the file space to put the new block.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_first_unused
c_func
(paren
id|tp
comma
id|dp
comma
id|count
comma
op_amp
id|bno
comma
id|w
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|w
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
id|ASSERT
c_func
(paren
id|bno
op_ge
id|mp-&gt;m_dirleafblk
op_logical_and
id|bno
OL
id|mp-&gt;m_dirfreeblk
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try mapping it in one filesystem block.&n;&t; */
id|nmap
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;firstblock
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|dp
comma
id|bno
comma
id|count
comma
id|XFS_BMAPI_AFLAG
c_func
(paren
id|w
)paren
op_or
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_METADATA
op_or
id|XFS_BMAPI_CONTIG
comma
id|args-&gt;firstblock
comma
id|args-&gt;total
comma
op_amp
id|map
comma
op_amp
id|nmap
comma
id|args-&gt;flist
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nmap
op_le
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nmap
op_eq
l_int|1
)paren
(brace
id|mapp
op_assign
op_amp
id|map
suffix:semicolon
id|mapi
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we didn&squot;t get it and the block might work if fragmented,&n;&t; * try without the CONTIG flag.  Loop until we get it all.&n;&t; */
r_else
r_if
c_cond
(paren
id|nmap
op_eq
l_int|0
op_logical_and
id|count
OG
l_int|1
)paren
(brace
id|mapp
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_for
c_loop
(paren
id|b
op_assign
id|bno
comma
id|mapi
op_assign
l_int|0
suffix:semicolon
id|b
OL
id|bno
op_plus
id|count
suffix:semicolon
)paren
(brace
id|nmap
op_assign
id|MIN
c_func
(paren
id|XFS_BMAP_MAX_NMAP
comma
id|count
)paren
suffix:semicolon
id|c
op_assign
(paren
r_int
)paren
(paren
id|bno
op_plus
id|count
op_minus
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|tp
comma
id|dp
comma
id|b
comma
id|c
comma
id|XFS_BMAPI_AFLAG
c_func
(paren
id|w
)paren
op_or
id|XFS_BMAPI_WRITE
op_or
id|XFS_BMAPI_METADATA
comma
id|args-&gt;firstblock
comma
id|args-&gt;total
comma
op_amp
id|mapp
(braket
id|mapi
)braket
comma
op_amp
id|nmap
comma
id|args-&gt;flist
)paren
)paren
)paren
(brace
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nmap
OL
l_int|1
)paren
r_break
suffix:semicolon
id|mapi
op_add_assign
id|nmap
suffix:semicolon
id|b
op_assign
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_blockcount
suffix:semicolon
)brace
)brace
r_else
(brace
id|mapi
op_assign
l_int|0
suffix:semicolon
id|mapp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Count the blocks we got, make sure it matches the total.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|got
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mapi
suffix:semicolon
id|i
op_increment
)paren
id|got
op_add_assign
id|mapp
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
r_if
c_cond
(paren
id|got
op_ne
id|count
op_logical_or
id|mapp
(braket
l_int|0
)braket
dot
id|br_startoff
op_ne
id|bno
op_logical_or
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_startoff
op_plus
id|mapp
(braket
id|mapi
op_minus
l_int|1
)braket
dot
id|br_blockcount
op_ne
id|bno
op_plus
id|count
)paren
(brace
r_if
c_cond
(paren
id|mapp
op_ne
op_amp
id|map
)paren
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mapp
op_ne
op_amp
id|map
)paren
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|count
)paren
suffix:semicolon
op_star
id|new_blkno
op_assign
(paren
id|xfs_dablk_t
)paren
id|bno
suffix:semicolon
multiline_comment|/*&n;&t; * For version 1 directories, adjust the file size if it changed.&n;&t; */
r_if
c_cond
(paren
id|w
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V1
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|mapi
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_last_offset
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|bno
comma
id|w
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|size
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|mp
comma
id|bno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|dp-&gt;i_d.di_size
)paren
(brace
id|dp-&gt;i_d.di_size
op_assign
id|size
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Ick.  We need to always be able to remove a btree block, even&n; * if there&squot;s no space reservation because the filesystem is full.&n; * This is called if xfs_bunmapi on a btree block fails due to ENOSPC.&n; * It swaps the target block with the last block in the file.  The&n; * last block in the file can always be removed since it can&squot;t cause&n; * a bmap btree split to do that.&n; */
id|STATIC
r_int
DECL|function|xfs_da_swap_lastblock
id|xfs_da_swap_lastblock
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dablk_t
op_star
id|dead_blknop
comma
id|xfs_dabuf_t
op_star
op_star
id|dead_bufp
)paren
(brace
id|xfs_dablk_t
id|dead_blkno
comma
id|last_blkno
comma
id|sib_blkno
comma
id|par_blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|dead_buf
comma
op_star
id|last_buf
comma
op_star
id|sib_buf
comma
op_star
id|par_buf
suffix:semicolon
id|xfs_fileoff_t
id|lastoff
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
comma
id|w
comma
id|entno
comma
id|level
comma
id|dead_level
suffix:semicolon
id|xfs_da_blkinfo_t
op_star
id|dead_info
comma
op_star
id|sib_info
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|par_node
comma
op_star
id|dead_node
suffix:semicolon
id|xfs_dir_leafblock_t
op_star
id|dead_leaf
suffix:semicolon
id|xfs_dir2_leaf_t
op_star
id|dead_leaf2
suffix:semicolon
id|xfs_dahash_t
id|dead_hash
suffix:semicolon
id|dead_buf
op_assign
op_star
id|dead_bufp
suffix:semicolon
id|dead_blkno
op_assign
op_star
id|dead_blknop
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|ip
op_assign
id|args-&gt;dp
suffix:semicolon
id|w
op_assign
id|args-&gt;whichfork
suffix:semicolon
id|ASSERT
c_func
(paren
id|w
op_eq
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
(brace
id|lastoff
op_assign
id|mp-&gt;m_dirfreeblk
suffix:semicolon
id|error
op_assign
id|xfs_bmap_last_before
c_func
(paren
id|tp
comma
id|ip
comma
op_amp
id|lastoff
comma
id|w
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
id|xfs_bmap_last_offset
c_func
(paren
id|tp
comma
id|ip
comma
op_amp
id|lastoff
comma
id|w
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lastoff
op_eq
l_int|0
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_swap_lastblock(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the last block in the btree space.&n;&t; */
id|last_blkno
op_assign
(paren
id|xfs_dablk_t
)paren
id|lastoff
op_minus
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|ip
comma
id|last_blkno
comma
op_minus
l_int|1
comma
op_amp
id|last_buf
comma
id|w
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the last block into the dead buffer and log it.&n;&t; */
id|memcpy
c_func
(paren
id|dead_buf-&gt;data
comma
id|last_buf-&gt;data
comma
id|mp-&gt;m_dirblksize
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|dead_buf
comma
l_int|0
comma
id|mp-&gt;m_dirblksize
op_minus
l_int|1
)paren
suffix:semicolon
id|dead_info
op_assign
id|dead_buf-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Get values from the moved block.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dead_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR_LEAF_MAGIC
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V1
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|dead_leaf
op_assign
(paren
id|xfs_dir_leafblock_t
op_star
)paren
id|dead_info
suffix:semicolon
id|dead_level
op_assign
l_int|0
suffix:semicolon
id|dead_hash
op_assign
id|INT_GET
c_func
(paren
id|dead_leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|dead_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dead_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAFN_MAGIC
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|dead_leaf2
op_assign
(paren
id|xfs_dir2_leaf_t
op_star
)paren
id|dead_info
suffix:semicolon
id|dead_level
op_assign
l_int|0
suffix:semicolon
id|dead_hash
op_assign
id|INT_GET
c_func
(paren
id|dead_leaf2-&gt;ents
(braket
id|INT_GET
c_func
(paren
id|dead_leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dead_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|dead_node
op_assign
(paren
id|xfs_da_intnode_t
op_star
)paren
id|dead_info
suffix:semicolon
id|dead_level
op_assign
id|INT_GET
c_func
(paren
id|dead_node-&gt;hdr.level
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|dead_hash
op_assign
id|INT_GET
c_func
(paren
id|dead_node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|dead_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
id|sib_buf
op_assign
id|par_buf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * If the moved block has a left sibling, fix up the pointers.&n;&t; */
r_if
c_cond
(paren
(paren
id|sib_blkno
op_assign
id|INT_GET
c_func
(paren
id|dead_info-&gt;back
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|ip
comma
id|sib_blkno
comma
op_minus
l_int|1
comma
op_amp
id|sib_buf
comma
id|w
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|sib_info
op_assign
id|sib_buf-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|sib_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
op_ne
id|last_blkno
op_logical_or
id|INT_GET
c_func
(paren
id|sib_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|INT_GET
c_func
(paren
id|dead_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_swap_lastblock(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|sib_info-&gt;forw
comma
id|ARCH_CONVERT
comma
id|dead_blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|sib_buf
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|sib_info
comma
op_amp
id|sib_info-&gt;forw
comma
r_sizeof
(paren
id|sib_info-&gt;forw
)paren
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|sib_buf
)paren
suffix:semicolon
id|sib_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the moved block has a right sibling, fix up the pointers.&n;&t; */
r_if
c_cond
(paren
(paren
id|sib_blkno
op_assign
id|INT_GET
c_func
(paren
id|dead_info-&gt;forw
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|ip
comma
id|sib_blkno
comma
op_minus
l_int|1
comma
op_amp
id|sib_buf
comma
id|w
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|sib_info
op_assign
id|sib_buf-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|sib_info-&gt;back
comma
id|ARCH_CONVERT
)paren
op_ne
id|last_blkno
op_logical_or
id|INT_GET
c_func
(paren
id|sib_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|INT_GET
c_func
(paren
id|dead_info-&gt;magic
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_swap_lastblock(3)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|sib_info-&gt;back
comma
id|ARCH_CONVERT
comma
id|dead_blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|sib_buf
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|sib_info
comma
op_amp
id|sib_info-&gt;back
comma
r_sizeof
(paren
id|sib_info-&gt;back
)paren
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|sib_buf
)paren
suffix:semicolon
id|sib_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|par_blkno
op_assign
id|XFS_DIR_IS_V1
c_func
(paren
id|mp
)paren
ques
c_cond
l_int|0
suffix:colon
id|mp-&gt;m_dirleafblk
suffix:semicolon
id|level
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Walk down the tree looking for the parent of the moved block.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|ip
comma
id|par_blkno
comma
op_minus
l_int|1
comma
op_amp
id|par_buf
comma
id|w
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|par_node
op_assign
id|par_buf-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DA_NODE_MAGIC
op_logical_or
(paren
id|level
op_ge
l_int|0
op_logical_and
id|level
op_ne
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.level
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_swap_lastblock(4)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|level
op_assign
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.level
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entno
op_assign
l_int|0
suffix:semicolon
id|entno
OL
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|par_node-&gt;btree
(braket
id|entno
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|dead_hash
suffix:semicolon
id|entno
op_increment
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|entno
op_eq
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_swap_lastblock(5)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|par_blkno
op_assign
id|INT_GET
c_func
(paren
id|par_node-&gt;btree
(braket
id|entno
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|level
op_eq
id|dead_level
op_plus
l_int|1
)paren
r_break
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|par_buf
)paren
suffix:semicolon
id|par_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We&squot;re in the right parent block.&n;&t; * Look for the right entry.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|entno
OL
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|par_node-&gt;btree
(braket
id|entno
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
op_ne
id|last_blkno
suffix:semicolon
id|entno
op_increment
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|entno
OL
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_break
suffix:semicolon
id|par_blkno
op_assign
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|par_buf
)paren
suffix:semicolon
id|par_buf
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|par_blkno
op_eq
l_int|0
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_swap_lastblock(6)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|ip
comma
id|par_blkno
comma
op_minus
l_int|1
comma
op_amp
id|par_buf
comma
id|w
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
id|par_node
op_assign
id|par_buf-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.level
comma
id|ARCH_CONVERT
)paren
op_ne
id|level
op_logical_or
id|INT_GET
c_func
(paren
id|par_node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DA_NODE_MAGIC
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_swap_lastblock(7)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|entno
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the parent entry pointing to the moved block.&n;&t; */
id|INT_SET
c_func
(paren
id|par_node-&gt;btree
(braket
id|entno
)braket
dot
id|before
comma
id|ARCH_CONVERT
comma
id|dead_blkno
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|par_buf
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|par_node
comma
op_amp
id|par_node-&gt;btree
(braket
id|entno
)braket
dot
id|before
comma
r_sizeof
(paren
id|par_node-&gt;btree
(braket
id|entno
)braket
dot
id|before
)paren
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|par_buf
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|dead_buf
)paren
suffix:semicolon
op_star
id|dead_blknop
op_assign
id|last_blkno
suffix:semicolon
op_star
id|dead_bufp
op_assign
id|last_buf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|par_buf
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|par_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sib_buf
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|sib_buf
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|last_buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a btree block from a directory or attribute.&n; */
r_int
DECL|function|xfs_da_shrink_inode
id|xfs_da_shrink_inode
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dablk_t
id|dead_blkno
comma
id|xfs_dabuf_t
op_star
id|dead_buf
)paren
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
r_int
id|done
comma
id|error
comma
id|w
comma
id|count
suffix:semicolon
id|xfs_fileoff_t
id|bno
suffix:semicolon
id|xfs_fsize_t
id|size
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|w
op_assign
id|args-&gt;whichfork
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|w
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
id|count
op_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
r_else
id|count
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * Remove extents.  If we get ENOSPC for a dir we have to move&n;&t;&t; * the last block to the place we want to kill.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bunmapi
c_func
(paren
id|tp
comma
id|dp
comma
id|dead_blkno
comma
id|count
comma
id|XFS_BMAPI_AFLAG
c_func
(paren
id|w
)paren
op_or
id|XFS_BMAPI_METADATA
comma
l_int|0
comma
id|args-&gt;firstblock
comma
id|args-&gt;flist
comma
op_amp
id|done
)paren
)paren
op_eq
id|ENOSPC
)paren
(brace
r_if
c_cond
(paren
id|w
op_ne
id|XFS_DATA_FORK
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_swap_lastblock
c_func
(paren
id|args
comma
op_amp
id|dead_blkno
comma
op_amp
id|dead_buf
)paren
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
r_goto
id|done
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|done
)paren
suffix:semicolon
id|xfs_da_binval
c_func
(paren
id|tp
comma
id|dead_buf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the directory size for version 1.&n;&t; */
r_if
c_cond
(paren
id|w
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V1
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmap_last_offset
c_func
(paren
id|tp
comma
id|dp
comma
op_amp
id|bno
comma
id|w
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|size
op_assign
id|XFS_FSB_TO_B
c_func
(paren
id|dp-&gt;i_mount
comma
id|bno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ne
id|dp-&gt;i_d.di_size
)paren
(brace
id|dp-&gt;i_d.di_size
op_assign
id|size
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
id|done
suffix:colon
id|xfs_da_binval
c_func
(paren
id|tp
comma
id|dead_buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * See if the mapping(s) for this btree block are valid, i.e.&n; * don&squot;t contain holes, are logically contiguous, and cover the whole range.&n; */
id|STATIC
r_int
DECL|function|xfs_da_map_covers_blocks
id|xfs_da_map_covers_blocks
c_func
(paren
r_int
id|nmap
comma
id|xfs_bmbt_irec_t
op_star
id|mapp
comma
id|xfs_dablk_t
id|bno
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
id|xfs_fileoff_t
id|off
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|off
op_assign
id|bno
suffix:semicolon
id|i
OL
id|nmap
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mapp
(braket
id|i
)braket
dot
id|br_startblock
op_eq
id|HOLESTARTBLOCK
op_logical_or
id|mapp
(braket
id|i
)braket
dot
id|br_startblock
op_eq
id|DELAYSTARTBLOCK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|off
op_ne
id|mapp
(braket
id|i
)braket
dot
id|br_startoff
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|off
op_add_assign
id|mapp
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
)brace
r_return
id|off
op_eq
id|bno
op_plus
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Make a dabuf.&n; * Used for get_buf, read_buf, read_bufr, and reada_buf.&n; */
id|STATIC
r_int
DECL|function|xfs_da_do_buf
id|xfs_da_do_buf
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dablk_t
id|bno
comma
id|xfs_daddr_t
op_star
id|mappedbnop
comma
id|xfs_dabuf_t
op_star
op_star
id|bpp
comma
r_int
id|whichfork
comma
r_int
id|caller
comma
id|inst_t
op_star
id|ra
)paren
(brace
id|xfs_buf_t
op_star
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|xfs_buf_t
op_star
op_star
id|bplist
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
id|xfs_bmbt_irec_t
op_star
id|mapp
suffix:semicolon
id|xfs_daddr_t
id|mappedbno
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|nbplist
op_assign
l_int|0
suffix:semicolon
r_int
id|nfsb
suffix:semicolon
r_int
id|nmap
suffix:semicolon
id|xfs_dabuf_t
op_star
id|rbp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_DATA_FORK
op_logical_and
id|XFS_DIR_IS_V2
c_func
(paren
id|mp
)paren
)paren
id|nfsb
op_assign
id|mp-&gt;m_dirblkfsbs
suffix:semicolon
r_else
id|nfsb
op_assign
l_int|1
suffix:semicolon
id|mappedbno
op_assign
op_star
id|mappedbnop
suffix:semicolon
multiline_comment|/*&n;&t; * Caller doesn&squot;t have a mapping.  -2 means don&squot;t complain&n;&t; * if we land in a hole.&n;&t; */
r_if
c_cond
(paren
id|mappedbno
op_eq
op_minus
l_int|1
op_logical_or
id|mappedbno
op_eq
op_minus
l_int|2
)paren
(brace
multiline_comment|/*&n;&t;&t; * Optimize the one-block case.&n;&t;&t; */
r_if
c_cond
(paren
id|nfsb
op_eq
l_int|1
)paren
(brace
id|xfs_fsblock_t
id|fsb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi_single
c_func
(paren
id|trans
comma
id|dp
comma
id|whichfork
comma
op_amp
id|fsb
comma
(paren
id|xfs_fileoff_t
)paren
id|bno
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|mapp
op_assign
op_amp
id|map
suffix:semicolon
r_if
c_cond
(paren
id|fsb
op_eq
id|NULLFSBLOCK
)paren
(brace
id|nmap
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|map.br_startblock
op_assign
id|fsb
suffix:semicolon
id|map.br_startoff
op_assign
(paren
id|xfs_fileoff_t
)paren
id|bno
suffix:semicolon
id|map.br_blockcount
op_assign
l_int|1
suffix:semicolon
id|nmap
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|mapp
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|nfsb
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|nmap
op_assign
id|nfsb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|trans
comma
id|dp
comma
(paren
id|xfs_fileoff_t
)paren
id|bno
comma
id|nfsb
comma
id|XFS_BMAPI_METADATA
op_or
id|XFS_BMAPI_AFLAG
c_func
(paren
id|whichfork
)paren
comma
l_int|NULL
comma
l_int|0
comma
id|mapp
comma
op_amp
id|nmap
comma
l_int|NULL
)paren
)paren
)paren
r_goto
id|exit0
suffix:semicolon
)brace
)brace
r_else
(brace
id|map.br_startblock
op_assign
id|XFS_DADDR_TO_FSB
c_func
(paren
id|mp
comma
id|mappedbno
)paren
suffix:semicolon
id|map.br_startoff
op_assign
(paren
id|xfs_fileoff_t
)paren
id|bno
suffix:semicolon
id|map.br_blockcount
op_assign
id|nfsb
suffix:semicolon
id|mapp
op_assign
op_amp
id|map
suffix:semicolon
id|nmap
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|xfs_da_map_covers_blocks
c_func
(paren
id|nmap
comma
id|mapp
comma
id|bno
comma
id|nfsb
)paren
)paren
(brace
id|error
op_assign
id|mappedbno
op_eq
op_minus
l_int|2
ques
c_cond
l_int|0
suffix:colon
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_error_level
op_ge
id|XFS_ERRLEVEL_LOW
)paren
(brace
r_int
id|i
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;xfs_da_do_buf: bno %lld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|bno
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;dir: inode %lld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|dp-&gt;i_ino
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nmap
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_ALERT
comma
l_string|&quot;[%02d] br_startoff %lld br_startblock %lld br_blockcount %lld br_state %d&bslash;n&quot;
comma
id|i
comma
(paren
r_int
r_int
)paren
id|mapp
(braket
id|i
)braket
dot
id|br_startoff
comma
(paren
r_int
r_int
)paren
id|mapp
(braket
id|i
)braket
dot
id|br_startblock
comma
(paren
r_int
r_int
)paren
id|mapp
(braket
id|i
)braket
dot
id|br_blockcount
comma
id|mapp
(braket
id|i
)braket
dot
id|br_state
)paren
suffix:semicolon
)brace
)brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_da_do_buf(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
)brace
r_goto
id|exit0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|caller
op_ne
l_int|3
op_logical_and
id|nmap
OG
l_int|1
)paren
(brace
id|bplist
op_assign
id|kmem_alloc
c_func
(paren
r_sizeof
(paren
op_star
id|bplist
)paren
op_star
id|nmap
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|nbplist
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|bplist
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Turn the mapping(s) into buffer(s).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nmap
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|nmapped
suffix:semicolon
id|mappedbno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|mapp
(braket
id|i
)braket
dot
id|br_startblock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
op_star
id|mappedbnop
op_assign
id|mappedbno
suffix:semicolon
id|nmapped
op_assign
(paren
r_int
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mapp
(braket
id|i
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|caller
)paren
(brace
r_case
l_int|0
suffix:colon
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|trans
comma
id|mp-&gt;m_ddev_targp
comma
id|mappedbno
comma
id|nmapped
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|bp
ques
c_cond
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:colon
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
macro_line|#ifndef __KERNEL__
r_case
l_int|2
suffix:colon
macro_line|#endif
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|trans
comma
id|mp-&gt;m_ddev_targp
comma
id|mappedbno
comma
id|nmapped
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef __KERNEL__
r_case
l_int|3
suffix:colon
id|xfs_baread
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|mappedbno
comma
id|nmapped
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|bp
)paren
id|xfs_trans_brelse
c_func
(paren
id|trans
comma
id|bp
)paren
suffix:semicolon
r_goto
id|exit1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|caller
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|whichfork
op_eq
id|XFS_ATTR_FORK
)paren
(brace
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_ATTR_BTREE
comma
id|XFS_ATTR_BTREE_REF
)paren
suffix:semicolon
)brace
r_else
(brace
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_DIR_BTREE
comma
id|XFS_DIR_BTREE_REF
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bplist
)paren
(brace
id|bplist
(braket
id|nbplist
op_increment
)braket
op_assign
id|bp
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Build a dabuf structure.&n;&t; */
r_if
c_cond
(paren
id|bplist
)paren
(brace
id|rbp
op_assign
id|xfs_da_buf_make
c_func
(paren
id|nbplist
comma
id|bplist
comma
id|ra
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bp
)paren
id|rbp
op_assign
id|xfs_da_buf_make
c_func
(paren
l_int|1
comma
op_amp
id|bp
comma
id|ra
)paren
suffix:semicolon
r_else
id|rbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * For read_buf, check the magic number.&n;&t; */
r_if
c_cond
(paren
id|caller
op_eq
l_int|1
)paren
(brace
id|xfs_dir2_data_t
op_star
id|data
suffix:semicolon
id|xfs_dir2_free_t
op_star
id|free
suffix:semicolon
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
id|uint
id|magic
comma
id|magic1
suffix:semicolon
id|info
op_assign
id|rbp-&gt;data
suffix:semicolon
id|data
op_assign
id|rbp-&gt;data
suffix:semicolon
id|free
op_assign
id|rbp-&gt;data
suffix:semicolon
id|magic
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|magic1
op_assign
id|INT_GET
c_func
(paren
id|data-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
(paren
id|magic
op_ne
id|XFS_DA_NODE_MAGIC
)paren
op_logical_and
(paren
id|magic
op_ne
id|XFS_DIR_LEAF_MAGIC
)paren
op_logical_and
(paren
id|magic
op_ne
id|XFS_ATTR_LEAF_MAGIC
)paren
op_logical_and
(paren
id|magic
op_ne
id|XFS_DIR2_LEAF1_MAGIC
)paren
op_logical_and
(paren
id|magic
op_ne
id|XFS_DIR2_LEAFN_MAGIC
)paren
op_logical_and
(paren
id|magic1
op_ne
id|XFS_DIR2_BLOCK_MAGIC
)paren
op_logical_and
(paren
id|magic1
op_ne
id|XFS_DIR2_DATA_MAGIC
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|free-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_FREE_MAGIC
)paren
comma
id|mp
comma
id|XFS_ERRTAG_DA_READ_BUF
comma
id|XFS_RANDOM_DA_READ_BUF
)paren
)paren
)paren
(brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;DA READ ERROR&quot;
comma
id|rbp-&gt;bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_da_do_buf(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|info
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|trans
comma
id|rbp
)paren
suffix:semicolon
id|nbplist
op_assign
l_int|0
suffix:semicolon
r_goto
id|exit1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bplist
)paren
(brace
id|kmem_free
c_func
(paren
id|bplist
comma
r_sizeof
(paren
op_star
id|bplist
)paren
op_star
id|nmap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mapp
op_ne
op_amp
id|map
)paren
(brace
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|nfsb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bpp
)paren
op_star
id|bpp
op_assign
id|rbp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|exit1
suffix:colon
r_if
c_cond
(paren
id|bplist
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbplist
suffix:semicolon
id|i
op_increment
)paren
id|xfs_trans_brelse
c_func
(paren
id|trans
comma
id|bplist
(braket
id|i
)braket
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|bplist
comma
r_sizeof
(paren
op_star
id|bplist
)paren
op_star
id|nmap
)paren
suffix:semicolon
)brace
id|exit0
suffix:colon
r_if
c_cond
(paren
id|mapp
op_ne
op_amp
id|map
)paren
id|kmem_free
c_func
(paren
id|mapp
comma
r_sizeof
(paren
op_star
id|mapp
)paren
op_star
id|nfsb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bpp
)paren
op_star
id|bpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a buffer for the dir/attr block.&n; */
r_int
DECL|function|xfs_da_get_buf
id|xfs_da_get_buf
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dablk_t
id|bno
comma
id|xfs_daddr_t
id|mappedbno
comma
id|xfs_dabuf_t
op_star
op_star
id|bpp
comma
r_int
id|whichfork
)paren
(brace
r_return
id|xfs_da_do_buf
c_func
(paren
id|trans
comma
id|dp
comma
id|bno
comma
op_amp
id|mappedbno
comma
id|bpp
comma
id|whichfork
comma
l_int|0
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a buffer for the dir/attr block, fill in the contents.&n; */
r_int
DECL|function|xfs_da_read_buf
id|xfs_da_read_buf
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dablk_t
id|bno
comma
id|xfs_daddr_t
id|mappedbno
comma
id|xfs_dabuf_t
op_star
op_star
id|bpp
comma
r_int
id|whichfork
)paren
(brace
r_return
id|xfs_da_do_buf
c_func
(paren
id|trans
comma
id|dp
comma
id|bno
comma
op_amp
id|mappedbno
comma
id|bpp
comma
id|whichfork
comma
l_int|1
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Readahead the dir/attr block.&n; */
id|xfs_daddr_t
DECL|function|xfs_da_reada_buf
id|xfs_da_reada_buf
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dablk_t
id|bno
comma
r_int
id|whichfork
)paren
(brace
id|xfs_daddr_t
id|rval
suffix:semicolon
id|rval
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|xfs_da_do_buf
c_func
(paren
id|trans
comma
id|dp
comma
id|bno
comma
op_amp
id|rval
comma
l_int|NULL
comma
id|whichfork
comma
l_int|3
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate the number of bits needed to hold i different values.&n; */
id|uint
DECL|function|xfs_da_log2_roundup
id|xfs_da_log2_roundup
c_func
(paren
id|uint
id|i
)paren
(brace
id|uint
id|rval
suffix:semicolon
r_for
c_loop
(paren
id|rval
op_assign
l_int|0
suffix:semicolon
id|rval
OL
id|NBBY
op_star
r_sizeof
(paren
id|i
)paren
suffix:semicolon
id|rval
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|rval
)paren
op_ge
id|i
)paren
r_break
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
DECL|variable|xfs_da_state_zone
id|kmem_zone_t
op_star
id|xfs_da_state_zone
suffix:semicolon
multiline_comment|/* anchor for state struct zone */
DECL|variable|xfs_dabuf_zone
id|kmem_zone_t
op_star
id|xfs_dabuf_zone
suffix:semicolon
multiline_comment|/* dabuf zone */
multiline_comment|/*&n; * Allocate a dir-state structure.&n; * We don&squot;t put them on the stack since they&squot;re large.&n; */
id|xfs_da_state_t
op_star
DECL|function|xfs_da_state_alloc
id|xfs_da_state_alloc
c_func
(paren
r_void
)paren
(brace
r_return
id|kmem_zone_zalloc
c_func
(paren
id|xfs_da_state_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Kill the altpath contents of a da-state structure.&n; */
r_void
DECL|function|xfs_da_state_kill_altpath
id|xfs_da_state_kill_altpath
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;altpath.active
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;altpath.blk
(braket
id|i
)braket
dot
id|bp
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;altpath.blk
(braket
id|i
)braket
dot
id|bp
op_ne
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
id|xfs_da_buf_done
c_func
(paren
id|state-&gt;altpath.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;altpath.blk
(braket
id|i
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|state-&gt;altpath.active
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Free a da-state structure.&n; */
r_void
DECL|function|xfs_da_state_free
id|xfs_da_state_free
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
(brace
r_int
id|i
suffix:semicolon
id|xfs_da_state_kill_altpath
c_func
(paren
id|state
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;path.active
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
id|xfs_da_buf_done
c_func
(paren
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|state-&gt;extravalid
op_logical_and
id|state-&gt;extrablk.bp
)paren
id|xfs_da_buf_done
c_func
(paren
id|state-&gt;extrablk.bp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|state
)paren
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|kmem_zone_free
c_func
(paren
id|xfs_da_state_zone
comma
id|state
)paren
suffix:semicolon
)brace
macro_line|#ifdef XFS_DABUF_DEBUG
DECL|variable|xfs_dabuf_global_list
id|xfs_dabuf_t
op_star
id|xfs_dabuf_global_list
suffix:semicolon
DECL|variable|xfs_dabuf_global_lock
id|lock_t
id|xfs_dabuf_global_lock
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Create a dabuf.&n; */
multiline_comment|/* ARGSUSED */
id|STATIC
id|xfs_dabuf_t
op_star
DECL|function|xfs_da_buf_make
id|xfs_da_buf_make
c_func
(paren
r_int
id|nbuf
comma
id|xfs_buf_t
op_star
op_star
id|bps
comma
id|inst_t
op_star
id|ra
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|dabuf
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|off
suffix:semicolon
r_if
c_cond
(paren
id|nbuf
op_eq
l_int|1
)paren
id|dabuf
op_assign
id|kmem_zone_alloc
c_func
(paren
id|xfs_dabuf_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_else
id|dabuf
op_assign
id|kmem_alloc
c_func
(paren
id|XFS_DA_BUF_SIZE
c_func
(paren
id|nbuf
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|dabuf-&gt;dirty
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef XFS_DABUF_DEBUG
id|dabuf-&gt;ra
op_assign
id|ra
suffix:semicolon
id|dabuf-&gt;target
op_assign
id|XFS_BUF_TARGET
c_func
(paren
id|bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|dabuf-&gt;blkno
op_assign
id|XFS_BUF_ADDR
c_func
(paren
id|bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nbuf
op_eq
l_int|1
)paren
(brace
id|dabuf-&gt;nbuf
op_assign
l_int|1
suffix:semicolon
id|bp
op_assign
id|bps
(braket
l_int|0
)braket
suffix:semicolon
id|dabuf-&gt;bbcount
op_assign
(paren
r_int
)paren
id|BTOBB
c_func
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|dabuf-&gt;data
op_assign
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
id|dabuf-&gt;bps
(braket
l_int|0
)braket
op_assign
id|bp
suffix:semicolon
)brace
r_else
(brace
id|dabuf-&gt;nbuf
op_assign
id|nbuf
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dabuf-&gt;bbcount
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbuf
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dabuf-&gt;bps
(braket
id|i
)braket
op_assign
id|bp
op_assign
id|bps
(braket
id|i
)braket
suffix:semicolon
id|dabuf-&gt;bbcount
op_add_assign
id|BTOBB
c_func
(paren
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
id|dabuf-&gt;data
op_assign
id|kmem_alloc
c_func
(paren
id|BBTOB
c_func
(paren
id|dabuf-&gt;bbcount
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|off
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbuf
suffix:semicolon
id|i
op_increment
comma
id|off
op_add_assign
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
(brace
id|bp
op_assign
id|bps
(braket
id|i
)braket
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|dabuf-&gt;data
op_plus
id|off
comma
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef XFS_DABUF_DEBUG
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|xfs_dabuf_t
op_star
id|p
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|xfs_dabuf_global_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|xfs_dabuf_global_list
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|ASSERT
c_func
(paren
id|p-&gt;blkno
op_ne
id|dabuf-&gt;blkno
op_logical_or
id|p-&gt;target
op_ne
id|dabuf-&gt;target
)paren
suffix:semicolon
)brace
id|dabuf-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|xfs_dabuf_global_list
)paren
id|xfs_dabuf_global_list-&gt;prev
op_assign
id|dabuf
suffix:semicolon
id|dabuf-&gt;next
op_assign
id|xfs_dabuf_global_list
suffix:semicolon
id|xfs_dabuf_global_list
op_assign
id|dabuf
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|xfs_dabuf_global_lock
comma
id|s
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|dabuf
suffix:semicolon
)brace
multiline_comment|/*&n; * Un-dirty a dabuf.&n; */
id|STATIC
r_void
DECL|function|xfs_da_buf_clean
id|xfs_da_buf_clean
c_func
(paren
id|xfs_dabuf_t
op_star
id|dabuf
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|off
suffix:semicolon
r_if
c_cond
(paren
id|dabuf-&gt;dirty
)paren
(brace
id|ASSERT
c_func
(paren
id|dabuf-&gt;nbuf
OG
l_int|1
)paren
suffix:semicolon
id|dabuf-&gt;dirty
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|off
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dabuf-&gt;nbuf
suffix:semicolon
id|i
op_increment
comma
id|off
op_add_assign
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
(brace
id|bp
op_assign
id|dabuf-&gt;bps
(braket
id|i
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
(paren
r_char
op_star
)paren
id|dabuf-&gt;data
op_plus
id|off
comma
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Release a dabuf.&n; */
r_void
DECL|function|xfs_da_buf_done
id|xfs_da_buf_done
c_func
(paren
id|xfs_dabuf_t
op_star
id|dabuf
)paren
(brace
id|ASSERT
c_func
(paren
id|dabuf
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dabuf-&gt;nbuf
op_logical_and
id|dabuf-&gt;data
op_logical_and
id|dabuf-&gt;bbcount
op_logical_and
id|dabuf-&gt;bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabuf-&gt;dirty
)paren
id|xfs_da_buf_clean
c_func
(paren
id|dabuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabuf-&gt;nbuf
OG
l_int|1
)paren
id|kmem_free
c_func
(paren
id|dabuf-&gt;data
comma
id|BBTOB
c_func
(paren
id|dabuf-&gt;bbcount
)paren
)paren
suffix:semicolon
macro_line|#ifdef XFS_DABUF_DEBUG
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|xfs_dabuf_global_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabuf-&gt;prev
)paren
id|dabuf-&gt;prev-&gt;next
op_assign
id|dabuf-&gt;next
suffix:semicolon
r_else
id|xfs_dabuf_global_list
op_assign
id|dabuf-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dabuf-&gt;next
)paren
id|dabuf-&gt;next-&gt;prev
op_assign
id|dabuf-&gt;prev
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|xfs_dabuf_global_lock
comma
id|s
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dabuf
comma
l_int|0
comma
id|XFS_DA_BUF_SIZE
c_func
(paren
id|dabuf-&gt;nbuf
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dabuf-&gt;nbuf
op_eq
l_int|1
)paren
id|kmem_zone_free
c_func
(paren
id|xfs_dabuf_zone
comma
id|dabuf
)paren
suffix:semicolon
r_else
id|kmem_free
c_func
(paren
id|dabuf
comma
id|XFS_DA_BUF_SIZE
c_func
(paren
id|dabuf-&gt;nbuf
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log transaction from a dabuf.&n; */
r_void
DECL|function|xfs_da_log_buf
id|xfs_da_log_buf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dabuf_t
op_star
id|dabuf
comma
id|uint
id|first
comma
id|uint
id|last
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|uint
id|f
suffix:semicolon
r_int
id|i
suffix:semicolon
id|uint
id|l
suffix:semicolon
r_int
id|off
suffix:semicolon
id|ASSERT
c_func
(paren
id|dabuf-&gt;nbuf
op_logical_and
id|dabuf-&gt;data
op_logical_and
id|dabuf-&gt;bbcount
op_logical_and
id|dabuf-&gt;bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dabuf-&gt;nbuf
op_eq
l_int|1
)paren
(brace
id|ASSERT
c_func
(paren
id|dabuf-&gt;data
op_eq
(paren
r_void
op_star
)paren
id|XFS_BUF_PTR
c_func
(paren
id|dabuf-&gt;bps
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|dabuf-&gt;bps
(braket
l_int|0
)braket
comma
id|first
comma
id|last
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dabuf-&gt;dirty
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
id|first
op_le
id|last
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|off
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dabuf-&gt;nbuf
suffix:semicolon
id|i
op_increment
comma
id|off
op_add_assign
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
)paren
(brace
id|bp
op_assign
id|dabuf-&gt;bps
(braket
id|i
)braket
suffix:semicolon
id|f
op_assign
id|off
suffix:semicolon
id|l
op_assign
id|f
op_plus
id|XFS_BUF_COUNT
c_func
(paren
id|bp
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|f
OL
id|first
)paren
id|f
op_assign
id|first
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
id|last
)paren
id|l
op_assign
id|last
suffix:semicolon
r_if
c_cond
(paren
id|f
op_le
id|l
)paren
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|f
op_minus
id|off
comma
id|l
op_minus
id|off
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * B_DONE is set by xfs_trans_log buf.&n;&t;&t; * If we don&squot;t set it on a new buffer (get not read)&n;&t;&t; * then if we don&squot;t put anything in the buffer it won&squot;t&n;&t;&t; * be set, and at commit it it released into the cache,&n;&t;&t; * and then a read will fail.&n;&t;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_BUF_ISDONE
c_func
(paren
id|bp
)paren
)paren
)paren
id|XFS_BUF_DONE
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|last
OL
id|off
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release dabuf from a transaction.&n; * Have to free up the dabuf before the buffers are released,&n; * since the synchronization on the dabuf is really the lock on the buffer.&n; */
r_void
DECL|function|xfs_da_brelse
id|xfs_da_brelse
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dabuf_t
op_star
id|dabuf
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_buf_t
op_star
op_star
id|bplist
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nbuf
suffix:semicolon
id|ASSERT
c_func
(paren
id|dabuf-&gt;nbuf
op_logical_and
id|dabuf-&gt;data
op_logical_and
id|dabuf-&gt;bbcount
op_logical_and
id|dabuf-&gt;bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nbuf
op_assign
id|dabuf-&gt;nbuf
)paren
op_eq
l_int|1
)paren
(brace
id|bplist
op_assign
op_amp
id|bp
suffix:semicolon
id|bp
op_assign
id|dabuf-&gt;bps
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|bplist
op_assign
id|kmem_alloc
c_func
(paren
id|nbuf
op_star
r_sizeof
(paren
op_star
id|bplist
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bplist
comma
id|dabuf-&gt;bps
comma
id|nbuf
op_star
r_sizeof
(paren
op_star
id|bplist
)paren
)paren
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|dabuf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbuf
suffix:semicolon
id|i
op_increment
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bplist
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bplist
op_ne
op_amp
id|bp
)paren
id|kmem_free
c_func
(paren
id|bplist
comma
id|nbuf
op_star
r_sizeof
(paren
op_star
id|bplist
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Invalidate dabuf from a transaction.&n; */
r_void
DECL|function|xfs_da_binval
id|xfs_da_binval
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dabuf_t
op_star
id|dabuf
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_buf_t
op_star
op_star
id|bplist
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nbuf
suffix:semicolon
id|ASSERT
c_func
(paren
id|dabuf-&gt;nbuf
op_logical_and
id|dabuf-&gt;data
op_logical_and
id|dabuf-&gt;bbcount
op_logical_and
id|dabuf-&gt;bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nbuf
op_assign
id|dabuf-&gt;nbuf
)paren
op_eq
l_int|1
)paren
(brace
id|bplist
op_assign
op_amp
id|bp
suffix:semicolon
id|bp
op_assign
id|dabuf-&gt;bps
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
id|bplist
op_assign
id|kmem_alloc
c_func
(paren
id|nbuf
op_star
r_sizeof
(paren
op_star
id|bplist
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bplist
comma
id|dabuf-&gt;bps
comma
id|nbuf
op_star
r_sizeof
(paren
op_star
id|bplist
)paren
)paren
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|dabuf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbuf
suffix:semicolon
id|i
op_increment
)paren
id|xfs_trans_binval
c_func
(paren
id|tp
comma
id|bplist
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bplist
op_ne
op_amp
id|bp
)paren
id|kmem_free
c_func
(paren
id|bplist
comma
id|nbuf
op_star
r_sizeof
(paren
op_star
id|bplist
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the first daddr from a dabuf.&n; */
id|xfs_daddr_t
DECL|function|xfs_da_blkno
id|xfs_da_blkno
c_func
(paren
id|xfs_dabuf_t
op_star
id|dabuf
)paren
(brace
id|ASSERT
c_func
(paren
id|dabuf-&gt;nbuf
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dabuf-&gt;data
)paren
suffix:semicolon
r_return
id|XFS_BUF_ADDR
c_func
(paren
id|dabuf-&gt;bps
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
eof
