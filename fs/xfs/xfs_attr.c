multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_attr_leaf.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_trans_space.h&quot;
multiline_comment|/*&n; * xfs_attr.c&n; *&n; * Provide the external interfaces to manage attribute lists.&n; */
multiline_comment|/*========================================================================&n; * Function prototypes for the kernel.&n; *========================================================================*/
multiline_comment|/*&n; * Internal routines when attribute list fits inside the inode.&n; */
id|STATIC
r_int
id|xfs_attr_shortform_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal routines when attribute list is one block.&n; */
id|STATIC
r_int
id|xfs_attr_leaf_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_leaf_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_leaf_list
c_func
(paren
id|xfs_attr_list_context_t
op_star
id|context
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal routines when attribute list is more than one block.&n; */
id|STATIC
r_int
id|xfs_attr_node_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_node_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_node_list
c_func
(paren
id|xfs_attr_list_context_t
op_star
id|context
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_fillstate
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_refillstate
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
suffix:semicolon
multiline_comment|/*&n; * Routines to manipulate out-of-line attribute values.&n; */
id|STATIC
r_int
id|xfs_attr_rmtval_get
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_rmtval_set
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_rmtval_remove
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
DECL|macro|ATTR_RMTVALUE_MAPSIZE
mdefine_line|#define ATTR_RMTVALUE_MAPSIZE&t;1&t;/* # of map entries at once */
DECL|macro|ATTR_RMTVALUE_TRANSBLKS
mdefine_line|#define ATTR_RMTVALUE_TRANSBLKS&t;8&t;/* max # of blks in a transaction */
macro_line|#if defined(DEBUG)
DECL|variable|xfs_attr_trace_buf
id|ktrace_t
op_star
id|xfs_attr_trace_buf
suffix:semicolon
macro_line|#endif
multiline_comment|/*========================================================================&n; * Overall external interface routines.&n; *========================================================================*/
multiline_comment|/*ARGSUSED*/
r_int
multiline_comment|/* error */
DECL|function|xfs_attr_get
id|xfs_attr_get
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_char
op_star
id|name
comma
r_char
op_star
id|value
comma
r_int
op_star
id|valuelenp
comma
r_int
id|flags
comma
r_struct
id|cred
op_star
id|cred
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
id|EINVAL
suffix:semicolon
id|ASSERT
c_func
(paren
id|MAXNAMELEN
op_minus
l_int|1
op_le
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* length is stored in uint8 */
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_ge
id|MAXNAMELEN
)paren
r_return
id|EFAULT
suffix:semicolon
multiline_comment|/* match IRIX behaviour */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_attr_get
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
op_eq
l_int|0
)paren
r_return
id|ENOATTR
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|ip-&gt;i_mount
)paren
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we answer them, or ignore them?&n;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
comma
id|IREAD
comma
id|cred
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.value
op_assign
id|value
suffix:semicolon
id|args.valuelen
op_assign
op_star
id|valuelenp
suffix:semicolon
id|args.flags
op_assign
id|flags
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|args.name
comma
id|args.namelen
)paren
suffix:semicolon
id|args.dp
op_assign
id|ip
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_ATTR_FORK
suffix:semicolon
id|args.trans
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
op_eq
l_int|0
op_logical_or
(paren
id|ip-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|ip-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ip-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|error
op_assign
id|xfs_attr_shortform_getvalue
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|ip
comma
id|XFS_ATTR_FORK
)paren
)paren
(brace
id|error
op_assign
id|xfs_attr_leaf_get
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_attr_node_get
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Return the number of bytes in the value to the caller.&n;&t; */
op_star
id|valuelenp
op_assign
id|args.valuelen
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EEXIST
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*ARGSUSED*/
r_int
multiline_comment|/* error */
DECL|function|xfs_attr_set
id|xfs_attr_set
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_char
op_star
id|name
comma
r_char
op_star
id|value
comma
r_int
id|valuelen
comma
r_int
id|flags
comma
r_struct
id|cred
op_star
id|cred
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_fsblock_t
id|firstblock
suffix:semicolon
id|xfs_bmap_free_t
id|flist
suffix:semicolon
r_int
id|error
comma
id|err2
comma
id|committed
suffix:semicolon
r_int
id|local
comma
id|size
suffix:semicolon
id|uint
id|nblks
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|rsvd
op_assign
(paren
id|flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|ASSERT
c_func
(paren
id|MAXNAMELEN
op_minus
l_int|1
op_le
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* length is stored in uint8 */
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_ge
id|MAXNAMELEN
)paren
r_return
id|EFAULT
suffix:semicolon
multiline_comment|/* match irix behaviour */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_attr_set
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we answer them, or ignore them?&n;&t; */
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|dp
comma
id|IWRITE
comma
id|cred
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the dquots to the inode.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|dp
comma
l_int|0
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the inode doesn&squot;t have an attribute fork, add one.&n;&t; * (inode must not be locked when we call this routine)&n;&t; */
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|dp
)paren
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_bmap_add_attrfork
c_func
(paren
id|dp
comma
id|rsvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.value
op_assign
id|value
suffix:semicolon
id|args.valuelen
op_assign
id|valuelen
suffix:semicolon
id|args.flags
op_assign
id|flags
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|args.name
comma
id|args.namelen
)paren
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
op_amp
id|firstblock
suffix:semicolon
id|args.flist
op_assign
op_amp
id|flist
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_ATTR_FORK
suffix:semicolon
id|args.oknoent
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Determine space new attribute will use, and if it will be inline&n;&t; * or out of line.&n;&t; */
id|size
op_assign
id|xfs_attr_leaf_newentsize
c_func
(paren
op_amp
id|args
comma
id|mp-&gt;m_sb.sb_blocksize
comma
op_amp
id|local
)paren
suffix:semicolon
id|nblks
op_assign
id|XFS_DAENTER_SPACE_RES
c_func
(paren
id|mp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local
)paren
(brace
r_if
c_cond
(paren
id|size
OG
(paren
id|mp-&gt;m_sb.sb_blocksize
op_rshift
l_int|1
)paren
)paren
(brace
multiline_comment|/* Double split possible */
id|nblks
op_lshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|uint
id|dblocks
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|valuelen
)paren
suffix:semicolon
multiline_comment|/* Out of line attribute, cannot double split, but make&n;&t;&t; * room for the attribute value itself.&n;&t;&t; */
id|nblks
op_add_assign
id|dblocks
suffix:semicolon
id|nblks
op_add_assign
id|XFS_NEXTENTADD_SPACE_RES
c_func
(paren
id|mp
comma
id|dblocks
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
)brace
multiline_comment|/* Size is now blocks for attribute data */
id|args.total
op_assign
id|nblks
suffix:semicolon
multiline_comment|/*&n;&t; * Start our first transaction of the day.&n;&t; *&n;&t; * All future transactions during this code must be &quot;chained&quot; off&n;&t; * this one via the trans_dup() call.  All transactions will contain&n;&t; * the inode, and the inode will always be marked with trans_ihold().&n;&t; * Since the inode will be locked in all transactions, we must log&n;&t; * the inode in every transaction to let it float upward through&n;&t; * the log.&n;&t; */
id|args.trans
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_ATTR_SET
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Root fork attributes can use reserved data blocks for this&n;&t; * operation if necessary&n;&t; */
r_if
c_cond
(paren
id|rsvd
)paren
id|args.trans-&gt;t_flags
op_or_assign
id|XFS_TRANS_RESERVE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|args.trans
comma
(paren
id|uint
)paren
id|nblks
comma
id|XFS_ATTRSET_LOG_RES
c_func
(paren
id|mp
comma
id|nblks
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ATTRSET_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|args.trans
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|XFS_TRANS_RESERVE_QUOTA_NBLKS
c_func
(paren
id|mp
comma
id|args.trans
comma
id|dp
comma
id|nblks
comma
l_int|0
comma
id|rsvd
ques
c_cond
id|XFS_QMOPT_RES_REGBLKS
op_or
id|XFS_QMOPT_FORCE_RES
suffix:colon
id|XFS_QMOPT_RES_REGBLKS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|args.trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|xfs_trans_ijoin
c_func
(paren
id|args.trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args.trans
comma
id|dp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the attribute list is non-existant or a shortform list,&n;&t; * upgrade it to a single-leaf-block attribute list.&n;&t; */
r_if
c_cond
(paren
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
op_logical_or
(paren
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
op_logical_and
(paren
id|dp-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Build initial attribute list (if required).&n;&t;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
(paren
r_void
)paren
id|xfs_attr_shortform_create
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Try to add the attr to the attribute list in&n;&t;&t; * the inode.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_shortform_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
id|ENOSPC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Commit the shortform mods, and we&squot;re done.&n;&t;&t;&t; * NOTE: this is also the error path (EEXIST, etc).&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|args.trans
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If this is a synchronous mount, make sure that&n;&t;&t;&t; * the transaction goes to disk before returning&n;&t;&t;&t; * to the user.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|args.trans
)paren
suffix:semicolon
)brace
id|err2
op_assign
id|xfs_trans_commit
c_func
(paren
id|args.trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Hit the inode change time.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|flags
op_amp
id|ATTR_KERNOTIME
)paren
op_eq
l_int|0
)paren
(brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
)brace
r_return
id|error
op_eq
l_int|0
ques
c_cond
id|err2
suffix:colon
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * It won&squot;t fit in the shortform, transform to a leaf block.&n;&t;&t; * GROT: another possible req&squot;mt for a double-split btree op.&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
id|args.flist
comma
id|args.firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_shortform_to_leaf
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args.trans
comma
id|args.flist
comma
op_star
id|args.firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args.trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
op_amp
id|flist
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bmap_finish() may have committed the last trans and started&n;&t;&t; * a new one.  We need the inode to be in all transactions.&n;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args.trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args.trans
comma
id|dp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Commit the leaf transformation.  We&squot;ll need another (linked)&n;&t;&t; * transaction to add the new attribute to the leaf.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args.trans
comma
id|dp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_ATTR_FORK
)paren
)paren
(brace
id|error
op_assign
id|xfs_attr_leaf_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_attr_node_addname
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * transaction goes to disk before returning to the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|args.trans
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commit the last in the sequence of transactions.&n;&t; */
id|xfs_trans_log_inode
c_func
(paren
id|args.trans
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|args.trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hit the inode change time.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|flags
op_amp
id|ATTR_KERNOTIME
)paren
op_eq
l_int|0
)paren
(brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|args.trans
)paren
id|xfs_trans_cancel
c_func
(paren
id|args.trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic handler routine to remove a name from an attribute list.&n; * Transitions attribute list from Btree to shortform as necessary.&n; */
multiline_comment|/*ARGSUSED*/
r_int
multiline_comment|/* error */
DECL|function|xfs_attr_remove
id|xfs_attr_remove
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_char
op_star
id|name
comma
r_int
id|flags
comma
r_struct
id|cred
op_star
id|cred
)paren
(brace
id|xfs_da_args_t
id|args
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_fsblock_t
id|firstblock
suffix:semicolon
id|xfs_bmap_free_t
id|flist
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|namelen
suffix:semicolon
id|ASSERT
c_func
(paren
id|MAXNAMELEN
op_minus
l_int|1
op_le
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* length is stored in uint8 */
id|namelen
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_ge
id|MAXNAMELEN
)paren
r_return
id|EFAULT
suffix:semicolon
multiline_comment|/* match irix behaviour */
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_attr_remove
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do we answer them, or ignore them?&n;&t; */
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|dp
comma
id|IWRITE
comma
id|cred
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|dp
)paren
op_eq
l_int|0
op_logical_or
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|dp-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the arg structure for this request.&n;&t; */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|args
comma
l_int|0
comma
r_sizeof
(paren
id|args
)paren
)paren
suffix:semicolon
id|args.name
op_assign
id|name
suffix:semicolon
id|args.namelen
op_assign
id|namelen
suffix:semicolon
id|args.flags
op_assign
id|flags
suffix:semicolon
id|args.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
id|args.name
comma
id|args.namelen
)paren
suffix:semicolon
id|args.dp
op_assign
id|dp
suffix:semicolon
id|args.firstblock
op_assign
op_amp
id|firstblock
suffix:semicolon
id|args.flist
op_assign
op_amp
id|flist
suffix:semicolon
id|args.total
op_assign
l_int|0
suffix:semicolon
id|args.whichfork
op_assign
id|XFS_ATTR_FORK
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the dquots to the inode.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_DQATTACH
c_func
(paren
id|mp
comma
id|dp
comma
l_int|0
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start our first transaction of the day.&n;&t; *&n;&t; * All future transactions during this code must be &quot;chained&quot; off&n;&t; * this one via the trans_dup() call.  All transactions will contain&n;&t; * the inode, and the inode will always be marked with trans_ihold().&n;&t; * Since the inode will be locked in all transactions, we must log&n;&t; * the inode in every transaction to let it float upward through&n;&t; * the log.&n;&t; */
id|args.trans
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_ATTR_RM
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Root fork attributes can use reserved data blocks for this&n;&t; * operation if necessary&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|ATTR_ROOT
)paren
id|args.trans-&gt;t_flags
op_or_assign
id|XFS_TRANS_RESERVE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|args.trans
comma
id|XFS_ATTRRM_SPACE_RES
c_func
(paren
id|mp
)paren
comma
id|XFS_ATTRRM_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ATTRRM_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|args.trans
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No need to make quota reservations here. We expect to release some&n;&t; * blocks not allocate in the common case.&n;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|args.trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args.trans
comma
id|dp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|dp
)paren
op_eq
l_int|0
op_logical_or
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|dp-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_afp-&gt;if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_shortform_remove
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_ATTR_FORK
)paren
)paren
(brace
id|error
op_assign
id|xfs_attr_leaf_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_attr_node_removename
c_func
(paren
op_amp
id|args
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * transaction goes to disk before returning to the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|args.trans
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commit the last in the sequence of transactions.&n;&t; */
id|xfs_trans_log_inode
c_func
(paren
id|args.trans
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|args.trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Hit the inode change time.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|flags
op_amp
id|ATTR_KERNOTIME
)paren
op_eq
l_int|0
)paren
(brace
id|xfs_ichgtime
c_func
(paren
id|dp
comma
id|XFS_ICHGTIME_CHG
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|args.trans
)paren
id|xfs_trans_cancel
c_func
(paren
id|args.trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Generate a list of extended attribute names and optionally&n; * also value lengths.  Positive return value follows the XFS&n; * convention of being an error, zero or negative return code&n; * is the length of the buffer returned (negated), indicating&n; * success.&n; */
r_int
DECL|function|xfs_attr_list
id|xfs_attr_list
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_char
op_star
id|buffer
comma
r_int
id|bufsize
comma
r_int
id|flags
comma
id|attrlist_cursor_kern_t
op_star
id|cursor
comma
r_struct
id|cred
op_star
id|cred
)paren
(brace
id|xfs_attr_list_context_t
id|context
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xfsstats.xs_attr_list
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Validate the cursor.&n;&t; */
r_if
c_cond
(paren
id|cursor-&gt;pad1
op_logical_or
id|cursor-&gt;pad2
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cursor-&gt;initted
op_eq
l_int|0
)paren
op_logical_and
(paren
id|cursor-&gt;hashval
op_logical_or
id|cursor-&gt;blkno
op_logical_or
id|cursor-&gt;offset
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for a properly aligned buffer.&n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|buffer
)paren
op_amp
(paren
r_sizeof
(paren
r_int
)paren
op_minus
l_int|1
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|ATTR_KERNOVAL
)paren
id|bufsize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the output buffer.&n;&t; */
id|context.dp
op_assign
id|dp
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|context.cursor
op_assign
id|cursor
suffix:semicolon
id|context.count
op_assign
l_int|0
suffix:semicolon
id|context.dupcnt
op_assign
l_int|0
suffix:semicolon
id|context.resynch
op_assign
l_int|1
suffix:semicolon
id|context.flags
op_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|ATTR_KERNAMELS
)paren
)paren
(brace
id|context.bufsize
op_assign
(paren
id|bufsize
op_amp
op_complement
(paren
r_sizeof
(paren
r_int
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* align */
id|context.firstu
op_assign
id|context.bufsize
suffix:semicolon
id|context.alist
op_assign
(paren
id|attrlist_t
op_star
)paren
id|buffer
suffix:semicolon
id|context.alist-&gt;al_count
op_assign
l_int|0
suffix:semicolon
id|context.alist-&gt;al_more
op_assign
l_int|0
suffix:semicolon
id|context.alist-&gt;al_offset
(braket
l_int|0
)braket
op_assign
id|context.bufsize
suffix:semicolon
)brace
r_else
(brace
id|context.bufsize
op_assign
id|bufsize
suffix:semicolon
id|context.firstu
op_assign
id|context.bufsize
suffix:semicolon
id|context.alist
op_assign
(paren
id|attrlist_t
op_star
)paren
id|buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
r_return
(paren
id|EIO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do they have permission?&n;&t; */
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|dp
comma
id|IREAD
comma
id|cred
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;syscall start&quot;
comma
op_amp
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|dp
)paren
op_eq
l_int|0
op_logical_or
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|dp-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|error
op_assign
id|xfs_attr_shortform_list
c_func
(paren
op_amp
id|context
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_ATTR_FORK
)paren
)paren
(brace
id|error
op_assign
id|xfs_attr_leaf_list
c_func
(paren
op_amp
id|context
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_attr_node_list
c_func
(paren
op_amp
id|context
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;syscall end&quot;
comma
op_amp
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|context.flags
op_amp
(paren
id|ATTR_KERNOVAL
op_or
id|ATTR_KERNAMELS
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ge
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* must return negated buffer size or the error */
r_if
c_cond
(paren
id|context.count
OL
l_int|0
)paren
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|ERANGE
)paren
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|context.count
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_int
multiline_comment|/* error */
DECL|function|xfs_attr_inactive
id|xfs_attr_inactive
c_func
(paren
id|xfs_inode_t
op_star
id|dp
)paren
(brace
id|xfs_trans_t
op_star
id|trans
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_NOT_DQATTACHED
c_func
(paren
id|mp
comma
id|dp
)paren
)paren
suffix:semicolon
multiline_comment|/* XXXsup - why on earth are we taking ILOCK_EXCL here??? */
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|XFS_IFORK_Q
c_func
(paren
id|dp
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
op_logical_or
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|dp-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start our first transaction of the day.&n;&t; *&n;&t; * All future transactions during this code must be &quot;chained&quot; off&n;&t; * this one via the trans_dup() call.  All transactions will contain&n;&t; * the inode, and the inode will always be marked with trans_ihold().&n;&t; * Since the inode will be locked in all transactions, we must log&n;&t; * the inode in every transaction to let it float upward through&n;&t; * the log.&n;&t; */
id|trans
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_ATTRINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|trans
comma
l_int|0
comma
id|XFS_ATTRINVAL_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|XFS_ATTRINVAL_LOG_COUNT
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|trans
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No need to make quota reservations here. We expect to release some&n;&t; * blocks, not allocate, in the common case.&n;&t; */
id|xfs_trans_ijoin
c_func
(paren
id|trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|trans
comma
id|dp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Decide on what work routines to call based on the inode size.&n;&t; */
r_if
c_cond
(paren
(paren
id|XFS_IFORK_Q
c_func
(paren
id|dp
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
op_logical_or
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
op_logical_and
id|dp-&gt;i_d.di_anextents
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|xfs_attr_root_inactive
c_func
(paren
op_amp
id|trans
comma
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * signal synchronous inactive transactions unless this&n;&t; * is a synchronous mount filesystem in which case we&n;&t; * know that we&squot;re here because we&squot;ve been called out of&n;&t; * xfs_inactive which means that the last reference is gone&n;&t; * and the unlink transaction has already hit the disk so&n;&t; * async inactive transactions are safe.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_itruncate_finish
c_func
(paren
op_amp
id|trans
comma
id|dp
comma
l_int|0LL
comma
id|XFS_ATTR_FORK
comma
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the last in the sequence of transactions.&n;&t; */
id|xfs_trans_log_inode
c_func
(paren
id|trans
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|out
suffix:colon
id|xfs_trans_cancel
c_func
(paren
id|trans
comma
id|XFS_TRANS_RELEASE_LOG_RES
op_or
id|XFS_TRANS_ABORT
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * External routines when attribute list is inside the inode&n; *========================================================================*/
multiline_comment|/*&n; * Add a name to the shortform attribute list structure&n; * This is the external routine.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_shortform_addname
id|xfs_attr_shortform_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
r_int
id|newsize
comma
id|retval
suffix:semicolon
id|retval
op_assign
id|xfs_attr_shortform_lookup
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_REPLACE
)paren
op_logical_and
(paren
id|retval
op_eq
id|ENOATTR
)paren
)paren
(brace
r_return
id|retval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
(brace
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|ATTR_CREATE
)paren
r_return
id|retval
suffix:semicolon
id|retval
op_assign
id|xfs_attr_shortform_remove
c_func
(paren
id|args
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|retval
op_eq
l_int|0
)paren
suffix:semicolon
)brace
id|newsize
op_assign
id|XFS_ATTR_SF_TOTSIZE
c_func
(paren
id|args-&gt;dp
)paren
suffix:semicolon
id|newsize
op_add_assign
id|XFS_ATTR_SF_ENTSIZE_BYNAME
c_func
(paren
id|args-&gt;namelen
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newsize
op_le
id|XFS_IFORK_ASIZE
c_func
(paren
id|args-&gt;dp
)paren
)paren
op_logical_and
(paren
id|args-&gt;namelen
OL
id|XFS_ATTR_SF_ENTSIZE_MAX
)paren
op_logical_and
(paren
id|args-&gt;valuelen
OL
id|XFS_ATTR_SF_ENTSIZE_MAX
)paren
)paren
(brace
id|retval
op_assign
id|xfs_attr_shortform_add
c_func
(paren
id|args
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|retval
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * External routines when attribute list is one block&n; *========================================================================*/
multiline_comment|/*&n; * Add a name to the leaf attribute list structure&n; *&n; * This leaf block cannot have a &quot;remote&quot; value, we only call this routine&n; * if bmap_one_block() says there is only one block (ie: no remote blks).&n; */
r_int
DECL|function|xfs_attr_leaf_addname
id|xfs_attr_leaf_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|retval
comma
id|error
comma
id|committed
suffix:semicolon
multiline_comment|/*&n;&t; * Read the (only) block in the attribute list in.&n;&t; */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|args-&gt;blkno
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the given attribute in the leaf block.  Figure out if&n;&t; * the given flags produce an error or call for an atomic rename.&n;&t; */
id|retval
op_assign
id|xfs_attr_leaf_lookup_int
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_REPLACE
)paren
op_logical_and
(paren
id|retval
op_eq
id|ENOATTR
)paren
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
(brace
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|ATTR_CREATE
)paren
(brace
multiline_comment|/* pure create op */
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|args-&gt;rename
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* an atomic rename */
id|args-&gt;blkno2
op_assign
id|args-&gt;blkno
suffix:semicolon
multiline_comment|/* set 2nd entry info*/
id|args-&gt;index2
op_assign
id|args-&gt;index
suffix:semicolon
id|args-&gt;rmtblkno2
op_assign
id|args-&gt;rmtblkno
suffix:semicolon
id|args-&gt;rmtblkcnt2
op_assign
id|args-&gt;rmtblkcnt
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Add the attribute to the leaf block, transitioning to a Btree&n;&t; * if required.&n;&t; */
id|retval
op_assign
id|xfs_attr_leaf_add
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|ENOSPC
)paren
(brace
multiline_comment|/*&n;&t;&t; * Promote the attribute list to the Btree format, then&n;&t;&t; * Commit that transaction so that the node_addname() call&n;&t;&t; * can manage its own transactions.&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_to_node
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bmap_finish() may have committed the last trans and started&n;&t;&t; * a new one.  We need the inode to be in all transactions.&n;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Commit the current trans (including the inode) and start&n;&t;&t; * a new one.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fob the whole rest of the problem off on the Btree code.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_node_addname
c_func
(paren
id|args
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Commit the transaction that added the attr name so that&n;&t; * later routines can manage their own transactions.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there was an out-of-line value, allocate the blocks we&n;&t; * identified for its storage and copy the value.  This is done&n;&t; * after we create the attribute so that we don&squot;t overflow the&n;&t; * maximum size of a transaction and/or hit a deadlock.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;rmtblkno
OG
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_attr_rmtval_set
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this is an atomic rename operation, we must &quot;flip&quot; the&n;&t; * incomplete flags on the &quot;new&quot; and &quot;old&quot; attribute/value pairs&n;&t; * so that one disappears and one appears atomically.  Then we&n;&t; * must remove the &quot;old&quot; attribute/value pair.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;rename
)paren
(brace
multiline_comment|/*&n;&t;&t; * In a separate transaction, set the incomplete flag on the&n;&t;&t; * &quot;old&quot; attr and clear the incomplete flag on the &quot;new&quot; attr.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_leaf_flipflags
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Dismantle the &quot;old&quot; attribute/value pair by removing&n;&t;&t; * a &quot;remote&quot; value (if it exists).&n;&t;&t; */
id|args-&gt;index
op_assign
id|args-&gt;index2
suffix:semicolon
id|args-&gt;blkno
op_assign
id|args-&gt;blkno2
suffix:semicolon
id|args-&gt;rmtblkno
op_assign
id|args-&gt;rmtblkno2
suffix:semicolon
id|args-&gt;rmtblkcnt
op_assign
id|args-&gt;rmtblkcnt2
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;rmtblkno
)paren
(brace
id|error
op_assign
id|xfs_attr_rmtval_remove
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Read in the block containing the &quot;old&quot; attr, then&n;&t;&t; * remove the &quot;old&quot; attr from that block (neat, huh!)&n;&t;&t; */
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_attr_leaf_remove
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the result is small enough, shrink it all into the inode.&n;&t;&t; */
r_if
c_cond
(paren
id|xfs_attr_shortform_allfit
c_func
(paren
id|bp
comma
id|dp
)paren
)paren
(brace
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_to_shortform
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
multiline_comment|/* bp is gone due to xfs_da_shrink_inode */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * bmap_finish() may have committed the last trans&n;&t;&t;&t; * and started a new one.  We need the inode to be&n;&t;&t;&t; * in all transactions.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
)brace
r_else
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Commit the remove and start the next trans in series.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|args-&gt;rmtblkno
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Added a &quot;remote&quot; value, just clear the incomplete flag.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_leaf_clearflag
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from the leaf attribute list structure&n; *&n; * This leaf block cannot have a &quot;remote&quot; value, we only call this routine&n; * if bmap_one_block() says there is only one block (ie: no remote blks).&n; */
id|STATIC
r_int
DECL|function|xfs_attr_leaf_removename
id|xfs_attr_leaf_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|committed
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Remove the attribute.&n;&t; */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|args-&gt;blkno
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_lookup_int
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOATTR
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
(paren
r_void
)paren
id|xfs_attr_leaf_remove
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the result is small enough, shrink it all into the inode.&n;&t; */
r_if
c_cond
(paren
id|xfs_attr_shortform_allfit
c_func
(paren
id|bp
comma
id|dp
)paren
)paren
(brace
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_to_shortform
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
multiline_comment|/* bp is gone due to xfs_da_shrink_inode */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bmap_finish() may have committed the last trans and started&n;&t;&t; * a new one.  We need the inode to be in all transactions.&n;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
)brace
r_else
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a name in a leaf attribute list structure.&n; *&n; * This leaf block cannot have a &quot;remote&quot; value, we only call this routine&n; * if bmap_one_block() says there is only one block (ie: no remote blks).&n; */
r_int
DECL|function|xfs_attr_leaf_get
id|xfs_attr_leaf_get
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|args-&gt;blkno
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_lookup_int
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
id|EEXIST
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
id|xfs_attr_leaf_getvalue
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|args-&gt;rmtblkno
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|args-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
)paren
(brace
id|error
op_assign
id|xfs_attr_rmtval_get
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy out attribute entries for attr_list(), for leaf attribute lists.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_leaf_list
id|xfs_attr_leaf_list
c_func
(paren
id|xfs_attr_list_context_t
op_star
id|context
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|context-&gt;cursor-&gt;blkno
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
l_int|NULL
comma
id|context-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_ATTR_LEAF_MAGIC
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_attr_leaf_list&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|context-&gt;dp-&gt;i_mount
comma
id|leaf
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|xfs_attr_leaf_list_int
c_func
(paren
id|bp
comma
id|context
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * External routines when attribute list size &gt; XFS_LBSIZE(mp).&n; *========================================================================*/
multiline_comment|/*&n; * Add a name to a Btree-format attribute list.&n; *&n; * This will involve walking down the Btree, and may involve splitting&n; * leaf nodes and even splitting intermediate nodes up to and including&n; * the root node (a special case of an intermediate node).&n; *&n; * &quot;Remote&quot; attribute values confuse the issue and atomic rename operations&n; * add a whole extra layer of confusion on top of that.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_node_addname
id|xfs_attr_node_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|committed
comma
id|retval
comma
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in bucket of arguments/results/context to carry around.&n;&t; */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|restart
suffix:colon
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|mp
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_attr_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Search to see if name already exists, and get back a pointer&n;&t; * to where it should go.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_REPLACE
)paren
op_logical_and
(paren
id|retval
op_eq
id|ENOATTR
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
(brace
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|ATTR_CREATE
)paren
r_goto
id|out
suffix:semicolon
id|args-&gt;rename
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* atomic rename op */
id|args-&gt;blkno2
op_assign
id|args-&gt;blkno
suffix:semicolon
multiline_comment|/* set 2nd entry info*/
id|args-&gt;index2
op_assign
id|args-&gt;index
suffix:semicolon
id|args-&gt;rmtblkno2
op_assign
id|args-&gt;rmtblkno
suffix:semicolon
id|args-&gt;rmtblkcnt2
op_assign
id|args-&gt;rmtblkcnt
suffix:semicolon
id|args-&gt;rmtblkno
op_assign
l_int|0
suffix:semicolon
id|args-&gt;rmtblkcnt
op_assign
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
id|xfs_attr_leaf_add
c_func
(paren
id|blk-&gt;bp
comma
id|state-&gt;args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|ENOSPC
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;path.active
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Its really a single leaf node, but it had&n;&t;&t;&t; * out-of-line values so it looked like it *might*&n;&t;&t;&t; * have been a b-tree.&n;&t;&t;&t; */
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_to_node
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * bmap_finish() may have committed the last trans&n;&t;&t;&t; * and started a new one.  We need the inode to be&n;&t;&t;&t; * in all transactions.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Commit the node conversion and start the next&n;&t;&t;&t; * trans in the chain.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Split as many Btree elements as required.&n;&t;&t; * This code tracks the new and old attr&squot;s location&n;&t;&t; * in the index/blkno/rmtblkno/rmtblkcnt fields and&n;&t;&t; * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_split
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bmap_finish() may have committed the last trans and started&n;&t;&t; * a new one.  We need the inode to be in all transactions.&n;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Addition succeeded, update Btree hashvals.&n;&t;&t; */
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Kill the state structure, we&squot;re done with it and need to&n;&t; * allow the buffers to come back later.&n;&t; */
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
id|state
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the leaf addition or btree split and start the next&n;&t; * trans in the chain.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * If there was an out-of-line value, allocate the blocks we&n;&t; * identified for its storage and copy the value.  This is done&n;&t; * after we create the attribute so that we don&squot;t overflow the&n;&t; * maximum size of a transaction and/or hit a deadlock.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;rmtblkno
OG
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_attr_rmtval_set
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this is an atomic rename operation, we must &quot;flip&quot; the&n;&t; * incomplete flags on the &quot;new&quot; and &quot;old&quot; attribute/value pairs&n;&t; * so that one disappears and one appears atomically.  Then we&n;&t; * must remove the &quot;old&quot; attribute/value pair.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;rename
)paren
(brace
multiline_comment|/*&n;&t;&t; * In a separate transaction, set the incomplete flag on the&n;&t;&t; * &quot;old&quot; attr and clear the incomplete flag on the &quot;new&quot; attr.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_leaf_flipflags
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Dismantle the &quot;old&quot; attribute/value pair by removing&n;&t;&t; * a &quot;remote&quot; value (if it exists).&n;&t;&t; */
id|args-&gt;index
op_assign
id|args-&gt;index2
suffix:semicolon
id|args-&gt;blkno
op_assign
id|args-&gt;blkno2
suffix:semicolon
id|args-&gt;rmtblkno
op_assign
id|args-&gt;rmtblkno2
suffix:semicolon
id|args-&gt;rmtblkcnt
op_assign
id|args-&gt;rmtblkcnt2
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;rmtblkno
)paren
(brace
id|error
op_assign
id|xfs_attr_rmtval_remove
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Re-find the &quot;old&quot; attribute entry after any split ops.&n;&t;&t; * The INCOMPLETE flag means that we will find the &quot;old&quot;&n;&t;&t; * attr, not the &quot;new&quot; one.&n;&t;&t; */
id|args-&gt;flags
op_or_assign
id|XFS_ATTR_INCOMPLETE
suffix:semicolon
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|mp
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_attr_node_ents
suffix:semicolon
id|state-&gt;inleaf
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remove the name and update the hashvals in the tree.&n;&t;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_remove
c_func
(paren
id|blk-&gt;bp
comma
id|args
)paren
suffix:semicolon
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check to see if the tree needs to be collapsed.&n;&t;&t; */
r_if
c_cond
(paren
id|retval
op_logical_and
(paren
id|state-&gt;path.active
OG
l_int|1
)paren
)paren
(brace
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_join
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * bmap_finish() may have committed the last trans&n;&t;&t;&t; * and started a new one.  We need the inode to be&n;&t;&t;&t; * in all transactions.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Commit and start the next trans in the chain.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|args-&gt;rmtblkno
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Added a &quot;remote&quot; value, just clear the incomplete flag.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_leaf_clearflag
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
id|retval
op_assign
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|state
)paren
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from a B-tree attribute list.&n; *&n; * This will involve walking down the Btree, and may involve joining&n; * leaf nodes and even joining intermediate nodes up to and including&n; * the root node (a special case of an intermediate node).&n; */
id|STATIC
r_int
DECL|function|xfs_attr_node_removename
id|xfs_attr_node_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|retval
comma
id|error
comma
id|committed
suffix:semicolon
multiline_comment|/*&n;&t; * Tie a string around our finger to remind us where we are.&n;&t; */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_attr_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Search to see if name exists, and get back a pointer to it.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|retval
op_ne
id|EEXIST
)paren
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|error
op_assign
id|retval
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there is an out-of-line value, de-allocate the blocks.&n;&t; * This is done before we remove the attribute so that we don&squot;t&n;&t; * overflow the maximum size of a transaction and/or hit a deadlock.&n;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;rmtblkno
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Fill in disk block numbers in the state structure&n;&t;&t; * so that we can get the buffers back after we commit&n;&t;&t; * several transactions in the following calls.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_fillstate
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Mark the attribute as INCOMPLETE, then bunmapi() the&n;&t;&t; * remote value.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_leaf_setflag
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|xfs_attr_rmtval_remove
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Refill the state structure with buffers, the prior calls&n;&t;&t; * released our buffers.&n;&t;&t; */
id|error
op_assign
id|xfs_attr_refillstate
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove the name and update the hashvals in the tree.&n;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|retval
op_assign
id|xfs_attr_leaf_remove
c_func
(paren
id|blk-&gt;bp
comma
id|args
)paren
suffix:semicolon
id|xfs_da_fixhashpath
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if the tree needs to be collapsed.&n;&t; */
r_if
c_cond
(paren
id|retval
op_logical_and
(paren
id|state-&gt;path.active
OG
l_int|1
)paren
)paren
(brace
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_join
c_func
(paren
id|state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bmap_finish() may have committed the last trans and started&n;&t;&t; * a new one.  We need the inode to be in all transactions.&n;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Commit the Btree join operation and start a new trans.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the result is small enough, push it all into the inode.&n;&t; */
r_if
c_cond
(paren
id|xfs_bmap_one_block
c_func
(paren
id|dp
comma
id|XFS_ATTR_FORK
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Have to get rid of the copy of this dabuf in the state.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|state-&gt;path.active
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|state-&gt;path.blk
(braket
l_int|0
)braket
dot
id|bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|state-&gt;path.blk
(braket
l_int|0
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
l_int|0
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
(paren
(paren
id|xfs_attr_leafblock_t
op_star
)paren
id|bp-&gt;data
)paren
op_member_access_from_pointer
id|hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_attr_shortform_allfit
c_func
(paren
id|bp
comma
id|dp
)paren
)paren
(brace
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_to_shortform
c_func
(paren
id|bp
comma
id|args
)paren
suffix:semicolon
multiline_comment|/* bp is gone due to xfs_da_shrink_inode */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * bmap_finish() may have committed the last trans&n;&t;&t;&t; * and started a new one.  We need the inode to be&n;&t;&t;&t; * in all transactions.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
)brace
r_else
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Fill in the disk block numbers in the state structure for the buffers&n; * that are attached to the state structure.&n; * This is done so that we can quickly reattach ourselves to those buffers&n; * after some set of transaction commit&squot;s has released these buffers.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_fillstate
id|xfs_attr_fillstate
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
(brace
id|xfs_da_state_path_t
op_star
id|path
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
r_int
id|level
suffix:semicolon
multiline_comment|/*&n;&t; * Roll down the &quot;path&quot; in the state structure, storing the on-disk&n;&t; * block number for those buffers in the &quot;path&quot;.&n;&t; */
id|path
op_assign
op_amp
id|state-&gt;path
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|path-&gt;active
op_ge
l_int|0
)paren
op_logical_and
(paren
id|path-&gt;active
OL
id|XFS_DA_NODE_MAXDEPTH
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
id|path-&gt;blk
comma
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|path-&gt;active
suffix:semicolon
id|blk
op_increment
comma
id|level
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blk-&gt;bp
)paren
(brace
id|blk-&gt;disk_blkno
op_assign
id|xfs_da_blkno
c_func
(paren
id|blk-&gt;bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|blk-&gt;bp
)paren
suffix:semicolon
id|blk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|blk-&gt;disk_blkno
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Roll down the &quot;altpath&quot; in the state structure, storing the on-disk&n;&t; * block number for those buffers in the &quot;altpath&quot;.&n;&t; */
id|path
op_assign
op_amp
id|state-&gt;altpath
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|path-&gt;active
op_ge
l_int|0
)paren
op_logical_and
(paren
id|path-&gt;active
OL
id|XFS_DA_NODE_MAXDEPTH
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
id|path-&gt;blk
comma
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|path-&gt;active
suffix:semicolon
id|blk
op_increment
comma
id|level
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blk-&gt;bp
)paren
(brace
id|blk-&gt;disk_blkno
op_assign
id|xfs_da_blkno
c_func
(paren
id|blk-&gt;bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|blk-&gt;bp
)paren
suffix:semicolon
id|blk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|blk-&gt;disk_blkno
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reattach the buffers to the state structure based on the disk block&n; * numbers stored in the state structure.&n; * This is done after some set of transaction commit&squot;s has released those&n; * buffers from our grip.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_refillstate
id|xfs_attr_refillstate
c_func
(paren
id|xfs_da_state_t
op_star
id|state
)paren
(brace
id|xfs_da_state_path_t
op_star
id|path
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
r_int
id|level
comma
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Roll down the &quot;path&quot; in the state structure, storing the on-disk&n;&t; * block number for those buffers in the &quot;path&quot;.&n;&t; */
id|path
op_assign
op_amp
id|state-&gt;path
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|path-&gt;active
op_ge
l_int|0
)paren
op_logical_and
(paren
id|path-&gt;active
OL
id|XFS_DA_NODE_MAXDEPTH
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
id|path-&gt;blk
comma
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|path-&gt;active
suffix:semicolon
id|blk
op_increment
comma
id|level
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blk-&gt;disk_blkno
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|state-&gt;args-&gt;dp
comma
id|blk-&gt;blkno
comma
id|blk-&gt;disk_blkno
comma
op_amp
id|blk-&gt;bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_else
(brace
id|blk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Roll down the &quot;altpath&quot; in the state structure, storing the on-disk&n;&t; * block number for those buffers in the &quot;altpath&quot;.&n;&t; */
id|path
op_assign
op_amp
id|state-&gt;altpath
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|path-&gt;active
op_ge
l_int|0
)paren
op_logical_and
(paren
id|path-&gt;active
OL
id|XFS_DA_NODE_MAXDEPTH
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
id|path-&gt;blk
comma
id|level
op_assign
l_int|0
suffix:semicolon
id|level
OL
id|path-&gt;active
suffix:semicolon
id|blk
op_increment
comma
id|level
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blk-&gt;disk_blkno
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|state-&gt;args-&gt;dp
comma
id|blk-&gt;blkno
comma
id|blk-&gt;disk_blkno
comma
op_amp
id|blk-&gt;bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_else
(brace
id|blk-&gt;bp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a filename in a node attribute list.&n; *&n; * This routine gets called for any attribute fork that has more than one&n; * block, ie: both true Btree attr lists and for single-leaf-blocks with&n; * &quot;remote&quot; values taking up more blocks.&n; */
r_int
DECL|function|xfs_attr_node_get
id|xfs_attr_node_get
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_da_state_t
op_star
id|state
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
r_int
id|error
comma
id|retval
suffix:semicolon
r_int
id|i
suffix:semicolon
id|state
op_assign
id|xfs_da_state_alloc
c_func
(paren
)paren
suffix:semicolon
id|state-&gt;holeok
op_assign
l_int|1
suffix:semicolon
id|state-&gt;args
op_assign
id|args
suffix:semicolon
id|state-&gt;mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|state-&gt;blocksize
op_assign
id|state-&gt;mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|state-&gt;node_ents
op_assign
id|state-&gt;mp-&gt;m_attr_node_ents
suffix:semicolon
multiline_comment|/*&n;&t; * Search to see if name exists, and get back a pointer to it.&n;&t; */
id|error
op_assign
id|xfs_da_node_lookup_int
c_func
(paren
id|state
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|retval
op_assign
id|error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_eq
id|EEXIST
)paren
(brace
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the value, local or &quot;remote&quot;&n;&t;&t; */
id|retval
op_assign
id|xfs_attr_leaf_getvalue
c_func
(paren
id|blk-&gt;bp
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
(paren
id|args-&gt;rmtblkno
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|args-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
)paren
(brace
id|retval
op_assign
id|xfs_attr_rmtval_get
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If not in a transaction, we have to release all the buffers.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;path.active
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
)paren
suffix:semicolon
id|state-&gt;path.blk
(braket
id|i
)braket
dot
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xfs_da_state_free
c_func
(paren
id|state
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_attr_node_list
id|xfs_attr_node_list
c_func
(paren
id|xfs_attr_list_context_t
op_star
id|context
)paren
(brace
id|attrlist_cursor_kern_t
op_star
id|cursor
suffix:semicolon
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_da_node_entry_t
op_star
id|btree
suffix:semicolon
r_int
id|error
comma
id|i
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|cursor
op_assign
id|context-&gt;cursor
suffix:semicolon
id|cursor-&gt;initted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Do all sorts of validation on the passed-in cursor structure.&n;&t; * If anything is amiss, ignore the cursor and look up the hashval&n;&t; * starting from the btree root.&n;&t; */
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cursor-&gt;blkno
OG
l_int|0
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
l_int|NULL
comma
id|context-&gt;dp
comma
id|cursor-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_ne
l_int|0
)paren
op_logical_and
(paren
id|error
op_ne
id|EFSCORRUPTED
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
r_switch
c_cond
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_case
id|XFS_DA_NODE_MAGIC
suffix:colon
id|xfs_attr_trace_l_cn
c_func
(paren
l_string|&quot;wrong blk&quot;
comma
id|context
comma
id|node
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ATTR_LEAF_MAGIC
suffix:colon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|cursor-&gt;hashval
OG
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_attr_trace_l_cl
c_func
(paren
l_string|&quot;wrong blk&quot;
comma
id|context
comma
id|leaf
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cursor-&gt;hashval
op_le
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_attr_trace_l_cl
c_func
(paren
l_string|&quot;maybe wrong blk&quot;
comma
id|context
comma
id|leaf
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;wrong blk - ??&quot;
comma
id|context
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * We did not find what we expected given the cursor&squot;s contents,&n;&t; * so we start from the top and work down based on the hash value.&n;&t; * Note that start of node block is same as start of leaf block.&n;&t; */
r_if
c_cond
(paren
id|bp
op_eq
l_int|NULL
)paren
(brace
id|cursor-&gt;blkno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
l_int|NULL
comma
id|context-&gt;dp
comma
id|cursor-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bp
op_eq
l_int|NULL
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_attr_node_list(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|context-&gt;dp-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DA_NODE_MAGIC
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_attr_node_list(3)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|context-&gt;dp-&gt;i_mount
comma
id|node
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|btree
op_assign
id|node-&gt;btree
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|btree
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cursor-&gt;hashval
op_le
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|cursor-&gt;blkno
op_assign
id|INT_GET
c_func
(paren
id|btree-&gt;before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_attr_trace_l_cb
c_func
(paren
l_string|&quot;descending&quot;
comma
id|context
comma
id|btree
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Roll upward through the blocks, processing each leaf block in&n;&t; * order.  As long as there is space in the result buffer, keep&n;&t; * adding the information.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_ATTR_LEAF_MAGIC
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_attr_node_list(4)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|context-&gt;dp-&gt;i_mount
comma
id|leaf
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|error
op_assign
id|xfs_attr_leaf_list_int
c_func
(paren
id|bp
comma
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* not really an error, buffer full or EOF */
id|cursor-&gt;blkno
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
l_int|NULL
comma
id|context-&gt;dp
comma
id|cursor-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|bp
op_eq
l_int|NULL
)paren
)paren
)paren
(brace
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_attr_node_list(5)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|context-&gt;dp-&gt;i_mount
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
)brace
id|xfs_da_brelse
c_func
(paren
l_int|NULL
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * External routines for manipulating out-of-line attribute values.&n; *========================================================================*/
multiline_comment|/*&n; * Read the value associated with an attribute from the out-of-line buffer&n; * that we stored it in.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_rmtval_get
id|xfs_attr_rmtval_get
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_bmbt_irec_t
id|map
(braket
id|ATTR_RMTVALUE_MAPSIZE
)braket
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_daddr_t
id|dblkno
suffix:semicolon
id|xfs_caddr_t
id|dst
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|nmap
comma
id|error
comma
id|tmp
comma
id|valuelen
comma
id|blkcnt
comma
id|i
suffix:semicolon
id|xfs_dablk_t
id|lblkno
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|args-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
)paren
suffix:semicolon
id|mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
id|dst
op_assign
id|args-&gt;value
suffix:semicolon
id|valuelen
op_assign
id|args-&gt;valuelen
suffix:semicolon
id|lblkno
op_assign
id|args-&gt;rmtblkno
suffix:semicolon
r_while
c_loop
(paren
id|valuelen
OG
l_int|0
)paren
(brace
id|nmap
op_assign
id|ATTR_RMTVALUE_MAPSIZE
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
(paren
id|xfs_fileoff_t
)paren
id|lblkno
comma
id|args-&gt;rmtblkcnt
comma
id|XFS_BMAPI_ATTRFORK
op_or
id|XFS_BMAPI_METADATA
comma
l_int|NULL
comma
l_int|0
comma
id|map
comma
op_amp
id|nmap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|nmap
op_ge
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|nmap
)paren
op_logical_and
(paren
id|valuelen
OG
l_int|0
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
op_logical_and
(paren
id|map
(braket
id|i
)braket
dot
id|br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
)paren
suffix:semicolon
id|dblkno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|map
(braket
id|i
)braket
dot
id|br_startblock
)paren
suffix:semicolon
id|blkcnt
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|map
(braket
id|i
)braket
dot
id|br_blockcount
)paren
suffix:semicolon
id|error
op_assign
id|xfs_read_buf
c_func
(paren
id|mp
comma
id|mp-&gt;m_ddev_targp
comma
id|dblkno
comma
id|blkcnt
comma
id|XFS_BUF_LOCK
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|tmp
op_assign
(paren
id|valuelen
OL
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
)paren
ques
c_cond
id|valuelen
suffix:colon
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_biomove
c_func
(paren
id|bp
comma
l_int|0
comma
id|tmp
comma
id|dst
comma
id|XFS_B_READ
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|dst
op_add_assign
id|tmp
suffix:semicolon
id|valuelen
op_sub_assign
id|tmp
suffix:semicolon
id|lblkno
op_add_assign
id|map
(braket
id|i
)braket
dot
id|br_blockcount
suffix:semicolon
)brace
)brace
id|ASSERT
c_func
(paren
id|valuelen
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the value associated with an attribute into the out-of-line buffer&n; * that we have defined for it.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_rmtval_set
id|xfs_attr_rmtval_set
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_fileoff_t
id|lfileoff
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
id|xfs_daddr_t
id|dblkno
suffix:semicolon
id|xfs_caddr_t
id|src
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_dablk_t
id|lblkno
suffix:semicolon
r_int
id|blkcnt
comma
id|valuelen
comma
id|nmap
comma
id|error
comma
id|tmp
comma
id|committed
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|src
op_assign
id|args-&gt;value
suffix:semicolon
multiline_comment|/*&n;&t; * Find a &quot;hole&quot; in the attribute address space large enough for&n;&t; * us to drop the new attribute&squot;s value into.&n;&t; */
id|blkcnt
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
id|lfileoff
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_bmap_first_unused
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|blkcnt
comma
op_amp
id|lfileoff
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|args-&gt;rmtblkno
op_assign
id|lblkno
op_assign
(paren
id|xfs_dablk_t
)paren
id|lfileoff
suffix:semicolon
id|args-&gt;rmtblkcnt
op_assign
id|blkcnt
suffix:semicolon
multiline_comment|/*&n;&t; * Roll through the &quot;value&quot;, allocating blocks on disk as required.&n;&t; */
r_while
c_loop
(paren
id|blkcnt
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Allocate a single extent, up to the size of the value.&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|nmap
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
(paren
id|xfs_fileoff_t
)paren
id|lblkno
comma
id|blkcnt
comma
id|XFS_BMAPI_ATTRFORK
op_or
id|XFS_BMAPI_METADATA
op_or
id|XFS_BMAPI_WRITE
comma
id|args-&gt;firstblock
comma
id|args-&gt;total
comma
op_amp
id|map
comma
op_amp
id|nmap
comma
id|args-&gt;flist
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bmap_finish() may have committed the last trans and started&n;&t;&t; * a new one.  We need the inode to be in all transactions.&n;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|dp
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nmap
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|map.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
op_logical_and
(paren
id|map.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
)paren
suffix:semicolon
id|lblkno
op_add_assign
id|map.br_blockcount
suffix:semicolon
id|blkcnt
op_sub_assign
id|map.br_blockcount
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Start the next trans in the chain.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|dp
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Roll through the &quot;value&quot;, copying the attribute value to the&n;&t; * already-allocated blocks.  Blocks are written synchronously&n;&t; * so that we can know they are all on disk before we turn off&n;&t; * the INCOMPLETE flag.&n;&t; */
id|lblkno
op_assign
id|args-&gt;rmtblkno
suffix:semicolon
id|valuelen
op_assign
id|args-&gt;valuelen
suffix:semicolon
r_while
c_loop
(paren
id|valuelen
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try to remember where we decided to put the value.&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|nmap
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|dp
comma
(paren
id|xfs_fileoff_t
)paren
id|lblkno
comma
id|args-&gt;rmtblkcnt
comma
id|XFS_BMAPI_ATTRFORK
op_or
id|XFS_BMAPI_METADATA
comma
id|args-&gt;firstblock
comma
l_int|0
comma
op_amp
id|map
comma
op_amp
id|nmap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nmap
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|map.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
op_logical_and
(paren
id|map.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
)paren
suffix:semicolon
id|dblkno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|map.br_startblock
)paren
comma
id|blkcnt
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|map.br_blockcount
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_buf_get_flags
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|dblkno
comma
id|blkcnt
comma
id|XFS_BUF_LOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|valuelen
OL
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
)paren
ques
c_cond
id|valuelen
suffix:colon
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_biomove
c_func
(paren
id|bp
comma
l_int|0
comma
id|tmp
comma
id|src
comma
id|XFS_B_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
)paren
id|xfs_biozero
c_func
(paren
id|bp
comma
id|tmp
comma
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
op_minus
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
)paren
)paren
(brace
multiline_comment|/* GROT: NOTE: synchronous write */
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|src
op_add_assign
id|tmp
suffix:semicolon
id|valuelen
op_sub_assign
id|tmp
suffix:semicolon
id|lblkno
op_add_assign
id|map.br_blockcount
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|valuelen
op_eq
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove the value associated with an attribute by deleting the&n; * out-of-line buffer that it is stored on.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_rmtval_remove
id|xfs_attr_rmtval_remove
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_daddr_t
id|dblkno
suffix:semicolon
id|xfs_dablk_t
id|lblkno
suffix:semicolon
r_int
id|valuelen
comma
id|blkcnt
comma
id|nmap
comma
id|error
comma
id|done
comma
id|committed
suffix:semicolon
id|mp
op_assign
id|args-&gt;dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Roll through the &quot;value&quot;, invalidating the attribute value&squot;s&n;&t; * blocks.&n;&t; */
id|lblkno
op_assign
id|args-&gt;rmtblkno
suffix:semicolon
id|valuelen
op_assign
id|args-&gt;rmtblkcnt
suffix:semicolon
r_while
c_loop
(paren
id|valuelen
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try to remember where we decided to put the value.&n;&t;&t; */
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|nmap
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
l_int|NULL
comma
id|args-&gt;dp
comma
(paren
id|xfs_fileoff_t
)paren
id|lblkno
comma
id|args-&gt;rmtblkcnt
comma
id|XFS_BMAPI_ATTRFORK
op_or
id|XFS_BMAPI_METADATA
comma
id|args-&gt;firstblock
comma
l_int|0
comma
op_amp
id|map
comma
op_amp
id|nmap
comma
id|args-&gt;flist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nmap
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|map.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
op_logical_and
(paren
id|map.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
)paren
suffix:semicolon
id|dblkno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|map.br_startblock
)paren
comma
id|blkcnt
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|map.br_blockcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the &quot;remote&quot; value is in the cache, remove it.&n;&t;&t; */
multiline_comment|/* bp = incore(mp-&gt;m_dev, dblkno, blkcnt, 1); */
id|bp
op_assign
id|xfs_incore
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|dblkno
comma
id|blkcnt
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_UNDELAYWRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|valuelen
op_sub_assign
id|map.br_blockcount
suffix:semicolon
id|lblkno
op_add_assign
id|map.br_blockcount
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Keep de-allocating extents until the remote-value region is gone.&n;&t; */
id|lblkno
op_assign
id|args-&gt;rmtblkno
suffix:semicolon
id|blkcnt
op_assign
id|args-&gt;rmtblkcnt
suffix:semicolon
id|done
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
id|XFS_BMAP_INIT
c_func
(paren
id|args-&gt;flist
comma
id|args-&gt;firstblock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bunmapi
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|lblkno
comma
id|blkcnt
comma
id|XFS_BMAPI_ATTRFORK
op_or
id|XFS_BMAPI_METADATA
comma
l_int|1
comma
id|args-&gt;firstblock
comma
id|args-&gt;flist
comma
op_amp
id|done
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|xfs_bmap_finish
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;flist
comma
op_star
id|args-&gt;firstblock
comma
op_amp
id|committed
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ASSERT
c_func
(paren
id|committed
)paren
suffix:semicolon
id|args-&gt;trans
op_assign
l_int|NULL
suffix:semicolon
id|xfs_bmap_cancel
c_func
(paren
id|args-&gt;flist
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bmap_finish() may have committed the last trans and started&n;&t;&t; * a new one.  We need the inode to be in all transactions.&n;&t;&t; */
r_if
c_cond
(paren
id|committed
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Close out trans and start the next one in the chain.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;dp
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(XFS_ATTR_TRACE)
multiline_comment|/*&n; * Add a trace buffer entry for an attr_list context structure.&n; */
r_void
DECL|function|xfs_attr_trace_l_c
id|xfs_attr_trace_l_c
c_func
(paren
r_char
op_star
id|where
comma
r_struct
id|xfs_attr_list_context
op_star
id|context
)paren
(brace
id|xfs_attr_trace_enter
c_func
(paren
id|XFS_ATTR_KTRACE_L_C
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dp
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;hashval
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;blkno
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;offset
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;alist
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;bufsize
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;count
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;firstu
comma
(paren
id|__psunsigned_t
)paren
(paren
id|context-&gt;count
OG
l_int|0
)paren
ques
c_cond
(paren
id|ATTR_ENTRY
c_func
(paren
id|context-&gt;alist
comma
id|context-&gt;count
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|a_valuelen
)paren
suffix:colon
l_int|0
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dupcnt
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;flags
comma
(paren
id|__psunsigned_t
)paren
l_int|NULL
comma
(paren
id|__psunsigned_t
)paren
l_int|NULL
comma
(paren
id|__psunsigned_t
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for a context structure and a Btree node.&n; */
r_void
DECL|function|xfs_attr_trace_l_cn
id|xfs_attr_trace_l_cn
c_func
(paren
r_char
op_star
id|where
comma
r_struct
id|xfs_attr_list_context
op_star
id|context
comma
r_struct
id|xfs_da_intnode
op_star
id|node
)paren
(brace
id|xfs_attr_trace_enter
c_func
(paren
id|XFS_ATTR_KTRACE_L_CN
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dp
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;hashval
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;blkno
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;offset
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;alist
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;bufsize
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;count
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;firstu
comma
(paren
id|__psunsigned_t
)paren
(paren
id|context-&gt;count
OG
l_int|0
)paren
ques
c_cond
(paren
id|ATTR_ENTRY
c_func
(paren
id|context-&gt;alist
comma
id|context-&gt;count
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|a_valuelen
)paren
suffix:colon
l_int|0
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dupcnt
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;flags
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for a context structure and a Btree element.&n; */
r_void
DECL|function|xfs_attr_trace_l_cb
id|xfs_attr_trace_l_cb
c_func
(paren
r_char
op_star
id|where
comma
r_struct
id|xfs_attr_list_context
op_star
id|context
comma
r_struct
id|xfs_da_node_entry
op_star
id|btree
)paren
(brace
id|xfs_attr_trace_enter
c_func
(paren
id|XFS_ATTR_KTRACE_L_CB
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dp
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;hashval
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;blkno
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;offset
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;alist
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;bufsize
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;count
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;firstu
comma
(paren
id|__psunsigned_t
)paren
(paren
id|context-&gt;count
OG
l_int|0
)paren
ques
c_cond
(paren
id|ATTR_ENTRY
c_func
(paren
id|context-&gt;alist
comma
id|context-&gt;count
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|a_valuelen
)paren
suffix:colon
l_int|0
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dupcnt
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;flags
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|btree-&gt;hashval
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|btree-&gt;before
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for a context structure and a leaf block.&n; */
r_void
DECL|function|xfs_attr_trace_l_cl
id|xfs_attr_trace_l_cl
c_func
(paren
r_char
op_star
id|where
comma
r_struct
id|xfs_attr_list_context
op_star
id|context
comma
r_struct
id|xfs_attr_leafblock
op_star
id|leaf
)paren
(brace
id|xfs_attr_trace_enter
c_func
(paren
id|XFS_ATTR_KTRACE_L_CL
comma
id|where
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dp
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;hashval
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;blkno
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;cursor-&gt;offset
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;alist
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;bufsize
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;count
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;firstu
comma
(paren
id|__psunsigned_t
)paren
(paren
id|context-&gt;count
OG
l_int|0
)paren
ques
c_cond
(paren
id|ATTR_ENTRY
c_func
(paren
id|context-&gt;alist
comma
id|context-&gt;count
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|a_valuelen
)paren
suffix:colon
l_int|0
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;dupcnt
comma
(paren
id|__psunsigned_t
)paren
id|context-&gt;flags
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
comma
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a trace buffer entry for the arguments given to the routine,&n; * generic form.&n; */
r_void
DECL|function|xfs_attr_trace_enter
id|xfs_attr_trace_enter
c_func
(paren
r_int
id|type
comma
r_char
op_star
id|where
comma
id|__psunsigned_t
id|a2
comma
id|__psunsigned_t
id|a3
comma
id|__psunsigned_t
id|a4
comma
id|__psunsigned_t
id|a5
comma
id|__psunsigned_t
id|a6
comma
id|__psunsigned_t
id|a7
comma
id|__psunsigned_t
id|a8
comma
id|__psunsigned_t
id|a9
comma
id|__psunsigned_t
id|a10
comma
id|__psunsigned_t
id|a11
comma
id|__psunsigned_t
id|a12
comma
id|__psunsigned_t
id|a13
comma
id|__psunsigned_t
id|a14
comma
id|__psunsigned_t
id|a15
)paren
(brace
id|ASSERT
c_func
(paren
id|xfs_attr_trace_buf
)paren
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|xfs_attr_trace_buf
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|__psunsigned_t
)paren
id|type
)paren
comma
(paren
r_void
op_star
)paren
id|where
comma
(paren
r_void
op_star
)paren
id|a2
comma
(paren
r_void
op_star
)paren
id|a3
comma
(paren
r_void
op_star
)paren
id|a4
comma
(paren
r_void
op_star
)paren
id|a5
comma
(paren
r_void
op_star
)paren
id|a6
comma
(paren
r_void
op_star
)paren
id|a7
comma
(paren
r_void
op_star
)paren
id|a8
comma
(paren
r_void
op_star
)paren
id|a9
comma
(paren
r_void
op_star
)paren
id|a10
comma
(paren
r_void
op_star
)paren
id|a11
comma
(paren
r_void
op_star
)paren
id|a12
comma
(paren
r_void
op_star
)paren
id|a13
comma
(paren
r_void
op_star
)paren
id|a14
comma
(paren
r_void
op_star
)paren
id|a15
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* XFS_ATTR_TRACE */
eof
