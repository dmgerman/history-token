multiline_comment|/*&n; * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_rtalloc.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_fsops.h&quot;
id|STATIC
r_void
id|xfs_mount_log_sbunit
c_func
(paren
id|xfs_mount_t
op_star
comma
id|__int64_t
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_uuid_mount
c_func
(paren
id|xfs_mount_t
op_star
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_uuid_unmount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
suffix:semicolon
r_void
id|xfs_xlatesb
c_func
(paren
r_void
op_star
comma
id|xfs_sb_t
op_star
comma
r_int
comma
id|xfs_arch_t
comma
id|__int64_t
)paren
suffix:semicolon
r_static
r_struct
(brace
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
multiline_comment|/* 0 = integer&n;&t;&t;* 1 = binary / string (no translation)&n;&t;&t;*/
DECL|variable|xfs_sb_info
)brace
id|xfs_sb_info
(braket
)braket
op_assign
(brace
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_magicnum
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_blocksize
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_dblocks
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rblocks
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rextents
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_uuid
)paren
comma
l_int|1
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_logstart
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rootino
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rbmino
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rsumino
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rextsize
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_agblocks
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_agcount
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rbmblocks
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_logblocks
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_versionnum
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_sectsize
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_inodesize
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_inopblock
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_fname
(braket
l_int|0
)braket
)paren
comma
l_int|1
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_blocklog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_sectlog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_inodelog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_inopblog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_agblklog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_rextslog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_inprogress
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_imax_pct
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_icount
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_ifree
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_fdblocks
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_frextents
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_uquotino
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_gquotino
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_qflags
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_flags
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_shared_vn
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_inoalignmt
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_unit
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_width
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_dirblklog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_logsectlog
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_logsectsize
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_logsunit
)paren
comma
l_int|0
)brace
comma
(brace
m_offsetof
(paren
id|xfs_sb_t
comma
id|sb_features2
)paren
comma
l_int|0
)brace
comma
(brace
r_sizeof
(paren
id|xfs_sb_t
)paren
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * Return a pointer to an initialized xfs_mount structure.&n; */
id|xfs_mount_t
op_star
DECL|function|xfs_mount_init
id|xfs_mount_init
c_func
(paren
r_void
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
op_star
id|mp
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|AIL_LOCKINIT
c_func
(paren
op_amp
id|mp-&gt;m_ail_lock
comma
l_string|&quot;xfs_ail&quot;
)paren
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|mp-&gt;m_sb_lock
comma
l_string|&quot;xfs_sb&quot;
)paren
suffix:semicolon
id|mutex_init
c_func
(paren
op_amp
id|mp-&gt;m_ilock
comma
id|MUTEX_DEFAULT
comma
l_string|&quot;xfs_ilock&quot;
)paren
suffix:semicolon
id|initnsema
c_func
(paren
op_amp
id|mp-&gt;m_growlock
comma
l_int|1
comma
l_string|&quot;xfs_grow&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the AIL.&n;&t; */
id|xfs_trans_ail_init
c_func
(paren
id|mp
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mp-&gt;m_active_trans
comma
l_int|0
)paren
suffix:semicolon
r_return
id|mp
suffix:semicolon
)brace
multiline_comment|/*&n; * Free up the resources associated with a mount structure.  Assume that&n; * the structure was initially zeroed, so we can tell which fields got&n; * initialized.&n; */
r_void
DECL|function|xfs_mount_free
id|xfs_mount_free
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|remove_bhv
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_ihash
)paren
id|xfs_ihash_free
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_chash
)paren
id|xfs_chash_free
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_perag
)paren
(brace
r_int
id|agno
suffix:semicolon
r_for
c_loop
(paren
id|agno
op_assign
l_int|0
suffix:semicolon
id|agno
OL
id|mp-&gt;m_maxagi
suffix:semicolon
id|agno
op_increment
)paren
r_if
c_cond
(paren
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
)paren
id|kmem_free
c_func
(paren
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
comma
r_sizeof
(paren
id|xfs_perag_busy_t
)paren
op_star
id|XFS_PAGB_NUM_SLOTS
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|mp-&gt;m_perag
comma
r_sizeof
(paren
id|xfs_perag_t
)paren
op_star
id|mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
)brace
id|AIL_LOCK_DESTROY
c_func
(paren
op_amp
id|mp-&gt;m_ail_lock
)paren
suffix:semicolon
id|spinlock_destroy
c_func
(paren
op_amp
id|mp-&gt;m_sb_lock
)paren
suffix:semicolon
id|mutex_destroy
c_func
(paren
op_amp
id|mp-&gt;m_ilock
)paren
suffix:semicolon
id|freesema
c_func
(paren
op_amp
id|mp-&gt;m_growlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_quotainfo
)paren
id|XFS_QM_DONE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_fsname
op_ne
l_int|NULL
)paren
id|kmem_free
c_func
(paren
id|mp-&gt;m_fsname
comma
id|mp-&gt;m_fsname_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_bhv
)paren
(brace
r_struct
id|vfs
op_star
id|vfsp
op_assign
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
suffix:semicolon
id|bhv_remove_all_vfsops
c_func
(paren
id|vfsp
comma
l_int|0
)paren
suffix:semicolon
id|VFS_REMOVEBHV
c_func
(paren
id|vfsp
comma
op_amp
id|mp-&gt;m_bhv
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|mp
comma
r_sizeof
(paren
id|xfs_mount_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check the validity of the SB found.&n; */
id|STATIC
r_int
DECL|function|xfs_mount_validate_sb
id|xfs_mount_validate_sb
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_sb_t
op_star
id|sbp
)paren
(brace
multiline_comment|/*&n;&t; * If the log device and data device have the&n;&t; * same device number, the log is internal.&n;&t; * Consequently, the sb_logstart should be non-zero.  If&n;&t; * we have a zero sb_logstart in this case, we may be trying to mount&n;&t; * a volume filesystem in a non-volume manner.&n;&t; */
r_if
c_cond
(paren
id|sbp-&gt;sb_magicnum
op_ne
id|XFS_SB_MAGIC
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: bad magic number&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EWRONGFS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_GOOD_VERSION
c_func
(paren
id|sbp
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: bad version&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EWRONGFS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sbp-&gt;sb_logstart
op_eq
l_int|0
op_logical_and
id|mp-&gt;m_logdev_targp
op_eq
id|mp-&gt;m_ddev_targp
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: filesystem is marked as having an external log; &quot;
l_string|&quot;specify logdev on the&bslash;nmount command line.&quot;
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_mount_validate_sb(1)&quot;
comma
id|XFS_ERRLEVEL_HIGH
comma
id|mp
comma
id|sbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sbp-&gt;sb_logstart
op_ne
l_int|0
op_logical_and
id|mp-&gt;m_logdev_targp
op_ne
id|mp-&gt;m_ddev_targp
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: filesystem is marked as having an internal log; &quot;
l_string|&quot;don&squot;t specify logdev on&bslash;nthe mount command line.&quot;
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_mount_validate_sb(2)&quot;
comma
id|XFS_ERRLEVEL_HIGH
comma
id|mp
comma
id|sbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * More sanity checking. These were stolen directly from&n;&t; * xfs_repair.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sbp-&gt;sb_agcount
op_le
l_int|0
op_logical_or
id|sbp-&gt;sb_sectsize
template_param
id|XFS_MAX_SECTORSIZE
op_logical_or
id|sbp-&gt;sb_sectlog
template_param
id|XFS_MAX_SECTORSIZE_LOG
op_logical_or
id|sbp-&gt;sb_blocksize
template_param
id|XFS_MAX_BLOCKSIZE
op_logical_or
id|sbp-&gt;sb_blocklog
template_param
id|XFS_MAX_BLOCKSIZE_LOG
op_logical_or
id|sbp-&gt;sb_inodesize
template_param
id|XFS_DINODE_MAX_SIZE
op_logical_or
(paren
id|sbp-&gt;sb_rextsize
op_star
id|sbp-&gt;sb_blocksize
OG
id|XFS_MAX_RTEXTSIZE
)paren
op_logical_or
(paren
id|sbp-&gt;sb_rextsize
op_star
id|sbp-&gt;sb_blocksize
OL
id|XFS_MIN_RTEXTSIZE
)paren
op_logical_or
id|sbp-&gt;sb_imax_pct
OG
l_int|100
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: SB sanity check 1 failed&quot;
)paren
suffix:semicolon
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_mount_validate_sb(3)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|sbp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Sanity check AG count, size fields against data size field&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sbp-&gt;sb_dblocks
op_eq
l_int|0
op_logical_or
id|sbp-&gt;sb_dblocks
OG
(paren
id|xfs_drfsbno_t
)paren
id|sbp-&gt;sb_agcount
op_star
id|sbp-&gt;sb_agblocks
op_logical_or
id|sbp-&gt;sb_dblocks
OL
(paren
id|xfs_drfsbno_t
)paren
(paren
id|sbp-&gt;sb_agcount
op_minus
l_int|1
)paren
op_star
id|sbp-&gt;sb_agblocks
op_plus
id|XFS_MIN_AG_BLOCKS
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: SB sanity check 2 failed&quot;
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_mount_validate_sb(4)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|PAGE_SHIFT
op_ge
id|sbp-&gt;sb_blocklog
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|sbp-&gt;sb_blocklog
op_ge
id|BBSHIFT
)paren
suffix:semicolon
macro_line|#if XFS_BIG_BLKNOS     /* Limited by ULONG_MAX of page cache index */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|sbp-&gt;sb_dblocks
op_rshift
(paren
id|PAGE_SHIFT
op_minus
id|sbp-&gt;sb_blocklog
)paren
)paren
OG
id|ULONG_MAX
op_logical_or
(paren
id|sbp-&gt;sb_rblocks
op_rshift
(paren
id|PAGE_SHIFT
op_minus
id|sbp-&gt;sb_blocklog
)paren
)paren
OG
id|ULONG_MAX
)paren
)paren
(brace
macro_line|#else                  /* Limited by UINT_MAX of sectors */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|sbp-&gt;sb_dblocks
op_lshift
(paren
id|sbp-&gt;sb_blocklog
op_minus
id|BBSHIFT
)paren
)paren
OG
id|UINT_MAX
op_logical_or
(paren
id|sbp-&gt;sb_rblocks
op_lshift
(paren
id|sbp-&gt;sb_blocklog
op_minus
id|BBSHIFT
)paren
)paren
OG
id|UINT_MAX
)paren
)paren
(brace
macro_line|#endif
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: File system is too large to be mounted on this system.&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|E2BIG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sbp-&gt;sb_inprogress
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: file system busy&quot;
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_mount_validate_sb(5)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Until this is fixed only page-sized or smaller data blocks work.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|sbp-&gt;sb_blocksize
OG
id|PAGE_SIZE
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: Attempted to mount file system with blocksize %d bytes&quot;
comma
id|sbp-&gt;sb_blocksize
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: Only page-sized (%d) or less blocksizes currently work.&quot;
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSYS
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xfs_initialize_perag
id|xfs_initialize_perag
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|agcount
)paren
(brace
r_int
id|index
comma
id|max_metadata
suffix:semicolon
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
id|xfs_agino_t
id|agino
suffix:semicolon
id|xfs_ino_t
id|ino
suffix:semicolon
id|xfs_sb_t
op_star
id|sbp
op_assign
op_amp
id|mp-&gt;m_sb
suffix:semicolon
id|xfs_ino_t
id|max_inum
op_assign
id|XFS_MAXINUMBER_32
suffix:semicolon
multiline_comment|/* Check to see if the filesystem can overflow 32 bit inodes */
id|agino
op_assign
id|XFS_OFFBNO_TO_AGINO
c_func
(paren
id|mp
comma
id|sbp-&gt;sb_agblocks
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agcount
op_minus
l_int|1
comma
id|agino
)paren
suffix:semicolon
multiline_comment|/* Clear the mount flag if no inode can overflow 32 bits&n;&t; * on this filesystem, or if specifically requested..&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_32BITINOOPT
)paren
op_logical_and
id|ino
OG
id|max_inum
)paren
(brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_32BITINODES
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;m_flags
op_and_assign
op_complement
id|XFS_MOUNT_32BITINODES
suffix:semicolon
)brace
multiline_comment|/* If we can overflow then setup the ag headers accordingly */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_32BITINODES
)paren
(brace
multiline_comment|/* Calculate how much should be reserved for inodes to&n;&t;&t; * meet the max inode percentage.&n;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_maxicount
)paren
(brace
id|__uint64_t
id|icount
suffix:semicolon
id|icount
op_assign
id|sbp-&gt;sb_dblocks
op_star
id|sbp-&gt;sb_imax_pct
suffix:semicolon
id|do_div
c_func
(paren
id|icount
comma
l_int|100
)paren
suffix:semicolon
id|icount
op_add_assign
id|sbp-&gt;sb_agblocks
op_minus
l_int|1
suffix:semicolon
id|do_div
c_func
(paren
id|icount
comma
id|mp-&gt;m_ialloc_blks
)paren
suffix:semicolon
id|max_metadata
op_assign
id|icount
suffix:semicolon
)brace
r_else
(brace
id|max_metadata
op_assign
id|agcount
suffix:semicolon
)brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|agcount
suffix:semicolon
id|index
op_increment
)paren
(brace
id|ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|index
comma
id|agino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
OG
id|max_inum
)paren
(brace
id|index
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* This ag is prefered for inodes */
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|index
)braket
suffix:semicolon
id|pag-&gt;pagi_inodeok
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|max_metadata
)paren
id|pag-&gt;pagf_metadata
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Setup default behavior for smaller filesystems */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|agcount
suffix:semicolon
id|index
op_increment
)paren
(brace
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|index
)braket
suffix:semicolon
id|pag-&gt;pagi_inodeok
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|mp-&gt;m_maxagi
op_assign
id|index
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_xlatesb&n; *&n; *     data       - on disk version of sb&n; *     sb         - a superblock&n; *     dir        - conversion direction: &lt;0 - convert sb to buf&n; *                                        &gt;0 - convert buf to sb&n; *     arch       - architecture to read/write from/to buf&n; *     fields     - which fields to copy (bitmask)&n; */
r_void
DECL|function|xfs_xlatesb
id|xfs_xlatesb
c_func
(paren
r_void
op_star
id|data
comma
id|xfs_sb_t
op_star
id|sb
comma
r_int
id|dir
comma
id|xfs_arch_t
id|arch
comma
id|__int64_t
id|fields
)paren
(brace
id|xfs_caddr_t
id|buf_ptr
suffix:semicolon
id|xfs_caddr_t
id|mem_ptr
suffix:semicolon
id|xfs_sb_field_t
id|f
suffix:semicolon
r_int
id|first
suffix:semicolon
r_int
id|size
suffix:semicolon
id|ASSERT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|fields
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fields
)paren
r_return
suffix:semicolon
id|buf_ptr
op_assign
(paren
id|xfs_caddr_t
)paren
id|data
suffix:semicolon
id|mem_ptr
op_assign
(paren
id|xfs_caddr_t
)paren
id|sb
suffix:semicolon
r_while
c_loop
(paren
id|fields
)paren
(brace
id|f
op_assign
(paren
id|xfs_sb_field_t
)paren
id|xfs_lowbit64
c_func
(paren
(paren
id|__uint64_t
)paren
id|fields
)paren
suffix:semicolon
id|first
op_assign
id|xfs_sb_info
(braket
id|f
)braket
dot
id|offset
suffix:semicolon
id|size
op_assign
id|xfs_sb_info
(braket
id|f
op_plus
l_int|1
)braket
dot
id|offset
op_minus
id|first
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_sb_info
(braket
id|f
)braket
dot
id|type
op_eq
l_int|0
op_logical_or
id|xfs_sb_info
(braket
id|f
)braket
dot
id|type
op_eq
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arch
op_eq
id|ARCH_NOCONVERT
op_logical_or
id|size
op_eq
l_int|1
op_logical_or
id|xfs_sb_info
(braket
id|f
)braket
dot
id|type
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|dir
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|mem_ptr
op_plus
id|first
comma
id|buf_ptr
op_plus
id|first
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|buf_ptr
op_plus
id|first
comma
id|mem_ptr
op_plus
id|first
comma
id|size
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|2
suffix:colon
id|INT_XLATE
c_func
(paren
op_star
(paren
id|__uint16_t
op_star
)paren
(paren
id|buf_ptr
op_plus
id|first
)paren
comma
op_star
(paren
id|__uint16_t
op_star
)paren
(paren
id|mem_ptr
op_plus
id|first
)paren
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|INT_XLATE
c_func
(paren
op_star
(paren
id|__uint32_t
op_star
)paren
(paren
id|buf_ptr
op_plus
id|first
)paren
comma
op_star
(paren
id|__uint32_t
op_star
)paren
(paren
id|mem_ptr
op_plus
id|first
)paren
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|INT_XLATE
c_func
(paren
op_star
(paren
id|__uint64_t
op_star
)paren
(paren
id|buf_ptr
op_plus
id|first
)paren
comma
op_star
(paren
id|__uint64_t
op_star
)paren
(paren
id|mem_ptr
op_plus
id|first
)paren
comma
id|dir
comma
id|arch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|fields
op_and_assign
op_complement
(paren
l_int|1LL
op_lshift
id|f
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * xfs_readsb&n; *&n; * Does the initial read of the superblock.&n; */
r_int
DECL|function|xfs_readsb
id|xfs_readsb
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
r_int
r_int
id|sector_size
suffix:semicolon
r_int
r_int
id|extra_flags
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_sb_bp
op_eq
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_ddev_targp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a (locked) buffer to hold the superblock.&n;&t; * This will be kept around at all times to optimize&n;&t; * access to the superblock.&n;&t; */
id|sector_size
op_assign
id|xfs_getsize_buftarg
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|extra_flags
op_assign
id|XFS_BUF_LOCK
op_or
id|XFS_BUF_MANAGE
op_or
id|XFS_BUF_MAPPED
suffix:semicolon
id|bp
op_assign
id|xfs_buf_read_flags
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|XFS_SB_DADDR
comma
id|BTOBB
c_func
(paren
id|sector_size
)paren
comma
id|extra_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
op_logical_or
id|XFS_BUF_ISERROR
c_func
(paren
id|bp
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: SB read failed&quot;
)paren
suffix:semicolon
id|error
op_assign
id|bp
ques
c_cond
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:colon
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the mount structure from the superblock.&n;&t; * But first do some basic consistency checking.&n;&t; */
id|sbp
op_assign
id|XFS_BUF_TO_SBP
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_xlatesb
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
op_amp
(paren
id|mp-&gt;m_sb
)paren
comma
l_int|1
comma
id|ARCH_CONVERT
comma
id|XFS_SB_ALL_BITS
)paren
suffix:semicolon
id|error
op_assign
id|xfs_mount_validate_sb
c_func
(paren
id|mp
comma
op_amp
(paren
id|mp-&gt;m_sb
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: SB validate failed&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We must be able to do sector-sized and sector-aligned IO.&n;&t; */
r_if
c_cond
(paren
id|sector_size
OG
id|mp-&gt;m_sb.sb_sectsize
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: device supports only %u byte sectors (not %u)&quot;
comma
id|sector_size
comma
id|mp-&gt;m_sb.sb_sectsize
)paren
suffix:semicolon
id|error
op_assign
id|ENOSYS
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If device sector size is smaller than the superblock size,&n;&t; * re-read the superblock so the buffer is correctly sized.&n;&t; */
r_if
c_cond
(paren
id|sector_size
OL
id|mp-&gt;m_sb.sb_sectsize
)paren
(brace
id|XFS_BUF_UNMANAGE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|sector_size
op_assign
id|mp-&gt;m_sb.sb_sectsize
suffix:semicolon
id|bp
op_assign
id|xfs_buf_read_flags
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|XFS_SB_DADDR
comma
id|BTOBB
c_func
(paren
id|sector_size
)paren
comma
id|extra_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
op_logical_or
id|XFS_BUF_ISERROR
c_func
(paren
id|bp
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: SB re-read failed&quot;
)paren
suffix:semicolon
id|error
op_assign
id|bp
ques
c_cond
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
suffix:colon
id|ENOMEM
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb_bp
op_assign
id|bp
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
OG
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|XFS_BUF_UNMANAGE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mount_common&n; *&n; * Mount initialization code establishing various mount&n; * fields from the superblock associated with the given&n; * mount structure&n; */
r_void
DECL|function|xfs_mount_common
id|xfs_mount_common
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_sb_t
op_star
id|sbp
)paren
(brace
r_int
id|i
suffix:semicolon
id|mp-&gt;m_agfrotor
op_assign
id|mp-&gt;m_agirotor
op_assign
l_int|0
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|mp-&gt;m_agirotor_lock
comma
l_string|&quot;m_agirotor_lock&quot;
)paren
suffix:semicolon
id|mp-&gt;m_maxagi
op_assign
id|mp-&gt;m_sb.sb_agcount
suffix:semicolon
id|mp-&gt;m_blkbit_log
op_assign
id|sbp-&gt;sb_blocklog
op_plus
id|XFS_NBBYLOG
suffix:semicolon
id|mp-&gt;m_blkbb_log
op_assign
id|sbp-&gt;sb_blocklog
op_minus
id|BBSHIFT
suffix:semicolon
id|mp-&gt;m_sectbb_log
op_assign
id|sbp-&gt;sb_sectlog
op_minus
id|BBSHIFT
suffix:semicolon
id|mp-&gt;m_agno_log
op_assign
id|xfs_highbit32
c_func
(paren
id|sbp-&gt;sb_agcount
op_minus
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
id|mp-&gt;m_agino_log
op_assign
id|sbp-&gt;sb_inopblog
op_plus
id|sbp-&gt;sb_agblklog
suffix:semicolon
id|mp-&gt;m_litino
op_assign
id|sbp-&gt;sb_inodesize
op_minus
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_agino_t
)paren
)paren
suffix:semicolon
id|mp-&gt;m_blockmask
op_assign
id|sbp-&gt;sb_blocksize
op_minus
l_int|1
suffix:semicolon
id|mp-&gt;m_blockwsize
op_assign
id|sbp-&gt;sb_blocksize
op_rshift
id|XFS_WORDLOG
suffix:semicolon
id|mp-&gt;m_blockwmask
op_assign
id|mp-&gt;m_blockwsize
op_minus
l_int|1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|mp-&gt;m_del_inodes
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup for attributes, in case they get created.&n;&t; * This value is for inodes getting attributes for the first time,&n;&t; * the per-inode value is for old attribute values.&n;&t; */
id|ASSERT
c_func
(paren
id|sbp-&gt;sb_inodesize
op_ge
l_int|256
op_logical_and
id|sbp-&gt;sb_inodesize
op_le
l_int|2048
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sbp-&gt;sb_inodesize
)paren
(brace
r_case
l_int|256
suffix:colon
id|mp-&gt;m_attroffset
op_assign
id|XFS_LITINO
c_func
(paren
id|mp
)paren
op_minus
id|XFS_BMDR_SPACE_CALC
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|512
suffix:colon
r_case
l_int|1024
suffix:colon
r_case
l_int|2048
suffix:colon
id|mp-&gt;m_attroffset
op_assign
id|XFS_BMDR_SPACE_CALC
c_func
(paren
l_int|12
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|mp-&gt;m_attroffset
OL
id|XFS_LITINO
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mp-&gt;m_alloc_mxr
(braket
id|i
)braket
op_assign
id|XFS_BTREE_BLOCK_MAXRECS
c_func
(paren
id|sbp-&gt;sb_blocksize
comma
id|xfs_alloc
comma
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|mp-&gt;m_alloc_mnr
(braket
id|i
)braket
op_assign
id|XFS_BTREE_BLOCK_MINRECS
c_func
(paren
id|sbp-&gt;sb_blocksize
comma
id|xfs_alloc
comma
id|i
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mp-&gt;m_bmap_dmxr
(braket
id|i
)braket
op_assign
id|XFS_BTREE_BLOCK_MAXRECS
c_func
(paren
id|sbp-&gt;sb_blocksize
comma
id|xfs_bmbt
comma
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|mp-&gt;m_bmap_dmnr
(braket
id|i
)braket
op_assign
id|XFS_BTREE_BLOCK_MINRECS
c_func
(paren
id|sbp-&gt;sb_blocksize
comma
id|xfs_bmbt
comma
id|i
op_eq
l_int|0
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|mp-&gt;m_inobt_mxr
(braket
id|i
)braket
op_assign
id|XFS_BTREE_BLOCK_MAXRECS
c_func
(paren
id|sbp-&gt;sb_blocksize
comma
id|xfs_inobt
comma
id|i
op_eq
l_int|0
)paren
suffix:semicolon
id|mp-&gt;m_inobt_mnr
(braket
id|i
)braket
op_assign
id|XFS_BTREE_BLOCK_MINRECS
c_func
(paren
id|sbp-&gt;sb_blocksize
comma
id|xfs_inobt
comma
id|i
op_eq
l_int|0
)paren
suffix:semicolon
)brace
id|mp-&gt;m_bsize
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
suffix:semicolon
id|mp-&gt;m_ialloc_inos
op_assign
(paren
r_int
)paren
id|MAX
c_func
(paren
(paren
id|__uint16_t
)paren
id|XFS_INODES_PER_CHUNK
comma
id|sbp-&gt;sb_inopblock
)paren
suffix:semicolon
id|mp-&gt;m_ialloc_blks
op_assign
id|mp-&gt;m_ialloc_inos
op_rshift
id|sbp-&gt;sb_inopblog
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mountfs&n; *&n; * This function does the following on an initial mount of a file system:&n; *&t;- reads the superblock from disk and init the mount struct&n; *&t;- if we&squot;re a 32-bit kernel, do a size check on the superblock&n; *&t;&t;so we don&squot;t mount terabyte filesystems&n; *&t;- init mount struct realtime fields&n; *&t;- allocate inode hash table for fs&n; *&t;- init directory manager&n; *&t;- perform recovery and init the log manager&n; */
r_int
DECL|function|xfs_mountfs
id|xfs_mountfs
c_func
(paren
id|vfs_t
op_star
id|vfsp
comma
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|mfsi_flags
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_sb_t
op_star
id|sbp
op_assign
op_amp
(paren
id|mp-&gt;m_sb
)paren
suffix:semicolon
id|xfs_inode_t
op_star
id|rip
suffix:semicolon
id|vnode_t
op_star
id|rvp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|readio_log
comma
id|writeio_log
suffix:semicolon
id|xfs_daddr_t
id|d
suffix:semicolon
id|__uint64_t
id|ret64
suffix:semicolon
id|__int64_t
id|update_flags
suffix:semicolon
id|uint
id|quotamount
comma
id|quotaflags
suffix:semicolon
r_int
id|agno
suffix:semicolon
r_int
id|uuid_mounted
op_assign
l_int|0
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_sb_bp
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_readsb
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
id|xfs_mount_common
c_func
(paren
id|mp
comma
id|sbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if sb_agblocks is aligned at stripe boundary&n;&t; * If sb_agblocks is NOT aligned turn off m_dalign since&n;&t; * allocator alignment is within an ag, therefore ag has&n;&t; * to be aligned at stripe boundary.&n;&t; */
id|update_flags
op_assign
l_int|0LL
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_dalign
op_logical_and
op_logical_neg
(paren
id|mfsi_flags
op_amp
id|XFS_MFSI_SECOND
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If stripe unit and stripe width are not multiples&n;&t;&t; * of the fs blocksize turn off alignment.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|BBTOB
c_func
(paren
id|mp-&gt;m_dalign
)paren
op_amp
id|mp-&gt;m_blockmask
)paren
op_logical_or
(paren
id|BBTOB
c_func
(paren
id|mp-&gt;m_swidth
)paren
op_amp
id|mp-&gt;m_blockmask
)paren
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_RETERR
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: alignment check 1 failed&quot;
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|mp-&gt;m_dalign
op_assign
id|mp-&gt;m_swidth
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Convert the stripe unit and width to FSBs.&n;&t;&t;&t; */
id|mp-&gt;m_dalign
op_assign
id|XFS_BB_TO_FSBT
c_func
(paren
id|mp
comma
id|mp-&gt;m_dalign
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_dalign
op_logical_and
(paren
id|sbp-&gt;sb_agblocks
op_mod
id|mp-&gt;m_dalign
)paren
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_RETERR
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;stripe alignment turned off: sunit(%d)/swidth(%d) incompatible with agsize(%d)&quot;
comma
id|mp-&gt;m_dalign
comma
id|mp-&gt;m_swidth
comma
id|sbp-&gt;sb_agblocks
)paren
suffix:semicolon
id|mp-&gt;m_dalign
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;m_swidth
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mp-&gt;m_dalign
)paren
(brace
id|mp-&gt;m_swidth
op_assign
id|XFS_BB_TO_FSBT
c_func
(paren
id|mp
comma
id|mp-&gt;m_swidth
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_RETERR
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;stripe alignment turned off: sunit(%d) less than bsize(%d)&quot;
comma
id|mp-&gt;m_dalign
comma
id|mp-&gt;m_blockmask
op_plus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|mp-&gt;m_swidth
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Update superblock with new values&n;&t;&t; * and log changes&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASDALIGN
c_func
(paren
id|sbp
)paren
)paren
(brace
r_if
c_cond
(paren
id|sbp-&gt;sb_unit
op_ne
id|mp-&gt;m_dalign
)paren
(brace
id|sbp-&gt;sb_unit
op_assign
id|mp-&gt;m_dalign
suffix:semicolon
id|update_flags
op_or_assign
id|XFS_SB_UNIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sbp-&gt;sb_width
op_ne
id|mp-&gt;m_swidth
)paren
(brace
id|sbp-&gt;sb_width
op_assign
id|mp-&gt;m_swidth
suffix:semicolon
id|update_flags
op_or_assign
id|XFS_SB_WIDTH
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NOALIGN
)paren
op_ne
id|XFS_MOUNT_NOALIGN
op_logical_and
id|XFS_SB_VERSION_HASDALIGN
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|mp-&gt;m_dalign
op_assign
id|sbp-&gt;sb_unit
suffix:semicolon
id|mp-&gt;m_swidth
op_assign
id|sbp-&gt;sb_width
suffix:semicolon
)brace
id|xfs_alloc_compute_maxlevels
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_bmap_compute_maxlevels
c_func
(paren
id|mp
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_bmap_compute_maxlevels
c_func
(paren
id|mp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
id|xfs_ialloc_compute_maxlevels
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp-&gt;sb_imax_pct
)paren
(brace
id|__uint64_t
id|icount
suffix:semicolon
multiline_comment|/* Make sure the maximum inode count is a multiple of the&n;&t;&t; * units we allocate inodes in.&n;&t;&t; */
id|icount
op_assign
id|sbp-&gt;sb_dblocks
op_star
id|sbp-&gt;sb_imax_pct
suffix:semicolon
id|do_div
c_func
(paren
id|icount
comma
l_int|100
)paren
suffix:semicolon
id|do_div
c_func
(paren
id|icount
comma
id|mp-&gt;m_ialloc_blks
)paren
suffix:semicolon
id|mp-&gt;m_maxicount
op_assign
(paren
id|icount
op_star
id|mp-&gt;m_ialloc_blks
)paren
op_lshift
id|sbp-&gt;sb_inopblog
suffix:semicolon
)brace
r_else
id|mp-&gt;m_maxicount
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;m_maxioffset
op_assign
id|xfs_max_file_offset
c_func
(paren
id|sbp-&gt;sb_blocklog
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * XFS uses the uuid from the superblock as the unique&n;&t; * identifier for fsid.  We can not use the uuid from the volume&n;&t; * since a single partition filesystem is identical to a single&n;&t; * partition volume/filesystem.&n;&t; */
r_if
c_cond
(paren
(paren
id|mfsi_flags
op_amp
id|XFS_MFSI_SECOND
)paren
op_eq
l_int|0
op_logical_and
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NOUUID
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|xfs_uuid_mount
c_func
(paren
id|mp
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|uuid_mounted
op_assign
l_int|1
suffix:semicolon
id|ret64
op_assign
id|uuid_hash64
c_func
(paren
op_amp
id|sbp-&gt;sb_uuid
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|vfsp-&gt;vfs_fsid
comma
op_amp
id|ret64
comma
r_sizeof
(paren
id|ret64
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set the default minimum read and write sizes unless&n;&t; * already specified in a mount option.&n;&t; * We use smaller I/O sizes when the file system&n;&t; * is being used for NFS service (wsync mount option).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_DFLT_IOSIZE
)paren
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|readio_log
op_assign
id|XFS_WSYNC_READIO_LOG
suffix:semicolon
id|writeio_log
op_assign
id|XFS_WSYNC_WRITEIO_LOG
suffix:semicolon
)brace
r_else
(brace
id|readio_log
op_assign
id|XFS_READIO_LOG_LARGE
suffix:semicolon
id|writeio_log
op_assign
id|XFS_WRITEIO_LOG_LARGE
suffix:semicolon
)brace
)brace
r_else
(brace
id|readio_log
op_assign
id|mp-&gt;m_readio_log
suffix:semicolon
id|writeio_log
op_assign
id|mp-&gt;m_writeio_log
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set the number of readahead buffers to use based on&n;&t; * physical memory size.&n;&t; */
r_if
c_cond
(paren
id|xfs_physmem
op_le
l_int|4096
)paren
multiline_comment|/* &lt;= 16MB */
id|mp-&gt;m_nreadaheads
op_assign
id|XFS_RW_NREADAHEAD_16MB
suffix:semicolon
r_else
r_if
c_cond
(paren
id|xfs_physmem
op_le
l_int|8192
)paren
multiline_comment|/* &lt;= 32MB */
id|mp-&gt;m_nreadaheads
op_assign
id|XFS_RW_NREADAHEAD_32MB
suffix:semicolon
r_else
id|mp-&gt;m_nreadaheads
op_assign
id|XFS_RW_NREADAHEAD_K32
suffix:semicolon
r_if
c_cond
(paren
id|sbp-&gt;sb_blocklog
OG
id|readio_log
)paren
(brace
id|mp-&gt;m_readio_log
op_assign
id|sbp-&gt;sb_blocklog
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;m_readio_log
op_assign
id|readio_log
suffix:semicolon
)brace
id|mp-&gt;m_readio_blocks
op_assign
l_int|1
op_lshift
(paren
id|mp-&gt;m_readio_log
op_minus
id|sbp-&gt;sb_blocklog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbp-&gt;sb_blocklog
OG
id|writeio_log
)paren
(brace
id|mp-&gt;m_writeio_log
op_assign
id|sbp-&gt;sb_blocklog
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;m_writeio_log
op_assign
id|writeio_log
suffix:semicolon
)brace
id|mp-&gt;m_writeio_blocks
op_assign
l_int|1
op_lshift
(paren
id|mp-&gt;m_writeio_log
op_minus
id|sbp-&gt;sb_blocklog
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the inode cluster size based on the physical memory&n;&t; * size.  This may still be overridden by the file system&n;&t; * block size if it is larger than the chosen cluster size.&n;&t; */
r_if
c_cond
(paren
id|xfs_physmem
op_le
id|btoc
c_func
(paren
l_int|32
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
(brace
multiline_comment|/* &lt;= 32 MB */
id|mp-&gt;m_inode_cluster_size
op_assign
id|XFS_INODE_SMALL_CLUSTER_SIZE
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;m_inode_cluster_size
op_assign
id|XFS_INODE_BIG_CLUSTER_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set whether we&squot;re using inode alignment.&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASALIGN
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
op_logical_and
id|mp-&gt;m_sb.sb_inoalignmt
op_ge
id|XFS_B_TO_FSBT
c_func
(paren
id|mp
comma
id|mp-&gt;m_inode_cluster_size
)paren
)paren
id|mp-&gt;m_inoalign_mask
op_assign
id|mp-&gt;m_sb.sb_inoalignmt
op_minus
l_int|1
suffix:semicolon
r_else
id|mp-&gt;m_inoalign_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If we are using stripe alignment, check whether&n;&t; * the stripe unit is a multiple of the inode alignment&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_dalign
op_logical_and
id|mp-&gt;m_inoalign_mask
op_logical_and
op_logical_neg
(paren
id|mp-&gt;m_dalign
op_amp
id|mp-&gt;m_inoalign_mask
)paren
)paren
id|mp-&gt;m_sinoalign
op_assign
id|mp-&gt;m_dalign
suffix:semicolon
r_else
id|mp-&gt;m_sinoalign
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Check that the data (and log if separate) are an ok size.&n;&t; */
id|d
op_assign
(paren
id|xfs_daddr_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_sb.sb_dblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|d
)paren
op_ne
id|mp-&gt;m_sb.sb_dblocks
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: size check 1 failed&quot;
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|E2BIG
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|error
op_assign
id|xfs_read_buf
c_func
(paren
id|mp
comma
id|mp-&gt;m_ddev_targp
comma
id|d
op_minus
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: size check 2 failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|E2BIG
)paren
suffix:semicolon
)brace
r_goto
id|error1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|mfsi_flags
op_amp
id|XFS_MFSI_CLIENT
)paren
op_eq
l_int|0
)paren
op_logical_and
id|mp-&gt;m_logdev_targp
op_ne
id|mp-&gt;m_ddev_targp
)paren
(brace
id|d
op_assign
(paren
id|xfs_daddr_t
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_sb.sb_logblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_BB_TO_FSB
c_func
(paren
id|mp
comma
id|d
)paren
op_ne
id|mp-&gt;m_sb.sb_logblocks
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: size check 3 failed&quot;
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|E2BIG
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
id|error
op_assign
id|xfs_read_buf
c_func
(paren
id|mp
comma
id|mp-&gt;m_logdev_targp
comma
id|d
op_minus
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: size check 3 failed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|E2BIG
)paren
suffix:semicolon
)brace
r_goto
id|error1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Initialize realtime fields in the mount structure&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_rtmount_init
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: RT mount failed&quot;
)paren
suffix:semicolon
r_goto
id|error1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For client case we are done now&n;&t; */
r_if
c_cond
(paren
id|mfsi_flags
op_amp
id|XFS_MFSI_CLIENT
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Copies the low order bits of the timestamp and the randomly&n;&t; *  set &quot;sequence&quot; number out of a UUID.&n;&t; */
id|uuid_getnodeuniq
c_func
(paren
op_amp
id|sbp-&gt;sb_uuid
comma
id|mp-&gt;m_fixedfsid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  The vfs structure needs to have a file system independent&n;&t; *  way of checking for the invariant file system ID.  Since it&n;&t; *  can&squot;t look at mount structures it has a pointer to the data&n;&t; *  in the mount structure.&n;&t; *&n;&t; *  File systems that don&squot;t support user level file handles (i.e.&n;&t; *  all of them except for XFS) will leave vfs_altfsid as NULL.&n;&t; */
id|vfsp-&gt;vfs_altfsid
op_assign
(paren
id|xfs_fsid_t
op_star
)paren
id|mp-&gt;m_fixedfsid
suffix:semicolon
id|mp-&gt;m_dmevmask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not persistent; set after each mount */
multiline_comment|/*&n;&t; * Select the right directory manager.&n;&t; */
id|mp-&gt;m_dirops
op_assign
id|XFS_SB_VERSION_HASDIRV2
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
ques
c_cond
id|xfsv2_dirops
suffix:colon
id|xfsv1_dirops
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize directory manager&squot;s entries.&n;&t; */
id|XFS_DIR_MOUNT
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the attribute manager&squot;s entries.&n;&t; */
id|mp-&gt;m_attr_magicpct
op_assign
(paren
id|mp-&gt;m_sb.sb_blocksize
op_star
l_int|37
)paren
op_div
l_int|100
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the precomputed transaction reservations values.&n;&t; */
id|xfs_trans_init
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the inode hash table for this&n;&t; * file system.&n;&t; */
id|xfs_ihash_init
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_chash_init
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize the per-ag data.&n;&t; */
id|init_rwsem
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|mp-&gt;m_perag
op_assign
id|kmem_zalloc
c_func
(paren
id|sbp-&gt;sb_agcount
op_star
r_sizeof
(paren
id|xfs_perag_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|xfs_initialize_perag
c_func
(paren
id|mp
comma
id|sbp-&gt;sb_agcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * log&squot;s mount-time initialization. Perform 1st part recovery if needed&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|sbp-&gt;sb_logblocks
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/* check for volume case */
id|error
op_assign
id|xfs_log_mount
c_func
(paren
id|mp
comma
id|mp-&gt;m_logdev_targp
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|sbp-&gt;sb_logstart
)paren
comma
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|sbp-&gt;sb_logblocks
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: log mount failed&quot;
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* No log has been defined */
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: no log defined&quot;
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_mountfs_int(1)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|error2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get and sanity-check the root inode.&n;&t; * Save the pointer to it in the mount structure.&n;&t; */
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|sbp-&gt;sb_rootino
comma
id|XFS_ILOCK_EXCL
comma
op_amp
id|rip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: failed to read root inode&quot;
)paren
suffix:semicolon
r_goto
id|error3
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|rip
op_ne
l_int|NULL
)paren
suffix:semicolon
id|rvp
op_assign
id|XFS_ITOV
c_func
(paren
id|rip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|rip-&gt;i_d.di_mode
op_amp
id|S_IFMT
)paren
op_ne
id|S_IFDIR
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: corrupted root inode&quot;
)paren
suffix:semicolon
id|prdev
c_func
(paren
l_string|&quot;Root inode %llu is not a directory&quot;
comma
id|mp-&gt;m_ddev_targp
comma
(paren
r_int
r_int
r_int
)paren
id|rip-&gt;i_ino
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|XFS_ERROR_REPORT
c_func
(paren
l_string|&quot;xfs_mountfs_int(2)&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_goto
id|error4
suffix:semicolon
)brace
id|mp-&gt;m_rootip
op_assign
id|rip
suffix:semicolon
multiline_comment|/* save it */
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize realtime inode pointers in the mount structure&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_rtmount_inodes
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Free up the root inode.&n;&t;&t; */
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: failed to read RT inodes&quot;
)paren
suffix:semicolon
r_goto
id|error4
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If fs is not mounted readonly, then update the superblock&n;&t; * unit and width changes.&n;&t; */
r_if
c_cond
(paren
id|update_flags
op_logical_and
op_logical_neg
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
)paren
id|xfs_mount_log_sbunit
c_func
(paren
id|mp
comma
id|update_flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialise the XFS quota management subsystem for this mount&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_INIT
c_func
(paren
id|mp
comma
op_amp
id|quotamount
comma
op_amp
id|quotaflags
)paren
)paren
)paren
r_goto
id|error4
suffix:semicolon
multiline_comment|/*&n;&t; * Finish recovering the file system.  This part needed to be&n;&t; * delayed until after the root and real-time bitmap inodes&n;&t; * were consistently read in.&n;&t; */
id|error
op_assign
id|xfs_log_mount_finish
c_func
(paren
id|mp
comma
id|mfsi_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: log mount finish failed&quot;
)paren
suffix:semicolon
r_goto
id|error4
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Complete the quota initialisation, post-log-replay component.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_QM_MOUNT
c_func
(paren
id|mp
comma
id|quotamount
comma
id|quotaflags
)paren
)paren
)paren
r_goto
id|error4
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error4
suffix:colon
multiline_comment|/*&n;&t; * Free up the root inode.&n;&t; */
id|VN_RELE
c_func
(paren
id|rvp
)paren
suffix:semicolon
id|error3
suffix:colon
id|xfs_log_unmount_dealloc
c_func
(paren
id|mp
)paren
suffix:semicolon
id|error2
suffix:colon
id|xfs_ihash_free
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_chash_free
c_func
(paren
id|mp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|agno
op_assign
l_int|0
suffix:semicolon
id|agno
OL
id|sbp-&gt;sb_agcount
suffix:semicolon
id|agno
op_increment
)paren
r_if
c_cond
(paren
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
)paren
id|kmem_free
c_func
(paren
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
comma
r_sizeof
(paren
id|xfs_perag_busy_t
)paren
op_star
id|XFS_PAGB_NUM_SLOTS
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|mp-&gt;m_perag
comma
id|sbp-&gt;sb_agcount
op_star
r_sizeof
(paren
id|xfs_perag_t
)paren
)paren
suffix:semicolon
id|mp-&gt;m_perag
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
id|error1
suffix:colon
r_if
c_cond
(paren
id|uuid_mounted
)paren
id|xfs_uuid_unmount
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_freesb
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_unmountfs&n; *&n; * This flushes out the inodes,dquots and the superblock, unmounts the&n; * log and makes sure that incore structures are freed.&n; */
r_int
DECL|function|xfs_unmountfs
id|xfs_unmountfs
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_struct
id|cred
op_star
id|cr
)paren
(brace
r_struct
id|vfs
op_star
id|vfsp
op_assign
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(INDUCE_IO_ERROR)
r_int64
id|fsid
suffix:semicolon
macro_line|#endif
id|xfs_iflush_all
c_func
(paren
id|mp
comma
id|XFS_FLUSH_ALL
)paren
suffix:semicolon
id|XFS_QM_DQPURGEALL
c_func
(paren
id|mp
comma
id|XFS_QMOPT_UQUOTA
op_or
id|XFS_QMOPT_GQUOTA
op_or
id|XFS_QMOPT_UMOUNTING
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush out the log synchronously so that we know for sure&n;&t; * that nothing is pinned.  This is important because bflush()&n;&t; * will skip pinned buffers.&n;&t; */
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|xfs_binval
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rtdev_targp
)paren
(brace
id|xfs_binval
c_func
(paren
id|mp-&gt;m_rtdev_targp
)paren
suffix:semicolon
)brace
id|xfs_unmountfs_writesb
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_log_unmount
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* Done! No more fs ops. */
id|xfs_freesb
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * All inodes from this mount point should be freed.&n;&t; */
id|ASSERT
c_func
(paren
id|mp-&gt;m_inodes
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We may have bufs that are in the process of getting written still.&n;&t; * We must wait for the I/O completion of those. The sync flag here&n;&t; * does a two pass iteration thru the bufcache.&n;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_incore_relse
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* synchronous */
)brace
id|xfs_unmountfs_close
c_func
(paren
id|mp
comma
id|cr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NOUUID
)paren
op_eq
l_int|0
)paren
id|xfs_uuid_unmount
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(INDUCE_IO_ERROR)
multiline_comment|/*&n;&t; * clear all error tags on this filesystem&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|fsid
comma
op_amp
id|vfsp-&gt;vfs_fsid
comma
r_sizeof
(paren
r_int64
)paren
)paren
suffix:semicolon
id|xfs_errortag_clearall_umount
c_func
(paren
id|fsid
comma
id|mp-&gt;m_fsname
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|XFS_IODONE
c_func
(paren
id|vfsp
)paren
suffix:semicolon
id|xfs_mount_free
c_func
(paren
id|mp
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xfs_unmountfs_close
id|xfs_unmountfs_close
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_struct
id|cred
op_star
id|cr
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_logdev_targp
op_ne
id|mp-&gt;m_ddev_targp
)paren
id|xfs_free_buftarg
c_func
(paren
id|mp-&gt;m_logdev_targp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rtdev_targp
)paren
id|xfs_free_buftarg
c_func
(paren
id|mp-&gt;m_rtdev_targp
comma
l_int|1
)paren
suffix:semicolon
id|xfs_free_buftarg
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_unmountfs_writesb
id|xfs_unmountfs_writesb
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_buf_t
op_star
id|sbp
suffix:semicolon
id|xfs_sb_t
op_star
id|sb
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * skip superblock write if fs is read-only, or&n;&t; * if we are doing a forced umount.&n;&t; */
id|sbp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
op_member_access_from_pointer
id|vfs_flag
op_amp
id|VFS_RDONLY
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * mark shared-readonly if desired&n;&t;&t; */
id|sb
op_assign
id|XFS_BUF_TO_SBP
c_func
(paren
id|sbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_mk_sharedro
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb-&gt;sb_flags
op_amp
id|XFS_SBF_READONLY
)paren
)paren
id|sb-&gt;sb_flags
op_or_assign
id|XFS_SBF_READONLY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASSHARED
c_func
(paren
id|sb
)paren
)paren
id|XFS_SB_VERSION_ADDSHARED
c_func
(paren
id|sb
)paren
suffix:semicolon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_NOTE
comma
id|mp
comma
l_string|&quot;Unmounting, marking shared read-only&quot;
)paren
suffix:semicolon
)brace
id|XFS_BUF_UNDONE
c_func
(paren
id|sbp
)paren
suffix:semicolon
id|XFS_BUF_UNREAD
c_func
(paren
id|sbp
)paren
suffix:semicolon
id|XFS_BUF_UNDELAYWRITE
c_func
(paren
id|sbp
)paren
suffix:semicolon
id|XFS_BUF_WRITE
c_func
(paren
id|sbp
)paren
suffix:semicolon
id|XFS_BUF_UNASYNC
c_func
(paren
id|sbp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_TARGET
c_func
(paren
id|sbp
)paren
op_eq
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|xfsbdstrat
c_func
(paren
id|mp
comma
id|sbp
)paren
suffix:semicolon
multiline_comment|/* Nevermind errors we might get here. */
id|error
op_assign
id|xfs_iowait
c_func
(paren
id|sbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xfs_unmountfs_writesb&quot;
comma
id|mp
comma
id|sbp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|sbp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_and
id|mp-&gt;m_mk_sharedro
)paren
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;Superblock write error detected while unmounting.  Filesystem may not be marked shared readonly&quot;
)paren
suffix:semicolon
)brace
id|xfs_buf_relse
c_func
(paren
id|sbp
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mod_sb() can be used to copy arbitrary changes to the&n; * in-core superblock into the superblock buffer to be logged.&n; * It does not provide the higher level of locking that is&n; * needed to protect the in-core superblock from concurrent&n; * access.&n; */
r_void
DECL|function|xfs_mod_sb
id|xfs_mod_sb
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|__int64_t
id|fields
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|first
suffix:semicolon
r_int
id|last
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
id|xfs_sb_field_t
id|f
suffix:semicolon
id|ASSERT
c_func
(paren
id|fields
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fields
)paren
r_return
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|bp
op_assign
id|xfs_trans_getsb
c_func
(paren
id|tp
comma
id|mp
comma
l_int|0
)paren
suffix:semicolon
id|sbp
op_assign
id|XFS_BUF_TO_SBP
c_func
(paren
id|bp
)paren
suffix:semicolon
id|first
op_assign
r_sizeof
(paren
id|xfs_sb_t
)paren
suffix:semicolon
id|last
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* translate/copy */
id|xfs_xlatesb
c_func
(paren
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
comma
op_amp
(paren
id|mp-&gt;m_sb
)paren
comma
op_minus
l_int|1
comma
id|ARCH_CONVERT
comma
id|fields
)paren
suffix:semicolon
multiline_comment|/* find modified range */
id|f
op_assign
(paren
id|xfs_sb_field_t
)paren
id|xfs_lowbit64
c_func
(paren
(paren
id|__uint64_t
)paren
id|fields
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
l_int|1LL
op_lshift
id|f
)paren
op_amp
id|XFS_SB_MOD_BITS
)paren
suffix:semicolon
id|first
op_assign
id|xfs_sb_info
(braket
id|f
)braket
dot
id|offset
suffix:semicolon
id|f
op_assign
(paren
id|xfs_sb_field_t
)paren
id|xfs_highbit64
c_func
(paren
(paren
id|__uint64_t
)paren
id|fields
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
l_int|1LL
op_lshift
id|f
)paren
op_amp
id|XFS_SB_MOD_BITS
)paren
suffix:semicolon
id|last
op_assign
id|xfs_sb_info
(braket
id|f
op_plus
l_int|1
)braket
dot
id|offset
op_minus
l_int|1
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mod_incore_sb_unlocked() is a utility routine common used to apply&n; * a delta to a specified field in the in-core superblock.  Simply&n; * switch on the field indicated and apply the delta to that field.&n; * Fields are not allowed to dip below zero, so if the delta would&n; * do this do not apply it and return EINVAL.&n; *&n; * The SB_LOCK must be held when this routine is called.&n; */
id|STATIC
r_int
DECL|function|xfs_mod_incore_sb_unlocked
id|xfs_mod_incore_sb_unlocked
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_sb_field_t
id|field
comma
r_int
id|delta
comma
r_int
id|rsvd
)paren
(brace
r_int
id|scounter
suffix:semicolon
multiline_comment|/* short counter for 32 bit fields */
r_int
r_int
id|lcounter
suffix:semicolon
multiline_comment|/* long counter for 64 bit fields */
r_int
r_int
id|res_used
comma
id|rem
suffix:semicolon
multiline_comment|/*&n;&t; * With the in-core superblock spin lock held, switch&n;&t; * on the indicated field.  Apply the delta to the&n;&t; * proper field.  If the fields value would dip below&n;&t; * 0, then do not apply the delta and return EINVAL.&n;&t; */
r_switch
c_cond
(paren
id|field
)paren
(brace
r_case
id|XFS_SBS_ICOUNT
suffix:colon
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_icount
suffix:semicolon
id|lcounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_icount
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_IFREE
suffix:colon
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_ifree
suffix:semicolon
id|lcounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_ifree
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_FDBLOCKS
suffix:colon
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_fdblocks
suffix:semicolon
id|res_used
op_assign
(paren
r_int
r_int
)paren
(paren
id|mp-&gt;m_resblks
op_minus
id|mp-&gt;m_resblks_avail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
l_int|0
)paren
(brace
multiline_comment|/* Putting blocks back */
r_if
c_cond
(paren
id|res_used
OG
id|delta
)paren
(brace
id|mp-&gt;m_resblks_avail
op_add_assign
id|delta
suffix:semicolon
)brace
r_else
(brace
id|rem
op_assign
id|delta
op_minus
id|res_used
suffix:semicolon
id|mp-&gt;m_resblks_avail
op_assign
id|mp-&gt;m_resblks
suffix:semicolon
id|lcounter
op_add_assign
id|rem
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Taking blocks away */
id|lcounter
op_add_assign
id|delta
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If were out of blocks, use any available reserved blocks if&n;&t;&t; * were allowed to.&n;&t;&t; */
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|rsvd
)paren
(brace
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_resblks_avail
op_plus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_resblks_avail
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* not reserved */
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|mp-&gt;m_sb.sb_fdblocks
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_FREXTENTS
suffix:colon
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_frextents
suffix:semicolon
id|lcounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_frextents
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_DBLOCKS
suffix:colon
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_dblocks
suffix:semicolon
id|lcounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_dblocks
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_AGCOUNT
suffix:colon
id|scounter
op_assign
id|mp-&gt;m_sb.sb_agcount
suffix:semicolon
id|scounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|scounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_agcount
op_assign
id|scounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_IMAX_PCT
suffix:colon
id|scounter
op_assign
id|mp-&gt;m_sb.sb_imax_pct
suffix:semicolon
id|scounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|scounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_imax_pct
op_assign
id|scounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_REXTSIZE
suffix:colon
id|scounter
op_assign
id|mp-&gt;m_sb.sb_rextsize
suffix:semicolon
id|scounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|scounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_rextsize
op_assign
id|scounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_RBMBLOCKS
suffix:colon
id|scounter
op_assign
id|mp-&gt;m_sb.sb_rbmblocks
suffix:semicolon
id|scounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|scounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_rbmblocks
op_assign
id|scounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_RBLOCKS
suffix:colon
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_rblocks
suffix:semicolon
id|lcounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_rblocks
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_REXTENTS
suffix:colon
id|lcounter
op_assign
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_rextents
suffix:semicolon
id|lcounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|lcounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_rextents
op_assign
id|lcounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|XFS_SBS_REXTSLOG
suffix:colon
id|scounter
op_assign
id|mp-&gt;m_sb.sb_rextslog
suffix:semicolon
id|scounter
op_add_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|scounter
OL
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
id|mp-&gt;m_sb.sb_rextslog
op_assign
id|scounter
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * xfs_mod_incore_sb() is used to change a field in the in-core&n; * superblock structure by the specified delta.  This modification&n; * is protected by the SB_LOCK.  Just use the xfs_mod_incore_sb_unlocked()&n; * routine to do the work.&n; */
r_int
DECL|function|xfs_mod_incore_sb
id|xfs_mod_incore_sb
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_sb_field_t
id|field
comma
r_int
id|delta
comma
r_int
id|rsvd
)paren
(brace
r_int
r_int
id|s
suffix:semicolon
r_int
id|status
suffix:semicolon
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|status
op_assign
id|xfs_mod_incore_sb_unlocked
c_func
(paren
id|mp
comma
id|field
comma
id|delta
comma
id|rsvd
)paren
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mod_incore_sb_batch() is used to change more than one field&n; * in the in-core superblock structure at a time.  This modification&n; * is protected by a lock internal to this module.  The fields and&n; * changes to those fields are specified in the array of xfs_mod_sb&n; * structures passed in.&n; *&n; * Either all of the specified deltas will be applied or none of&n; * them will.  If any modified field dips below 0, then all modifications&n; * will be backed out and EINVAL will be returned.&n; */
r_int
DECL|function|xfs_mod_incore_sb_batch
id|xfs_mod_incore_sb_batch
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_mod_sb_t
op_star
id|msb
comma
id|uint
id|nmsb
comma
r_int
id|rsvd
)paren
(brace
r_int
r_int
id|s
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|xfs_mod_sb_t
op_star
id|msbp
suffix:semicolon
multiline_comment|/*&n;&t; * Loop through the array of mod structures and apply each&n;&t; * individually.  If any fail, then back out all those&n;&t; * which have already been applied.  Do all of this within&n;&t; * the scope of the SB_LOCK so that all of the changes will&n;&t; * be atomic.&n;&t; */
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|msbp
op_assign
op_amp
id|msb
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|msbp
op_assign
op_amp
id|msbp
(braket
l_int|0
)braket
suffix:semicolon
id|msbp
OL
(paren
id|msb
op_plus
id|nmsb
)paren
suffix:semicolon
id|msbp
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Apply the delta at index n.  If it fails, break&n;&t;&t; * from the loop so we&squot;ll fall into the undo loop&n;&t;&t; * below.&n;&t;&t; */
id|status
op_assign
id|xfs_mod_incore_sb_unlocked
c_func
(paren
id|mp
comma
id|msbp-&gt;msb_field
comma
id|msbp-&gt;msb_delta
comma
id|rsvd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we didn&squot;t complete the loop above, then back out&n;&t; * any changes made to the superblock.  If you add code&n;&t; * between the loop above and here, make sure that you&n;&t; * preserve the value of status. Loop back until&n;&t; * we step below the beginning of the array.  Make sure&n;&t; * we don&squot;t touch anything back there.&n;&t; */
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|msbp
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|msbp
op_ge
id|msb
)paren
(brace
id|status
op_assign
id|xfs_mod_incore_sb_unlocked
c_func
(paren
id|mp
comma
id|msbp-&gt;msb_field
comma
op_minus
(paren
id|msbp-&gt;msb_delta
)paren
comma
id|rsvd
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|status
op_eq
l_int|0
)paren
suffix:semicolon
id|msbp
op_decrement
suffix:semicolon
)brace
)brace
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_getsb() is called to obtain the buffer for the superblock.&n; * The buffer is returned locked and read in from disk.&n; * The buffer should be released with a call to xfs_brelse().&n; *&n; * If the flags parameter is BUF_TRYLOCK, then we&squot;ll only return&n; * the superblock buffer if it can be locked without sleeping.&n; * If it can&squot;t then we&squot;ll return NULL.&n; */
id|xfs_buf_t
op_star
DECL|function|xfs_getsb
id|xfs_getsb
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|flags
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_sb_bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bp
op_assign
id|mp-&gt;m_sb_bp
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_BUF_TRYLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_BUF_CPSEMA
c_func
(paren
id|bp
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
id|XFS_BUF_PSEMA
c_func
(paren
id|bp
comma
id|PRIBIO
)paren
suffix:semicolon
)brace
id|XFS_BUF_HOLD
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISDONE
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_return
(paren
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used to free the superblock along various error paths.&n; */
r_void
DECL|function|xfs_freesb
id|xfs_freesb
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * Use xfs_getsb() so that the buffer will be locked&n;&t; * when we call xfs_buf_relse().&n;&t; */
id|bp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
id|XFS_BUF_UNMANAGE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
id|mp-&gt;m_sb_bp
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * See if the UUID is unique among mounted XFS filesystems.&n; * Mount fails if UUID is nil or a FS with the same UUID is already mounted.&n; */
id|STATIC
r_int
DECL|function|xfs_uuid_mount
id|xfs_uuid_mount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
r_if
c_cond
(paren
id|uuid_is_nil
c_func
(paren
op_amp
id|mp-&gt;m_sb.sb_uuid
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: Filesystem %s has nil UUID - can&squot;t mount&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|uuid_table_insert
c_func
(paren
op_amp
id|mp-&gt;m_sb.sb_uuid
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: Filesystem %s has duplicate UUID - can&squot;t mount&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove filesystem from the UUID table.&n; */
id|STATIC
r_void
DECL|function|xfs_uuid_unmount
id|xfs_uuid_unmount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|uuid_table_remove
c_func
(paren
op_amp
id|mp-&gt;m_sb.sb_uuid
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Used to log changes to the superblock unit and width fields which could&n; * be altered by the mount options. Only the first superblock is updated.&n; */
id|STATIC
r_void
DECL|function|xfs_mount_log_sbunit
id|xfs_mount_log_sbunit
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|__int64_t
id|fields
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|ASSERT
c_func
(paren
id|fields
op_amp
(paren
id|XFS_SB_UNIT
op_or
id|XFS_SB_WIDTH
op_or
id|XFS_SB_UUID
)paren
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_SB_UNIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|mp-&gt;m_sb.sb_sectsize
op_plus
l_int|128
comma
l_int|0
comma
l_int|0
comma
id|XFS_DEFAULT_LOG_COUNT
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|xfs_mod_sb
c_func
(paren
id|tp
comma
id|fields
)paren
suffix:semicolon
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
eof
