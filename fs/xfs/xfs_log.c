multiline_comment|/*&n; * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * High level interface routines for log manager&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_log_priv.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_log_recover.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_trans_priv.h&quot;
DECL|macro|xlog_write_adv_cnt
mdefine_line|#define xlog_write_adv_cnt(ptr, len, off, bytes) &bslash;&n;&t;{ (ptr) += (bytes); &bslash;&n;&t;  (len) -= (bytes); &bslash;&n;&t;  (off) += (bytes);}
multiline_comment|/* Local miscellaneous function prototypes */
id|STATIC
r_int
id|xlog_bdstrat_cb
c_func
(paren
r_struct
id|xfs_buf
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_commit_record
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_ticket_t
op_star
id|ticket
comma
id|xlog_in_core_t
op_star
op_star
comma
id|xfs_lsn_t
op_star
)paren
suffix:semicolon
id|STATIC
id|xlog_t
op_star
id|xlog_alloc_log
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_buftarg_t
op_star
id|log_target
comma
id|xfs_daddr_t
id|blk_offset
comma
r_int
id|num_bblks
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_space_left
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|cycle
comma
r_int
id|bytes
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_sync
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_unalloc_log
c_func
(paren
id|xlog_t
op_star
id|log
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_write
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_log_iovec_t
id|region
(braket
)braket
comma
r_int
id|nentries
comma
id|xfs_log_ticket_t
id|tic
comma
id|xfs_lsn_t
op_star
id|start_lsn
comma
id|xlog_in_core_t
op_star
op_star
id|commit_iclog
comma
id|uint
id|flags
)paren
suffix:semicolon
multiline_comment|/* local state machine functions */
id|STATIC
r_void
id|xlog_state_done_syncing
c_func
(paren
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_state_do_callback
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|aborted
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_state_get_iclog_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|len
comma
id|xlog_in_core_t
op_star
op_star
id|iclog
comma
id|xlog_ticket_t
op_star
id|ticket
comma
r_int
op_star
id|continued_write
comma
r_int
op_star
id|logoffsetp
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_state_put_ticket
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|tic
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_state_release_iclog
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_state_switch_iclogs
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
id|eventual_size
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_state_sync
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_lsn_t
id|lsn
comma
id|uint
id|flags
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_state_sync_all
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|uint
id|flags
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_state_want_sync
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
suffix:semicolon
multiline_comment|/* local functions to manipulate grant head */
id|STATIC
r_int
id|xlog_grant_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|xtic
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_grant_push_ail
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|need_bytes
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_regrant_reserve_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|ticket
)paren
suffix:semicolon
id|STATIC
r_int
id|xlog_regrant_write_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|ticket
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_ungrant_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|ticket
)paren
suffix:semicolon
multiline_comment|/* local ticket functions */
id|STATIC
r_void
id|xlog_state_ticket_alloc
c_func
(paren
id|xlog_t
op_star
id|log
)paren
suffix:semicolon
id|STATIC
id|xlog_ticket_t
op_star
id|xlog_ticket_get
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|unit_bytes
comma
r_int
id|count
comma
r_char
id|clientid
comma
id|uint
id|flags
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_ticket_put
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|ticket
)paren
suffix:semicolon
multiline_comment|/* local debug functions */
macro_line|#if defined(DEBUG) &amp;&amp; !defined(XLOG_NOLOG)
id|STATIC
r_void
id|xlog_verify_dest_ptr
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|__psint_t
id|ptr
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_verify_disk_cycle_no
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_verify_grant_head
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|equals
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_verify_iclog
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
id|count
comma
id|boolean_t
id|syncing
)paren
suffix:semicolon
id|STATIC
r_void
id|xlog_verify_tail_lsn
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
id|xfs_lsn_t
id|tail_lsn
)paren
suffix:semicolon
macro_line|#else
DECL|macro|xlog_verify_dest_ptr
mdefine_line|#define xlog_verify_dest_ptr(a,b)
DECL|macro|xlog_verify_disk_cycle_no
mdefine_line|#define xlog_verify_disk_cycle_no(a,b)
DECL|macro|xlog_verify_grant_head
mdefine_line|#define xlog_verify_grant_head(a,b)
DECL|macro|xlog_verify_iclog
mdefine_line|#define xlog_verify_iclog(a,b,c,d)
DECL|macro|xlog_verify_tail_lsn
mdefine_line|#define xlog_verify_tail_lsn(a,b,c)
macro_line|#endif
r_int
id|xlog_iclogs_empty
c_func
(paren
id|xlog_t
op_star
id|log
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|variable|xlog_do_error
r_int
id|xlog_do_error
op_assign
l_int|0
suffix:semicolon
DECL|variable|xlog_req_num
r_int
id|xlog_req_num
op_assign
l_int|0
suffix:semicolon
DECL|variable|xlog_error_mod
r_int
id|xlog_error_mod
op_assign
l_int|33
suffix:semicolon
macro_line|#endif
DECL|macro|XLOG_FORCED_SHUTDOWN
mdefine_line|#define XLOG_FORCED_SHUTDOWN(log)&t;(log-&gt;l_flags &amp; XLOG_IO_ERROR)
multiline_comment|/*&n; * 0 =&gt; disable log manager&n; * 1 =&gt; enable log manager&n; * 2 =&gt; enable log manager and log debugging&n; */
macro_line|#if defined(XLOG_NOLOG) || defined(DEBUG)
DECL|variable|xlog_debug
r_int
id|xlog_debug
op_assign
l_int|1
suffix:semicolon
DECL|variable|xlog_target
id|xfs_buftarg_t
op_star
id|xlog_target
suffix:semicolon
macro_line|#endif
macro_line|#if defined(XFS_LOG_TRACE)
r_void
DECL|function|xlog_trace_loggrant
id|xlog_trace_loggrant
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|tic
comma
id|xfs_caddr_t
id|string
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|log-&gt;l_grant_trace
)paren
(brace
id|log-&gt;l_grant_trace
op_assign
id|ktrace_alloc
c_func
(paren
l_int|1024
comma
id|KM_NOSLEEP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|log-&gt;l_grant_trace
)paren
r_return
suffix:semicolon
)brace
id|ktrace_enter
c_func
(paren
id|log-&gt;l_grant_trace
comma
(paren
r_void
op_star
)paren
id|tic
comma
(paren
r_void
op_star
)paren
id|log-&gt;l_reserve_headq
comma
(paren
r_void
op_star
)paren
id|log-&gt;l_write_headq
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|log-&gt;l_grant_reserve_cycle
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|log-&gt;l_grant_reserve_bytes
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|log-&gt;l_grant_write_cycle
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|log-&gt;l_grant_write_bytes
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|log-&gt;l_curr_cycle
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|log-&gt;l_curr_block
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|CYCLE_LSN
c_func
(paren
id|log-&gt;l_tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|BLOCK_LSN
c_func
(paren
id|log-&gt;l_tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|string
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
l_int|13
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
l_int|14
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
l_int|15
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
l_int|16
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|xlog_trace_iclog
id|xlog_trace_iclog
c_func
(paren
id|xlog_in_core_t
op_star
id|iclog
comma
id|uint
id|state
)paren
(brace
id|pid_t
id|pid
suffix:semicolon
id|pid
op_assign
id|current_pid
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iclog-&gt;ic_trace
)paren
id|iclog-&gt;ic_trace
op_assign
id|ktrace_alloc
c_func
(paren
l_int|256
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ktrace_enter
c_func
(paren
id|iclog-&gt;ic_trace
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|state
)paren
comma
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|pid
)paren
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
comma
(paren
r_void
op_star
)paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|xlog_trace_loggrant
mdefine_line|#define&t;xlog_trace_loggrant(log,tic,string)
DECL|macro|xlog_trace_iclog
mdefine_line|#define&t;xlog_trace_iclog(iclog,state)
macro_line|#endif /* XFS_LOG_TRACE */
multiline_comment|/*&n; * NOTES:&n; *&n; *&t;1. currblock field gets updated at startup and after in-core logs&n; *&t;&t;marked as with WANT_SYNC.&n; */
multiline_comment|/*&n; * This routine is called when a user of a log manager ticket is done with&n; * the reservation.  If the ticket was ever used, then a commit record for&n; * the associated transaction is written out as a log operation header with&n; * no data.  The flag XLOG_TIC_INITED is set when the first write occurs with&n; * a given ticket.  If the ticket was one with a permanent reservation, then&n; * a few operations are done differently.  Permanent reservation tickets by&n; * default don&squot;t release the reservation.  They just commit the current&n; * transaction with the belief that the reservation is still needed.  A flag&n; * must be passed in before permanent reservations are actually released.&n; * When these type of tickets are not released, they need to be set into&n; * the inited state again.  By doing this, a start record will be written&n; * out when the next write occurs.&n; */
id|xfs_lsn_t
DECL|function|xfs_log_done
id|xfs_log_done
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_log_ticket_t
id|xtic
comma
r_void
op_star
op_star
id|iclog
comma
id|uint
id|flags
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|xlog_ticket_t
op_star
id|ticket
op_assign
(paren
id|xfs_log_ticket_t
)paren
id|xtic
suffix:semicolon
id|xfs_lsn_t
id|lsn
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
op_logical_and
id|xlog_target
op_eq
id|log-&gt;l_targ
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
op_logical_or
multiline_comment|/*&n;&t;     * If nothing was ever written, don&squot;t write out commit record.&n;&t;     * If we get an error, just continue and give back the log ticket.&n;&t;     */
(paren
(paren
(paren
id|ticket-&gt;t_flags
op_amp
id|XLOG_TIC_INITED
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|xlog_commit_record
c_func
(paren
id|mp
comma
id|ticket
comma
(paren
id|xlog_in_core_t
op_star
op_star
)paren
id|iclog
comma
op_amp
id|lsn
)paren
)paren
)paren
)paren
(brace
id|lsn
op_assign
(paren
id|xfs_lsn_t
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ticket-&gt;t_flags
op_amp
id|XLOG_TIC_PERM_RESERV
)paren
(brace
id|flags
op_or_assign
id|XFS_LOG_REL_PERM_RESERV
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|ticket-&gt;t_flags
op_amp
id|XLOG_TIC_PERM_RESERV
)paren
op_eq
l_int|0
op_logical_or
(paren
id|flags
op_amp
id|XFS_LOG_REL_PERM_RESERV
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Release ticket if not permanent reservation or a specifc&n;&t;&t; * request has been made to release a permanent reservation.&n;&t;&t; */
id|xlog_ungrant_log_space
c_func
(paren
id|log
comma
id|ticket
)paren
suffix:semicolon
id|xlog_state_put_ticket
c_func
(paren
id|log
comma
id|ticket
)paren
suffix:semicolon
)brace
r_else
(brace
id|xlog_regrant_reserve_log_space
c_func
(paren
id|log
comma
id|ticket
)paren
suffix:semicolon
)brace
multiline_comment|/* If this ticket was a permanent reservation and we aren&squot;t&n;&t; * trying to release it, reset the inited flags; so next time&n;&t; * we write, a start record will be written out.&n;&t; */
r_if
c_cond
(paren
(paren
id|ticket-&gt;t_flags
op_amp
id|XLOG_TIC_PERM_RESERV
)paren
op_logical_and
(paren
id|flags
op_amp
id|XFS_LOG_REL_PERM_RESERV
)paren
op_eq
l_int|0
)paren
id|ticket-&gt;t_flags
op_or_assign
id|XLOG_TIC_INITED
suffix:semicolon
r_return
id|lsn
suffix:semicolon
)brace
multiline_comment|/* xfs_log_done */
multiline_comment|/*&n; * Force the in-core log to disk.  If flags == XFS_LOG_SYNC,&n; *&t;the force is done synchronously.&n; *&n; * Asynchronous forces are implemented by setting the WANT_SYNC&n; * bit in the appropriate in-core log and then returning.&n; *&n; * Synchronous forces are implemented with a semaphore.  All callers&n; * to force a given lsn to disk will wait on a semaphore attached to the&n; * specific in-core log.  When given in-core log finally completes its&n; * write to disk, that thread will wake up all threads waiting on the&n; * semaphore.&n; */
r_int
DECL|function|xfs_log_force
id|xfs_log_force
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_lsn_t
id|lsn
comma
id|uint
id|flags
)paren
(brace
r_int
id|rval
suffix:semicolon
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
op_logical_and
id|xlog_target
op_eq
id|log-&gt;l_targ
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|flags
op_amp
id|XFS_LOG_FORCE
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_log_force
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|log-&gt;l_flags
op_amp
id|XLOG_IO_ERROR
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lsn
op_eq
l_int|0
)paren
id|rval
op_assign
id|xlog_state_sync_all
c_func
(paren
id|log
comma
id|flags
)paren
suffix:semicolon
r_else
id|rval
op_assign
id|xlog_state_sync
c_func
(paren
id|log
comma
id|lsn
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|rval
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_return
id|rval
suffix:semicolon
)brace
multiline_comment|/* xfs_log_force */
multiline_comment|/*&n; * Attaches a new iclog I/O completion callback routine during&n; * transaction commit.  If the log is in error state, a non-zero&n; * return code is handed back and the caller is responsible for&n; * executing the callback at an appropriate time.&n; */
r_int
DECL|function|xfs_log_notify
id|xfs_log_notify
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount of partition */
r_void
op_star
id|iclog_hndl
comma
multiline_comment|/* iclog to hang callback off */
id|xfs_log_callback_t
op_star
id|cb
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|xlog_in_core_t
op_star
id|iclog
op_assign
(paren
id|xlog_in_core_t
op_star
)paren
id|iclog_hndl
suffix:semicolon
r_int
id|abortflg
comma
id|spl
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
op_logical_and
id|xlog_target
op_eq
id|log-&gt;l_targ
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|cb-&gt;cb_next
op_assign
l_int|0
suffix:semicolon
id|spl
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|abortflg
op_assign
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|abortflg
)paren
(brace
id|ASSERT_ALWAYS
c_func
(paren
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
)paren
op_logical_or
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_WANT_SYNC
)paren
)paren
suffix:semicolon
id|cb-&gt;cb_next
op_assign
l_int|0
suffix:semicolon
op_star
(paren
id|iclog-&gt;ic_callback_tail
)paren
op_assign
id|cb
suffix:semicolon
id|iclog-&gt;ic_callback_tail
op_assign
op_amp
(paren
id|cb-&gt;cb_next
)paren
suffix:semicolon
)brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|spl
)paren
suffix:semicolon
r_return
id|abortflg
suffix:semicolon
)brace
multiline_comment|/* xfs_log_notify */
r_int
DECL|function|xfs_log_release_iclog
id|xfs_log_release_iclog
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_void
op_star
id|iclog_hndl
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|xlog_in_core_t
op_star
id|iclog
op_assign
(paren
id|xlog_in_core_t
op_star
)paren
id|iclog_hndl
suffix:semicolon
r_if
c_cond
(paren
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
)paren
(brace
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_LOG_IO_ERROR
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  1. Reserve an amount of on-disk log space and return a ticket corresponding&n; *&t;to the reservation.&n; *  2. Potentially, push buffers at tail of log to disk.&n; *&n; * Each reservation is going to reserve extra space for a log record header.&n; * When writes happen to the on-disk log, we don&squot;t subtract the length of the&n; * log record header from any reservation.  By wasting space in each&n; * reservation, we prevent over allocation problems.&n; */
r_int
DECL|function|xfs_log_reserve
id|xfs_log_reserve
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|unit_bytes
comma
r_int
id|cnt
comma
id|xfs_log_ticket_t
op_star
id|ticket
comma
id|__uint8_t
id|client
comma
id|uint
id|flags
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|xlog_ticket_t
op_star
id|internal_ticket
suffix:semicolon
r_int
id|retval
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
op_logical_and
id|xlog_target
op_eq
id|log-&gt;l_targ
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
id|retval
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|client
op_eq
id|XFS_TRANSACTION
op_logical_or
id|client
op_eq
id|XFS_LOG
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|flags
op_amp
id|XFS_LOG_NOSLEEP
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_try_logspace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ticket
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|flags
op_amp
id|XFS_LOG_PERM_RESERV
)paren
suffix:semicolon
id|internal_ticket
op_assign
(paren
id|xlog_ticket_t
op_star
)paren
op_star
id|ticket
suffix:semicolon
id|xlog_grant_push_ail
c_func
(paren
id|mp
comma
id|internal_ticket-&gt;t_unit_res
)paren
suffix:semicolon
id|retval
op_assign
id|xlog_regrant_write_log_space
c_func
(paren
id|log
comma
id|internal_ticket
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* may sleep if need to allocate more tickets */
id|internal_ticket
op_assign
id|xlog_ticket_get
c_func
(paren
id|log
comma
id|unit_bytes
comma
id|cnt
comma
id|client
comma
id|flags
)paren
suffix:semicolon
op_star
id|ticket
op_assign
id|internal_ticket
suffix:semicolon
id|xlog_grant_push_ail
c_func
(paren
id|mp
comma
(paren
id|internal_ticket-&gt;t_unit_res
op_star
id|internal_ticket-&gt;t_cnt
)paren
)paren
suffix:semicolon
id|retval
op_assign
id|xlog_grant_log_space
c_func
(paren
id|log
comma
id|internal_ticket
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* xfs_log_reserve */
multiline_comment|/*&n; * Mount a log filesystem&n; *&n; * mp&t;&t;- ubiquitous xfs mount point structure&n; * log_target&t;- buftarg of on-disk log device&n; * blk_offset&t;- Start block # where block size is 512 bytes (BBSIZE)&n; * num_bblocks&t;- Number of BBSIZE blocks in on-disk log&n; *&n; * Return error or zero.&n; */
r_int
DECL|function|xfs_log_mount
id|xfs_log_mount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_buftarg_t
op_star
id|log_target
comma
id|xfs_daddr_t
id|blk_offset
comma
r_int
id|num_bblks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NORECOVERY
)paren
)paren
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;XFS mounting filesystem %s&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_else
(brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;!Mounting filesystem &bslash;&quot;%s&bslash;&quot; in no-recovery mode.  Filesystem will be inconsistent.&quot;
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
op_member_access_from_pointer
id|vfs_flag
op_amp
id|VFS_RDONLY
)paren
suffix:semicolon
)brace
id|mp-&gt;m_log
op_assign
id|xlog_alloc_log
c_func
(paren
id|mp
comma
id|log_target
comma
id|blk_offset
comma
id|num_bblks
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_NOTE
comma
l_string|&quot;log dev: %s&quot;
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|log_target
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * skip log recovery on a norecovery mount.  pretend it all&n;&t; * just worked.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NORECOVERY
)paren
)paren
(brace
r_int
id|error
suffix:semicolon
id|vfs_t
op_star
id|vfsp
op_assign
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
suffix:semicolon
r_int
id|readonly
op_assign
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readonly
)paren
id|vfsp-&gt;vfs_flag
op_and_assign
op_complement
id|VFS_RDONLY
suffix:semicolon
id|error
op_assign
id|xlog_recover
c_func
(paren
id|mp-&gt;m_log
comma
id|readonly
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readonly
)paren
id|vfsp-&gt;vfs_flag
op_or_assign
id|VFS_RDONLY
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: log mount/recovery failed: error %d&quot;
comma
id|error
)paren
suffix:semicolon
id|xlog_unalloc_log
c_func
(paren
id|mp-&gt;m_log
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/* Normal transactions can now occur */
id|mp-&gt;m_log-&gt;l_flags
op_and_assign
op_complement
id|XLOG_ACTIVE_RECOVERY
suffix:semicolon
multiline_comment|/* End mounting message in xfs_log_mount_finish */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* xfs_log_mount */
multiline_comment|/*&n; * Finish the recovery of the file system.  This is separate from&n; * the xfs_log_mount() call, because it depends on the code in&n; * xfs_mountfs() to read in the root and real-time bitmap inodes&n; * between calling xfs_log_mount() and here.&n; *&n; * mp&t;&t;- ubiquitous xfs mount point structure&n; */
r_int
DECL|function|xfs_log_mount_finish
id|xfs_log_mount_finish
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|mfsi_flags
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NORECOVERY
)paren
)paren
id|error
op_assign
id|xlog_recover_finish
c_func
(paren
id|mp-&gt;m_log
comma
id|mfsi_flags
)paren
suffix:semicolon
r_else
(brace
id|error
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
op_member_access_from_pointer
id|vfs_flag
op_amp
id|VFS_RDONLY
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Unmount processing for the log.&n; */
r_int
DECL|function|xfs_log_unmount
id|xfs_log_unmount
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|xfs_log_unmount_write
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_log_unmount_dealloc
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Final log writes as part of unmount.&n; *&n; * Mark the filesystem clean as unmount happens.  Note that during relocation&n; * this routine needs to be executed as part of source-bag while the&n; * deallocation must not be done until source-end.&n; */
multiline_comment|/*&n; * Unmount record used to have a string &quot;Unmount filesystem--&quot; in the&n; * data section where the &quot;Un&quot; was really a magic number (XLOG_UNMOUNT_TYPE).&n; * We just write the magic number now since that particular field isn&squot;t&n; * currently architecture converted and &quot;nUmount&quot; is a bit foo.&n; * As far as I know, there weren&squot;t any dependencies on the old behaviour.&n; */
r_int
DECL|function|xfs_log_unmount_write
id|xfs_log_unmount_write
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
macro_line|#ifdef DEBUG
id|xlog_in_core_t
op_star
id|first_iclog
suffix:semicolon
macro_line|#endif
id|xfs_log_iovec_t
id|reg
(braket
l_int|1
)braket
suffix:semicolon
id|xfs_log_ticket_t
id|tic
op_assign
l_int|0
suffix:semicolon
id|xfs_lsn_t
id|lsn
suffix:semicolon
r_int
id|error
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* the data section must be 32 bit size aligned */
r_struct
(brace
id|__uint16_t
id|magic
suffix:semicolon
id|__uint16_t
id|pad1
suffix:semicolon
id|__uint32_t
id|pad2
suffix:semicolon
multiline_comment|/* may as well make it 64 bits */
)brace
id|magic
op_assign
(brace
id|XLOG_UNMOUNT_TYPE
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
op_logical_and
id|xlog_target
op_eq
id|log-&gt;l_targ
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Don&squot;t write out unmount record on read-only mounts.&n;&t; * Or, if we are doing a forced umount (typically because of IO errors).&n;&t; */
r_if
c_cond
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
op_member_access_from_pointer
id|vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
l_int|0
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|first_iclog
op_assign
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_ACTIVE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_offset
op_eq
l_int|0
)paren
suffix:semicolon
)brace
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|iclog
op_ne
id|first_iclog
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
)paren
(brace
id|reg
(braket
l_int|0
)braket
dot
id|i_addr
op_assign
(paren
r_void
op_star
)paren
op_amp
id|magic
suffix:semicolon
id|reg
(braket
l_int|0
)braket
dot
id|i_len
op_assign
r_sizeof
(paren
id|magic
)paren
suffix:semicolon
id|error
op_assign
id|xfs_log_reserve
c_func
(paren
id|mp
comma
l_int|600
comma
l_int|1
comma
op_amp
id|tic
comma
id|XFS_LOG
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/* remove inited flag */
(paren
(paren
id|xlog_ticket_t
op_star
)paren
id|tic
)paren
op_member_access_from_pointer
id|t_flags
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xlog_write
c_func
(paren
id|mp
comma
id|reg
comma
l_int|1
comma
id|tic
comma
op_amp
id|lsn
comma
l_int|NULL
comma
id|XLOG_UNMOUNT_TRANS
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * At this point, we&squot;re umounting anyway,&n;&t;&t;&t; * so there&squot;s no point in transitioning log state&n;&t;&t;&t; * to IOERROR. Just continue...&n;&t;&t;&t; */
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_log_unmount: unmount record failed&quot;
)paren
suffix:semicolon
)brace
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
id|iclog-&gt;ic_refcnt
op_increment
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
id|xlog_state_want_sync
c_func
(paren
id|log
comma
id|iclog
)paren
suffix:semicolon
(paren
r_void
)paren
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DIRTY
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
(brace
id|sv_wait
c_func
(paren
op_amp
id|iclog-&gt;ic_forcesema
comma
id|PMEM
comma
op_amp
id|log-&gt;l_icloglock
comma
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tic
)paren
id|xlog_state_put_ticket
c_func
(paren
id|log
comma
id|tic
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re already in forced_shutdown mode, couldn&squot;t&n;&t;&t; * even attempt to write out the unmount transaction.&n;&t;&t; *&n;&t;&t; * Go through the motions of sync&squot;ing and releasing&n;&t;&t; * the iclog, even though no I/O will actually happen,&n;&t;&t; * we need to wait for other log I/O&squot;s that may already&n;&t;&t; * be in progress.  Do this as a separate section of&n;&t;&t; * code so we&squot;ll know if we ever get stuck here that&n;&t;&t; * we&squot;re in this odd situation of trying to unmount&n;&t;&t; * a file system that went into forced_shutdown as&n;&t;&t; * the result of an unmount..&n;&t;&t; */
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
id|iclog-&gt;ic_refcnt
op_increment
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
id|xlog_state_want_sync
c_func
(paren
id|log
comma
id|iclog
)paren
suffix:semicolon
(paren
r_void
)paren
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DIRTY
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_IOERROR
)paren
)paren
(brace
id|sv_wait
c_func
(paren
op_amp
id|iclog-&gt;ic_forcesema
comma
id|PMEM
comma
op_amp
id|log-&gt;l_icloglock
comma
id|s
)paren
suffix:semicolon
)brace
r_else
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* xfs_log_unmount_write */
multiline_comment|/*&n; * Deallocate log structures for unmount/relocation.&n; */
r_void
DECL|function|xfs_log_unmount_dealloc
id|xfs_log_unmount_dealloc
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xlog_unalloc_log
c_func
(paren
id|mp-&gt;m_log
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write region vectors to log.  The write happens using the space reservation&n; * of the ticket (tic).  It is not a requirement that all writes for a given&n; * transaction occur with one call to xfs_log_write().&n; */
r_int
DECL|function|xfs_log_write
id|xfs_log_write
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_log_iovec_t
id|reg
(braket
)braket
comma
r_int
id|nentries
comma
id|xfs_log_ticket_t
id|tic
comma
id|xfs_lsn_t
op_star
id|start_lsn
)paren
(brace
r_int
id|error
suffix:semicolon
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
op_logical_and
id|xlog_target
op_eq
id|log-&gt;l_targ
)paren
(brace
op_star
id|start_lsn
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_write
c_func
(paren
id|mp
comma
id|reg
comma
id|nentries
comma
id|tic
comma
id|start_lsn
comma
l_int|NULL
comma
l_int|0
)paren
)paren
)paren
(brace
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_LOG_IO_ERROR
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* xfs_log_write */
r_void
DECL|function|xfs_log_move_tail
id|xfs_log_move_tail
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_lsn_t
id|tail_lsn
)paren
(brace
id|xlog_ticket_t
op_star
id|tic
suffix:semicolon
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
r_int
id|need_bytes
comma
id|free_bytes
comma
id|cycle
comma
id|bytes
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
r_if
c_cond
(paren
op_logical_neg
id|xlog_debug
op_logical_and
id|xlog_target
op_eq
id|log-&gt;l_targ
)paren
r_return
suffix:semicolon
macro_line|#endif
multiline_comment|/* XXXsup tmp */
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
r_return
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail_lsn
op_eq
l_int|0
)paren
(brace
multiline_comment|/* needed since sync_lsn is 64 bits */
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|tail_lsn
op_assign
id|log-&gt;l_last_sync_lsn
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* Also an invalid lsn.  1 implies that we aren&squot;t passing in a valid&n;&t; * tail_lsn.&n;&t; */
r_if
c_cond
(paren
id|tail_lsn
op_ne
l_int|1
)paren
(brace
id|log-&gt;l_tail_lsn
op_assign
id|tail_lsn
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tic
op_assign
id|log-&gt;l_write_headq
)paren
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|log-&gt;l_flags
op_amp
id|XLOG_ACTIVE_RECOVERY
)paren
id|panic
c_func
(paren
l_string|&quot;Recovery problem&quot;
)paren
suffix:semicolon
macro_line|#endif
id|cycle
op_assign
id|log-&gt;l_grant_write_cycle
suffix:semicolon
id|bytes
op_assign
id|log-&gt;l_grant_write_bytes
suffix:semicolon
id|free_bytes
op_assign
id|xlog_space_left
c_func
(paren
id|log
comma
id|cycle
comma
id|bytes
)paren
suffix:semicolon
r_do
(brace
id|ASSERT
c_func
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_PERM_RESERV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_bytes
OL
id|tic-&gt;t_unit_res
op_logical_and
id|tail_lsn
op_ne
l_int|1
)paren
r_break
suffix:semicolon
id|tail_lsn
op_assign
l_int|0
suffix:semicolon
id|free_bytes
op_sub_assign
id|tic-&gt;t_unit_res
suffix:semicolon
id|sv_signal
c_func
(paren
op_amp
id|tic-&gt;t_sema
)paren
suffix:semicolon
id|tic
op_assign
id|tic-&gt;t_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tic
op_ne
id|log-&gt;l_write_headq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tic
op_assign
id|log-&gt;l_reserve_headq
)paren
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|log-&gt;l_flags
op_amp
id|XLOG_ACTIVE_RECOVERY
)paren
id|panic
c_func
(paren
l_string|&quot;Recovery problem&quot;
)paren
suffix:semicolon
macro_line|#endif
id|cycle
op_assign
id|log-&gt;l_grant_reserve_cycle
suffix:semicolon
id|bytes
op_assign
id|log-&gt;l_grant_reserve_bytes
suffix:semicolon
id|free_bytes
op_assign
id|xlog_space_left
c_func
(paren
id|log
comma
id|cycle
comma
id|bytes
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_PERM_RESERV
)paren
id|need_bytes
op_assign
id|tic-&gt;t_unit_res
op_star
id|tic-&gt;t_cnt
suffix:semicolon
r_else
id|need_bytes
op_assign
id|tic-&gt;t_unit_res
suffix:semicolon
r_if
c_cond
(paren
id|free_bytes
OL
id|need_bytes
op_logical_and
id|tail_lsn
op_ne
l_int|1
)paren
r_break
suffix:semicolon
id|tail_lsn
op_assign
l_int|0
suffix:semicolon
id|free_bytes
op_sub_assign
id|need_bytes
suffix:semicolon
id|sv_signal
c_func
(paren
op_amp
id|tic-&gt;t_sema
)paren
suffix:semicolon
id|tic
op_assign
id|tic-&gt;t_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tic
op_ne
id|log-&gt;l_reserve_headq
)paren
suffix:semicolon
)brace
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* xfs_log_move_tail */
multiline_comment|/*&n; * Determine if we have a transaction that has gone to disk&n; * that needs to be covered. Log activity needs to be idle (no AIL and&n; * nothing in the iclogs). And, we need to be in the right state indicating&n; * something has gone out.&n; */
r_int
DECL|function|xfs_log_need_covered
id|xfs_log_need_covered
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
r_int
id|needed
op_assign
l_int|0
comma
id|gen
suffix:semicolon
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|vfs_t
op_star
id|vfsp
op_assign
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_super-&gt;s_frozen
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
op_logical_or
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|log-&gt;l_covered_state
op_eq
id|XLOG_STATE_COVER_NEED
)paren
op_logical_or
(paren
id|log-&gt;l_covered_state
op_eq
id|XLOG_STATE_COVER_NEED2
)paren
)paren
op_logical_and
op_logical_neg
id|xfs_trans_first_ail
c_func
(paren
id|mp
comma
op_amp
id|gen
)paren
op_logical_and
id|xlog_iclogs_empty
c_func
(paren
id|log
)paren
)paren
(brace
r_if
c_cond
(paren
id|log-&gt;l_covered_state
op_eq
id|XLOG_STATE_COVER_NEED
)paren
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_DONE
suffix:semicolon
r_else
(brace
id|ASSERT
c_func
(paren
id|log-&gt;l_covered_state
op_eq
id|XLOG_STATE_COVER_NEED2
)paren
suffix:semicolon
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_DONE2
suffix:semicolon
)brace
id|needed
op_assign
l_int|1
suffix:semicolon
)brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|needed
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; *&t;local routines&n; *&n; ******************************************************************************&n; */
multiline_comment|/* xfs_trans_tail_ail returns 0 when there is nothing in the list.&n; * The log manager must keep track of the last LR which was committed&n; * to disk.  The lsn of this LR will become the new tail_lsn whenever&n; * xfs_trans_tail_ail returns 0.  If we don&squot;t do this, we run into&n; * the situation where stuff could be written into the log but nothing&n; * was ever in the AIL when asked.  Eventually, we panic since the&n; * tail hits the head.&n; *&n; * We may be holding the log iclog lock upon entering this routine.&n; */
id|xfs_lsn_t
DECL|function|xlog_assign_tail_lsn
id|xlog_assign_tail_lsn
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_lsn_t
id|tail_lsn
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|tail_lsn
op_assign
id|xfs_trans_tail_ail
c_func
(paren
id|mp
)paren
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tail_lsn
op_ne
l_int|0
)paren
(brace
id|log-&gt;l_tail_lsn
op_assign
id|tail_lsn
suffix:semicolon
)brace
r_else
(brace
id|tail_lsn
op_assign
id|log-&gt;l_tail_lsn
op_assign
id|log-&gt;l_last_sync_lsn
suffix:semicolon
)brace
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|tail_lsn
suffix:semicolon
)brace
multiline_comment|/* xlog_assign_tail_lsn */
multiline_comment|/*&n; * Return the space in the log between the tail and the head.  The head&n; * is passed in the cycle/bytes formal parms.  In the special case where&n; * the reserve head has wrapped passed the tail, this calculation is no&n; * longer valid.  In this case, just return 0 which means there is no space&n; * in the log.  This works for all places where this function is called&n; * with the reserve head.  Of course, if the write head were to ever&n; * wrap the tail, we should blow up.  Rather than catch this case here,&n; * we depend on other ASSERTions in other parts of the code.   XXXmiken&n; *&n; * This code also handles the case where the reservation head is behind&n; * the tail.  The details of this case are described below, but the end&n; * result is that we return the size of the log as the amount of space left.&n; */
r_int
DECL|function|xlog_space_left
id|xlog_space_left
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|cycle
comma
r_int
id|bytes
)paren
(brace
r_int
id|free_bytes
suffix:semicolon
r_int
id|tail_bytes
suffix:semicolon
r_int
id|tail_cycle
suffix:semicolon
id|tail_bytes
op_assign
id|BBTOB
c_func
(paren
id|BLOCK_LSN
c_func
(paren
id|log-&gt;l_tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
suffix:semicolon
id|tail_cycle
op_assign
id|CYCLE_LSN
c_func
(paren
id|log-&gt;l_tail_lsn
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tail_cycle
op_eq
id|cycle
)paren
op_logical_and
(paren
id|bytes
op_ge
id|tail_bytes
)paren
)paren
(brace
id|free_bytes
op_assign
id|log-&gt;l_logsize
op_minus
(paren
id|bytes
op_minus
id|tail_bytes
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|tail_cycle
op_plus
l_int|1
)paren
OL
id|cycle
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tail_cycle
OL
id|cycle
)paren
(brace
id|ASSERT
c_func
(paren
id|tail_cycle
op_eq
(paren
id|cycle
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|free_bytes
op_assign
id|tail_bytes
op_minus
id|bytes
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * The reservation head is behind the tail.&n;&t;&t; * This can only happen when the AIL is empty so the tail&n;&t;&t; * is equal to the head and the l_roundoff value in the&n;&t;&t; * log structure is taking up the difference between the&n;&t;&t; * reservation head and the tail.  The bytes accounted for&n;&t;&t; * by the l_roundoff field are temporarily &squot;lost&squot; to the&n;&t;&t; * reservation mechanism, but they are cleaned up when the&n;&t;&t; * log buffers that created them are reused.  These lost&n;&t;&t; * bytes are what allow the reservation head to fall behind&n;&t;&t; * the tail in the case that the log is &squot;empty&squot;.&n;&t;&t; * In this case we just want to return the size of the&n;&t;&t; * log as the amount of space left.&n;&t;&t; */
id|ASSERT
c_func
(paren
(paren
id|tail_cycle
op_eq
(paren
id|cycle
op_plus
l_int|1
)paren
)paren
op_logical_or
(paren
(paren
id|bytes
op_plus
id|log-&gt;l_roundoff
)paren
op_ge
id|tail_bytes
)paren
)paren
suffix:semicolon
id|free_bytes
op_assign
id|log-&gt;l_logsize
suffix:semicolon
)brace
r_return
id|free_bytes
suffix:semicolon
)brace
multiline_comment|/* xlog_space_left */
multiline_comment|/*&n; * Log function which is called when an io completes.&n; *&n; * The log manager needs its own routine, in order to control what&n; * happens with the buffer after the write completes.&n; */
r_void
DECL|function|xlog_iodone
id|xlog_iodone
c_func
(paren
id|xfs_buf_t
op_star
id|bp
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
id|xlog_t
op_star
id|l
suffix:semicolon
r_int
id|aborted
suffix:semicolon
id|iclog
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xlog_in_core_t
op_star
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
r_int
r_int
)paren
op_eq
(paren
r_int
r_int
)paren
l_int|2
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
(paren
r_int
r_int
)paren
l_int|1
)paren
suffix:semicolon
id|aborted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Some versions of cpp barf on the recursive definition of&n;&t; * ic_log -&gt; hic_fields.ic_log and expand ic_log twice when&n;&t; * it is passed through two macros.  Workaround broken cpp.&n;&t; */
id|l
op_assign
id|iclog-&gt;ic_log
suffix:semicolon
multiline_comment|/*&n;&t; * Race to shutdown the filesystem if we see an error.&n;&t; */
r_if
c_cond
(paren
id|XFS_TEST_ERROR
c_func
(paren
(paren
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
comma
id|l-&gt;l_mp
comma
id|XFS_ERRTAG_IODONE_IOERR
comma
id|XFS_RANDOM_IODONE_IOERR
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_iodone&quot;
comma
id|l-&gt;l_mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_force_shutdown
c_func
(paren
id|l-&gt;l_mp
comma
id|XFS_LOG_IO_ERROR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This flag will be propagated to the trans-committed&n;&t;&t; * callback routines to let them know that the log-commit&n;&t;&t; * didn&squot;t succeed.&n;&t;&t; */
id|aborted
op_assign
id|XFS_LI_ABORTED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
(brace
id|aborted
op_assign
id|XFS_LI_ABORTED
suffix:semicolon
)brace
id|xlog_state_done_syncing
c_func
(paren
id|iclog
comma
id|aborted
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_BUF_ISASYNC
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Corresponding psema() will be done in bwrite().  If we don&squot;t&n;&t;&t; * vsema() here, panic.&n;&t;&t; */
id|XFS_BUF_V_IODONESEMA
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* xlog_iodone */
multiline_comment|/*&n; * The bdstrat callback function for log bufs. This gives us a central&n; * place to trap bufs in case we get hit by a log I/O error and need to&n; * shutdown. Actually, in practice, even when we didn&squot;t get a log error,&n; * we transition the iclogs to IOERROR state *after* flushing all existing&n; * iclogs to disk. This is because we don&squot;t want anymore new transactions to be&n; * started or completed afterwards.&n; */
id|STATIC
r_int
DECL|function|xlog_bdstrat_cb
id|xlog_bdstrat_cb
c_func
(paren
r_struct
id|xfs_buf
op_star
id|bp
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
id|iclog
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xlog_in_core_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* note for irix bstrat will need  struct bdevsw passed&n;&t;   * Fix the following macro if the code ever is merged&n;&t;   */
id|XFS_bdstrat
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xfs_buftrace
c_func
(paren
l_string|&quot;XLOG__BDSTRAT IOERROR&quot;
comma
id|bp
)paren
suffix:semicolon
id|XFS_BUF_ERROR
c_func
(paren
id|bp
comma
id|EIO
)paren
suffix:semicolon
id|XFS_BUF_STALE
c_func
(paren
id|bp
)paren
suffix:semicolon
id|xfs_biodone
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
(paren
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Return size of each in-core log record buffer.&n; *&n; * Low memory machines only get 2 16KB buffers.  We don&squot;t want to waste&n; * memory here.  However, all other machines get at least 2 32KB buffers.&n; * The number is hard coded because we don&squot;t care about the minimum&n; * memory size, just 32MB systems.&n; *&n; * If the filesystem blocksize is too large, we may need to choose a&n; * larger size since the directory code currently logs entire blocks.&n; */
id|STATIC
r_void
DECL|function|xlog_get_iclog_buffer_size
id|xlog_get_iclog_buffer_size
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_t
op_star
id|log
)paren
(brace
r_int
id|size
suffix:semicolon
r_int
id|xhdrs
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
multiline_comment|/*&n;&t; * When logbufs == 0, someone has disabled the log from the FSTAB&n;&t; * file.  This is not a documented feature.  We need to set xlog_debug&n;&t; * to zero (this deactivates the log) and set xlog_target to the&n;&t; * appropriate device.  Only one filesystem may be affected as such&n;&t; * since this is just a performance hack to test what we might be able&n;&t; * to get if the log were not present.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_logbufs
op_eq
l_int|0
)paren
(brace
id|xlog_debug
op_assign
l_int|0
suffix:semicolon
id|xlog_target
op_assign
id|log-&gt;l_targ
suffix:semicolon
id|log-&gt;l_iclog_bufs
op_assign
id|XLOG_MIN_ICLOGS
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/*&n;&t;&t; * This is the normal path.  If m_logbufs == -1, then the&n;&t;&t; * admin has chosen to use the system defaults for logbuffers.&n;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_logbufs
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|xfs_physmem
op_le
id|btoc
c_func
(paren
l_int|128
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
(brace
id|log-&gt;l_iclog_bufs
op_assign
id|XLOG_MIN_ICLOGS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|xfs_physmem
op_le
id|btoc
c_func
(paren
l_int|400
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
(brace
id|log-&gt;l_iclog_bufs
op_assign
id|XLOG_MED_ICLOGS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 256K with 32K bufs */
id|log-&gt;l_iclog_bufs
op_assign
id|XLOG_MAX_ICLOGS
suffix:semicolon
)brace
)brace
r_else
id|log-&gt;l_iclog_bufs
op_assign
id|mp-&gt;m_logbufs
suffix:semicolon
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
multiline_comment|/* We are reactivating a filesystem after it was inactive */
r_if
c_cond
(paren
id|log-&gt;l_targ
op_eq
id|xlog_target
)paren
(brace
id|xlog_target
op_assign
l_int|NULL
suffix:semicolon
id|xlog_debug
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * Buffer size passed in from mount system call.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_logbsize
op_ne
op_minus
l_int|1
)paren
(brace
id|size
op_assign
id|log-&gt;l_iclog_size
op_assign
id|mp-&gt;m_logbsize
suffix:semicolon
id|log-&gt;l_iclog_size_log
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
op_ne
l_int|1
)paren
(brace
id|log-&gt;l_iclog_size_log
op_increment
suffix:semicolon
id|size
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
multiline_comment|/* # headers = size / 32K&n;&t;&t;&t; * one header holds cycles from 32K of data&n;&t;&t;&t; */
id|xhdrs
op_assign
id|mp-&gt;m_logbsize
op_div
id|XLOG_HEADER_CYCLE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_logbsize
op_mod
id|XLOG_HEADER_CYCLE_SIZE
)paren
id|xhdrs
op_increment
suffix:semicolon
id|log-&gt;l_iclog_hsize
op_assign
id|xhdrs
op_lshift
id|BBSHIFT
suffix:semicolon
id|log-&gt;l_iclog_heads
op_assign
id|xhdrs
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|mp-&gt;m_logbsize
op_le
id|XLOG_BIG_RECORD_BSIZE
)paren
suffix:semicolon
id|log-&gt;l_iclog_hsize
op_assign
id|BBSIZE
suffix:semicolon
id|log-&gt;l_iclog_heads
op_assign
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Special case machines that have less than 32MB of memory.&n;&t; * All machines with more memory use 32KB buffers.&n;&t; */
r_if
c_cond
(paren
id|xfs_physmem
op_le
id|btoc
c_func
(paren
l_int|32
op_star
l_int|1024
op_star
l_int|1024
)paren
)paren
(brace
multiline_comment|/* Don&squot;t change; min configuration */
id|log-&gt;l_iclog_size
op_assign
id|XLOG_RECORD_BSIZE
suffix:semicolon
multiline_comment|/* 16k */
id|log-&gt;l_iclog_size_log
op_assign
id|XLOG_RECORD_BSHIFT
suffix:semicolon
)brace
r_else
(brace
id|log-&gt;l_iclog_size
op_assign
id|XLOG_BIG_RECORD_BSIZE
suffix:semicolon
multiline_comment|/* 32k */
id|log-&gt;l_iclog_size_log
op_assign
id|XLOG_BIG_RECORD_BSHIFT
suffix:semicolon
)brace
multiline_comment|/* the default log size is 16k or 32k which is one header sector */
id|log-&gt;l_iclog_hsize
op_assign
id|BBSIZE
suffix:semicolon
id|log-&gt;l_iclog_heads
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * For 16KB, we use 3 32KB buffers.  For 32KB block sizes, we use&n;&t; * 4 32KB buffers.  For 64KB block sizes, we use 8 32KB buffers.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_sb.sb_blocksize
op_ge
l_int|16
op_star
l_int|1024
)paren
(brace
id|log-&gt;l_iclog_size
op_assign
id|XLOG_BIG_RECORD_BSIZE
suffix:semicolon
id|log-&gt;l_iclog_size_log
op_assign
id|XLOG_BIG_RECORD_BSHIFT
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_logbufs
op_eq
op_minus
l_int|1
)paren
(brace
r_switch
c_cond
(paren
id|mp-&gt;m_sb.sb_blocksize
)paren
(brace
r_case
l_int|16
op_star
l_int|1024
suffix:colon
multiline_comment|/* 16 KB */
id|log-&gt;l_iclog_bufs
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|32
op_star
l_int|1024
suffix:colon
multiline_comment|/* 32 KB */
id|log-&gt;l_iclog_bufs
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|64
op_star
l_int|1024
suffix:colon
multiline_comment|/* 64 KB */
id|log-&gt;l_iclog_bufs
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|xlog_panic
c_func
(paren
l_string|&quot;XFS: Invalid blocksize&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* xlog_get_iclog_buffer_size */
multiline_comment|/*&n; * This routine initializes some of the log structure for a given mount point.&n; * Its primary purpose is to fill in enough, so recovery can occur.  However,&n; * some other stuff may be filled in too.&n; */
id|STATIC
id|xlog_t
op_star
DECL|function|xlog_alloc_log
id|xlog_alloc_log
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_buftarg_t
op_star
id|log_target
comma
id|xfs_daddr_t
id|blk_offset
comma
r_int
id|num_bblks
)paren
(brace
id|xlog_t
op_star
id|log
suffix:semicolon
id|xlog_rec_header_t
op_star
id|head
suffix:semicolon
id|xlog_in_core_t
op_star
op_star
id|iclogp
suffix:semicolon
id|xlog_in_core_t
op_star
id|iclog
comma
op_star
id|prev_iclog
op_assign
l_int|NULL
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|iclogsize
suffix:semicolon
id|log
op_assign
(paren
id|xlog_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xlog_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|log-&gt;l_mp
op_assign
id|mp
suffix:semicolon
id|log-&gt;l_targ
op_assign
id|log_target
suffix:semicolon
id|log-&gt;l_logsize
op_assign
id|BBTOB
c_func
(paren
id|num_bblks
)paren
suffix:semicolon
id|log-&gt;l_logBBstart
op_assign
id|blk_offset
suffix:semicolon
id|log-&gt;l_logBBsize
op_assign
id|num_bblks
suffix:semicolon
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_IDLE
suffix:semicolon
id|log-&gt;l_flags
op_or_assign
id|XLOG_ACTIVE_RECOVERY
suffix:semicolon
id|log-&gt;l_prev_block
op_assign
op_minus
l_int|1
suffix:semicolon
id|ASSIGN_ANY_LSN
c_func
(paren
id|log-&gt;l_tail_lsn
comma
l_int|1
comma
l_int|0
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
multiline_comment|/* log-&gt;l_tail_lsn = 0x100000000LL; cycle = 1; current block = 0 */
id|log-&gt;l_last_sync_lsn
op_assign
id|log-&gt;l_tail_lsn
suffix:semicolon
id|log-&gt;l_curr_cycle
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 0 is bad since this is initial value */
id|log-&gt;l_grant_reserve_cycle
op_assign
l_int|1
suffix:semicolon
id|log-&gt;l_grant_write_cycle
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASSECTOR
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
id|log-&gt;l_sectbb_log
op_assign
id|mp-&gt;m_sb.sb_logsectlog
op_minus
id|BBSHIFT
suffix:semicolon
id|ASSERT
c_func
(paren
id|log-&gt;l_sectbb_log
op_le
id|mp-&gt;m_sectbb_log
)paren
suffix:semicolon
multiline_comment|/* for larger sector sizes, must have v2 or external log */
id|ASSERT
c_func
(paren
id|log-&gt;l_sectbb_log
op_eq
l_int|0
op_logical_or
id|log-&gt;l_logBBstart
op_eq
l_int|0
op_logical_or
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|mp-&gt;m_sb.sb_logsectlog
op_ge
id|BBSHIFT
)paren
suffix:semicolon
)brace
id|log-&gt;l_sectbb_mask
op_assign
(paren
l_int|1
op_lshift
id|log-&gt;l_sectbb_log
)paren
op_minus
l_int|1
suffix:semicolon
id|xlog_get_iclog_buffer_size
c_func
(paren
id|mp
comma
id|log
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_buf_get_empty
c_func
(paren
id|log-&gt;l_iclog_size
comma
id|mp-&gt;m_logdev_targp
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|bp
comma
id|xlog_iodone
)paren
suffix:semicolon
id|XFS_BUF_SET_BDSTRAT_FUNC
c_func
(paren
id|bp
comma
id|xlog_bdstrat_cb
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
(paren
r_int
r_int
)paren
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|log-&gt;l_xbuf
op_assign
id|bp
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|log-&gt;l_icloglock
comma
l_string|&quot;iclog&quot;
)paren
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|log-&gt;l_grant_lock
comma
l_string|&quot;grhead_iclog&quot;
)paren
suffix:semicolon
id|initnsema
c_func
(paren
op_amp
id|log-&gt;l_flushsema
comma
l_int|0
comma
l_string|&quot;ic-flush&quot;
)paren
suffix:semicolon
id|xlog_state_ticket_alloc
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* wait until after icloglock inited */
multiline_comment|/* log record size must be multiple of BBSIZE; see xlog_rec_header_t */
id|ASSERT
c_func
(paren
(paren
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
op_amp
id|BBMASK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|iclogp
op_assign
op_amp
id|log-&gt;l_iclog
suffix:semicolon
multiline_comment|/*&n;&t; * The amount of memory to allocate for the iclog structure is&n;&t; * rather funky due to the way the structure is defined.  It is&n;&t; * done this way so that we can use different sizes for machines&n;&t; * with different amounts of memory.  See the definition of&n;&t; * xlog_in_core_t in xfs_log_priv.h for details.&n;&t; */
id|iclogsize
op_assign
id|log-&gt;l_iclog_size
suffix:semicolon
id|ASSERT
c_func
(paren
id|log-&gt;l_iclog_size
op_ge
l_int|4096
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|log-&gt;l_iclog_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|iclogp
op_assign
(paren
id|xlog_in_core_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xlog_in_core_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|iclog
op_assign
op_star
id|iclogp
suffix:semicolon
id|iclog-&gt;hic_data
op_assign
(paren
id|xlog_in_core_2_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
id|iclogsize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|iclog-&gt;ic_prev
op_assign
id|prev_iclog
suffix:semicolon
id|prev_iclog
op_assign
id|iclog
suffix:semicolon
id|log-&gt;l_iclog_bak
(braket
id|i
)braket
op_assign
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|iclog-&gt;ic_header
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|iclog-&gt;ic_header
suffix:semicolon
id|memset
c_func
(paren
id|head
comma
l_int|0
comma
r_sizeof
(paren
id|xlog_rec_header_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|head-&gt;h_magicno
comma
id|ARCH_CONVERT
comma
id|XLOG_HEADER_MAGIC_NUM
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|head-&gt;h_version
comma
id|ARCH_CONVERT
comma
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|head-&gt;h_size
comma
id|ARCH_CONVERT
comma
id|log-&gt;l_iclog_size
)paren
suffix:semicolon
multiline_comment|/* new fields */
id|INT_SET
c_func
(paren
id|head-&gt;h_fmt
comma
id|ARCH_CONVERT
comma
id|XLOG_FMT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|head-&gt;h_fs_uuid
comma
op_amp
id|mp-&gt;m_sb.sb_uuid
comma
r_sizeof
(paren
id|uuid_t
)paren
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_buf_get_empty
c_func
(paren
id|log-&gt;l_iclog_size
comma
id|mp-&gt;m_logdev_targp
)paren
suffix:semicolon
id|XFS_BUF_SET_IODONE_FUNC
c_func
(paren
id|bp
comma
id|xlog_iodone
)paren
suffix:semicolon
id|XFS_BUF_SET_BDSTRAT_FUNC
c_func
(paren
id|bp
comma
id|xlog_bdstrat_cb
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
(paren
r_int
r_int
)paren
l_int|1
)paren
suffix:semicolon
id|iclog-&gt;ic_bp
op_assign
id|bp
suffix:semicolon
id|iclog-&gt;ic_size
op_assign
id|XFS_BUF_SIZE
c_func
(paren
id|bp
)paren
op_minus
id|log-&gt;l_iclog_hsize
suffix:semicolon
id|iclog-&gt;ic_state
op_assign
id|XLOG_STATE_ACTIVE
suffix:semicolon
id|iclog-&gt;ic_log
op_assign
id|log
suffix:semicolon
id|iclog-&gt;ic_callback_tail
op_assign
op_amp
(paren
id|iclog-&gt;ic_callback
)paren
suffix:semicolon
id|iclog-&gt;ic_datap
op_assign
(paren
r_char
op_star
)paren
id|iclog-&gt;hic_data
op_plus
id|log-&gt;l_iclog_hsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ISBUSY
c_func
(paren
id|iclog-&gt;ic_bp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_VALUSEMA
c_func
(paren
id|iclog-&gt;ic_bp
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
id|iclog-&gt;ic_forcesema
comma
id|SV_DEFAULT
comma
l_string|&quot;iclog-force&quot;
)paren
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
id|iclog-&gt;ic_writesema
comma
id|SV_DEFAULT
comma
l_string|&quot;iclog-write&quot;
)paren
suffix:semicolon
id|iclogp
op_assign
op_amp
id|iclog-&gt;ic_next
suffix:semicolon
)brace
op_star
id|iclogp
op_assign
id|log-&gt;l_iclog
suffix:semicolon
multiline_comment|/* complete ring */
id|log-&gt;l_iclog-&gt;ic_prev
op_assign
id|prev_iclog
suffix:semicolon
multiline_comment|/* re-write 1st prev ptr */
r_return
id|log
suffix:semicolon
)brace
multiline_comment|/* xlog_alloc_log */
multiline_comment|/*&n; * Write out the commit record of a transaction associated with the given&n; * ticket.  Return the lsn of the commit record.&n; */
id|STATIC
r_int
DECL|function|xlog_commit_record
id|xlog_commit_record
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xlog_ticket_t
op_star
id|ticket
comma
id|xlog_in_core_t
op_star
op_star
id|iclog
comma
id|xfs_lsn_t
op_star
id|commitlsnp
)paren
(brace
r_int
id|error
suffix:semicolon
id|xfs_log_iovec_t
id|reg
(braket
l_int|1
)braket
suffix:semicolon
id|reg
(braket
l_int|0
)braket
dot
id|i_addr
op_assign
l_int|0
suffix:semicolon
id|reg
(braket
l_int|0
)braket
dot
id|i_len
op_assign
l_int|0
suffix:semicolon
id|ASSERT_ALWAYS
c_func
(paren
id|iclog
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_write
c_func
(paren
id|mp
comma
id|reg
comma
l_int|1
comma
id|ticket
comma
id|commitlsnp
comma
id|iclog
comma
id|XLOG_COMMIT_TRANS
)paren
)paren
)paren
(brace
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_LOG_IO_ERROR
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_commit_record */
multiline_comment|/*&n; * Push on the buffer cache code if we ever use more than 75% of the on-disk&n; * log space.  This code pushes on the lsn which would supposedly free up&n; * the 25% which we want to leave free.  We may need to adopt a policy which&n; * pushes on an lsn which is further along in the log once we reach the high&n; * water mark.  In this manner, we would be creating a low water mark.&n; */
r_void
DECL|function|xlog_grant_push_ail
id|xlog_grant_push_ail
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|need_bytes
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
multiline_comment|/* pointer to the log */
id|xfs_lsn_t
id|tail_lsn
suffix:semicolon
multiline_comment|/* lsn of the log tail */
id|xfs_lsn_t
id|threshold_lsn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* lsn we&squot;d like to be at */
r_int
id|free_blocks
suffix:semicolon
multiline_comment|/* free blocks left to write to */
r_int
id|free_bytes
suffix:semicolon
multiline_comment|/* free bytes left to write to */
r_int
id|threshold_block
suffix:semicolon
multiline_comment|/* block in lsn we&squot;d like to be at */
r_int
id|threshold_cycle
suffix:semicolon
multiline_comment|/* lsn cycle we&squot;d like to be at */
r_int
id|free_threshold
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|BTOBB
c_func
(paren
id|need_bytes
)paren
OL
id|log-&gt;l_logBBsize
)paren
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|free_bytes
op_assign
id|xlog_space_left
c_func
(paren
id|log
comma
id|log-&gt;l_grant_reserve_cycle
comma
id|log-&gt;l_grant_reserve_bytes
)paren
suffix:semicolon
id|tail_lsn
op_assign
id|log-&gt;l_tail_lsn
suffix:semicolon
id|free_blocks
op_assign
id|BTOBBT
c_func
(paren
id|free_bytes
)paren
suffix:semicolon
multiline_comment|/*&n;     * Set the threshold for the minimum number of free blocks in the&n;     * log to the maximum of what the caller needs, one quarter of the&n;     * log, and 256 blocks.&n;     */
id|free_threshold
op_assign
id|BTOBB
c_func
(paren
id|need_bytes
)paren
suffix:semicolon
id|free_threshold
op_assign
id|MAX
c_func
(paren
id|free_threshold
comma
(paren
id|log-&gt;l_logBBsize
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
id|free_threshold
op_assign
id|MAX
c_func
(paren
id|free_threshold
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_blocks
OL
id|free_threshold
)paren
(brace
id|threshold_block
op_assign
id|BLOCK_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
op_plus
id|free_threshold
suffix:semicolon
id|threshold_cycle
op_assign
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|threshold_block
op_ge
id|log-&gt;l_logBBsize
)paren
(brace
id|threshold_block
op_sub_assign
id|log-&gt;l_logBBsize
suffix:semicolon
id|threshold_cycle
op_add_assign
l_int|1
suffix:semicolon
)brace
id|ASSIGN_ANY_LSN
c_func
(paren
id|threshold_lsn
comma
id|threshold_cycle
comma
id|threshold_block
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t pass in an lsn greater than the lsn of the last&n;&t; * log record known to be on disk.&n;&t; */
r_if
c_cond
(paren
id|XFS_LSN_CMP_ARCH
c_func
(paren
id|threshold_lsn
comma
id|log-&gt;l_last_sync_lsn
comma
id|ARCH_NOCONVERT
)paren
OG
l_int|0
)paren
id|threshold_lsn
op_assign
id|log-&gt;l_last_sync_lsn
suffix:semicolon
)brace
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;     * Get the transaction layer to kick the dirty buffers out to&n;     * disk asynchronously. No point in trying to do this if&n;     * the filesystem is shutting down.&n;     */
r_if
c_cond
(paren
id|threshold_lsn
op_logical_and
op_logical_neg
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
id|xfs_trans_push_ail
c_func
(paren
id|mp
comma
id|threshold_lsn
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_grant_push_ail */
multiline_comment|/*&n; * Flush out the in-core log (iclog) to the on-disk log in a synchronous or&n; * asynchronous fashion.  Previously, we should have moved the current iclog&n; * ptr in the log to point to the next available iclog.  This allows further&n; * write to continue while this code syncs out an iclog ready to go.&n; * Before an in-core log can be written out, the data section must be scanned&n; * to save away the 1st word of each BBSIZE block into the header.  We replace&n; * it with the current cycle count.  Each BBSIZE block is tagged with the&n; * cycle count because there in an implicit assumption that drives will&n; * guarantee that entire 512 byte blocks get written at once.  In other words,&n; * we can&squot;t have part of a 512 byte block written and part not written.  By&n; * tagging each block, we will know which blocks are valid when recovering&n; * after an unclean shutdown.&n; *&n; * This routine is single threaded on the iclog.  No other thread can be in&n; * this routine with the same iclog.  Changing contents of iclog can there-&n; * fore be done without grabbing the state machine lock.  Updating the global&n; * log will require grabbing the lock though.&n; *&n; * The entire log manager uses a logical block numbering scheme.  Only&n; * log_sync (and then only bwrite()) know about the fact that the log may&n; * not start with block zero on a given device.  The log block start offset&n; * is added immediately before calling bwrite().&n; */
r_int
DECL|function|xlog_sync
id|xlog_sync
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
(brace
id|xfs_caddr_t
id|dptr
suffix:semicolon
multiline_comment|/* pointer to byte sized element */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|i
comma
id|ops
suffix:semicolon
id|uint
id|count
suffix:semicolon
multiline_comment|/* byte count of bwrite */
id|uint
id|count_init
suffix:semicolon
multiline_comment|/* initial count before roundup */
r_int
id|split
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* split write into two regions */
r_int
id|error
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_log_writes
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_refcnt
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Add for LR header */
id|count_init
op_assign
id|log-&gt;l_iclog_hsize
op_plus
id|iclog-&gt;ic_offset
suffix:semicolon
multiline_comment|/* Round out the log write size */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
op_logical_and
id|log-&gt;l_mp-&gt;m_sb.sb_logsunit
OG
l_int|1
)paren
(brace
multiline_comment|/* we have a v2 stripe unit to use */
id|count
op_assign
id|XLOG_LSUNITTOB
c_func
(paren
id|log
comma
id|XLOG_BTOLSUNIT
c_func
(paren
id|log
comma
id|count_init
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|count
op_assign
id|BBTOB
c_func
(paren
id|BTOBB
c_func
(paren
id|count_init
)paren
)paren
suffix:semicolon
)brace
id|iclog-&gt;ic_roundoff
op_assign
id|count
op_minus
id|count_init
suffix:semicolon
id|log-&gt;l_roundoff
op_add_assign
id|iclog-&gt;ic_roundoff
suffix:semicolon
id|xlog_pack_data
c_func
(paren
id|log
comma
id|iclog
)paren
suffix:semicolon
multiline_comment|/* put cycle number in every block */
multiline_comment|/* real byte length */
id|INT_SET
c_func
(paren
id|iclog-&gt;ic_header.h_len
comma
id|ARCH_CONVERT
comma
id|iclog-&gt;ic_offset
op_plus
id|iclog-&gt;ic_roundoff
)paren
suffix:semicolon
multiline_comment|/* put ops count in correct order */
id|ops
op_assign
id|iclog-&gt;ic_header.h_num_logops
suffix:semicolon
id|INT_SET
c_func
(paren
id|iclog-&gt;ic_header.h_num_logops
comma
id|ARCH_CONVERT
comma
id|ops
)paren
suffix:semicolon
id|bp
op_assign
id|iclog-&gt;ic_bp
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
r_int
r_int
)paren
op_eq
(paren
r_int
r_int
)paren
l_int|1
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
(paren
r_int
r_int
)paren
l_int|2
)paren
suffix:semicolon
id|XFS_BUF_SET_ADDR
c_func
(paren
id|bp
comma
id|BLOCK_LSN
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|XFS_STATS_ADD
c_func
(paren
id|xs_log_blocks
comma
id|BTOBB
c_func
(paren
id|count
)paren
)paren
suffix:semicolon
multiline_comment|/* Do we need to split this write into 2 parts? */
r_if
c_cond
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_plus
id|BTOBB
c_func
(paren
id|count
)paren
OG
id|log-&gt;l_logBBsize
)paren
(brace
id|split
op_assign
id|count
op_minus
(paren
id|BBTOB
c_func
(paren
id|log-&gt;l_logBBsize
op_minus
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
)paren
suffix:semicolon
id|count
op_assign
id|BBTOB
c_func
(paren
id|log-&gt;l_logBBsize
op_minus
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|iclog-&gt;ic_bwritecnt
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* split into 2 writes */
)brace
r_else
(brace
id|iclog-&gt;ic_bwritecnt
op_assign
l_int|1
suffix:semicolon
)brace
id|XFS_BUF_SET_PTR
c_func
(paren
id|bp
comma
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|iclog-&gt;ic_header
)paren
comma
id|count
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|iclog
)paren
suffix:semicolon
multiline_comment|/* save for later */
id|XFS_BUF_BUSY
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_ASYNC
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do a disk write cache flush for the log block.&n;&t; * This is a bit of a sledgehammer, it would be better&n;&t; * to use a tag barrier here that just prevents reordering.&n;&t; * It may not be needed to flush the first split block in the log wrap&n;&t; * case, but do it anyways to be safe -AK&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|log-&gt;l_mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NOLOGFLUSH
)paren
)paren
id|XFS_BUF_FLUSH
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_le
id|log-&gt;l_logBBsize
op_minus
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_plus
id|BTOBB
c_func
(paren
id|count
)paren
op_le
id|log-&gt;l_logBBsize
)paren
suffix:semicolon
id|xlog_verify_iclog
c_func
(paren
id|log
comma
id|iclog
comma
id|count
comma
id|B_TRUE
)paren
suffix:semicolon
multiline_comment|/* account for log which doesn&squot;t start at block #0 */
id|XFS_BUF_SET_ADDR
c_func
(paren
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_plus
id|log-&gt;l_logBBstart
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t call xfs_bwrite here. We do log-syncs even when the filesystem&n;&t; * is shutting down.&n;&t; */
id|XFS_BUF_WRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_bwrite
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_sync&quot;
comma
id|log-&gt;l_mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|split
)paren
(brace
id|bp
op_assign
id|iclog-&gt;ic_log-&gt;l_xbuf
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_FSPRIVATE2
c_func
(paren
id|bp
comma
r_int
r_int
)paren
op_eq
(paren
r_int
r_int
)paren
l_int|1
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE2
c_func
(paren
id|bp
comma
(paren
r_int
r_int
)paren
l_int|2
)paren
suffix:semicolon
id|XFS_BUF_SET_ADDR
c_func
(paren
id|bp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* logical 0 */
id|XFS_BUF_SET_PTR
c_func
(paren
id|bp
comma
(paren
id|xfs_caddr_t
)paren
(paren
(paren
id|__psint_t
)paren
op_amp
(paren
id|iclog-&gt;ic_header
)paren
op_plus
(paren
id|__psint_t
)paren
id|count
)paren
comma
id|split
)paren
suffix:semicolon
id|XFS_BUF_SET_FSPRIVATE
c_func
(paren
id|bp
comma
id|iclog
)paren
suffix:semicolon
id|XFS_BUF_BUSY
c_func
(paren
id|bp
)paren
suffix:semicolon
id|XFS_BUF_ASYNC
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|log-&gt;l_mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NOLOGFLUSH
)paren
)paren
id|XFS_BUF_FLUSH
c_func
(paren
id|bp
)paren
suffix:semicolon
id|dptr
op_assign
id|XFS_BUF_PTR
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Bump the cycle numbers at the start of each block&n;&t;&t; * since this part of the buffer is at the start of&n;&t;&t; * a new cycle.  Watch out for the header magic number&n;&t;&t; * case, though.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|split
suffix:semicolon
id|i
op_add_assign
id|BBSIZE
)paren
(brace
id|INT_MOD
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|dptr
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|dptr
comma
id|ARCH_CONVERT
)paren
op_eq
id|XLOG_HEADER_MAGIC_NUM
)paren
id|INT_MOD
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|dptr
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|dptr
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_le
id|log-&gt;l_logBBsize
op_minus
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_plus
id|BTOBB
c_func
(paren
id|count
)paren
op_le
id|log-&gt;l_logBBsize
)paren
suffix:semicolon
multiline_comment|/* account for internal log which does&squot;t start at block #0 */
id|XFS_BUF_SET_ADDR
c_func
(paren
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
op_plus
id|log-&gt;l_logBBstart
)paren
suffix:semicolon
id|XFS_BUF_WRITE
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|XFS_bwrite
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|xfs_ioerror_alert
c_func
(paren
l_string|&quot;xlog_sync (split)&quot;
comma
id|log-&gt;l_mp
comma
id|bp
comma
id|XFS_BUF_ADDR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_sync */
multiline_comment|/*&n; * Unallocate a log structure&n; */
r_void
DECL|function|xlog_unalloc_log
id|xlog_unalloc_log
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
comma
op_star
id|next_iclog
suffix:semicolon
id|xlog_ticket_t
op_star
id|tic
comma
op_star
id|next_tic
suffix:semicolon
r_int
id|i
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|log-&gt;l_iclog_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sv_destroy
c_func
(paren
op_amp
id|iclog-&gt;ic_forcesema
)paren
suffix:semicolon
id|sv_destroy
c_func
(paren
op_amp
id|iclog-&gt;ic_writesema
)paren
suffix:semicolon
id|xfs_buf_free
c_func
(paren
id|iclog-&gt;ic_bp
)paren
suffix:semicolon
macro_line|#ifdef XFS_LOG_TRACE
r_if
c_cond
(paren
id|iclog-&gt;ic_trace
op_ne
l_int|NULL
)paren
(brace
id|ktrace_free
c_func
(paren
id|iclog-&gt;ic_trace
)paren
suffix:semicolon
)brace
macro_line|#endif
id|next_iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
id|kmem_free
c_func
(paren
id|iclog-&gt;hic_data
comma
id|log-&gt;l_iclog_size
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|iclog
comma
r_sizeof
(paren
id|xlog_in_core_t
)paren
)paren
suffix:semicolon
id|iclog
op_assign
id|next_iclog
suffix:semicolon
)brace
id|freesema
c_func
(paren
op_amp
id|log-&gt;l_flushsema
)paren
suffix:semicolon
id|spinlock_destroy
c_func
(paren
op_amp
id|log-&gt;l_icloglock
)paren
suffix:semicolon
id|spinlock_destroy
c_func
(paren
op_amp
id|log-&gt;l_grant_lock
)paren
suffix:semicolon
multiline_comment|/* XXXsup take a look at this again. */
r_if
c_cond
(paren
(paren
id|log-&gt;l_ticket_cnt
op_ne
id|log-&gt;l_ticket_tcnt
)paren
op_logical_and
op_logical_neg
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|log-&gt;l_mp
comma
l_string|&quot;xlog_unalloc_log: (cnt: %d, total: %d)&quot;
comma
id|log-&gt;l_ticket_cnt
comma
id|log-&gt;l_ticket_tcnt
)paren
suffix:semicolon
multiline_comment|/* ASSERT(log-&gt;l_ticket_cnt == log-&gt;l_ticket_tcnt); */
)brace
r_else
(brace
id|tic
op_assign
id|log-&gt;l_unmount_free
suffix:semicolon
r_while
c_loop
(paren
id|tic
)paren
(brace
id|next_tic
op_assign
id|tic-&gt;t_next
suffix:semicolon
id|kmem_free
c_func
(paren
id|tic
comma
id|NBPP
)paren
suffix:semicolon
id|tic
op_assign
id|next_tic
suffix:semicolon
)brace
)brace
id|xfs_buf_free
c_func
(paren
id|log-&gt;l_xbuf
)paren
suffix:semicolon
macro_line|#ifdef XFS_LOG_TRACE
r_if
c_cond
(paren
id|log-&gt;l_trace
op_ne
l_int|NULL
)paren
(brace
id|ktrace_free
c_func
(paren
id|log-&gt;l_trace
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|log-&gt;l_grant_trace
op_ne
l_int|NULL
)paren
(brace
id|ktrace_free
c_func
(paren
id|log-&gt;l_grant_trace
)paren
suffix:semicolon
)brace
macro_line|#endif
id|log-&gt;l_mp-&gt;m_log
op_assign
l_int|NULL
suffix:semicolon
id|kmem_free
c_func
(paren
id|log
comma
r_sizeof
(paren
id|xlog_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_unalloc_log */
multiline_comment|/*&n; * Update counters atomically now that memcpy is done.&n; */
multiline_comment|/* ARGSUSED */
r_static
r_inline
r_void
DECL|function|xlog_state_finish_copy
id|xlog_state_finish_copy
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
id|record_cnt
comma
r_int
id|copy_bytes
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|iclog-&gt;ic_header.h_num_logops
op_add_assign
id|record_cnt
suffix:semicolon
id|iclog-&gt;ic_offset
op_add_assign
id|copy_bytes
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_state_finish_copy */
multiline_comment|/*&n; * Write some region out to in-core log&n; *&n; * This will be called when writing externally provided regions or when&n; * writing out a commit record for a given transaction.&n; *&n; * General algorithm:&n; *&t;1. Find total length of this write.  This may include adding to the&n; *&t;&t;lengths passed in.&n; *&t;2. Check whether we violate the tickets reservation.&n; *&t;3. While writing to this iclog&n; *&t;    A. Reserve as much space in this iclog as can get&n; *&t;    B. If this is first write, save away start lsn&n; *&t;    C. While writing this region:&n; *&t;&t;1. If first write of transaction, write start record&n; *&t;&t;2. Write log operation header (header per region)&n; *&t;&t;3. Find out if we can fit entire region into this iclog&n; *&t;&t;4. Potentially, verify destination memcpy ptr&n; *&t;&t;5. Memcpy (partial) region&n; *&t;&t;6. If partial copy, release iclog; otherwise, continue&n; *&t;&t;&t;copying more regions into current iclog&n; *&t;4. Mark want sync bit (in simulation mode)&n; *&t;5. Release iclog for potential flush to on-disk log.&n; *&n; * ERRORS:&n; * 1.&t;Panic if reservation is overrun.  This should never happen since&n; *&t;reservation amounts are generated internal to the filesystem.&n; * NOTES:&n; * 1. Tickets are single threaded data structures.&n; * 2. The XLOG_END_TRANS &amp; XLOG_CONTINUE_TRANS flags are passed down to the&n; *&t;syncing routine.  When a single log_write region needs to span&n; *&t;multiple in-core logs, the XLOG_CONTINUE_TRANS bit should be set&n; *&t;on all log operation writes which don&squot;t contain the end of the&n; *&t;region.  The XLOG_END_TRANS bit is used for the in-core log&n; *&t;operation which contains the end of the continued log_write region.&n; * 3. When xlog_state_get_iclog_space() grabs the rest of the current iclog,&n; *&t;we don&squot;t really know exactly how much space will be used.  As a result,&n; *&t;we don&squot;t update ic_offset until the end when we know exactly how many&n; *&t;bytes have been written out.&n; */
r_int
DECL|function|xlog_write
id|xlog_write
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_log_iovec_t
id|reg
(braket
)braket
comma
r_int
id|nentries
comma
id|xfs_log_ticket_t
id|tic
comma
id|xfs_lsn_t
op_star
id|start_lsn
comma
id|xlog_in_core_t
op_star
op_star
id|commit_iclog
comma
id|uint
id|flags
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
id|xlog_ticket_t
op_star
id|ticket
op_assign
(paren
id|xlog_ticket_t
op_star
)paren
id|tic
suffix:semicolon
id|xlog_op_header_t
op_star
id|logop_head
suffix:semicolon
multiline_comment|/* ptr to log operation header */
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
multiline_comment|/* ptr to current in-core log */
id|__psint_t
id|ptr
suffix:semicolon
multiline_comment|/* copy address into data region */
r_int
id|len
suffix:semicolon
multiline_comment|/* # xlog_write() bytes 2 still copy */
r_int
id|index
suffix:semicolon
multiline_comment|/* region index currently copying */
r_int
id|log_offset
suffix:semicolon
multiline_comment|/* offset (from 0) into data region */
r_int
id|start_rec_copy
suffix:semicolon
multiline_comment|/* # bytes to copy for start record */
r_int
id|partial_copy
suffix:semicolon
multiline_comment|/* did we split a region? */
r_int
id|partial_copy_len
suffix:semicolon
multiline_comment|/* # bytes copied if split region */
r_int
id|need_copy
suffix:semicolon
multiline_comment|/* # bytes need to memcpy this region */
r_int
id|copy_len
suffix:semicolon
multiline_comment|/* # bytes actually memcpy&squot;ing */
r_int
id|copy_off
suffix:semicolon
multiline_comment|/* # bytes from entry start */
r_int
id|contwr
suffix:semicolon
multiline_comment|/* continued write of in-core log? */
r_int
id|error
suffix:semicolon
r_int
id|record_cnt
op_assign
l_int|0
comma
id|data_cnt
op_assign
l_int|0
suffix:semicolon
id|partial_copy_len
op_assign
id|partial_copy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate potential maximum space.  Each region gets its own&n;     * xlog_op_header_t and may need to be double word aligned.&n;     */
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ticket-&gt;t_flags
op_amp
id|XLOG_TIC_INITED
)paren
multiline_comment|/* acct for start rec of xact */
id|len
op_add_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|nentries
suffix:semicolon
id|index
op_increment
)paren
(brace
id|len
op_add_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
multiline_comment|/* each region gets &gt;= 1 */
id|len
op_add_assign
id|reg
(braket
id|index
)braket
dot
id|i_len
suffix:semicolon
)brace
id|contwr
op_assign
op_star
id|start_lsn
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ticket-&gt;t_curr_res
OL
id|len
)paren
(brace
macro_line|#ifdef DEBUG
id|xlog_panic
c_func
(paren
l_string|&quot;xfs_log_write: reservation ran out. Need to up reservation&quot;
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Customer configurable panic */
id|xfs_cmn_err
c_func
(paren
id|XFS_PTAG_LOGRES
comma
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_log_write: reservation ran out. Need to up reservation&quot;
)paren
suffix:semicolon
multiline_comment|/* If we did not panic, shutdown the filesystem */
id|xfs_force_shutdown
c_func
(paren
id|mp
comma
id|XFS_CORRUPT_INCORE
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|ticket-&gt;t_curr_res
op_sub_assign
id|len
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|nentries
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_state_get_iclog_space
c_func
(paren
id|log
comma
id|len
comma
op_amp
id|iclog
comma
id|ticket
comma
op_amp
id|contwr
comma
op_amp
id|log_offset
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log_offset
op_le
id|iclog-&gt;ic_size
op_minus
l_int|1
)paren
suffix:semicolon
id|ptr
op_assign
(paren
id|__psint_t
)paren
(paren
(paren
r_char
op_star
)paren
id|iclog-&gt;ic_datap
op_plus
id|log_offset
)paren
suffix:semicolon
multiline_comment|/* start_lsn is the first lsn written to. That&squot;s all we need. */
r_if
c_cond
(paren
op_logical_neg
op_star
id|start_lsn
)paren
op_star
id|start_lsn
op_assign
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* This loop writes out as many regions as can fit in the amount&n;&t; * of space which was allocated by xlog_state_get_iclog_space().&n;&t; */
r_while
c_loop
(paren
id|index
OL
id|nentries
)paren
(brace
id|ASSERT
c_func
(paren
id|reg
(braket
id|index
)braket
dot
id|i_len
op_mod
r_sizeof
(paren
id|__int32_t
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|__psint_t
)paren
id|ptr
op_mod
r_sizeof
(paren
id|__int32_t
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|start_rec_copy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If first write for transaction, insert start record.&n;&t;     * We can&squot;t be trying to commit if we are inited.  We can&squot;t&n;&t;     * have any &quot;partial_copy&quot; if we are inited.&n;&t;     */
r_if
c_cond
(paren
id|ticket-&gt;t_flags
op_amp
id|XLOG_TIC_INITED
)paren
(brace
id|logop_head
op_assign
(paren
id|xlog_op_header_t
op_star
)paren
id|ptr
suffix:semicolon
id|INT_SET
c_func
(paren
id|logop_head-&gt;oh_tid
comma
id|ARCH_CONVERT
comma
id|ticket-&gt;t_tid
)paren
suffix:semicolon
id|logop_head-&gt;oh_clientid
op_assign
id|ticket-&gt;t_clientid
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|logop_head-&gt;oh_len
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|logop_head-&gt;oh_flags
op_assign
id|XLOG_START_TRANS
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|logop_head-&gt;oh_res2
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ticket-&gt;t_flags
op_and_assign
op_complement
id|XLOG_TIC_INITED
suffix:semicolon
multiline_comment|/* clear bit */
id|record_cnt
op_increment
suffix:semicolon
id|start_rec_copy
op_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
id|xlog_write_adv_cnt
c_func
(paren
id|ptr
comma
id|len
comma
id|log_offset
comma
id|start_rec_copy
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy log operation header directly into data section */
id|logop_head
op_assign
(paren
id|xlog_op_header_t
op_star
)paren
id|ptr
suffix:semicolon
id|INT_SET
c_func
(paren
id|logop_head-&gt;oh_tid
comma
id|ARCH_CONVERT
comma
id|ticket-&gt;t_tid
)paren
suffix:semicolon
id|logop_head-&gt;oh_clientid
op_assign
id|ticket-&gt;t_clientid
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|logop_head-&gt;oh_res2
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/* header copied directly */
id|xlog_write_adv_cnt
c_func
(paren
id|ptr
comma
id|len
comma
id|log_offset
comma
r_sizeof
(paren
id|xlog_op_header_t
)paren
)paren
suffix:semicolon
multiline_comment|/* are we copying a commit or unmount record? */
id|logop_head-&gt;oh_flags
op_assign
id|flags
suffix:semicolon
multiline_comment|/*&n;&t;     * We&squot;ve seen logs corrupted with bad transaction client&n;&t;     * ids.  This makes sure that XFS doesn&squot;t generate them on.&n;&t;     * Turn this into an EIO and shut down the filesystem.&n;&t;     */
r_switch
c_cond
(paren
id|logop_head-&gt;oh_clientid
)paren
(brace
r_case
id|XFS_TRANSACTION
suffix:colon
r_case
id|XFS_VOLUME
suffix:colon
r_case
id|XFS_LOG
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|mp
comma
l_string|&quot;Bad XFS transaction clientid 0x%x in ticket 0x%p&quot;
comma
id|logop_head-&gt;oh_clientid
comma
id|tic
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* Partial write last time? =&gt; (partial_copy != 0)&n;&t;     * need_copy is the amount we&squot;d like to copy if everything could&n;&t;     * fit in the current memcpy.&n;&t;     */
id|need_copy
op_assign
id|reg
(braket
id|index
)braket
dot
id|i_len
op_minus
id|partial_copy_len
suffix:semicolon
id|copy_off
op_assign
id|partial_copy_len
suffix:semicolon
r_if
c_cond
(paren
id|need_copy
op_le
id|iclog-&gt;ic_size
op_minus
id|log_offset
)paren
(brace
multiline_comment|/*complete write */
id|INT_SET
c_func
(paren
id|logop_head-&gt;oh_len
comma
id|ARCH_CONVERT
comma
id|copy_len
op_assign
id|need_copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|partial_copy
)paren
id|logop_head-&gt;oh_flags
op_or_assign
(paren
id|XLOG_END_TRANS
op_or
id|XLOG_WAS_CONT_TRANS
)paren
suffix:semicolon
id|partial_copy_len
op_assign
id|partial_copy
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* partial write */
id|copy_len
op_assign
id|iclog-&gt;ic_size
op_minus
id|log_offset
suffix:semicolon
id|INT_SET
c_func
(paren
id|logop_head-&gt;oh_len
comma
id|ARCH_CONVERT
comma
id|copy_len
)paren
suffix:semicolon
id|logop_head-&gt;oh_flags
op_or_assign
id|XLOG_CONTINUE_TRANS
suffix:semicolon
r_if
c_cond
(paren
id|partial_copy
)paren
id|logop_head-&gt;oh_flags
op_or_assign
id|XLOG_WAS_CONT_TRANS
suffix:semicolon
id|partial_copy_len
op_add_assign
id|copy_len
suffix:semicolon
id|partial_copy
op_increment
suffix:semicolon
id|len
op_add_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
multiline_comment|/* from splitting of region */
multiline_comment|/* account for new log op header */
id|ticket-&gt;t_curr_res
op_sub_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
)brace
id|xlog_verify_dest_ptr
c_func
(paren
id|log
comma
id|ptr
)paren
suffix:semicolon
multiline_comment|/* copy region */
id|ASSERT
c_func
(paren
id|copy_len
op_ge
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|xfs_caddr_t
)paren
id|ptr
comma
id|reg
(braket
id|index
)braket
dot
id|i_addr
op_plus
id|copy_off
comma
id|copy_len
)paren
suffix:semicolon
id|xlog_write_adv_cnt
c_func
(paren
id|ptr
comma
id|len
comma
id|log_offset
comma
id|copy_len
)paren
suffix:semicolon
multiline_comment|/* make copy_len total bytes copied, including headers */
id|copy_len
op_add_assign
id|start_rec_copy
op_plus
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
id|record_cnt
op_increment
suffix:semicolon
id|data_cnt
op_add_assign
id|contwr
ques
c_cond
id|copy_len
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|partial_copy
)paren
(brace
multiline_comment|/* copied partial region */
multiline_comment|/* already marked WANT_SYNC by xlog_state_get_iclog_space */
id|xlog_state_finish_copy
c_func
(paren
id|log
comma
id|iclog
comma
id|record_cnt
comma
id|data_cnt
)paren
suffix:semicolon
id|record_cnt
op_assign
id|data_cnt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* don&squot;t increment index */
)brace
r_else
(brace
multiline_comment|/* copied entire region */
id|index
op_increment
suffix:semicolon
id|partial_copy_len
op_assign
id|partial_copy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iclog-&gt;ic_size
op_minus
id|log_offset
op_le
r_sizeof
(paren
id|xlog_op_header_t
)paren
)paren
(brace
id|xlog_state_finish_copy
c_func
(paren
id|log
comma
id|iclog
comma
id|record_cnt
comma
id|data_cnt
)paren
suffix:semicolon
id|record_cnt
op_assign
id|data_cnt
op_assign
l_int|0
suffix:semicolon
id|xlog_state_want_sync
c_func
(paren
id|log
comma
id|iclog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_iclog
)paren
(brace
id|ASSERT
c_func
(paren
id|flags
op_amp
id|XLOG_COMMIT_TRANS
)paren
suffix:semicolon
op_star
id|commit_iclog
op_assign
id|iclog
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|nentries
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we are done */
r_else
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* if (partial_copy) */
)brace
multiline_comment|/* while (index &lt; nentries) */
)brace
multiline_comment|/* for (index = 0; index &lt; nentries; ) */
id|ASSERT
c_func
(paren
id|len
op_eq
l_int|0
)paren
suffix:semicolon
id|xlog_state_finish_copy
c_func
(paren
id|log
comma
id|iclog
comma
id|record_cnt
comma
id|data_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|commit_iclog
)paren
(brace
id|ASSERT
c_func
(paren
id|flags
op_amp
id|XLOG_COMMIT_TRANS
)paren
suffix:semicolon
op_star
id|commit_iclog
op_assign
id|iclog
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_write */
multiline_comment|/*****************************************************************************&n; *&n; *&t;&t;State Machine functions&n; *&n; *****************************************************************************&n; */
multiline_comment|/* Clean iclogs starting from the head.  This ordering must be&n; * maintained, so an iclog doesn&squot;t become ACTIVE beyond one that&n; * is SYNCING.  This is also required to maintain the notion that we use&n; * a counting semaphore to hold off would be writers to the log when every&n; * iclog is trying to sync to disk.&n; *&n; * State Change: DIRTY -&gt; ACTIVE&n; */
r_void
DECL|function|xlog_state_clean_log
id|xlog_state_clean_log
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DIRTY
)paren
(brace
id|iclog-&gt;ic_state
op_assign
id|XLOG_STATE_ACTIVE
suffix:semicolon
id|iclog-&gt;ic_offset
op_assign
l_int|0
suffix:semicolon
id|iclog-&gt;ic_callback
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t need to free */
multiline_comment|/*&n;&t;&t;&t; * If the number of ops in this iclog indicate it just&n;&t;&t;&t; * contains the dummy transaction, we can&n;&t;&t;&t; * change state into IDLE (the second time around).&n;&t;&t;&t; * Otherwise we should change the state into&n;&t;&t;&t; * NEED a dummy.&n;&t;&t;&t; * We don&squot;t need to cover the dummy.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|changed
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_num_logops
comma
id|ARCH_CONVERT
)paren
op_eq
id|XLOG_COVER_OPS
)paren
)paren
(brace
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We have two dirty iclogs so start over&n;&t;&t;&t;&t; * This could also be num of ops indicates&n;&t;&t;&t;&t; * this is not the dummy going out.&n;&t;&t;&t;&t; */
id|changed
op_assign
l_int|2
suffix:semicolon
)brace
id|INT_ZERO
c_func
(paren
id|iclog-&gt;ic_header.h_num_logops
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memset
c_func
(paren
id|iclog-&gt;ic_header.h_cycle_data
comma
l_int|0
comma
r_sizeof
(paren
id|iclog-&gt;ic_header.h_cycle_data
)paren
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
)paren
multiline_comment|/* do nothing */
suffix:semicolon
r_else
r_break
suffix:semicolon
multiline_comment|/* stop cleaning */
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|iclog
op_ne
id|log-&gt;l_iclog
)paren
suffix:semicolon
multiline_comment|/* log is locked when we are called */
multiline_comment|/*&n;&t; * Change state for the dummy log recording.&n;&t; * We usually go to NEED. But we go to NEED2 if the changed indicates&n;&t; * we are done writing the dummy record.&n;&t; * If we are done with the second dummy recored (DONE2), then&n;&t; * we go to IDLE.&n;&t; */
r_if
c_cond
(paren
id|changed
)paren
(brace
r_switch
c_cond
(paren
id|log-&gt;l_covered_state
)paren
(brace
r_case
id|XLOG_STATE_COVER_IDLE
suffix:colon
r_case
id|XLOG_STATE_COVER_NEED
suffix:colon
r_case
id|XLOG_STATE_COVER_NEED2
suffix:colon
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_NEED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XLOG_STATE_COVER_DONE
suffix:colon
r_if
c_cond
(paren
id|changed
op_eq
l_int|1
)paren
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_NEED2
suffix:semicolon
r_else
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_NEED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XLOG_STATE_COVER_DONE2
suffix:colon
r_if
c_cond
(paren
id|changed
op_eq
l_int|1
)paren
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_IDLE
suffix:semicolon
r_else
id|log-&gt;l_covered_state
op_assign
id|XLOG_STATE_COVER_NEED
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* xlog_state_clean_log */
id|STATIC
id|xfs_lsn_t
DECL|function|xlog_get_lowest_lsn
id|xlog_get_lowest_lsn
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xlog_in_core_t
op_star
id|lsn_log
suffix:semicolon
id|xfs_lsn_t
id|lowest_lsn
comma
id|lsn
suffix:semicolon
id|lsn_log
op_assign
id|log-&gt;l_iclog
suffix:semicolon
id|lowest_lsn
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|lsn_log-&gt;ic_state
op_amp
(paren
id|XLOG_STATE_ACTIVE
op_or
id|XLOG_STATE_DIRTY
)paren
)paren
)paren
(brace
id|lsn
op_assign
id|INT_GET
c_func
(paren
id|lsn_log-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lsn
op_logical_and
op_logical_neg
id|lowest_lsn
)paren
op_logical_or
(paren
id|XFS_LSN_CMP_ARCH
c_func
(paren
id|lsn
comma
id|lowest_lsn
comma
id|ARCH_NOCONVERT
)paren
OL
l_int|0
)paren
)paren
(brace
id|lowest_lsn
op_assign
id|lsn
suffix:semicolon
)brace
)brace
id|lsn_log
op_assign
id|lsn_log-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|lsn_log
op_ne
id|log-&gt;l_iclog
)paren
suffix:semicolon
r_return
id|lowest_lsn
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xlog_state_do_callback
id|xlog_state_do_callback
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|aborted
comma
id|xlog_in_core_t
op_star
id|ciclog
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
id|xlog_in_core_t
op_star
id|first_iclog
suffix:semicolon
multiline_comment|/* used to know when we&squot;ve&n;&t;&t;&t;&t;&t;&t; * processed all iclogs once */
id|xfs_log_callback_t
op_star
id|cb
comma
op_star
id|cb_next
suffix:semicolon
r_int
id|flushcnt
op_assign
l_int|0
suffix:semicolon
id|xfs_lsn_t
id|lowest_lsn
suffix:semicolon
r_int
id|ioerrors
suffix:semicolon
multiline_comment|/* counter: iclogs with errors */
r_int
id|loopdidcallbacks
suffix:semicolon
multiline_comment|/* flag: inner loop did callbacks*/
r_int
id|funcdidcallbacks
suffix:semicolon
multiline_comment|/* flag: function did callbacks */
r_int
id|repeats
suffix:semicolon
multiline_comment|/* for issuing console warnings if&n;&t;&t;&t;&t;&t; * looping too many times */
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|first_iclog
op_assign
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
id|ioerrors
op_assign
l_int|0
suffix:semicolon
id|funcdidcallbacks
op_assign
l_int|0
suffix:semicolon
id|repeats
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Scan all iclogs starting with the one pointed to by the&n;&t;&t; * log.  Reset this starting point each time the log is&n;&t;&t; * unlocked (during callbacks).&n;&t;&t; *&n;&t;&t; * Keep looping through iclogs until one full pass is made&n;&t;&t; * without running any callbacks.&n;&t;&t; */
id|first_iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
id|loopdidcallbacks
op_assign
l_int|0
suffix:semicolon
id|repeats
op_increment
suffix:semicolon
r_do
(brace
multiline_comment|/* skip all iclogs in the ACTIVE &amp; DIRTY states */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
(paren
id|XLOG_STATE_ACTIVE
op_or
id|XLOG_STATE_DIRTY
)paren
)paren
(brace
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Between marking a filesystem SHUTDOWN and stopping&n;&t;&t;&t; * the log, we do flush all iclogs to disk (if there&n;&t;&t;&t; * wasn&squot;t a log I/O error). So, we do want things to&n;&t;&t;&t; * go smoothly in case of just a SHUTDOWN  w/o a&n;&t;&t;&t; * LOG_IO_ERROR.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Can only perform callbacks in order.  Since&n;&t;&t;&t;&t; * this iclog is not in the DONE_SYNC/&n;&t;&t;&t;&t; * DO_CALLBACK state, we skip the rest and&n;&t;&t;&t;&t; * just try to clean up.  If we set our iclog&n;&t;&t;&t;&t; * to DO_CALLBACK, we will not process it when&n;&t;&t;&t;&t; * we retry since a previous iclog is in the&n;&t;&t;&t;&t; * CALLBACK and the state cannot change since&n;&t;&t;&t;&t; * we are holding the LOG_LOCK.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_amp
(paren
id|XLOG_STATE_DONE_SYNC
op_or
id|XLOG_STATE_DO_CALLBACK
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ciclog
op_logical_and
(paren
id|ciclog-&gt;ic_state
op_eq
id|XLOG_STATE_DONE_SYNC
)paren
)paren
(brace
id|ciclog-&gt;ic_state
op_assign
id|XLOG_STATE_DO_CALLBACK
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * We now have an iclog that is in either the&n;&t;&t;&t;&t; * DO_CALLBACK or DONE_SYNC states. The other&n;&t;&t;&t;&t; * states (WANT_SYNC, SYNCING, or CALLBACK were&n;&t;&t;&t;&t; * caught by the above if and are going to&n;&t;&t;&t;&t; * clean (i.e. we aren&squot;t doing their callbacks)&n;&t;&t;&t;&t; * see the above if.&n;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t; * We will do one more check here to see if we&n;&t;&t;&t;&t; * have chased our tail around.&n;&t;&t;&t;&t; */
id|lowest_lsn
op_assign
id|xlog_get_lowest_lsn
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lowest_lsn
op_logical_and
(paren
id|XFS_LSN_CMP_ARCH
c_func
(paren
id|lowest_lsn
comma
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_NOCONVERT
)paren
OL
l_int|0
)paren
)paren
(brace
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* Leave this iclog for&n;&t;&t;&t;&t;&t;&t;   * another thread */
)brace
id|iclog-&gt;ic_state
op_assign
id|XLOG_STATE_CALLBACK
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* l_last_sync_lsn field protected by&n;&t;&t;&t;&t; * GRANT_LOCK. Don&squot;t worry about iclog&squot;s lsn.&n;&t;&t;&t;&t; * No one else can be here except us.&n;&t;&t;&t;&t; */
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_LSN_CMP_ARCH
c_func
(paren
id|log-&gt;l_last_sync_lsn
comma
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_NOCONVERT
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|log-&gt;l_last_sync_lsn
op_assign
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Keep processing entries in the callback list&n;&t;&t;&t;&t; * until we come around and it is empty.  We&n;&t;&t;&t;&t; * need to atomically see that the list is&n;&t;&t;&t;&t; * empty and change the state to DIRTY so that&n;&t;&t;&t;&t; * we don&squot;t miss any more callbacks being added.&n;&t;&t;&t;&t; */
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioerrors
op_increment
suffix:semicolon
)brace
id|cb
op_assign
id|iclog-&gt;ic_callback
suffix:semicolon
r_while
c_loop
(paren
id|cb
op_ne
l_int|0
)paren
(brace
id|iclog-&gt;ic_callback_tail
op_assign
op_amp
(paren
id|iclog-&gt;ic_callback
)paren
suffix:semicolon
id|iclog-&gt;ic_callback
op_assign
l_int|0
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* perform callbacks in the order given */
r_for
c_loop
(paren
suffix:semicolon
id|cb
op_ne
l_int|0
suffix:semicolon
id|cb
op_assign
id|cb_next
)paren
(brace
id|cb_next
op_assign
id|cb-&gt;cb_next
suffix:semicolon
id|cb
op_member_access_from_pointer
id|cb_func
c_func
(paren
id|cb-&gt;cb_arg
comma
id|aborted
)paren
suffix:semicolon
)brace
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|cb
op_assign
id|iclog-&gt;ic_callback
suffix:semicolon
)brace
id|loopdidcallbacks
op_increment
suffix:semicolon
id|funcdidcallbacks
op_increment
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_callback
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
)paren
id|iclog-&gt;ic_state
op_assign
id|XLOG_STATE_DIRTY
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Transition from DIRTY to ACTIVE if applicable.&n;&t;&t;&t; * NOP if STATE_IOERROR.&n;&t;&t;&t; */
id|xlog_state_clean_log
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* wake up threads waiting in xfs_log_force() */
id|sv_broadcast
c_func
(paren
op_amp
id|iclog-&gt;ic_forcesema
)paren
suffix:semicolon
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|first_iclog
op_ne
id|iclog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|repeats
op_logical_and
(paren
id|repeats
op_mod
l_int|10
)paren
op_eq
l_int|0
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_WARN
comma
id|log-&gt;l_mp
comma
l_string|&quot;xlog_state_do_callback: looping %d&quot;
comma
id|repeats
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|ioerrors
op_logical_and
id|loopdidcallbacks
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * make one last gasp attempt to see if iclogs are being left in&n;&t; * limbo..&n;&t; */
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|funcdidcallbacks
)paren
(brace
id|first_iclog
op_assign
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_do
(brace
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_state
op_ne
id|XLOG_STATE_DO_CALLBACK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Terminate the loop if iclogs are found in states&n;&t;&t;&t; * which will cause other threads to clean up iclogs.&n;&t;&t;&t; *&n;&t;&t;&t; * SYNCING - i/o completion will go through logs&n;&t;&t;&t; * DONE_SYNC - interrupt thread should be waiting for&n;&t;&t;&t; *              LOG_LOCK&n;&t;&t;&t; * IOERROR - give up hope all ye who enter here&n;&t;&t;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_WANT_SYNC
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_SYNCING
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DONE_SYNC
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_IOERROR
)paren
r_break
suffix:semicolon
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|first_iclog
op_ne
id|iclog
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|log-&gt;l_iclog-&gt;ic_state
op_amp
(paren
id|XLOG_STATE_ACTIVE
op_or
id|XLOG_STATE_IOERROR
)paren
)paren
(brace
id|flushcnt
op_assign
id|log-&gt;l_flushcnt
suffix:semicolon
id|log-&gt;l_flushcnt
op_assign
l_int|0
suffix:semicolon
)brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_while
c_loop
(paren
id|flushcnt
op_decrement
)paren
id|vsema
c_func
(paren
op_amp
id|log-&gt;l_flushsema
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_state_do_callback */
multiline_comment|/*&n; * Finish transitioning this iclog to the dirty state.&n; *&n; * Make sure that we completely execute this routine only when this is&n; * the last call to the iclog.  There is a good chance that iclog flushes,&n; * when we reach the end of the physical log, get turned into 2 separate&n; * calls to bwrite.  Hence, one iclog flush could generate two calls to this&n; * routine.  By using the reference count bwritecnt, we guarantee that only&n; * the second completion goes through.&n; *&n; * Callbacks could take time, so they are done outside the scope of the&n; * global state machine log lock.  Assume that the calls to cvsema won&squot;t&n; * take a long time.  At least we know it won&squot;t sleep.&n; */
r_void
DECL|function|xlog_state_done_syncing
id|xlog_state_done_syncing
c_func
(paren
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
id|aborted
)paren
(brace
id|xlog_t
op_star
id|log
op_assign
id|iclog-&gt;ic_log
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_SYNCING
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_IOERROR
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_refcnt
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_bwritecnt
op_eq
l_int|1
op_logical_or
id|iclog-&gt;ic_bwritecnt
op_eq
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we got an error, either on the first buffer, or in the case of&n;&t; * split log writes, on the second, we mark ALL iclogs STATE_IOERROR,&n;&t; * and none should ever be attempted to be written to disk&n;&t; * again.&n;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_ne
id|XLOG_STATE_IOERROR
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|iclog-&gt;ic_bwritecnt
op_eq
l_int|1
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|iclog-&gt;ic_state
op_assign
id|XLOG_STATE_DONE_SYNC
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Someone could be sleeping prior to writing out the next&n;&t; * iclog buffer, we wake them all, one will get to do the&n;&t; * I/O, the others get to wait for the result.&n;&t; */
id|sv_broadcast
c_func
(paren
op_amp
id|iclog-&gt;ic_writesema
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
id|xlog_state_do_callback
c_func
(paren
id|log
comma
id|aborted
comma
id|iclog
)paren
suffix:semicolon
multiline_comment|/* also cleans log */
)brace
multiline_comment|/* xlog_state_done_syncing */
multiline_comment|/*&n; * If the head of the in-core log ring is not (ACTIVE or DIRTY), then we must&n; * sleep.  The flush semaphore is set to the number of in-core buffers and&n; * decremented around disk syncing.  Therefore, if all buffers are syncing,&n; * this semaphore will cause new writes to sleep until a sync completes.&n; * Otherwise, this code just does p() followed by v().  This approximates&n; * a sleep/wakeup except we can&squot;t race.&n; *&n; * The in-core logs are used in a circular fashion. They are not used&n; * out-of-order even when an iclog past the head is free.&n; *&n; * return:&n; *&t;* log_offset where xlog_write() can start writing into the in-core&n; *&t;&t;log&squot;s data space.&n; *&t;* in-core log pointer to which xlog_write() should write.&n; *&t;* boolean indicating this is a continued write to an in-core log.&n; *&t;&t;If this is the last write, then the in-core log&squot;s offset field&n; *&t;&t;needs to be incremented, depending on the amount of data which&n; *&t;&t;is copied.&n; */
r_int
DECL|function|xlog_state_get_iclog_space
id|xlog_state_get_iclog_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|len
comma
id|xlog_in_core_t
op_star
op_star
id|iclogp
comma
id|xlog_ticket_t
op_star
id|ticket
comma
r_int
op_star
id|continued_write
comma
r_int
op_star
id|logoffsetp
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
r_int
id|log_offset
suffix:semicolon
id|xlog_rec_header_t
op_star
id|head
suffix:semicolon
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
r_int
id|error
suffix:semicolon
id|restart
suffix:colon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
)paren
)paren
(brace
id|log-&gt;l_flushcnt
op_increment
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
id|xlog_trace_iclog
c_func
(paren
id|iclog
comma
id|XLOG_TRACE_SLEEP_FLUSH
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_log_noiclogs
)paren
suffix:semicolon
multiline_comment|/* Ensure that log writes happen */
id|psema
c_func
(paren
op_amp
id|log-&gt;l_flushsema
comma
id|PINOD
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|iclog-&gt;ic_header
suffix:semicolon
id|iclog-&gt;ic_refcnt
op_increment
suffix:semicolon
multiline_comment|/* prevents sync */
id|log_offset
op_assign
id|iclog-&gt;ic_offset
suffix:semicolon
multiline_comment|/* On the 1st write to an iclog, figure out lsn.  This works&n;&t; * if iclogs marked XLOG_STATE_WANT_SYNC always write out what they are&n;&t; * committing to.  If the offset is set, that&squot;s how many blocks&n;&t; * must be written.&n;&t; */
r_if
c_cond
(paren
id|log_offset
op_eq
l_int|0
)paren
(brace
id|ticket-&gt;t_curr_res
op_sub_assign
id|log-&gt;l_iclog_hsize
suffix:semicolon
id|INT_SET
c_func
(paren
id|head-&gt;h_cycle
comma
id|ARCH_CONVERT
comma
id|log-&gt;l_curr_cycle
)paren
suffix:semicolon
id|ASSIGN_LSN
c_func
(paren
id|head-&gt;h_lsn
comma
id|log
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log-&gt;l_curr_block
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/* round off error from last write with this iclog */
id|ticket-&gt;t_curr_res
op_sub_assign
id|iclog-&gt;ic_roundoff
suffix:semicolon
id|log-&gt;l_roundoff
op_sub_assign
id|iclog-&gt;ic_roundoff
suffix:semicolon
id|iclog-&gt;ic_roundoff
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If there is enough room to write everything, then do it.  Otherwise,&n;&t; * claim the rest of the region and make sure the XLOG_STATE_WANT_SYNC&n;&t; * bit is on, so this will get flushed out.  Don&squot;t update ic_offset&n;&t; * until you know exactly how many bytes get copied.  Therefore, wait&n;&t; * until later to update ic_offset.&n;&t; *&n;&t; * xlog_write() algorithm assumes that at least 2 xlog_op_header_t&squot;s&n;&t; * can fit into remaining data section.&n;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_size
op_minus
id|iclog-&gt;ic_offset
OL
l_int|2
op_star
r_sizeof
(paren
id|xlog_op_header_t
)paren
)paren
(brace
id|xlog_state_switch_iclogs
c_func
(paren
id|log
comma
id|iclog
comma
id|iclog-&gt;ic_size
)paren
suffix:semicolon
multiline_comment|/* If I&squot;m the only one writing to this iclog, sync it to disk */
r_if
c_cond
(paren
id|iclog-&gt;ic_refcnt
op_eq
l_int|1
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_else
(brace
id|iclog-&gt;ic_refcnt
op_decrement
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/* Do we have enough room to write the full amount in the remainder&n;&t; * of this iclog?  Or must we continue a write on the next iclog and&n;&t; * mark this iclog as completely taken?  In the case where we switch&n;&t; * iclogs (to mark it taken), this particular iclog will release/sync&n;&t; * to disk in xlog_write().&n;&t; */
r_if
c_cond
(paren
id|len
op_le
id|iclog-&gt;ic_size
op_minus
id|iclog-&gt;ic_offset
)paren
(brace
op_star
id|continued_write
op_assign
l_int|0
suffix:semicolon
id|iclog-&gt;ic_offset
op_add_assign
id|len
suffix:semicolon
)brace
r_else
(brace
op_star
id|continued_write
op_assign
l_int|1
suffix:semicolon
id|xlog_state_switch_iclogs
c_func
(paren
id|log
comma
id|iclog
comma
id|iclog-&gt;ic_size
)paren
suffix:semicolon
)brace
op_star
id|iclogp
op_assign
id|iclog
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_offset
op_le
id|iclog-&gt;ic_size
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
op_star
id|logoffsetp
op_assign
id|log_offset
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* xlog_state_get_iclog_space */
multiline_comment|/*&n; * Atomically get the log space required for a log ticket.&n; *&n; * Once a ticket gets put onto the reserveq, it will only return after&n; * the needed reservation is satisfied.&n; */
id|STATIC
r_int
DECL|function|xlog_grant_log_space
id|xlog_grant_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|tic
)paren
(brace
r_int
id|free_bytes
suffix:semicolon
r_int
id|need_bytes
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_lsn_t
id|tail_lsn
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|log-&gt;l_flags
op_amp
id|XLOG_ACTIVE_RECOVERY
)paren
id|panic
c_func
(paren
l_string|&quot;grant Recovery problem&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Is there space or do we need to sleep? */
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_grant_log_space: enter&quot;
)paren
suffix:semicolon
multiline_comment|/* something is already sleeping; insert new transaction at end */
r_if
c_cond
(paren
id|log-&gt;l_reserve_headq
)paren
(brace
id|XLOG_INS_TICKETQ
c_func
(paren
id|log-&gt;l_reserve_headq
comma
id|tic
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_grant_log_space: sleep 1&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Gotta check this before going to sleep, while we&squot;re&n;&t;&t; * holding the grant lock.&n;&t;&t; */
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_sleep_logspace
)paren
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
id|tic-&gt;t_sema
comma
id|PINOD
op_or
id|PLTWAIT
comma
op_amp
id|log-&gt;l_grant_lock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we got an error, and the filesystem is shutting down,&n;&t;&t; * we&squot;ll catch it down below. So just continue...&n;&t;&t; */
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_grant_log_space: wake 1&quot;
)paren
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tic-&gt;t_flags
op_amp
id|XFS_LOG_PERM_RESERV
)paren
id|need_bytes
op_assign
id|tic-&gt;t_unit_res
op_star
id|tic-&gt;t_ocnt
suffix:semicolon
r_else
id|need_bytes
op_assign
id|tic-&gt;t_unit_res
suffix:semicolon
id|redo
suffix:colon
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|free_bytes
op_assign
id|xlog_space_left
c_func
(paren
id|log
comma
id|log-&gt;l_grant_reserve_cycle
comma
id|log-&gt;l_grant_reserve_bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_bytes
OL
id|need_bytes
)paren
(brace
r_if
c_cond
(paren
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_IN_Q
)paren
op_eq
l_int|0
)paren
id|XLOG_INS_TICKETQ
c_func
(paren
id|log-&gt;l_reserve_headq
comma
id|tic
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_grant_log_space: sleep 2&quot;
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_sleep_logspace
)paren
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
id|tic-&gt;t_sema
comma
id|PINOD
op_or
id|PLTWAIT
comma
op_amp
id|log-&gt;l_grant_lock
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
(brace
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_grant_log_space: wake 2&quot;
)paren
suffix:semicolon
id|xlog_grant_push_ail
c_func
(paren
id|log-&gt;l_mp
comma
id|need_bytes
)paren
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_goto
id|redo
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_IN_Q
)paren
id|XLOG_DEL_TICKETQ
c_func
(paren
id|log-&gt;l_reserve_headq
comma
id|tic
)paren
suffix:semicolon
multiline_comment|/* we&squot;ve got enough space */
id|XLOG_GRANT_ADD_SPACE
c_func
(paren
id|log
comma
id|need_bytes
comma
l_char|&squot;w&squot;
)paren
suffix:semicolon
id|XLOG_GRANT_ADD_SPACE
c_func
(paren
id|log
comma
id|need_bytes
comma
l_char|&squot;r&squot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|tail_lsn
op_assign
id|log-&gt;l_tail_lsn
suffix:semicolon
multiline_comment|/*&n;&t; * Check to make sure the grant write head didn&squot;t just over lap the&n;&t; * tail.  If the cycles are the same, we can&squot;t be overlapping.&n;&t; * Otherwise, make sure that the cycles differ by exactly one and&n;&t; * check the byte count.&n;&t; */
r_if
c_cond
(paren
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
op_ne
id|log-&gt;l_grant_write_cycle
)paren
(brace
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_write_cycle
op_minus
l_int|1
op_eq
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_write_bytes
op_le
id|BBTOB
c_func
(paren
id|BLOCK_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_grant_log_space: exit&quot;
)paren
suffix:semicolon
id|xlog_verify_grant_head
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error_return
suffix:colon
r_if
c_cond
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_IN_Q
)paren
id|XLOG_DEL_TICKETQ
c_func
(paren
id|log-&gt;l_reserve_headq
comma
id|tic
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_grant_log_space: err_ret&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are failing, make sure the ticket doesn&squot;t have any&n;&t; * current reservations. We don&squot;t want to add this back when&n;&t; * the ticket/transaction gets cancelled.&n;&t; */
id|tic-&gt;t_curr_res
op_assign
l_int|0
suffix:semicolon
id|tic-&gt;t_cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ungrant will give back unit_res * t_cnt. */
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_grant_log_space */
multiline_comment|/*&n; * Replenish the byte reservation required by moving the grant write head.&n; *&n; *&n; */
id|STATIC
r_int
DECL|function|xlog_regrant_write_log_space
id|xlog_regrant_write_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|tic
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
r_int
id|free_bytes
comma
id|need_bytes
suffix:semicolon
id|xlog_ticket_t
op_star
id|ntic
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_lsn_t
id|tail_lsn
suffix:semicolon
macro_line|#endif
id|tic-&gt;t_curr_res
op_assign
id|tic-&gt;t_unit_res
suffix:semicolon
r_if
c_cond
(paren
id|tic-&gt;t_cnt
OG
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|log-&gt;l_flags
op_amp
id|XLOG_ACTIVE_RECOVERY
)paren
id|panic
c_func
(paren
l_string|&quot;regrant Recovery problem&quot;
)paren
suffix:semicolon
macro_line|#endif
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_regrant_write_log_space: enter&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
r_goto
id|error_return
suffix:semicolon
multiline_comment|/* If there are other waiters on the queue then give them a&n;&t; * chance at logspace before us. Wake up the first waiters,&n;&t; * if we do not wake up all the waiters then go to sleep waiting&n;&t; * for more free space, otherwise try to get some space for&n;&t; * this transaction.&n;&t; */
r_if
c_cond
(paren
(paren
id|ntic
op_assign
id|log-&gt;l_write_headq
)paren
)paren
(brace
id|free_bytes
op_assign
id|xlog_space_left
c_func
(paren
id|log
comma
id|log-&gt;l_grant_write_cycle
comma
id|log-&gt;l_grant_write_bytes
)paren
suffix:semicolon
r_do
(brace
id|ASSERT
c_func
(paren
id|ntic-&gt;t_flags
op_amp
id|XLOG_TIC_PERM_RESERV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_bytes
OL
id|ntic-&gt;t_unit_res
)paren
r_break
suffix:semicolon
id|free_bytes
op_sub_assign
id|ntic-&gt;t_unit_res
suffix:semicolon
id|sv_signal
c_func
(paren
op_amp
id|ntic-&gt;t_sema
)paren
suffix:semicolon
id|ntic
op_assign
id|ntic-&gt;t_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ntic
op_ne
id|log-&gt;l_write_headq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntic
op_ne
id|log-&gt;l_write_headq
)paren
(brace
r_if
c_cond
(paren
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_IN_Q
)paren
op_eq
l_int|0
)paren
id|XLOG_INS_TICKETQ
c_func
(paren
id|log-&gt;l_write_headq
comma
id|tic
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_regrant_write_log_space: sleep 1&quot;
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_sleep_logspace
)paren
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
id|tic-&gt;t_sema
comma
id|PINOD
op_or
id|PLTWAIT
comma
op_amp
id|log-&gt;l_grant_lock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* If we&squot;re shutting down, this tic is already&n;&t;&t;&t; * off the queue */
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
(brace
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_regrant_write_log_space: wake 1&quot;
)paren
suffix:semicolon
id|xlog_grant_push_ail
c_func
(paren
id|log-&gt;l_mp
comma
id|tic-&gt;t_unit_res
)paren
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
id|need_bytes
op_assign
id|tic-&gt;t_unit_res
suffix:semicolon
id|redo
suffix:colon
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
r_goto
id|error_return
suffix:semicolon
id|free_bytes
op_assign
id|xlog_space_left
c_func
(paren
id|log
comma
id|log-&gt;l_grant_write_cycle
comma
id|log-&gt;l_grant_write_bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_bytes
OL
id|need_bytes
)paren
(brace
r_if
c_cond
(paren
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_IN_Q
)paren
op_eq
l_int|0
)paren
id|XLOG_INS_TICKETQ
c_func
(paren
id|log-&gt;l_write_headq
comma
id|tic
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_sleep_logspace
)paren
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
id|tic-&gt;t_sema
comma
id|PINOD
op_or
id|PLTWAIT
comma
op_amp
id|log-&gt;l_grant_lock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* If we&squot;re shutting down, this tic is already off the queue */
r_if
c_cond
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
(brace
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_goto
id|error_return
suffix:semicolon
)brace
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_regrant_write_log_space: wake 2&quot;
)paren
suffix:semicolon
id|xlog_grant_push_ail
c_func
(paren
id|log-&gt;l_mp
comma
id|need_bytes
)paren
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_goto
id|redo
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_IN_Q
)paren
id|XLOG_DEL_TICKETQ
c_func
(paren
id|log-&gt;l_write_headq
comma
id|tic
)paren
suffix:semicolon
id|XLOG_GRANT_ADD_SPACE
c_func
(paren
id|log
comma
id|need_bytes
comma
l_char|&squot;w&squot;
)paren
suffix:semicolon
multiline_comment|/* we&squot;ve got enough space */
macro_line|#ifdef DEBUG
id|tail_lsn
op_assign
id|log-&gt;l_tail_lsn
suffix:semicolon
r_if
c_cond
(paren
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
op_ne
id|log-&gt;l_grant_write_cycle
)paren
(brace
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_write_cycle
op_minus
l_int|1
op_eq
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_write_bytes
op_le
id|BBTOB
c_func
(paren
id|BLOCK_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_regrant_write_log_space: exit&quot;
)paren
suffix:semicolon
id|xlog_verify_grant_head
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|error_return
suffix:colon
r_if
c_cond
(paren
id|tic-&gt;t_flags
op_amp
id|XLOG_TIC_IN_Q
)paren
id|XLOG_DEL_TICKETQ
c_func
(paren
id|log-&gt;l_reserve_headq
comma
id|tic
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|tic
comma
l_string|&quot;xlog_regrant_write_log_space: err_ret&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are failing, make sure the ticket doesn&squot;t have any&n;&t; * current reservations. We don&squot;t want to add this back when&n;&t; * the ticket/transaction gets cancelled.&n;&t; */
id|tic-&gt;t_curr_res
op_assign
l_int|0
suffix:semicolon
id|tic-&gt;t_cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ungrant will give back unit_res * t_cnt. */
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_regrant_write_log_space */
multiline_comment|/* The first cnt-1 times through here we don&squot;t need to&n; * move the grant write head because the permanent&n; * reservation has reserved cnt times the unit amount.&n; * Release part of current permanent unit reservation and&n; * reset current reservation to be one units worth.  Also&n; * move grant reservation head forward.&n; */
id|STATIC
r_void
DECL|function|xlog_regrant_reserve_log_space
id|xlog_regrant_reserve_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|ticket
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|ticket
comma
l_string|&quot;xlog_regrant_reserve_log_space: enter&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticket-&gt;t_cnt
OG
l_int|0
)paren
id|ticket-&gt;t_cnt
op_decrement
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|XLOG_GRANT_SUB_SPACE
c_func
(paren
id|log
comma
id|ticket-&gt;t_curr_res
comma
l_char|&squot;w&squot;
)paren
suffix:semicolon
id|XLOG_GRANT_SUB_SPACE
c_func
(paren
id|log
comma
id|ticket-&gt;t_curr_res
comma
l_char|&squot;r&squot;
)paren
suffix:semicolon
id|ticket-&gt;t_curr_res
op_assign
id|ticket-&gt;t_unit_res
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|ticket
comma
l_string|&quot;xlog_regrant_reserve_log_space: sub current res&quot;
)paren
suffix:semicolon
id|xlog_verify_grant_head
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* just return if we still have some of the pre-reserved space */
r_if
c_cond
(paren
id|ticket-&gt;t_cnt
OG
l_int|0
)paren
(brace
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|XLOG_GRANT_ADD_SPACE
c_func
(paren
id|log
comma
id|ticket-&gt;t_unit_res
comma
l_char|&squot;r&squot;
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|ticket
comma
l_string|&quot;xlog_regrant_reserve_log_space: exit&quot;
)paren
suffix:semicolon
id|xlog_verify_grant_head
c_func
(paren
id|log
comma
l_int|0
)paren
suffix:semicolon
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
id|ticket-&gt;t_curr_res
op_assign
id|ticket-&gt;t_unit_res
suffix:semicolon
)brace
multiline_comment|/* xlog_regrant_reserve_log_space */
multiline_comment|/*&n; * Give back the space left from a reservation.&n; *&n; * All the information we need to make a correct determination of space left&n; * is present.  For non-permanent reservations, things are quite easy.  The&n; * count should have been decremented to zero.  We only need to deal with the&n; * space remaining in the current reservation part of the ticket.  If the&n; * ticket contains a permanent reservation, there may be left over space which&n; * needs to be released.  A count of N means that N-1 refills of the current&n; * reservation can be done before we need to ask for more space.  The first&n; * one goes to fill up the first current reservation.  Once we run out of&n; * space, the count will stay at zero and the only space remaining will be&n; * in the current reservation field.&n; */
id|STATIC
r_void
DECL|function|xlog_ungrant_log_space
id|xlog_ungrant_log_space
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|ticket
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticket-&gt;t_cnt
OG
l_int|0
)paren
id|ticket-&gt;t_cnt
op_decrement
suffix:semicolon
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|ticket
comma
l_string|&quot;xlog_ungrant_log_space: enter&quot;
)paren
suffix:semicolon
id|XLOG_GRANT_SUB_SPACE
c_func
(paren
id|log
comma
id|ticket-&gt;t_curr_res
comma
l_char|&squot;w&squot;
)paren
suffix:semicolon
id|XLOG_GRANT_SUB_SPACE
c_func
(paren
id|log
comma
id|ticket-&gt;t_curr_res
comma
l_char|&squot;r&squot;
)paren
suffix:semicolon
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|ticket
comma
l_string|&quot;xlog_ungrant_log_space: sub current&quot;
)paren
suffix:semicolon
multiline_comment|/* If this is a permanent reservation ticket, we may be able to free&n;&t; * up more space based on the remaining count.&n;&t; */
r_if
c_cond
(paren
id|ticket-&gt;t_cnt
OG
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|ticket-&gt;t_flags
op_amp
id|XLOG_TIC_PERM_RESERV
)paren
suffix:semicolon
id|XLOG_GRANT_SUB_SPACE
c_func
(paren
id|log
comma
id|ticket-&gt;t_unit_res
op_star
id|ticket-&gt;t_cnt
comma
l_char|&squot;w&squot;
)paren
suffix:semicolon
id|XLOG_GRANT_SUB_SPACE
c_func
(paren
id|log
comma
id|ticket-&gt;t_unit_res
op_star
id|ticket-&gt;t_cnt
comma
l_char|&squot;r&squot;
)paren
suffix:semicolon
)brace
id|xlog_trace_loggrant
c_func
(paren
id|log
comma
id|ticket
comma
l_string|&quot;xlog_ungrant_log_space: exit&quot;
)paren
suffix:semicolon
id|xlog_verify_grant_head
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
id|xfs_log_move_tail
c_func
(paren
id|log-&gt;l_mp
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_ungrant_log_space */
multiline_comment|/*&n; * Atomically put back used ticket.&n; */
r_void
DECL|function|xlog_state_put_ticket
id|xlog_state_put_ticket
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|tic
)paren
(brace
r_int
r_int
id|s
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|xlog_ticket_put
c_func
(paren
id|log
comma
id|tic
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_state_put_ticket */
multiline_comment|/*&n; * Flush iclog to disk if this is the last reference to the given iclog and&n; * the WANT_SYNC bit is set.&n; *&n; * When this function is entered, the iclog is not necessarily in the&n; * WANT_SYNC state.  It may be sitting around waiting to get filled.&n; *&n; *&n; */
r_int
DECL|function|xlog_state_release_iclog
id|xlog_state_release_iclog
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
r_int
id|sync
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do we sync? */
id|xlog_assign_tail_lsn
c_func
(paren
id|log-&gt;l_mp
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_refcnt
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_WANT_SYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|iclog-&gt;ic_refcnt
op_eq
l_int|0
op_logical_and
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_WANT_SYNC
)paren
(brace
id|sync
op_increment
suffix:semicolon
id|iclog-&gt;ic_state
op_assign
id|XLOG_STATE_SYNCING
suffix:semicolon
id|INT_SET
c_func
(paren
id|iclog-&gt;ic_header.h_tail_lsn
comma
id|ARCH_CONVERT
comma
id|log-&gt;l_tail_lsn
)paren
suffix:semicolon
id|xlog_verify_tail_lsn
c_func
(paren
id|log
comma
id|iclog
comma
id|log-&gt;l_tail_lsn
)paren
suffix:semicolon
multiline_comment|/* cycle incremented when incrementing curr_block */
)brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We let the log lock go, so it&squot;s possible that we hit a log I/O&n;&t; * error or someother SHUTDOWN condition that marks the iclog&n;&t; * as XLOG_STATE_IOERROR before the bwrite. However, we know that&n;&t; * this iclog has consistent data, so we ignore IOERROR&n;&t; * flags after this point.&n;&t; */
r_if
c_cond
(paren
id|sync
)paren
(brace
r_return
id|xlog_sync
c_func
(paren
id|log
comma
id|iclog
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_state_release_iclog */
multiline_comment|/*&n; * This routine will mark the current iclog in the ring as WANT_SYNC&n; * and move the current iclog pointer to the next iclog in the ring.&n; * When this routine is called from xlog_state_get_iclog_space(), the&n; * exact size of the iclog has not yet been determined.  All we know is&n; * that every data block.  We have run out of space in this log record.&n; */
id|STATIC
r_void
DECL|function|xlog_state_switch_iclogs
id|xlog_state_switch_iclogs
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
id|eventual_size
)paren
(brace
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eventual_size
)paren
id|eventual_size
op_assign
id|iclog-&gt;ic_offset
suffix:semicolon
id|iclog-&gt;ic_state
op_assign
id|XLOG_STATE_WANT_SYNC
suffix:semicolon
id|INT_SET
c_func
(paren
id|iclog-&gt;ic_header.h_prev_block
comma
id|ARCH_CONVERT
comma
id|log-&gt;l_prev_block
)paren
suffix:semicolon
id|log-&gt;l_prev_block
op_assign
id|log-&gt;l_curr_block
suffix:semicolon
id|log-&gt;l_prev_cycle
op_assign
id|log-&gt;l_curr_cycle
suffix:semicolon
multiline_comment|/* roll log?: ic_offset changed later */
id|log-&gt;l_curr_block
op_add_assign
id|BTOBB
c_func
(paren
id|eventual_size
)paren
op_plus
id|BTOBB
c_func
(paren
id|log-&gt;l_iclog_hsize
)paren
suffix:semicolon
multiline_comment|/* Round up to next log-sunit */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
op_logical_and
id|log-&gt;l_mp-&gt;m_sb.sb_logsunit
OG
l_int|1
)paren
(brace
id|__uint32_t
id|sunit_bb
op_assign
id|BTOBB
c_func
(paren
id|log-&gt;l_mp-&gt;m_sb.sb_logsunit
)paren
suffix:semicolon
id|log-&gt;l_curr_block
op_assign
id|roundup
c_func
(paren
id|log-&gt;l_curr_block
comma
id|sunit_bb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|log-&gt;l_curr_block
op_ge
id|log-&gt;l_logBBsize
)paren
(brace
id|log-&gt;l_curr_cycle
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_curr_cycle
op_eq
id|XLOG_HEADER_MAGIC_NUM
)paren
id|log-&gt;l_curr_cycle
op_increment
suffix:semicolon
id|log-&gt;l_curr_block
op_sub_assign
id|log-&gt;l_logBBsize
suffix:semicolon
id|ASSERT
c_func
(paren
id|log-&gt;l_curr_block
op_ge
l_int|0
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|iclog
op_eq
id|log-&gt;l_iclog
)paren
suffix:semicolon
id|log-&gt;l_iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
)brace
multiline_comment|/* xlog_state_switch_iclogs */
multiline_comment|/*&n; * Write out all data in the in-core log as of this exact moment in time.&n; *&n; * Data may be written to the in-core log during this call.  However,&n; * we don&squot;t guarantee this data will be written out.  A change from past&n; * implementation means this routine will *not* write out zero length LRs.&n; *&n; * Basically, we try and perform an intelligent scan of the in-core logs.&n; * If we determine there is no flushable data, we just return.  There is no&n; * flushable data if:&n; *&n; *&t;1. the current iclog is active and has no data; the previous iclog&n; *&t;&t;is in the active or dirty state.&n; *&t;2. the current iclog is drity, and the previous iclog is in the&n; *&t;&t;active or dirty state.&n; *&n; * We may sleep (call psema) if:&n; *&n; *&t;1. the current iclog is not in the active nor dirty state.&n; *&t;2. the current iclog dirty, and the previous iclog is not in the&n; *&t;&t;active nor dirty state.&n; *&t;3. the current iclog is active, and there is another thread writing&n; *&t;&t;to this particular iclog.&n; *&t;4. a) the current iclog is active and has no other writers&n; *&t;   b) when we return from flushing out this iclog, it is still&n; *&t;&t;not in the active nor dirty state.&n; */
id|STATIC
r_int
DECL|function|xlog_state_sync_all
id|xlog_state_sync_all
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|uint
id|flags
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
id|xfs_lsn_t
id|lsn
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* If the head iclog is not active nor dirty, we just attach&n;&t; * ourselves to the head and go to sleep.&n;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DIRTY
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the head is dirty or (active and empty), then&n;&t;&t; * we need to look at the previous iclog.  If the previous&n;&t;&t; * iclog is active or dirty we are done.  There is nothing&n;&t;&t; * to sync out.  Otherwise, we attach ourselves to the&n;&t;&t; * previous iclog and go to sleep.&n;&t;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DIRTY
op_logical_or
(paren
id|iclog-&gt;ic_refcnt
op_eq
l_int|0
op_logical_and
id|iclog-&gt;ic_offset
op_eq
l_int|0
)paren
)paren
(brace
id|iclog
op_assign
id|iclog-&gt;ic_prev
suffix:semicolon
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
op_logical_or
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DIRTY
)paren
r_goto
id|no_sleep
suffix:semicolon
r_else
r_goto
id|maybe_sleep
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|iclog-&gt;ic_refcnt
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We are the only one with access to this&n;&t;&t;&t;&t; * iclog.  Flush it out now.  There should&n;&t;&t;&t;&t; * be a roundoff of zero to show that someone&n;&t;&t;&t;&t; * has already taken care of the roundoff from&n;&t;&t;&t;&t; * the previous sync.&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_roundoff
op_eq
l_int|0
)paren
suffix:semicolon
id|iclog-&gt;ic_refcnt
op_increment
suffix:semicolon
id|lsn
op_assign
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xlog_state_switch_iclogs
c_func
(paren
id|log
comma
id|iclog
comma
l_int|0
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
op_eq
id|lsn
op_logical_and
id|iclog-&gt;ic_state
op_ne
id|XLOG_STATE_DIRTY
)paren
r_goto
id|maybe_sleep
suffix:semicolon
r_else
r_goto
id|no_sleep
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Someone else is writing to this iclog.&n;&t;&t;&t;&t; * Use its call to flush out the data.  However,&n;&t;&t;&t;&t; * the other thread may not force out this LR,&n;&t;&t;&t;&t; * so we mark it WANT_SYNC.&n;&t;&t;&t;&t; */
id|xlog_state_switch_iclogs
c_func
(paren
id|log
comma
id|iclog
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|maybe_sleep
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* By the time we come around again, the iclog could&squot;ve been filled&n;&t; * which would give it another lsn.  If we have a new lsn, just&n;&t; * return because the relevant data has been flushed.&n;&t; */
id|maybe_sleep
suffix:colon
r_if
c_cond
(paren
id|flags
op_amp
id|XFS_LOG_SYNC
)paren
(brace
multiline_comment|/*&n;&t;&t; * We must check if we&squot;re shutting down here, before&n;&t;&t; * we wait, while we&squot;re holding the LOG_LOCK.&n;&t;&t; * Then we check again after waking up, in case our&n;&t;&t; * sleep was disturbed by a bad news.&n;&t;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|XFS_STATS_INC
c_func
(paren
id|xs_log_force_sleep
)paren
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
id|iclog-&gt;ic_forcesema
comma
id|PINOD
comma
op_amp
id|log-&gt;l_icloglock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No need to grab the log lock here since we&squot;re&n;&t;&t; * only deciding whether or not to return EIO&n;&t;&t; * and the memory read should be atomic.&n;&t;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
id|no_sleep
suffix:colon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* xlog_state_sync_all */
multiline_comment|/*&n; * Used by code which implements synchronous log forces.&n; *&n; * Find in-core log with lsn.&n; *&t;If it is in the DIRTY state, just return.&n; *&t;If it is in the ACTIVE state, move the in-core log into the WANT_SYNC&n; *&t;&t;state and go to sleep or return.&n; *&t;If it is in any other state, go to sleep or return.&n; *&n; * If filesystem activity goes to zero, the iclog will get flushed only by&n; * bdflush().&n; */
r_int
DECL|function|xlog_state_sync
id|xlog_state_sync
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xfs_lsn_t
id|lsn
comma
id|uint
id|flags
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
r_int
id|already_slept
op_assign
l_int|0
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|try_again
suffix:colon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
op_ne
id|lsn
)paren
(brace
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_DIRTY
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
)paren
(brace
multiline_comment|/*&n;&t;&t; * We sleep here if we haven&squot;t already slept (e.g.&n;&t;&t; * this is the first time we&squot;ve looked at the correct&n;&t;&t; * iclog buf) and the buffer before us is going to&n;&t;&t; * be sync&squot;ed. The reason for this is that if we&n;&t;&t; * are doing sync transactions here, by waiting for&n;&t;&t; * the previous I/O to complete, we can allow a few&n;&t;&t; * more transactions into this iclog before we close&n;&t;&t; * it down.&n;&t;&t; *&n;&t;&t; * Otherwise, we mark the buffer WANT_SYNC, and bump&n;&t;&t; * up the refcnt so we can release the log (which drops&n;&t;&t; * the ref count).  The state switch keeps new transaction&n;&t;&t; * commits from using this buffer.  When the current commits&n;&t;&t; * finish writing into the buffer, the refcount will drop to&n;&t;&t; * zero and the buffer will go out then.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|already_slept
op_logical_and
(paren
id|iclog-&gt;ic_prev-&gt;ic_state
op_amp
(paren
id|XLOG_STATE_WANT_SYNC
op_or
id|XLOG_STATE_SYNCING
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_log_force_sleep
)paren
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
id|iclog-&gt;ic_prev-&gt;ic_writesema
comma
id|PSWP
comma
op_amp
id|log-&gt;l_icloglock
comma
id|s
)paren
suffix:semicolon
id|already_slept
op_assign
l_int|1
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
r_else
(brace
id|iclog-&gt;ic_refcnt
op_increment
suffix:semicolon
id|xlog_state_switch_iclogs
c_func
(paren
id|log
comma
id|iclog
comma
l_int|0
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xlog_state_release_iclog
c_func
(paren
id|log
comma
id|iclog
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|XFS_LOG_SYNC
)paren
op_logical_and
multiline_comment|/* sleep */
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_amp
(paren
id|XLOG_STATE_ACTIVE
op_or
id|XLOG_STATE_DIRTY
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t wait on the forcesema if we know that we&squot;ve&n;&t;&t; * gotten a log write error.&n;&t;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|XFS_STATS_INC
c_func
(paren
id|xs_log_force_sleep
)paren
suffix:semicolon
id|sv_wait
c_func
(paren
op_amp
id|iclog-&gt;ic_forcesema
comma
id|PSWP
comma
op_amp
id|log-&gt;l_icloglock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * No need to grab the log lock here since we&squot;re&n;&t;&t; * only deciding whether or not to return EIO&n;&t;&t; * and the memory read should be atomic.&n;&t;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* just return */
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|iclog
op_ne
id|log-&gt;l_iclog
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_state_sync */
multiline_comment|/*&n; * Called when we want to mark the current iclog as being ready to sync to&n; * disk.&n; */
r_void
DECL|function|xlog_state_want_sync
id|xlog_state_want_sync
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
(brace
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iclog-&gt;ic_state
op_eq
id|XLOG_STATE_ACTIVE
)paren
(brace
id|xlog_state_switch_iclogs
c_func
(paren
id|log
comma
id|iclog
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_state
op_amp
(paren
id|XLOG_STATE_WANT_SYNC
op_or
id|XLOG_STATE_IOERROR
)paren
)paren
suffix:semicolon
)brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_state_want_sync */
multiline_comment|/*****************************************************************************&n; *&n; *&t;&t;TICKET functions&n; *&n; *****************************************************************************&n; */
multiline_comment|/*&n; *&t;Algorithm doesn&squot;t take into account page size. ;-(&n; */
id|STATIC
r_void
DECL|function|xlog_state_ticket_alloc
id|xlog_state_ticket_alloc
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xlog_ticket_t
op_star
id|t_list
suffix:semicolon
id|xlog_ticket_t
op_star
id|next
suffix:semicolon
id|xfs_caddr_t
id|buf
suffix:semicolon
id|uint
id|i
op_assign
(paren
id|NBPP
op_div
r_sizeof
(paren
id|xlog_ticket_t
)paren
)paren
op_minus
l_int|2
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The kmem_zalloc may sleep, so we shouldn&squot;t be holding the&n;&t; * global lock.  XXXmiken: may want to use zone allocator.&n;&t; */
id|buf
op_assign
(paren
id|xfs_caddr_t
)paren
id|kmem_zalloc
c_func
(paren
id|NBPP
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* Attach 1st ticket to Q, so we can keep track of allocated memory */
id|t_list
op_assign
(paren
id|xlog_ticket_t
op_star
)paren
id|buf
suffix:semicolon
id|t_list-&gt;t_next
op_assign
id|log-&gt;l_unmount_free
suffix:semicolon
id|log-&gt;l_unmount_free
op_assign
id|t_list
op_increment
suffix:semicolon
id|log-&gt;l_ticket_cnt
op_increment
suffix:semicolon
id|log-&gt;l_ticket_tcnt
op_increment
suffix:semicolon
multiline_comment|/* Next ticket becomes first ticket attached to ticket free list */
r_if
c_cond
(paren
id|log-&gt;l_freelist
op_ne
l_int|NULL
)paren
(brace
id|ASSERT
c_func
(paren
id|log-&gt;l_tail
op_ne
l_int|NULL
)paren
suffix:semicolon
id|log-&gt;l_tail-&gt;t_next
op_assign
id|t_list
suffix:semicolon
)brace
r_else
(brace
id|log-&gt;l_freelist
op_assign
id|t_list
suffix:semicolon
)brace
id|log-&gt;l_ticket_cnt
op_increment
suffix:semicolon
id|log-&gt;l_ticket_tcnt
op_increment
suffix:semicolon
multiline_comment|/* Cycle through rest of alloc&squot;ed memory, building up free Q */
r_for
c_loop
(paren
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|next
op_assign
id|t_list
op_plus
l_int|1
suffix:semicolon
id|t_list-&gt;t_next
op_assign
id|next
suffix:semicolon
id|t_list
op_assign
id|next
suffix:semicolon
id|log-&gt;l_ticket_cnt
op_increment
suffix:semicolon
id|log-&gt;l_ticket_tcnt
op_increment
suffix:semicolon
)brace
id|t_list-&gt;t_next
op_assign
l_int|0
suffix:semicolon
id|log-&gt;l_tail
op_assign
id|t_list
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_state_ticket_alloc */
multiline_comment|/*&n; * Put ticket into free list&n; *&n; * Assumption: log lock is held around this call.&n; */
id|STATIC
r_void
DECL|function|xlog_ticket_put
id|xlog_ticket_put
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_ticket_t
op_star
id|ticket
)paren
(brace
id|sv_destroy
c_func
(paren
op_amp
id|ticket-&gt;t_sema
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t think caching will make that much difference.  It&squot;s&n;&t; * more important to make debug easier.&n;&t; */
macro_line|#if 0
multiline_comment|/* real code will want to use LIFO for caching */
id|ticket-&gt;t_next
op_assign
id|log-&gt;l_freelist
suffix:semicolon
id|log-&gt;l_freelist
op_assign
id|ticket
suffix:semicolon
multiline_comment|/* no need to clear fields */
macro_line|#else
multiline_comment|/* When we debug, it is easier if tickets are cycled */
id|ticket-&gt;t_next
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_tail
op_ne
l_int|0
)paren
(brace
id|log-&gt;l_tail-&gt;t_next
op_assign
id|ticket
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|log-&gt;l_freelist
op_eq
l_int|0
)paren
suffix:semicolon
id|log-&gt;l_freelist
op_assign
id|ticket
suffix:semicolon
)brace
id|log-&gt;l_tail
op_assign
id|ticket
suffix:semicolon
macro_line|#endif /* DEBUG */
id|log-&gt;l_ticket_cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* xlog_ticket_put */
multiline_comment|/*&n; * Grab ticket off freelist or allocation some more&n; */
id|xlog_ticket_t
op_star
DECL|function|xlog_ticket_get
id|xlog_ticket_get
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|unit_bytes
comma
r_int
id|cnt
comma
r_char
id|client
comma
id|uint
id|xflags
)paren
(brace
id|xlog_ticket_t
op_star
id|tic
suffix:semicolon
id|uint
id|num_headers
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|alloc
suffix:colon
r_if
c_cond
(paren
id|log-&gt;l_freelist
op_eq
l_int|NULL
)paren
id|xlog_state_ticket_alloc
c_func
(paren
id|log
)paren
suffix:semicolon
multiline_comment|/* potentially sleep */
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_freelist
op_eq
l_int|NULL
)paren
(brace
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_goto
id|alloc
suffix:semicolon
)brace
id|tic
op_assign
id|log-&gt;l_freelist
suffix:semicolon
id|log-&gt;l_freelist
op_assign
id|tic-&gt;t_next
suffix:semicolon
r_if
c_cond
(paren
id|log-&gt;l_freelist
op_eq
l_int|NULL
)paren
id|log-&gt;l_tail
op_assign
l_int|NULL
suffix:semicolon
id|log-&gt;l_ticket_cnt
op_decrement
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Permanent reservations have up to &squot;cnt&squot;-1 active log operations&n;&t; * in the log.  A unit in this case is the amount of space for one&n;&t; * of these log operations.  Normal reservations have a cnt of 1&n;&t; * and their unit amount is the total amount of space required.&n;&t; *&n;&t; * The following lines of code account for non-transaction data&n;&t; * which occupy space in the on-disk log. &n;&t; */
multiline_comment|/* for start-rec */
id|unit_bytes
op_add_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
multiline_comment|/* for padding */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|log-&gt;l_mp-&gt;m_sb
)paren
op_logical_and
id|log-&gt;l_mp-&gt;m_sb.sb_logsunit
OG
l_int|1
)paren
(brace
multiline_comment|/* log su roundoff */
id|unit_bytes
op_add_assign
id|log-&gt;l_mp-&gt;m_sb.sb_logsunit
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* BB roundoff */
id|unit_bytes
op_add_assign
id|BBSIZE
suffix:semicolon
)brace
multiline_comment|/* for commit-rec */
id|unit_bytes
op_add_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
suffix:semicolon
multiline_comment|/* for LR headers */
id|num_headers
op_assign
(paren
(paren
id|unit_bytes
op_plus
id|log-&gt;l_iclog_size
op_minus
l_int|1
)paren
op_rshift
id|log-&gt;l_iclog_size_log
)paren
suffix:semicolon
id|unit_bytes
op_add_assign
id|log-&gt;l_iclog_hsize
op_star
id|num_headers
suffix:semicolon
id|tic-&gt;t_unit_res
op_assign
id|unit_bytes
suffix:semicolon
id|tic-&gt;t_curr_res
op_assign
id|unit_bytes
suffix:semicolon
id|tic-&gt;t_cnt
op_assign
id|cnt
suffix:semicolon
id|tic-&gt;t_ocnt
op_assign
id|cnt
suffix:semicolon
id|tic-&gt;t_tid
op_assign
(paren
id|xlog_tid_t
)paren
(paren
(paren
id|__psint_t
)paren
id|tic
op_amp
l_int|0xffffffff
)paren
suffix:semicolon
id|tic-&gt;t_clientid
op_assign
id|client
suffix:semicolon
id|tic-&gt;t_flags
op_assign
id|XLOG_TIC_INITED
suffix:semicolon
r_if
c_cond
(paren
id|xflags
op_amp
id|XFS_LOG_PERM_RESERV
)paren
id|tic-&gt;t_flags
op_or_assign
id|XLOG_TIC_PERM_RESERV
suffix:semicolon
id|sv_init
c_func
(paren
op_amp
(paren
id|tic-&gt;t_sema
)paren
comma
id|SV_DEFAULT
comma
l_string|&quot;logtick&quot;
)paren
suffix:semicolon
r_return
id|tic
suffix:semicolon
)brace
multiline_comment|/* xlog_ticket_get */
multiline_comment|/******************************************************************************&n; *&n; *&t;&t;Log debug routines&n; *&n; ******************************************************************************&n; */
macro_line|#if defined(DEBUG) &amp;&amp; !defined(XLOG_NOLOG)
multiline_comment|/*&n; * Make sure that the destination ptr is within the valid data region of&n; * one of the iclogs.  This uses backup pointers stored in a different&n; * part of the log in case we trash the log structure.&n; */
r_void
DECL|function|xlog_verify_dest_ptr
id|xlog_verify_dest_ptr
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|__psint_t
id|ptr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|good_ptr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|log-&gt;l_iclog_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ptr
op_ge
(paren
id|__psint_t
)paren
id|log-&gt;l_iclog_bak
(braket
id|i
)braket
op_logical_and
id|ptr
op_le
(paren
id|__psint_t
)paren
id|log-&gt;l_iclog_bak
(braket
id|i
)braket
op_plus
id|log-&gt;l_iclog_size
)paren
id|good_ptr
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|good_ptr
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_dest_ptr: invalid ptr&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* xlog_verify_dest_ptr */
macro_line|#ifdef DEBUG
multiline_comment|/* check split LR write */
id|STATIC
r_void
DECL|function|xlog_verify_disk_cycle_no
id|xlog_verify_disk_cycle_no
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|uint
id|cycle_no
suffix:semicolon
id|xfs_caddr_t
id|ptr
suffix:semicolon
id|xfs_daddr_t
id|i
suffix:semicolon
r_if
c_cond
(paren
id|BLOCK_LSN
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
OL
l_int|10
)paren
(brace
id|cycle_no
op_assign
id|CYCLE_LSN
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bp
op_assign
id|xlog_get_bp
c_func
(paren
id|log
comma
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|BLOCK_LSN
c_func
(paren
id|iclog-&gt;ic_header.h_lsn
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xlog_bread
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
id|ptr
op_assign
id|xlog_align
c_func
(paren
id|log
comma
id|i
comma
l_int|1
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GET_CYCLE
c_func
(paren
id|ptr
comma
id|ARCH_CONVERT
)paren
op_ne
id|cycle_no
)paren
id|xlog_warn
c_func
(paren
l_string|&quot;XFS: xlog_verify_disk_cycle_no: bad cycle no&quot;
)paren
suffix:semicolon
)brace
id|xlog_put_bp
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* xlog_verify_disk_cycle_no */
macro_line|#endif
id|STATIC
r_void
DECL|function|xlog_verify_grant_head
id|xlog_verify_grant_head
c_func
(paren
id|xlog_t
op_star
id|log
comma
r_int
id|equals
)paren
(brace
r_if
c_cond
(paren
id|log-&gt;l_grant_reserve_cycle
op_eq
id|log-&gt;l_grant_write_cycle
)paren
(brace
r_if
c_cond
(paren
id|equals
)paren
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_reserve_bytes
op_ge
id|log-&gt;l_grant_write_bytes
)paren
suffix:semicolon
r_else
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_reserve_bytes
OG
id|log-&gt;l_grant_write_bytes
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_reserve_cycle
op_minus
l_int|1
op_eq
id|log-&gt;l_grant_write_cycle
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|log-&gt;l_grant_write_bytes
op_ge
id|log-&gt;l_grant_reserve_bytes
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* xlog_verify_grant_head */
multiline_comment|/* check if it will fit */
id|STATIC
r_void
DECL|function|xlog_verify_tail_lsn
id|xlog_verify_tail_lsn
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
id|xfs_lsn_t
id|tail_lsn
)paren
(brace
r_int
id|blocks
suffix:semicolon
r_if
c_cond
(paren
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
op_eq
id|log-&gt;l_prev_cycle
)paren
(brace
id|blocks
op_assign
id|log-&gt;l_logBBsize
op_minus
(paren
id|log-&gt;l_prev_block
op_minus
id|BLOCK_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OL
id|BTOBB
c_func
(paren
id|iclog-&gt;ic_offset
)paren
op_plus
id|BTOBB
c_func
(paren
id|log-&gt;l_iclog_hsize
)paren
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_tail_lsn: ran out of log space&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|CYCLE_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
op_plus
l_int|1
op_eq
id|log-&gt;l_prev_cycle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BLOCK_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
op_eq
id|log-&gt;l_prev_block
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_tail_lsn: tail wrapped&quot;
)paren
suffix:semicolon
id|blocks
op_assign
id|BLOCK_LSN
c_func
(paren
id|tail_lsn
comma
id|ARCH_NOCONVERT
)paren
op_minus
id|log-&gt;l_prev_block
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OL
id|BTOBB
c_func
(paren
id|iclog-&gt;ic_offset
)paren
op_plus
l_int|1
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_tail_lsn: ran out of log space&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* xlog_verify_tail_lsn */
multiline_comment|/*&n; * Perform a number of checks on the iclog before writing to disk.&n; *&n; * 1. Make sure the iclogs are still circular&n; * 2. Make sure we have a good magic number&n; * 3. Make sure we don&squot;t have magic numbers in the data&n; * 4. Check fields of each log operation header for:&n; *&t;A. Valid client identifier&n; *&t;B. tid ptr value falls in valid ptr space (user space code)&n; *&t;C. Length in log record header is correct according to the&n; *&t;&t;individual operation headers within record.&n; * 5. When a bwrite will occur within 5 blocks of the front of the physical&n; *&t;log, check the preceding blocks of the physical log to make sure all&n; *&t;the cycle numbers agree with the current cycle number.&n; */
id|STATIC
r_void
DECL|function|xlog_verify_iclog
id|xlog_verify_iclog
c_func
(paren
id|xlog_t
op_star
id|log
comma
id|xlog_in_core_t
op_star
id|iclog
comma
r_int
id|count
comma
id|boolean_t
id|syncing
)paren
(brace
id|xlog_op_header_t
op_star
id|ophead
suffix:semicolon
id|xlog_in_core_t
op_star
id|icptr
suffix:semicolon
id|xlog_in_core_2_t
op_star
id|xhdr
suffix:semicolon
id|xfs_caddr_t
id|ptr
suffix:semicolon
id|xfs_caddr_t
id|base_ptr
suffix:semicolon
id|__psint_t
id|field_offset
suffix:semicolon
id|__uint8_t
id|clientid
suffix:semicolon
r_int
id|len
comma
id|i
comma
id|j
comma
id|k
comma
id|op_len
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
multiline_comment|/* check validity of iclog pointers */
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|icptr
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|log-&gt;l_iclog_bufs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|icptr
op_eq
l_int|0
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_iclog: invalid ptr&quot;
)paren
suffix:semicolon
id|icptr
op_assign
id|icptr-&gt;ic_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|icptr
op_ne
id|log-&gt;l_iclog
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_iclog: corrupt iclog ring&quot;
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
multiline_comment|/* check log magic numbers */
id|ptr
op_assign
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|iclog-&gt;ic_header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|ptr
comma
id|ARCH_CONVERT
)paren
op_ne
id|XLOG_HEADER_MAGIC_NUM
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_iclog: invalid magic num&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_add_assign
id|BBSIZE
suffix:semicolon
id|ptr
OL
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|iclog-&gt;ic_header
)paren
)paren
op_plus
id|count
suffix:semicolon
id|ptr
op_add_assign
id|BBSIZE
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
op_star
(paren
id|uint
op_star
)paren
id|ptr
comma
id|ARCH_CONVERT
)paren
op_eq
id|XLOG_HEADER_MAGIC_NUM
)paren
id|xlog_panic
c_func
(paren
l_string|&quot;xlog_verify_iclog: unexpected magic num&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* check fields */
id|len
op_assign
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_num_logops
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ptr
op_assign
id|iclog-&gt;ic_datap
suffix:semicolon
id|base_ptr
op_assign
id|ptr
suffix:semicolon
id|ophead
op_assign
(paren
id|xlog_op_header_t
op_star
)paren
id|ptr
suffix:semicolon
id|xhdr
op_assign
(paren
id|xlog_in_core_2_t
op_star
)paren
op_amp
id|iclog-&gt;ic_header
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ophead
op_assign
(paren
id|xlog_op_header_t
op_star
)paren
id|ptr
suffix:semicolon
multiline_comment|/* clientid is only 1 byte */
id|field_offset
op_assign
(paren
id|__psint_t
)paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|ophead-&gt;oh_clientid
)paren
op_minus
id|base_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|syncing
op_eq
id|B_FALSE
op_logical_or
(paren
id|field_offset
op_amp
l_int|0x1ff
)paren
)paren
(brace
id|clientid
op_assign
id|ophead-&gt;oh_clientid
suffix:semicolon
)brace
r_else
(brace
id|idx
op_assign
id|BTOBBT
c_func
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|ophead-&gt;oh_clientid
)paren
op_minus
id|iclog-&gt;ic_datap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
)paren
(brace
id|j
op_assign
id|idx
op_div
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|k
op_assign
id|idx
op_mod
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|clientid
op_assign
id|GET_CLIENT_ID
c_func
(paren
id|xhdr
(braket
id|j
)braket
dot
id|hic_xheader.xh_cycle_data
(braket
id|k
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
(brace
id|clientid
op_assign
id|GET_CLIENT_ID
c_func
(paren
id|iclog-&gt;ic_header.h_cycle_data
(braket
id|idx
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|clientid
op_ne
id|XFS_TRANSACTION
op_logical_and
id|clientid
op_ne
id|XFS_LOG
)paren
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xlog_verify_iclog: invalid clientid %d op 0x%p offset 0x%x&quot;
comma
id|clientid
comma
id|ophead
comma
id|field_offset
)paren
suffix:semicolon
multiline_comment|/* check length */
id|field_offset
op_assign
(paren
id|__psint_t
)paren
(paren
(paren
id|xfs_caddr_t
)paren
op_amp
(paren
id|ophead-&gt;oh_len
)paren
op_minus
id|base_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|syncing
op_eq
id|B_FALSE
op_logical_or
(paren
id|field_offset
op_amp
l_int|0x1ff
)paren
)paren
(brace
id|op_len
op_assign
id|INT_GET
c_func
(paren
id|ophead-&gt;oh_len
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
(brace
id|idx
op_assign
id|BTOBBT
c_func
(paren
(paren
id|__psint_t
)paren
op_amp
id|ophead-&gt;oh_len
op_minus
(paren
id|__psint_t
)paren
id|iclog-&gt;ic_datap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
op_ge
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
)paren
(brace
id|j
op_assign
id|idx
op_div
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|k
op_assign
id|idx
op_mod
(paren
id|XLOG_HEADER_CYCLE_SIZE
op_div
id|BBSIZE
)paren
suffix:semicolon
id|op_len
op_assign
id|INT_GET
c_func
(paren
id|xhdr
(braket
id|j
)braket
dot
id|hic_xheader.xh_cycle_data
(braket
id|k
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
(brace
id|op_len
op_assign
id|INT_GET
c_func
(paren
id|iclog-&gt;ic_header.h_cycle_data
(braket
id|idx
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
)brace
id|ptr
op_add_assign
r_sizeof
(paren
id|xlog_op_header_t
)paren
op_plus
id|op_len
suffix:semicolon
)brace
)brace
multiline_comment|/* xlog_verify_iclog */
macro_line|#endif /* DEBUG &amp;&amp; !XLOG_NOLOG */
multiline_comment|/*&n; * Mark all iclogs IOERROR. LOG_LOCK is held by the caller.&n; */
id|STATIC
r_int
DECL|function|xlog_state_ioerror
id|xlog_state_ioerror
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
comma
op_star
id|ic
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mark all the incore logs IOERROR.&n;&t;&t; * From now on, no log flushes will result.&n;&t;&t; */
id|ic
op_assign
id|iclog
suffix:semicolon
r_do
(brace
id|ic-&gt;ic_state
op_assign
id|XLOG_STATE_IOERROR
suffix:semicolon
id|ic
op_assign
id|ic-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ic
op_ne
id|iclog
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return non-zero, if state transition has already happened.&n;&t; */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from xfs_force_shutdown, when we&squot;re forcibly&n; * shutting down the filesystem, typically because of an IO error.&n; * Our main objectives here are to make sure that:&n; *&t;a. the filesystem gets marked &squot;SHUTDOWN&squot; for all interested&n; *&t;   parties to find out, &squot;atomically&squot;.&n; *&t;b. those who&squot;re sleeping on log reservations, pinned objects and&n; *&t;    other resources get woken up, and be told the bad news.&n; *&t;c. nothing new gets queued up after (a) and (b) are done.&n; *&t;d. if !logerror, flush the iclogs to disk, then seal them off&n; *&t;   for business.&n; */
r_int
DECL|function|xfs_log_force_umount
id|xfs_log_force_umount
c_func
(paren
r_struct
id|xfs_mount
op_star
id|mp
comma
r_int
id|logerror
)paren
(brace
id|xlog_ticket_t
op_star
id|tic
suffix:semicolon
id|xlog_t
op_star
id|log
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s2
)paren
suffix:semicolon
id|log
op_assign
id|mp-&gt;m_log
suffix:semicolon
multiline_comment|/*&n;&t; * If this happens during log recovery, don&squot;t worry about&n;&t; * locking; the log isn&squot;t open for business yet.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|log
op_logical_or
id|log-&gt;l_flags
op_amp
id|XLOG_ACTIVE_RECOVERY
)paren
(brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_FS_SHUTDOWN
suffix:semicolon
id|XFS_BUF_DONE
c_func
(paren
id|mp-&gt;m_sb_bp
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Somebody could&squot;ve already done the hard work for us.&n;&t; * No need to get locks for this.&n;&t; */
r_if
c_cond
(paren
id|logerror
op_logical_and
id|log-&gt;l_iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
(brace
id|ASSERT
c_func
(paren
id|XLOG_FORCED_SHUTDOWN
c_func
(paren
id|log
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We must hold both the GRANT lock and the LOG lock,&n;&t; * before we mark the filesystem SHUTDOWN and wake&n;&t; * everybody up to tell the bad news.&n;&t; */
id|s
op_assign
id|GRANT_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|s2
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_FS_SHUTDOWN
suffix:semicolon
id|XFS_BUF_DONE
c_func
(paren
id|mp-&gt;m_sb_bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This flag is sort of redundant because of the mount flag, but&n;&t; * it&squot;s good to maintain the separation between the log and the rest&n;&t; * of XFS.&n;&t; */
id|log-&gt;l_flags
op_or_assign
id|XLOG_IO_ERROR
suffix:semicolon
multiline_comment|/*&n;&t; * If we hit a log error, we want to mark all the iclogs IOERROR&n;&t; * while we&squot;re still holding the loglock.&n;&t; */
r_if
c_cond
(paren
id|logerror
)paren
id|retval
op_assign
id|xlog_state_ioerror
c_func
(paren
id|log
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t want anybody waiting for log reservations&n;&t; * after this. That means we have to wake up everybody&n;&t; * queued up on reserve_headq as well as write_headq.&n;&t; * In addition, we make sure in xlog_{re}grant_log_space&n;&t; * that we don&squot;t enqueue anything once the SHUTDOWN flag&n;&t; * is set, and this action is protected by the GRANTLOCK.&n;&t; */
r_if
c_cond
(paren
(paren
id|tic
op_assign
id|log-&gt;l_reserve_headq
)paren
)paren
(brace
r_do
(brace
id|sv_signal
c_func
(paren
op_amp
id|tic-&gt;t_sema
)paren
suffix:semicolon
id|tic
op_assign
id|tic-&gt;t_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tic
op_ne
id|log-&gt;l_reserve_headq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tic
op_assign
id|log-&gt;l_write_headq
)paren
)paren
(brace
r_do
(brace
id|sv_signal
c_func
(paren
op_amp
id|tic-&gt;t_sema
)paren
suffix:semicolon
id|tic
op_assign
id|tic-&gt;t_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tic
op_ne
id|log-&gt;l_write_headq
)paren
suffix:semicolon
)brace
id|GRANT_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|log-&gt;l_iclog-&gt;ic_state
op_amp
id|XLOG_STATE_IOERROR
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
id|logerror
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Force the incore logs to disk before shutting the&n;&t;&t; * log down completely.&n;&t;&t; */
id|xlog_state_sync_all
c_func
(paren
id|log
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
id|s2
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|retval
op_assign
id|xlog_state_ioerror
c_func
(paren
id|log
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Wake up everybody waiting on xfs_log_force.&n;&t; * Callback all log item committed functions as if the&n;&t; * log writes were completed.&n;&t; */
id|xlog_state_do_callback
c_func
(paren
id|log
comma
id|XFS_LI_ABORTED
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef XFSERRORDEBUG
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
id|s
op_assign
id|LOG_LOCK
c_func
(paren
id|log
)paren
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_do
(brace
id|ASSERT
c_func
(paren
id|iclog-&gt;ic_callback
op_eq
l_int|0
)paren
suffix:semicolon
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|iclog
op_ne
id|log-&gt;l_iclog
)paren
suffix:semicolon
id|LOG_UNLOCK
c_func
(paren
id|log
comma
id|s
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* return non-zero if log IOERROR transition had already happened */
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
r_int
DECL|function|xlog_iclogs_empty
id|xlog_iclogs_empty
c_func
(paren
id|xlog_t
op_star
id|log
)paren
(brace
id|xlog_in_core_t
op_star
id|iclog
suffix:semicolon
id|iclog
op_assign
id|log-&gt;l_iclog
suffix:semicolon
r_do
(brace
multiline_comment|/* endianness does not matter here, zero is zero in&n;&t;&t; * any language.&n;&t;&t; */
r_if
c_cond
(paren
id|iclog-&gt;ic_header.h_num_logops
)paren
r_return
l_int|0
suffix:semicolon
id|iclog
op_assign
id|iclog-&gt;ic_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|iclog
op_ne
id|log-&gt;l_iclog
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
