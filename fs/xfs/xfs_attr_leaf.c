multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * xfs_attr_leaf.c&n; *&n; * GROT: figure out how to recover gracefully when bmap returns ENOSPC.&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_attr_leaf.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
multiline_comment|/*&n; * xfs_attr_leaf.c&n; *&n; * Routines to implement leaf blocks of attributes as Btrees of hashed names.&n; */
multiline_comment|/*========================================================================&n; * Function prototypes for the kernel.&n; *========================================================================*/
multiline_comment|/*&n; * Routines used for growing the Btree.&n; */
id|STATIC
r_int
id|xfs_attr_leaf_add_work
c_func
(paren
id|xfs_dabuf_t
op_star
id|leaf_buffer
comma
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|freemap_index
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_attr_leaf_compact
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_dabuf_t
op_star
id|leaf_buffer
)paren
suffix:semicolon
id|STATIC
r_void
id|xfs_attr_leaf_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_attr_leaf_figure_balance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|leaf_blk_1
comma
id|xfs_da_state_blk_t
op_star
id|leaf_blk_2
comma
r_int
op_star
id|number_entries_in_blk1
comma
r_int
op_star
id|number_usedbytes_in_blk1
)paren
suffix:semicolon
multiline_comment|/*&n; * Utility routines.&n; */
id|STATIC
r_void
id|xfs_attr_leaf_moveents
c_func
(paren
id|xfs_attr_leafblock_t
op_star
id|src_leaf
comma
r_int
id|src_start
comma
id|xfs_attr_leafblock_t
op_star
id|dst_leaf
comma
r_int
id|dst_start
comma
r_int
id|move_count
comma
id|xfs_mount_t
op_star
id|mp
)paren
suffix:semicolon
multiline_comment|/*========================================================================&n; * External routines when dirsize &lt; XFS_LITINO(mp).&n; *========================================================================*/
multiline_comment|/*&n; * Create the initial contents of a shortform attribute list.&n; */
r_int
DECL|function|xfs_attr_shortform_create
id|xfs_attr_shortform_create
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_sf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ifp
op_assign
id|dp-&gt;i_afp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_bytes
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dp-&gt;i_d.di_aformat
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
(brace
id|ifp-&gt;if_flags
op_and_assign
op_complement
id|XFS_IFEXTENTS
suffix:semicolon
multiline_comment|/* just in case */
id|dp-&gt;i_d.di_aformat
op_assign
id|XFS_DINODE_FMT_LOCAL
suffix:semicolon
id|ifp-&gt;if_flags
op_or_assign
id|XFS_IFINLINE
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
)brace
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
r_sizeof
(paren
op_star
id|hdr
)paren
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
id|hdr
op_assign
(paren
id|xfs_attr_sf_hdr_t
op_star
)paren
id|ifp-&gt;if_u1.if_data
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;totsize
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_ADATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a name/value pair to the shortform attribute list.&n; * Overflow from the inode has already been checked for.&n; */
r_int
DECL|function|xfs_attr_shortform_add
id|xfs_attr_shortform_add
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_attr_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|i
comma
id|offset
comma
id|size
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ifp
op_assign
id|dp-&gt;i_afp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|ifp-&gt;if_u1.if_data
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_ne
id|args-&gt;namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfe-&gt;nameval
comma
id|args-&gt;namelen
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
id|offset
op_assign
(paren
r_char
op_star
)paren
id|sfe
op_minus
(paren
r_char
op_star
)paren
id|sf
suffix:semicolon
id|size
op_assign
id|XFS_ATTR_SF_ENTSIZE_BYNAME
c_func
(paren
id|args-&gt;namelen
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|size
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|ifp-&gt;if_u1.if_data
suffix:semicolon
id|sfe
op_assign
(paren
id|xfs_attr_sf_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|sf
op_plus
id|offset
)paren
suffix:semicolon
id|sfe-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|INT_SET
c_func
(paren
id|sfe-&gt;valuelen
comma
id|ARCH_CONVERT
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
id|sfe-&gt;flags
op_assign
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
ques
c_cond
id|XFS_ATTR_ROOT
suffix:colon
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|sfe-&gt;nameval
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sfe-&gt;nameval
(braket
id|args-&gt;namelen
)braket
comma
id|args-&gt;value
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|sf-&gt;hdr.totsize
comma
id|ARCH_CONVERT
comma
id|size
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_ADATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from the shortform attribute list structure.&n; */
r_int
DECL|function|xfs_attr_shortform_remove
id|xfs_attr_shortform_remove
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_attr_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|base
comma
id|size
op_assign
l_int|0
comma
id|end
comma
id|totsize
comma
id|i
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/*&n;&t; * Remove the attribute.&n;&t; */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|base
op_assign
r_sizeof
(paren
id|xfs_attr_sf_hdr_t
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|dp-&gt;i_afp-&gt;if_u1.if_data
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
comma
id|base
op_add_assign
id|size
comma
id|i
op_increment
)paren
(brace
id|size
op_assign
id|XFS_ATTR_SF_ENTSIZE
c_func
(paren
id|sfe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_ne
id|args-&gt;namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|sfe-&gt;nameval
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
id|end
op_assign
id|base
op_plus
id|size
suffix:semicolon
id|totsize
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.totsize
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_ne
id|totsize
)paren
(brace
id|memmove
c_func
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|sf
)paren
(braket
id|base
)braket
comma
op_amp
(paren
(paren
r_char
op_star
)paren
id|sf
)paren
(braket
id|end
)braket
comma
id|totsize
op_minus
id|end
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|sf-&gt;hdr.totsize
comma
id|ARCH_CONVERT
comma
op_minus
id|size
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|size
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_ADATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a name in a shortform attribute list structure.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|xfs_attr_shortform_lookup
id|xfs_attr_shortform_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_attr_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|i
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
id|ifp
op_assign
id|args-&gt;dp-&gt;i_afp
suffix:semicolon
id|ASSERT
c_func
(paren
id|ifp-&gt;if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|ifp-&gt;if_u1.if_data
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_ne
id|args-&gt;namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfe-&gt;nameval
comma
id|args-&gt;namelen
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a name in a shortform attribute list structure.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|xfs_attr_shortform_getvalue
id|xfs_attr_shortform_getvalue
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_attr_sf_entry_t
op_star
id|sfe
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;dp-&gt;i_d.di_aformat
op_eq
id|XFS_IFINLINE
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|args-&gt;dp-&gt;i_afp-&gt;if_u1.if_data
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sfe-&gt;namelen
op_ne
id|args-&gt;namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfe-&gt;nameval
comma
id|args-&gt;namelen
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
(brace
id|args-&gt;valuelen
op_assign
id|INT_GET
c_func
(paren
id|sfe-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args-&gt;valuelen
OL
id|INT_GET
c_func
(paren
id|sfe-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|args-&gt;valuelen
op_assign
id|INT_GET
c_func
(paren
id|sfe-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ERANGE
)paren
suffix:semicolon
)brace
id|args-&gt;valuelen
op_assign
id|INT_GET
c_func
(paren
id|sfe-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|args-&gt;value
comma
op_amp
id|sfe-&gt;nameval
(braket
id|args-&gt;namelen
)braket
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from using the shortform to the leaf.&n; */
r_int
DECL|function|xfs_attr_shortform_to_leaf
id|xfs_attr_shortform_to_leaf
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_attr_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_attr_sf_entry_t
op_star
id|sfe
suffix:semicolon
id|xfs_da_args_t
id|nargs
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
r_int
id|error
comma
id|i
comma
id|size
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
id|xfs_ifork_t
op_star
id|ifp
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ifp
op_assign
id|dp-&gt;i_afp
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|ifp-&gt;if_u1.if_data
suffix:semicolon
id|size
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.totsize
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|size
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpbuffer
comma
id|ifp-&gt;if_u1.if_data
comma
id|size
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|size
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|args
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t; * If we hit an IO error middle of the transaction inside&n;&t;&t; * grow_inode(), we may have inconsistent data. Bail out.&n;&t;&t; */
r_if
c_cond
(paren
id|error
op_eq
id|EIO
)paren
r_goto
id|out
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|size
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
multiline_comment|/* try to put */
id|memcpy
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|tmpbuffer
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* it back */
r_goto
id|out
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|blkno
op_eq
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_create
c_func
(paren
id|args
comma
id|blkno
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|error
op_assign
id|xfs_da_shrink_inode
c_func
(paren
id|args
comma
l_int|0
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|size
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
multiline_comment|/* try to put */
id|memcpy
c_func
(paren
id|ifp-&gt;if_u1.if_data
comma
id|tmpbuffer
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* it back */
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|nargs
comma
l_int|0
comma
r_sizeof
(paren
id|nargs
)paren
)paren
suffix:semicolon
id|nargs.dp
op_assign
id|dp
suffix:semicolon
id|nargs.firstblock
op_assign
id|args-&gt;firstblock
suffix:semicolon
id|nargs.flist
op_assign
id|args-&gt;flist
suffix:semicolon
id|nargs.total
op_assign
id|args-&gt;total
suffix:semicolon
id|nargs.whichfork
op_assign
id|XFS_ATTR_FORK
suffix:semicolon
id|nargs.trans
op_assign
id|args-&gt;trans
suffix:semicolon
id|nargs.oknoent
op_assign
l_int|1
suffix:semicolon
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nargs.name
op_assign
(paren
r_char
op_star
)paren
id|sfe-&gt;nameval
suffix:semicolon
id|nargs.namelen
op_assign
id|sfe-&gt;namelen
suffix:semicolon
id|nargs.value
op_assign
(paren
r_char
op_star
)paren
op_amp
id|sfe-&gt;nameval
(braket
id|nargs.namelen
)braket
suffix:semicolon
id|nargs.valuelen
op_assign
id|INT_GET
c_func
(paren
id|sfe-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|nargs.hashval
op_assign
id|xfs_da_hashname
c_func
(paren
(paren
r_char
op_star
)paren
id|sfe-&gt;nameval
comma
id|sfe-&gt;namelen
)paren
suffix:semicolon
id|nargs.flags
op_assign
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
ques
c_cond
id|ATTR_ROOT
suffix:colon
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_lookup_int
c_func
(paren
id|bp
comma
op_amp
id|nargs
)paren
suffix:semicolon
multiline_comment|/* set a-&gt;index */
id|ASSERT
c_func
(paren
id|error
op_eq
id|ENOATTR
)paren
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_add
c_func
(paren
id|bp
comma
op_amp
id|nargs
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|bp
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|size
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_attr_shortform_compare
id|xfs_attr_shortform_compare
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
id|xfs_attr_sf_sort_t
op_star
id|sa
comma
op_star
id|sb
suffix:semicolon
id|sa
op_assign
(paren
id|xfs_attr_sf_sort_t
op_star
)paren
id|a
suffix:semicolon
id|sb
op_assign
(paren
id|xfs_attr_sf_sort_t
op_star
)paren
id|b
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|sa-&gt;hash
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|sb-&gt;hash
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|sa-&gt;hash
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|sb-&gt;hash
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
id|sa-&gt;entno
op_minus
id|sb-&gt;entno
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Copy out entries of shortform attribute lists for attr_list().&n; * Shortform atrtribute lists are not stored in hashval sorted order.&n; * If the output buffer is not large enough to hold them all, then we&n; * we have to calculate each entries&squot; hashvalue and sort them before&n; * we can begin returning them to the user.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|xfs_attr_shortform_list
id|xfs_attr_shortform_list
c_func
(paren
id|xfs_attr_list_context_t
op_star
id|context
)paren
(brace
id|attrlist_cursor_kern_t
op_star
id|cursor
suffix:semicolon
id|xfs_attr_sf_sort_t
op_star
id|sbuf
comma
op_star
id|sbp
suffix:semicolon
id|xfs_attr_shortform_t
op_star
id|sf
suffix:semicolon
id|xfs_attr_sf_entry_t
op_star
id|sfe
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
r_int
id|sbsize
comma
id|nsbuf
comma
id|count
comma
id|i
suffix:semicolon
id|ASSERT
c_func
(paren
id|context
op_ne
l_int|NULL
)paren
suffix:semicolon
id|dp
op_assign
id|context-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_afp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sf
op_assign
(paren
id|xfs_attr_shortform_t
op_star
)paren
id|dp-&gt;i_afp-&gt;if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|sf
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cursor
op_assign
id|context-&gt;cursor
suffix:semicolon
id|ASSERT
c_func
(paren
id|cursor
op_ne
l_int|NULL
)paren
suffix:semicolon
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;sf start&quot;
comma
id|context
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the buffer is large enough, do not bother with sorting.&n;&t; * Note the generous fudge factor of 16 overhead bytes per entry.&n;&t; */
r_if
c_cond
(paren
(paren
id|dp-&gt;i_afp-&gt;if_bytes
op_plus
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
l_int|16
)paren
OL
id|context-&gt;bufsize
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|ns
op_assign
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
ques
c_cond
id|ROOT_NAMES
suffix:colon
id|USER_NAMES
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|context-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNFULLS
)paren
)paren
(brace
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
(brace
id|ASSERT
c_func
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNAMELS
)paren
suffix:semicolon
id|context-&gt;count
op_add_assign
id|xfs_namespaces
(braket
id|ns
)braket
dot
id|namelen
op_plus
id|INT_GET
c_func
(paren
id|sfe-&gt;namelen
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|xfs_attr_put_listent
c_func
(paren
id|context
comma
id|ns
comma
(paren
r_char
op_star
)paren
id|sfe-&gt;nameval
comma
(paren
r_int
)paren
id|sfe-&gt;namelen
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|sfe-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
)brace
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;sf big-gulp&quot;
comma
id|context
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It didn&squot;t all fit, so we have to sort everything on hashval.&n;&t; */
id|sbsize
op_assign
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|sbuf
)paren
suffix:semicolon
id|sbp
op_assign
id|sbuf
op_assign
id|kmem_alloc
c_func
(paren
id|sbsize
comma
id|KM_SLEEP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the attribute list for the rest of the entries, storing&n;&t; * the relevant info from only those that match into a buffer.&n;&t; */
id|nsbuf
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfe
op_assign
op_amp
id|sf-&gt;list
(braket
l_int|0
)braket
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|sf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|sfe
OL
(paren
r_char
op_star
)paren
id|sf
)paren
op_logical_or
(paren
(paren
r_char
op_star
)paren
id|sfe
op_ge
(paren
(paren
r_char
op_star
)paren
id|sf
op_plus
id|dp-&gt;i_afp-&gt;if_bytes
)paren
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_attr_shortform_list&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|context-&gt;dp-&gt;i_mount
comma
id|sfe
)paren
suffix:semicolon
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;sf corrupted&quot;
comma
id|context
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|sbuf
comma
id|sbsize
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|context-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|sfe-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNFULLS
)paren
)paren
(brace
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sbp-&gt;entno
op_assign
id|i
suffix:semicolon
id|INT_SET
c_func
(paren
id|sbp-&gt;hash
comma
id|ARCH_CONVERT
comma
id|xfs_da_hashname
c_func
(paren
(paren
r_char
op_star
)paren
id|sfe-&gt;nameval
comma
id|sfe-&gt;namelen
)paren
)paren
suffix:semicolon
id|sbp-&gt;name
op_assign
(paren
r_char
op_star
)paren
id|sfe-&gt;nameval
suffix:semicolon
id|sbp-&gt;namelen
op_assign
id|sfe-&gt;namelen
suffix:semicolon
multiline_comment|/* These are bytes, and both on-disk, don&squot;t endian-flip */
id|sbp-&gt;valuelen
op_assign
id|sfe-&gt;valuelen
suffix:semicolon
id|sbp-&gt;flags
op_assign
id|sfe-&gt;flags
suffix:semicolon
id|sfe
op_assign
id|XFS_ATTR_SF_NEXTENTRY
c_func
(paren
id|sfe
)paren
suffix:semicolon
id|sbp
op_increment
suffix:semicolon
id|nsbuf
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Sort the entries on hash then entno.&n;&t; */
id|qsort
c_func
(paren
id|sbuf
comma
id|nsbuf
comma
r_sizeof
(paren
op_star
id|sbuf
)paren
comma
id|xfs_attr_shortform_compare
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Re-find our place IN THE SORTED LIST.&n;&t; */
id|count
op_assign
l_int|0
suffix:semicolon
id|cursor-&gt;initted
op_assign
l_int|1
suffix:semicolon
id|cursor-&gt;blkno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|sbp
op_assign
id|sbuf
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nsbuf
suffix:semicolon
id|i
op_increment
comma
id|sbp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|sbp-&gt;hash
comma
id|ARCH_CONVERT
)paren
op_eq
id|cursor-&gt;hashval
)paren
(brace
r_if
c_cond
(paren
id|cursor-&gt;offset
op_eq
id|count
)paren
(brace
r_break
suffix:semicolon
)brace
id|count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|sbp-&gt;hash
comma
id|ARCH_CONVERT
)paren
OG
id|cursor-&gt;hashval
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|nsbuf
)paren
(brace
id|kmem_free
c_func
(paren
id|sbuf
comma
id|sbsize
)paren
suffix:semicolon
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;blk end&quot;
comma
id|context
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop putting entries into the user buffer.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|nsbuf
suffix:semicolon
id|i
op_increment
comma
id|sbp
op_increment
)paren
(brace
r_int
id|ns
op_assign
(paren
id|sbp-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
ques
c_cond
id|ROOT_NAMES
suffix:colon
id|USER_NAMES
suffix:semicolon
r_if
c_cond
(paren
id|cursor-&gt;hashval
op_ne
id|INT_GET
c_func
(paren
id|sbp-&gt;hash
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|cursor-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|sbp-&gt;hash
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|cursor-&gt;offset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
(brace
id|ASSERT
c_func
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNAMELS
)paren
suffix:semicolon
id|context-&gt;count
op_add_assign
id|xfs_namespaces
(braket
id|ns
)braket
dot
id|namelen
op_plus
id|sbp-&gt;namelen
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|xfs_attr_put_listent
c_func
(paren
id|context
comma
id|ns
comma
id|sbp-&gt;name
comma
id|sbp-&gt;namelen
comma
id|INT_GET
c_func
(paren
id|sbp-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|cursor-&gt;offset
op_increment
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|sbuf
comma
id|sbsize
)paren
suffix:semicolon
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;sf E-O-F&quot;
comma
id|context
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check a leaf attribute block to see if all the entries would fit into&n; * a shortform attribute list.&n; */
r_int
DECL|function|xfs_attr_shortform_allfit
id|xfs_attr_shortform_allfit
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_inode_t
op_star
id|dp
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
r_int
id|bytes
comma
id|i
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
id|bytes
op_assign
r_sizeof
(paren
r_struct
id|xfs_attr_sf_hdr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
r_continue
suffix:semicolon
multiline_comment|/* don&squot;t copy partial entries */
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_loc-&gt;namelen
op_ge
id|XFS_ATTR_SF_ENTSIZE_MAX
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
op_ge
id|XFS_ATTR_SF_ENTSIZE_MAX
)paren
r_return
l_int|0
suffix:semicolon
id|bytes
op_add_assign
r_sizeof
(paren
r_struct
id|xfs_attr_sf_entry
)paren
op_minus
l_int|1
op_plus
id|name_loc-&gt;namelen
op_plus
id|INT_GET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_return
id|bytes
OL
id|XFS_IFORK_ASIZE
c_func
(paren
id|dp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a leaf attribute list to shortform attribute list&n; */
r_int
DECL|function|xfs_attr_leaf_to_shortform
id|xfs_attr_leaf_to_shortform
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
id|xfs_da_args_t
id|nargs
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
r_int
id|error
comma
id|i
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpbuffer
comma
id|bp-&gt;data
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_attr_leafblock_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bp-&gt;data
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean out the prior contents of the attribute list.&n;&t; */
id|error
op_assign
id|xfs_da_shrink_inode
c_func
(paren
id|args
comma
l_int|0
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|xfs_attr_shortform_create
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the attributes&n;&t; */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|nargs
comma
l_int|0
comma
r_sizeof
(paren
id|nargs
)paren
)paren
suffix:semicolon
id|nargs.dp
op_assign
id|dp
suffix:semicolon
id|nargs.firstblock
op_assign
id|args-&gt;firstblock
suffix:semicolon
id|nargs.flist
op_assign
id|args-&gt;flist
suffix:semicolon
id|nargs.total
op_assign
id|args-&gt;total
suffix:semicolon
id|nargs.whichfork
op_assign
id|XFS_ATTR_FORK
suffix:semicolon
id|nargs.trans
op_assign
id|args-&gt;trans
suffix:semicolon
id|nargs.oknoent
op_assign
l_int|1
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
r_continue
suffix:semicolon
multiline_comment|/* don&squot;t copy partial entries */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
r_continue
suffix:semicolon
id|ASSERT
c_func
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
suffix:semicolon
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|i
)paren
suffix:semicolon
id|nargs.name
op_assign
(paren
r_char
op_star
)paren
id|name_loc-&gt;nameval
suffix:semicolon
id|nargs.namelen
op_assign
id|name_loc-&gt;namelen
suffix:semicolon
id|nargs.value
op_assign
(paren
r_char
op_star
)paren
op_amp
id|name_loc-&gt;nameval
(braket
id|nargs.namelen
)braket
suffix:semicolon
id|nargs.valuelen
op_assign
id|INT_GET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|nargs.hashval
op_assign
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|nargs.flags
op_assign
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
ques
c_cond
id|ATTR_ROOT
suffix:colon
l_int|0
suffix:semicolon
id|xfs_attr_shortform_add
c_func
(paren
op_amp
id|nargs
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from using a single leaf to a root node and a leaf.&n; */
r_int
DECL|function|xfs_attr_leaf_to_node
id|xfs_attr_leaf_to_node
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp1
comma
op_star
id|bp2
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
r_int
id|error
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|bp1
op_assign
id|bp2
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|args
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp1
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp1
op_ne
l_int|NULL
)paren
suffix:semicolon
id|bp2
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp2
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp2
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bp2-&gt;data
comma
id|bp1-&gt;data
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp1
)paren
suffix:semicolon
id|bp1
op_assign
l_int|NULL
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp2
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the new root node.&n;&t; */
id|error
op_assign
id|xfs_da_node_create
c_func
(paren
id|args
comma
l_int|0
comma
l_int|1
comma
op_amp
id|bp1
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|node
op_assign
id|bp1-&gt;data
suffix:semicolon
id|leaf
op_assign
id|bp2-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
multiline_comment|/* both on-disk, don&squot;t endian-flip twice */
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|hashval
op_assign
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|before
comma
id|ARCH_CONVERT
comma
id|blkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp1
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|bp1
)paren
id|xfs_da_buf_done
c_func
(paren
id|bp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp2
)paren
id|xfs_da_buf_done
c_func
(paren
id|bp2
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for growing the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Create the initial contents of a leaf attribute list&n; * or a leaf in a node attribute list.&n; */
r_int
DECL|function|xfs_attr_leaf_create
id|xfs_attr_leaf_create
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dablk_t
id|blkno
comma
id|xfs_dabuf_t
op_star
op_star
id|bpp
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|leaf
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;info.magic
comma
id|ARCH_CONVERT
comma
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
op_minus
id|XFS_ATTR_LEAF_NAME_ALIGN
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|dp-&gt;i_mount
)paren
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Split the leaf node, rebalance, then add the new entry.&n; */
r_int
DECL|function|xfs_attr_leaf_split
id|xfs_attr_leaf_split
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|oldblk
comma
id|xfs_da_state_blk_t
op_star
id|newblk
)paren
(brace
id|xfs_dablk_t
id|blkno
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for a new leaf node.&n;&t; */
id|ASSERT
c_func
(paren
id|oldblk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_grow_inode
c_func
(paren
id|state-&gt;args
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|xfs_attr_leaf_create
c_func
(paren
id|state-&gt;args
comma
id|blkno
comma
op_amp
id|newblk-&gt;bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|newblk-&gt;blkno
op_assign
id|blkno
suffix:semicolon
id|newblk-&gt;magic
op_assign
id|XFS_ATTR_LEAF_MAGIC
suffix:semicolon
multiline_comment|/*&n;&t; * Rebalance the entries across the two leaves.&n;&t; * NOTE: rebalance() currently depends on the 2nd block being empty.&n;&t; */
id|xfs_attr_leaf_rebalance
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_blk_link
c_func
(paren
id|state
comma
id|oldblk
comma
id|newblk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Save info on &quot;old&quot; attribute for &quot;atomic rename&quot; ops, leaf_add()&n;&t; * modifies the index/blkno/rmtblk/rmtblkcnt fields to show the&n;&t; * &quot;new&quot; attrs info.  Will need the &quot;old&quot; info to remove it later.&n;&t; *&n;&t; * Insert the &quot;new&quot; entry in the correct block.&n;&t; */
r_if
c_cond
(paren
id|state-&gt;inleaf
)paren
id|error
op_assign
id|xfs_attr_leaf_add
c_func
(paren
id|oldblk-&gt;bp
comma
id|state-&gt;args
)paren
suffix:semicolon
r_else
id|error
op_assign
id|xfs_attr_leaf_add
c_func
(paren
id|newblk-&gt;bp
comma
id|state-&gt;args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update last hashval in each block since we added the name.&n;&t; */
id|oldblk-&gt;hashval
op_assign
id|xfs_attr_leaf_lasthash
c_func
(paren
id|oldblk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
id|newblk-&gt;hashval
op_assign
id|xfs_attr_leaf_lasthash
c_func
(paren
id|newblk-&gt;bp
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a name to the leaf attribute list structure.&n; */
r_int
DECL|function|xfs_attr_leaf_add
id|xfs_attr_leaf_add
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_attr_leaf_map_t
op_star
id|map
suffix:semicolon
r_int
id|tablesize
comma
id|entsize
comma
id|sum
comma
id|tmp
comma
id|i
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|args-&gt;index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|args-&gt;index
op_le
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|entsize
op_assign
id|xfs_attr_leaf_newentsize
c_func
(paren
id|args
comma
id|args-&gt;trans-&gt;t_mountp-&gt;m_sb.sb_blocksize
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Search through freemap for first-fit on new name length.&n;&t; * (may need to figure in size of entry struct too)&n;&t; */
id|tablesize
op_assign
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
op_plus
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|XFS_ATTR_LEAF_MAPSIZE
op_minus
l_int|1
)braket
suffix:semicolon
r_for
c_loop
(paren
id|sum
op_assign
l_int|0
comma
id|i
op_assign
id|XFS_ATTR_LEAF_MAPSIZE
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|map
op_decrement
comma
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|tablesize
OG
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|sum
op_add_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* no space in this map */
id|tmp
op_assign
id|entsize
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|tmp
op_add_assign
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
op_ge
id|tmp
)paren
(brace
id|tmp
op_assign
id|xfs_attr_leaf_add_work
c_func
(paren
id|bp
comma
id|args
comma
id|i
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
id|sum
op_add_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are no holes in the address space of the block,&n;&t; * and we don&squot;t have enough freespace, then compaction will do us&n;&t; * no good and we should just give up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|hdr-&gt;holes
op_logical_and
(paren
id|sum
OL
id|entsize
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compact the entries to coalesce free space.&n;&t; * This may change the hdr-&gt;count via dropping INCOMPLETE entries.&n;&t; */
id|xfs_attr_leaf_compact
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * After compaction, the block is guaranteed to have only one&n;&t; * free region, in freemap[0].  If it is not big enough, give up.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|entsize
op_plus
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
r_return
id|xfs_attr_leaf_add_work
c_func
(paren
id|bp
comma
id|args
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a name to a leaf attribute list structure.&n; */
id|STATIC
r_int
DECL|function|xfs_attr_leaf_add_work
id|xfs_attr_leaf_add_work
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|mapindex
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
id|xfs_attr_leaf_map_t
op_star
id|map
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|mapindex
op_ge
l_int|0
)paren
op_logical_and
(paren
id|mapindex
OL
id|XFS_ATTR_LEAF_MAPSIZE
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|args-&gt;index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|args-&gt;index
op_le
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Force open some space in the entry array and fill it in.&n;&t; */
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|args-&gt;index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;index
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|args-&gt;index
suffix:semicolon
id|tmp
op_mul_assign
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|entry
op_plus
l_int|1
)paren
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|tmp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
id|tmp
op_plus
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for the new string (at the end of the run).&n;&t; */
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|mapindex
)braket
suffix:semicolon
id|mp
op_assign
id|args-&gt;trans-&gt;t_mountp
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_amp
l_int|0x3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
op_ge
id|xfs_attr_leaf_newentsize
c_func
(paren
id|args
comma
id|mp-&gt;m_sb.sb_blocksize
comma
l_int|NULL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
op_amp
l_int|0x3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
op_minus
id|xfs_attr_leaf_newentsize
c_func
(paren
id|args
comma
id|mp-&gt;m_sb.sb_blocksize
comma
op_amp
id|tmp
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
comma
id|args-&gt;hashval
)paren
suffix:semicolon
id|entry-&gt;flags
op_assign
id|tmp
ques
c_cond
id|XFS_ATTR_LOCAL
suffix:colon
l_int|0
suffix:semicolon
id|entry-&gt;flags
op_or_assign
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
ques
c_cond
id|XFS_ATTR_ROOT
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;rename
)paren
(brace
id|entry-&gt;flags
op_or_assign
id|XFS_ATTR_INCOMPLETE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|args-&gt;blkno2
op_eq
id|args-&gt;blkno
)paren
op_logical_and
(paren
id|args-&gt;index2
op_le
id|args-&gt;index
)paren
)paren
(brace
id|args-&gt;index2
op_increment
suffix:semicolon
)brace
)brace
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|args-&gt;index
op_eq
l_int|0
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
(paren
id|entry
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|args-&gt;index
op_eq
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_le
(paren
id|INT_GET
c_func
(paren
(paren
id|entry
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the attribute name and value into the new space.&n;&t; *&n;&t; * For &quot;remote&quot; attribute values, simply note that we need to&n;&t; * allocate space for the &quot;remote&quot; value.  We can&squot;t actually&n;&t; * allocate the extents in this transaction, and we can&squot;t decide&n;&t; * which blocks they should be as we might allocate more blocks&n;&t; * as part of this transaction (a split operation for example).&n;&t; */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|name_loc-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|INT_SET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|name_loc-&gt;nameval
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|name_loc-&gt;nameval
(braket
id|args-&gt;namelen
)braket
comma
id|args-&gt;value
comma
id|INT_GET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|name_rmt-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|name_rmt-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|entry-&gt;flags
op_or_assign
id|XFS_ATTR_INCOMPLETE
suffix:semicolon
multiline_comment|/* just in case */
id|INT_ZERO
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args-&gt;rmtblkno
op_assign
l_int|1
suffix:semicolon
id|args-&gt;rmtblkcnt
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|mp
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
)brace
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|XFS_ATTR_LEAF_NAME
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
comma
id|xfs_attr_leaf_entsize
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the control info for this leaf node&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/* both on-disk, don&squot;t endian-flip twice */
id|hdr-&gt;firstused
op_assign
id|entry-&gt;nameidx
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
op_plus
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFS_ATTR_LEAF_MAPSIZE
suffix:semicolon
id|map
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_eq
id|tmp
)paren
(brace
id|INT_MOD
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
op_minus
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
)paren
suffix:semicolon
)brace
)brace
id|INT_MOD
c_func
(paren
id|hdr-&gt;usedbytes
comma
id|ARCH_CONVERT
comma
id|xfs_attr_leaf_entsize
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Garbage collect a leaf attribute list block by copying it to a new buffer.&n; */
id|STATIC
r_void
DECL|function|xfs_attr_leaf_compact
id|xfs_attr_leaf_compact
c_func
(paren
id|xfs_trans_t
op_star
id|trans
comma
id|xfs_dabuf_t
op_star
id|bp
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf_s
comma
op_star
id|leaf_d
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|hdr_s
comma
op_star
id|hdr_d
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
id|mp
op_assign
id|trans-&gt;t_mountp
suffix:semicolon
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpbuffer
comma
id|bp-&gt;data
comma
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bp-&gt;data
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy basic information&n;&t; */
id|leaf_s
op_assign
(paren
id|xfs_attr_leafblock_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|leaf_d
op_assign
id|bp-&gt;data
suffix:semicolon
id|hdr_s
op_assign
op_amp
id|leaf_s-&gt;hdr
suffix:semicolon
id|hdr_d
op_assign
op_amp
id|leaf_d-&gt;hdr
suffix:semicolon
id|hdr_d-&gt;info
op_assign
id|hdr_s-&gt;info
suffix:semicolon
multiline_comment|/* struct copy */
id|INT_SET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/* handle truncation gracefully */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|INT_SET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_minus
id|XFS_ATTR_LEAF_NAME_ALIGN
)paren
suffix:semicolon
)brace
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;usedbytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|hdr_d-&gt;holes
op_assign
l_int|0
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy all entry&squot;s in the same (sorted) order,&n;&t; * but allocate name/value pairs packed and in sequence.&n;&t; */
id|xfs_attr_leaf_moveents
c_func
(paren
id|leaf_s
comma
l_int|0
comma
id|leaf_d
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|trans
comma
id|bp
comma
l_int|0
comma
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Redistribute the attribute list entries between two leaf nodes,&n; * taking into account the size of the new entry.&n; *&n; * NOTE: if new block is empty, then it will get the upper half of the&n; * old block.  At present, all (one) callers pass in an empty second block.&n; *&n; * This code adjusts the args-&gt;index/blkno and args-&gt;index2/blkno2 fields&n; * to match what it is doing in splitting the attribute leaf block.  Those&n; * values are used in &quot;atomic rename&quot; operations on attributes.  Note that&n; * the &quot;new&quot; and &quot;old&quot; values can end up in different blocks.&n; */
id|STATIC
r_void
DECL|function|xfs_attr_leaf_rebalance
id|xfs_attr_leaf_rebalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
)paren
(brace
id|xfs_da_args_t
op_star
id|args
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|tmp_blk
suffix:semicolon
id|xfs_attr_leafblock_t
op_star
id|leaf1
comma
op_star
id|leaf2
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|hdr1
comma
op_star
id|hdr2
suffix:semicolon
r_int
id|count
comma
id|totallen
comma
id|max
comma
id|space
comma
id|swap
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|ASSERT
c_func
(paren
id|blk1-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|blk2-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|leaf1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|args
op_assign
id|state-&gt;args
suffix:semicolon
multiline_comment|/*&n;&t; * Check ordering of blocks, reverse if it makes things simpler.&n;&t; *&n;&t; * NOTE: Given that all (current) callers pass in an empty&n;&t; * second block, this code should never set &quot;swap&quot;.&n;&t; */
id|swap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xfs_attr_leaf_order
c_func
(paren
id|blk1-&gt;bp
comma
id|blk2-&gt;bp
)paren
)paren
(brace
id|tmp_blk
op_assign
id|blk1
suffix:semicolon
id|blk1
op_assign
id|blk2
suffix:semicolon
id|blk2
op_assign
id|tmp_blk
suffix:semicolon
id|leaf1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|swap
op_assign
l_int|1
suffix:semicolon
)brace
id|hdr1
op_assign
op_amp
id|leaf1-&gt;hdr
suffix:semicolon
id|hdr2
op_assign
op_amp
id|leaf2-&gt;hdr
suffix:semicolon
multiline_comment|/*&n;&t; * Examine entries until we reduce the absolute difference in&n;&t; * byte usage between the two blocks to a minimum.  Then get&n;&t; * the direction to copy and the number of elements to move.&n;&t; *&n;&t; * &quot;inleaf&quot; is true if the new entry should be inserted into blk1.&n;&t; * If &quot;swap&quot; is also true, then reverse the sense of &quot;inleaf&quot;.&n;&t; */
id|state-&gt;inleaf
op_assign
id|xfs_attr_leaf_figure_balance
c_func
(paren
id|state
comma
id|blk1
comma
id|blk2
comma
op_amp
id|count
comma
op_amp
id|totallen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|swap
)paren
id|state-&gt;inleaf
op_assign
op_logical_neg
id|state-&gt;inleaf
suffix:semicolon
multiline_comment|/*&n;&t; * Move any entries required from leaf to leaf:&n;&t; */
r_if
c_cond
(paren
id|count
OL
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Figure the total bytes to be added to the destination leaf.&n;&t;&t; */
multiline_comment|/* number entries being moved */
id|count
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
suffix:semicolon
id|space
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;usedbytes
comma
id|ARCH_CONVERT
)paren
op_minus
id|totallen
suffix:semicolon
id|space
op_add_assign
id|count
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * leaf2 is the destination, compact it if it looks tight.&n;&t;&t; */
id|max
op_assign
id|INT_GET
c_func
(paren
id|hdr2-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|max
op_sub_assign
id|INT_GET
c_func
(paren
id|hdr2-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
id|max
)paren
(brace
id|xfs_attr_leaf_compact
c_func
(paren
id|args-&gt;trans
comma
id|blk2-&gt;bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move high entries from leaf1 to low end of leaf2.&n;&t;&t; */
id|xfs_attr_leaf_moveents
c_func
(paren
id|leaf1
comma
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
comma
id|leaf2
comma
l_int|0
comma
id|count
comma
id|state-&gt;mp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|blk1-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|blk2-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|count
OG
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * I assert that since all callers pass in an empty&n;&t;&t; * second buffer, this code should never execute.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * Figure the total bytes to be added to the destination leaf.&n;&t;&t; */
multiline_comment|/* number entries being moved */
id|count
op_sub_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|space
op_assign
id|totallen
op_minus
id|INT_GET
c_func
(paren
id|hdr1-&gt;usedbytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|space
op_add_assign
id|count
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * leaf1 is the destination, compact it if it looks tight.&n;&t;&t; */
id|max
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|max
op_sub_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
id|max
)paren
(brace
id|xfs_attr_leaf_compact
c_func
(paren
id|args-&gt;trans
comma
id|blk1-&gt;bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move low entries from leaf2 to high end of leaf1.&n;&t;&t; */
id|xfs_attr_leaf_moveents
c_func
(paren
id|leaf2
comma
l_int|0
comma
id|leaf1
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|count
comma
id|state-&gt;mp
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|blk1-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|blk2-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy out last hashval in each block for B-tree code.&n;&t; */
id|blk1-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|leaf1-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|blk2-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|leaf2-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Adjust the expected index for insertion.&n;&t; * NOTE: this code depends on the (current) situation that the&n;&t; * second block was originally empty.&n;&t; *&n;&t; * If the insertion point moved to the 2nd block, we must adjust&n;&t; * the index.  We must also track the entry just following the&n;&t; * new entry for use in an &quot;atomic rename&quot; operation, that entry&n;&t; * is always the &quot;old&quot; entry and the &quot;new&quot; entry is what we are&n;&t; * inserting.  The index/blkno fields refer to the &quot;old&quot; entry,&n;&t; * while the index2/blkno2 fields refer to the &quot;new&quot; entry.&n;&t; */
r_if
c_cond
(paren
id|blk1-&gt;index
OG
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|state-&gt;inleaf
op_eq
l_int|0
)paren
suffix:semicolon
id|blk2-&gt;index
op_assign
id|blk1-&gt;index
op_minus
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args-&gt;index
op_assign
id|args-&gt;index2
op_assign
id|blk2-&gt;index
suffix:semicolon
id|args-&gt;blkno
op_assign
id|args-&gt;blkno2
op_assign
id|blk2-&gt;blkno
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|blk1-&gt;index
op_eq
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;inleaf
)paren
(brace
id|args-&gt;index
op_assign
id|blk1-&gt;index
suffix:semicolon
id|args-&gt;blkno
op_assign
id|blk1-&gt;blkno
suffix:semicolon
id|args-&gt;index2
op_assign
l_int|0
suffix:semicolon
id|args-&gt;blkno2
op_assign
id|blk2-&gt;blkno
suffix:semicolon
)brace
r_else
(brace
id|blk2-&gt;index
op_assign
id|blk1-&gt;index
op_minus
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args-&gt;index
op_assign
id|args-&gt;index2
op_assign
id|blk2-&gt;index
suffix:semicolon
id|args-&gt;blkno
op_assign
id|args-&gt;blkno2
op_assign
id|blk2-&gt;blkno
suffix:semicolon
)brace
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|state-&gt;inleaf
op_eq
l_int|1
)paren
suffix:semicolon
id|args-&gt;index
op_assign
id|args-&gt;index2
op_assign
id|blk1-&gt;index
suffix:semicolon
id|args-&gt;blkno
op_assign
id|args-&gt;blkno2
op_assign
id|blk1-&gt;blkno
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Examine entries until we reduce the absolute difference in&n; * byte usage between the two blocks to a minimum.&n; * GROT: Is this really necessary?  With other than a 512 byte blocksize,&n; * GROT: there will always be enough room in either block for a new entry.&n; * GROT: Do a double-split for this case?&n; */
id|STATIC
r_int
DECL|function|xfs_attr_leaf_figure_balance
id|xfs_attr_leaf_figure_balance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|blk1
comma
id|xfs_da_state_blk_t
op_star
id|blk2
comma
r_int
op_star
id|countarg
comma
r_int
op_star
id|usedbytesarg
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf1
comma
op_star
id|leaf2
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|hdr1
comma
op_star
id|hdr2
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
r_int
id|count
comma
id|max
comma
id|index
comma
id|totallen
comma
id|half
suffix:semicolon
r_int
id|lastdelta
comma
id|foundit
comma
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|leaf1
op_assign
id|blk1-&gt;bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|blk2-&gt;bp-&gt;data
suffix:semicolon
id|hdr1
op_assign
op_amp
id|leaf1-&gt;hdr
suffix:semicolon
id|hdr2
op_assign
op_amp
id|leaf2-&gt;hdr
suffix:semicolon
id|foundit
op_assign
l_int|0
suffix:semicolon
id|totallen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Examine entries until we reduce the absolute difference in&n;&t; * byte usage between the two blocks to a minimum.&n;&t; */
id|max
op_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|hdr2-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|half
op_assign
(paren
id|max
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|entry
)paren
suffix:semicolon
id|half
op_add_assign
id|INT_GET
c_func
(paren
id|hdr1-&gt;usedbytes
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|hdr2-&gt;usedbytes
comma
id|ARCH_CONVERT
)paren
op_plus
id|xfs_attr_leaf_newentsize
c_func
(paren
id|state-&gt;args
comma
id|state-&gt;blocksize
comma
l_int|NULL
)paren
suffix:semicolon
id|half
op_div_assign
l_int|2
suffix:semicolon
id|lastdelta
op_assign
id|state-&gt;blocksize
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf1-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
id|index
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|max
suffix:semicolon
id|entry
op_increment
comma
id|index
op_increment
comma
id|count
op_increment
)paren
(brace
DECL|macro|XFS_ATTR_ABS
mdefine_line|#define XFS_ATTR_ABS(A)&t;(((A) &lt; 0) ? -(A) : (A))
multiline_comment|/*&n;&t;&t; * The new entry is in the first block, account for it.&n;&t;&t; */
r_if
c_cond
(paren
id|count
op_eq
id|blk1-&gt;index
)paren
(brace
id|tmp
op_assign
id|totallen
op_plus
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
id|xfs_attr_leaf_newentsize
c_func
(paren
id|state-&gt;args
comma
id|state-&gt;blocksize
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_ATTR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
OG
id|lastdelta
)paren
r_break
suffix:semicolon
id|lastdelta
op_assign
id|XFS_ATTR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
suffix:semicolon
id|totallen
op_assign
id|tmp
suffix:semicolon
id|foundit
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wrap around into the second block if necessary.&n;&t;&t; */
r_if
c_cond
(paren
id|count
op_eq
id|INT_GET
c_func
(paren
id|hdr1-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|leaf1
op_assign
id|leaf2
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf1-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Figure out if next leaf entry would be too much.&n;&t;&t; */
id|tmp
op_assign
id|totallen
op_plus
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
id|xfs_attr_leaf_entsize
c_func
(paren
id|leaf1
comma
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_ATTR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
OG
id|lastdelta
)paren
r_break
suffix:semicolon
id|lastdelta
op_assign
id|XFS_ATTR_ABS
c_func
(paren
id|half
op_minus
id|tmp
)paren
suffix:semicolon
id|totallen
op_assign
id|tmp
suffix:semicolon
DECL|macro|XFS_ATTR_ABS
macro_line|#undef XFS_ATTR_ABS
)brace
multiline_comment|/*&n;&t; * Calculate the number of usedbytes that will end up in lower block.&n;&t; * If new entry not in lower block, fix up the count.&n;&t; */
id|totallen
op_sub_assign
id|count
op_star
r_sizeof
(paren
op_star
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foundit
)paren
(brace
id|totallen
op_sub_assign
r_sizeof
(paren
op_star
id|entry
)paren
op_plus
id|xfs_attr_leaf_newentsize
c_func
(paren
id|state-&gt;args
comma
id|state-&gt;blocksize
comma
l_int|NULL
)paren
suffix:semicolon
)brace
op_star
id|countarg
op_assign
id|count
suffix:semicolon
op_star
id|usedbytesarg
op_assign
id|totallen
suffix:semicolon
r_return
id|foundit
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for shrinking the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Check a leaf block and its neighbors to see if the block should be&n; * collapsed into one or the other neighbor.  Always keep the block&n; * with the smaller block number.&n; * If the current block is over 50% full, don&squot;t try to join it, return 0.&n; * If the block is empty, fill in the state structure and return 2.&n; * If it can be collapsed, fill in the state structure and return 1.&n; * If nothing can be done, return 0.&n; *&n; * GROT: allow for INCOMPLETE entries in calculation.&n; */
r_int
DECL|function|xfs_attr_leaf_toosmall
id|xfs_attr_leaf_toosmall
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
r_int
op_star
id|action
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_da_state_blk_t
op_star
id|blk
suffix:semicolon
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
r_int
id|count
comma
id|bytes
comma
id|forward
comma
id|error
comma
id|retval
comma
id|i
suffix:semicolon
id|xfs_dablk_t
id|blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being over 50% full.&n;&t; * If so, it&squot;s not worth even looking to see if we might be able&n;&t; * to coalesce with a sibling.&n;&t; */
id|blk
op_assign
op_amp
id|state-&gt;path.blk
(braket
id|state-&gt;path.active
op_minus
l_int|1
)braket
suffix:semicolon
id|info
op_assign
id|blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_attr_leafblock_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_assign
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
op_plus
id|count
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
op_plus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.usedbytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
(paren
id|state-&gt;blocksize
op_rshift
l_int|1
)paren
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* blk over 50%, don&squot;t try to join */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for the degenerate case of the block being empty.&n;&t; * If the block is empty, we&squot;ll simply delete it, no need to&n;&t; * coalesce it with a sibling block.  We choose (aribtrarily)&n;&t; * to merge with the forward block unless it is NULL.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Make altpath point to the block we want to keep and&n;&t;&t; * path point to the block we want to drop (this one).&n;&t;&t; */
id|forward
op_assign
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|action
op_assign
l_int|2
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Examine each sibling block to see if we can coalesce with&n;&t; * at least 25% free space to spare.  We need to figure out&n;&t; * whether to merge with the forward or the backward block.&n;&t; * We prefer coalescing with the lower numbered sibling so as&n;&t; * to shrink an attribute list over time.&n;&t; */
multiline_comment|/* start with smaller blk num */
id|forward
op_assign
(paren
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|forward
op_assign
op_logical_neg
id|forward
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|forward
)paren
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;forw
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_else
id|blkno
op_assign
id|INT_GET
c_func
(paren
id|info-&gt;back
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|state-&gt;args-&gt;dp
comma
id|blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
(paren
id|xfs_attr_leafblock_t
op_star
)paren
id|info
suffix:semicolon
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_assign
id|state-&gt;blocksize
op_minus
(paren
id|state-&gt;blocksize
op_rshift
l_int|2
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.usedbytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|count
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.usedbytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|bytes
op_sub_assign
id|count
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|bytes
op_sub_assign
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes
op_ge
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* fits with at least 25% to spare */
)brace
r_if
c_cond
(paren
id|i
op_ge
l_int|2
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make altpath point to the block we want to keep (the lower&n;&t; * numbered block) and path point to the block we want to drop.&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|state-&gt;altpath
comma
op_amp
id|state-&gt;path
comma
r_sizeof
(paren
id|state-&gt;path
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkno
OL
id|blk-&gt;blkno
)paren
(brace
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;altpath
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|xfs_da_path_shift
c_func
(paren
id|state
comma
op_amp
id|state-&gt;path
comma
id|forward
comma
l_int|0
comma
op_amp
id|retval
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
op_star
id|action
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|action
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a name from the leaf attribute list structure.&n; *&n; * Return 1 if leaf is less than 37% full, 0 if &gt;= 37% full.&n; * If two leaves are 37% full, when combined they will leave 25% free.&n; */
r_int
DECL|function|xfs_attr_leaf_remove
id|xfs_attr_leaf_remove
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|hdr
suffix:semicolon
id|xfs_attr_leaf_map_t
op_star
id|map
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
r_int
id|before
comma
id|after
comma
id|smallest
comma
id|entsize
suffix:semicolon
r_int
id|tablesize
comma
id|tmp
comma
id|i
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|hdr
op_assign
op_amp
id|leaf-&gt;hdr
suffix:semicolon
id|mp
op_assign
id|args-&gt;trans-&gt;t_mountp
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_div
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|args-&gt;index
op_ge
l_int|0
)paren
op_logical_and
(paren
id|args-&gt;index
OL
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|args-&gt;index
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan through free region table:&n;&t; *    check for adjacency of free&squot;d entry with an existing one,&n;&t; *    find smallest free region in case we need to replace it,&n;&t; *    adjust any map that borders the entry table,&n;&t; */
id|tablesize
op_assign
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
op_plus
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
l_int|0
)braket
suffix:semicolon
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|before
op_assign
id|after
op_assign
op_minus
l_int|1
suffix:semicolon
id|smallest
op_assign
id|XFS_ATTR_LEAF_MAPSIZE
op_minus
l_int|1
suffix:semicolon
id|entsize
op_assign
id|xfs_attr_leaf_entsize
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFS_ATTR_LEAF_MAPSIZE
suffix:semicolon
id|map
op_increment
comma
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_eq
id|tablesize
)paren
(brace
id|INT_MOD
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
comma
op_minus
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|before
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
)paren
op_eq
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_plus
id|entsize
)paren
)paren
(brace
id|after
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|tmp
)paren
(brace
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|smallest
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Coalesce adjacent freemap regions,&n;&t; * or replace the smallest region.&n;&t; */
r_if
c_cond
(paren
(paren
id|before
op_ge
l_int|0
)paren
op_logical_or
(paren
id|after
op_ge
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|before
op_ge
l_int|0
)paren
op_logical_and
(paren
id|after
op_ge
l_int|0
)paren
)paren
(brace
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|before
)braket
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr-&gt;freemap
(braket
id|after
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr-&gt;freemap
(braket
id|after
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr-&gt;freemap
(braket
id|after
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|before
op_ge
l_int|0
)paren
(brace
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|before
)braket
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
)brace
r_else
(brace
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|after
)braket
suffix:semicolon
multiline_comment|/* both on-disk, don&squot;t endian flip twice */
id|map-&gt;base
op_assign
id|entry-&gt;nameidx
suffix:semicolon
id|INT_MOD
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Replace smallest region (if it is smaller than free&squot;d entry)&n;&t;&t; */
id|map
op_assign
op_amp
id|hdr-&gt;freemap
(braket
id|smallest
)braket
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
)paren
OL
id|entsize
)paren
(brace
id|INT_SET
c_func
(paren
id|map-&gt;base
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|map-&gt;size
comma
id|ARCH_CONVERT
comma
id|entsize
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Did we remove the first entry?&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
id|smallest
op_assign
l_int|1
suffix:semicolon
r_else
id|smallest
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Compress the remaining entries and zero out the removed stuff.&n;&t; */
id|memset
c_func
(paren
id|XFS_ATTR_LEAF_NAME
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
comma
l_int|0
comma
id|entsize
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr-&gt;usedbytes
comma
id|ARCH_CONVERT
comma
op_minus
id|entsize
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|XFS_ATTR_LEAF_NAME
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
comma
id|entsize
)paren
)paren
suffix:semicolon
id|tmp
op_assign
(paren
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|args-&gt;index
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
id|entry
comma
(paren
r_char
op_star
)paren
(paren
id|entry
op_plus
l_int|1
)paren
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
id|tmp
op_plus
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|entry
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we removed the first entry, re-find the first used byte&n;&t; * in the name area.  Note that if the entry was the &quot;firstused&quot;,&n;&t; * then we don&squot;t have a &quot;hole&quot; in our block resulting from&n;&t; * removing the name.&n;&t; */
r_if
c_cond
(paren
id|smallest
)paren
(brace
id|tmp
op_assign
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|INT_GET
c_func
(paren
id|hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|entry
op_increment
comma
id|i
op_decrement
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
OL
id|tmp
)paren
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|INT_SET
c_func
(paren
id|hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|tmp
op_minus
id|XFS_ATTR_LEAF_NAME_ALIGN
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|hdr-&gt;holes
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* mark as needing compaction */
)brace
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if leaf is less than 50% full, caller may want to&n;&t; * &quot;join&quot; the leaf with a sibling if so.&n;&t; */
id|tmp
op_assign
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|tmp
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|tmp
op_add_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.usedbytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|tmp
OL
id|mp-&gt;m_attr_magicpct
suffix:semicolon
multiline_comment|/* leaf is &lt; 37% full */
)brace
multiline_comment|/*&n; * Move all the attribute list entries from drop_leaf into save_leaf.&n; */
r_void
DECL|function|xfs_attr_leaf_unbalance
id|xfs_attr_leaf_unbalance
c_func
(paren
id|xfs_da_state_t
op_star
id|state
comma
id|xfs_da_state_blk_t
op_star
id|drop_blk
comma
id|xfs_da_state_blk_t
op_star
id|save_blk
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|drop_leaf
comma
op_star
id|save_leaf
comma
op_star
id|tmp_leaf
suffix:semicolon
id|xfs_attr_leaf_hdr_t
op_star
id|drop_hdr
comma
op_star
id|save_hdr
comma
op_star
id|tmp_hdr
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_char
op_star
id|tmpbuffer
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|mp
op_assign
id|state-&gt;mp
suffix:semicolon
id|ASSERT
c_func
(paren
id|drop_blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|save_blk-&gt;magic
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|drop_leaf
op_assign
id|drop_blk-&gt;bp-&gt;data
suffix:semicolon
id|save_leaf
op_assign
id|save_blk-&gt;bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|drop_hdr
op_assign
op_amp
id|drop_leaf-&gt;hdr
suffix:semicolon
id|save_hdr
op_assign
op_amp
id|save_leaf-&gt;hdr
suffix:semicolon
multiline_comment|/*&n;&t; * Save last hashval from dying block for later Btree fixup.&n;&t; */
id|drop_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|drop_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check if we need a temp buffer, or can we do it in place.&n;&t; * Note that we don&squot;t check &quot;leaf&quot; for holes because we will&n;&t; * always be dropping it, toosmall() decided that for us already.&n;&t; */
r_if
c_cond
(paren
id|save_hdr-&gt;holes
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * dest leaf has no holes, so we add there.  May need&n;&t;&t; * to make some room in the entry array.&n;&t;&t; */
r_if
c_cond
(paren
id|xfs_attr_leaf_order
c_func
(paren
id|save_blk-&gt;bp
comma
id|drop_blk-&gt;bp
)paren
)paren
(brace
id|xfs_attr_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|save_leaf
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_attr_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|save_leaf
comma
id|INT_GET
c_func
(paren
id|save_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Destination has holes, so we make a temporary copy&n;&t;&t; * of the leaf and add them both to that.&n;&t;&t; */
id|tmpbuffer
op_assign
id|kmem_alloc
c_func
(paren
id|state-&gt;blocksize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|tmpbuffer
op_ne
l_int|NULL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tmpbuffer
comma
l_int|0
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
id|tmp_leaf
op_assign
(paren
id|xfs_attr_leafblock_t
op_star
)paren
id|tmpbuffer
suffix:semicolon
id|tmp_hdr
op_assign
op_amp
id|tmp_leaf-&gt;hdr
suffix:semicolon
id|tmp_hdr-&gt;info
op_assign
id|save_hdr-&gt;info
suffix:semicolon
multiline_comment|/* struct copy */
id|INT_ZERO
c_func
(paren
id|tmp_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|tmp_hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|tmp_hdr-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|INT_SET
c_func
(paren
id|tmp_hdr-&gt;firstused
comma
id|ARCH_CONVERT
comma
id|state-&gt;blocksize
op_minus
id|XFS_ATTR_LEAF_NAME_ALIGN
)paren
suffix:semicolon
)brace
id|INT_ZERO
c_func
(paren
id|tmp_hdr-&gt;usedbytes
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_attr_leaf_order
c_func
(paren
id|save_blk-&gt;bp
comma
id|drop_blk-&gt;bp
)paren
)paren
(brace
id|xfs_attr_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
id|xfs_attr_leaf_moveents
c_func
(paren
id|save_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
id|INT_GET
c_func
(paren
id|tmp_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|save_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_attr_leaf_moveents
c_func
(paren
id|save_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
l_int|0
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|save_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
id|xfs_attr_leaf_moveents
c_func
(paren
id|drop_leaf
comma
l_int|0
comma
id|tmp_leaf
comma
id|INT_GET
c_func
(paren
id|tmp_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|drop_hdr-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
id|mp
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|save_leaf
comma
(paren
r_char
op_star
)paren
id|tmp_leaf
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|tmpbuffer
comma
id|state-&gt;blocksize
)paren
suffix:semicolon
)brace
id|xfs_da_log_buf
c_func
(paren
id|state-&gt;args-&gt;trans
comma
id|save_blk-&gt;bp
comma
l_int|0
comma
id|state-&gt;blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy out last hashval in each block for B-tree code.&n;&t; */
id|save_blk-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|save_leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|save_leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Routines used for finding things in the Btree.&n; *========================================================================*/
multiline_comment|/*&n; * Look up a name in a leaf attribute list structure.&n; * This is the internal routine, it uses the caller&squot;s buffer.&n; *&n; * Note that duplicate keys are allowed, but only check within the&n; * current leaf node.  The Btree code must check in adjacent leaf nodes.&n; *&n; * Return in args-&gt;index the index into the entry[] array of either&n; * the found entry, or where the entry should have been (insert before&n; * that entry).&n; *&n; * Don&squot;t change the args-&gt;value unless we find the attribute.&n; */
r_int
DECL|function|xfs_attr_leaf_lookup_int
id|xfs_attr_leaf_lookup_int
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
r_int
id|probe
comma
id|span
suffix:semicolon
id|xfs_dahash_t
id|hashval
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|args-&gt;dp-&gt;i_mount
)paren
op_div
l_int|8
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Binary search.  (note: small blocks will skip this loop)&n;&t; */
id|hashval
op_assign
id|args-&gt;hashval
suffix:semicolon
id|probe
op_assign
id|span
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_div
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|probe
)braket
suffix:semicolon
id|span
OG
l_int|4
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|probe
)braket
)paren
(brace
id|span
op_div_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OL
id|hashval
)paren
id|probe
op_add_assign
id|span
suffix:semicolon
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OG
id|hashval
)paren
id|probe
op_sub_assign
id|span
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
id|probe
op_ge
l_int|0
)paren
op_logical_and
"&bslash;"
(paren
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|probe
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|span
op_le
l_int|4
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hashval
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since we may have duplicate hashval&squot;s, find the first matching&n;&t; * hashval in the leaf.&n;&t; */
r_while
c_loop
(paren
(paren
id|probe
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|hashval
)paren
)paren
(brace
id|entry
op_decrement
suffix:semicolon
id|probe
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|probe
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OL
id|hashval
)paren
)paren
(brace
id|entry
op_increment
suffix:semicolon
id|probe
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|probe
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ne
id|hashval
)paren
)paren
(brace
id|args-&gt;index
op_assign
id|probe
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Duplicate keys may be present, so search all of them for a match.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
(paren
id|probe
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hashval
)paren
suffix:semicolon
id|entry
op_increment
comma
id|probe
op_increment
)paren
(brace
multiline_comment|/*&n; * GROT: Add code to remove incomplete entries.&n; */
multiline_comment|/*&n;&t;&t; * If we are looking for INCOMPLETE entries, show only those.&n;&t;&t; * If we are looking for complete entries, show only those.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|args-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
op_ne
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|probe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_loc-&gt;namelen
op_ne
id|args-&gt;namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|args-&gt;name
comma
(paren
r_char
op_star
)paren
id|name_loc-&gt;nameval
comma
id|args-&gt;namelen
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
)paren
r_continue
suffix:semicolon
id|args-&gt;index
op_assign
id|probe
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|probe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_rmt-&gt;namelen
op_ne
id|args-&gt;namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|args-&gt;name
comma
(paren
r_char
op_star
)paren
id|name_rmt-&gt;name
comma
id|args-&gt;namelen
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|args-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
)paren
r_continue
suffix:semicolon
id|args-&gt;index
op_assign
id|probe
suffix:semicolon
id|args-&gt;rmtblkno
op_assign
id|INT_GET
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args-&gt;rmtblkcnt
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|args-&gt;dp-&gt;i_mount
comma
id|INT_GET
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
)brace
id|args-&gt;index
op_assign
id|probe
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOATTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the value associated with an attribute name from a leaf attribute&n; * list structure.&n; */
r_int
DECL|function|xfs_attr_leaf_getvalue
id|xfs_attr_leaf_getvalue
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_da_args_t
op_star
id|args
)paren
(brace
r_int
id|valuelen
suffix:semicolon
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|args-&gt;dp-&gt;i_mount
)paren
op_div
l_int|8
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index
OL
(paren
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|args-&gt;index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|name_loc-&gt;namelen
op_eq
id|args-&gt;namelen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|name_loc-&gt;nameval
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|valuelen
op_assign
id|INT_GET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
(brace
id|args-&gt;valuelen
op_assign
id|valuelen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args-&gt;valuelen
OL
id|valuelen
)paren
(brace
id|args-&gt;valuelen
op_assign
id|valuelen
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ERANGE
)paren
suffix:semicolon
)brace
id|args-&gt;valuelen
op_assign
id|valuelen
suffix:semicolon
id|memcpy
c_func
(paren
id|args-&gt;value
comma
op_amp
id|name_loc-&gt;nameval
(braket
id|args-&gt;namelen
)braket
comma
id|valuelen
)paren
suffix:semicolon
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|name_rmt-&gt;namelen
op_eq
id|args-&gt;namelen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|name_rmt-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|valuelen
op_assign
id|INT_GET
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args-&gt;rmtblkno
op_assign
id|INT_GET
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args-&gt;rmtblkcnt
op_assign
id|XFS_B_TO_FSB
c_func
(paren
id|args-&gt;dp-&gt;i_mount
comma
id|valuelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
(brace
id|args-&gt;valuelen
op_assign
id|valuelen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args-&gt;valuelen
OL
id|valuelen
)paren
(brace
id|args-&gt;valuelen
op_assign
id|valuelen
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ERANGE
)paren
suffix:semicolon
)brace
id|args-&gt;valuelen
op_assign
id|valuelen
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Utility routines.&n; *========================================================================*/
multiline_comment|/*&n; * Move the indicated entries from one leaf to another.&n; * NOTE: this routine modifies both source and destination leaves.&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_void
DECL|function|xfs_attr_leaf_moveents
id|xfs_attr_leaf_moveents
c_func
(paren
id|xfs_attr_leafblock_t
op_star
id|leaf_s
comma
r_int
id|start_s
comma
id|xfs_attr_leafblock_t
op_star
id|leaf_d
comma
r_int
id|start_d
comma
r_int
id|count
comma
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_attr_leaf_hdr_t
op_star
id|hdr_s
comma
op_star
id|hdr_d
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry_s
comma
op_star
id|entry_d
suffix:semicolon
r_int
id|desti
comma
id|tmp
comma
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Check for nothing to do.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Set up environment.&n;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf_s-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf_d-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|hdr_s
op_assign
op_amp
id|leaf_s-&gt;hdr
suffix:semicolon
id|hdr_d
op_assign
op_amp
id|leaf_d-&gt;hdr
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_div
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry_s
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr_s
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
OL
(paren
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
op_div
l_int|8
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
(paren
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
op_star
id|entry_d
)paren
)paren
op_plus
r_sizeof
(paren
op_star
id|hdr_d
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_s
OL
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|start_d
op_le
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|count
op_le
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Move the entries in the destination leaf up to make a hole?&n;&t; */
r_if
c_cond
(paren
id|start_d
OL
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|start_d
suffix:semicolon
id|tmp
op_mul_assign
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_d-&gt;entries
(braket
id|start_d
)braket
suffix:semicolon
id|entry_d
op_assign
op_amp
id|leaf_d-&gt;entries
(braket
id|start_d
op_plus
id|count
)braket
suffix:semicolon
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_d
comma
(paren
r_char
op_star
)paren
id|entry_s
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Copy all entry&squot;s in the same (sorted) order,&n;&t; * but allocate attribute info packed and in sequence.&n;&t; */
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
)braket
suffix:semicolon
id|entry_d
op_assign
op_amp
id|leaf_d-&gt;entries
(braket
id|start_d
)braket
suffix:semicolon
id|desti
op_assign
id|start_d
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|entry_s
op_increment
comma
id|entry_d
op_increment
comma
id|desti
op_increment
comma
id|i
op_increment
)paren
(brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry_s-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_ge
id|INT_GET
c_func
(paren
id|hdr_s-&gt;firstused
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|xfs_attr_leaf_entsize
c_func
(paren
id|leaf_s
comma
id|start_s
op_plus
id|i
)paren
suffix:semicolon
macro_line|#ifdef GROT
multiline_comment|/*&n;&t;&t; * Code to drop INCOMPLETE entries.  Difficult to use as we&n;&t;&t; * may also need to change the insertion index.  Code turned&n;&t;&t; * off for 6.2, should be revisited later.&n;&t;&t; */
r_if
c_cond
(paren
id|entry_s-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
(brace
multiline_comment|/* skip partials? */
id|memset
c_func
(paren
id|XFS_ATTR_LEAF_NAME
c_func
(paren
id|leaf_s
comma
id|start_s
op_plus
id|i
)paren
comma
l_int|0
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_s-&gt;usedbytes
comma
id|ARCH_CONVERT
comma
op_minus
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|entry_d
op_decrement
suffix:semicolon
multiline_comment|/* to compensate for ++ in loop hdr */
id|desti
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start_s
op_plus
id|i
)paren
OL
id|offset
)paren
id|result
op_increment
suffix:semicolon
multiline_comment|/* insertion index adjustment */
)brace
r_else
(brace
macro_line|#endif /* GROT */
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
comma
op_minus
id|tmp
)paren
suffix:semicolon
multiline_comment|/* both on-disk, don&squot;t endian flip twice */
id|entry_d-&gt;hashval
op_assign
id|entry_s-&gt;hashval
suffix:semicolon
multiline_comment|/* both on-disk, don&squot;t endian flip twice */
id|entry_d-&gt;nameidx
op_assign
id|hdr_d-&gt;firstused
suffix:semicolon
id|entry_d-&gt;flags
op_assign
id|entry_s-&gt;flags
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry_d-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_plus
id|tmp
op_le
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|XFS_ATTR_LEAF_NAME
c_func
(paren
id|leaf_d
comma
id|desti
)paren
comma
id|XFS_ATTR_LEAF_NAME
c_func
(paren
id|leaf_s
comma
id|start_s
op_plus
id|i
)paren
comma
id|tmp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry_s-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_plus
id|tmp
op_le
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|XFS_ATTR_LEAF_NAME
c_func
(paren
id|leaf_s
comma
id|start_s
op_plus
id|i
)paren
comma
l_int|0
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_s-&gt;usedbytes
comma
id|ARCH_CONVERT
comma
op_minus
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;usedbytes
comma
id|ARCH_CONVERT
comma
id|tmp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
op_plus
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_ge
id|tmp
)paren
suffix:semicolon
macro_line|#ifdef GROT
)brace
macro_line|#endif /* GROT */
)brace
multiline_comment|/*&n;&t; * Zero out the entries we just copied.&n;&t; */
r_if
c_cond
(paren
id|start_s
op_eq
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|tmp
op_assign
id|count
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|entry_s
op_plus
id|tmp
)paren
op_le
(paren
(paren
r_char
op_star
)paren
id|leaf_s
op_plus
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_s
comma
l_int|0
comma
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Move the remaining entries down to fill the hole,&n;&t;&t; * then zero the entries at the top.&n;&t;&t; */
id|tmp
op_assign
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
id|count
suffix:semicolon
id|tmp
op_mul_assign
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
op_plus
id|count
)braket
suffix:semicolon
id|entry_d
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|start_s
)braket
suffix:semicolon
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_d
comma
(paren
r_char
op_star
)paren
id|entry_s
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_assign
id|count
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
suffix:semicolon
id|entry_s
op_assign
op_amp
id|leaf_s-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|hdr_s-&gt;count
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|entry_s
op_plus
id|tmp
)paren
op_le
(paren
(paren
r_char
op_star
)paren
id|leaf_s
op_plus
id|XFS_LBSIZE
c_func
(paren
id|mp
)paren
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|entry_s
comma
l_int|0
comma
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the freemap information&n;&t; */
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
r_sizeof
(paren
id|xfs_attr_leaf_hdr_t
)paren
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr_d-&gt;count
comma
id|ARCH_CONVERT
)paren
op_star
r_sizeof
(paren
id|xfs_attr_leaf_entry_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|size
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|hdr_d-&gt;firstused
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|0
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|1
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|2
)braket
dot
id|base
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|1
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|hdr_d-&gt;freemap
(braket
l_int|2
)braket
dot
id|size
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|hdr_s-&gt;holes
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* leaf may not be compact */
)brace
multiline_comment|/*&n; * Compare two leaf blocks &quot;order&quot;.&n; * Return 0 unless leaf2 should go before leaf1.&n; */
r_int
DECL|function|xfs_attr_leaf_order
id|xfs_attr_leaf_order
c_func
(paren
id|xfs_dabuf_t
op_star
id|leaf1_bp
comma
id|xfs_dabuf_t
op_star
id|leaf2_bp
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf1
comma
op_star
id|leaf2
suffix:semicolon
id|leaf1
op_assign
id|leaf1_bp-&gt;data
suffix:semicolon
id|leaf2
op_assign
id|leaf2_bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|leaf1-&gt;entries
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_or
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|leaf1-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Pick up the last hashvalue from a leaf block.&n; */
id|xfs_dahash_t
DECL|function|xfs_attr_leaf_lasthash
id|xfs_attr_leaf_lasthash
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
op_star
id|count
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
op_star
id|count
op_assign
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|INT_GET
c_func
(paren
id|leaf-&gt;entries
(braket
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate the number of bytes used to store the indicated attribute&n; * (whether local or remote only calculate bytes in this block).&n; */
r_int
DECL|function|xfs_attr_leaf_entsize
id|xfs_attr_leaf_entsize
c_func
(paren
id|xfs_attr_leafblock_t
op_star
id|leaf
comma
r_int
id|index
)paren
(brace
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
r_int
id|size
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|leaf-&gt;entries
(braket
id|index
)braket
dot
id|flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|index
)paren
suffix:semicolon
id|size
op_assign
id|XFS_ATTR_LEAF_ENTSIZE_LOCAL
c_func
(paren
id|name_loc-&gt;namelen
comma
id|INT_GET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|index
)paren
suffix:semicolon
id|size
op_assign
id|XFS_ATTR_LEAF_ENTSIZE_REMOTE
c_func
(paren
id|name_rmt-&gt;namelen
)paren
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate the number of bytes that would be required to store the new&n; * attribute (whether local or remote only calculate bytes in this block).&n; * This routine decides as a side effect whether the attribute will be&n; * a &quot;local&quot; or a &quot;remote&quot; attribute.&n; */
r_int
DECL|function|xfs_attr_leaf_newentsize
id|xfs_attr_leaf_newentsize
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|blocksize
comma
r_int
op_star
id|local
)paren
(brace
r_int
id|size
suffix:semicolon
id|size
op_assign
id|XFS_ATTR_LEAF_ENTSIZE_LOCAL
c_func
(paren
id|args-&gt;namelen
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|XFS_ATTR_LEAF_ENTSIZE_LOCAL_MAX
c_func
(paren
id|blocksize
)paren
)paren
(brace
r_if
c_cond
(paren
id|local
)paren
(brace
op_star
id|local
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|size
op_assign
id|XFS_ATTR_LEAF_ENTSIZE_REMOTE
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|local
)paren
(brace
op_star
id|local
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy out attribute list entries for attr_list(), for leaf attribute lists.&n; */
r_int
DECL|function|xfs_attr_leaf_list_int
id|xfs_attr_leaf_list_int
c_func
(paren
id|xfs_dabuf_t
op_star
id|bp
comma
id|xfs_attr_list_context_t
op_star
id|context
)paren
(brace
id|attrlist_cursor_kern_t
op_star
id|cursor
suffix:semicolon
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
r_int
id|retval
comma
id|i
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|cursor
op_assign
id|context-&gt;cursor
suffix:semicolon
id|cursor-&gt;initted
op_assign
l_int|1
suffix:semicolon
id|xfs_attr_trace_l_cl
c_func
(paren
l_string|&quot;blk start&quot;
comma
id|context
comma
id|leaf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Re-find our place in the leaf block if this is a new syscall.&n;&t; */
r_if
c_cond
(paren
id|context-&gt;resynch
)paren
(brace
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|cursor-&gt;hashval
)paren
(brace
r_if
c_cond
(paren
id|cursor-&gt;offset
op_eq
id|context-&gt;dupcnt
)paren
(brace
id|context-&gt;dupcnt
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|context-&gt;dupcnt
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OG
id|cursor-&gt;hashval
)paren
(brace
id|context-&gt;dupcnt
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;not found&quot;
comma
id|context
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
)brace
id|context-&gt;resynch
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We have found our place, start copying out the new attributes.&n;&t; */
id|retval
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_and
(paren
id|retval
op_eq
l_int|0
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
r_int
id|ns
op_assign
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
ques
c_cond
id|ROOT_NAMES
suffix:colon
id|USER_NAMES
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_ne
id|cursor-&gt;hashval
)paren
(brace
id|cursor-&gt;hashval
op_assign
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|cursor-&gt;offset
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip incomplete entries */
r_if
c_cond
(paren
(paren
(paren
id|context-&gt;flags
op_amp
id|ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_ne
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_ROOT
)paren
op_ne
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNFULLS
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip non-matching entries */
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
(brace
id|ASSERT
c_func
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNAMELS
)paren
suffix:semicolon
id|context-&gt;count
op_add_assign
id|xfs_namespaces
(braket
id|ns
)braket
dot
id|namelen
op_plus
(paren
r_int
)paren
id|name_loc-&gt;namelen
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|xfs_attr_put_listent
c_func
(paren
id|context
comma
id|ns
comma
(paren
r_char
op_star
)paren
id|name_loc-&gt;nameval
comma
(paren
r_int
)paren
id|name_loc-&gt;namelen
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|name_loc-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
(brace
id|ASSERT
c_func
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNAMELS
)paren
suffix:semicolon
id|context-&gt;count
op_add_assign
id|xfs_namespaces
(braket
id|ns
)braket
dot
id|namelen
op_plus
(paren
r_int
)paren
id|name_rmt-&gt;namelen
op_plus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|xfs_attr_put_listent
c_func
(paren
id|context
comma
id|ns
comma
(paren
r_char
op_star
)paren
id|name_rmt-&gt;name
comma
(paren
r_int
)paren
id|name_rmt-&gt;namelen
comma
(paren
r_int
)paren
id|INT_GET
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
id|cursor-&gt;offset
op_increment
suffix:semicolon
)brace
)brace
id|xfs_attr_trace_l_cl
c_func
(paren
l_string|&quot;blk end&quot;
comma
id|context
comma
id|leaf
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|ATTR_ENTBASESIZE
mdefine_line|#define&t;ATTR_ENTBASESIZE&t;&t;/* minimum bytes used by an attr */ &bslash;&n;&t;(((struct attrlist_ent *) 0)-&gt;a_name - (char *) 0)
DECL|macro|ATTR_ENTSIZE
mdefine_line|#define&t;ATTR_ENTSIZE(namelen)&t;&t;/* actual bytes used by an attr */ &bslash;&n;&t;((ATTR_ENTBASESIZE + (namelen) + 1 + sizeof(u_int32_t)-1) &bslash;&n;&t; &amp; ~(sizeof(u_int32_t)-1))
multiline_comment|/*&n; * Format an attribute and copy it out to the user&squot;s buffer.&n; * Take care to check values and protect against them changing later,&n; * we may be reading them directly out of a user buffer.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|xfs_attr_put_listent
id|xfs_attr_put_listent
c_func
(paren
id|xfs_attr_list_context_t
op_star
id|context
comma
r_int
id|ns
comma
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|valuelen
)paren
(brace
id|attrlist_ent_t
op_star
id|aep
suffix:semicolon
r_int
id|arraytop
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNOVAL
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;flags
op_amp
id|ATTR_KERNAMELS
)paren
(brace
r_char
op_star
id|offset
suffix:semicolon
id|xattr_namespace_t
op_star
id|nsp
suffix:semicolon
id|ASSERT
c_func
(paren
id|context-&gt;count
op_ge
l_int|0
)paren
suffix:semicolon
id|nsp
op_assign
op_amp
id|xfs_namespaces
(braket
id|ns
)braket
suffix:semicolon
id|arraytop
op_assign
id|context-&gt;count
op_plus
id|nsp-&gt;namelen
op_plus
id|namelen
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|arraytop
OG
id|context-&gt;firstu
)paren
(brace
id|context-&gt;count
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* insufficient space */
r_return
l_int|1
suffix:semicolon
)brace
id|offset
op_assign
(paren
r_char
op_star
)paren
id|context-&gt;alist
op_plus
id|context-&gt;count
suffix:semicolon
id|strncpy
c_func
(paren
id|offset
comma
id|nsp-&gt;name
comma
id|nsp-&gt;namelen
)paren
suffix:semicolon
multiline_comment|/* namespace */
id|offset
op_add_assign
id|nsp-&gt;namelen
suffix:semicolon
id|strncpy
c_func
(paren
id|offset
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
multiline_comment|/* real name */
id|offset
op_add_assign
id|namelen
suffix:semicolon
op_star
id|offset
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|context-&gt;count
op_add_assign
id|nsp-&gt;namelen
op_plus
id|namelen
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|context-&gt;count
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|context-&gt;count
OL
(paren
id|ATTR_MAX_VALUELEN
op_div
l_int|8
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|context-&gt;firstu
op_ge
r_sizeof
(paren
op_star
id|context-&gt;alist
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|context-&gt;firstu
op_le
id|context-&gt;bufsize
)paren
suffix:semicolon
id|arraytop
op_assign
r_sizeof
(paren
op_star
id|context-&gt;alist
)paren
op_plus
id|context-&gt;count
op_star
r_sizeof
(paren
id|context-&gt;alist-&gt;al_offset
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|context-&gt;firstu
op_sub_assign
id|ATTR_ENTSIZE
c_func
(paren
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|context-&gt;firstu
OL
id|arraytop
)paren
(brace
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;buffer full&quot;
comma
id|context
)paren
suffix:semicolon
id|context-&gt;alist-&gt;al_more
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|aep
op_assign
(paren
id|attrlist_ent_t
op_star
)paren
op_amp
(paren
(paren
(paren
r_char
op_star
)paren
id|context-&gt;alist
)paren
(braket
id|context-&gt;firstu
)braket
)paren
suffix:semicolon
id|aep-&gt;a_valuelen
op_assign
id|valuelen
suffix:semicolon
id|memcpy
c_func
(paren
id|aep-&gt;a_name
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
id|aep-&gt;a_name
(braket
id|namelen
)braket
op_assign
l_int|0
suffix:semicolon
id|context-&gt;alist-&gt;al_offset
(braket
id|context-&gt;count
op_increment
)braket
op_assign
id|context-&gt;firstu
suffix:semicolon
id|context-&gt;alist-&gt;al_count
op_assign
id|context-&gt;count
suffix:semicolon
id|xfs_attr_trace_l_c
c_func
(paren
l_string|&quot;add&quot;
comma
id|context
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Manage the INCOMPLETE flag in a leaf entry&n; *========================================================================*/
multiline_comment|/*&n; * Clear the INCOMPLETE flag on an entry in a leaf block.&n; */
r_int
DECL|function|xfs_attr_leaf_clearflag
id|xfs_attr_leaf_clearflag
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t; * Set up the operation.&n;&t; */
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index
op_ge
l_int|0
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|args-&gt;index
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|namelen
op_assign
id|name_loc-&gt;namelen
suffix:semicolon
id|name
op_assign
(paren
r_char
op_star
)paren
id|name_loc-&gt;nameval
suffix:semicolon
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|namelen
op_assign
id|name_rmt-&gt;namelen
suffix:semicolon
id|name
op_assign
(paren
r_char
op_star
)paren
id|name_rmt-&gt;name
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|args-&gt;hashval
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|namelen
op_eq
id|args-&gt;namelen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|memcmp
c_func
(paren
id|name
comma
id|args-&gt;name
comma
id|namelen
)paren
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|entry-&gt;flags
op_and_assign
op_complement
id|XFS_ATTR_INCOMPLETE
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;rmtblkno
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
comma
id|args-&gt;rmtblkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|name_rmt
comma
r_sizeof
(paren
op_star
id|name_rmt
)paren
)paren
)paren
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the flag value change and start the next trans in series.&n;&t; */
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;dp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the INCOMPLETE flag on an entry in a leaf block.&n; */
r_int
DECL|function|xfs_attr_leaf_setflag
id|xfs_attr_leaf_setflag
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the operation.&n;&t; */
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index
op_ge
l_int|0
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
id|args-&gt;index
)braket
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|entry-&gt;flags
op_or_assign
id|XFS_ATTR_INCOMPLETE
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
op_eq
l_int|0
)paren
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|args-&gt;index
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf
comma
id|name_rmt
comma
r_sizeof
(paren
op_star
id|name_rmt
)paren
)paren
)paren
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the flag value change and start the next trans in series.&n;&t; */
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;dp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * In a single transaction, clear the INCOMPLETE flag on the leaf entry&n; * given by args-&gt;blkno/index and set the INCOMPLETE flag on the leaf&n; * entry given by args-&gt;blkno2/index2.&n; *&n; * Note that they could be in different blocks, or in the same block.&n; */
r_int
DECL|function|xfs_attr_leaf_flipflags
id|xfs_attr_leaf_flipflags
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf1
comma
op_star
id|leaf2
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry1
comma
op_star
id|entry2
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp1
comma
op_star
id|bp2
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_attr_leaf_name_local_t
op_star
id|name_loc
suffix:semicolon
r_int
id|namelen1
comma
id|namelen2
suffix:semicolon
r_char
op_star
id|name1
comma
op_star
id|name2
suffix:semicolon
macro_line|#endif /* DEBUG */
multiline_comment|/*&n;&t; * Read the block containing the &quot;old&quot; attr&n;&t; */
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno
comma
op_minus
l_int|1
comma
op_amp
id|bp1
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp1
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the block containing the &quot;new&quot; attr, if it is different&n;&t; */
r_if
c_cond
(paren
id|args-&gt;blkno2
op_ne
id|args-&gt;blkno
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|args-&gt;trans
comma
id|args-&gt;dp
comma
id|args-&gt;blkno2
comma
op_minus
l_int|1
comma
op_amp
id|bp2
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp2
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|bp2
op_assign
id|bp1
suffix:semicolon
)brace
id|leaf1
op_assign
id|bp1-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index
OL
id|INT_GET
c_func
(paren
id|leaf1-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index
op_ge
l_int|0
)paren
suffix:semicolon
id|entry1
op_assign
op_amp
id|leaf1-&gt;entries
(braket
id|args-&gt;index
)braket
suffix:semicolon
id|leaf2
op_assign
id|bp2-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index2
OL
id|INT_GET
c_func
(paren
id|leaf2-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;index2
op_ge
l_int|0
)paren
suffix:semicolon
id|entry2
op_assign
op_amp
id|leaf2-&gt;entries
(braket
id|args-&gt;index2
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|entry1-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf1
comma
id|args-&gt;index
)paren
suffix:semicolon
id|namelen1
op_assign
id|name_loc-&gt;namelen
suffix:semicolon
id|name1
op_assign
(paren
r_char
op_star
)paren
id|name_loc-&gt;nameval
suffix:semicolon
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf1
comma
id|args-&gt;index
)paren
suffix:semicolon
id|namelen1
op_assign
id|name_rmt-&gt;namelen
suffix:semicolon
id|name1
op_assign
(paren
r_char
op_star
)paren
id|name_rmt-&gt;name
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry2-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
(brace
id|name_loc
op_assign
id|XFS_ATTR_LEAF_NAME_LOCAL
c_func
(paren
id|leaf2
comma
id|args-&gt;index2
)paren
suffix:semicolon
id|namelen2
op_assign
id|name_loc-&gt;namelen
suffix:semicolon
id|name2
op_assign
(paren
r_char
op_star
)paren
id|name_loc-&gt;nameval
suffix:semicolon
)brace
r_else
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf2
comma
id|args-&gt;index2
)paren
suffix:semicolon
id|namelen2
op_assign
id|name_rmt-&gt;namelen
suffix:semicolon
id|name2
op_assign
(paren
r_char
op_star
)paren
id|name_rmt-&gt;name
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|entry1-&gt;hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|entry2-&gt;hashval
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|namelen1
op_eq
id|namelen2
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|memcmp
c_func
(paren
id|name1
comma
id|name2
comma
id|namelen1
)paren
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|ASSERT
c_func
(paren
id|entry1-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|entry2-&gt;flags
op_amp
id|XFS_ATTR_INCOMPLETE
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|entry1-&gt;flags
op_and_assign
op_complement
id|XFS_ATTR_INCOMPLETE
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp1
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf1
comma
id|entry1
comma
r_sizeof
(paren
op_star
id|entry1
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;rmtblkno
)paren
(brace
id|ASSERT
c_func
(paren
(paren
id|entry1-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf1
comma
id|args-&gt;index
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
comma
id|args-&gt;rmtblkno
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
comma
id|args-&gt;valuelen
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp1
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf1
comma
id|name_rmt
comma
r_sizeof
(paren
op_star
id|name_rmt
)paren
)paren
)paren
suffix:semicolon
)brace
id|entry2-&gt;flags
op_or_assign
id|XFS_ATTR_INCOMPLETE
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp2
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf2
comma
id|entry2
comma
r_sizeof
(paren
op_star
id|entry2
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry2-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
op_eq
l_int|0
)paren
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf2
comma
id|args-&gt;index2
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|args-&gt;trans
comma
id|bp2
comma
id|XFS_DA_LOGRANGE
c_func
(paren
id|leaf2
comma
id|name_rmt
comma
r_sizeof
(paren
op_star
id|name_rmt
)paren
)paren
)paren
suffix:semicolon
)brace
id|xfs_da_buf_done
c_func
(paren
id|bp1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp1
op_ne
id|bp2
)paren
id|xfs_da_buf_done
c_func
(paren
id|bp2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the flag value change and start the next trans in series.&n;&t; */
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
op_amp
id|args-&gt;trans
comma
id|args-&gt;dp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*========================================================================&n; * Indiscriminately delete the entire attribute fork&n; *========================================================================*/
multiline_comment|/*&n; * Recurse (gasp!) through the attribute nodes until we find leaves.&n; * We&squot;re doing a depth-first traversal in order to invalidate everything.&n; */
r_int
DECL|function|xfs_attr_root_inactive
id|xfs_attr_root_inactive
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
)paren
(brace
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
id|xfs_daddr_t
id|blkno
suffix:semicolon
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Read block 0 to see what we have to work with.&n;&t; * We only get here if we have extents, since we remove&n;&t; * the extents in reverse order the extent containing&n;&t; * block 0 must still be there.&n;&t; */
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
op_star
id|trans
comma
id|dp
comma
l_int|0
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|blkno
op_assign
id|xfs_da_blkno
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Invalidate the tree, even if the &quot;tree&quot; is only a single leaf block.&n;&t; * This is a depth-first traversal!&n;&t; */
id|info
op_assign
id|bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
(brace
id|error
op_assign
id|xfs_attr_node_inactive
c_func
(paren
id|trans
comma
id|dp
comma
id|bp
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
(brace
id|error
op_assign
id|xfs_attr_leaf_inactive
c_func
(paren
id|trans
comma
id|dp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Invalidate the incore copy of the root block.&n;&t; */
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
op_star
id|trans
comma
id|dp
comma
l_int|0
comma
id|blkno
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|xfs_da_binval
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* remove from cache */
multiline_comment|/*&n;&t; * Commit the invalidate and start the next transaction.&n;&t; */
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
id|trans
comma
id|dp
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Recurse (gasp!) through the attribute nodes until we find leaves.&n; * We&squot;re doing a depth-first traversal in order to invalidate everything.&n; */
r_int
DECL|function|xfs_attr_node_inactive
id|xfs_attr_node_inactive
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
id|level
)paren
(brace
id|xfs_da_blkinfo_t
op_star
id|info
suffix:semicolon
id|xfs_da_intnode_t
op_star
id|node
suffix:semicolon
id|xfs_dablk_t
id|child_fsb
suffix:semicolon
id|xfs_daddr_t
id|parent_blkno
comma
id|child_blkno
suffix:semicolon
r_int
id|error
comma
id|count
comma
id|i
suffix:semicolon
id|xfs_dabuf_t
op_star
id|child_bp
suffix:semicolon
multiline_comment|/*&n;&t; * Since this code is recursive (gasp!) we must protect ourselves.&n;&t; */
r_if
c_cond
(paren
id|level
OG
id|XFS_DA_NODE_MAXDEPTH
)paren
(brace
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* no locks for later trans */
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|node
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|node-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
suffix:semicolon
id|parent_blkno
op_assign
id|xfs_da_blkno
c_func
(paren
id|bp
)paren
suffix:semicolon
multiline_comment|/* save for re-read later */
id|count
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|child_fsb
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
l_int|0
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* no locks for later trans */
multiline_comment|/*&n;&t; * If this is the node level just above the leaves, simply loop&n;&t; * over the leaves removing all of them.  If this is higher up&n;&t; * in the tree, recurse downward.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Read the subsidiary block to see what we have to work with.&n;&t;&t; * Don&squot;t do this in a transaction.  This is a depth-first&n;&t;&t; * traversal of the tree so we may deal with many blocks&n;&t;&t; * before we come back to this one.&n;&t;&t; */
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
op_star
id|trans
comma
id|dp
comma
id|child_fsb
comma
op_minus
l_int|2
comma
op_amp
id|child_bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|child_bp
)paren
(brace
multiline_comment|/* save for re-read later */
id|child_blkno
op_assign
id|xfs_da_blkno
c_func
(paren
id|child_bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Invalidate the subtree, however we have to.&n;&t;&t;&t; */
id|info
op_assign
id|child_bp-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DA_NODE_MAGIC
)paren
(brace
id|error
op_assign
id|xfs_attr_node_inactive
c_func
(paren
id|trans
comma
id|dp
comma
id|child_bp
comma
id|level
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|info-&gt;magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
(brace
id|error
op_assign
id|xfs_attr_leaf_inactive
c_func
(paren
id|trans
comma
id|dp
comma
id|child_bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|child_bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Remove the subsidiary block from the cache&n;&t;&t;&t; * and from the log.&n;&t;&t;&t; */
id|error
op_assign
id|xfs_da_get_buf
c_func
(paren
op_star
id|trans
comma
id|dp
comma
l_int|0
comma
id|child_blkno
comma
op_amp
id|child_bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|xfs_da_binval
c_func
(paren
op_star
id|trans
comma
id|child_bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we&squot;re not done, re-read the parent to get the next&n;&t;&t; * child block number.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
)paren
OL
id|count
)paren
(brace
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
op_star
id|trans
comma
id|dp
comma
l_int|0
comma
id|parent_blkno
comma
op_amp
id|bp
comma
id|XFS_ATTR_FORK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|child_fsb
op_assign
id|INT_GET
c_func
(paren
id|node-&gt;btree
(braket
id|i
op_plus
l_int|1
)braket
dot
id|before
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Atomically commit the whole invalidate stuff.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
id|trans
comma
id|dp
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Invalidate all of the &quot;remote&quot; value regions pointed to by a particular&n; * leaf block.&n; * Note that we must release the lock on the buffer so that we are not&n; * caught holding something that the logging code wants to flush to disk.&n; */
r_int
DECL|function|xfs_attr_leaf_inactive
id|xfs_attr_leaf_inactive
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dabuf_t
op_star
id|bp
)paren
(brace
id|xfs_attr_leafblock_t
op_star
id|leaf
suffix:semicolon
id|xfs_attr_leaf_entry_t
op_star
id|entry
suffix:semicolon
id|xfs_attr_leaf_name_remote_t
op_star
id|name_rmt
suffix:semicolon
id|xfs_attr_inactive_list_t
op_star
id|list
comma
op_star
id|lp
suffix:semicolon
r_int
id|error
comma
id|count
comma
id|size
comma
id|tmp
comma
id|i
suffix:semicolon
id|leaf
op_assign
id|bp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_ATTR_LEAF_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Count the number of &quot;remote&quot; value extents.&n;&t; */
id|count
op_assign
l_int|0
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
)paren
id|count
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If there are no &quot;remote&quot; values, we&squot;re done.&n;&t; */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate storage for a list of all the &quot;remote&quot; value extents.&n;&t; */
id|size
op_assign
id|count
op_star
r_sizeof
(paren
id|xfs_attr_inactive_list_t
)paren
suffix:semicolon
id|list
op_assign
(paren
id|xfs_attr_inactive_list_t
op_star
)paren
id|kmem_alloc
c_func
(paren
id|size
comma
id|KM_SLEEP
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Identify each of the &quot;remote&quot; value extents.&n;&t; */
id|lp
op_assign
id|list
suffix:semicolon
id|entry
op_assign
op_amp
id|leaf-&gt;entries
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|entry
op_increment
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|entry-&gt;nameidx
comma
id|ARCH_CONVERT
)paren
op_logical_and
(paren
(paren
id|entry-&gt;flags
op_amp
id|XFS_ATTR_LOCAL
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|name_rmt
op_assign
id|XFS_ATTR_LEAF_NAME_REMOTE
c_func
(paren
id|leaf
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|name_rmt-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/* both on-disk, don&squot;t endian flip twice */
id|lp-&gt;valueblk
op_assign
id|name_rmt-&gt;valueblk
suffix:semicolon
id|INT_SET
c_func
(paren
id|lp-&gt;valuelen
comma
id|ARCH_CONVERT
comma
id|XFS_B_TO_FSB
c_func
(paren
id|dp-&gt;i_mount
comma
id|INT_GET
c_func
(paren
id|name_rmt-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|lp
op_increment
suffix:semicolon
)brace
)brace
)brace
id|xfs_da_brelse
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* unlock for trans. in freextent() */
multiline_comment|/*&n;&t; * Invalidate each of the &quot;remote&quot; value extents.&n;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|lp
op_assign
id|list
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
comma
id|lp
op_increment
)paren
(brace
id|tmp
op_assign
id|xfs_attr_leaf_freextent
c_func
(paren
id|trans
comma
id|dp
comma
id|INT_GET
c_func
(paren
id|lp-&gt;valueblk
comma
id|ARCH_CONVERT
)paren
comma
id|INT_GET
c_func
(paren
id|lp-&gt;valuelen
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|error
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* save only the 1st errno */
)brace
id|kmem_free
c_func
(paren
(paren
id|xfs_caddr_t
)paren
id|list
comma
id|size
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Look at all the extents for this logical region,&n; * invalidate any buffers that are incore/in transactions.&n; */
r_int
DECL|function|xfs_attr_leaf_freextent
id|xfs_attr_leaf_freextent
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|trans
comma
id|xfs_inode_t
op_star
id|dp
comma
id|xfs_dablk_t
id|blkno
comma
r_int
id|blkcnt
)paren
(brace
id|xfs_bmbt_irec_t
id|map
suffix:semicolon
id|xfs_dablk_t
id|tblkno
suffix:semicolon
r_int
id|tblkcnt
comma
id|dblkcnt
comma
id|nmap
comma
id|error
suffix:semicolon
id|xfs_daddr_t
id|dblkno
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/*&n;&t; * Roll through the &quot;value&quot;, invalidating the attribute value&squot;s&n;&t; * blocks.&n;&t; */
id|tblkno
op_assign
id|blkno
suffix:semicolon
id|tblkcnt
op_assign
id|blkcnt
suffix:semicolon
r_while
c_loop
(paren
id|tblkcnt
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try to remember where we decided to put the value.&n;&t;&t; */
id|nmap
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|xfs_bmapi
c_func
(paren
op_star
id|trans
comma
id|dp
comma
(paren
id|xfs_fileoff_t
)paren
id|tblkno
comma
id|tblkcnt
comma
id|XFS_BMAPI_ATTRFORK
op_or
id|XFS_BMAPI_METADATA
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|map
comma
op_amp
id|nmap
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|nmap
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|map.br_startblock
op_ne
id|DELAYSTARTBLOCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s a hole, these are already unmapped&n;&t;&t; * so there&squot;s nothing to invalidate.&n;&t;&t; */
r_if
c_cond
(paren
id|map.br_startblock
op_ne
id|HOLESTARTBLOCK
)paren
(brace
id|dblkno
op_assign
id|XFS_FSB_TO_DADDR
c_func
(paren
id|dp-&gt;i_mount
comma
id|map.br_startblock
)paren
suffix:semicolon
id|dblkcnt
op_assign
id|XFS_FSB_TO_BB
c_func
(paren
id|dp-&gt;i_mount
comma
id|map.br_blockcount
)paren
suffix:semicolon
id|bp
op_assign
id|xfs_trans_get_buf
c_func
(paren
op_star
id|trans
comma
id|dp-&gt;i_mount-&gt;m_ddev_targp
comma
id|dblkno
comma
id|dblkcnt
comma
id|XFS_BUF_LOCK
)paren
suffix:semicolon
id|xfs_trans_binval
c_func
(paren
op_star
id|trans
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Roll to next transaction.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_attr_rolltrans
c_func
(paren
id|trans
comma
id|dp
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
id|tblkno
op_add_assign
id|map.br_blockcount
suffix:semicolon
id|tblkcnt
op_sub_assign
id|map.br_blockcount
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Roll from one trans in the sequence of PERMANENT transactions to the next.&n; */
r_int
DECL|function|xfs_attr_rolltrans
id|xfs_attr_rolltrans
c_func
(paren
id|xfs_trans_t
op_star
op_star
id|transp
comma
id|xfs_inode_t
op_star
id|dp
)paren
(brace
id|xfs_trans_t
op_star
id|trans
suffix:semicolon
r_int
r_int
id|logres
comma
id|count
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Ensure that the inode is always logged.&n;&t; */
id|trans
op_assign
op_star
id|transp
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|trans
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the critical parameters from one trans to the next.&n;&t; */
id|logres
op_assign
id|trans-&gt;t_log_res
suffix:semicolon
id|count
op_assign
id|trans-&gt;t_log_count
suffix:semicolon
op_star
id|transp
op_assign
id|xfs_trans_dup
c_func
(paren
id|trans
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Commit the current transaction.&n;&t; * If this commit failed, then it&squot;d just unlock those items that&n;&t; * are not marked ihold. That also means that a filesystem shutdown&n;&t; * is in progress. The caller takes the responsibility to cancel&n;&t; * the duplicate transaction that gets returned.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|trans
comma
l_int|0
comma
l_int|NULL
)paren
)paren
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|trans
op_assign
op_star
id|transp
suffix:semicolon
multiline_comment|/*&n;&t; * Reserve space in the log for th next transaction.&n;&t; * This also pushes items in the &quot;AIL&quot;, the list of logged items,&n;&t; * out to disk if they are taking up space at the tail of the log&n;&t; * that we want to use.  This requires that either nothing be locked&n;&t; * across this call, or that anything that is locked be logged in&n;&t; * the prior and the next transactions.&n;&t; */
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|trans
comma
l_int|0
comma
id|logres
comma
l_int|0
comma
id|XFS_TRANS_PERM_LOG_RES
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Ensure that the inode is in the new transaction and locked.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|xfs_trans_ijoin
c_func
(paren
id|trans
comma
id|dp
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|trans
comma
id|dp
)paren
suffix:semicolon
)brace
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
eof
