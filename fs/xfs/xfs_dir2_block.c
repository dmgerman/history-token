multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * xfs_dir2_block.c&n; * XFS V2 directory implementation, single-block form.&n; * See xfs_dir2_block.h for the format.&n; */
macro_line|#include &lt;xfs.h&gt;
multiline_comment|/*&n; * Local function prototypes.&n; */
r_static
r_void
id|xfs_dir2_block_log_leaf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dabuf_t
op_star
id|bp
comma
r_int
id|first
comma
r_int
id|last
)paren
suffix:semicolon
r_static
r_void
id|xfs_dir2_block_log_tail
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_dabuf_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_block_lookup_int
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dabuf_t
op_star
op_star
id|bpp
comma
r_int
op_star
id|entno
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_block_sort
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
suffix:semicolon
multiline_comment|/*&n; * Add an entry to a block directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_addname
id|xfs_dir2_block_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* directory op arguments */
(brace
id|xfs_dir2_data_free_t
op_star
id|bf
suffix:semicolon
multiline_comment|/* bestfree table in block */
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* directory block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block leaf entries */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for block */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
r_int
id|compact
suffix:semicolon
multiline_comment|/* need to compact leaf ents */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* block data entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* directory inode */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* block unused entry */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_dir2_data_unused_t
op_star
id|enddup
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* unused at end of data */
id|xfs_dahash_t
id|hash
suffix:semicolon
multiline_comment|/* hash value of found entry */
r_int
id|high
suffix:semicolon
multiline_comment|/* high index for binary srch */
r_int
id|highstale
suffix:semicolon
multiline_comment|/* high stale index */
r_int
id|lfloghigh
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* last final leaf to log */
r_int
id|lfloglow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first final leaf to log */
r_int
id|len
suffix:semicolon
multiline_comment|/* length of the new entry */
r_int
id|low
suffix:semicolon
multiline_comment|/* low index for binary srch */
r_int
id|lowstale
suffix:semicolon
multiline_comment|/* low stale index */
r_int
id|mid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* midpoint for binary srch */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to rescan freespace */
id|xfs_dir2_data_off_t
op_star
id|tagp
suffix:semicolon
multiline_comment|/* pointer to tag value */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction structure */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;block_addname&quot;
comma
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Read the (one and only) directory block into dabuf bp.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|mp-&gt;m_dirdatablk
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * Check the magic number, corrupted if wrong.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_BLOCK_MAGIC
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_dir2_block_addname&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|block
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|len
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up pointers to parts of the block.&n;&t; */
id|bf
op_assign
id|block-&gt;hdr.bestfree
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No stale entries?  Need space for entry and new leaf.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Tag just before the first leaf entry.&n;&t;&t; */
id|tagp
op_assign
(paren
id|xfs_dir2_data_off_t
op_star
)paren
id|blp
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Data object just before the first leaf entry.&n;&t;&t; */
id|enddup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|INT_GET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s not free then can&squot;t do this add without cleaning up:&n;&t;&t; * the space before the first leaf entry needs to be free so it&n;&t;&t; * can be expanded to hold the pointer to the new entry.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|enddup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_DATA_FREE_TAG
)paren
id|dup
op_assign
id|enddup
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check out the biggest freespace and see if it&squot;s the same one.&n;&t;&t; */
r_else
(brace
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|0
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dup
op_eq
id|enddup
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * It is the biggest freespace, is it too small&n;&t;&t;&t;&t; * to hold the new leaf too?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
OL
id|len
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|blp
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Yes, we use the second-largest&n;&t;&t;&t;&t;&t; * entry instead if it works.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|1
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_ge
id|len
)paren
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|1
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_else
id|dup
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Not the same free entry,&n;&t;&t;&t;&t; * just check its length.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
OL
id|len
)paren
(brace
id|dup
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|compact
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are stale entries we&squot;ll use one for the leaf.&n;&t; * Is the biggest entry enough to avoid compaction?&n;&t; */
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|0
)braket
dot
id|length
comma
id|ARCH_CONVERT
)paren
op_ge
id|len
)paren
(brace
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|INT_GET
c_func
(paren
id|bf
(braket
l_int|0
)braket
dot
id|offset
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|compact
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Will need to compact to make this work.&n;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t; * Tag just before the first leaf entry.&n;&t;&t; */
id|tagp
op_assign
(paren
id|xfs_dir2_data_off_t
op_star
)paren
id|blp
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Data object just before the first leaf entry.&n;&t;&t; */
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|INT_GET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it&squot;s not free then the data will go where the&n;&t;&t; * leaf data starts now, if it works at all.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
op_plus
(paren
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|blp
)paren
OL
id|len
)paren
id|dup
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|blp
)paren
OL
id|len
)paren
id|dup
op_assign
l_int|NULL
suffix:semicolon
r_else
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|blp
suffix:semicolon
id|compact
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this isn&squot;t a real add, we&squot;re done with the buffer.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
)paren
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we don&squot;t have space for the new entry &amp; leaf ...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dup
)paren
(brace
multiline_comment|/*&n;&t;&t; * Not trying to actually do anything, or don&squot;t have&n;&t;&t; * a space reservation: return no-space.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
op_logical_or
id|args-&gt;total
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Convert to the next larger format.&n;&t;&t; * Then add the new entry in that format.&n;&t;&t; */
id|error
op_assign
id|xfs_dir2_block_to_leaf
c_func
(paren
id|args
comma
id|bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|xfs_dir2_leaf_addname
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Just checking, and it would work, so say so.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
)paren
r_return
l_int|0
suffix:semicolon
id|needlog
op_assign
id|needscan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If need to compact the leaf entries, do it now.&n;&t; * Leave the highest-numbered stale entry stale.&n;&t; * XXX should be the one closest to mid but mid is not yet computed.&n;&t; */
r_if
c_cond
(paren
id|compact
)paren
(brace
r_int
id|fromidx
suffix:semicolon
multiline_comment|/* source leaf index */
r_int
id|toidx
suffix:semicolon
multiline_comment|/* target leaf index */
r_for
c_loop
(paren
id|fromidx
op_assign
id|toidx
op_assign
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
comma
id|highstale
op_assign
id|lfloghigh
op_assign
op_minus
l_int|1
suffix:semicolon
id|fromidx
op_ge
l_int|0
suffix:semicolon
id|fromidx
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|blp
(braket
id|fromidx
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
(brace
r_if
c_cond
(paren
id|highstale
op_eq
op_minus
l_int|1
)paren
id|highstale
op_assign
id|toidx
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|lfloghigh
op_eq
op_minus
l_int|1
)paren
id|lfloghigh
op_assign
id|toidx
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fromidx
OL
id|toidx
)paren
id|blp
(braket
id|toidx
)braket
op_assign
id|blp
(braket
id|fromidx
)braket
suffix:semicolon
id|toidx
op_decrement
suffix:semicolon
)brace
id|lfloglow
op_assign
id|toidx
op_plus
l_int|1
op_minus
(paren
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|lfloghigh
op_sub_assign
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|INT_MOD
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_make_free
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|blp
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|blp
)paren
)paren
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
id|blp
op_add_assign
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|INT_SET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we now need to rebuild the bestfree map, do so.&n;&t;&t; * This needs to happen before the next call to use_free.&n;&t;&t; */
r_if
c_cond
(paren
id|needscan
)paren
(brace
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_data_t
op_star
)paren
id|block
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
id|needscan
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Set leaf logging boundaries to impossible state.&n;&t; * For the no-stale case they&squot;re set explicitly.&n;&t; */
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
id|lfloglow
op_assign
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|lfloghigh
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Find the slot that&squot;s first lower than our hash value, -1 if none.&n;&t; */
r_for
c_loop
(paren
id|low
op_assign
l_int|0
comma
id|high
op_assign
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
id|low
op_le
id|high
suffix:semicolon
)paren
(brace
id|mid
op_assign
(paren
id|low
op_plus
id|high
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hash
op_assign
id|INT_GET
c_func
(paren
id|blp
(braket
id|mid
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
id|args-&gt;hashval
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|hash
OL
id|args-&gt;hashval
)paren
id|low
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
id|high
op_assign
id|mid
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mid
op_ge
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|blp
(braket
id|mid
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_ge
id|args-&gt;hashval
)paren
(brace
id|mid
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No stale entries, will use enddup space to hold new leaf.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mark the space needed for the new leaf entry, now in use.&n;&t;&t; */
id|xfs_dir2_data_use_free
c_func
(paren
id|tp
comma
id|bp
comma
id|enddup
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|enddup
op_minus
(paren
r_char
op_star
)paren
id|block
op_plus
id|INT_GET
c_func
(paren
id|enddup-&gt;length
comma
id|ARCH_CONVERT
)paren
op_minus
r_sizeof
(paren
op_star
id|blp
)paren
)paren
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
r_sizeof
(paren
op_star
id|blp
)paren
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the tail (entry count).&n;&t;&t; */
id|INT_MOD
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we now need to rebuild the bestfree map, do so.&n;&t;&t; * This needs to happen before the next call to use_free.&n;&t;&t; */
r_if
c_cond
(paren
id|needscan
)paren
(brace
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_data_t
op_star
)paren
id|block
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
id|needscan
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Adjust pointer to the first leaf entry, we&squot;re about to move&n;&t;&t; * the table up one to open up space for the new leaf entry.&n;&t;&t; * Then adjust our index to match.&n;&t;&t; */
id|blp
op_decrement
suffix:semicolon
id|mid
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mid
)paren
id|memmove
c_func
(paren
id|blp
comma
op_amp
id|blp
(braket
l_int|1
)braket
comma
id|mid
op_star
r_sizeof
(paren
op_star
id|blp
)paren
)paren
suffix:semicolon
id|lfloglow
op_assign
l_int|0
suffix:semicolon
id|lfloghigh
op_assign
id|mid
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Use a stale leaf for our new entry.&n;&t; */
r_else
(brace
r_for
c_loop
(paren
id|lowstale
op_assign
id|mid
suffix:semicolon
id|lowstale
op_ge
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|blp
(braket
id|lowstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
suffix:semicolon
id|lowstale
op_decrement
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|highstale
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
id|highstale
OL
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|blp
(braket
id|highstale
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_NULL_DATAPTR
op_logical_and
(paren
id|lowstale
template_param
id|highstale
op_minus
id|mid
)paren
suffix:semicolon
id|highstale
op_increment
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move entries toward the low-numbered stale entry.&n;&t;&t; */
r_if
c_cond
(paren
id|lowstale
op_ge
l_int|0
op_logical_and
(paren
id|highstale
op_eq
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|mid
op_minus
id|lowstale
op_le
id|highstale
op_minus
id|mid
)paren
)paren
(brace
r_if
c_cond
(paren
id|mid
op_minus
id|lowstale
)paren
id|memmove
c_func
(paren
op_amp
id|blp
(braket
id|lowstale
)braket
comma
op_amp
id|blp
(braket
id|lowstale
op_plus
l_int|1
)braket
comma
(paren
id|mid
op_minus
id|lowstale
)paren
op_star
r_sizeof
(paren
op_star
id|blp
)paren
)paren
suffix:semicolon
id|lfloglow
op_assign
id|MIN
c_func
(paren
id|lowstale
comma
id|lfloglow
)paren
suffix:semicolon
id|lfloghigh
op_assign
id|MAX
c_func
(paren
id|mid
comma
id|lfloghigh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Move entries toward the high-numbered stale entry.&n;&t;&t; */
r_else
(brace
id|ASSERT
c_func
(paren
id|highstale
OL
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|mid
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|highstale
op_minus
id|mid
)paren
id|memmove
c_func
(paren
op_amp
id|blp
(braket
id|mid
op_plus
l_int|1
)braket
comma
op_amp
id|blp
(braket
id|mid
)braket
comma
(paren
id|highstale
op_minus
id|mid
)paren
op_star
r_sizeof
(paren
op_star
id|blp
)paren
)paren
suffix:semicolon
id|lfloglow
op_assign
id|MIN
c_func
(paren
id|mid
comma
id|lfloglow
)paren
suffix:semicolon
id|lfloghigh
op_assign
id|MAX
c_func
(paren
id|highstale
comma
id|lfloghigh
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Point to the new data entry.&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|dup
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the leaf entry.&n;&t; */
id|INT_SET
c_func
(paren
id|blp
(braket
id|mid
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
comma
id|args-&gt;hashval
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|blp
(braket
id|mid
)braket
dot
id|address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_BYTE_TO_DATAPTR
c_func
(paren
id|mp
comma
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
id|xfs_dir2_block_log_leaf
c_func
(paren
id|tp
comma
id|bp
comma
id|lfloglow
comma
id|lfloghigh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark space for the data entry used.&n;&t; */
id|xfs_dir2_data_use_free
c_func
(paren
id|tp
comma
id|bp
comma
id|dup
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
id|len
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create the new data entry.&n;&t; */
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|args-&gt;inumber
)paren
suffix:semicolon
id|dep-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|dep-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|tagp
op_assign
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean up the bestfree array and log the header, tail, and entry.&n;&t; */
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_data_t
op_star
)paren
id|block
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|xfs_dir2_block_log_tail
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|tp
comma
id|bp
comma
id|dep
)paren
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Readdir for block directories.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_getdents
id|xfs_dir2_block_getdents
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction (NULL) */
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore inode */
id|uio_t
op_star
id|uio
comma
multiline_comment|/* caller&squot;s buffer control */
r_int
op_star
id|eofp
comma
multiline_comment|/* eof reached? (out) */
id|xfs_dirent_t
op_star
id|dbp
comma
multiline_comment|/* caller&squot;s buffer */
id|xfs_dir2_put_t
id|put
)paren
multiline_comment|/* abi&squot;s formatting function */
(brace
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* directory block structure */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* buffer for block */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* block data entry */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* block unused entry */
r_char
op_star
id|endptr
suffix:semicolon
multiline_comment|/* end of the data entries */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_put_args_t
id|p
suffix:semicolon
multiline_comment|/* arg package for put rtn */
r_char
op_star
id|ptr
suffix:semicolon
multiline_comment|/* current data entry */
r_int
id|wantoff
suffix:semicolon
multiline_comment|/* starting block offset */
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * If the block number in the offset is out of range, we&squot;re done.&n;&t; */
r_if
c_cond
(paren
id|XFS_DIR2_DATAPTR_TO_DB
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
OG
id|mp-&gt;m_dirdatablk
)paren
(brace
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Can&squot;t read the block, give up, else get dabuf in bp.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|mp-&gt;m_dirdatablk
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Extract the byte offset we start at from the seek pointer.&n;&t; * We&squot;ll skip entries before this.&n;&t; */
id|wantoff
op_assign
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|uio-&gt;uio_offset
)paren
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up values for the loop.&n;&t; */
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_char
op_star
)paren
id|block-&gt;u
suffix:semicolon
id|endptr
op_assign
(paren
r_char
op_star
)paren
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|p.dbp
op_assign
id|dbp
suffix:semicolon
id|p.put
op_assign
id|put
suffix:semicolon
id|p.uio
op_assign
id|uio
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the data portion of the block.&n;&t; * Each object is a real entry (dep) or an unused one (dup).&n;&t; */
r_while
c_loop
(paren
id|ptr
OL
id|endptr
)paren
(brace
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|ptr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Unused, skip it.&n;&t;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
(brace
id|ptr
op_add_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|ptr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Bump pointer for the next iteration.&n;&t;&t; */
id|ptr
op_add_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The entry is before the desired starting point, skip it.&n;&t;&t; */
r_if
c_cond
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
OL
id|wantoff
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up argument structure for put routine.&n;&t;&t; */
id|p.namelen
op_assign
id|dep-&gt;namelen
suffix:semicolon
id|p.cook
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|ptr
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
id|p.ino
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
op_plus
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#else
id|p.ino
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#endif
id|p.name
op_assign
(paren
r_char
op_star
)paren
id|dep-&gt;name
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put the entry in the caller&squot;s buffer.&n;&t;&t; */
id|error
op_assign
id|p
dot
id|put
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If it didn&squot;t fit, set the final offset to here &amp; return.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|p.done
)paren
(brace
id|uio-&gt;uio_offset
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Reached the end of the block.&n;&t; * Set the offset to a nonexistent block 1 and return.&n;&t; */
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
id|uio-&gt;uio_offset
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Log leaf entries from the block.&n; */
r_static
r_void
DECL|function|xfs_dir2_block_log_leaf
id|xfs_dir2_block_log_leaf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction structure */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* block buffer */
r_int
id|first
comma
multiline_comment|/* index of first logged leaf */
r_int
id|last
)paren
multiline_comment|/* index of last logged leaf */
(brace
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* directory block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block leaf entries */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|blp
(braket
id|first
)braket
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|blp
(braket
id|last
op_plus
l_int|1
)braket
op_minus
(paren
r_char
op_star
)paren
id|block
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log the block tail.&n; */
r_static
r_void
DECL|function|xfs_dir2_block_log_tail
id|xfs_dir2_block_log_tail
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction structure */
id|xfs_dabuf_t
op_star
id|bp
)paren
multiline_comment|/* block buffer */
(brace
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* directory block structure */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|xfs_da_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|btp
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|btp
op_plus
l_int|1
)paren
op_minus
(paren
r_char
op_star
)paren
id|block
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up an entry in the block.  This is the external routine,&n; * xfs_dir2_block_lookup_int does the real work.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_lookup
id|xfs_dir2_block_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* dir lookup arguments */
(brace
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block leaf entries */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* block buffer */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* block data entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore inode */
r_int
id|ent
suffix:semicolon
multiline_comment|/* entry index */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;block_lookup&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the buffer, look up the entry.&n;&t; * If not found (ENOENT) then return, have no buffer.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_block_lookup_int
c_func
(paren
id|args
comma
op_amp
id|bp
comma
op_amp
id|ent
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the offset from the leaf entry, to point to the data.&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|blp
(braket
id|ent
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in inode number, release the block.&n;&t; */
id|args-&gt;inumber
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|args-&gt;trans
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Internal block lookup routine.&n; */
r_static
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_lookup_int
id|xfs_dir2_block_lookup_int
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* dir lookup arguments */
id|xfs_dabuf_t
op_star
op_star
id|bpp
comma
multiline_comment|/* returned block buffer */
r_int
op_star
id|entno
)paren
multiline_comment|/* returned entry number */
(brace
id|xfs_dir2_dataptr_t
id|addr
suffix:semicolon
multiline_comment|/* data entry address */
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block leaf entries */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* block buffer */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* block data entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_dahash_t
id|hash
suffix:semicolon
multiline_comment|/* found hash value */
r_int
id|high
suffix:semicolon
multiline_comment|/* binary search high index */
r_int
id|low
suffix:semicolon
multiline_comment|/* binary search low index */
r_int
id|mid
suffix:semicolon
multiline_comment|/* binary search current idx */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Read the buffer, return error if we can&squot;t get it.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|mp-&gt;m_dirdatablk
comma
op_minus
l_int|1
comma
op_amp
id|bp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|bp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop doing a binary search for our hash value.&n;&t; * Find our entry, ENOENT if it&squot;s not there.&n;&t; */
r_for
c_loop
(paren
id|low
op_assign
l_int|0
comma
id|high
op_assign
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
suffix:semicolon
suffix:semicolon
)paren
(brace
id|ASSERT
c_func
(paren
id|low
op_le
id|high
)paren
suffix:semicolon
id|mid
op_assign
(paren
id|low
op_plus
id|high
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hash
op_assign
id|INT_GET
c_func
(paren
id|blp
(braket
id|mid
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
id|args-&gt;hashval
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|hash
OL
id|args-&gt;hashval
)paren
id|low
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
r_else
id|high
op_assign
id|mid
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|low
OG
id|high
)paren
(brace
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Back up to the first one with the right hash value.&n;&t; */
r_while
c_loop
(paren
id|mid
OG
l_int|0
op_logical_and
id|INT_GET
c_func
(paren
id|blp
(braket
id|mid
op_minus
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|args-&gt;hashval
)paren
(brace
id|mid
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now loop forward through all the entries with the&n;&t; * right hash value looking for our name.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
(paren
id|addr
op_assign
id|INT_GET
c_func
(paren
id|blp
(braket
id|mid
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get pointer to the entry from the leaf.&n;&t;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|addr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compare, if it&squot;s right give back buffer &amp; entry number.&n;&t;&t; */
r_if
c_cond
(paren
id|dep-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|dep-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|dep-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
op_star
id|entno
op_assign
id|mid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_increment
id|mid
OL
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|blp
(braket
id|mid
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
)paren
op_eq
id|hash
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * No match, release the buffer and return ENOENT.&n;&t; */
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
id|xfs_da_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from a block format directory.&n; * If that makes the block small enough to fit in shortform, transform it.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_removename
id|xfs_dir2_block_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* directory operation args */
(brace
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block leaf pointer */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* block buffer */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* block data entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore inode */
r_int
id|ent
suffix:semicolon
multiline_comment|/* block leaf entry index */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log block header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to fixup bestfree */
id|xfs_dir2_sf_hdr_t
id|sfh
suffix:semicolon
multiline_comment|/* shortform header */
r_int
id|size
suffix:semicolon
multiline_comment|/* shortform size */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;block_removename&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the entry in the block.  Gets the buffer and entry index.&n;&t; * It will always be there, the vnodeops level does a lookup first.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_block_lookup_int
c_func
(paren
id|args
comma
op_amp
id|bp
comma
op_amp
id|ent
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the data entry using the leaf entry.&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|blp
(braket
id|ent
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the data entry&squot;s space free.&n;&t; */
id|needlog
op_assign
id|needscan
op_assign
l_int|0
suffix:semicolon
id|xfs_dir2_data_make_free
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the block tail.&n;&t; */
id|INT_MOD
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
comma
op_plus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_block_log_tail
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove the leaf entry by marking it stale.&n;&t; */
id|INT_SET
c_func
(paren
id|blp
(braket
id|ent
)braket
dot
id|address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_NULL_DATAPTR
)paren
suffix:semicolon
id|xfs_dir2_block_log_leaf
c_func
(paren
id|tp
comma
id|bp
comma
id|ent
comma
id|ent
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up bestfree, log the header if necessary.&n;&t; */
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_data_t
op_star
)paren
id|block
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if the size as a shortform is good enough.&n;&t; */
r_if
c_cond
(paren
(paren
id|size
op_assign
id|xfs_dir2_block_sfsize
c_func
(paren
id|dp
comma
id|block
comma
op_amp
id|sfh
)paren
)paren
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
(brace
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If it works, do the conversion.&n;&t; */
r_return
id|xfs_dir2_block_to_sf
c_func
(paren
id|args
comma
id|bp
comma
id|size
comma
op_amp
id|sfh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace an entry in a V2 block directory.&n; * Change the inode number to the new value.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_replace
id|xfs_dir2_block_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* directory operation args */
(brace
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block leaf entries */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* block buffer */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* block data entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore inode */
r_int
id|ent
suffix:semicolon
multiline_comment|/* leaf entry index */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;block_replace&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lookup the entry in the directory.  Get buffer and entry index.&n;&t; * This will always succeed since the caller has already done a lookup.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_block_lookup_int
c_func
(paren
id|args
comma
op_amp
id|bp
comma
op_amp
id|ent
)paren
)paren
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Point to the data entry we need to change.&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|INT_GET
c_func
(paren
id|blp
(braket
id|ent
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
op_ne
id|args-&gt;inumber
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Change the inode number to the new value.&n;&t; */
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|args-&gt;inumber
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|args-&gt;trans
comma
id|bp
comma
id|dep
)paren
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Qsort comparison routine for the block leaf entries.&n; */
r_static
r_int
multiline_comment|/* sort order */
DECL|function|xfs_dir2_block_sort
id|xfs_dir2_block_sort
c_func
(paren
r_const
r_void
op_star
id|a
comma
multiline_comment|/* first leaf entry */
r_const
r_void
op_star
id|b
)paren
multiline_comment|/* second leaf entry */
(brace
r_const
id|xfs_dir2_leaf_entry_t
op_star
id|la
suffix:semicolon
multiline_comment|/* first leaf entry */
r_const
id|xfs_dir2_leaf_entry_t
op_star
id|lb
suffix:semicolon
multiline_comment|/* second leaf entry */
id|la
op_assign
id|a
suffix:semicolon
id|lb
op_assign
id|b
suffix:semicolon
r_return
id|INT_GET
c_func
(paren
id|la-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OL
id|INT_GET
c_func
(paren
id|lb-&gt;hashval
comma
id|ARCH_CONVERT
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
(paren
id|INT_GET
c_func
(paren
id|la-&gt;hashval
comma
id|ARCH_CONVERT
)paren
OG
id|INT_GET
c_func
(paren
id|lb-&gt;hashval
comma
id|ARCH_CONVERT
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a V2 leaf directory to a V2 block directory if possible.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_leaf_to_block
id|xfs_dir2_leaf_to_block
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|lbp
comma
multiline_comment|/* leaf buffer */
id|xfs_dabuf_t
op_star
id|dbp
)paren
multiline_comment|/* data buffer */
(brace
id|xfs_dir2_data_off_t
op_star
id|bestsp
suffix:semicolon
multiline_comment|/* leaf bests table */
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* unused data entry */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|from
suffix:semicolon
multiline_comment|/* leaf from index */
id|xfs_dir2_leaf_t
op_star
id|leaf
suffix:semicolon
multiline_comment|/* leaf structure */
id|xfs_dir2_leaf_entry_t
op_star
id|lep
suffix:semicolon
multiline_comment|/* leaf entry */
id|xfs_dir2_leaf_tail_t
op_star
id|ltp
suffix:semicolon
multiline_comment|/* leaf tail structure */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log data header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to scan for bestfree */
id|xfs_dir2_sf_hdr_t
id|sfh
suffix:semicolon
multiline_comment|/* shortform header */
r_int
id|size
suffix:semicolon
multiline_comment|/* bytes used */
id|xfs_dir2_data_off_t
op_star
id|tagp
suffix:semicolon
multiline_comment|/* end of entry (tag) */
r_int
id|to
suffix:semicolon
multiline_comment|/* block/leaf to index */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args_bb
c_func
(paren
l_string|&quot;leaf_to_block&quot;
comma
id|args
comma
id|lbp
comma
id|dbp
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|leaf
op_assign
id|lbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.info.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_LEAF1_MAGIC
)paren
suffix:semicolon
id|ltp
op_assign
id|XFS_DIR2_LEAF_TAIL_P
c_func
(paren
id|mp
comma
id|leaf
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If there are data blocks other than the first one, take this&n;&t; * opportunity to remove trailing empty data blocks that may have&n;&t; * been left behind during no-space-reservation operations.&n;&t; * These will show up in the leaf bests table.&n;&t; */
r_while
c_loop
(paren
id|dp-&gt;i_d.di_size
OG
id|mp-&gt;m_dirblksize
)paren
(brace
id|bestsp
op_assign
id|XFS_DIR2_LEAF_BESTS_P_ARCH
c_func
(paren
id|ltp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|bestsp
(braket
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)braket
comma
id|ARCH_CONVERT
)paren
op_eq
id|mp-&gt;m_dirblksize
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|block-&gt;hdr
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_leaf_trim_data
c_func
(paren
id|args
comma
id|lbp
comma
(paren
id|xfs_dir2_db_t
)paren
(paren
id|INT_GET
c_func
(paren
id|ltp-&gt;bestcount
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Read the data block if we don&squot;t already have it, give up if it fails.&n;&t; */
r_if
c_cond
(paren
id|dbp
op_eq
l_int|NULL
op_logical_and
(paren
id|error
op_assign
id|xfs_da_read_buf
c_func
(paren
id|tp
comma
id|dp
comma
id|mp-&gt;m_dirdatablk
comma
op_minus
l_int|1
comma
op_amp
id|dbp
comma
id|XFS_DATA_FORK
)paren
)paren
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|block
op_assign
id|dbp-&gt;data
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|block-&gt;hdr.magic
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Size of the &quot;leaf&quot; area in the block.&n;&t; */
id|size
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|block-&gt;tail
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|lep
)paren
op_star
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look at the last data entry.&n;&t; */
id|tagp
op_assign
(paren
id|xfs_dir2_data_off_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|mp-&gt;m_dirblksize
)paren
op_minus
l_int|1
suffix:semicolon
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|INT_GET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s not free or is too short we can&squot;t do it.&n;&t; */
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_ne
id|XFS_DIR2_DATA_FREE_TAG
op_logical_or
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
OL
id|size
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Start converting it to block form.&n;&t; */
id|INT_SET
c_func
(paren
id|block-&gt;hdr.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
id|needlog
op_assign
l_int|1
suffix:semicolon
id|needscan
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Use up the space at the end of the block (blp/btp).&n;&t; */
id|xfs_dir2_data_use_free
c_func
(paren
id|tp
comma
id|dbp
comma
id|dup
comma
id|mp-&gt;m_dirblksize
op_minus
id|size
comma
id|size
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the block tail.&n;&t; */
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_minus
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.stale
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|INT_ZERO
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|xfs_dir2_block_log_tail
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the block leaf area.  We compact out stale entries.&n;&t; */
id|lep
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|from
op_assign
id|to
op_assign
l_int|0
suffix:semicolon
id|from
OL
id|INT_GET
c_func
(paren
id|leaf-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|from
op_increment
)paren
(brace
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|leaf-&gt;ents
(braket
id|from
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
r_continue
suffix:semicolon
id|lep
(braket
id|to
op_increment
)braket
op_assign
id|leaf-&gt;ents
(braket
id|from
)braket
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|to
op_eq
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|xfs_dir2_block_log_leaf
c_func
(paren
id|tp
comma
id|dbp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan the bestfree if we need it and log the data block header.&n;&t; */
r_if
c_cond
(paren
id|needscan
)paren
id|xfs_dir2_data_freescan
c_func
(paren
id|mp
comma
(paren
id|xfs_dir2_data_t
op_star
)paren
id|block
comma
op_amp
id|needlog
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|needlog
)paren
id|xfs_dir2_data_log_header
c_func
(paren
id|tp
comma
id|dbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pitch the old leaf block.&n;&t; */
id|error
op_assign
id|xfs_da_shrink_inode
c_func
(paren
id|args
comma
id|mp-&gt;m_dirleafblk
comma
id|lbp
)paren
suffix:semicolon
id|lbp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now see if the resulting block can be shrunken to shortform.&n;&t; */
r_if
c_cond
(paren
(paren
id|size
op_assign
id|xfs_dir2_block_sfsize
c_func
(paren
id|dp
comma
id|block
comma
op_amp
id|sfh
)paren
)paren
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_return
id|xfs_dir2_block_to_sf
c_func
(paren
id|args
comma
id|dbp
comma
id|size
comma
op_amp
id|sfh
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|lbp
)paren
id|xfs_da_buf_done
c_func
(paren
id|lbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dbp
)paren
id|xfs_da_buf_done
c_func
(paren
id|dbp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert the shortform directory to block form.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_sf_to_block
id|xfs_dir2_sf_to_block
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_dir2_db_t
id|blkno
suffix:semicolon
multiline_comment|/* dir-relative block # (0) */
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* block leaf entries */
id|xfs_dabuf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* block buffer */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail pointer */
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* sf buffer */
r_int
id|buf_len
suffix:semicolon
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry pointer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|dummy
suffix:semicolon
multiline_comment|/* trash */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* unused entry pointer */
r_int
id|endoffset
suffix:semicolon
multiline_comment|/* end of data objects */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* index */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_int
id|needlog
suffix:semicolon
multiline_comment|/* need to log block header */
r_int
id|needscan
suffix:semicolon
multiline_comment|/* need to scan block freespc */
r_int
id|newoffset
suffix:semicolon
multiline_comment|/* offset from current entry */
r_int
id|offset
suffix:semicolon
multiline_comment|/* target block offset */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* sf entry pointer */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|xfs_dir2_data_off_t
op_star
id|tagp
suffix:semicolon
multiline_comment|/* end of data entry */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;sf_to_block&quot;
comma
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|tp
op_assign
id|args-&gt;trans
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bomb out if the shortform directory is way too short.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
m_offsetof
(paren
id|xfs_dir2_sf_hdr_t
comma
id|parent
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_d.di_size
op_ge
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|sfp-&gt;hdr.i8count
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the directory into the stack buffer.&n;&t; * Then pitch the incore inode data so we can make extents.&n;&t; */
id|buf_len
op_assign
id|dp-&gt;i_df.if_bytes
suffix:semicolon
id|buf
op_assign
id|kmem_alloc
c_func
(paren
id|dp-&gt;i_df.if_bytes
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|sfp
comma
id|dp-&gt;i_df.if_bytes
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|dp-&gt;i_df.if_bytes
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
l_int|0
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset pointer - old sfp is gone.&n;&t; */
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|buf
suffix:semicolon
multiline_comment|/*&n;&t; * Add block 0 to the inode.&n;&t; */
id|error
op_assign
id|xfs_dir2_grow_inode
c_func
(paren
id|args
comma
id|XFS_DIR2_DATA_SPACE
comma
op_amp
id|blkno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kmem_free
c_func
(paren
id|buf
comma
id|buf_len
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize the data block.&n;&t; */
id|error
op_assign
id|xfs_dir2_data_init
c_func
(paren
id|args
comma
id|blkno
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kmem_free
c_func
(paren
id|buf
comma
id|buf_len
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|block
op_assign
id|bp-&gt;data
suffix:semicolon
id|INT_SET
c_func
(paren
id|block-&gt;hdr.magic
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_BLOCK_MAGIC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute size of block &quot;tail&quot; area.&n;&t; */
id|i
op_assign
(paren
id|uint
)paren
r_sizeof
(paren
op_star
id|btp
)paren
op_plus
(paren
id|INT_GET
c_func
(paren
id|sfp-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|2
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_leaf_entry_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The whole thing is initialized to free by the init routine.&n;&t; * Say we&squot;re using the leaf and tail area.&n;&t; */
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|block-&gt;u
suffix:semicolon
id|needlog
op_assign
id|needscan
op_assign
l_int|0
suffix:semicolon
id|xfs_dir2_data_use_free
c_func
(paren
id|tp
comma
id|bp
comma
id|dup
comma
id|mp-&gt;m_dirblksize
op_minus
id|i
comma
id|i
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|needscan
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the tail.&n;&t; */
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
comma
id|INT_GET
c_func
(paren
id|sfp-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* ., .. */
id|INT_ZERO
c_func
(paren
id|btp-&gt;stale
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|endoffset
op_assign
(paren
id|uint
)paren
(paren
(paren
r_char
op_star
)paren
id|blp
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove the freespace, we&squot;ll manage it.&n;&t; */
id|xfs_dir2_data_use_free
c_func
(paren
id|tp
comma
id|bp
comma
id|dup
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
comma
op_amp
id|needlog
comma
op_amp
id|needscan
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create entry for .&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|XFS_DIR2_DATA_DOT_OFFSET
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|dp-&gt;i_ino
)paren
suffix:semicolon
id|dep-&gt;namelen
op_assign
l_int|1
suffix:semicolon
id|dep-&gt;name
(braket
l_int|0
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|tagp
op_assign
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|tp
comma
id|bp
comma
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|blp
(braket
l_int|0
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
comma
id|xfs_dir_hash_dot
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|blp
(braket
l_int|0
)braket
dot
id|address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_BYTE_TO_DATAPTR
c_func
(paren
id|mp
comma
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create entry for ..&n;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|XFS_DIR2_DATA_DOTDOT_OFFSET
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dep-&gt;namelen
op_assign
l_int|2
suffix:semicolon
id|dep-&gt;name
(braket
l_int|0
)braket
op_assign
id|dep-&gt;name
(braket
l_int|1
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|tagp
op_assign
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|tp
comma
id|bp
comma
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|blp
(braket
l_int|1
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
comma
id|xfs_dir_hash_dotdot
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|blp
(braket
l_int|1
)braket
dot
id|address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_BYTE_TO_DATAPTR
c_func
(paren
id|mp
comma
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
id|offset
op_assign
id|XFS_DIR2_DATA_FIRST_OFFSET
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over existing entries, stuff them in.&n;&t; */
r_if
c_cond
(paren
(paren
id|i
op_assign
l_int|0
)paren
op_eq
id|INT_GET
c_func
(paren
id|sfp-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|sfep
op_assign
l_int|NULL
suffix:semicolon
r_else
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to preserve the existing offset values in the sf directory.&n;&t; * Insert holes (unused entries) where necessary.&n;&t; */
r_while
c_loop
(paren
id|offset
OL
id|endoffset
)paren
(brace
multiline_comment|/*&n;&t;&t; * sfep is null when we reach the end of the list.&n;&t;&t; */
r_if
c_cond
(paren
id|sfep
op_eq
l_int|NULL
)paren
id|newoffset
op_assign
id|endoffset
suffix:semicolon
r_else
id|newoffset
op_assign
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There should be a hole here, make one.&n;&t;&t; */
r_if
c_cond
(paren
id|offset
OL
id|newoffset
)paren
(brace
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|offset
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_DATA_FREE_TAG
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
comma
id|newoffset
op_minus
id|offset
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|XFS_DIR2_DATA_UNUSED_TAG_P_ARCH
c_func
(paren
id|dup
comma
id|ARCH_CONVERT
)paren
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dup
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_unused
c_func
(paren
id|tp
comma
id|bp
comma
id|dup
)paren
suffix:semicolon
(paren
r_void
)paren
id|xfs_dir2_data_freeinsert
c_func
(paren
(paren
id|xfs_dir2_data_t
op_star
)paren
id|block
comma
id|dup
comma
op_amp
id|dummy
)paren
suffix:semicolon
id|offset
op_add_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Copy a real entry.&n;&t;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|newoffset
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|dep-&gt;namelen
op_assign
id|sfep-&gt;namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|dep-&gt;name
comma
id|sfep-&gt;name
comma
id|dep-&gt;namelen
)paren
suffix:semicolon
id|tagp
op_assign
id|XFS_DIR2_DATA_ENTRY_TAG_P
c_func
(paren
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|tagp
comma
id|ARCH_CONVERT
comma
(paren
id|xfs_dir2_data_off_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
id|xfs_dir2_data_log_entry
c_func
(paren
id|tp
comma
id|bp
comma
id|dep
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|blp
(braket
l_int|2
op_plus
id|i
)braket
dot
id|hashval
comma
id|ARCH_CONVERT
comma
id|xfs_da_hashname
c_func
(paren
(paren
r_char
op_star
)paren
id|sfep-&gt;name
comma
id|sfep-&gt;namelen
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|blp
(braket
l_int|2
op_plus
id|i
)braket
dot
id|address
comma
id|ARCH_CONVERT
comma
id|XFS_DIR2_BYTE_TO_DATAPTR
c_func
(paren
id|mp
comma
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
)paren
suffix:semicolon
id|offset
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
(paren
id|tagp
op_plus
l_int|1
)paren
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|INT_GET
c_func
(paren
id|sfp-&gt;hdr.count
comma
id|ARCH_CONVERT
)paren
)paren
id|sfep
op_assign
l_int|NULL
suffix:semicolon
r_else
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
suffix:semicolon
)brace
multiline_comment|/* Done with the temporary buffer */
id|kmem_free
c_func
(paren
id|buf
comma
id|buf_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Sort the leaf entries by hash value.&n;&t; */
id|qsort
c_func
(paren
id|blp
comma
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
comma
r_sizeof
(paren
op_star
id|blp
)paren
comma
id|xfs_dir2_block_sort
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log the leaf entry area and tail.&n;&t; * Already logged the header in data_init, ignore needlog.&n;&t; */
id|ASSERT
c_func
(paren
id|needscan
op_eq
l_int|0
)paren
suffix:semicolon
id|xfs_dir2_block_log_leaf
c_func
(paren
id|tp
comma
id|bp
comma
l_int|0
comma
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_dir2_block_log_tail
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
id|xfs_dir2_data_check
c_func
(paren
id|dp
comma
id|bp
)paren
suffix:semicolon
id|xfs_da_buf_done
c_func
(paren
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
