multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_rtalloc.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
multiline_comment|/*&n; * Log specified fields for the inode given by bp and off.&n; */
id|STATIC
r_void
DECL|function|xfs_ialloc_log_di
id|xfs_ialloc_log_di
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|bp
comma
multiline_comment|/* inode buffer */
r_int
id|off
comma
multiline_comment|/* index of inode in buffer */
r_int
id|fields
)paren
multiline_comment|/* bitmask of fields to log */
(brace
r_int
id|first
suffix:semicolon
multiline_comment|/* first byte number */
r_int
id|ioffset
suffix:semicolon
multiline_comment|/* off in bytes */
r_int
id|last
suffix:semicolon
multiline_comment|/* last byte number */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount point structure */
r_static
r_const
r_int
id|offsets
(braket
)braket
op_assign
(brace
multiline_comment|/* field offsets */
multiline_comment|/* keep in sync with bits */
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_magic
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_mode
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_version
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_format
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_onlink
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_uid
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_gid
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_nlink
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_projid
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_pad
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_atime
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_mtime
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_ctime
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_size
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_nblocks
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_extsize
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_nextents
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_anextents
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_forkoff
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_aformat
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_dmevmask
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_dmstate
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_flags
)paren
comma
m_offsetof
(paren
id|xfs_dinode_core_t
comma
id|di_gen
)paren
comma
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_next_unlinked
)paren
comma
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_u
)paren
comma
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_a
)paren
comma
r_sizeof
(paren
id|xfs_dinode_t
)paren
)brace
suffix:semicolon
id|ASSERT
c_func
(paren
m_offsetof
(paren
id|xfs_dinode_t
comma
id|di_core
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|fields
op_amp
(paren
id|XFS_DI_U
op_or
id|XFS_DI_A
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * Get the inode-relative first and last bytes for these fields&n;&t; */
id|xfs_btree_offsets
c_func
(paren
id|fields
comma
id|offsets
comma
id|XFS_DI_NUM_BITS
comma
op_amp
id|first
comma
op_amp
id|last
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert to buffer offsets and log it.&n;&t; */
id|ioffset
op_assign
id|off
op_lshift
id|mp-&gt;m_sb.sb_inodelog
suffix:semicolon
id|first
op_add_assign
id|ioffset
suffix:semicolon
id|last
op_add_assign
id|ioffset
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocation group level functions.&n; */
multiline_comment|/*&n; * Allocate new inodes in the allocation group specified by agbp.&n; * Return 0 for success, else error code.&n; */
id|STATIC
r_int
multiline_comment|/* error code or 0 */
DECL|function|xfs_ialloc_ag_alloc
id|xfs_ialloc_ag_alloc
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|agbp
comma
multiline_comment|/* alloc group buffer */
r_int
op_star
id|alloc
)paren
(brace
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
multiline_comment|/* allocation group header */
id|xfs_alloc_arg_t
id|args
suffix:semicolon
multiline_comment|/* allocation argument structure */
r_int
id|blks_per_cluster
suffix:semicolon
multiline_comment|/* fs blocks per inode cluster */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* inode btree cursor */
id|xfs_daddr_t
id|d
suffix:semicolon
multiline_comment|/* disk addr of buffer */
r_int
id|error
suffix:semicolon
id|xfs_buf_t
op_star
id|fbuf
suffix:semicolon
multiline_comment|/* new free inodes&squot; buffer */
id|xfs_dinode_t
op_star
id|free
suffix:semicolon
multiline_comment|/* new free inode structure */
r_int
id|i
suffix:semicolon
multiline_comment|/* inode counter */
r_int
id|j
suffix:semicolon
multiline_comment|/* block counter */
r_int
id|nbufs
suffix:semicolon
multiline_comment|/* num bufs of new inodes */
id|xfs_agino_t
id|newino
suffix:semicolon
multiline_comment|/* new first inode&squot;s number */
id|xfs_agino_t
id|newlen
suffix:semicolon
multiline_comment|/* new number of inodes */
r_int
id|ninodes
suffix:semicolon
multiline_comment|/* num inodes per buf */
id|xfs_agino_t
id|thisino
suffix:semicolon
multiline_comment|/* current inode number, for loop */
r_int
id|version
suffix:semicolon
multiline_comment|/* inode version number to use */
r_int
id|isaligned
suffix:semicolon
multiline_comment|/* inode allocation at stripe unit */
multiline_comment|/* boundary */
id|xfs_dinode_core_t
id|dic
suffix:semicolon
multiline_comment|/* a dinode_core to copy to new */
multiline_comment|/* inodes */
id|args.tp
op_assign
id|tp
suffix:semicolon
id|args.mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * Locking will ensure that we don&squot;t have two callers in here&n;&t; * at one time.&n;&t; */
id|newlen
op_assign
id|XFS_IALLOC_INODES
c_func
(paren
id|args.mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args.mp-&gt;m_maxicount
op_logical_and
id|args.mp-&gt;m_sb.sb_icount
op_plus
id|newlen
OG
id|args.mp-&gt;m_maxicount
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
id|args.minlen
op_assign
id|args.maxlen
op_assign
id|XFS_IALLOC_BLOCKS
c_func
(paren
id|args.mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set the alignment for the allocation.&n;&t; * If stripe alignment is turned on then align at stripe unit&n;&t; * boundary.&n;&t; * If the cluster size is smaller than a filesystem block&n;&t; * then we&squot;re doing I/O for inodes in filesystem block size pieces,&n;&t; * so don&squot;t need alignment anyway.&n;&t; */
id|isaligned
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|args.mp-&gt;m_sinoalign
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|args.mp-&gt;m_flags
op_amp
id|XFS_MOUNT_NOALIGN
)paren
)paren
suffix:semicolon
id|args.alignment
op_assign
id|args.mp-&gt;m_dalign
suffix:semicolon
id|isaligned
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASALIGN
c_func
(paren
op_amp
id|args.mp-&gt;m_sb
)paren
op_logical_and
id|args.mp-&gt;m_sb.sb_inoalignmt
op_ge
id|XFS_B_TO_FSBT
c_func
(paren
id|args.mp
comma
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|args.mp
)paren
)paren
)paren
id|args.alignment
op_assign
id|args.mp-&gt;m_sb.sb_inoalignmt
suffix:semicolon
r_else
id|args.alignment
op_assign
l_int|1
suffix:semicolon
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to figure out where to allocate the inode blocks.&n;&t; * Ideally they should be spaced out through the a.g.&n;&t; * For now, just allocate blocks up front.&n;&t; */
id|args.agbno
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_root
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args.fsbno
op_assign
id|XFS_AGB_TO_FSB
c_func
(paren
id|args.mp
comma
id|INT_GET
c_func
(paren
id|agi-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|args.agbno
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a fixed-size extent of inodes.&n;&t; */
id|args.type
op_assign
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
id|args.mod
op_assign
id|args.total
op_assign
id|args.wasdel
op_assign
id|args.isfl
op_assign
id|args.userdata
op_assign
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
id|args.prod
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Allow space for the inode btree to split.&n;&t; */
id|args.minleft
op_assign
id|XFS_IN_MAXLEVELS
c_func
(paren
id|args.mp
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * If stripe alignment is turned on, then try again with cluster&n;&t; * alignment.&n;&t; */
r_if
c_cond
(paren
id|isaligned
op_logical_and
id|args.fsbno
op_eq
id|NULLFSBLOCK
)paren
(brace
id|args.type
op_assign
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
id|args.agbno
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_root
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|args.fsbno
op_assign
id|XFS_AGB_TO_FSB
c_func
(paren
id|args.mp
comma
id|INT_GET
c_func
(paren
id|agi-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|args.agbno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASALIGN
c_func
(paren
op_amp
id|args.mp-&gt;m_sb
)paren
op_logical_and
id|args.mp-&gt;m_sb.sb_inoalignmt
op_ge
id|XFS_B_TO_FSBT
c_func
(paren
id|args.mp
comma
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|args.mp
)paren
)paren
)paren
id|args.alignment
op_assign
id|args.mp-&gt;m_sb.sb_inoalignmt
suffix:semicolon
r_else
id|args.alignment
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_vextent
c_func
(paren
op_amp
id|args
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args.fsbno
op_eq
id|NULLFSBLOCK
)paren
(brace
op_star
id|alloc
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|args.len
op_eq
id|args.minlen
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert the results.&n;&t; */
id|newino
op_assign
id|XFS_OFFBNO_TO_AGINO
c_func
(paren
id|args.mp
comma
id|args.agbno
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the new block(s), filling in the inodes.&n;&t; * For small block sizes, manipulate the inodes in buffers&n;&t; * which are multiples of the blocks size.&n;&t; */
r_if
c_cond
(paren
id|args.mp-&gt;m_sb.sb_blocksize
op_ge
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|args.mp
)paren
)paren
(brace
id|blks_per_cluster
op_assign
l_int|1
suffix:semicolon
id|nbufs
op_assign
(paren
r_int
)paren
id|args.len
suffix:semicolon
id|ninodes
op_assign
id|args.mp-&gt;m_sb.sb_inopblock
suffix:semicolon
)brace
r_else
(brace
id|blks_per_cluster
op_assign
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|args.mp
)paren
op_div
id|args.mp-&gt;m_sb.sb_blocksize
suffix:semicolon
id|nbufs
op_assign
(paren
r_int
)paren
id|args.len
op_div
id|blks_per_cluster
suffix:semicolon
id|ninodes
op_assign
id|blks_per_cluster
op_star
id|args.mp-&gt;m_sb.sb_inopblock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Figure out what version number to use in the inodes we create.&n;&t; * If the superblock version has caught up to the one that supports&n;&t; * the new inode format, then use the new inode version.  Otherwise&n;&t; * use the old version so that old kernels will continue to be&n;&t; * able to use the file system.&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASNLINK
c_func
(paren
op_amp
id|args.mp-&gt;m_sb
)paren
)paren
id|version
op_assign
id|XFS_DINODE_VERSION_2
suffix:semicolon
r_else
id|version
op_assign
id|XFS_DINODE_VERSION_1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dic
comma
l_int|0
comma
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dic.di_magic
comma
id|ARCH_CONVERT
comma
id|XFS_DINODE_MAGIC
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|dic.di_version
comma
id|ARCH_CONVERT
comma
id|version
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nbufs
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get the block.&n;&t;&t; */
id|d
op_assign
id|XFS_AGB_TO_DADDR
c_func
(paren
id|args.mp
comma
id|INT_GET
c_func
(paren
id|agi-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|args.agbno
op_plus
(paren
id|j
op_star
id|blks_per_cluster
)paren
)paren
suffix:semicolon
id|fbuf
op_assign
id|xfs_trans_get_buf
c_func
(paren
id|tp
comma
id|args.mp-&gt;m_ddev_targp
comma
id|d
comma
id|args.mp-&gt;m_bsize
op_star
id|blks_per_cluster
comma
id|XFS_BUF_LOCK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|fbuf
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|fbuf
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Loop over the inodes in this buffer.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ninodes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|free
op_assign
id|XFS_MAKE_IPTR
c_func
(paren
id|args.mp
comma
id|fbuf
comma
id|i
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|free-&gt;di_core
)paren
comma
op_amp
id|dic
comma
r_sizeof
(paren
id|xfs_dinode_core_t
)paren
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|free-&gt;di_next_unlinked
comma
id|ARCH_CONVERT
comma
id|NULLAGINO
)paren
suffix:semicolon
id|xfs_ialloc_log_di
c_func
(paren
id|tp
comma
id|fbuf
comma
id|i
comma
id|XFS_DI_CORE_BITS
op_or
id|XFS_DI_NEXT_UNLINKED
)paren
suffix:semicolon
)brace
id|xfs_trans_inode_alloc_buf
c_func
(paren
id|tp
comma
id|fbuf
)paren
suffix:semicolon
)brace
id|INT_MOD
c_func
(paren
id|agi-&gt;agi_count
comma
id|ARCH_CONVERT
comma
id|newlen
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
comma
id|newlen
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|args.mp-&gt;m_peraglock
)paren
suffix:semicolon
id|args.mp-&gt;m_perag
(braket
id|INT_GET
c_func
(paren
id|agi-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
)braket
dot
id|pagi_freecount
op_add_assign
id|newlen
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|args.mp-&gt;m_peraglock
)paren
suffix:semicolon
id|INT_SET
c_func
(paren
id|agi-&gt;agi_newino
comma
id|ARCH_CONVERT
comma
id|newino
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Insert records describing the new inode chunk into the btree.&n;&t; */
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args.mp
comma
id|tp
comma
id|agbp
comma
id|INT_GET
c_func
(paren
id|agi-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|XFS_BTNUM_INO
comma
(paren
id|xfs_inode_t
op_star
)paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|thisino
op_assign
id|newino
suffix:semicolon
id|thisino
OL
id|newino
op_plus
id|newlen
suffix:semicolon
id|thisino
op_add_assign
id|XFS_INODES_PER_CHUNK
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_eq
c_func
(paren
id|cur
comma
id|thisino
comma
id|XFS_INODES_PER_CHUNK
comma
id|XFS_INOBT_ALL_FREE
comma
op_amp
id|i
)paren
)paren
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_insert
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log allocation group header fields&n;&t; */
id|xfs_ialloc_log_agi
c_func
(paren
id|tp
comma
id|agbp
comma
id|XFS_AGI_COUNT
op_or
id|XFS_AGI_FREECOUNT
op_or
id|XFS_AGI_NEWINO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Modify/log superblock values for inode count and inode free count.&n;&t; */
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_ICOUNT
comma
(paren
r_int
)paren
id|newlen
)paren
suffix:semicolon
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_IFREE
comma
(paren
r_int
)paren
id|newlen
)paren
suffix:semicolon
op_star
id|alloc
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
id|__inline
id|xfs_agnumber_t
DECL|function|xfs_ialloc_next_ag
id|xfs_ialloc_next_ag
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_agnumber_t
id|agno
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mp-&gt;m_agirotor_lock
)paren
suffix:semicolon
id|agno
op_assign
id|mp-&gt;m_agirotor
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|mp-&gt;m_agirotor
op_eq
id|mp-&gt;m_maxagi
)paren
id|mp-&gt;m_agirotor
op_assign
l_int|0
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mp-&gt;m_agirotor_lock
)paren
suffix:semicolon
r_return
id|agno
suffix:semicolon
)brace
multiline_comment|/*&n; * Select an allocation group to look for a free inode in, based on the parent&n; * inode and then mode.  Return the allocation group buffer.&n; */
id|STATIC
id|xfs_buf_t
op_star
multiline_comment|/* allocation group buffer */
DECL|function|xfs_ialloc_ag_select
id|xfs_ialloc_ag_select
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_ino_t
id|parent
comma
multiline_comment|/* parent directory inode number */
id|mode_t
id|mode
comma
multiline_comment|/* bits set to indicate file type */
r_int
id|okalloc
)paren
multiline_comment|/* ok to allocate more space */
(brace
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* allocation group header buffer */
id|xfs_agnumber_t
id|agcount
suffix:semicolon
multiline_comment|/* number of ag&squot;s in the filesystem */
id|xfs_agnumber_t
id|agno
suffix:semicolon
multiline_comment|/* current ag number */
r_int
id|flags
suffix:semicolon
multiline_comment|/* alloc buffer locking flags */
id|xfs_extlen_t
id|ineed
suffix:semicolon
multiline_comment|/* blocks needed for inode allocation */
id|xfs_extlen_t
id|longest
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* longest extent available */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount point structure */
r_int
id|needspace
suffix:semicolon
multiline_comment|/* file mode implies space allocated */
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
multiline_comment|/* per allocation group data */
id|xfs_agnumber_t
id|pagno
suffix:semicolon
multiline_comment|/* parent (starting) ag number */
multiline_comment|/*&n;&t; * Files of these types need at least one block if length &gt; 0&n;&t; * (and they won&squot;t fit in the inode, but that&squot;s hard to figure out).&n;&t; */
id|needspace
op_assign
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|agcount
op_assign
id|mp-&gt;m_maxagi
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
id|pagno
op_assign
id|xfs_ialloc_next_ag
c_func
(paren
id|mp
)paren
suffix:semicolon
r_else
(brace
id|pagno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pagno
op_ge
id|agcount
)paren
id|pagno
op_assign
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|pagno
OL
id|agcount
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop through allocation groups, looking for one with a little&n;&t; * free space in it.  Note we don&squot;t look for free inodes, exactly.&n;&t; * Instead, we include whether there is a need to allocate inodes&n;&t; * to mean that blocks must be allocated for them,&n;&t; * if none are currently free.&n;&t; */
id|agno
op_assign
id|pagno
suffix:semicolon
id|flags
op_assign
id|XFS_ALLOC_FLAG_TRYLOCK
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pag-&gt;pagi_init
)paren
(brace
r_if
c_cond
(paren
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
id|tp
comma
id|agno
comma
op_amp
id|agbp
)paren
)paren
(brace
id|agbp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|nextag
suffix:semicolon
)brace
)brace
r_else
id|agbp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pag-&gt;pagi_inodeok
)paren
(brace
id|xfs_ialloc_next_ag
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|unlock_nextag
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Is there enough free space for the file plus a block&n;&t;&t; * of inodes (if we need to allocate some)?&n;&t;&t; */
id|ineed
op_assign
id|pag-&gt;pagi_freecount
ques
c_cond
l_int|0
suffix:colon
id|XFS_IALLOC_BLOCKS
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ineed
op_logical_and
op_logical_neg
id|pag-&gt;pagf_init
)paren
(brace
r_if
c_cond
(paren
id|agbp
op_eq
l_int|NULL
op_logical_and
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
id|tp
comma
id|agno
comma
op_amp
id|agbp
)paren
)paren
(brace
id|agbp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|nextag
suffix:semicolon
)brace
(paren
r_void
)paren
id|xfs_alloc_pagf_init
c_func
(paren
id|mp
comma
id|tp
comma
id|agno
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ineed
op_logical_or
id|pag-&gt;pagf_init
)paren
(brace
r_if
c_cond
(paren
id|ineed
op_logical_and
op_logical_neg
(paren
id|longest
op_assign
id|pag-&gt;pagf_longest
)paren
)paren
id|longest
op_assign
id|pag-&gt;pagf_flcount
OG
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ineed
op_logical_or
(paren
id|pag-&gt;pagf_freeblks
op_ge
id|needspace
op_plus
id|ineed
op_logical_and
id|longest
op_ge
id|ineed
op_logical_and
id|okalloc
)paren
)paren
(brace
r_if
c_cond
(paren
id|agbp
op_eq
l_int|NULL
op_logical_and
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
id|tp
comma
id|agno
comma
op_amp
id|agbp
)paren
)paren
(brace
id|agbp
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|nextag
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_return
id|agbp
suffix:semicolon
)brace
)brace
id|unlock_nextag
suffix:colon
r_if
c_cond
(paren
id|agbp
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agbp
)paren
suffix:semicolon
id|nextag
suffix:colon
multiline_comment|/*&n;&t;&t; * No point in iterating over the rest, if we&squot;re shutting&n;&t;&t; * down.&n;&t;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_return
(paren
id|xfs_buf_t
op_star
)paren
l_int|0
suffix:semicolon
)brace
id|agno
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|agno
op_ge
id|agcount
)paren
id|agno
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|agno
op_eq
id|pagno
)paren
(brace
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_return
(paren
id|xfs_buf_t
op_star
)paren
l_int|0
suffix:semicolon
)brace
id|flags
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Visible inode allocation functions.&n; */
multiline_comment|/*&n; * Allocate an inode on disk.&n; * Mode is used to tell whether the new inode will need space, and whether&n; * it is a directory.&n; *&n; * The arguments IO_agbp and alloc_done are defined to work within&n; * the constraint of one allocation per transaction.&n; * xfs_dialloc() is designed to be called twice if it has to do an&n; * allocation to make more free inodes.  On the first call,&n; * IO_agbp should be set to NULL. If an inode is available,&n; * i.e., xfs_dialloc() did not need to do an allocation, an inode&n; * number is returned.  In this case, IO_agbp would be set to the&n; * current ag_buf and alloc_done set to false.&n; * If an allocation needed to be done, xfs_dialloc would return&n; * the current ag_buf in IO_agbp and set alloc_done to true.&n; * The caller should then commit the current transaction, allocate a new&n; * transaction, and call xfs_dialloc() again, passing in the previous&n; * value of IO_agbp.  IO_agbp should be held across the transactions.&n; * Since the agbp is locked across the two calls, the second call is&n; * guaranteed to have a free inode available.&n; *&n; * Once we successfully pick an inode its number is returned and the&n; * on-disk data structures are updated.  The inode itself is not read&n; * in, since doing so would break ordering constraints with xfs_reclaim.&n; */
r_int
DECL|function|xfs_dialloc
id|xfs_dialloc
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_ino_t
id|parent
comma
multiline_comment|/* parent inode (directory) */
id|mode_t
id|mode
comma
multiline_comment|/* mode bits for new inode */
r_int
id|okalloc
comma
multiline_comment|/* ok to allocate more space */
id|xfs_buf_t
op_star
op_star
id|IO_agbp
comma
multiline_comment|/* in/out ag header&squot;s buffer */
id|boolean_t
op_star
id|alloc_done
comma
multiline_comment|/* true if we needed to replenish&n;&t;&t;&t;&t;&t;   inode freelist */
id|xfs_ino_t
op_star
id|inop
)paren
multiline_comment|/* inode number allocated */
(brace
id|xfs_agnumber_t
id|agcount
suffix:semicolon
multiline_comment|/* number of allocation groups */
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* allocation group header&squot;s buffer */
id|xfs_agnumber_t
id|agno
suffix:semicolon
multiline_comment|/* allocation group number */
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
multiline_comment|/* allocation group header structure */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* inode allocation btree cursor */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* result code */
r_int
id|ialloced
suffix:semicolon
multiline_comment|/* inode allocation status */
r_int
id|noroom
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no space for inode blk allocation */
id|xfs_ino_t
id|ino
suffix:semicolon
multiline_comment|/* fs-relative inode to be returned */
multiline_comment|/* REFERENCED */
r_int
id|j
suffix:semicolon
multiline_comment|/* result code */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount structure */
r_int
id|offset
suffix:semicolon
multiline_comment|/* index of inode in chunk */
id|xfs_agino_t
id|pagino
suffix:semicolon
multiline_comment|/* parent&squot;s a.g. relative inode # */
id|xfs_agnumber_t
id|pagno
suffix:semicolon
multiline_comment|/* parent&squot;s allocation group number */
id|xfs_inobt_rec_t
id|rec
suffix:semicolon
multiline_comment|/* inode allocation record */
id|xfs_agnumber_t
id|tagno
suffix:semicolon
multiline_comment|/* testing allocation group number */
id|xfs_btree_cur_t
op_star
id|tcur
suffix:semicolon
multiline_comment|/* temp cursor */
id|xfs_inobt_rec_t
id|trec
suffix:semicolon
multiline_comment|/* temp inode allocation record */
r_if
c_cond
(paren
op_star
id|IO_agbp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We do not have an agbp, so select an initial allocation&n;&t;&t; * group for inode allocation.&n;&t;&t; */
id|agbp
op_assign
id|xfs_ialloc_ag_select
c_func
(paren
id|tp
comma
id|parent
comma
id|mode
comma
id|okalloc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Couldn&squot;t find an allocation group satisfying the&n;&t;&t; * criteria, give up.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|agbp
)paren
(brace
op_star
id|inop
op_assign
id|NULLFSINO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Continue where we left off before.  In this case, we&n;&t;&t; * know that the allocation group has free inodes.&n;&t;&t; */
id|agbp
op_assign
op_star
id|IO_agbp
suffix:semicolon
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
)brace
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|agcount
op_assign
id|mp-&gt;m_sb.sb_agcount
suffix:semicolon
id|agno
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|tagno
op_assign
id|agno
suffix:semicolon
id|pagno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|parent
)paren
suffix:semicolon
id|pagino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|parent
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we have already hit the ceiling of inode blocks then clear&n;&t; * okalloc so we scan all available agi structures for a free&n;&t; * inode.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_maxicount
op_logical_and
id|mp-&gt;m_sb.sb_icount
op_plus
id|XFS_IALLOC_INODES
c_func
(paren
id|mp
)paren
OG
id|mp-&gt;m_maxicount
)paren
(brace
id|noroom
op_assign
l_int|1
suffix:semicolon
id|okalloc
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop until we find an allocation group that either has free inodes&n;&t; * or in which we can allocate some inodes.  Iterate through the&n;&t; * allocation groups upward, wrapping at the end.&n;&t; */
op_star
id|alloc_done
op_assign
id|B_FALSE
suffix:semicolon
r_while
c_loop
(paren
id|INT_ISZERO
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t do anything if we&squot;re not supposed to allocate&n;&t;&t; * any blocks, just go on to the next ag.&n;&t;&t; */
r_if
c_cond
(paren
id|okalloc
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Try to allocate some new inodes in the allocation&n;&t;&t;&t; * group.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_ialloc_ag_alloc
c_func
(paren
id|tp
comma
id|agbp
comma
op_amp
id|ialloced
)paren
)paren
)paren
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|ENOSPC
)paren
(brace
op_star
id|inop
op_assign
id|NULLFSINO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ialloced
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We successfully allocated some inodes, return&n;&t;&t;&t;&t; * the current context to the caller so that it&n;&t;&t;&t;&t; * can commit the current transaction and call&n;&t;&t;&t;&t; * us again where we left off.&n;&t;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
)paren
suffix:semicolon
op_star
id|alloc_done
op_assign
id|B_TRUE
suffix:semicolon
op_star
id|IO_agbp
op_assign
id|agbp
suffix:semicolon
op_star
id|inop
op_assign
id|NULLFSINO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * If it failed, give up on this ag.&n;&t;&t; */
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Go on to the next ag: get its ag header.&n;&t;&t; */
id|nextag
suffix:colon
r_if
c_cond
(paren
op_increment
id|tagno
op_eq
id|agcount
)paren
id|tagno
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tagno
op_eq
id|agno
)paren
(brace
op_star
id|inop
op_assign
id|NULLFSINO
suffix:semicolon
r_return
id|noroom
ques
c_cond
id|ENOSPC
suffix:colon
l_int|0
suffix:semicolon
)brace
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_perag
(braket
id|tagno
)braket
dot
id|pagi_inodeok
op_eq
l_int|0
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_goto
id|nextag
suffix:semicolon
)brace
id|error
op_assign
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
id|tp
comma
id|tagno
comma
op_amp
id|agbp
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|nextag
suffix:semicolon
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Here with an allocation group that has a free inode.&n;&t; * Reset agno since we may have chosen a new ag in the&n;&t; * loop above.&n;&t; */
id|agno
op_assign
id|tagno
suffix:semicolon
op_star
id|IO_agbp
op_assign
l_int|NULL
suffix:semicolon
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
id|agbp
comma
id|INT_GET
c_func
(paren
id|agi-&gt;agi_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|XFS_BTNUM_INO
comma
(paren
id|xfs_inode_t
op_star
)paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If pagino is 0 (this is the root inode allocation) use newino.&n;&t; * This must work because we&squot;ve just allocated some.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pagino
)paren
id|pagino
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_newino
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|cur-&gt;bc_nlevels
op_eq
l_int|1
)paren
(brace
r_int
id|freecount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|freecount
op_add_assign
id|rec.ir_freecount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|freecount
op_eq
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * If in the same a.g. as the parent, try to get near the parent.&n;&t; */
r_if
c_cond
(paren
id|pagno
op_eq
id|agno
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_le
c_func
(paren
id|cur
comma
id|pagino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|0
op_logical_and
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|j
comma
id|ARCH_NOCONVERT
)paren
)paren
op_eq
l_int|0
op_logical_and
id|j
op_eq
l_int|1
op_logical_and
id|rec.ir_freecount
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Found a free inode in the same chunk&n;&t;&t;&t; * as parent, done.&n;&t;&t;&t; */
)brace
multiline_comment|/*&n;&t;&t; * In the same a.g. as parent, but parent&squot;s chunk is full.&n;&t;&t; */
r_else
(brace
r_int
id|doneleft
suffix:semicolon
multiline_comment|/* done, to the left */
r_int
id|doneright
suffix:semicolon
multiline_comment|/* done, to the right */
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|j
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Duplicate the cursor, search left &amp; right&n;&t;&t;&t; * simultaneously.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_dup_cursor
c_func
(paren
id|cur
comma
op_amp
id|tcur
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Search left with tcur, back up 1 record.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_decrement
c_func
(paren
id|tcur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|doneleft
op_assign
op_logical_neg
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|doneleft
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|tcur
comma
op_amp
id|trec.ir_startino
comma
op_amp
id|trec.ir_freecount
comma
op_amp
id|trec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Search right with cur, go forward 1 record.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|doneright
op_assign
op_logical_neg
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|doneright
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Loop until we find the closest inode chunk&n;&t;&t;&t; * with a free one.&n;&t;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
id|doneleft
op_logical_or
op_logical_neg
id|doneright
)paren
(brace
r_int
id|useleft
suffix:semicolon
multiline_comment|/* using left inode&n;&t;&t;&t;&t;&t;&t;     chunk this time */
multiline_comment|/*&n;&t;&t;&t;&t; * Figure out which block is closer,&n;&t;&t;&t;&t; * if both are valid.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|doneleft
op_logical_and
op_logical_neg
id|doneright
)paren
id|useleft
op_assign
id|pagino
op_minus
(paren
id|trec.ir_startino
op_plus
id|XFS_INODES_PER_CHUNK
op_minus
l_int|1
)paren
OL
id|rec.ir_startino
op_minus
id|pagino
suffix:semicolon
r_else
id|useleft
op_assign
op_logical_neg
id|doneleft
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If checking the left, does it have&n;&t;&t;&t;&t; * free inodes?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|useleft
op_logical_and
id|trec.ir_freecount
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Yes, set it up as the chunk to use.&n;&t;&t;&t;&t;&t; */
id|rec
op_assign
id|trec
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|cur
op_assign
id|tcur
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If checking the right, does it have&n;&t;&t;&t;&t; * free inodes?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|useleft
op_logical_and
id|rec.ir_freecount
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Yes, it&squot;s already set up.&n;&t;&t;&t;&t;&t; */
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If used the left, get another one&n;&t;&t;&t;&t; * further left.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|useleft
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_decrement
c_func
(paren
id|tcur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|doneleft
op_assign
op_logical_neg
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|doneleft
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|tcur
comma
op_amp
id|trec.ir_startino
comma
op_amp
id|trec.ir_freecount
comma
op_amp
id|trec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If used the right, get another one&n;&t;&t;&t;&t; * further right.&n;&t;&t;&t;&t; */
r_else
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|doneright
op_assign
op_logical_neg
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|doneright
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error1
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error1
)paren
suffix:semicolon
)brace
)brace
)brace
id|ASSERT
c_func
(paren
op_logical_neg
id|doneleft
op_logical_or
op_logical_neg
id|doneright
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * In a different a.g. from the parent.&n;&t; * See if the most recently allocated block has any free.&n;&t; */
r_else
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_newino
comma
id|ARCH_CONVERT
)paren
op_ne
id|NULLAGINO
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_eq
c_func
(paren
id|cur
comma
id|INT_GET
c_func
(paren
id|agi-&gt;agi_newino
comma
id|ARCH_CONVERT
)paren
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|1
op_logical_and
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|j
comma
id|ARCH_NOCONVERT
)paren
)paren
op_eq
l_int|0
op_logical_and
id|j
op_eq
l_int|1
op_logical_and
id|rec.ir_freecount
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The last chunk allocated in the group still has&n;&t;&t;&t; * a free inode.&n;&t;&t;&t; */
)brace
multiline_comment|/*&n;&t;&t; * None left in the last group, search the whole a.g.&n;&t;&t; */
r_else
(brace
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rec.ir_freecount
OG
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
)brace
)brace
)brace
id|offset
op_assign
id|XFS_IALLOC_FIND_FREE
c_func
(paren
op_amp
id|rec.ir_free
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
op_ge
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
OL
id|XFS_INODES_PER_CHUNK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|XFS_AGINO_TO_OFFSET
c_func
(paren
id|mp
comma
id|rec.ir_startino
)paren
op_mod
id|XFS_INODES_PER_CHUNK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|rec.ir_startino
op_plus
id|offset
)paren
suffix:semicolon
id|XFS_INOBT_CLR_FREE
c_func
(paren
op_amp
id|rec
comma
id|offset
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
id|rec.ir_freecount
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_update
c_func
(paren
id|cur
comma
id|rec.ir_startino
comma
id|rec.ir_freecount
comma
id|rec.ir_free
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_ialloc_log_agi
c_func
(paren
id|tp
comma
id|agbp
comma
id|XFS_AGI_FREECOUNT
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|tagno
)braket
dot
id|pagi_freecount
op_decrement
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|cur-&gt;bc_nlevels
op_eq
l_int|1
)paren
(brace
r_int
id|freecount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|freecount
op_add_assign
id|rec.ir_freecount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|freecount
op_eq
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_IFREE
comma
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|inop
op_assign
id|ino
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error1
suffix:colon
id|xfs_btree_del_cursor
c_func
(paren
id|tcur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
id|error0
suffix:colon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Free disk inode.  Carefully avoids touching the incore inode, all&n; * manipulations incore are the caller&squot;s responsibility.&n; * The on-disk inode is not changed by this operation, only the&n; * btree (free inode mask) is changed.&n; */
r_int
DECL|function|xfs_difree
id|xfs_difree
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_ino_t
id|inode
comma
multiline_comment|/* inode to be freed */
id|xfs_bmap_free_t
op_star
id|flist
comma
multiline_comment|/* extents to free */
r_int
op_star
r_delete
comma
multiline_comment|/* set if inode cluster was deleted */
id|xfs_ino_t
op_star
id|first_ino
)paren
multiline_comment|/* first inode in deleted cluster */
(brace
multiline_comment|/* REFERENCED */
id|xfs_agblock_t
id|agbno
suffix:semicolon
multiline_comment|/* block number containing inode */
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* buffer containing allocation group header */
id|xfs_agino_t
id|agino
suffix:semicolon
multiline_comment|/* inode number relative to allocation group */
id|xfs_agnumber_t
id|agno
suffix:semicolon
multiline_comment|/* allocation group number */
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
multiline_comment|/* allocation group header */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* inode btree cursor */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* result code */
r_int
id|ilen
suffix:semicolon
multiline_comment|/* inodes in an inode cluster */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure for filesystem */
r_int
id|off
suffix:semicolon
multiline_comment|/* offset of inode in inode chunk */
id|xfs_inobt_rec_t
id|rec
suffix:semicolon
multiline_comment|/* btree record */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * Break up inode number into its components.&n;&t; */
id|agno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agno
op_ge
id|mp-&gt;m_sb.sb_agcount
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: agno &gt;= mp-&gt;m_sb.sb_agcount (%d &gt;= %d) on %s.  Returning EINVAL.&quot;
comma
id|agno
comma
id|mp-&gt;m_sb.sb_agcount
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|agino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_ne
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: inode != XFS_AGINO_TO_INO() (%d != %d) on %s.  Returning EINVAL.&quot;
comma
id|inode
comma
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|agbno
op_assign
id|XFS_AGINO_TO_AGBNO
c_func
(paren
id|mp
comma
id|agino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agbno
op_ge
id|mp-&gt;m_sb.sb_agblocks
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: agbno &gt;= mp-&gt;m_sb.sb_agblocks (%d &gt;= %d) on %s.  Returning EINVAL.&quot;
comma
id|agbno
comma
id|mp-&gt;m_sb.sb_agblocks
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the allocation group header.&n;&t; */
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
id|tp
comma
id|agno
comma
op_amp
id|agbp
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: xfs_ialloc_read_agi() returned an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|agbno
OL
id|INT_GET
c_func
(paren
id|agi-&gt;agi_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the cursor.&n;&t; */
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
id|agbp
comma
id|agno
comma
id|XFS_BTNUM_INO
comma
(paren
id|xfs_inode_t
op_star
)paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|cur-&gt;bc_nlevels
op_eq
l_int|1
)paren
(brace
r_int
id|freecount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|freecount
op_add_assign
id|rec.ir_freecount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|freecount
op_eq
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Look for the entry describing this inode.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_le
c_func
(paren
id|cur
comma
id|agino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: xfs_inobt_lookup_le returned()  an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: xfs_inobt_get_rec()  returned an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the offset in the inode chunk.&n;&t; */
id|off
op_assign
id|agino
op_minus
id|rec.ir_startino
suffix:semicolon
id|ASSERT
c_func
(paren
id|off
op_ge
l_int|0
op_logical_and
id|off
OL
id|XFS_INODES_PER_CHUNK
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_INOBT_IS_FREE
c_func
(paren
op_amp
id|rec
comma
id|off
comma
id|ARCH_NOCONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the inode free &amp; increment the count.&n;&t; */
id|XFS_INOBT_SET_FREE
c_func
(paren
op_amp
id|rec
comma
id|off
comma
id|ARCH_NOCONVERT
)paren
suffix:semicolon
id|rec.ir_freecount
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * When an inode cluster is free, it becomes elgible for removal&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_IDELETE
)paren
op_logical_and
(paren
id|rec.ir_freecount
op_eq
id|XFS_IALLOC_INODES
c_func
(paren
id|mp
)paren
)paren
)paren
(brace
op_star
r_delete
op_assign
l_int|1
suffix:semicolon
op_star
id|first_ino
op_assign
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|rec.ir_startino
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Remove the inode cluster from the AGI B+Tree, adjust the&n;&t;&t; * AGI and Superblock inode counts, and mark the disk space&n;&t;&t; * to be freed when the transaction is committed.&n;&t;&t; */
id|ilen
op_assign
id|XFS_IALLOC_INODES
c_func
(paren
id|mp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agi-&gt;agi_count
comma
id|ARCH_CONVERT
comma
op_minus
id|ilen
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|ilen
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|xfs_ialloc_log_agi
c_func
(paren
id|tp
comma
id|agbp
comma
id|XFS_AGI_COUNT
op_or
id|XFS_AGI_FREECOUNT
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagi_freecount
op_sub_assign
id|ilen
op_minus
l_int|1
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_ICOUNT
comma
op_minus
id|ilen
)paren
suffix:semicolon
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_IFREE
comma
op_minus
(paren
id|ilen
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_delete
c_func
(paren
id|cur
comma
op_amp
id|i
)paren
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: xfs_inobt_delete returned an error %d on %s.&bslash;n&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|xfs_bmap_add_free
c_func
(paren
id|XFS_AGB_TO_FSB
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_INO_TO_AGBNO
c_func
(paren
id|mp
comma
id|rec.ir_startino
)paren
)paren
comma
id|XFS_IALLOC_BLOCKS
c_func
(paren
id|mp
)paren
comma
id|flist
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
r_delete
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_update
c_func
(paren
id|cur
comma
id|rec.ir_startino
comma
id|rec.ir_freecount
comma
id|rec.ir_free
)paren
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;xfs_difree: xfs_inobt_update()  returned an error %d on %s.  Returning error.&quot;
comma
id|error
comma
id|mp-&gt;m_fsname
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * Change the inode free counts and log the ag/sb changes.&n;&t;&t; */
id|INT_MOD
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|xfs_ialloc_log_agi
c_func
(paren
id|tp
comma
id|agbp
comma
id|XFS_AGI_FREECOUNT
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagi_freecount
op_increment
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_IFREE
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|cur-&gt;bc_nlevels
op_eq
l_int|1
)paren
(brace
r_int
id|freecount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_ge
c_func
(paren
id|cur
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|rec.ir_startino
comma
op_amp
id|rec.ir_freecount
comma
op_amp
id|rec.ir_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|freecount
op_add_assign
id|rec.ir_freecount
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_increment
c_func
(paren
id|cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|freecount
op_eq
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the location of the inode in bno/off, for mapping it into a buffer.&n; */
multiline_comment|/*ARGSUSED*/
r_int
DECL|function|xfs_dilocate
id|xfs_dilocate
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_ino_t
id|ino
comma
multiline_comment|/* inode to locate */
id|xfs_fsblock_t
op_star
id|bno
comma
multiline_comment|/* output: block containing inode */
r_int
op_star
id|len
comma
multiline_comment|/* output: num blocks in inode cluster */
r_int
op_star
id|off
comma
multiline_comment|/* output: index in block of inode */
id|uint
id|flags
)paren
multiline_comment|/* flags concerning inode lookup */
(brace
id|xfs_agblock_t
id|agbno
suffix:semicolon
multiline_comment|/* block number of inode in the alloc group */
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* agi buffer */
id|xfs_agino_t
id|agino
suffix:semicolon
multiline_comment|/* inode number within alloc group */
id|xfs_agnumber_t
id|agno
suffix:semicolon
multiline_comment|/* allocation group number */
r_int
id|blks_per_cluster
suffix:semicolon
multiline_comment|/* num blocks per inode cluster */
id|xfs_agblock_t
id|chunk_agbno
suffix:semicolon
multiline_comment|/* first block in inode chunk */
id|xfs_agino_t
id|chunk_agino
suffix:semicolon
multiline_comment|/* first agino in inode chunk */
id|__int32_t
id|chunk_cnt
suffix:semicolon
multiline_comment|/* count of free inodes in chunk */
id|xfs_inofree_t
id|chunk_free
suffix:semicolon
multiline_comment|/* mask of free inodes in chunk */
id|xfs_agblock_t
id|cluster_agbno
suffix:semicolon
multiline_comment|/* first block in inode cluster */
id|xfs_btree_cur_t
op_star
id|cur
suffix:semicolon
multiline_comment|/* inode btree cursor */
r_int
id|error
suffix:semicolon
multiline_comment|/* error code */
r_int
id|i
suffix:semicolon
multiline_comment|/* temp state */
r_int
id|offset
suffix:semicolon
multiline_comment|/* index of inode in its buffer */
r_int
id|offset_agbno
suffix:semicolon
multiline_comment|/* blks from chunk start to inode */
id|ASSERT
c_func
(paren
id|ino
op_ne
id|NULLFSINO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Split up the inode number into its parts.&n;&t; */
id|agno
op_assign
id|XFS_INO_TO_AGNO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|agino
op_assign
id|XFS_INO_TO_AGINO
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|agbno
op_assign
id|XFS_AGINO_TO_AGBNO
c_func
(paren
id|mp
comma
id|agino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|agno
op_ge
id|mp-&gt;m_sb.sb_agcount
op_logical_or
id|agbno
op_ge
id|mp-&gt;m_sb.sb_agblocks
op_logical_or
id|ino
op_ne
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|agno
op_ge
id|mp-&gt;m_sb.sb_agcount
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_dilocate: agno (%d) &gt;= &quot;
l_string|&quot;mp-&gt;m_sb.sb_agcount (%d)&quot;
comma
id|agno
comma
id|mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|agbno
op_ge
id|mp-&gt;m_sb.sb_agblocks
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_dilocate: agbno (0x%llx) &gt;= &quot;
l_string|&quot;mp-&gt;m_sb.sb_agblocks (0x%lx)&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|agbno
comma
(paren
r_int
r_int
)paren
id|mp-&gt;m_sb.sb_agblocks
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ino
op_ne
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
)paren
(brace
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_dilocate: ino (0x%llx) != &quot;
l_string|&quot;XFS_AGINO_TO_INO(mp, agno, agino) &quot;
l_string|&quot;(0x%llx)&quot;
comma
id|ino
comma
id|XFS_AGINO_TO_INO
c_func
(paren
id|mp
comma
id|agno
comma
id|agino
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG */
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mp-&gt;m_sb.sb_blocksize
op_ge
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|mp
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|flags
op_amp
id|XFS_IMAP_LOOKUP
)paren
)paren
(brace
id|offset
op_assign
id|XFS_INO_TO_OFFSET
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
OL
id|mp-&gt;m_sb.sb_inopblock
)paren
suffix:semicolon
op_star
id|bno
op_assign
id|XFS_AGB_TO_FSB
c_func
(paren
id|mp
comma
id|agno
comma
id|agbno
)paren
suffix:semicolon
op_star
id|off
op_assign
id|offset
suffix:semicolon
op_star
id|len
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|blks_per_cluster
op_assign
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|mp
)paren
op_rshift
id|mp-&gt;m_sb.sb_blocklog
suffix:semicolon
r_if
c_cond
(paren
op_star
id|bno
op_ne
id|NULLFSBLOCK
)paren
(brace
id|offset
op_assign
id|XFS_INO_TO_OFFSET
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
OL
id|mp-&gt;m_sb.sb_inopblock
)paren
suffix:semicolon
id|cluster_agbno
op_assign
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
op_star
id|bno
)paren
suffix:semicolon
op_star
id|off
op_assign
(paren
(paren
id|agbno
op_minus
id|cluster_agbno
)paren
op_star
id|mp-&gt;m_sb.sb_inopblock
)paren
op_plus
id|offset
suffix:semicolon
op_star
id|len
op_assign
id|blks_per_cluster
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp-&gt;m_inoalign_mask
)paren
(brace
id|offset_agbno
op_assign
id|agbno
op_amp
id|mp-&gt;m_inoalign_mask
suffix:semicolon
id|chunk_agbno
op_assign
id|agbno
op_minus
id|offset_agbno
suffix:semicolon
)brace
r_else
(brace
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|error
op_assign
id|xfs_ialloc_read_agi
c_func
(paren
id|mp
comma
id|tp
comma
id|agno
comma
op_amp
id|agbp
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_dilocate: &quot;
l_string|&quot;xfs_ialloc_read_agi() returned &quot;
l_string|&quot;error %d, agno %d&quot;
comma
id|error
comma
id|agno
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_return
id|error
suffix:semicolon
)brace
id|cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
id|agbp
comma
id|agno
comma
id|XFS_BTNUM_INO
comma
(paren
id|xfs_inode_t
op_star
)paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_lookup_le
c_func
(paren
id|cur
comma
id|agino
comma
l_int|0
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_dilocate: &quot;
l_string|&quot;xfs_inobt_lookup_le() failed&quot;
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_inobt_get_rec
c_func
(paren
id|cur
comma
op_amp
id|chunk_agino
comma
op_amp
id|chunk_cnt
comma
op_amp
id|chunk_free
comma
op_amp
id|i
comma
id|ARCH_NOCONVERT
)paren
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_dilocate: &quot;
l_string|&quot;xfs_inobt_get_rec() failed&quot;
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG
id|xfs_fs_cmn_err
c_func
(paren
id|CE_ALERT
comma
id|mp
comma
l_string|&quot;xfs_dilocate: &quot;
l_string|&quot;xfs_inobt_get_rec() failed&quot;
)paren
suffix:semicolon
macro_line|#endif /* DEBUG */
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agbp
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|chunk_agbno
op_assign
id|XFS_AGINO_TO_AGBNO
c_func
(paren
id|mp
comma
id|chunk_agino
)paren
suffix:semicolon
id|offset_agbno
op_assign
id|agbno
op_minus
id|chunk_agbno
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|agbno
op_ge
id|chunk_agbno
)paren
suffix:semicolon
id|cluster_agbno
op_assign
id|chunk_agbno
op_plus
(paren
(paren
id|offset_agbno
op_div
id|blks_per_cluster
)paren
op_star
id|blks_per_cluster
)paren
suffix:semicolon
id|offset
op_assign
(paren
(paren
id|agbno
op_minus
id|cluster_agbno
)paren
op_star
id|mp-&gt;m_sb.sb_inopblock
)paren
op_plus
id|XFS_INO_TO_OFFSET
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
op_star
id|bno
op_assign
id|XFS_AGB_TO_FSB
c_func
(paren
id|mp
comma
id|agno
comma
id|cluster_agbno
)paren
suffix:semicolon
op_star
id|off
op_assign
id|offset
suffix:semicolon
op_star
id|len
op_assign
id|blks_per_cluster
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agbp
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Compute and fill in value of m_in_maxlevels.&n; */
r_void
DECL|function|xfs_ialloc_compute_maxlevels
id|xfs_ialloc_compute_maxlevels
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
multiline_comment|/* file system mount structure */
(brace
r_int
id|level
suffix:semicolon
id|uint
id|maxblocks
suffix:semicolon
id|uint
id|maxleafents
suffix:semicolon
r_int
id|minleafrecs
suffix:semicolon
r_int
id|minnoderecs
suffix:semicolon
id|maxleafents
op_assign
(paren
l_int|1LL
op_lshift
id|XFS_INO_AGINO_BITS
c_func
(paren
id|mp
)paren
)paren
op_rshift
id|XFS_INODES_PER_CHUNK_LOG
suffix:semicolon
id|minleafrecs
op_assign
id|mp-&gt;m_alloc_mnr
(braket
l_int|0
)braket
suffix:semicolon
id|minnoderecs
op_assign
id|mp-&gt;m_alloc_mnr
(braket
l_int|1
)braket
suffix:semicolon
id|maxblocks
op_assign
(paren
id|maxleafents
op_plus
id|minleafrecs
op_minus
l_int|1
)paren
op_div
id|minleafrecs
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|1
suffix:semicolon
id|maxblocks
OG
l_int|1
suffix:semicolon
id|level
op_increment
)paren
id|maxblocks
op_assign
(paren
id|maxblocks
op_plus
id|minnoderecs
op_minus
l_int|1
)paren
op_div
id|minnoderecs
suffix:semicolon
id|mp-&gt;m_in_maxlevels
op_assign
id|level
suffix:semicolon
)brace
multiline_comment|/*&n; * Log specified fields for the ag hdr (inode section)&n; */
r_void
DECL|function|xfs_ialloc_log_agi
id|xfs_ialloc_log_agi
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|bp
comma
multiline_comment|/* allocation group header buffer */
r_int
id|fields
)paren
multiline_comment|/* bitmask of fields to log */
(brace
r_int
id|first
suffix:semicolon
multiline_comment|/* first byte number */
r_int
id|last
suffix:semicolon
multiline_comment|/* last byte number */
r_static
r_const
r_int
id|offsets
(braket
)braket
op_assign
(brace
multiline_comment|/* field starting offsets */
multiline_comment|/* keep in sync with bit definitions */
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_magicnum
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_versionnum
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_seqno
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_length
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_count
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_root
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_level
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_freecount
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_newino
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_dirino
)paren
comma
m_offsetof
(paren
id|xfs_agi_t
comma
id|agi_unlinked
)paren
comma
r_sizeof
(paren
id|xfs_agi_t
)paren
)brace
suffix:semicolon
macro_line|#ifdef DEBUG
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
multiline_comment|/* allocation group header */
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Compute byte offsets for the first and last fields.&n;&t; */
id|xfs_btree_offsets
c_func
(paren
id|fields
comma
id|offsets
comma
id|XFS_AGI_NUM_BITS
comma
op_amp
id|first
comma
op_amp
id|last
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Log the allocation group inode header buffer.&n;&t; */
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
id|first
comma
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in the allocation group header (inode allocation section)&n; */
r_int
DECL|function|xfs_ialloc_read_agi
id|xfs_ialloc_read_agi
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_buf_t
op_star
op_star
id|bpp
)paren
multiline_comment|/* allocation group hdr buf */
(brace
id|xfs_agi_t
op_star
id|agi
suffix:semicolon
multiline_comment|/* allocation group header */
r_int
id|agi_ok
suffix:semicolon
multiline_comment|/* agi is consistent */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* allocation group hdr buf */
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
multiline_comment|/* per allocation group data */
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|agno
op_ne
id|NULLAGNUMBER
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGI_DADDR
c_func
(paren
id|mp
)paren
)paren
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
op_logical_and
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Validate the magic number of the agi block.&n;&t; */
id|agi
op_assign
id|XFS_BUF_TO_AGI
c_func
(paren
id|bp
)paren
suffix:semicolon
id|agi_ok
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGI_MAGIC
op_logical_and
id|XFS_AGI_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|agi-&gt;agi_versionnum
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|agi_ok
comma
id|mp
comma
id|XFS_ERRTAG_IALLOC_READ_AGI
comma
id|XFS_RANDOM_IALLOC_READ_AGI
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_ialloc_read_agi&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|agi
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pag-&gt;pagi_init
)paren
(brace
id|pag-&gt;pagi_freecount
op_assign
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pag-&gt;pagi_init
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * It&squot;s possible for these to be out of sync if&n;&t;&t; * we are in the middle of a forced shutdown.&n;&t;&t; */
id|ASSERT
c_func
(paren
id|pag-&gt;pagi_freecount
op_eq
id|INT_GET
c_func
(paren
id|agi-&gt;agi_freecount
comma
id|ARCH_CONVERT
)paren
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XFS_AGI_UNLINKED_BUCKETS
suffix:semicolon
id|i
op_increment
)paren
id|ASSERT
c_func
(paren
op_logical_neg
id|INT_ISZERO
c_func
(paren
id|agi-&gt;agi_unlinked
(braket
id|i
)braket
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_AGI
comma
id|XFS_AGI_REF
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
