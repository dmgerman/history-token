multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * xfs_dir2_sf.c&n; * Shortform directory implementation for v2 directories.&n; */
macro_line|#include &lt;xfs.h&gt;
multiline_comment|/*&n; * Prototypes for internal functions.&n; */
r_static
r_void
id|xfs_dir2_sf_addname_easy
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
id|xfs_dir2_sf_entry_t
op_star
id|sfep
comma
id|xfs_dir2_data_aoff_t
id|offset
comma
r_int
id|new_isize
)paren
suffix:semicolon
r_static
r_void
id|xfs_dir2_sf_addname_hard
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|objchange
comma
r_int
id|new_isize
)paren
suffix:semicolon
r_static
r_int
id|xfs_dir2_sf_addname_pick
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
r_int
id|objchange
comma
id|xfs_dir2_sf_entry_t
op_star
op_star
id|sfepp
comma
id|xfs_dir2_data_aoff_t
op_star
id|offsetp
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_static
r_void
id|xfs_dir2_sf_check
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
macro_line|#else
DECL|macro|xfs_dir2_sf_check
mdefine_line|#define&t;xfs_dir2_sf_check(args)
macro_line|#endif /* DEBUG */
macro_line|#if XFS_BIG_FILESYSTEMS
r_static
r_void
id|xfs_dir2_sf_toino4
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
r_static
r_void
id|xfs_dir2_sf_toino8
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
suffix:semicolon
macro_line|#endif /* XFS_BIG_FILESYSTEMS */
multiline_comment|/*&n; * Given a block directory (dp/block), calculate its size as a shortform (sf)&n; * directory and a header for the sf directory, if it will fit it the&n; * space currently present in the inode.  If it won&squot;t fit, the output&n; * size is too big (but not accurate).&n; */
r_int
multiline_comment|/* size for sf form */
DECL|function|xfs_dir2_block_sfsize
id|xfs_dir2_block_sfsize
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore inode pointer */
id|xfs_dir2_block_t
op_star
id|block
comma
multiline_comment|/* block directory data */
id|xfs_dir2_sf_hdr_t
op_star
id|sfhp
)paren
multiline_comment|/* output: header for sf form */
(brace
id|xfs_dir2_dataptr_t
id|addr
suffix:semicolon
multiline_comment|/* data entry address */
id|xfs_dir2_leaf_entry_t
op_star
id|blp
suffix:semicolon
multiline_comment|/* leaf area of the block */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* tail area of the block */
r_int
id|count
suffix:semicolon
multiline_comment|/* shortform entry count */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry in the block */
r_int
id|i
suffix:semicolon
multiline_comment|/* block entry index */
r_int
id|i8count
suffix:semicolon
multiline_comment|/* count of big-inode entries */
r_int
id|isdot
suffix:semicolon
multiline_comment|/* entry is &quot;.&quot; */
r_int
id|isdotdot
suffix:semicolon
multiline_comment|/* entry is &quot;..&quot; */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure pointer */
r_int
id|namelen
suffix:semicolon
multiline_comment|/* total name bytes */
id|xfs_ino_t
id|parent
suffix:semicolon
multiline_comment|/* parent inode number */
r_int
id|size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* total computed size */
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|count
op_assign
id|i8count
op_assign
id|namelen
op_assign
l_int|0
suffix:semicolon
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|blp
op_assign
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate over the block&squot;s data entries by using the leaf pointers.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INT_GET
c_func
(paren
id|btp-&gt;count
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_assign
id|INT_GET
c_func
(paren
id|blp
(braket
id|i
)braket
dot
id|address
comma
id|ARCH_CONVERT
)paren
)paren
op_eq
id|XFS_DIR2_NULL_DATAPTR
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate the pointer to the entry at hand.&n;&t;&t; */
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|block
op_plus
id|XFS_DIR2_DATAPTR_TO_OFF
c_func
(paren
id|mp
comma
id|addr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Detect . and .., so we can special-case them.&n;&t;&t; * . is not included in sf directories.&n;&t;&t; * .. is included by just the parent inode number.&n;&t;&t; */
id|isdot
op_assign
id|dep-&gt;namelen
op_eq
l_int|1
op_logical_and
id|dep-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
suffix:semicolon
id|isdotdot
op_assign
id|dep-&gt;namelen
op_eq
l_int|2
op_logical_and
id|dep-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|dep-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
op_logical_neg
id|isdot
)paren
id|i8count
op_add_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
OG
id|XFS_DIR2_MAX_SHORT_INUM
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|isdot
op_logical_and
op_logical_neg
id|isdotdot
)paren
(brace
id|count
op_increment
suffix:semicolon
id|namelen
op_add_assign
id|dep-&gt;namelen
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|isdotdot
)paren
id|parent
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Calculate the new size, see if we should give up yet.&n;&t;&t; */
id|size
op_assign
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|i8count
)paren
op_plus
multiline_comment|/* header */
id|count
op_plus
multiline_comment|/* namelen */
id|count
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_sf_off_t
)paren
op_plus
multiline_comment|/* offset */
id|namelen
op_plus
multiline_comment|/* name */
(paren
id|i8count
ques
c_cond
multiline_comment|/* inumber */
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino8_t
)paren
op_star
id|count
suffix:colon
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino4_t
)paren
op_star
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
r_return
id|size
suffix:semicolon
multiline_comment|/* size value is a failure */
)brace
multiline_comment|/*&n;&t; * Create the output header, if it worked.&n;&t; */
id|sfhp-&gt;count
op_assign
id|count
suffix:semicolon
id|sfhp-&gt;i8count
op_assign
id|i8count
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|sfhp
comma
op_amp
id|parent
comma
op_amp
id|sfhp-&gt;parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a block format directory to shortform.&n; * Caller has already checked that it will fit, and built us a header.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_block_to_sf
id|xfs_dir2_block_to_sf
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dabuf_t
op_star
id|bp
comma
multiline_comment|/* block buffer */
r_int
id|size
comma
multiline_comment|/* shortform directory size */
id|xfs_dir2_sf_hdr_t
op_star
id|sfhp
)paren
multiline_comment|/* shortform directory hdr */
(brace
id|xfs_dir2_block_t
op_star
id|block
suffix:semicolon
multiline_comment|/* block structure */
id|xfs_dir2_block_tail_t
op_star
id|btp
suffix:semicolon
multiline_comment|/* block tail pointer */
id|xfs_dir2_data_entry_t
op_star
id|dep
suffix:semicolon
multiline_comment|/* data entry pointer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
id|xfs_dir2_data_unused_t
op_star
id|dup
suffix:semicolon
multiline_comment|/* unused data pointer */
r_char
op_star
id|endptr
suffix:semicolon
multiline_comment|/* end of data entries */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|logflags
suffix:semicolon
multiline_comment|/* inode logging flags */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
r_char
op_star
id|ptr
suffix:semicolon
multiline_comment|/* current data pointer */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|xfs_ino_t
id|temp
suffix:semicolon
id|xfs_dir2_trace_args_sb
c_func
(paren
l_string|&quot;block_to_sf&quot;
comma
id|args
comma
id|size
comma
id|bp
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
multiline_comment|/*&n;&t; * Make a copy of the block data, so we can shrink the inode&n;&t; * and add local data.&n;&t; */
id|block
op_assign
id|kmem_alloc
c_func
(paren
id|mp-&gt;m_dirblksize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|block
comma
id|bp-&gt;data
comma
id|mp-&gt;m_dirblksize
)paren
suffix:semicolon
id|logflags
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_dir2_shrink_inode
c_func
(paren
id|args
comma
id|mp-&gt;m_dirdatablk
comma
id|bp
)paren
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|error
op_ne
id|ENOSPC
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The buffer is now unconditionally gone, whether&n;&t; * xfs_dir2_shrink_inode worked or not.&n;&t; *&n;&t; * Convert the inode to local format.&n;&t; */
id|dp-&gt;i_df.if_flags
op_and_assign
op_complement
id|XFS_IFEXTENTS
suffix:semicolon
id|dp-&gt;i_df.if_flags
op_or_assign
id|XFS_IFINLINE
suffix:semicolon
id|dp-&gt;i_d.di_format
op_assign
id|XFS_DINODE_FMT_LOCAL
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|size
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|logflags
op_or_assign
id|XFS_ILOG_DDATA
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the header into the newly allocate local space.&n;&t; */
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|memcpy
c_func
(paren
id|sfp
comma
id|sfhp
comma
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|sfhp-&gt;i8count
)paren
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
id|size
suffix:semicolon
multiline_comment|/*&n;&t; * Set up to loop over the block&squot;s entries.&n;&t; */
id|btp
op_assign
id|XFS_DIR2_BLOCK_TAIL_P
c_func
(paren
id|mp
comma
id|block
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_char
op_star
)paren
id|block-&gt;u
suffix:semicolon
id|endptr
op_assign
(paren
r_char
op_star
)paren
id|XFS_DIR2_BLOCK_LEAF_P_ARCH
c_func
(paren
id|btp
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the active and unused entries.&n;&t; * Stop when we reach the leaf/tail portion of the block.&n;&t; */
r_while
c_loop
(paren
id|ptr
OL
id|endptr
)paren
(brace
multiline_comment|/*&n;&t;&t; * If it&squot;s unused, just skip over it.&n;&t;&t; */
id|dup
op_assign
(paren
id|xfs_dir2_data_unused_t
op_star
)paren
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|dup-&gt;freetag
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_DATA_FREE_TAG
)paren
(brace
id|ptr
op_add_assign
id|INT_GET
c_func
(paren
id|dup-&gt;length
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dep
op_assign
(paren
id|xfs_dir2_data_entry_t
op_star
)paren
id|ptr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Skip .&n;&t;&t; */
r_if
c_cond
(paren
id|dep-&gt;namelen
op_eq
l_int|1
op_logical_and
id|dep-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
op_eq
id|dp-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Skip .., but make sure the inode number is right.&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|dep-&gt;namelen
op_eq
l_int|2
op_logical_and
id|dep-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|dep-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Normal entry, copy it into shortform.&n;&t;&t; */
r_else
(brace
id|sfep-&gt;namelen
op_assign
id|dep-&gt;namelen
suffix:semicolon
id|XFS_DIR2_SF_PUT_OFFSET_ARCH
c_func
(paren
id|sfep
comma
(paren
id|xfs_dir2_data_aoff_t
)paren
(paren
(paren
r_char
op_star
)paren
id|dep
op_minus
(paren
r_char
op_star
)paren
id|block
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sfep-&gt;name
comma
id|dep-&gt;name
comma
id|dep-&gt;namelen
)paren
suffix:semicolon
id|temp
op_assign
id|INT_GET
c_func
(paren
id|dep-&gt;inumber
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|temp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
suffix:semicolon
)brace
id|ptr
op_add_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|dep-&gt;namelen
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
id|sfep
op_minus
(paren
r_char
op_star
)paren
id|sfp
op_eq
id|size
)paren
suffix:semicolon
id|xfs_dir2_sf_check
c_func
(paren
id|args
)paren
suffix:semicolon
id|out
suffix:colon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|logflags
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|block
comma
id|mp-&gt;m_dirblksize
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a name to a shortform directory.&n; * There are two algorithms, &quot;easy&quot; and &quot;hard&quot; which we decide on&n; * before changing anything.&n; * Convert to block form if necessary, if the new entry won&squot;t fit.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_sf_addname
id|xfs_dir2_sf_addname
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
r_int
id|add_entsize
suffix:semicolon
multiline_comment|/* size of the new entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|incr_isize
suffix:semicolon
multiline_comment|/* total change in size */
r_int
id|new_isize
suffix:semicolon
multiline_comment|/* di_size after adding name */
r_int
id|objchange
suffix:semicolon
multiline_comment|/* changing to 8-byte inodes */
id|xfs_dir2_data_aoff_t
id|offset
suffix:semicolon
multiline_comment|/* offset for new entry */
r_int
id|old_isize
suffix:semicolon
multiline_comment|/* di_size before adding name */
r_int
id|pick
suffix:semicolon
multiline_comment|/* which algorithm to use */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform entry */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;sf_addname&quot;
comma
id|args
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_dir2_sf_lookup
c_func
(paren
id|args
)paren
op_eq
id|ENOENT
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the shortform value has some of its header.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
m_offsetof
(paren
id|xfs_dir2_sf_hdr_t
comma
id|parent
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_d.di_size
op_ge
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|sfp-&gt;hdr.i8count
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute entry (and change in) size.&n;&t; */
id|add_entsize
op_assign
id|XFS_DIR2_SF_ENTSIZE_BYNAME
c_func
(paren
id|sfp
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|incr_isize
op_assign
id|add_entsize
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
multiline_comment|/*&n;&t; * Do we have to change to 8 byte inodes?&n;&t; */
r_if
c_cond
(paren
id|args-&gt;inumber
OG
id|XFS_DIR2_MAX_SHORT_INUM
op_logical_and
id|sfp-&gt;hdr.i8count
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Yes, adjust the entry size and the total size.&n;&t;&t; */
id|add_entsize
op_add_assign
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino8_t
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino4_t
)paren
suffix:semicolon
id|incr_isize
op_add_assign
(paren
id|sfp-&gt;hdr.count
op_plus
l_int|2
)paren
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino8_t
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino4_t
)paren
)paren
suffix:semicolon
id|objchange
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|objchange
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|objchange
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|old_isize
op_assign
(paren
r_int
)paren
id|dp-&gt;i_d.di_size
suffix:semicolon
id|new_isize
op_assign
id|old_isize
op_plus
id|incr_isize
suffix:semicolon
multiline_comment|/*&n;&t; * Won&squot;t fit as shortform any more (due to size),&n;&t; * or the pick routine says it won&squot;t (due to offset values).&n;&t; */
r_if
c_cond
(paren
id|new_isize
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
op_logical_or
(paren
id|pick
op_assign
id|xfs_dir2_sf_addname_pick
c_func
(paren
id|args
comma
id|objchange
comma
op_amp
id|sfep
comma
op_amp
id|offset
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Just checking or no space reservation, it doesn&squot;t fit.&n;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
op_logical_or
id|args-&gt;total
op_eq
l_int|0
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSPC
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Convert to block form then add the name.&n;&t;&t; */
id|error
op_assign
id|xfs_dir2_sf_to_block
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|xfs_dir2_block_addname
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Just checking, it fits.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;justcheck
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Do it the easy way - just add it at the end.&n;&t; */
r_if
c_cond
(paren
id|pick
op_eq
l_int|1
)paren
id|xfs_dir2_sf_addname_easy
c_func
(paren
id|args
comma
id|sfep
comma
id|offset
comma
id|new_isize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do it the hard way - look for a place to insert the new entry.&n;&t; * Convert to 8 byte inode numbers first if necessary.&n;&t; */
r_else
(brace
id|ASSERT
c_func
(paren
id|pick
op_eq
l_int|2
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
id|objchange
)paren
id|xfs_dir2_sf_toino8
c_func
(paren
id|args
)paren
suffix:semicolon
macro_line|#endif
id|xfs_dir2_sf_addname_hard
c_func
(paren
id|args
comma
id|objchange
comma
id|new_isize
)paren
suffix:semicolon
)brace
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the new entry the &quot;easy&quot; way.&n; * This is copying the old directory and adding the new entry at the end.&n; * Since it&squot;s sorted by &quot;offset&quot; we need room after the last offset&n; * that&squot;s already there, and then room to convert to a block directory.&n; * This is already checked by the pick routine.&n; */
r_static
r_void
DECL|function|xfs_dir2_sf_addname_easy
id|xfs_dir2_sf_addname_easy
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
comma
multiline_comment|/* pointer to new entry */
id|xfs_dir2_data_aoff_t
id|offset
comma
multiline_comment|/* offset to use for new ent */
r_int
id|new_isize
)paren
multiline_comment|/* new directory size */
(brace
r_int
id|byteoff
suffix:semicolon
multiline_comment|/* byte offset in sf dir */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|byteoff
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|sfep
op_minus
(paren
r_char
op_star
)paren
id|sfp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Grow the in-inode space.&n;&t; */
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|XFS_DIR2_SF_ENTSIZE_BYNAME
c_func
(paren
id|sfp
comma
id|args-&gt;namelen
)paren
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Need to set up again due to realloc of the inode data.&n;&t; */
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|sfep
op_assign
(paren
id|xfs_dir2_sf_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|sfp
op_plus
id|byteoff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the new entry.&n;&t; */
id|sfep-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|XFS_DIR2_SF_PUT_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sfep-&gt;name
comma
id|args-&gt;name
comma
id|sfep-&gt;namelen
)paren
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|args-&gt;inumber
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the header and inode.&n;&t; */
id|sfp-&gt;hdr.count
op_increment
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
id|args-&gt;inumber
OG
id|XFS_DIR2_MAX_SHORT_INUM
)paren
id|sfp-&gt;hdr.i8count
op_increment
suffix:semicolon
macro_line|#endif
id|dp-&gt;i_d.di_size
op_assign
id|new_isize
suffix:semicolon
id|xfs_dir2_sf_check
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add the new entry the &quot;hard&quot; way.&n; * The caller has already converted to 8 byte inode numbers if necessary,&n; * in which case we need to leave the i8count at 1.&n; * Find a hole that the new entry will fit into, and copy&n; * the first part of the entries, the new entry, and the last part of&n; * the entries.&n; */
multiline_comment|/* ARGSUSED */
r_static
r_void
DECL|function|xfs_dir2_sf_addname_hard
id|xfs_dir2_sf_addname_hard
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
r_int
id|objchange
comma
multiline_comment|/* changing inode number size */
r_int
id|new_isize
)paren
multiline_comment|/* new directory size */
(brace
r_int
id|add_datasize
suffix:semicolon
multiline_comment|/* data size need for new ent */
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* buffer for old */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|eof
suffix:semicolon
multiline_comment|/* reached end of old dir */
r_int
id|nbytes
suffix:semicolon
multiline_comment|/* temp for byte copies */
id|xfs_dir2_data_aoff_t
id|new_offset
suffix:semicolon
multiline_comment|/* next offset value */
id|xfs_dir2_data_aoff_t
id|offset
suffix:semicolon
multiline_comment|/* current offset value */
r_int
id|old_isize
suffix:semicolon
multiline_comment|/* previous di_size */
id|xfs_dir2_sf_entry_t
op_star
id|oldsfep
suffix:semicolon
multiline_comment|/* entry in original dir */
id|xfs_dir2_sf_t
op_star
id|oldsfp
suffix:semicolon
multiline_comment|/* original shortform dir */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* entry in new dir */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* new shortform dir */
multiline_comment|/*&n;&t; * Copy the old directory to the stack buffer.&n;&t; */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|old_isize
op_assign
(paren
r_int
)paren
id|dp-&gt;i_d.di_size
suffix:semicolon
id|buf
op_assign
id|kmem_alloc
c_func
(paren
id|old_isize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|oldsfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|buf
suffix:semicolon
id|memcpy
c_func
(paren
id|oldsfp
comma
id|sfp
comma
id|old_isize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the old directory finding the place we&squot;re going&n;&t; * to insert the new entry.&n;&t; * If it&squot;s going to end up at the end then oldsfep will point there.&n;&t; */
r_for
c_loop
(paren
id|offset
op_assign
id|XFS_DIR2_DATA_FIRST_OFFSET
comma
id|oldsfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|oldsfp
)paren
comma
id|add_datasize
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|args-&gt;namelen
)paren
comma
id|eof
op_assign
(paren
r_char
op_star
)paren
id|oldsfep
op_eq
op_amp
id|buf
(braket
id|old_isize
)braket
suffix:semicolon
op_logical_neg
id|eof
suffix:semicolon
id|offset
op_assign
id|new_offset
op_plus
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|oldsfep-&gt;namelen
)paren
comma
id|oldsfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|oldsfp
comma
id|oldsfep
)paren
comma
id|eof
op_assign
(paren
r_char
op_star
)paren
id|oldsfep
op_eq
op_amp
id|buf
(braket
id|old_isize
)braket
)paren
(brace
id|new_offset
op_assign
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|oldsfep
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|add_datasize
op_le
id|new_offset
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get rid of the old directory, then allocate space for&n;&t; * the new one.  We do this so xfs_idata_realloc won&squot;t copy&n;&t; * the data.&n;&t; */
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|old_isize
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|new_isize
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the pointer since the buffer was reallocated.&n;&t; */
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the first part of the directory, including the header.&n;&t; */
id|nbytes
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|oldsfep
op_minus
(paren
r_char
op_star
)paren
id|oldsfp
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sfp
comma
id|oldsfp
comma
id|nbytes
)paren
suffix:semicolon
id|sfep
op_assign
(paren
id|xfs_dir2_sf_entry_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|sfp
op_plus
id|nbytes
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the new entry, and update the header counts.&n;&t; */
id|sfep-&gt;namelen
op_assign
id|args-&gt;namelen
suffix:semicolon
id|XFS_DIR2_SF_PUT_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|offset
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sfep-&gt;name
comma
id|args-&gt;name
comma
id|sfep-&gt;namelen
)paren
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|args-&gt;inumber
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfp-&gt;hdr.count
op_increment
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
id|args-&gt;inumber
OG
id|XFS_DIR2_MAX_SHORT_INUM
op_logical_and
op_logical_neg
id|objchange
)paren
id|sfp-&gt;hdr.i8count
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If there&squot;s more left to copy, do that.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|eof
)paren
(brace
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|sfep
comma
id|oldsfep
comma
id|old_isize
op_minus
id|nbytes
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|buf
comma
id|old_isize
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
id|new_isize
suffix:semicolon
id|xfs_dir2_sf_check
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decide if the new entry will fit at all.&n; * If it will fit, pick between adding the new entry to the end (easy)&n; * or somewhere else (hard).&n; * Return 0 (won&squot;t fit), 1 (easy), 2 (hard).&n; */
multiline_comment|/*ARGSUSED*/
r_static
r_int
multiline_comment|/* pick result */
DECL|function|xfs_dir2_sf_addname_pick
id|xfs_dir2_sf_addname_pick
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
r_int
id|objchange
comma
multiline_comment|/* inode # size changes */
id|xfs_dir2_sf_entry_t
op_star
op_star
id|sfepp
comma
multiline_comment|/* out(1): new entry ptr */
id|xfs_dir2_data_aoff_t
op_star
id|offsetp
)paren
multiline_comment|/* out(1): new offset */
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|holefit
suffix:semicolon
multiline_comment|/* found hole it will fit in */
r_int
id|i
suffix:semicolon
multiline_comment|/* entry number */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_data_aoff_t
id|offset
suffix:semicolon
multiline_comment|/* data block offset */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
r_int
id|size
suffix:semicolon
multiline_comment|/* entry&squot;s data size */
r_int
id|used
suffix:semicolon
multiline_comment|/* data bytes used */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|size
op_assign
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|args-&gt;namelen
)paren
suffix:semicolon
id|offset
op_assign
id|XFS_DIR2_DATA_FIRST_OFFSET
suffix:semicolon
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
id|holefit
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over sf entries.&n;&t; * Keep track of data offset and whether we&squot;ve seen a place&n;&t; * to insert the new entry.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|holefit
)paren
id|holefit
op_assign
id|offset
op_plus
id|size
op_le
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|offset
op_assign
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|ARCH_CONVERT
)paren
op_plus
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|sfep-&gt;namelen
)paren
suffix:semicolon
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate data bytes used excluding the new entry, if this&n;&t; * was a data block (block form directory).&n;&t; */
id|used
op_assign
id|offset
op_plus
(paren
id|sfp-&gt;hdr.count
op_plus
l_int|3
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_leaf_entry_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_block_tail_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it won&squot;t fit in a block form then we can&squot;t insert it,&n;&t; * we&squot;ll go back, convert to block, then try the insert and convert&n;&t; * to leaf.&n;&t; */
r_if
c_cond
(paren
id|used
op_plus
(paren
id|holefit
ques
c_cond
l_int|0
suffix:colon
id|size
)paren
OG
id|mp-&gt;m_dirblksize
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If changing the inode number size, do it the hard way.&n;&t; */
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
id|objchange
)paren
(brace
r_return
l_int|2
suffix:semicolon
)brace
macro_line|#else
id|ASSERT
c_func
(paren
id|objchange
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If it won&squot;t fit at the end then do it the hard way (use the hole).&n;&t; */
r_if
c_cond
(paren
id|used
op_plus
id|size
OG
id|mp-&gt;m_dirblksize
)paren
r_return
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * Do it the easy way.&n;&t; */
op_star
id|sfepp
op_assign
id|sfep
suffix:semicolon
op_star
id|offsetp
op_assign
id|offset
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/*&n; * Check consistency of shortform directory, assert if bad.&n; */
r_static
r_void
DECL|function|xfs_dir2_sf_check
id|xfs_dir2_sf_check
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|i
suffix:semicolon
multiline_comment|/* entry number */
r_int
id|i8count
suffix:semicolon
multiline_comment|/* number of big inode#s */
id|xfs_ino_t
id|ino
suffix:semicolon
multiline_comment|/* entry inode number */
r_int
id|offset
suffix:semicolon
multiline_comment|/* data offset */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform dir entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|offset
op_assign
id|XFS_DIR2_DATA_FIRST_OFFSET
suffix:semicolon
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i8count
op_assign
id|ino
OG
id|XFS_DIR2_MAX_SHORT_INUM
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
comma
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|ARCH_CONVERT
)paren
op_ge
id|offset
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|i8count
op_add_assign
id|ino
OG
id|XFS_DIR2_MAX_SHORT_INUM
suffix:semicolon
id|offset
op_assign
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|ARCH_CONVERT
)paren
op_plus
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|sfep-&gt;namelen
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i8count
op_eq
id|sfp-&gt;hdr.i8count
)paren
suffix:semicolon
macro_line|#if !XFS_BIG_FILESYSTEMS
id|ASSERT
c_func
(paren
id|i8count
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
(paren
r_char
op_star
)paren
id|sfep
op_minus
(paren
r_char
op_star
)paren
id|sfp
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|offset
op_plus
(paren
id|sfp-&gt;hdr.count
op_plus
l_int|2
)paren
op_star
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_leaf_entry_t
)paren
op_plus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_block_tail_t
)paren
op_le
id|dp-&gt;i_mount-&gt;m_dirblksize
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* DEBUG */
multiline_comment|/*&n; * Create a new (shortform) directory.&n; */
r_int
multiline_comment|/* error, always 0 */
DECL|function|xfs_dir2_sf_create
id|xfs_dir2_sf_create
c_func
(paren
id|xfs_da_args_t
op_star
id|args
comma
multiline_comment|/* operation arguments */
id|xfs_ino_t
id|pino
)paren
multiline_comment|/* parent inode number */
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|i8count
suffix:semicolon
multiline_comment|/* parent inode is an 8-byte number */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
r_int
id|size
suffix:semicolon
multiline_comment|/* directory size */
id|xfs_dir2_trace_args_i
c_func
(paren
l_string|&quot;sf_create&quot;
comma
id|args
comma
id|pino
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_d.di_size
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it&squot;s currently a zero-length extent file,&n;&t; * convert it to local format.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_EXTENTS
)paren
(brace
id|dp-&gt;i_df.if_flags
op_and_assign
op_complement
id|XFS_IFEXTENTS
suffix:semicolon
multiline_comment|/* just in case */
id|dp-&gt;i_d.di_format
op_assign
id|XFS_DINODE_FMT_LOCAL
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|dp-&gt;i_df.if_flags
op_or_assign
id|XFS_IFINLINE
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
l_int|0
)paren
suffix:semicolon
id|i8count
op_assign
id|pino
OG
id|XFS_DIR2_MAX_SHORT_INUM
suffix:semicolon
id|size
op_assign
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|i8count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make a buffer for the data.&n;&t; */
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|size
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the header,&n;&t; */
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|sfp-&gt;hdr.i8count
op_assign
id|i8count
suffix:semicolon
multiline_comment|/*&n;&t; * Now can put in the inode number, since i8count is set.&n;&t; */
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|pino
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|sfp-&gt;hdr.count
op_assign
l_int|0
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
id|size
suffix:semicolon
id|xfs_dir2_sf_check
c_func
(paren
id|args
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_sf_getdents
id|xfs_dir2_sf_getdents
c_func
(paren
id|xfs_inode_t
op_star
id|dp
comma
multiline_comment|/* incore directory inode */
id|uio_t
op_star
id|uio
comma
multiline_comment|/* caller&squot;s buffer control */
r_int
op_star
id|eofp
comma
multiline_comment|/* eof reached? (out) */
id|xfs_dirent_t
op_star
id|dbp
comma
multiline_comment|/* caller&squot;s buffer */
id|xfs_dir2_put_t
id|put
)paren
multiline_comment|/* abi&squot;s formatting function */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|i
suffix:semicolon
multiline_comment|/* shortform entry number */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* filesystem mount point */
id|xfs_dir2_dataptr_t
id|off
suffix:semicolon
multiline_comment|/* current entry&squot;s offset */
id|xfs_dir2_put_args_t
id|p
suffix:semicolon
multiline_comment|/* arg package for put rtn */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform directory entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|xfs_off_t
id|dir_offset
suffix:semicolon
id|mp
op_assign
id|dp-&gt;i_mount
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Give up if the directory is way too short.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
m_offsetof
(paren
id|xfs_dir2_sf_hdr_t
comma
id|parent
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|dir_offset
op_assign
id|uio-&gt;uio_offset
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_d.di_size
op_ge
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|sfp-&gt;hdr.i8count
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the block number in the offset is out of range, we&squot;re done.&n;&t; */
r_if
c_cond
(paren
id|XFS_DIR2_DATAPTR_TO_DB
c_func
(paren
id|mp
comma
id|dir_offset
)paren
OG
id|mp-&gt;m_dirdatablk
)paren
(brace
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set up putargs structure.&n;&t; */
id|p.dbp
op_assign
id|dbp
suffix:semicolon
id|p.put
op_assign
id|put
suffix:semicolon
id|p.uio
op_assign
id|uio
suffix:semicolon
multiline_comment|/*&n;&t; * Put . entry unless we&squot;re starting past it.&n;&t; */
r_if
c_cond
(paren
id|dir_offset
op_le
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|XFS_DIR2_DATA_DOT_OFFSET
)paren
)paren
(brace
id|p.cook
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
l_int|0
comma
id|XFS_DIR2_DATA_DOTDOT_OFFSET
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
id|p.ino
op_assign
id|dp-&gt;i_ino
op_plus
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#else
id|p.ino
op_assign
id|dp-&gt;i_ino
suffix:semicolon
macro_line|#endif
id|p.name
op_assign
l_string|&quot;.&quot;
suffix:semicolon
id|p.namelen
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|p
dot
id|put
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p.done
)paren
(brace
id|uio-&gt;uio_offset
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|XFS_DIR2_DATA_DOT_OFFSET
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Put .. entry unless we&squot;re starting past it.&n;&t; */
r_if
c_cond
(paren
id|dir_offset
op_le
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|XFS_DIR2_DATA_DOTDOT_OFFSET
)paren
)paren
(brace
id|p.cook
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|XFS_DIR2_DATA_FIRST_OFFSET
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
id|p.ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
op_plus
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#else
id|p.ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#endif
id|p.name
op_assign
l_string|&quot;..&quot;
suffix:semicolon
id|p.namelen
op_assign
l_int|2
suffix:semicolon
id|error
op_assign
id|p
dot
id|put
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p.done
)paren
(brace
id|uio-&gt;uio_offset
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|XFS_DIR2_DATA_DOTDOT_OFFSET
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Loop while there are more entries and put&squot;ing works.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
comma
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
)paren
(brace
id|off
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir_offset
OG
id|off
)paren
r_continue
suffix:semicolon
id|p.namelen
op_assign
id|sfep-&gt;namelen
suffix:semicolon
id|p.cook
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
comma
id|XFS_DIR2_SF_GET_OFFSET_ARCH
c_func
(paren
id|sfep
comma
id|ARCH_CONVERT
)paren
op_plus
id|XFS_DIR2_DATA_ENTSIZE
c_func
(paren
id|p.namelen
)paren
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
id|p.ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
op_plus
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#else
id|p.ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
macro_line|#endif
id|p.name
op_assign
(paren
r_char
op_star
)paren
id|sfep-&gt;name
suffix:semicolon
id|error
op_assign
id|p
dot
id|put
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p.done
)paren
(brace
id|uio-&gt;uio_offset
op_assign
id|off
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * They all fit.&n;&t; */
op_star
id|eofp
op_assign
l_int|1
suffix:semicolon
id|uio-&gt;uio_offset
op_assign
id|XFS_DIR2_DB_OFF_TO_DATAPTR
c_func
(paren
id|mp
comma
id|mp-&gt;m_dirdatablk
op_plus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup an entry in a shortform directory.&n; * Returns EEXIST if found, ENOENT if not found.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_sf_lookup
id|xfs_dir2_sf_lookup
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|i
suffix:semicolon
multiline_comment|/* entry index */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform directory entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;sf_lookup&quot;
comma
id|args
)paren
suffix:semicolon
id|xfs_dir2_sf_check
c_func
(paren
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bail out if the directory is way too short.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
m_offsetof
(paren
id|xfs_dir2_sf_hdr_t
comma
id|parent
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_d.di_size
op_ge
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|sfp-&gt;hdr.i8count
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Special case for .&n;&t; */
r_if
c_cond
(paren
id|args-&gt;namelen
op_eq
l_int|1
op_logical_and
id|args-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|args-&gt;inumber
op_assign
id|dp-&gt;i_ino
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Special case for ..&n;&t; */
r_if
c_cond
(paren
id|args-&gt;namelen
op_eq
l_int|2
op_logical_and
id|args-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|args-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|args-&gt;inumber
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop over all the entries trying to match ours.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
comma
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
)paren
(brace
r_if
c_cond
(paren
id|sfep-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|sfep-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfep-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
id|args-&gt;inumber
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EEXIST
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find it.&n;&t; */
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from a shortform directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_sf_removename
id|xfs_dir2_sf_removename
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
(brace
r_int
id|byteoff
suffix:semicolon
multiline_comment|/* offset of removed entry */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|entsize
suffix:semicolon
multiline_comment|/* this entry&squot;s size */
r_int
id|i
suffix:semicolon
multiline_comment|/* shortform entry index */
r_int
id|newsize
suffix:semicolon
multiline_comment|/* new inode size */
r_int
id|oldsize
suffix:semicolon
multiline_comment|/* old inode size */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform directory entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;sf_removename&quot;
comma
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
id|oldsize
op_assign
(paren
r_int
)paren
id|dp-&gt;i_d.di_size
suffix:semicolon
multiline_comment|/*&n;&t; * Bail out if the directory is way too short.&n;&t; */
r_if
c_cond
(paren
id|oldsize
OL
m_offsetof
(paren
id|xfs_dir2_sf_hdr_t
comma
id|parent
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|oldsize
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|oldsize
op_ge
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|sfp-&gt;hdr.i8count
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the old directory entries.&n;&t; * Find the one we&squot;re deleting.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
comma
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
)paren
(brace
r_if
c_cond
(paren
id|sfep-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|sfep-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|sfep-&gt;name
comma
id|args-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
op_eq
id|args-&gt;inumber
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Didn&squot;t find it.&n;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|sfp-&gt;hdr.count
)paren
(brace
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Calculate sizes.&n;&t; */
id|byteoff
op_assign
(paren
r_int
)paren
(paren
(paren
r_char
op_star
)paren
id|sfep
op_minus
(paren
r_char
op_star
)paren
id|sfp
)paren
suffix:semicolon
id|entsize
op_assign
id|XFS_DIR2_SF_ENTSIZE_BYNAME
c_func
(paren
id|sfp
comma
id|args-&gt;namelen
)paren
suffix:semicolon
id|newsize
op_assign
id|oldsize
op_minus
id|entsize
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the part if any after the removed entry, sliding it down.&n;&t; */
r_if
c_cond
(paren
id|byteoff
op_plus
id|entsize
OL
id|oldsize
)paren
id|memmove
c_func
(paren
(paren
r_char
op_star
)paren
id|sfp
op_plus
id|byteoff
comma
(paren
r_char
op_star
)paren
id|sfp
op_plus
id|byteoff
op_plus
id|entsize
comma
id|oldsize
op_minus
(paren
id|byteoff
op_plus
id|entsize
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the header and file size.&n;&t; */
id|sfp-&gt;hdr.count
op_decrement
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
id|newsize
suffix:semicolon
multiline_comment|/*&n;&t; * Reallocate, making it smaller.&n;&t; */
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|newsize
op_minus
id|oldsize
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
multiline_comment|/*&n;&t; * Are we changing inode number size?&n;&t; */
r_if
c_cond
(paren
id|args-&gt;inumber
OG
id|XFS_DIR2_MAX_SHORT_INUM
)paren
(brace
r_if
c_cond
(paren
id|sfp-&gt;hdr.i8count
op_eq
l_int|1
)paren
id|xfs_dir2_sf_toino4
c_func
(paren
id|args
)paren
suffix:semicolon
r_else
id|sfp-&gt;hdr.i8count
op_decrement
suffix:semicolon
)brace
macro_line|#endif
id|xfs_dir2_sf_check
c_func
(paren
id|args
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Replace the inode number of an entry in a shortform directory.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_dir2_sf_replace
id|xfs_dir2_sf_replace
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|i
suffix:semicolon
multiline_comment|/* entry index */
macro_line|#if XFS_BIG_FILESYSTEMS || defined(DEBUG)
id|xfs_ino_t
id|ino
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* entry old inode number */
macro_line|#endif
macro_line|#if XFS_BIG_FILESYSTEMS
r_int
id|i8elevated
suffix:semicolon
multiline_comment|/* sf_toino8 set i8count=1 */
macro_line|#endif
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* shortform directory entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* shortform structure */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;sf_replace&quot;
comma
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_flags
op_amp
id|XFS_IFINLINE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Bail out if the shortform directory is way too small.&n;&t; */
r_if
c_cond
(paren
id|dp-&gt;i_d.di_size
OL
m_offsetof
(paren
id|xfs_dir2_sf_hdr_t
comma
id|parent
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|dp-&gt;i_mount
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_bytes
op_eq
id|dp-&gt;i_d.di_size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_df.if_u1.if_data
op_ne
l_int|NULL
)paren
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|dp-&gt;i_d.di_size
op_ge
id|XFS_DIR2_SF_HDR_SIZE
c_func
(paren
id|sfp-&gt;hdr.i8count
)paren
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
multiline_comment|/*&n;&t; * New inode number is large, and need to convert to 8-byte inodes.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;inumber
OG
id|XFS_DIR2_MAX_SHORT_INUM
op_logical_and
id|sfp-&gt;hdr.i8count
op_eq
l_int|0
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
r_int
id|newsize
suffix:semicolon
multiline_comment|/* new inode size */
id|newsize
op_assign
id|dp-&gt;i_df.if_bytes
op_plus
(paren
id|sfp-&gt;hdr.count
op_plus
l_int|1
)paren
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino8_t
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino4_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Won&squot;t fit as shortform, convert to block then do replace.&n;&t;&t; */
r_if
c_cond
(paren
id|newsize
OG
id|XFS_IFORK_DSIZE
c_func
(paren
id|dp
)paren
)paren
(brace
id|error
op_assign
id|xfs_dir2_sf_to_block
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_return
id|xfs_dir2_block_replace
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Still fits, convert to 8-byte now.&n;&t;&t; */
id|xfs_dir2_sf_toino8
c_func
(paren
id|args
)paren
suffix:semicolon
id|i8elevated
op_assign
l_int|1
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
)brace
r_else
id|i8elevated
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|args-&gt;namelen
op_ne
l_int|1
op_logical_or
id|args-&gt;name
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Replace ..&squot;s entry.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;namelen
op_eq
l_int|2
op_logical_and
id|args-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|args-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
macro_line|#if XFS_BIG_FILESYSTEMS || defined(DEBUG)
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;inumber
op_ne
id|ino
)paren
suffix:semicolon
macro_line|#endif
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|args-&gt;inumber
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Normal entry, look for the name.&n;&t; */
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
comma
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
)paren
(brace
r_if
c_cond
(paren
id|sfep-&gt;namelen
op_eq
id|args-&gt;namelen
op_logical_and
id|sfep-&gt;name
(braket
l_int|0
)braket
op_eq
id|args-&gt;name
(braket
l_int|0
)braket
op_logical_and
id|memcmp
c_func
(paren
id|args-&gt;name
comma
id|sfep-&gt;name
comma
id|args-&gt;namelen
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#if XFS_BIG_FILESYSTEMS || defined(DEBUG)
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|sfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;inumber
op_ne
id|ino
)paren
suffix:semicolon
macro_line|#endif
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|args-&gt;inumber
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Didn&squot;t find it.&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|sfp-&gt;hdr.count
)paren
(brace
id|ASSERT
c_func
(paren
id|args-&gt;oknoent
)paren
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
id|i8elevated
)paren
id|xfs_dir2_sf_toino4
c_func
(paren
id|args
)paren
suffix:semicolon
macro_line|#endif
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
macro_line|#if XFS_BIG_FILESYSTEMS
multiline_comment|/*&n;&t; * See if the old number was large, the new number is small.&n;&t; */
r_if
c_cond
(paren
id|ino
OG
id|XFS_DIR2_MAX_SHORT_INUM
op_logical_and
id|args-&gt;inumber
op_le
id|XFS_DIR2_MAX_SHORT_INUM
)paren
(brace
multiline_comment|/*&n;&t;&t; * And the old count was one, so need to convert to small.&n;&t;&t; */
r_if
c_cond
(paren
id|sfp-&gt;hdr.i8count
op_eq
l_int|1
)paren
id|xfs_dir2_sf_toino4
c_func
(paren
id|args
)paren
suffix:semicolon
r_else
id|sfp-&gt;hdr.i8count
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * See if the old number was small, the new number is large.&n;&t; */
r_if
c_cond
(paren
id|ino
op_le
id|XFS_DIR2_MAX_SHORT_INUM
op_logical_and
id|args-&gt;inumber
OG
id|XFS_DIR2_MAX_SHORT_INUM
)paren
(brace
multiline_comment|/*&n;&t;&t; * add to the i8count unless we just converted to 8-byte&n;&t;&t; * inodes (which does an implied i8count = 1)&n;&t;&t; */
id|ASSERT
c_func
(paren
id|sfp-&gt;hdr.i8count
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i8elevated
)paren
id|sfp-&gt;hdr.i8count
op_increment
suffix:semicolon
)brace
macro_line|#endif
id|xfs_dir2_sf_check
c_func
(paren
id|args
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if XFS_BIG_FILESYSTEMS
multiline_comment|/*&n; * Convert from 8-byte inode numbers to 4-byte inode numbers.&n; * The last 8-byte inode number is gone, but the count is still 1.&n; */
r_static
r_void
DECL|function|xfs_dir2_sf_toino4
id|xfs_dir2_sf_toino4
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* old dir&squot;s buffer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|i
suffix:semicolon
multiline_comment|/* entry index */
id|xfs_ino_t
id|ino
suffix:semicolon
multiline_comment|/* entry inode number */
r_int
id|newsize
suffix:semicolon
multiline_comment|/* new inode size */
id|xfs_dir2_sf_entry_t
op_star
id|oldsfep
suffix:semicolon
multiline_comment|/* old sf entry */
id|xfs_dir2_sf_t
op_star
id|oldsfp
suffix:semicolon
multiline_comment|/* old sf directory */
r_int
id|oldsize
suffix:semicolon
multiline_comment|/* old inode size */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* new sf entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* new sf directory */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;sf_toino4&quot;
comma
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the old directory to the buffer.&n;&t; * Then nuke it from the inode, and add the new buffer to the inode.&n;&t; * Don&squot;t want xfs_idata_realloc copying the data here.&n;&t; */
id|oldsize
op_assign
id|dp-&gt;i_df.if_bytes
suffix:semicolon
id|buf
op_assign
id|kmem_alloc
c_func
(paren
id|oldsize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|oldsfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|oldsfp-&gt;hdr.i8count
op_eq
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|oldsfp
comma
id|oldsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the new inode size.&n;&t; */
id|newsize
op_assign
id|oldsize
op_minus
(paren
id|oldsfp-&gt;hdr.count
op_plus
l_int|1
)paren
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino8_t
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino4_t
)paren
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|oldsize
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|newsize
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset our pointers, the data has moved.&n;&t; */
id|oldsfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|buf
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the new header.&n;&t; */
id|sfp-&gt;hdr.count
op_assign
id|oldsfp-&gt;hdr.count
suffix:semicolon
id|sfp-&gt;hdr.i8count
op_assign
l_int|0
suffix:semicolon
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|oldsfp
comma
op_amp
id|oldsfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|ino
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the entries field by field.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
comma
id|oldsfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|oldsfp
)paren
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
comma
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
comma
id|oldsfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|oldsfp
comma
id|oldsfep
)paren
)paren
(brace
id|sfep-&gt;namelen
op_assign
id|oldsfep-&gt;namelen
suffix:semicolon
id|sfep-&gt;offset
op_assign
id|oldsfep-&gt;offset
suffix:semicolon
id|memcpy
c_func
(paren
id|sfep-&gt;name
comma
id|oldsfep-&gt;name
comma
id|sfep-&gt;namelen
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|oldsfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|oldsfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|ino
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clean up the inode.&n;&t; */
id|kmem_free
c_func
(paren
id|buf
comma
id|oldsize
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
id|newsize
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert from 4-byte inode numbers to 8-byte inode numbers.&n; * The new 8-byte inode number is not there yet, we leave with the&n; * count 1 but no corresponding entry.&n; */
r_static
r_void
DECL|function|xfs_dir2_sf_toino8
id|xfs_dir2_sf_toino8
c_func
(paren
id|xfs_da_args_t
op_star
id|args
)paren
multiline_comment|/* operation arguments */
(brace
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* old dir&squot;s buffer */
id|xfs_inode_t
op_star
id|dp
suffix:semicolon
multiline_comment|/* incore directory inode */
r_int
id|i
suffix:semicolon
multiline_comment|/* entry index */
id|xfs_ino_t
id|ino
suffix:semicolon
multiline_comment|/* entry inode number */
r_int
id|newsize
suffix:semicolon
multiline_comment|/* new inode size */
id|xfs_dir2_sf_entry_t
op_star
id|oldsfep
suffix:semicolon
multiline_comment|/* old sf entry */
id|xfs_dir2_sf_t
op_star
id|oldsfp
suffix:semicolon
multiline_comment|/* old sf directory */
r_int
id|oldsize
suffix:semicolon
multiline_comment|/* old inode size */
id|xfs_dir2_sf_entry_t
op_star
id|sfep
suffix:semicolon
multiline_comment|/* new sf entry */
id|xfs_dir2_sf_t
op_star
id|sfp
suffix:semicolon
multiline_comment|/* new sf directory */
id|xfs_dir2_trace_args
c_func
(paren
l_string|&quot;sf_toino8&quot;
comma
id|args
)paren
suffix:semicolon
id|dp
op_assign
id|args-&gt;dp
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the old directory to the buffer.&n;&t; * Then nuke it from the inode, and add the new buffer to the inode.&n;&t; * Don&squot;t want xfs_idata_realloc copying the data here.&n;&t; */
id|oldsize
op_assign
id|dp-&gt;i_df.if_bytes
suffix:semicolon
id|buf
op_assign
id|kmem_alloc
c_func
(paren
id|oldsize
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|oldsfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
id|ASSERT
c_func
(paren
id|oldsfp-&gt;hdr.i8count
op_eq
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|oldsfp
comma
id|oldsize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute the new inode size.&n;&t; */
id|newsize
op_assign
id|oldsize
op_plus
(paren
id|oldsfp-&gt;hdr.count
op_plus
l_int|1
)paren
op_star
(paren
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino8_t
)paren
op_minus
(paren
id|uint
)paren
r_sizeof
(paren
id|xfs_dir2_ino4_t
)paren
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
op_minus
id|oldsize
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
id|xfs_idata_realloc
c_func
(paren
id|dp
comma
id|newsize
comma
id|XFS_DATA_FORK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset our pointers, the data has moved.&n;&t; */
id|oldsfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|buf
suffix:semicolon
id|sfp
op_assign
(paren
id|xfs_dir2_sf_t
op_star
)paren
id|dp-&gt;i_df.if_u1.if_data
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the new header.&n;&t; */
id|sfp-&gt;hdr.count
op_assign
id|oldsfp-&gt;hdr.count
suffix:semicolon
id|sfp-&gt;hdr.i8count
op_assign
l_int|1
suffix:semicolon
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|oldsfp
comma
op_amp
id|oldsfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|ino
comma
op_amp
id|sfp-&gt;hdr.parent
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy the entries field by field.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|sfp
)paren
comma
id|oldsfep
op_assign
id|XFS_DIR2_SF_FIRSTENTRY
c_func
(paren
id|oldsfp
)paren
suffix:semicolon
id|i
OL
id|sfp-&gt;hdr.count
suffix:semicolon
id|i
op_increment
comma
id|sfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|sfp
comma
id|sfep
)paren
comma
id|oldsfep
op_assign
id|XFS_DIR2_SF_NEXTENTRY
c_func
(paren
id|oldsfp
comma
id|oldsfep
)paren
)paren
(brace
id|sfep-&gt;namelen
op_assign
id|oldsfep-&gt;namelen
suffix:semicolon
id|sfep-&gt;offset
op_assign
id|oldsfep-&gt;offset
suffix:semicolon
id|memcpy
c_func
(paren
id|sfep-&gt;name
comma
id|oldsfep-&gt;name
comma
id|sfep-&gt;namelen
)paren
suffix:semicolon
id|ino
op_assign
id|XFS_DIR2_SF_GET_INUMBER_ARCH
c_func
(paren
id|oldsfp
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|oldsfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|XFS_DIR2_SF_PUT_INUMBER_ARCH
c_func
(paren
id|sfp
comma
op_amp
id|ino
comma
id|XFS_DIR2_SF_INUMBERP
c_func
(paren
id|sfep
)paren
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clean up the inode.&n;&t; */
id|kmem_free
c_func
(paren
id|buf
comma
id|oldsize
)paren
suffix:semicolon
id|dp-&gt;i_d.di_size
op_assign
id|newsize
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|args-&gt;trans
comma
id|dp
comma
id|XFS_ILOG_CORE
op_or
id|XFS_ILOG_DDATA
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* XFS_BIG_FILESYSTEMS */
eof
