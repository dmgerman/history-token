multiline_comment|/*&n; * XFS filesystem operations.&n; *&n; * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode_item.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
macro_line|#include &quot;xfs_bmap.h&quot;
macro_line|#include &quot;xfs_da_btree.h&quot;
macro_line|#include &quot;xfs_rw.h&quot;
macro_line|#include &quot;xfs_refcache.h&quot;
macro_line|#include &quot;xfs_buf_item.h&quot;
macro_line|#include &quot;xfs_extfree_item.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_dir2_trace.h&quot;
macro_line|#include &quot;xfs_acl.h&quot;
macro_line|#include &quot;xfs_attr.h&quot;
macro_line|#include &quot;xfs_clnt.h&quot;
macro_line|#include &quot;xfs_log_priv.h&quot;
id|STATIC
r_int
id|xfs_sync
c_func
(paren
id|bhv_desc_t
op_star
comma
r_int
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
DECL|function|xfs_init
id|xfs_init
c_func
(paren
r_void
)paren
(brace
r_extern
id|kmem_zone_t
op_star
id|xfs_bmap_free_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_btree_cur_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_trans_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_buf_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_dabuf_zone
suffix:semicolon
macro_line|#ifdef XFS_DABUF_DEBUG
r_extern
id|lock_t
id|xfs_dabuf_global_lock
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|xfs_dabuf_global_lock
comma
l_string|&quot;xfsda&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize all of the zone allocators we use.&n;&t; */
id|xfs_bmap_free_item_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_bmap_free_item_t
)paren
comma
l_string|&quot;xfs_bmap_free_item&quot;
)paren
suffix:semicolon
id|xfs_btree_cur_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_btree_cur_t
)paren
comma
l_string|&quot;xfs_btree_cur&quot;
)paren
suffix:semicolon
id|xfs_inode_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_inode_t
)paren
comma
l_string|&quot;xfs_inode&quot;
)paren
suffix:semicolon
id|xfs_trans_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_trans_t
)paren
comma
l_string|&quot;xfs_trans&quot;
)paren
suffix:semicolon
id|xfs_da_state_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_da_state_t
)paren
comma
l_string|&quot;xfs_da_state&quot;
)paren
suffix:semicolon
id|xfs_dabuf_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_dabuf_t
)paren
comma
l_string|&quot;xfs_dabuf&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The size of the zone allocated buf log item is the maximum&n;&t; * size possible under XFS.  This wastes a little bit of memory,&n;&t; * but it is much faster.&n;&t; */
id|xfs_buf_item_zone
op_assign
id|kmem_zone_init
c_func
(paren
(paren
r_sizeof
(paren
id|xfs_buf_log_item_t
)paren
op_plus
(paren
(paren
(paren
id|XFS_MAX_BLOCKSIZE
op_div
id|XFS_BLI_CHUNK
)paren
op_div
id|NBWORD
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
)paren
comma
l_string|&quot;xfs_buf_item&quot;
)paren
suffix:semicolon
id|xfs_efd_zone
op_assign
id|kmem_zone_init
c_func
(paren
(paren
r_sizeof
(paren
id|xfs_efd_log_item_t
)paren
op_plus
(paren
(paren
id|XFS_EFD_MAX_FAST_EXTENTS
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
comma
l_string|&quot;xfs_efd_item&quot;
)paren
suffix:semicolon
id|xfs_efi_zone
op_assign
id|kmem_zone_init
c_func
(paren
(paren
r_sizeof
(paren
id|xfs_efi_log_item_t
)paren
op_plus
(paren
(paren
id|XFS_EFI_MAX_FAST_EXTENTS
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
comma
l_string|&quot;xfs_efi_item&quot;
)paren
suffix:semicolon
id|xfs_ifork_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_ifork_t
)paren
comma
l_string|&quot;xfs_ifork&quot;
)paren
suffix:semicolon
id|xfs_ili_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_inode_log_item_t
)paren
comma
l_string|&quot;xfs_ili&quot;
)paren
suffix:semicolon
id|xfs_chashlist_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_chashlist_t
)paren
comma
l_string|&quot;xfs_chashlist&quot;
)paren
suffix:semicolon
id|xfs_acl_zone_init
c_func
(paren
id|xfs_acl_zone
comma
l_string|&quot;xfs_acl&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate global trace buffers.&n;&t; */
macro_line|#ifdef XFS_ALLOC_TRACE
id|xfs_alloc_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_ALLOC_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMAP_TRACE
id|xfs_bmap_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_BMAP_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMBT_TRACE
id|xfs_bmbt_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_BMBT_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DIR_TRACE
id|xfs_dir_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_DIR_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_ATTR_TRACE
id|xfs_attr_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_ATTR_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DIR2_TRACE
id|xfs_dir2_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_DIR2_GTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
id|xfs_dir_startup
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (defined(DEBUG) || defined(INDUCE_IO_ERROR))
id|xfs_error_test_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* DEBUG || INDUCE_IO_ERROR */
id|xfs_init_procfs
c_func
(paren
)paren
suffix:semicolon
id|xfs_sysctl_register
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xfs_cleanup
id|xfs_cleanup
c_func
(paren
r_void
)paren
(brace
r_extern
id|kmem_zone_t
op_star
id|xfs_bmap_free_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_btree_cur_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_inode_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_trans_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_da_state_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_dabuf_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_efd_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_efi_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_buf_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_chashlist_zone
suffix:semicolon
id|xfs_cleanup_procfs
c_func
(paren
)paren
suffix:semicolon
id|xfs_sysctl_unregister
c_func
(paren
)paren
suffix:semicolon
id|xfs_refcache_destroy
c_func
(paren
)paren
suffix:semicolon
id|xfs_acl_zone_destroy
c_func
(paren
id|xfs_acl_zone
)paren
suffix:semicolon
macro_line|#ifdef XFS_DIR2_TRACE
id|ktrace_free
c_func
(paren
id|xfs_dir2_trace_buf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_ATTR_TRACE
id|ktrace_free
c_func
(paren
id|xfs_attr_trace_buf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DIR_TRACE
id|ktrace_free
c_func
(paren
id|xfs_dir_trace_buf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMBT_TRACE
id|ktrace_free
c_func
(paren
id|xfs_bmbt_trace_buf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMAP_TRACE
id|ktrace_free
c_func
(paren
id|xfs_bmap_trace_buf
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_ALLOC_TRACE
id|ktrace_free
c_func
(paren
id|xfs_alloc_trace_buf
)paren
suffix:semicolon
macro_line|#endif
id|kmem_cache_destroy
c_func
(paren
id|xfs_bmap_free_item_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_btree_cur_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_inode_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_trans_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_da_state_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_dabuf_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_buf_item_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_efd_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_efi_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_ifork_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_ili_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_chashlist_zone
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_start_flags&n; *&n; * This function fills in xfs_mount_t fields based on mount args.&n; * Note: the superblock has _not_ yet been read in.&n; */
id|STATIC
r_int
DECL|function|xfs_start_flags
id|xfs_start_flags
c_func
(paren
r_struct
id|vfs
op_star
id|vfs
comma
r_struct
id|xfs_mount_args
op_star
id|ap
comma
r_struct
id|xfs_mount
op_star
id|mp
)paren
(brace
multiline_comment|/* Values are in BBs */
r_if
c_cond
(paren
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOALIGN
)paren
op_ne
id|XFSMNT_NOALIGN
)paren
(brace
multiline_comment|/*&n;&t;&t; * At this point the superblock has not been read&n;&t;&t; * in, therefore we do not know the block size.&n;&t;&t; * Before the mount call ends we will convert&n;&t;&t; * these to FSBs.&n;&t;&t; */
id|mp-&gt;m_dalign
op_assign
id|ap-&gt;sunit
suffix:semicolon
id|mp-&gt;m_swidth
op_assign
id|ap-&gt;swidth
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;logbufs
op_ne
op_minus
l_int|1
op_logical_and
macro_line|#if defined(DEBUG) || defined(XLOG_NOLOG)
id|ap-&gt;logbufs
op_ne
l_int|0
op_logical_and
macro_line|#endif
(paren
id|ap-&gt;logbufs
template_param
id|XLOG_MAX_ICLOGS
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: invalid logbufs value: %d [not %d-%d]&quot;
comma
id|ap-&gt;logbufs
comma
id|XLOG_MIN_ICLOGS
comma
id|XLOG_MAX_ICLOGS
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_logbufs
op_assign
id|ap-&gt;logbufs
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;logbufsize
op_ne
op_minus
l_int|1
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|16
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|32
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|64
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|128
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|256
op_star
l_int|1024
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]&quot;
comma
id|ap-&gt;logbufsize
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_logbsize
op_assign
id|ap-&gt;logbufsize
suffix:semicolon
id|mp-&gt;m_fsname_len
op_assign
id|strlen
c_func
(paren
id|ap-&gt;fsname
)paren
op_plus
l_int|1
suffix:semicolon
id|mp-&gt;m_fsname
op_assign
id|kmem_alloc
c_func
(paren
id|mp-&gt;m_fsname_len
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|mp-&gt;m_fsname
comma
id|ap-&gt;fsname
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull in the &squot;wsync&squot; and &squot;ino64&squot; mount options before we do the real&n;&t; * work of mounting and recovery.  The arg pointer will&n;&t; * be NULL when we are being called from the root mount code.&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_WSYNC
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_WSYNC
suffix:semicolon
macro_line|#if XFS_BIG_INUMS
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_INO64
)paren
(brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_INO64
suffix:semicolon
id|mp-&gt;m_inoadd
op_assign
id|XFS_INO64_OFFSET
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOATIME
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOATIME
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_RETERR
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_RETERR
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOALIGN
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOALIGN
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_SWALLOC
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_SWALLOC
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_OSYNCISOSYNC
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_OSYNCISOSYNC
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_32BITINODES
)paren
id|mp-&gt;m_flags
op_or_assign
(paren
id|XFS_MOUNT_32BITINODES
op_or
id|XFS_MOUNT_32BITINOOPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_IOSIZE
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;iosizelog
OG
id|XFS_MAX_IO_LOG
op_logical_or
id|ap-&gt;iosizelog
OL
id|XFS_MIN_IO_LOG
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: invalid log iosize: %d [not %d-%d]&quot;
comma
id|ap-&gt;iosizelog
comma
id|XFS_MIN_IO_LOG
comma
id|XFS_MAX_IO_LOG
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_DFLT_IOSIZE
suffix:semicolon
id|mp-&gt;m_readio_log
op_assign
id|mp-&gt;m_writeio_log
op_assign
id|ap-&gt;iosizelog
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_IDELETE
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_IDELETE
suffix:semicolon
multiline_comment|/*&n;&t; * no recovery flag requires a read-only mount&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NORECOVERY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|vfs-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: tried to mount a FS read-write without recovery!&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NORECOVERY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOUUID
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOUUID
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOLOGFLUSH
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOLOGFLUSH
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function fills in xfs_mount_t fields based on mount args.&n; * Note: the superblock _has_ now been read in.&n; */
id|STATIC
r_int
DECL|function|xfs_finish_flags
id|xfs_finish_flags
c_func
(paren
r_struct
id|vfs
op_star
id|vfs
comma
r_struct
id|xfs_mount_args
op_star
id|ap
comma
r_struct
id|xfs_mount
op_star
id|mp
)paren
(brace
r_int
id|ronly
op_assign
(paren
id|vfs-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
suffix:semicolon
multiline_comment|/* Fail a mount where the logbuf is smaller then the log stripe */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ap-&gt;logbufsize
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|mp-&gt;m_sb.sb_logsunit
OG
id|XLOG_BIG_RECORD_BSIZE
)paren
)paren
(brace
id|mp-&gt;m_logbsize
op_assign
id|mp-&gt;m_sb.sb_logsunit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ap-&gt;logbufsize
OL
id|mp-&gt;m_sb.sb_logsunit
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: logbuf size must be greater than or equal to log stripe size&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Fail a mount if the logbuf is larger than 32K */
r_if
c_cond
(paren
id|ap-&gt;logbufsize
OG
id|XLOG_BIG_RECORD_BSIZE
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: logbuf size for version 1 logs must be 16K or 32K&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * prohibit r/w mounts of read-only filesystems&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;m_sb.sb_flags
op_amp
id|XFS_SBF_READONLY
)paren
op_logical_and
op_logical_neg
id|ronly
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: cannot mount a read-only filesystem as read-write&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * disallow mount attempts with (IRIX) project quota enabled&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
op_logical_and
(paren
id|mp-&gt;m_sb.sb_qflags
op_amp
id|XFS_PQUOTA_ACCT
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: cannot mount a filesystem with IRIX project quota enabled&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSYS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for shared mount.&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_SHARED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASSHARED
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For IRIX 6.5, shared mounts must have the shared&n;&t;&t; * version bit set, have the persistent readonly&n;&t;&t; * field set, must be version 0 and can only be mounted&n;&t;&t; * read-only.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ronly
op_logical_or
op_logical_neg
(paren
id|mp-&gt;m_sb.sb_flags
op_amp
id|XFS_SBF_READONLY
)paren
op_logical_or
(paren
id|mp-&gt;m_sb.sb_shared_vn
op_ne
l_int|0
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_SHARED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Shared XFS V0 can&squot;t deal with DMI.  Return EINVAL.&n;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_sb.sb_shared_vn
op_eq
l_int|0
op_logical_and
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_DMAPI
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mount&n; *&n; * The file system configurations are:&n; *&t;(1) device (partition) with data and internal log&n; *&t;(2) logical volume with data and log subvolumes.&n; *&t;(3) logical volume with data, log, and realtime subvolumes.&n; *&n; * We only have to handle opening the log and realtime volumes here if&n; * they are present.  The data subvolume has already been opened by&n; * get_sb_bdev() and is stored in vfsp-&gt;vfs_super-&gt;s_bdev.&n; */
id|STATIC
r_int
DECL|function|xfs_mount
id|xfs_mount
c_func
(paren
r_struct
id|bhv_desc
op_star
id|bhvp
comma
r_struct
id|xfs_mount_args
op_star
id|args
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_struct
id|vfs
op_star
id|vfsp
op_assign
id|bhvtovfs
c_func
(paren
id|bhvp
)paren
suffix:semicolon
r_struct
id|bhv_desc
op_star
id|p
suffix:semicolon
r_struct
id|xfs_mount
op_star
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bhvp
)paren
suffix:semicolon
r_struct
id|block_device
op_star
id|ddev
comma
op_star
id|logdev
comma
op_star
id|rtdev
suffix:semicolon
r_int
id|flags
op_assign
l_int|0
comma
id|error
suffix:semicolon
id|ddev
op_assign
id|vfsp-&gt;vfs_super-&gt;s_bdev
suffix:semicolon
id|logdev
op_assign
id|rtdev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Open real time and log devices - order is important.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;logname
(braket
l_int|0
)braket
)paren
(brace
id|error
op_assign
id|xfs_blkdev_get
c_func
(paren
id|mp
comma
id|args-&gt;logname
comma
op_amp
id|logdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args-&gt;rtname
(braket
l_int|0
)braket
)paren
(brace
id|error
op_assign
id|xfs_blkdev_get
c_func
(paren
id|mp
comma
id|args-&gt;rtname
comma
op_amp
id|rtdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_blkdev_put
c_func
(paren
id|logdev
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtdev
op_eq
id|ddev
op_logical_or
id|rtdev
op_eq
id|logdev
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: Cannot mount filesystem with identical rtdev and ddev/logdev.&quot;
)paren
suffix:semicolon
id|xfs_blkdev_put
c_func
(paren
id|logdev
)paren
suffix:semicolon
id|xfs_blkdev_put
c_func
(paren
id|rtdev
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Setup xfs_mount function vectors from available behaviors&n;&t; */
id|p
op_assign
id|vfs_bhv_lookup
c_func
(paren
id|vfsp
comma
id|VFS_POSITION_DM
)paren
suffix:semicolon
id|mp-&gt;m_dm_ops
op_assign
id|p
ques
c_cond
op_star
(paren
id|xfs_dmops_t
op_star
)paren
id|vfs_bhv_custom
c_func
(paren
id|p
)paren
suffix:colon
id|xfs_dmcore_stub
suffix:semicolon
id|p
op_assign
id|vfs_bhv_lookup
c_func
(paren
id|vfsp
comma
id|VFS_POSITION_QM
)paren
suffix:semicolon
id|mp-&gt;m_qm_ops
op_assign
id|p
ques
c_cond
op_star
(paren
id|xfs_qmops_t
op_star
)paren
id|vfs_bhv_custom
c_func
(paren
id|p
)paren
suffix:colon
id|xfs_qmcore_stub
suffix:semicolon
id|p
op_assign
id|vfs_bhv_lookup
c_func
(paren
id|vfsp
comma
id|VFS_POSITION_IO
)paren
suffix:semicolon
id|mp-&gt;m_io_ops
op_assign
id|p
ques
c_cond
op_star
(paren
id|xfs_ioops_t
op_star
)paren
id|vfs_bhv_custom
c_func
(paren
id|p
)paren
suffix:colon
id|xfs_iocore_xfs
suffix:semicolon
multiline_comment|/*&n;&t; * Setup xfs_mount buffer target pointers&n;&t; */
id|mp-&gt;m_ddev_targp
op_assign
id|xfs_alloc_buftarg
c_func
(paren
id|ddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtdev
)paren
id|mp-&gt;m_rtdev_targp
op_assign
id|xfs_alloc_buftarg
c_func
(paren
id|rtdev
)paren
suffix:semicolon
id|mp-&gt;m_logdev_targp
op_assign
(paren
id|logdev
op_logical_and
id|logdev
op_ne
id|ddev
)paren
ques
c_cond
id|xfs_alloc_buftarg
c_func
(paren
id|logdev
)paren
suffix:colon
id|mp-&gt;m_ddev_targp
suffix:semicolon
multiline_comment|/*&n;&t; * Setup flags based on mount(2) options and then the superblock&n;&t; */
id|error
op_assign
id|xfs_start_flags
c_func
(paren
id|vfsp
comma
id|args
comma
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error
suffix:semicolon
id|error
op_assign
id|xfs_readsb
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error
suffix:semicolon
id|error
op_assign
id|xfs_finish_flags
c_func
(paren
id|vfsp
comma
id|args
comma
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_freesb
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Setup xfs_mount buffer target pointers based on superblock&n;&t; */
id|xfs_setsize_buftarg
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
id|mp-&gt;m_sb.sb_blocksize
comma
id|mp-&gt;m_sb.sb_sectsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logdev
op_logical_and
id|logdev
op_ne
id|ddev
)paren
(brace
r_int
r_int
id|log_sector_size
op_assign
id|BBSIZE
suffix:semicolon
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASSECTOR
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
id|log_sector_size
op_assign
id|mp-&gt;m_sb.sb_logsectsize
suffix:semicolon
id|xfs_setsize_buftarg
c_func
(paren
id|mp-&gt;m_logdev_targp
comma
id|mp-&gt;m_sb.sb_blocksize
comma
id|log_sector_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtdev
)paren
id|xfs_setsize_buftarg
c_func
(paren
id|mp-&gt;m_rtdev_targp
comma
id|mp-&gt;m_sb.sb_blocksize
comma
id|mp-&gt;m_sb.sb_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|error
op_assign
id|XFS_IOINIT
c_func
(paren
id|vfsp
comma
id|args
comma
id|flags
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|xfs_binval
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logdev
op_ne
l_int|NULL
op_logical_and
id|logdev
op_ne
id|ddev
)paren
(brace
id|xfs_binval
c_func
(paren
id|mp-&gt;m_logdev_targp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtdev
op_ne
l_int|NULL
)paren
(brace
id|xfs_binval
c_func
(paren
id|mp-&gt;m_rtdev_targp
)paren
suffix:semicolon
)brace
id|xfs_unmountfs_close
c_func
(paren
id|mp
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_unmount
id|xfs_unmount
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|flags
comma
id|cred_t
op_star
id|credp
)paren
(brace
r_struct
id|vfs
op_star
id|vfsp
op_assign
id|bhvtovfs
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_inode_t
op_star
id|rip
suffix:semicolon
id|vnode_t
op_star
id|rvp
suffix:semicolon
r_int
id|unmount_event_wanted
op_assign
l_int|0
suffix:semicolon
r_int
id|unmount_event_flags
op_assign
l_int|0
suffix:semicolon
r_int
id|xfs_unmountfs_needed
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
id|rip
op_assign
id|mp-&gt;m_rootip
suffix:semicolon
id|rvp
op_assign
id|XFS_ITOV
c_func
(paren
id|rip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_DMI
)paren
(brace
id|error
op_assign
id|XFS_SEND_PREUNMOUNT
c_func
(paren
id|mp
comma
id|vfsp
comma
id|rvp
comma
id|DM_RIGHT_NULL
comma
id|rvp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
(paren
id|mp-&gt;m_dmevmask
op_amp
(paren
l_int|1
op_lshift
id|DM_EVENT_PREUNMOUNT
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|DM_FLAGS_UNWANTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
id|unmount_event_wanted
op_assign
l_int|1
suffix:semicolon
id|unmount_event_flags
op_assign
(paren
id|mp-&gt;m_dmevmask
op_amp
(paren
l_int|1
op_lshift
id|DM_EVENT_UNMOUNT
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|DM_FLAGS_UNWANTED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * First blow any referenced inode from this file system&n;&t; * out of the reference cache, and delete the timer.&n;&t; */
id|xfs_refcache_purge_mp
c_func
(paren
id|mp
)paren
suffix:semicolon
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_unmount_flush
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|ASSERT
c_func
(paren
id|vn_count
c_func
(paren
id|rvp
)paren
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Drop the reference count&n;&t; */
id|VN_RELE
c_func
(paren
id|rvp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re forcing a shutdown, typically because of a media error,&n;&t; * we want to make sure we invalidate dirty pages that belong to&n;&t; * referenced vnodes as well.&n;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|error
op_assign
id|xfs_sync
c_func
(paren
op_amp
id|mp-&gt;m_bhv
comma
(paren
id|SYNC_WAIT
op_or
id|SYNC_CLOSE
)paren
comma
id|credp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|xfs_unmountfs_needed
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&t;Send DMAPI event, if required.&n;&t; *&t;Then do xfs_unmountfs() if needed.&n;&t; *&t;Then return error (or zero).&n;&t; */
r_if
c_cond
(paren
id|unmount_event_wanted
)paren
(brace
multiline_comment|/* Note: mp structure must still exist for&n;&t;&t; * XFS_SEND_UNMOUNT() call.&n;&t;&t; */
id|XFS_SEND_UNMOUNT
c_func
(paren
id|mp
comma
id|vfsp
comma
id|error
op_eq
l_int|0
ques
c_cond
id|rvp
suffix:colon
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
l_int|0
comma
id|error
comma
id|unmount_event_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfs_unmountfs_needed
)paren
(brace
multiline_comment|/*&n;&t;&t; * Call common unmount function to flush to disk&n;&t;&t; * and free the super block buffer &amp; mount structures.&n;&t;&t; */
id|xfs_unmountfs
c_func
(paren
id|mp
comma
id|credp
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
DECL|macro|REMOUNT_READONLY_FLAGS
mdefine_line|#define REMOUNT_READONLY_FLAGS&t;(SYNC_REMOUNT|SYNC_ATTR|SYNC_WAIT)
id|STATIC
r_int
DECL|function|xfs_mntupdate
id|xfs_mntupdate
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
op_star
id|flags
comma
r_struct
id|xfs_mount_args
op_star
id|args
)paren
(brace
r_struct
id|vfs
op_star
id|vfsp
op_assign
id|bhvtovfs
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_int
id|pincount
comma
id|error
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|XFSMNT_NOATIME
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOATIME
suffix:semicolon
r_else
id|mp-&gt;m_flags
op_and_assign
op_complement
id|XFS_MOUNT_NOATIME
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
)paren
(brace
id|VFS_SYNC
c_func
(paren
id|vfsp
comma
id|SYNC_FSDATA
op_or
id|SYNC_BDFLUSH
op_or
id|SYNC_ATTR
comma
l_int|NULL
comma
id|error
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|flags
op_amp
id|MS_RDONLY
)paren
(brace
id|xfs_refcache_purge_mp
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_flush_buftarg
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
l_int|0
)paren
suffix:semicolon
id|xfs_finish_reclaim_all
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This loop must run at least twice.&n;&t;&t; * The first instance of the loop will flush&n;&t;&t; * most meta data but that will generate more&n;&t;&t; * meta data (typically directory updates).&n;&t;&t; * Which then must be flushed and logged before&n;&t;&t; * we can write the unmount record.&n;&t;&t; */
r_do
(brace
id|VFS_SYNC
c_func
(paren
id|vfsp
comma
id|REMOUNT_READONLY_FLAGS
comma
l_int|NULL
comma
id|error
)paren
suffix:semicolon
id|pincount
op_assign
id|xfs_flush_buftarg
c_func
(paren
id|mp-&gt;m_ddev_targp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pincount
)paren
(brace
id|delay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count
OL
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Ok now write out an unmount record */
id|xfs_log_unmount_write
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_unmountfs_writesb
c_func
(paren
id|mp
)paren
suffix:semicolon
id|vfsp-&gt;vfs_flag
op_or_assign
id|VFS_RDONLY
suffix:semicolon
)brace
r_else
(brace
id|vfsp-&gt;vfs_flag
op_and_assign
op_complement
id|VFS_RDONLY
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_unmount_flush implements a set of flush operation on special&n; * inodes, which are needed as a separate set of operations so that&n; * they can be called as part of relocation process.&n; */
r_int
DECL|function|xfs_unmount_flush
id|xfs_unmount_flush
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* Mount structure we are getting&n;&t;&t;&t;&t;&t;   rid of. */
r_int
id|relocation
)paren
multiline_comment|/* Called from vfs relocation. */
(brace
id|xfs_inode_t
op_star
id|rip
op_assign
id|mp-&gt;m_rootip
suffix:semicolon
id|xfs_inode_t
op_star
id|rbmip
suffix:semicolon
id|xfs_inode_t
op_star
id|rsumip
op_assign
l_int|NULL
suffix:semicolon
id|vnode_t
op_star
id|rvp
op_assign
id|XFS_ITOV
c_func
(paren
id|rip
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|rip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush out the real time inodes.&n;&t; */
r_if
c_cond
(paren
(paren
id|rbmip
op_assign
id|mp-&gt;m_rbmip
)paren
op_ne
l_int|NULL
)paren
(brace
id|xfs_ilock
c_func
(paren
id|rbmip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|rbmip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|rbmip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|rbmip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out
suffix:semicolon
id|ASSERT
c_func
(paren
id|vn_count
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rbmip
)paren
)paren
op_eq
l_int|1
)paren
suffix:semicolon
id|rsumip
op_assign
id|mp-&gt;m_rsumip
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|rsumip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|rsumip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|rsumip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|rsumip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out
suffix:semicolon
id|ASSERT
c_func
(paren
id|vn_count
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rsumip
)paren
)paren
op_eq
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Synchronously flush root inode to disk&n;&t; */
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|rip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out2
suffix:semicolon
r_if
c_cond
(paren
id|vn_count
c_func
(paren
id|rvp
)paren
op_ne
l_int|1
op_logical_and
op_logical_neg
id|relocation
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EBUSY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release dquot that rootinode, rbmino and rsumino might be holding,&n;&t; * flush and purge the quota inodes.&n;&t; */
id|error
op_assign
id|XFS_QM_UNMOUNT
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out2
suffix:semicolon
r_if
c_cond
(paren
id|rbmip
)paren
(brace
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rbmip
)paren
)paren
suffix:semicolon
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rsumip
)paren
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fscorrupt_out
suffix:colon
id|xfs_ifunlock
c_func
(paren
id|rip
)paren
suffix:semicolon
id|fscorrupt_out2
suffix:colon
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_root extracts the root vnode from a vfs.&n; *&n; * vfsp -- the vfs struct for the desired file system&n; * vpp  -- address of the caller&squot;s vnode pointer which should be&n; *         set to the desired fs root vnode&n; */
id|STATIC
r_int
DECL|function|xfs_root
id|xfs_root
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vnode_t
op_star
op_star
id|vpp
)paren
(brace
id|vnode_t
op_star
id|vp
suffix:semicolon
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
(paren
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
)paren
op_member_access_from_pointer
id|m_rootip
)paren
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|vp
)paren
suffix:semicolon
op_star
id|vpp
op_assign
id|vp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_statvfs&n; *&n; * Fill in the statvfs structure for the given file system.  We use&n; * the superblock lock in the mount structure to ensure a consistent&n; * snapshot of the counters returned.&n; */
id|STATIC
r_int
DECL|function|xfs_statvfs
id|xfs_statvfs
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|xfs_statfs_t
op_star
id|statp
comma
id|vnode_t
op_star
id|vp
)paren
(brace
id|__uint64_t
id|fakeinos
suffix:semicolon
id|xfs_extlen_t
id|lsize
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|u64
id|id
suffix:semicolon
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|sbp
op_assign
op_amp
(paren
id|mp-&gt;m_sb
)paren
suffix:semicolon
id|statp-&gt;f_type
op_assign
id|XFS_SB_MAGIC
suffix:semicolon
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|statp-&gt;f_bsize
op_assign
id|sbp-&gt;sb_blocksize
suffix:semicolon
id|lsize
op_assign
id|sbp-&gt;sb_logstart
ques
c_cond
id|sbp-&gt;sb_logblocks
suffix:colon
l_int|0
suffix:semicolon
id|statp-&gt;f_blocks
op_assign
id|sbp-&gt;sb_dblocks
op_minus
id|lsize
suffix:semicolon
id|statp-&gt;f_bfree
op_assign
id|statp-&gt;f_bavail
op_assign
id|sbp-&gt;sb_fdblocks
suffix:semicolon
id|fakeinos
op_assign
id|statp-&gt;f_bfree
op_lshift
id|sbp-&gt;sb_inopblog
suffix:semicolon
macro_line|#if XFS_BIG_INUMS
id|fakeinos
op_add_assign
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#endif
id|statp-&gt;f_files
op_assign
id|MIN
c_func
(paren
id|sbp-&gt;sb_icount
op_plus
id|fakeinos
comma
(paren
id|__uint64_t
)paren
id|XFS_MAXINUMBER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_maxicount
)paren
macro_line|#if XFS_BIG_INUMS
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;m_inoadd
)paren
macro_line|#endif
id|statp-&gt;f_files
op_assign
id|min_t
c_func
(paren
id|typeof
c_func
(paren
id|statp-&gt;f_files
)paren
comma
id|statp-&gt;f_files
comma
id|mp-&gt;m_maxicount
)paren
suffix:semicolon
id|statp-&gt;f_ffree
op_assign
id|statp-&gt;f_files
op_minus
(paren
id|sbp-&gt;sb_icount
op_minus
id|sbp-&gt;sb_ifree
)paren
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|id
op_assign
id|huge_encode_dev
c_func
(paren
id|mp-&gt;m_dev
)paren
suffix:semicolon
id|statp-&gt;f_fsid.val
(braket
l_int|0
)braket
op_assign
(paren
id|u32
)paren
id|id
suffix:semicolon
id|statp-&gt;f_fsid.val
(braket
l_int|1
)braket
op_assign
(paren
id|u32
)paren
(paren
id|id
op_rshift
l_int|32
)paren
suffix:semicolon
id|statp-&gt;f_namelen
op_assign
id|MAXNAMELEN
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_sync flushes any pending I/O to file system vfsp.&n; *&n; * This routine is called by vfs_sync() to make sure that things make it&n; * out to disk eventually, on sync() system calls to flush out everything,&n; * and when the file system is unmounted.  For the vfs_sync() case, all&n; * we really need to do is sync out the log to make all of our meta-data&n; * updates permanent (except for timestamps).  For calls from pflushd(),&n; * dirty pages are kept moving by calling pdflush() on the inodes&n; * containing them.  We also flush the inodes that we can lock without&n; * sleeping and the superblock if we can lock it without sleeping from&n; * vfs_sync() so that items at the tail of the log are always moving out.&n; *&n; * Flags:&n; *      SYNC_BDFLUSH - We&squot;re being called from vfs_sync() so we don&squot;t want&n; *&t;&t;       to sleep if we can help it.  All we really need&n; *&t;&t;       to do is ensure that the log is synced at least&n; *&t;&t;       periodically.  We also push the inodes and&n; *&t;&t;       superblock if we can lock them without sleeping&n; *&t;&t;&t;and they are not pinned.&n; *      SYNC_ATTR    - We need to flush the inodes.  If SYNC_BDFLUSH is not&n; *&t;&t;       set, then we really want to lock each inode and flush&n; *&t;&t;       it.&n; *      SYNC_WAIT    - All the flushes that take place in this call should&n; *&t;&t;       be synchronous.&n; *      SYNC_DELWRI  - This tells us to push dirty pages associated with&n; *&t;&t;       inodes.  SYNC_WAIT and SYNC_BDFLUSH are used to&n; *&t;&t;       determine if they should be flushed sync, async, or&n; *&t;&t;       delwri.&n; *      SYNC_CLOSE   - This flag is passed when the system is being&n; *&t;&t;       unmounted.  We should sync and invalidate everthing.&n; *      SYNC_FSDATA  - This indicates that the caller would like to make&n; *&t;&t;       sure the superblock is safe on disk.  We can ensure&n; *&t;&t;       this by simply makeing sure the log gets flushed&n; *&t;&t;       if SYNC_BDFLUSH is set, and by actually writing it&n; *&t;&t;       out otherwise.&n; *&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_int
DECL|function|xfs_sync
id|xfs_sync
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|flags
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
(paren
id|xfs_syncsub
c_func
(paren
id|mp
comma
id|flags
comma
l_int|0
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs sync routine for internal use&n; *&n; * This routine supports all of the flags defined for the generic VFS_SYNC&n; * interface as explained above under xfs_sync.  In the interests of not&n; * changing interfaces within the 6.5 family, additional internallly-&n; * required functions are specified within a separate xflags parameter,&n; * only available by calling this routine.&n; *&n; */
id|STATIC
r_int
DECL|function|xfs_sync_inodes
id|xfs_sync_inodes
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|flags
comma
r_int
id|xflags
comma
r_int
op_star
id|bypassed
)paren
(brace
id|xfs_inode_t
op_star
id|ip
op_assign
l_int|NULL
suffix:semicolon
id|xfs_inode_t
op_star
id|ip_next
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
l_int|NULL
suffix:semicolon
id|vmap_t
id|vmap
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|last_error
suffix:semicolon
r_uint64
id|fflag
suffix:semicolon
id|uint
id|lock_flags
suffix:semicolon
id|uint
id|base_lock_flags
suffix:semicolon
id|boolean_t
id|mount_locked
suffix:semicolon
id|boolean_t
id|vnode_refed
suffix:semicolon
r_int
id|preempt
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_iptr_t
op_star
id|ipointer
suffix:semicolon
macro_line|#ifdef DEBUG
id|boolean_t
id|ipointer_in
op_assign
id|B_FALSE
suffix:semicolon
DECL|macro|IPOINTER_SET
mdefine_line|#define IPOINTER_SET&t;ipointer_in = B_TRUE
DECL|macro|IPOINTER_CLR
mdefine_line|#define IPOINTER_CLR&t;ipointer_in = B_FALSE
macro_line|#else
mdefine_line|#define IPOINTER_SET
mdefine_line|#define IPOINTER_CLR
macro_line|#endif
multiline_comment|/* Insert a marker record into the inode list after inode ip. The list&n; * must be locked when this is called. After the call the list will no&n; * longer be locked.&n; */
DECL|macro|IPOINTER_INSERT
mdefine_line|#define IPOINTER_INSERT(ip, mp)&t;{ &bslash;&n;&t;&t;ASSERT(ipointer_in == B_FALSE); &bslash;&n;&t;&t;ipointer-&gt;ip_mnext = ip-&gt;i_mnext; &bslash;&n;&t;&t;ipointer-&gt;ip_mprev = ip; &bslash;&n;&t;&t;ip-&gt;i_mnext = (xfs_inode_t *)ipointer; &bslash;&n;&t;&t;ipointer-&gt;ip_mnext-&gt;i_mprev = (xfs_inode_t *)ipointer; &bslash;&n;&t;&t;preempt = 0; &bslash;&n;&t;&t;XFS_MOUNT_IUNLOCK(mp); &bslash;&n;&t;&t;mount_locked = B_FALSE; &bslash;&n;&t;&t;IPOINTER_SET; &bslash;&n;&t;}
multiline_comment|/* Remove the marker from the inode list. If the marker was the only item&n; * in the list then there are no remaining inodes and we should zero out&n; * the whole list. If we are the current head of the list then move the head&n; * past us.&n; */
DECL|macro|IPOINTER_REMOVE
mdefine_line|#define IPOINTER_REMOVE(ip, mp)&t;{ &bslash;&n;&t;&t;ASSERT(ipointer_in == B_TRUE); &bslash;&n;&t;&t;if (ipointer-&gt;ip_mnext != (xfs_inode_t *)ipointer) { &bslash;&n;&t;&t;&t;ip = ipointer-&gt;ip_mnext; &bslash;&n;&t;&t;&t;ip-&gt;i_mprev = ipointer-&gt;ip_mprev; &bslash;&n;&t;&t;&t;ipointer-&gt;ip_mprev-&gt;i_mnext = ip; &bslash;&n;&t;&t;&t;if (mp-&gt;m_inodes == (xfs_inode_t *)ipointer) { &bslash;&n;&t;&t;&t;&t;mp-&gt;m_inodes = ip; &bslash;&n;&t;&t;&t;} &bslash;&n;&t;&t;} else { &bslash;&n;&t;&t;&t;ASSERT(mp-&gt;m_inodes == (xfs_inode_t *)ipointer); &bslash;&n;&t;&t;&t;mp-&gt;m_inodes = NULL; &bslash;&n;&t;&t;&t;ip = NULL; &bslash;&n;&t;&t;} &bslash;&n;&t;&t;IPOINTER_CLR; &bslash;&n;&t;}
DECL|macro|XFS_PREEMPT_MASK
mdefine_line|#define XFS_PREEMPT_MASK&t;0x7f
r_if
c_cond
(paren
id|bypassed
)paren
op_star
id|bypassed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
op_member_access_from_pointer
id|vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|last_error
op_assign
l_int|0
suffix:semicolon
id|preempt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate a reference marker */
id|ipointer
op_assign
(paren
id|xfs_iptr_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xfs_iptr_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|fflag
op_assign
id|XFS_B_ASYNC
suffix:semicolon
multiline_comment|/* default is don&squot;t wait */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
id|fflag
op_assign
id|XFS_B_DELWRI
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
id|fflag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* synchronous overrides all */
id|base_lock_flags
op_assign
id|XFS_ILOCK_SHARED
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|SYNC_DELWRI
op_or
id|SYNC_CLOSE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need the I/O lock if we&squot;re going to call any of&n;&t;&t; * the flush/inval routines.&n;&t;&t; */
id|base_lock_flags
op_or_assign
id|XFS_IOLOCK_SHARED
suffix:semicolon
)brace
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ip
op_assign
id|mp-&gt;m_inodes
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|vnode_refed
op_assign
id|B_FALSE
suffix:semicolon
id|IPOINTER_CLR
suffix:semicolon
r_do
(brace
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|vnode_refed
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|lock_flags
op_assign
id|base_lock_flags
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There were no inodes in the list, just break out&n;&t;&t; * of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We found another sync thread marker - skip it&n;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_mount
op_eq
l_int|NULL
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the vnode is gone then this is being torn down,&n;&t;&t; * call reclaim if it is flushed, else let regular flush&n;&t;&t; * code deal with it later in the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|vp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Skip ones already in reclaim */
r_if
c_cond
(paren
id|ip-&gt;i_flags
op_amp
id|XFS_IRECLAIM
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
op_eq
l_int|0
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_eq
l_int|0
)paren
op_logical_and
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|xfs_finish_reclaim
c_func
(paren
id|ip
comma
l_int|1
comma
id|XFS_IFLUSH_DELWRI_ELSE_ASYNC
)paren
suffix:semicolon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|SYNC_CLOSE
)paren
)paren
(brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If this is just vfs_sync() or pflushd() calling&n;&t;&t; * then we can skip inodes for which it looks like&n;&t;&t; * there is nothing to do.  Since we don&squot;t have the&n;&t;&t; * inode locked this is racey, but these are periodic&n;&t;&t; * calls so it doesn&squot;t matter.  For the others we want&n;&t;&t; * to know for sure, so we at least try to lock them.&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|ip-&gt;i_itemp
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
op_logical_and
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Try to lock without sleeping.  We&squot;re out of order with&n;&t;&t; * the inode list lock here, so if we fail we need to drop&n;&t;&t; * the mount lock and try again.  If we&squot;re called from&n;&t;&t; * bdflush() here, then don&squot;t bother.&n;&t;&t; *&n;&t;&t; * The inode lock here actually coordinates with the&n;&t;&t; * almost spurious inode lock in xfs_ireclaim() to prevent&n;&t;&t; * the vnode we handle here without a reference from&n;&t;&t; * being freed while we reference it.  If we lock the inode&n;&t;&t; * while it&squot;s on the mount list here, then the spurious inode&n;&t;&t; * lock in xfs_ireclaim() after the inode is pulled from&n;&t;&t; * the mount list will sleep until we release it here.&n;&t;&t; * This keeps the vnode from being freed while we reference&n;&t;&t; * it.  It is also cheaper and simpler than actually doing&n;&t;&t; * a vn_get() for every inode we touch here.&n;&t;&t; */
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|lock_flags
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
op_logical_or
(paren
id|vp
op_eq
l_int|NULL
)paren
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We need to unlock the inode list lock in order&n;&t;&t;&t; * to lock the inode. Insert a marker record into&n;&t;&t;&t; * the inode list to remember our position, dropping&n;&t;&t;&t; * the lock is now done inside the IPOINTER_INSERT&n;&t;&t;&t; * macro.&n;&t;&t;&t; *&n;&t;&t;&t; * We also use the inode list lock to protect us&n;&t;&t;&t; * in taking a snapshot of the vnode version number&n;&t;&t;&t; * for use in calling vn_get().&n;&t;&t;&t; */
id|VMAP
c_func
(paren
id|vp
comma
id|vmap
)paren
suffix:semicolon
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|vp
op_assign
id|vn_get
c_func
(paren
id|vp
comma
op_amp
id|vmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The vnode was reclaimed once we let go&n;&t;&t;&t;&t; * of the inode list lock.  Skip to the&n;&t;&t;&t;&t; * next list entry. Remove the marker.&n;&t;&t;&t;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|vnode_refed
op_assign
id|B_FALSE
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|vp
op_eq
id|XFS_ITOV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
id|vnode_refed
op_assign
id|B_TRUE
suffix:semicolon
)brace
multiline_comment|/* From here on in the loop we may have a marker record&n;&t;&t; * in the inode list.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_CLOSE
)paren
op_logical_and
(paren
id|vp
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the shutdown case.  We just need to&n;&t;&t;&t; * flush and invalidate all the pages associated&n;&t;&t;&t; * with the inode.  Drop the inode lock since&n;&t;&t;&t; * we can&squot;t hold it across calls to the buffer&n;&t;&t;&t; * cache.&n;&t;&t;&t; *&n;&t;&t;&t; * We don&squot;t set the VREMAPPING bit in the vnode&n;&t;&t;&t; * here, because we don&squot;t hold the vnode lock&n;&t;&t;&t; * exclusively.  It doesn&squot;t really matter, though,&n;&t;&t;&t; * because we only come here when we&squot;re shutting&n;&t;&t;&t; * down anyway.&n;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|VOP_TOSS_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_REMAPF
)paren
suffix:semicolon
)brace
r_else
(brace
id|VOP_FLUSHINVAL_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_REMAPF
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_DELWRI
)paren
op_logical_and
(paren
id|vp
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|VN_DIRTY
c_func
(paren
id|vp
)paren
)paren
(brace
multiline_comment|/* We need to have dropped the lock here,&n;&t;&t;&t;&t; * so insert a marker if we have not already&n;&t;&t;&t;&t; * done so.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Drop the inode lock since we can&squot;t hold it&n;&t;&t;&t;&t; * across calls to the buffer cache.&n;&t;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|VOP_FLUSH_PAGES
c_func
(paren
id|vp
comma
(paren
id|xfs_off_t
)paren
l_int|0
comma
op_minus
l_int|1
comma
id|fflag
comma
id|FI_NONE
comma
id|error
)paren
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_ATTR
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_update_core
)paren
op_logical_or
(paren
(paren
id|ip-&gt;i_itemp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* Insert marker and drop lock if not already&n;&t;&t;&t;&t; * done.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * We don&squot;t want the periodic flushing of the&n;&t;&t;&t;&t; * inodes by vfs_sync() to interfere with&n;&t;&t;&t;&t; * I/O to the file, especially read I/O&n;&t;&t;&t;&t; * where it is only the access time stamp&n;&t;&t;&t;&t; * that is being flushed out.  To prevent&n;&t;&t;&t;&t; * long periods where we have both inode&n;&t;&t;&t;&t; * locks held shared here while reading the&n;&t;&t;&t;&t; * inode&squot;s buffer in from disk, we drop the&n;&t;&t;&t;&t; * inode lock while reading in the inode&n;&t;&t;&t;&t; * buffer.  We have to release the buffer&n;&t;&t;&t;&t; * and reacquire the inode lock so that they&n;&t;&t;&t;&t; * are acquired in the proper order (inode&n;&t;&t;&t;&t; * locks first).  The buffer will go at the&n;&t;&t;&t;&t; * end of the lru chain, though, so we can&n;&t;&t;&t;&t; * expect it to still be there when we go&n;&t;&t;&t;&t; * for it again in xfs_iflush().&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_eq
l_int|0
)paren
op_logical_and
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|bp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Bailing out, remove the&n;&t;&t;&t;&t;&t;&t; * marker and free it.&n;&t;&t;&t;&t;&t;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_SHARED
)paren
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Since we dropped the inode lock,&n;&t;&t;&t;&t;&t; * the inode may have been reclaimed.&n;&t;&t;&t;&t;&t; * Therefore, we reacquire the mount&n;&t;&t;&t;&t;&t; * lock and check to see if we were the&n;&t;&t;&t;&t;&t; * inode reclaimed. If this happened&n;&t;&t;&t;&t;&t; * then the ipointer marker will no&n;&t;&t;&t;&t;&t; * longer point back at us. In this&n;&t;&t;&t;&t;&t; * case, move ip along to the inode&n;&t;&t;&t;&t;&t; * after the marker, remove the marker&n;&t;&t;&t;&t;&t; * and continue.&n;&t;&t;&t;&t;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
id|ipointer-&gt;ip_mprev
)paren
(brace
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|vnode_refed
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_SHARED
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * We failed to reacquire&n;&t;&t;&t;&t;&t;&t; * the inode lock without&n;&t;&t;&t;&t;&t;&t; * sleeping, so just skip&n;&t;&t;&t;&t;&t;&t; * the inode for now.  We&n;&t;&t;&t;&t;&t;&t; * clear the ILOCK bit from&n;&t;&t;&t;&t;&t;&t; * the lock_flags so that we&n;&t;&t;&t;&t;&t;&t; * won&squot;t try to drop a lock&n;&t;&t;&t;&t;&t;&t; * we don&squot;t hold below.&n;&t;&t;&t;&t;&t;&t; */
id|lock_flags
op_and_assign
op_complement
id|XFS_ILOCK_SHARED
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip_next
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_eq
l_int|0
)paren
op_logical_and
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Since this is vfs_sync()&n;&t;&t;&t;&t;&t;&t; * calling we only flush the&n;&t;&t;&t;&t;&t;&t; * inode out if we can lock&n;&t;&t;&t;&t;&t;&t; * it without sleeping and&n;&t;&t;&t;&t;&t;&t; * it is not pinned.  Drop&n;&t;&t;&t;&t;&t;&t; * the mount lock here so&n;&t;&t;&t;&t;&t;&t; * that we don&squot;t hold it for&n;&t;&t;&t;&t;&t;&t; * too long. We already have&n;&t;&t;&t;&t;&t;&t; * a marker in the list here.&n;&t;&t;&t;&t;&t;&t; */
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_FALSE
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|XFS_IFLUSH_DELWRI
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip_next
comma
id|mp
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_ATTR
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_update_core
)paren
op_logical_or
(paren
(paren
id|ip-&gt;i_itemp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
(brace
id|xfs_iflock
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If we can&squot;t acquire the flush&n;&t;&t;&t;&t;&t; * lock, then the inode is already&n;&t;&t;&t;&t;&t; * being flushed so don&squot;t bother&n;&t;&t;&t;&t;&t; * waiting.  If we can lock it then&n;&t;&t;&t;&t;&t; * do a delwri flush so we can&n;&t;&t;&t;&t;&t; * combine multiple inode flushes&n;&t;&t;&t;&t;&t; * in each disk write.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|XFS_IFLUSH_DELWRI
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bypassed
)paren
(paren
op_star
id|bypassed
)paren
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|lock_flags
op_ne
l_int|0
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vnode_refed
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we had to take a reference on the vnode&n;&t;&t;&t; * above, then wait until after we&squot;ve unlocked&n;&t;&t;&t; * the inode to release the reference.  This is&n;&t;&t;&t; * because we can be already holding the inode&n;&t;&t;&t; * lock when VN_RELE() calls xfs_inactive().&n;&t;&t;&t; *&n;&t;&t;&t; * Make sure to drop the mount lock before calling&n;&t;&t;&t; * VN_RELE() so that we don&squot;t trip over ourselves if&n;&t;&t;&t; * we have to go for the mount lock again in the&n;&t;&t;&t; * inactive code.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
id|vnode_refed
op_assign
id|B_FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|last_error
op_assign
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bail out if the filesystem is corrupted.&n;&t;&t; */
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mount_locked
)paren
(brace
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* Let other threads have a chance at the mount lock&n;&t;&t; * if we have looped many times without dropping the&n;&t;&t; * lock.&n;&t;&t; */
r_if
c_cond
(paren
(paren
op_increment
id|preempt
op_amp
id|XFS_PREEMPT_MASK
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mount_locked
op_eq
id|B_FALSE
)paren
(brace
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ip
op_ne
id|mp-&gt;m_inodes
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|last_error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs sync routine for internal use&n; *&n; * This routine supports all of the flags defined for the generic VFS_SYNC&n; * interface as explained above under xfs_sync.  In the interests of not&n; * changing interfaces within the 6.5 family, additional internallly-&n; * required functions are specified within a separate xflags parameter,&n; * only available by calling this routine.&n; *&n; */
r_int
DECL|function|xfs_syncsub
id|xfs_syncsub
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|flags
comma
r_int
id|xflags
comma
r_int
op_star
id|bypassed
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|last_error
op_assign
l_int|0
suffix:semicolon
id|uint
id|log_flags
op_assign
id|XFS_LOG_FORCE
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
multiline_comment|/*&n;&t; * Sync out the log.  This ensures that the log is periodically&n;&t; * flushed even if there is not enough activity to fill it up.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
id|log_flags
op_or_assign
id|XFS_LOG_SYNC
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|log_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|SYNC_ATTR
op_or
id|SYNC_DELWRI
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
id|xfs_finish_reclaim_all
c_func
(paren
id|mp
comma
l_int|1
)paren
suffix:semicolon
r_else
id|error
op_assign
id|xfs_sync_inodes
c_func
(paren
id|mp
comma
id|flags
comma
id|xflags
comma
id|bypassed
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Flushing out dirty data above probably generated more&n;&t; * log activity, so if this isn&squot;t vfs_sync() then flush&n;&t; * the log again.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_DELWRI
)paren
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|log_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_FSDATA
)paren
(brace
multiline_comment|/*&n;&t;&t; * If this is vfs_sync() then only sync the superblock&n;&t;&t; * if we can lock it without sleeping and it is not pinned.&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
(brace
id|bp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
id|XFS_BUF_TRYLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bip
op_ne
l_int|NULL
)paren
op_logical_and
id|xfs_buf_item_dirty
c_func
(paren
id|bip
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|XFS_BUF_ASYNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|bp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the buffer is pinned then push on the log so&n;&t;&t;&t; * we won&squot;t get stuck waiting in the write for&n;&t;&t;&t; * someone, maybe ourselves, to flush the log.&n;&t;&t;&t; * Even though we just pushed the log above, we&n;&t;&t;&t; * did not have the superblock buffer locked at&n;&t;&t;&t; * that point so it can become pinned in between&n;&t;&t;&t; * there and here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
id|XFS_BUF_UNASYNC
c_func
(paren
id|bp
)paren
suffix:semicolon
r_else
id|XFS_BUF_ASYNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|last_error
op_assign
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If this is the periodic sync, then kick some entries out of&n;&t; * the reference cache.  This ensures that idle entries are&n;&t; * eventually kicked out of the cache.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_REFCACHE
)paren
(brace
id|xfs_refcache_purge_some
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now check to see if the log needs a &quot;dummy&quot; transaction.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|SYNC_REMOUNT
)paren
op_logical_and
id|xfs_log_need_covered
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put a dummy transaction in the log to tell&n;&t;&t; * recovery that all others are OK.&n;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_DUMMY1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ICHANGE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ip
op_assign
id|mp-&gt;m_rootip
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|log_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * When shutting down, we need to insure that the AIL is pushed&n;&t; * to disk or the filesystem can appear corrupt from the PROM.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SYNC_CLOSE
op_or
id|SYNC_WAIT
)paren
)paren
op_eq
(paren
id|SYNC_CLOSE
op_or
id|SYNC_WAIT
)paren
)paren
(brace
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rtdev_targp
)paren
(brace
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_rtdev_targp
)paren
suffix:semicolon
)brace
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|last_error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_vget - called by DMAPI to get vnode from file handle&n; */
id|STATIC
r_int
DECL|function|xfs_vget
id|xfs_vget
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vnode_t
op_star
op_star
id|vpp
comma
id|fid_t
op_star
id|fidp
)paren
(brace
id|xfs_fid_t
op_star
id|xfid
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_ino_t
id|ino
suffix:semicolon
r_int
r_int
id|igen
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfid
op_assign
(paren
r_struct
id|xfs_fid
op_star
)paren
id|fidp
suffix:semicolon
r_if
c_cond
(paren
id|xfid-&gt;xfs_fid_len
op_eq
r_sizeof
(paren
op_star
id|xfid
)paren
op_minus
r_sizeof
(paren
id|xfid-&gt;xfs_fid_len
)paren
)paren
(brace
id|ino
op_assign
id|xfid-&gt;xfs_fid_ino
suffix:semicolon
id|igen
op_assign
id|xfid-&gt;xfs_fid_gen
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Invalid.  Since handles can be created in user space&n;&t;&t; * and passed in via gethandle(), this is not cause for&n;&t;&t; * a panic.&n;&t;&t; */
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ino
comma
id|XFS_ILOCK_SHARED
comma
op_amp
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
op_star
id|vpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
op_star
id|vpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
op_logical_or
(paren
id|igen
op_logical_and
(paren
id|ip-&gt;i_d.di_gen
op_ne
id|igen
)paren
)paren
)paren
(brace
id|xfs_iput_new
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
op_star
id|vpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
op_star
id|vpp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|MNTOPT_LOGBUFS
mdefine_line|#define MNTOPT_LOGBUFS&t;&quot;logbufs&quot;&t;/* number of XFS log buffers */
DECL|macro|MNTOPT_LOGBSIZE
mdefine_line|#define MNTOPT_LOGBSIZE&t;&quot;logbsize&quot;&t;/* size of XFS log buffers */
DECL|macro|MNTOPT_LOGDEV
mdefine_line|#define MNTOPT_LOGDEV&t;&quot;logdev&quot;&t;/* log device */
DECL|macro|MNTOPT_RTDEV
mdefine_line|#define MNTOPT_RTDEV&t;&quot;rtdev&quot;&t;&t;/* realtime I/O device */
DECL|macro|MNTOPT_BIOSIZE
mdefine_line|#define MNTOPT_BIOSIZE&t;&quot;biosize&quot;&t;/* log2 of preferred buffered io size */
DECL|macro|MNTOPT_WSYNC
mdefine_line|#define MNTOPT_WSYNC&t;&quot;wsync&quot;&t;&t;/* safe-mode nfs compatible mount */
DECL|macro|MNTOPT_INO64
mdefine_line|#define MNTOPT_INO64&t;&quot;ino64&quot;&t;&t;/* force inodes into 64-bit range */
DECL|macro|MNTOPT_NOALIGN
mdefine_line|#define MNTOPT_NOALIGN&t;&quot;noalign&quot;&t;/* turn off stripe alignment */
DECL|macro|MNTOPT_SWALLOC
mdefine_line|#define MNTOPT_SWALLOC&t;&quot;swalloc&quot;&t;/* turn on stripe width allocation */
DECL|macro|MNTOPT_SUNIT
mdefine_line|#define MNTOPT_SUNIT&t;&quot;sunit&quot;&t;&t;/* data volume stripe unit */
DECL|macro|MNTOPT_SWIDTH
mdefine_line|#define MNTOPT_SWIDTH&t;&quot;swidth&quot;&t;/* data volume stripe width */
DECL|macro|MNTOPT_NOUUID
mdefine_line|#define MNTOPT_NOUUID&t;&quot;nouuid&quot;&t;/* ignore filesystem UUID */
DECL|macro|MNTOPT_MTPT
mdefine_line|#define MNTOPT_MTPT&t;&quot;mtpt&quot;&t;&t;/* filesystem mount point */
DECL|macro|MNTOPT_NORECOVERY
mdefine_line|#define MNTOPT_NORECOVERY   &quot;norecovery&quot;   /* don&squot;t run XFS recovery */
DECL|macro|MNTOPT_NOLOGFLUSH
mdefine_line|#define MNTOPT_NOLOGFLUSH   &quot;nologflush&quot;   /* don&squot;t hard flush on log writes */
DECL|macro|MNTOPT_OSYNCISOSYNC
mdefine_line|#define MNTOPT_OSYNCISOSYNC &quot;osyncisosync&quot; /* o_sync is REALLY o_sync */
DECL|macro|MNTOPT_64BITINODE
mdefine_line|#define MNTOPT_64BITINODE   &quot;inode64&quot;&t;/* inodes can be allocated anywhere */
DECL|macro|MNTOPT_IKEEP
mdefine_line|#define MNTOPT_IKEEP&t;&quot;ikeep&quot;&t;&t;/* do not free empty inode clusters */
DECL|macro|MNTOPT_NOIKEEP
mdefine_line|#define MNTOPT_NOIKEEP&t;&quot;noikeep&quot;&t;/* free empty inode clusters */
r_int
DECL|function|xfs_parseargs
id|xfs_parseargs
c_func
(paren
r_struct
id|bhv_desc
op_star
id|bhv
comma
r_char
op_star
id|options
comma
r_struct
id|xfs_mount_args
op_star
id|args
comma
r_int
id|update
)paren
(brace
r_struct
id|vfs
op_star
id|vfsp
op_assign
id|bhvtovfs
c_func
(paren
id|bhv
)paren
suffix:semicolon
r_char
op_star
id|this_char
comma
op_star
id|value
comma
op_star
id|eov
suffix:semicolon
r_int
id|dsunit
comma
id|dswidth
comma
id|vol_dsunit
comma
id|vol_dswidth
suffix:semicolon
r_int
id|iosize
suffix:semicolon
macro_line|#if 0&t;/* XXX: off by default, until some remaining issues ironed out */
id|args-&gt;flags
op_or_assign
id|XFSMNT_IDELETE
suffix:semicolon
multiline_comment|/* default to on */
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|options
)paren
r_return
l_int|0
suffix:semicolon
id|iosize
op_assign
id|dsunit
op_assign
id|dswidth
op_assign
id|vol_dsunit
op_assign
id|vol_dswidth
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|this_char
op_assign
id|strsep
c_func
(paren
op_amp
id|options
comma
l_string|&quot;,&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|this_char
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|value
op_assign
id|strchr
c_func
(paren
id|this_char
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|value
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_LOGBUFS
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_LOGBUFS
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|args-&gt;logbufs
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|eov
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_LOGBSIZE
)paren
)paren
(brace
r_int
id|last
comma
id|in_kilobytes
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_LOGBSIZE
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|last
op_assign
id|strlen
c_func
(paren
id|value
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|value
(braket
id|last
)braket
op_eq
l_char|&squot;K&squot;
op_logical_or
id|value
(braket
id|last
)braket
op_eq
l_char|&squot;k&squot;
)paren
(brace
id|in_kilobytes
op_assign
l_int|1
suffix:semicolon
id|value
(braket
id|last
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|args-&gt;logbufsize
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|eov
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_kilobytes
)paren
id|args-&gt;logbufsize
op_lshift_assign
l_int|10
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_LOGDEV
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_LOGDEV
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|args-&gt;logname
comma
id|value
comma
id|MAXNAMELEN
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_MTPT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_MTPT
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|args-&gt;mtpt
comma
id|value
comma
id|MAXNAMELEN
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_RTDEV
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_RTDEV
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|args-&gt;rtname
comma
id|value
comma
id|MAXNAMELEN
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_BIOSIZE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_BIOSIZE
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|iosize
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|eov
comma
l_int|10
)paren
suffix:semicolon
id|args-&gt;flags
op_or_assign
id|XFSMNT_IOSIZE
suffix:semicolon
id|args-&gt;iosizelog
op_assign
(paren
r_uint8
)paren
id|iosize
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_WSYNC
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_WSYNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_OSYNCISOSYNC
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_OSYNCISOSYNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_NORECOVERY
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_NORECOVERY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_INO64
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_INO64
suffix:semicolon
macro_line|#if !XFS_BIG_INUMS
id|printk
c_func
(paren
l_string|&quot;XFS: %s option not allowed on this system&bslash;n&quot;
comma
id|MNTOPT_INO64
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_NOALIGN
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_NOALIGN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_SWALLOC
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_SWALLOC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_SUNIT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_SUNIT
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|dsunit
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|eov
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_SWIDTH
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_or
op_logical_neg
op_star
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: %s option requires an argument&bslash;n&quot;
comma
id|MNTOPT_SWIDTH
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|dswidth
op_assign
id|simple_strtoul
c_func
(paren
id|value
comma
op_amp
id|eov
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_64BITINODE
)paren
)paren
(brace
id|args-&gt;flags
op_and_assign
op_complement
id|XFSMNT_32BITINODES
suffix:semicolon
macro_line|#if !XFS_BIG_INUMS
id|printk
c_func
(paren
l_string|&quot;XFS: %s option not allowed on this system&bslash;n&quot;
comma
id|MNTOPT_64BITINODE
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_NOUUID
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_NOUUID
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_NOLOGFLUSH
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_NOLOGFLUSH
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_IKEEP
)paren
)paren
(brace
id|args-&gt;flags
op_and_assign
op_complement
id|XFSMNT_IDELETE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
id|MNTOPT_NOIKEEP
)paren
)paren
(brace
id|args-&gt;flags
op_or_assign
id|XFSMNT_IDELETE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;osyncisdsync&quot;
)paren
)paren
(brace
multiline_comment|/* no-op, this is now the default */
id|printk
c_func
(paren
l_string|&quot;XFS: osyncisdsync is now the default, option is deprecated.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|this_char
comma
l_string|&quot;irixsgid&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: irixsgid is now a sysctl(2) variable, option is deprecated.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: unknown mount option [%s].&bslash;n&quot;
comma
id|this_char
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|args-&gt;flags
op_amp
id|XFSMNT_NORECOVERY
)paren
(brace
r_if
c_cond
(paren
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: no-recovery mounts must be read-only.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|args-&gt;flags
op_amp
id|XFSMNT_NOALIGN
)paren
op_logical_and
(paren
id|dsunit
op_logical_or
id|dswidth
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: sunit and swidth options incompatible with the noalign option&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dsunit
op_logical_and
op_logical_neg
id|dswidth
)paren
op_logical_or
(paren
op_logical_neg
id|dsunit
op_logical_and
id|dswidth
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: sunit and swidth must be specified together&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dsunit
op_logical_and
(paren
id|dswidth
op_mod
id|dsunit
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;XFS: stripe width (%d) must be a multiple of the stripe unit (%d)&bslash;n&quot;
comma
id|dswidth
comma
id|dsunit
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|args-&gt;flags
op_amp
id|XFSMNT_NOALIGN
)paren
op_ne
id|XFSMNT_NOALIGN
)paren
(brace
r_if
c_cond
(paren
id|dsunit
)paren
(brace
id|args-&gt;sunit
op_assign
id|dsunit
suffix:semicolon
id|args-&gt;flags
op_or_assign
id|XFSMNT_RETERR
suffix:semicolon
)brace
r_else
(brace
id|args-&gt;sunit
op_assign
id|vol_dsunit
suffix:semicolon
)brace
id|dswidth
ques
c_cond
(paren
id|args-&gt;swidth
op_assign
id|dswidth
)paren
suffix:colon
(paren
id|args-&gt;swidth
op_assign
id|vol_dswidth
)paren
suffix:semicolon
)brace
r_else
(brace
id|args-&gt;sunit
op_assign
id|args-&gt;swidth
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|xfs_showargs
id|xfs_showargs
c_func
(paren
r_struct
id|bhv_desc
op_star
id|bhv
comma
r_struct
id|seq_file
op_star
id|m
)paren
(brace
r_static
r_struct
id|proc_xfs_info
(brace
r_int
id|flag
suffix:semicolon
r_char
op_star
id|str
suffix:semicolon
)brace
id|xfs_info
(braket
)braket
op_assign
(brace
multiline_comment|/* the few simple ones we can get from the mount struct */
(brace
id|XFS_MOUNT_WSYNC
comma
l_string|&quot;,&quot;
id|MNTOPT_WSYNC
)brace
comma
(brace
id|XFS_MOUNT_INO64
comma
l_string|&quot;,&quot;
id|MNTOPT_INO64
)brace
comma
(brace
id|XFS_MOUNT_NOALIGN
comma
l_string|&quot;,&quot;
id|MNTOPT_NOALIGN
)brace
comma
(brace
id|XFS_MOUNT_SWALLOC
comma
l_string|&quot;,&quot;
id|MNTOPT_SWALLOC
)brace
comma
(brace
id|XFS_MOUNT_NOUUID
comma
l_string|&quot;,&quot;
id|MNTOPT_NOUUID
)brace
comma
(brace
id|XFS_MOUNT_NORECOVERY
comma
l_string|&quot;,&quot;
id|MNTOPT_NORECOVERY
)brace
comma
(brace
id|XFS_MOUNT_OSYNCISOSYNC
comma
l_string|&quot;,&quot;
id|MNTOPT_OSYNCISOSYNC
)brace
comma
(brace
id|XFS_MOUNT_NOLOGFLUSH
comma
l_string|&quot;,&quot;
id|MNTOPT_NOLOGFLUSH
)brace
comma
(brace
id|XFS_MOUNT_IDELETE
comma
l_string|&quot;,&quot;
id|MNTOPT_NOIKEEP
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
)brace
suffix:semicolon
r_struct
id|proc_xfs_info
op_star
id|xfs_infop
suffix:semicolon
r_struct
id|xfs_mount
op_star
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bhv
)paren
suffix:semicolon
r_for
c_loop
(paren
id|xfs_infop
op_assign
id|xfs_info
suffix:semicolon
id|xfs_infop-&gt;flag
suffix:semicolon
id|xfs_infop
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|xfs_infop-&gt;flag
)paren
id|seq_puts
c_func
(paren
id|m
comma
id|xfs_infop-&gt;str
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_DFLT_IOSIZE
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_BIOSIZE
l_string|&quot;=%d&quot;
comma
id|mp-&gt;m_writeio_log
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_logbufs
OG
l_int|0
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_LOGBUFS
l_string|&quot;=%d&quot;
comma
id|mp-&gt;m_logbufs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_logbsize
OG
l_int|0
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_LOGBSIZE
l_string|&quot;=%d&quot;
comma
id|mp-&gt;m_logbsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_ddev_targp
op_ne
id|mp-&gt;m_logdev_targp
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_LOGDEV
l_string|&quot;=%s&quot;
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|mp-&gt;m_logdev_targp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rtdev_targp
op_logical_and
id|mp-&gt;m_ddev_targp
op_ne
id|mp-&gt;m_rtdev_targp
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_RTDEV
l_string|&quot;=%s&quot;
comma
id|XFS_BUFTARG_NAME
c_func
(paren
id|mp-&gt;m_rtdev_targp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_dalign
OG
l_int|0
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_SUNIT
l_string|&quot;=%d&quot;
comma
(paren
r_int
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_dalign
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_swidth
OG
l_int|0
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_SWIDTH
l_string|&quot;=%d&quot;
comma
(paren
r_int
)paren
id|XFS_FSB_TO_BB
c_func
(paren
id|mp
comma
id|mp-&gt;m_swidth
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_32BITINOOPT
)paren
)paren
id|seq_printf
c_func
(paren
id|m
comma
l_string|&quot;,&quot;
id|MNTOPT_64BITINODE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_freeze
id|xfs_freeze
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|mp-&gt;m_active_trans
)paren
OG
l_int|0
)paren
id|delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Push the superblock and write an unmount record */
id|xfs_log_unmount_write
c_func
(paren
id|mp
)paren
suffix:semicolon
id|xfs_unmountfs_writesb
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
DECL|variable|xfs_vfsops
id|vfsops_t
id|xfs_vfsops
op_assign
(brace
id|BHV_IDENTITY_INIT
c_func
(paren
id|VFS_BHV_XFS
comma
id|VFS_POSITION_XFS
)paren
comma
dot
id|vfs_parseargs
op_assign
id|xfs_parseargs
comma
dot
id|vfs_showargs
op_assign
id|xfs_showargs
comma
dot
id|vfs_mount
op_assign
id|xfs_mount
comma
dot
id|vfs_unmount
op_assign
id|xfs_unmount
comma
dot
id|vfs_mntupdate
op_assign
id|xfs_mntupdate
comma
dot
id|vfs_root
op_assign
id|xfs_root
comma
dot
id|vfs_statvfs
op_assign
id|xfs_statvfs
comma
dot
id|vfs_sync
op_assign
id|xfs_sync
comma
dot
id|vfs_vget
op_assign
id|xfs_vget
comma
dot
id|vfs_dmapiops
op_assign
(paren
id|vfs_dmapiops_t
)paren
id|fs_nosys
comma
dot
id|vfs_quotactl
op_assign
(paren
id|vfs_quotactl_t
)paren
id|fs_nosys
comma
dot
id|vfs_init_vnode
op_assign
id|xfs_initialize_vnode
comma
dot
id|vfs_force_shutdown
op_assign
id|xfs_do_force_shutdown
comma
dot
id|vfs_freeze
op_assign
id|xfs_freeze
comma
)brace
suffix:semicolon
eof
