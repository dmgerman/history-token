multiline_comment|/*&n; * XFS filesystem operations.&n; *&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &lt;xfs.h&gt;
id|STATIC
r_int
id|xfs_ibusy
c_func
(paren
id|xfs_mount_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_sync
c_func
(paren
id|bhv_desc_t
op_star
comma
r_int
comma
id|cred_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_unmount
c_func
(paren
id|bhv_desc_t
op_star
comma
r_int
comma
id|cred_t
op_star
)paren
suffix:semicolon
r_int
DECL|function|xfs_init
id|xfs_init
c_func
(paren
r_void
)paren
(brace
r_extern
id|kmem_zone_t
op_star
id|xfs_da_state_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_bmap_free_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_btree_cur_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_inode_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_chashlist_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_trans_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_buf_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_efd_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_efi_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_dabuf_zone
suffix:semicolon
r_extern
id|mutex_t
id|xfs_uuidtabmon
suffix:semicolon
macro_line|#ifdef DEBUG_NOT
r_extern
id|ktrace_t
op_star
id|xfs_alloc_trace_buf
suffix:semicolon
r_extern
id|ktrace_t
op_star
id|xfs_bmap_trace_buf
suffix:semicolon
r_extern
id|ktrace_t
op_star
id|xfs_bmbt_trace_buf
suffix:semicolon
r_extern
id|ktrace_t
op_star
id|xfs_dir_trace_buf
suffix:semicolon
r_extern
id|ktrace_t
op_star
id|xfs_attr_trace_buf
suffix:semicolon
r_extern
id|ktrace_t
op_star
id|xfs_dir2_trace_buf
suffix:semicolon
macro_line|#endif&t;/* DEBUG */
macro_line|#ifdef XFS_DABUF_DEBUG
r_extern
id|lock_t
id|xfs_dabuf_global_lock
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DABUF_DEBUG
id|spinlock_init
c_func
(paren
op_amp
id|xfs_dabuf_global_lock
comma
l_string|&quot;xfsda&quot;
)paren
suffix:semicolon
macro_line|#endif
id|mutex_init
c_func
(paren
op_amp
id|xfs_uuidtabmon
comma
id|MUTEX_DEFAULT
comma
l_string|&quot;xfs_uuidtab&quot;
)paren
suffix:semicolon
id|mutex_init
c_func
(paren
op_amp
id|xfs_Gqm_lock
comma
id|MUTEX_DEFAULT
comma
l_string|&quot;xfs_qmlock&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize all of the zone allocators we use.&n;&t; */
id|xfs_bmap_free_item_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_bmap_free_item_t
)paren
comma
l_string|&quot;xfs_bmap_free_item&quot;
)paren
suffix:semicolon
id|xfs_btree_cur_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_btree_cur_t
)paren
comma
l_string|&quot;xfs_btree_cur&quot;
)paren
suffix:semicolon
id|xfs_inode_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_inode_t
)paren
comma
l_string|&quot;xfs_inode&quot;
)paren
suffix:semicolon
id|xfs_trans_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_trans_t
)paren
comma
l_string|&quot;xfs_trans&quot;
)paren
suffix:semicolon
id|xfs_da_state_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_da_state_t
)paren
comma
l_string|&quot;xfs_da_state&quot;
)paren
suffix:semicolon
id|xfs_dabuf_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_dabuf_t
)paren
comma
l_string|&quot;xfs_dabuf&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The size of the zone allocated buf log item is the maximum&n;&t; * size possible under XFS.  This wastes a little bit of memory,&n;&t; * but it is much faster.&n;&t; */
id|xfs_buf_item_zone
op_assign
id|kmem_zone_init
c_func
(paren
(paren
r_sizeof
(paren
id|xfs_buf_log_item_t
)paren
op_plus
(paren
(paren
(paren
id|XFS_MAX_BLOCKSIZE
op_div
id|XFS_BLI_CHUNK
)paren
op_div
id|NBWORD
)paren
op_star
r_sizeof
(paren
r_int
)paren
)paren
)paren
comma
l_string|&quot;xfs_buf_item&quot;
)paren
suffix:semicolon
id|xfs_efd_zone
op_assign
id|kmem_zone_init
c_func
(paren
(paren
r_sizeof
(paren
id|xfs_efd_log_item_t
)paren
op_plus
(paren
(paren
id|XFS_EFD_MAX_FAST_EXTENTS
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
comma
l_string|&quot;xfs_efd_item&quot;
)paren
suffix:semicolon
id|xfs_efi_zone
op_assign
id|kmem_zone_init
c_func
(paren
(paren
r_sizeof
(paren
id|xfs_efi_log_item_t
)paren
op_plus
(paren
(paren
id|XFS_EFI_MAX_FAST_EXTENTS
op_minus
l_int|1
)paren
op_star
r_sizeof
(paren
id|xfs_extent_t
)paren
)paren
)paren
comma
l_string|&quot;xfs_efi_item&quot;
)paren
suffix:semicolon
id|xfs_ifork_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_ifork_t
)paren
comma
l_string|&quot;xfs_ifork&quot;
)paren
suffix:semicolon
id|xfs_ili_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_inode_log_item_t
)paren
comma
l_string|&quot;xfs_ili&quot;
)paren
suffix:semicolon
id|xfs_chashlist_zone
op_assign
id|kmem_zone_init
c_func
(paren
r_sizeof
(paren
id|xfs_chashlist_t
)paren
comma
l_string|&quot;xfs_chashlist&quot;
)paren
suffix:semicolon
id|_ACL_ZONE_INIT
c_func
(paren
id|xfs_acl_zone
comma
l_string|&quot;xfs_acl&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_XFS_VNODE_TRACING
id|ktrace_init
c_func
(paren
id|VNODE_TRACE_SIZE
)paren
suffix:semicolon
macro_line|#else
macro_line|#ifdef DEBUG
id|ktrace_init
c_func
(paren
l_int|64
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n;&t; * Allocate global trace buffers.&n;&t; */
macro_line|#ifdef XFS_ALLOC_TRACE
id|xfs_alloc_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_ALLOC_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMAP_TRACE
id|xfs_bmap_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_BMAP_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_BMBT_TRACE
id|xfs_bmbt_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_BMBT_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DIR_TRACE
id|xfs_dir_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_DIR_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_ATTR_TRACE
id|xfs_attr_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_ATTR_TRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XFS_DIR2_TRACE
id|xfs_dir2_trace_buf
op_assign
id|ktrace_alloc
c_func
(paren
id|XFS_DIR2_GTRACE_SIZE
comma
id|KM_SLEEP
)paren
suffix:semicolon
macro_line|#endif
id|xfs_dir_startup
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (defined(DEBUG) || defined(INDUCE_IO_ERROR))
id|xfs_error_test_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif /* DEBUG || INDUCE_IO_ERROR */
id|xfs_init_procfs
c_func
(paren
)paren
suffix:semicolon
id|xfs_sysctl_register
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|xfs_cleanup
id|xfs_cleanup
c_func
(paren
r_void
)paren
(brace
r_extern
id|kmem_zone_t
op_star
id|xfs_bmap_free_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_btree_cur_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_inode_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_trans_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_da_state_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_dabuf_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_efd_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_efi_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_buf_item_zone
suffix:semicolon
r_extern
id|kmem_zone_t
op_star
id|xfs_chashlist_zone
suffix:semicolon
id|xfs_cleanup_procfs
c_func
(paren
)paren
suffix:semicolon
id|xfs_sysctl_unregister
c_func
(paren
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_bmap_free_item_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_btree_cur_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_inode_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_trans_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_da_state_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_dabuf_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_buf_item_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_efd_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_efi_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_ifork_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_ili_zone
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|xfs_chashlist_zone
)paren
suffix:semicolon
id|_XQM_ZONE_DESTROY
c_func
(paren
id|qm_dqzone
)paren
suffix:semicolon
id|_XQM_ZONE_DESTROY
c_func
(paren
id|qm_dqtrxzone
)paren
suffix:semicolon
id|_ACL_ZONE_DESTROY
c_func
(paren
id|xfs_acl_zone
)paren
suffix:semicolon
macro_line|#if  (defined(DEBUG) || defined(CONFIG_XFS_VNODE_TRACING))
id|ktrace_uninit
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * xfs_start_flags&n; * &n; * This function fills in xfs_mount_t fields based on mount args.&n; * Note: the superblock has _not_ yet been read in.&n; */
id|STATIC
r_int
DECL|function|xfs_start_flags
id|xfs_start_flags
c_func
(paren
r_struct
id|xfs_mount_args
op_star
id|ap
comma
r_struct
id|xfs_mount
op_star
id|mp
comma
r_int
id|ronly
)paren
(brace
multiline_comment|/* Values are in BBs */
r_if
c_cond
(paren
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOALIGN
)paren
op_ne
id|XFSMNT_NOALIGN
)paren
(brace
multiline_comment|/*&n;&t;&t; * At this point the superblock has not been read&n;&t;&t; * in, therefore we do not know the block size.&n;&t;&t; * Before, the mount call ends we will convert&n;&t;&t; * these to FSBs.&n;&t;&t; */
id|mp-&gt;m_dalign
op_assign
id|ap-&gt;sunit
suffix:semicolon
id|mp-&gt;m_swidth
op_assign
id|ap-&gt;swidth
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;logbufs
op_ne
l_int|0
op_logical_and
id|ap-&gt;logbufs
op_ne
op_minus
l_int|1
op_logical_and
(paren
id|ap-&gt;logbufs
template_param
id|XLOG_MAX_ICLOGS
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: invalid logbufs value: %d [not %d-%d]&quot;
comma
id|ap-&gt;logbufs
comma
id|XLOG_NUM_ICLOGS
comma
id|XLOG_MAX_ICLOGS
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_logbufs
op_assign
id|ap-&gt;logbufs
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;logbufsize
op_ne
op_minus
l_int|1
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|16
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|32
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|64
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|128
op_star
l_int|1024
op_logical_and
id|ap-&gt;logbufsize
op_ne
l_int|256
op_star
l_int|1024
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]&quot;
comma
id|ap-&gt;logbufsize
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_logbsize
op_assign
id|ap-&gt;logbufsize
suffix:semicolon
id|mp-&gt;m_fsname_len
op_assign
id|strlen
c_func
(paren
id|ap-&gt;fsname
)paren
op_plus
l_int|1
suffix:semicolon
id|mp-&gt;m_fsname
op_assign
id|kmem_alloc
c_func
(paren
id|mp-&gt;m_fsname_len
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|mp-&gt;m_fsname
comma
id|ap-&gt;fsname
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull in the &squot;wsync&squot; and &squot;ino64&squot; mount options before we do the real&n;&t; * work of mounting and recovery.  The arg pointer will&n;&t; * be NULL when we are being called from the root mount code.&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_WSYNC
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_WSYNC
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_INO64
)paren
(brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_INO64
suffix:semicolon
id|mp-&gt;m_inoadd
op_assign
id|XFS_INO64_OFFSET
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOATIME
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOATIME
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
(paren
id|XFSMNT_UQUOTA
op_or
id|XFSMNT_GQUOTA
)paren
)paren
id|xfs_qm_mount_quotainit
c_func
(paren
id|mp
comma
id|ap-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_RETERR
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_RETERR
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOALIGN
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOALIGN
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_OSYNCISOSYNC
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_OSYNCISOSYNC
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_32BITINODES
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_32BITINODES
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_IOSIZE
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;iosizelog
OG
id|XFS_MAX_IO_LOG
op_logical_or
id|ap-&gt;iosizelog
OL
id|XFS_MIN_IO_LOG
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: invalid log iosize: %d [not %d-%d]&quot;
comma
id|ap-&gt;iosizelog
comma
id|XFS_MIN_IO_LOG
comma
id|XFS_MAX_IO_LOG
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_DFLT_IOSIZE
suffix:semicolon
id|mp-&gt;m_readio_log
op_assign
id|mp-&gt;m_writeio_log
op_assign
id|ap-&gt;iosizelog
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * no recovery flag requires a read-only mount&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NORECOVERY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ronly
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: tried to mount a FS read-write without recovery!&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NORECOVERY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOUUID
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOUUID
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_NOLOGFLUSH
)paren
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_NOLOGFLUSH
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function fills in xfs_mount_t fields based on mount args.&n; * Note: the superblock _has_ now been read in.&n; */
id|STATIC
r_int
DECL|function|xfs_finish_flags
id|xfs_finish_flags
c_func
(paren
r_struct
id|xfs_mount_args
op_star
id|ap
comma
r_struct
id|xfs_mount
op_star
id|mp
comma
r_int
id|ronly
)paren
(brace
multiline_comment|/* Fail a mount where the logbuf is smaller then the log stripe */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASLOGV2
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|ap-&gt;logbufsize
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|mp-&gt;m_sb.sb_logsunit
OG
id|XLOG_BIG_RECORD_BSIZE
)paren
)paren
op_logical_or
(paren
id|ap-&gt;logbufsize
OL
id|mp-&gt;m_sb.sb_logsunit
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: logbuf size must be greater than or equal to log stripe size&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Fail a mount if the logbuf is larger than 32K */
r_if
c_cond
(paren
id|ap-&gt;logbufsize
OG
id|XLOG_BIG_RECORD_BSIZE
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: logbuf size for version 1 logs must be 16K or 32K&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * prohibit r/w mounts of read-only filesystems&n;&t; */
r_if
c_cond
(paren
(paren
id|mp-&gt;m_sb.sb_flags
op_amp
id|XFS_SBF_READONLY
)paren
op_logical_and
op_logical_neg
id|ronly
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: cannot mount a read-only filesystem as read-write&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * disallow mount attempts with (IRIX) project quota enabled&n;&t; */
r_if
c_cond
(paren
id|XFS_SB_VERSION_HASQUOTA
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
op_logical_and
(paren
id|mp-&gt;m_sb.sb_qflags
op_amp
id|XFS_PQUOTA_ACCT
)paren
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: cannot mount a filesystem with IRIX project quota enabled&quot;
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOSYS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check for shared mount.&n;&t; */
r_if
c_cond
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_SHARED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|XFS_SB_VERSION_HASSHARED
c_func
(paren
op_amp
id|mp-&gt;m_sb
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For IRIX 6.5, shared mounts must have the shared&n;&t;&t; * version bit set, have the persistent readonly&n;&t;&t; * field set, must be version 0 and can only be mounted&n;&t;&t; * read-only.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ronly
op_logical_or
op_logical_neg
(paren
id|mp-&gt;m_sb.sb_flags
op_amp
id|XFS_SBF_READONLY
)paren
op_logical_or
(paren
id|mp-&gt;m_sb.sb_shared_vn
op_ne
l_int|0
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
id|mp-&gt;m_flags
op_or_assign
id|XFS_MOUNT_SHARED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Shared XFS V0 can&squot;t deal with DMI.  Return EINVAL.&n;&t;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_sb.sb_shared_vn
op_eq
l_int|0
op_logical_and
(paren
id|ap-&gt;flags
op_amp
id|XFSMNT_DMAPI
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_mount&n; *&n; * The file system configurations are:&n; *&t;(1) device (partition) with data and internal log&n; *&t;(2) logical volume with data and log subvolumes.&n; *&t;(3) logical volume with data, log, and realtime subvolumes.&n; *&n; * The Linux VFS took care of finding and opening the data volume for&n; * us.  We have to handle the other two (if present) here.&n; */
id|STATIC
r_int
DECL|function|xfs_mount
id|xfs_mount
c_func
(paren
id|vfs_t
op_star
id|vfsp
comma
r_struct
id|xfs_mount_args
op_star
id|args
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
r_struct
id|block_device
op_star
id|ddev
comma
op_star
id|logdev
comma
op_star
id|rtdev
suffix:semicolon
r_int
id|ronly
op_assign
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_RDONLY
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|ddev
op_assign
id|vfsp-&gt;vfs_super-&gt;s_bdev
suffix:semicolon
id|logdev
op_assign
id|rtdev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Open real time and log devices - order is important.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;logname
(braket
l_int|0
)braket
)paren
(brace
id|error
op_assign
id|xfs_blkdev_get
c_func
(paren
id|args-&gt;logname
comma
op_amp
id|logdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|args-&gt;rtname
(braket
l_int|0
)braket
)paren
(brace
id|error
op_assign
id|xfs_blkdev_get
c_func
(paren
id|args-&gt;rtname
comma
op_amp
id|rtdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_blkdev_put
c_func
(paren
id|logdev
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtdev
op_eq
id|ddev
op_logical_or
id|rtdev
op_eq
id|logdev
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;XFS: Cannot mount filesystem with identical rtdev and ddev/logdev.&quot;
)paren
suffix:semicolon
id|xfs_blkdev_put
c_func
(paren
id|logdev
)paren
suffix:semicolon
id|xfs_blkdev_put
c_func
(paren
id|rtdev
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Allocate VFS private data (xfs mount structure).&n;&t; */
id|mp
op_assign
id|xfs_mount_init
c_func
(paren
)paren
suffix:semicolon
id|vfs_insertbhv
c_func
(paren
id|vfsp
comma
op_amp
id|mp-&gt;m_bhv
comma
op_amp
id|xfs_vfsops
comma
id|mp
)paren
suffix:semicolon
id|mp-&gt;m_ddev_targp
op_assign
id|xfs_alloc_buftarg
c_func
(paren
id|ddev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtdev
op_ne
l_int|NULL
)paren
(brace
id|mp-&gt;m_rtdev_targp
op_assign
id|xfs_alloc_buftarg
c_func
(paren
id|rtdev
)paren
suffix:semicolon
id|set_blocksize
c_func
(paren
id|rtdev
comma
l_int|512
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|logdev
op_ne
l_int|NULL
op_logical_and
id|logdev
op_ne
id|ddev
)paren
(brace
id|mp-&gt;m_logdev_targp
op_assign
id|xfs_alloc_buftarg
c_func
(paren
id|logdev
)paren
suffix:semicolon
id|set_blocksize
c_func
(paren
id|logdev
comma
l_int|512
)paren
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;m_logdev_targp
op_assign
id|mp-&gt;m_ddev_targp
suffix:semicolon
)brace
id|error
op_assign
id|xfs_start_flags
c_func
(paren
id|args
comma
id|mp
comma
id|ronly
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error
suffix:semicolon
id|error
op_assign
id|xfs_readsb
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error
suffix:semicolon
id|error
op_assign
id|xfs_finish_flags
c_func
(paren
id|args
comma
id|mp
comma
id|ronly
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_freesb
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|mp-&gt;m_ddev_targp-&gt;pbr_blocksize
op_assign
id|mp-&gt;m_sb.sb_blocksize
suffix:semicolon
r_if
c_cond
(paren
id|logdev
op_ne
l_int|0
op_logical_and
id|logdev
op_ne
id|ddev
)paren
(brace
id|mp-&gt;m_logdev_targp-&gt;pbr_blocksize
op_assign
id|mp-&gt;m_sb.sb_blocksize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtdev
op_ne
l_int|0
)paren
(brace
id|mp-&gt;m_rtdev_targp-&gt;pbr_blocksize
op_assign
id|mp-&gt;m_sb.sb_blocksize
suffix:semicolon
)brace
id|mp-&gt;m_cxfstype
op_assign
id|XFS_CXFS_NOT
suffix:semicolon
id|error
op_assign
id|xfs_mountfs
c_func
(paren
id|vfsp
comma
id|mp
comma
id|ddev-&gt;bd_dev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|xfs_binval
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|logdev
op_ne
l_int|NULL
op_logical_and
id|logdev
op_ne
id|ddev
)paren
(brace
id|xfs_binval
c_func
(paren
id|mp-&gt;m_logdev_targp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rtdev
op_ne
l_int|NULL
)paren
(brace
id|xfs_binval
c_func
(paren
id|mp-&gt;m_rtdev_targp
)paren
suffix:semicolon
)brace
id|xfs_unmountfs_close
c_func
(paren
id|mp
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_mount_free
c_func
(paren
id|mp
comma
l_int|1
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_ibusy searches for a busy inode in the mounted file system.&n; *&n; * Return 0 if there are no active inodes otherwise return 1.&n; */
id|STATIC
r_int
DECL|function|xfs_ibusy
id|xfs_ibusy
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|vnode_t
op_star
id|vp
suffix:semicolon
r_int
id|busy
suffix:semicolon
id|busy
op_assign
l_int|0
suffix:semicolon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ip
op_assign
id|mp-&gt;m_inodes
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|busy
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* Skip markers inserted by xfs_sync */
r_if
c_cond
(paren
id|ip-&gt;i_mount
op_eq
l_int|NULL
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
op_logical_and
id|vn_count
c_func
(paren
id|vp
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|xfs_ibusy_check
c_func
(paren
id|ip
comma
id|vn_count
c_func
(paren
id|vp
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;busy vp=0x%p ip=0x%p inum %Ld count=%d&bslash;n&quot;
comma
id|vp
comma
id|ip
comma
id|ip-&gt;i_ino
comma
id|vn_count
c_func
(paren
id|vp
)paren
)paren
suffix:semicolon
macro_line|#endif
id|busy
op_increment
suffix:semicolon
)brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ip
op_ne
id|mp-&gt;m_inodes
)paren
op_logical_and
op_logical_neg
id|busy
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
id|busy
suffix:semicolon
)brace
id|STATIC
r_int
DECL|function|xfs_unmount
id|xfs_unmount
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|flags
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_inode_t
op_star
id|rip
suffix:semicolon
id|vnode_t
op_star
id|rvp
op_assign
l_int|0
suffix:semicolon
r_struct
id|vfs
op_star
id|vfsp
op_assign
id|bhvtovfs
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_int
id|unmount_event_wanted
op_assign
l_int|0
suffix:semicolon
r_int
id|unmount_event_flags
op_assign
l_int|0
suffix:semicolon
r_int
id|xfs_unmountfs_needed
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|rip
op_assign
id|mp-&gt;m_rootip
suffix:semicolon
id|rvp
op_assign
id|XFS_ITOV
c_func
(paren
id|rip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfsp-&gt;vfs_flag
op_amp
id|VFS_DMI
)paren
(brace
id|bhv_desc_t
op_star
id|rbdp
suffix:semicolon
id|rbdp
op_assign
id|vn_bhv_lookup_unlocked
c_func
(paren
id|VN_BHV_HEAD
c_func
(paren
id|rvp
)paren
comma
op_amp
id|xfs_vnodeops
)paren
suffix:semicolon
id|error
op_assign
id|dm_send_namesp_event
c_func
(paren
id|DM_EVENT_PREUNMOUNT
comma
id|rbdp
comma
id|DM_RIGHT_NULL
comma
id|rbdp
comma
id|DM_RIGHT_NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
(paren
id|mp-&gt;m_dmevmask
op_amp
(paren
l_int|1
op_lshift
id|DM_EVENT_PREUNMOUNT
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|DM_FLAGS_UNWANTED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
id|unmount_event_wanted
op_assign
l_int|1
suffix:semicolon
id|unmount_event_flags
op_assign
(paren
id|mp-&gt;m_dmevmask
op_amp
(paren
l_int|1
op_lshift
id|DM_EVENT_UNMOUNT
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
id|DM_FLAGS_UNWANTED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure there are no active users.&n;&t; */
r_if
c_cond
(paren
id|xfs_ibusy
c_func
(paren
id|mp
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EBUSY
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xfs_unmount: xfs_ibusy says error/%d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_unmount_flush
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|ASSERT
c_func
(paren
id|vn_count
c_func
(paren
id|rvp
)paren
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Drop the reference count, and then&n;&t; * run the vnode through vn_remove.&n;&t; */
id|rvp-&gt;v_flag
op_or_assign
id|VPURGE
suffix:semicolon
multiline_comment|/* OK for vn_purge */
id|VN_RELE
c_func
(paren
id|rvp
)paren
suffix:semicolon
id|vn_remove
c_func
(paren
id|rvp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re forcing a shutdown, typically because of a media error,&n;&t; * we want to make sure we invalidate dirty pages that belong to&n;&t; * referenced vnodes as well.&n;&t; */
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|error
op_assign
id|xfs_sync
c_func
(paren
op_amp
id|mp-&gt;m_bhv
comma
(paren
id|SYNC_WAIT
op_or
id|SYNC_CLOSE
)paren
comma
id|credp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|error
op_ne
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|xfs_unmountfs_needed
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&t;Send DMAPI event, if required.&n;&t; *&t;Then do xfs_unmountfs() if needed.&n;&t; *&t;Then return error (or zero).&n;&t; */
r_if
c_cond
(paren
id|unmount_event_wanted
)paren
(brace
multiline_comment|/* Note: mp structure must still exist for&n;&t;&t; * dm_send_unmount_event() call.&n;&t;&t; */
id|dm_send_unmount_event
c_func
(paren
id|vfsp
comma
id|error
op_eq
l_int|0
ques
c_cond
id|rvp
suffix:colon
l_int|NULL
comma
id|DM_RIGHT_NULL
comma
l_int|0
comma
id|error
comma
id|unmount_event_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfs_unmountfs_needed
)paren
(brace
multiline_comment|/*&n;&t;&t; * Call common unmount function to flush to disk&n;&t;&t; * and free the super block buffer &amp; mount structures.&n;&t;&t; */
id|xfs_unmountfs
c_func
(paren
id|mp
comma
id|credp
)paren
suffix:semicolon
)brace
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_unmount_flush implements a set of flush operation on special&n; * inodes, which are needed as a separate set of operations so that&n; * they can be called as part of relocation process.&n; */
r_int
DECL|function|xfs_unmount_flush
id|xfs_unmount_flush
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* Mount structure we are getting&n;&t;&t;&t;&t;&t;   rid of. */
r_int
id|relocation
)paren
multiline_comment|/* Called from vfs relocation. */
(brace
id|xfs_inode_t
op_star
id|rip
op_assign
id|mp-&gt;m_rootip
suffix:semicolon
id|xfs_inode_t
op_star
id|rbmip
suffix:semicolon
id|xfs_inode_t
op_star
id|rsumip
op_assign
l_int|NULL
suffix:semicolon
id|vnode_t
op_star
id|rvp
op_assign
id|XFS_ITOV
c_func
(paren
id|rip
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|rip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Flush out the real time inodes.&n;&t; */
r_if
c_cond
(paren
(paren
id|rbmip
op_assign
id|mp-&gt;m_rbmip
)paren
op_ne
l_int|NULL
)paren
(brace
id|xfs_ilock
c_func
(paren
id|rbmip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|rbmip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|rbmip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|rbmip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out
suffix:semicolon
id|ASSERT
c_func
(paren
id|vn_count
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rbmip
)paren
)paren
op_eq
l_int|1
)paren
suffix:semicolon
id|rsumip
op_assign
id|mp-&gt;m_rsumip
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|rsumip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iflock
c_func
(paren
id|rsumip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|rsumip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|rsumip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out
suffix:semicolon
id|ASSERT
c_func
(paren
id|vn_count
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rsumip
)paren
)paren
op_eq
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * synchronously flush root inode to disk&n;&t; */
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|rip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out2
suffix:semicolon
r_if
c_cond
(paren
id|vn_count
c_func
(paren
id|rvp
)paren
op_ne
l_int|1
op_logical_and
op_logical_neg
id|relocation
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EBUSY
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release dquot that rootinode, rbmino and rsumino might be holding,&n;&t; * flush and purge the quota inodes.&n;&t; */
id|error
op_assign
id|xfs_qm_unmount_quotas
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
r_goto
id|fscorrupt_out2
suffix:semicolon
r_if
c_cond
(paren
id|rbmip
)paren
(brace
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rbmip
)paren
)paren
suffix:semicolon
id|VN_RELE
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|rsumip
)paren
)paren
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fscorrupt_out
suffix:colon
id|xfs_ifunlock
c_func
(paren
id|rip
)paren
suffix:semicolon
id|fscorrupt_out2
suffix:colon
id|xfs_iunlock
c_func
(paren
id|rip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_root extracts the root vnode from a vfs.&n; *&n; * vfsp -- the vfs struct for the desired file system&n; * vpp&t;-- address of the caller&squot;s vnode pointer which should be&n; *&t;   set to the desired fs root vnode&n; */
id|STATIC
r_int
DECL|function|xfs_root
id|xfs_root
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vnode_t
op_star
op_star
id|vpp
)paren
(brace
id|vnode_t
op_star
id|vp
suffix:semicolon
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
(paren
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
)paren
op_member_access_from_pointer
id|m_rootip
)paren
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|vp
)paren
suffix:semicolon
op_star
id|vpp
op_assign
id|vp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_statvfs&n; *&n; * Fill in the statvfs structure for the given file system.  We use&n; * the superblock lock in the mount structure to ensure a consistent&n; * snapshot of the counters returned.&n; */
id|STATIC
r_int
DECL|function|xfs_statvfs
id|xfs_statvfs
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_struct
id|statfs
op_star
id|statp
comma
id|vnode_t
op_star
id|vp
)paren
(brace
id|__uint64_t
id|fakeinos
suffix:semicolon
id|xfs_extlen_t
id|lsize
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_sb_t
op_star
id|sbp
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|sbp
op_assign
op_amp
(paren
id|mp-&gt;m_sb
)paren
suffix:semicolon
id|statp-&gt;f_type
op_assign
id|XFS_SB_MAGIC
suffix:semicolon
id|s
op_assign
id|XFS_SB_LOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|statp-&gt;f_bsize
op_assign
id|sbp-&gt;sb_blocksize
suffix:semicolon
id|lsize
op_assign
id|sbp-&gt;sb_logstart
ques
c_cond
id|sbp-&gt;sb_logblocks
suffix:colon
l_int|0
suffix:semicolon
id|statp-&gt;f_blocks
op_assign
id|sbp-&gt;sb_dblocks
op_minus
id|lsize
suffix:semicolon
id|statp-&gt;f_bfree
op_assign
id|statp-&gt;f_bavail
op_assign
id|sbp-&gt;sb_fdblocks
suffix:semicolon
id|fakeinos
op_assign
id|statp-&gt;f_bfree
op_lshift
id|sbp-&gt;sb_inopblog
suffix:semicolon
macro_line|#if XFS_BIG_FILESYSTEMS
id|fakeinos
op_add_assign
id|mp-&gt;m_inoadd
suffix:semicolon
macro_line|#endif
id|statp-&gt;f_files
op_assign
id|MIN
c_func
(paren
id|sbp-&gt;sb_icount
op_plus
id|fakeinos
comma
(paren
id|__uint64_t
)paren
id|XFS_MAXINUMBER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_maxicount
)paren
macro_line|#if XFS_BIG_FILESYSTEMS
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;m_inoadd
)paren
macro_line|#endif
id|statp-&gt;f_files
op_assign
id|MIN
c_func
(paren
id|statp-&gt;f_files
comma
(paren
r_int
)paren
id|mp-&gt;m_maxicount
)paren
suffix:semicolon
id|statp-&gt;f_ffree
op_assign
id|statp-&gt;f_files
op_minus
(paren
id|sbp-&gt;sb_icount
op_minus
id|sbp-&gt;sb_ifree
)paren
suffix:semicolon
id|XFS_SB_UNLOCK
c_func
(paren
id|mp
comma
id|s
)paren
suffix:semicolon
id|statp-&gt;f_fsid.val
(braket
l_int|0
)braket
op_assign
id|mp-&gt;m_dev
suffix:semicolon
id|statp-&gt;f_fsid.val
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|statp-&gt;f_namelen
op_assign
id|MAXNAMELEN
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_sync flushes any pending I/O to file system vfsp.&n; *&n; * This routine is called by vfs_sync() to make sure that things make it&n; * out to disk eventually, on sync() system calls to flush out everything,&n; * and when the file system is unmounted.  For the vfs_sync() case, all&n; * we really need to do is sync out the log to make all of our meta-data&n; * updates permanent (except for timestamps).  For calls from pflushd(),&n; * dirty pages are kept moving by calling pdflush() on the inodes&n; * containing them.  We also flush the inodes that we can lock without&n; * sleeping and the superblock if we can lock it without sleeping from&n; * vfs_sync() so that items at the tail of the log are always moving out.&n; *&n; * Flags:&n; *&t;SYNC_BDFLUSH - We&squot;re being called from vfs_sync() so we don&squot;t want&n; *&t;&t;       to sleep if we can help it.  All we really need&n; *&t;&t;       to do is ensure that the log is synced at least&n; *&t;&t;       periodically.  We also push the inodes and&n; *&t;&t;       superblock if we can lock them without sleeping&n; *&t;&t;&t;and they are not pinned.&n; *&t;SYNC_ATTR    - We need to flush the inodes.  If SYNC_BDFLUSH is not&n; *&t;&t;       set, then we really want to lock each inode and flush&n; *&t;&t;       it.&n; *&t;SYNC_WAIT    - All the flushes that take place in this call should&n; *&t;&t;       be synchronous.&n; *&t;SYNC_DELWRI  - This tells us to push dirty pages associated with&n; *&t;&t;       inodes.&t;SYNC_WAIT and SYNC_BDFLUSH are used to&n; *&t;&t;       determine if they should be flushed sync, async, or&n; *&t;&t;       delwri.&n; *&t;SYNC_CLOSE   - This flag is passed when the system is being&n; *&t;&t;       unmounted.  We should sync and invalidate everthing.&n; *&t;SYNC_FSDATA  - This indicates that the caller would like to make&n; *&t;&t;       sure the superblock is safe on disk.  We can ensure&n; *&t;&t;       this by simply makeing sure the log gets flushed&n; *&t;&t;       if SYNC_BDFLUSH is set, and by actually writing it&n; *&t;&t;       out otherwise.&n; *&n; */
multiline_comment|/*ARGSUSED*/
id|STATIC
r_int
DECL|function|xfs_sync
id|xfs_sync
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
r_int
id|flags
comma
id|cred_t
op_star
id|credp
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_return
(paren
id|xfs_syncsub
c_func
(paren
id|mp
comma
id|flags
comma
l_int|0
comma
l_int|NULL
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs sync routine for internal use&n; *&n; * This routine supports all of the flags defined for the generic VFS_SYNC&n; * interface as explained above under xys_sync.&t; In the interests of not&n; * changing interfaces within the 6.5 family, additional internallly-&n; * required functions are specified within a separate xflags parameter,&n; * only available by calling this routine.&n; *&n; * xflags:&n; *&t;XFS_XSYNC_RELOC - Sync for relocation.&t;Don&squot;t try to get behavior&n; *&t;&t;&t;  locks as this will cause you to hang.&t; Not all&n; *&t;&t;&t;  combinations of flags are necessarily supported&n; *&t;&t;&t;  when this is specified.&n; */
r_int
DECL|function|xfs_syncsub
id|xfs_syncsub
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
r_int
id|flags
comma
r_int
id|xflags
comma
r_int
op_star
id|bypassed
)paren
(brace
id|xfs_inode_t
op_star
id|ip
op_assign
l_int|NULL
suffix:semicolon
id|xfs_inode_t
op_star
id|ip_next
suffix:semicolon
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
l_int|NULL
suffix:semicolon
id|vmap_t
id|vmap
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|last_error
suffix:semicolon
r_uint64
id|fflag
suffix:semicolon
id|uint
id|lock_flags
suffix:semicolon
id|uint
id|base_lock_flags
suffix:semicolon
id|uint
id|log_flags
suffix:semicolon
id|boolean_t
id|mount_locked
suffix:semicolon
id|boolean_t
id|vnode_refed
suffix:semicolon
r_int
id|preempt
suffix:semicolon
r_int
id|do_mmap_flush
suffix:semicolon
id|xfs_dinode_t
op_star
id|dip
suffix:semicolon
id|xfs_buf_log_item_t
op_star
id|bip
suffix:semicolon
id|xfs_iptr_t
op_star
id|ipointer
suffix:semicolon
macro_line|#ifdef DEBUG
id|boolean_t
id|ipointer_in
op_assign
id|B_FALSE
suffix:semicolon
DECL|macro|IPOINTER_SET
mdefine_line|#define IPOINTER_SET&t;ipointer_in = B_TRUE
DECL|macro|IPOINTER_CLR
mdefine_line|#define IPOINTER_CLR&t;ipointer_in = B_FALSE
macro_line|#else
mdefine_line|#define IPOINTER_SET
mdefine_line|#define IPOINTER_CLR
macro_line|#endif
multiline_comment|/* Insert a marker record into the inode list after inode ip. The list&n; * must be locked when this is called. After the call the list will no&n; * longer be locked.&n; */
DECL|macro|IPOINTER_INSERT
mdefine_line|#define IPOINTER_INSERT(ip, mp) { &bslash;&n;&t;&t;ASSERT(ipointer_in == B_FALSE); &bslash;&n;&t;&t;ipointer-&gt;ip_mnext = ip-&gt;i_mnext; &bslash;&n;&t;&t;ipointer-&gt;ip_mprev = ip; &bslash;&n;&t;&t;ip-&gt;i_mnext = (xfs_inode_t *)ipointer; &bslash;&n;&t;&t;ipointer-&gt;ip_mnext-&gt;i_mprev = (xfs_inode_t *)ipointer; &bslash;&n;&t;&t;preempt = 0; &bslash;&n;&t;&t;XFS_MOUNT_IUNLOCK(mp); &bslash;&n;&t;&t;mount_locked = B_FALSE; &bslash;&n;&t;&t;IPOINTER_SET; &bslash;&n;&t;}
multiline_comment|/* Remove the marker from the inode list. If the marker was the only item&n; * in the list then there are no remaining inodes and we should zero out&n; * the whole list. If we are the current head of the list then move the head&n; * past us.&n; */
DECL|macro|IPOINTER_REMOVE
mdefine_line|#define IPOINTER_REMOVE(ip, mp) { &bslash;&n;&t;&t;ASSERT(ipointer_in == B_TRUE); &bslash;&n;&t;&t;if (ipointer-&gt;ip_mnext != (xfs_inode_t *)ipointer) { &bslash;&n;&t;&t;&t;ip = ipointer-&gt;ip_mnext; &bslash;&n;&t;&t;&t;ip-&gt;i_mprev = ipointer-&gt;ip_mprev; &bslash;&n;&t;&t;&t;ipointer-&gt;ip_mprev-&gt;i_mnext = ip; &bslash;&n;&t;&t;&t;if (mp-&gt;m_inodes == (xfs_inode_t *)ipointer) { &bslash;&n;&t;&t;&t;&t;mp-&gt;m_inodes = ip; &bslash;&n;&t;&t;&t;} &bslash;&n;&t;&t;} else { &bslash;&n;&t;&t;&t;ASSERT(mp-&gt;m_inodes == (xfs_inode_t *)ipointer); &bslash;&n;&t;&t;&t;mp-&gt;m_inodes = NULL; &bslash;&n;&t;&t;&t;ip = NULL; &bslash;&n;&t;&t;} &bslash;&n;&t;&t;IPOINTER_CLR; &bslash;&n;&t;}
DECL|macro|PREEMPT_MASK
mdefine_line|#define PREEMPT_MASK&t;0x7f
r_if
c_cond
(paren
id|bypassed
)paren
op_star
id|bypassed
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
op_member_access_from_pointer
id|vfs_flag
op_amp
id|VFS_RDONLY
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|last_error
op_assign
l_int|0
suffix:semicolon
id|preempt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate a reference marker */
id|ipointer
op_assign
(paren
id|xfs_iptr_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
r_sizeof
(paren
id|xfs_iptr_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|fflag
op_assign
id|XFS_B_ASYNC
suffix:semicolon
multiline_comment|/* default is don&squot;t wait */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
id|fflag
op_assign
id|XFS_B_DELWRI
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
id|fflag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* synchronous overrides all */
id|do_mmap_flush
op_assign
(paren
id|flags
op_amp
(paren
id|SYNC_DELWRI
op_or
id|SYNC_BDFLUSH
)paren
)paren
op_ne
(paren
id|SYNC_DELWRI
op_or
id|SYNC_BDFLUSH
)paren
suffix:semicolon
id|base_lock_flags
op_assign
id|XFS_ILOCK_SHARED
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|SYNC_DELWRI
op_or
id|SYNC_CLOSE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We need the I/O lock if we&squot;re going to call any of&n;&t;&t; * the flush/inval routines.&n;&t;&t; */
id|base_lock_flags
op_or_assign
id|XFS_IOLOCK_SHARED
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Sync out the log.  This ensures that the log is periodically&n;&t; * flushed even if there is not enough activity to fill it up.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
)brace
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ip
op_assign
id|mp-&gt;m_inodes
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|vnode_refed
op_assign
id|B_FALSE
suffix:semicolon
id|IPOINTER_CLR
suffix:semicolon
r_do
(brace
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|vnode_refed
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|lock_flags
op_assign
id|base_lock_flags
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There were no inodes in the list, just break out&n;&t;&t; * of the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We found another sync thread marker - skip it&n;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_mount
op_eq
l_int|NULL
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the vnode is gone then this is being torn down,&n;&t;&t; * call reclaim if it is flushed, else let regular flush&n;&t;&t; * code deal with it later in the loop.&n;&t;&t; */
r_if
c_cond
(paren
id|vp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Skip ones already in reclaim */
r_if
c_cond
(paren
id|ip-&gt;i_flags
op_amp
id|XFS_IRECLAIM
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_itemp
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
op_eq
l_int|0
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_eq
l_int|0
)paren
op_logical_and
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|xfs_finish_reclaim
c_func
(paren
id|ip
comma
l_int|1
comma
id|XFS_IFLUSH_DELWRI_ELSE_SYNC
)paren
suffix:semicolon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|SYNC_CLOSE
)paren
)paren
(brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If this is just vfs_sync() or pflushd() calling&n;&t;&t; * then we can skip inodes for which it looks like&n;&t;&t; * there is nothing to do.  Since we don&squot;t have the&n;&t;&t; * inode locked this is racey, but these are periodic&n;&t;&t; * calls so it doesn&squot;t matter.&t;For the others we want&n;&t;&t; * to know for sure, so we at least try to lock them.&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|ip-&gt;i_itemp
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_amp
id|XFS_ILOG_ALL
)paren
)paren
op_logical_and
(paren
id|ip-&gt;i_update_core
op_eq
l_int|0
)paren
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Try to lock without sleeping.  We&squot;re out of order with&n;&t;&t; * the inode list lock here, so if we fail we need to drop&n;&t;&t; * the mount lock and try again.  If we&squot;re called from&n;&t;&t; * bdflush() here, then don&squot;t bother.&n;&t;&t; *&n;&t;&t; * The inode lock here actually coordinates with the&n;&t;&t; * almost spurious inode lock in xfs_ireclaim() to prevent&n;&t;&t; * the vnode we handle here without a reference from&n;&t;&t; * being freed while we reference it.  If we lock the inode&n;&t;&t; * while it&squot;s on the mount list here, then the spurious inode&n;&t;&t; * lock in xfs_ireclaim() after the inode is pulled from&n;&t;&t; * the mount list will sleep until we release it here.&n;&t;&t; * This keeps the vnode from being freed while we reference&n;&t;&t; * it.&t;It is also cheaper and simpler than actually doing&n;&t;&t; * a vn_get() for every inode we touch here.&n;&t;&t; */
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|lock_flags
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
op_logical_or
(paren
id|vp
op_eq
l_int|NULL
)paren
)paren
(brace
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We need to unlock the inode list lock in order&n;&t;&t;&t; * to lock the inode. Insert a marker record into&n;&t;&t;&t; * the inode list to remember our position, dropping&n;&t;&t;&t; * the lock is now done inside the IPOINTER_INSERT&n;&t;&t;&t; * macro.&n;&t;&t;&t; *&n;&t;&t;&t; * We also use the inode list lock to protect us&n;&t;&t;&t; * in taking a snapshot of the vnode version number&n;&t;&t;&t; * for use in calling vn_get().&n;&t;&t;&t; */
id|VMAP
c_func
(paren
id|vp
comma
id|vmap
)paren
suffix:semicolon
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|vp
op_assign
id|vn_get
c_func
(paren
id|vp
comma
op_amp
id|vmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The vnode was reclaimed once we let go&n;&t;&t;&t;&t; * of the inode list lock.  Skip to the&n;&t;&t;&t;&t; * next list entry. Remove the marker.&n;&t;&t;&t;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|vnode_refed
op_assign
id|B_FALSE
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|vp
op_eq
id|XFS_ITOV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
id|vnode_refed
op_assign
id|B_TRUE
suffix:semicolon
)brace
multiline_comment|/* From here on in the loop we may have a marker record&n;&t;&t; * in the inode list.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_CLOSE
)paren
op_logical_and
(paren
id|vp
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is the shutdown case.  We just need to&n;&t;&t;&t; * flush and invalidate all the pages associated&n;&t;&t;&t; * with the inode.  Drop the inode lock since&n;&t;&t;&t; * we can&squot;t hold it across calls to the buffer&n;&t;&t;&t; * cache.&n;&t;&t;&t; *&n;&t;&t;&t; * We don&squot;t set the VREMAPPING bit in the vnode&n;&t;&t;&t; * here, because we don&squot;t hold the vnode lock&n;&t;&t;&t; * exclusively.&t; It doesn&squot;t really matter, though,&n;&t;&t;&t; * because we only come here when we&squot;re shutting&n;&t;&t;&t; * down anyway.&n;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
id|xflags
op_amp
id|XFS_XSYNC_RELOC
)paren
(brace
id|fs_tosspages
c_func
(paren
id|XFS_ITOBHV
c_func
(paren
id|ip
)paren
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_REMAPF
)paren
suffix:semicolon
)brace
r_else
(brace
id|VOP_TOSS_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_REMAPF
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|xflags
op_amp
id|XFS_XSYNC_RELOC
)paren
(brace
id|fs_flushinval_pages
c_func
(paren
id|XFS_ITOBHV
c_func
(paren
id|ip
)paren
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_REMAPF
)paren
suffix:semicolon
)brace
r_else
(brace
id|VOP_FLUSHINVAL_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_REMAPF
)paren
suffix:semicolon
)brace
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_DELWRI
)paren
op_logical_and
(paren
id|vp
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|VN_DIRTY
c_func
(paren
id|vp
)paren
)paren
(brace
multiline_comment|/* We need to have dropped the lock here,&n;&t;&t;&t;&t; * so insert a marker if we have not already&n;&t;&t;&t;&t; * done so.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Drop the inode lock since we can&squot;t hold it&n;&t;&t;&t;&t; * across calls to the buffer cache.&n;&t;&t;&t;&t; */
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_mmap_flush
)paren
(brace
id|VOP_FLUSH_PAGES
c_func
(paren
id|vp
comma
(paren
id|xfs_off_t
)paren
l_int|0
comma
op_minus
l_int|1
comma
id|fflag
comma
id|FI_NONE
comma
id|error
)paren
suffix:semicolon
)brace
r_else
(brace
id|filemap_fdatawrite
c_func
(paren
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
op_member_access_from_pointer
id|i_mapping
)paren
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_ATTR
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_update_core
)paren
op_logical_or
(paren
(paren
id|ip-&gt;i_itemp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* Insert marker and drop lock if not already&n;&t;&t;&t;&t; * done.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * We don&squot;t want the periodic flushing of the&n;&t;&t;&t;&t; * inodes by vfs_sync() to interfere with&n;&t;&t;&t;&t; * I/O to the file, especially read I/O&n;&t;&t;&t;&t; * where it is only the access time stamp&n;&t;&t;&t;&t; * that is being flushed out.  To prevent&n;&t;&t;&t;&t; * long periods where we have both inode&n;&t;&t;&t;&t; * locks held shared here while reading the&n;&t;&t;&t;&t; * inode&squot;s buffer in from disk, we drop the&n;&t;&t;&t;&t; * inode lock while reading in the inode&n;&t;&t;&t;&t; * buffer.  We have to release the buffer&n;&t;&t;&t;&t; * and reacquire the inode lock so that they&n;&t;&t;&t;&t; * are acquired in the proper order (inode&n;&t;&t;&t;&t; * locks first).  The buffer will go at the&n;&t;&t;&t;&t; * end of the lru chain, though, so we can&n;&t;&t;&t;&t; * expect it to still be there when we go&n;&t;&t;&t;&t; * for it again in xfs_iflush().&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_eq
l_int|0
)paren
op_logical_and
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|xfs_ifunlock
c_func
(paren
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
id|error
op_assign
id|xfs_itobp
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ip
comma
op_amp
id|dip
comma
op_amp
id|bp
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Bailing out, remove the&n;&t;&t;&t;&t;&t;&t; * marker and free it.&n;&t;&t;&t;&t;&t;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_SHARED
)paren
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Since we dropped the inode lock,&n;&t;&t;&t;&t;&t; * the inode may have been reclaimed.&n;&t;&t;&t;&t;&t; * Therefore, we reacquire the mount&n;&t;&t;&t;&t;&t; * lock and check to see if we were the&n;&t;&t;&t;&t;&t; * inode reclaimed. If this happened&n;&t;&t;&t;&t;&t; * then the ipointer marker will no&n;&t;&t;&t;&t;&t; * longer point back at us. In this&n;&t;&t;&t;&t;&t; * case, move ip along to the inode&n;&t;&t;&t;&t;&t; * after the marker, remove the marker&n;&t;&t;&t;&t;&t; * and continue.&n;&t;&t;&t;&t;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
r_if
c_cond
(paren
id|ip
op_ne
id|ipointer-&gt;ip_mprev
)paren
(brace
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|vnode_refed
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_SHARED
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_ilock_nowait
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
op_eq
l_int|0
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * We failed to reacquire&n;&t;&t;&t;&t;&t;&t; * the inode lock without&n;&t;&t;&t;&t;&t;&t; * sleeping, so just skip&n;&t;&t;&t;&t;&t;&t; * the inode for now.  We&n;&t;&t;&t;&t;&t;&t; * clear the ILOCK bit from&n;&t;&t;&t;&t;&t;&t; * the lock_flags so that we&n;&t;&t;&t;&t;&t;&t; * won&squot;t try to drop a lock&n;&t;&t;&t;&t;&t;&t; * we don&squot;t hold below.&n;&t;&t;&t;&t;&t;&t; */
id|lock_flags
op_and_assign
op_complement
id|XFS_ILOCK_SHARED
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip_next
comma
id|mp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|xfs_ipincount
c_func
(paren
id|ip
)paren
op_eq
l_int|0
)paren
op_logical_and
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Since this is vfs_sync()&n;&t;&t;&t;&t;&t;&t; * calling we only flush the&n;&t;&t;&t;&t;&t;&t; * inode out if we can lock&n;&t;&t;&t;&t;&t;&t; * it without sleeping and&n;&t;&t;&t;&t;&t;&t; * it is not pinned.  Drop&n;&t;&t;&t;&t;&t;&t; * the mount lock here so&n;&t;&t;&t;&t;&t;&t; * that we don&squot;t hold it for&n;&t;&t;&t;&t;&t;&t; * too long. We already have&n;&t;&t;&t;&t;&t;&t; * a marker in the list here.&n;&t;&t;&t;&t;&t;&t; */
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_FALSE
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|XFS_IFLUSH_DELWRI
)paren
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|ip-&gt;i_mount
op_eq
id|mp
)paren
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip_next
comma
id|mp
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SYNC_ATTR
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_update_core
)paren
op_logical_or
(paren
(paren
id|ip-&gt;i_itemp
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ip-&gt;i_itemp-&gt;ili_format.ilf_fields
op_ne
l_int|0
)paren
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
(brace
id|xfs_iflock
c_func
(paren
id|ip
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|XFS_IFLUSH_SYNC
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If we can&squot;t acquire the flush&n;&t;&t;&t;&t;&t; * lock, then the inode is already&n;&t;&t;&t;&t;&t; * being flushed so don&squot;t bother&n;&t;&t;&t;&t;&t; * waiting.  If we can lock it then&n;&t;&t;&t;&t;&t; * do a delwri flush so we can&n;&t;&t;&t;&t;&t; * combine multiple inode flushes&n;&t;&t;&t;&t;&t; * in each disk write.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|xfs_iflock_nowait
c_func
(paren
id|ip
)paren
)paren
(brace
id|error
op_assign
id|xfs_iflush
c_func
(paren
id|ip
comma
id|XFS_IFLUSH_DELWRI
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bypassed
)paren
(paren
op_star
id|bypassed
)paren
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|lock_flags
op_ne
l_int|0
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vnode_refed
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we had to take a reference on the vnode&n;&t;&t;&t; * above, then wait until after we&squot;ve unlocked&n;&t;&t;&t; * the inode to release the reference.&t;This is&n;&t;&t;&t; * because we can be already holding the inode&n;&t;&t;&t; * lock when VN_RELE() calls xfs_inactive().&n;&t;&t;&t; *&n;&t;&t;&t; * Make sure to drop the mount lock before calling&n;&t;&t;&t; * VN_RELE() so that we don&squot;t trip over ourselves if&n;&t;&t;&t; * we have to go for the mount lock again in the&n;&t;&t;&t; * inactive code.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
id|vnode_refed
op_assign
id|B_FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|last_error
op_assign
id|error
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * bail out if the filesystem is corrupted.&n;&t;&t; */
r_if
c_cond
(paren
id|error
op_eq
id|EFSCORRUPTED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mount_locked
)paren
(brace
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* Let other threads have a chance at the mount lock&n;&t;&t; * if we have looped many times without dropping the&n;&t;&t; * lock.&n;&t;&t; */
r_if
c_cond
(paren
(paren
op_increment
id|preempt
op_amp
id|PREEMPT_MASK
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mount_locked
)paren
(brace
id|IPOINTER_INSERT
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mount_locked
op_eq
id|B_FALSE
)paren
(brace
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|mount_locked
op_assign
id|B_TRUE
suffix:semicolon
id|IPOINTER_REMOVE
c_func
(paren
id|ip
comma
id|mp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ip
op_ne
id|mp-&gt;m_inodes
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ipointer_in
op_eq
id|B_FALSE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the Quota Manager to flush the dquots in a similar manner.&n;&t; */
r_if
c_cond
(paren
id|XFS_IS_QUOTA_ON
c_func
(paren
id|mp
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_qm_sync
c_func
(paren
id|mp
comma
id|flags
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we got an IO error, we will be shutting down.&n;&t;&t;&t; * So, there&squot;s nothing more for us to do here.&n;&t;&t;&t; */
id|ASSERT
c_func
(paren
id|error
op_ne
id|EIO
op_logical_or
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Flushing out dirty data above probably generated more&n;&t; * log activity, so if this isn&squot;t vfs_sync() then flush&n;&t; * the log again.  If SYNC_WAIT is set then do it synchronously.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
)paren
(brace
id|log_flags
op_assign
id|XFS_LOG_FORCE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_WAIT
)paren
(brace
id|log_flags
op_or_assign
id|XFS_LOG_SYNC
suffix:semicolon
)brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|log_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_FSDATA
)paren
(brace
multiline_comment|/*&n;&t;&t; * If this is vfs_sync() then only sync the superblock&n;&t;&t; * if we can lock it without sleeping and it is not pinned.&n;&t;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|SYNC_BDFLUSH
)paren
(brace
id|bp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
id|XFS_BUF_TRYLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
l_int|NULL
)paren
(brace
id|bip
op_assign
id|XFS_BUF_FSPRIVATE
c_func
(paren
id|bp
comma
id|xfs_buf_log_item_t
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bip
op_ne
l_int|NULL
)paren
op_logical_and
id|xfs_buf_item_dirty
c_func
(paren
id|bip
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
)paren
(brace
id|XFS_BUF_ASYNC
c_func
(paren
id|bp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|xfs_buf_relse
c_func
(paren
id|bp
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|bp
op_assign
id|xfs_getsb
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the buffer is pinned then push on the log so&n;&t;&t;&t; * we won&squot;t get stuck waiting in the write for&n;&t;&t;&t; * someone, maybe ourselves, to flush the log.&n;&t;&t;&t; * Even though we just pushed the log above, we&n;&t;&t;&t; * did not have the superblock buffer locked at&n;&t;&t;&t; * that point so it can become pinned in between&n;&t;&t;&t; * there and here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|XFS_BUF_ISPINNED
c_func
(paren
id|bp
)paren
)paren
(brace
id|xfs_log_force
c_func
(paren
id|mp
comma
(paren
id|xfs_lsn_t
)paren
l_int|0
comma
id|XFS_LOG_FORCE
)paren
suffix:semicolon
)brace
id|XFS_BUF_BFLAGS
c_func
(paren
id|bp
)paren
op_or_assign
id|fflag
suffix:semicolon
id|error
op_assign
id|xfs_bwrite
c_func
(paren
id|mp
comma
id|bp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|last_error
op_assign
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now check to see if the log needs a &quot;dummy&quot; transaction.&n;&t; */
r_if
c_cond
(paren
id|xfs_log_need_covered
c_func
(paren
id|mp
)paren
)paren
(brace
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put a dummy transaction in the log to tell&n;&t;&t; * recovery that all others are OK.&n;&t;&t; */
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_DUMMY1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ICHANGE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ip
op_assign
id|mp-&gt;m_rootip
suffix:semicolon
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_ihold
c_func
(paren
id|tp
comma
id|ip
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ILOG_CORE
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * When shutting down, we need to insure that the AIL is pushed&n;&t; * to disk or the filesystem can appear corrupt from the PROM.&n;&t; */
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SYNC_CLOSE
op_or
id|SYNC_WAIT
)paren
)paren
op_eq
(paren
id|SYNC_CLOSE
op_or
id|SYNC_WAIT
)paren
)paren
(brace
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_ddev_targp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;m_rtdev_targp
)paren
(brace
id|XFS_bflush
c_func
(paren
id|mp-&gt;m_rtdev_targp
)paren
suffix:semicolon
)brace
)brace
id|kmem_free
c_func
(paren
id|ipointer
comma
r_sizeof
(paren
id|xfs_iptr_t
)paren
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|last_error
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_vget - called by DMAPI to get vnode from file handle&n; */
id|STATIC
r_int
DECL|function|xfs_vget
id|xfs_vget
c_func
(paren
id|bhv_desc_t
op_star
id|bdp
comma
id|vnode_t
op_star
op_star
id|vpp
comma
id|fid_t
op_star
id|fidp
)paren
(brace
id|xfs_fid_t
op_star
id|xfid
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|error
suffix:semicolon
id|xfs_ino_t
id|ino
suffix:semicolon
r_int
r_int
id|igen
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfid
op_assign
(paren
r_struct
id|xfs_fid
op_star
)paren
id|fidp
suffix:semicolon
r_if
c_cond
(paren
id|xfid-&gt;xfs_fid_len
op_eq
r_sizeof
(paren
op_star
id|xfid
)paren
op_minus
r_sizeof
(paren
id|xfid-&gt;xfs_fid_len
)paren
)paren
(brace
id|ino
op_assign
id|xfid-&gt;xfs_fid_ino
suffix:semicolon
id|igen
op_assign
id|xfid-&gt;xfs_fid_gen
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Invalid.  Since handles can be created in user space&n;&t;&t; * and passed in via gethandle(), this is not cause for&n;&t;&t; * a panic.&n;&t;&t; */
r_return
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
)brace
id|mp
op_assign
id|XFS_BHVTOM
c_func
(paren
id|bdp
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iget
c_func
(paren
id|mp
comma
l_int|NULL
comma
id|ino
comma
id|XFS_ILOCK_SHARED
comma
op_amp
id|ip
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
op_star
id|vpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip
op_eq
l_int|NULL
)paren
(brace
op_star
id|vpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
op_logical_or
(paren
id|igen
op_logical_and
(paren
id|ip-&gt;i_d.di_gen
op_ne
id|igen
)paren
)paren
)paren
(brace
id|xfs_iput_new
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
op_star
id|vpp
op_assign
l_int|NULL
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|ENOENT
)paren
suffix:semicolon
)brace
op_star
id|vpp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_SHARED
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|xfs_vfsops
id|vfsops_t
id|xfs_vfsops
op_assign
(brace
dot
id|vfs_mount
op_assign
id|xfs_mount
comma
dot
id|vfs_dounmount
op_assign
id|fs_dounmount
comma
dot
id|vfs_unmount
op_assign
id|xfs_unmount
comma
dot
id|vfs_root
op_assign
id|xfs_root
comma
dot
id|vfs_statvfs
op_assign
id|xfs_statvfs
comma
dot
id|vfs_sync
op_assign
id|xfs_sync
comma
dot
id|vfs_vget
op_assign
id|xfs_vget
comma
dot
id|vfs_init_vnode
op_assign
id|xfs_initialize_vnode
comma
dot
id|vfs_force_shutdown
op_assign
id|xfs_do_force_shutdown
comma
macro_line|#ifdef CONFIG_XFS_DMAPI
dot
id|vfs_dmapi_mount
op_assign
id|xfs_dm_mount
comma
dot
id|vfs_dmapi_fsys_vector
op_assign
id|xfs_dm_get_fsys_vector
comma
macro_line|#endif
)brace
suffix:semicolon
eof
