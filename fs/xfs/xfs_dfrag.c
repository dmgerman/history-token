multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.&t; Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &lt;xfs.h&gt;
macro_line|#include &lt;xfs_dfrag.h&gt;
multiline_comment|/*&n; * Syssgi interface for swapext&n; */
r_int
DECL|function|xfs_swapext
id|xfs_swapext
c_func
(paren
id|xfs_swapext_t
op_star
id|sxp
)paren
(brace
id|xfs_swapext_t
id|sx
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
op_assign
l_int|NULL
comma
op_star
id|tip
op_assign
l_int|NULL
comma
op_star
id|ips
(braket
l_int|2
)braket
suffix:semicolon
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_bstat_t
op_star
id|sbp
suffix:semicolon
r_struct
id|file
op_star
id|fp
op_assign
l_int|NULL
comma
op_star
id|tfp
op_assign
l_int|NULL
suffix:semicolon
id|vnode_t
op_star
id|vp
comma
op_star
id|tvp
suffix:semicolon
id|bhv_desc_t
op_star
id|bdp
comma
op_star
id|tbdp
suffix:semicolon
id|vn_bhv_head_t
op_star
id|bhp
comma
op_star
id|tbhp
suffix:semicolon
id|uint
id|lock_flags
op_assign
l_int|0
suffix:semicolon
r_int
id|ilf_fields
comma
id|tilf_fields
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|xfs_ifork_t
id|tempif
comma
op_star
id|ifp
comma
op_star
id|tifp
suffix:semicolon
id|__uint64_t
id|tmp
suffix:semicolon
r_int
id|aforkblks
op_assign
l_int|0
suffix:semicolon
r_int
id|taforkblks
op_assign
l_int|0
suffix:semicolon
r_int
id|locked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|sx
comma
id|sxp
comma
r_sizeof
(paren
id|sx
)paren
)paren
)paren
r_return
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:semicolon
multiline_comment|/* Pull information for the target fd */
r_if
c_cond
(paren
(paren
(paren
id|fp
op_assign
id|fget
c_func
(paren
(paren
r_int
)paren
id|sx.sx_fdtarget
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|fp-&gt;f_dentry-&gt;d_inode
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|bhp
op_assign
id|VN_BHV_HEAD
c_func
(paren
id|vp
)paren
suffix:semicolon
id|bdp
op_assign
id|vn_bhv_lookup
c_func
(paren
id|bhp
comma
op_amp
id|xfs_vnodeops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EBADF
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
r_else
(brace
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|tfp
op_assign
id|fget
c_func
(paren
(paren
r_int
)paren
id|sx.sx_fdtmp
)paren
)paren
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|tvp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|tfp-&gt;f_dentry-&gt;d_inode
)paren
)paren
op_eq
l_int|NULL
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|tbhp
op_assign
id|VN_BHV_HEAD
c_func
(paren
id|tvp
)paren
suffix:semicolon
id|tbdp
op_assign
id|vn_bhv_lookup
c_func
(paren
id|tbhp
comma
op_amp
id|xfs_vnodeops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tbdp
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EBADF
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
r_else
(brace
id|tip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|tbdp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip-&gt;i_ino
op_eq
id|tip-&gt;i_ino
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|sbp
op_assign
op_amp
id|sx.sx_stat
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|locked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Lock in i_ino order */
r_if
c_cond
(paren
id|ip-&gt;i_ino
OL
id|tip-&gt;i_ino
)paren
(brace
id|ips
(braket
l_int|0
)braket
op_assign
id|ip
suffix:semicolon
id|ips
(braket
l_int|1
)braket
op_assign
id|tip
suffix:semicolon
)brace
r_else
(brace
id|ips
(braket
l_int|0
)braket
op_assign
id|tip
suffix:semicolon
id|ips
(braket
l_int|1
)braket
op_assign
id|ip
suffix:semicolon
)brace
id|lock_flags
op_assign
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
suffix:semicolon
id|xfs_lock_inodes
c_func
(paren
id|ips
comma
l_int|2
comma
l_int|0
comma
id|lock_flags
)paren
suffix:semicolon
multiline_comment|/* Check permissions */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|_MAC_XFS_IACCESS
c_func
(paren
id|ip
comma
id|MACWRITE
comma
l_int|NULL
)paren
)paren
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|_MAC_XFS_IACCESS
c_func
(paren
id|tip
comma
id|MACWRITE
comma
l_int|NULL
)paren
)paren
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|current-&gt;fsuid
op_ne
id|ip-&gt;i_d.di_uid
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|ip
comma
id|IWRITE
comma
l_int|NULL
)paren
)paren
op_logical_and
op_logical_neg
id|capable_cred
c_func
(paren
l_int|NULL
comma
id|CAP_FOWNER
)paren
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|current-&gt;fsuid
op_ne
id|tip-&gt;i_d.di_uid
)paren
op_logical_and
(paren
id|error
op_assign
id|xfs_iaccess
c_func
(paren
id|tip
comma
id|IWRITE
comma
l_int|NULL
)paren
)paren
op_logical_and
op_logical_neg
id|capable_cred
c_func
(paren
l_int|NULL
comma
id|CAP_FOWNER
)paren
)paren
(brace
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/* Verify both files are either real-time or non-realtime */
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
(paren
id|tip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/* Should never get a local format */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
op_logical_or
id|tip-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_LOCAL
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|VN_CACHED
c_func
(paren
id|tvp
)paren
op_ne
l_int|0
)paren
id|xfs_inval_cached_pages
c_func
(paren
id|XFS_ITOV
c_func
(paren
id|tip
)paren
comma
op_amp
(paren
id|tip-&gt;i_iocore
)paren
comma
(paren
id|loff_t
)paren
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Verify O_DIRECT for ftmp */
r_if
c_cond
(paren
id|VN_CACHED
c_func
(paren
id|tvp
)paren
op_ne
l_int|0
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/* Verify all data are being swapped */
r_if
c_cond
(paren
id|sx.sx_offset
op_ne
l_int|0
op_logical_or
id|sx.sx_length
op_ne
id|ip-&gt;i_d.di_size
op_logical_or
id|sx.sx_length
op_ne
id|tip-&gt;i_d.di_size
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EFAULT
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the target has extended attributes, the tmp file&n;&t; * must also in order to ensure the correct data fork&n;&t; * format.&n;&t; */
r_if
c_cond
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
op_ne
id|XFS_IFORK_Q
c_func
(paren
id|tip
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EINVAL
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Compare the current change &amp; modify times with that&n;&t; * passed in.  If they differ, we abort this swap.&n;&t; * This is the mechanism used to ensure the calling&n;&t; * process that the file was not changed out from&n;&t; * under it.&n;&t; */
r_if
c_cond
(paren
(paren
id|sbp-&gt;bs_ctime.tv_sec
op_ne
id|ip-&gt;i_d.di_ctime.t_sec
)paren
op_logical_or
(paren
id|sbp-&gt;bs_ctime.tv_nsec
op_ne
id|ip-&gt;i_d.di_ctime.t_nsec
)paren
op_logical_or
(paren
id|sbp-&gt;bs_mtime.tv_sec
op_ne
id|ip-&gt;i_d.di_mtime.t_sec
)paren
op_logical_or
(paren
id|sbp-&gt;bs_mtime.tv_nsec
op_ne
id|ip-&gt;i_d.di_mtime.t_nsec
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EBUSY
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/* We need to fail if the file is memory mapped.  Once we have tossed&n;&t; * all existing pages, the page fault will have no option&n;&t; * but to go to the filesystem for pages. By making the page fault call&n;&t; * VOP_READ (or write in the case of autogrow) they block on the iolock&n;&t; * until we have switched the extents.&n;&t; */
r_if
c_cond
(paren
id|VN_MAPPED
c_func
(paren
id|vp
)paren
)paren
(brace
id|error
op_assign
id|XFS_ERROR
c_func
(paren
id|EBUSY
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|tip
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is a race condition here since we gave up the&n;&t; * ilock.  However, the data fork will not change since&n;&t; * we have the iolock (locked for truncation too) so we&n;&t; * are safe.  We don&squot;t really care if non-io related&n;&t; * fields change.&n;&t; */
id|VOP_TOSS_PAGES
c_func
(paren
id|vp
comma
l_int|0
comma
op_minus
l_int|1
comma
id|FI_REMAPF
)paren
suffix:semicolon
id|tp
op_assign
id|xfs_trans_alloc
c_func
(paren
id|mp
comma
id|XFS_TRANS_SWAPEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_trans_reserve
c_func
(paren
id|tp
comma
l_int|0
comma
id|XFS_ICHANGE_LOG_RES
c_func
(paren
id|mp
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|tip
comma
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|xfs_lock_inodes
c_func
(paren
id|ips
comma
l_int|2
comma
l_int|0
comma
id|XFS_ILOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Count the number of extended attribute blocks&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|XFS_IFORK_Q
c_func
(paren
id|ip
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_anextents
OG
l_int|0
)paren
)paren
op_logical_and
(paren
id|ip-&gt;i_d.di_aformat
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
)paren
(brace
id|error
op_assign
id|xfs_bmap_count_blocks
c_func
(paren
id|tp
comma
id|ip
comma
id|XFS_ATTR_FORK
comma
op_amp
id|aforkblks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|tip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
(paren
id|XFS_IFORK_Q
c_func
(paren
id|tip
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|tip-&gt;i_d.di_anextents
OG
l_int|0
)paren
)paren
op_logical_and
(paren
id|tip-&gt;i_d.di_aformat
op_ne
id|XFS_DINODE_FMT_LOCAL
)paren
)paren
(brace
id|error
op_assign
id|xfs_bmap_count_blocks
c_func
(paren
id|tp
comma
id|tip
comma
id|XFS_ATTR_FORK
comma
op_amp
id|taforkblks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|tip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_trans_cancel
c_func
(paren
id|tp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Swap the data forks of the inodes&n;&t; */
id|ifp
op_assign
op_amp
id|ip-&gt;i_df
suffix:semicolon
id|tifp
op_assign
op_amp
id|tip-&gt;i_df
suffix:semicolon
id|tempif
op_assign
op_star
id|ifp
suffix:semicolon
multiline_comment|/* struct copy */
op_star
id|ifp
op_assign
op_star
id|tifp
suffix:semicolon
multiline_comment|/* struct copy */
op_star
id|tifp
op_assign
id|tempif
suffix:semicolon
multiline_comment|/* struct copy */
multiline_comment|/*&n;&t; * Fix the on-disk inode values&n;&t; */
id|tmp
op_assign
(paren
id|__uint64_t
)paren
id|ip-&gt;i_d.di_nblocks
suffix:semicolon
id|ip-&gt;i_d.di_nblocks
op_assign
id|tip-&gt;i_d.di_nblocks
op_minus
id|taforkblks
op_plus
id|aforkblks
suffix:semicolon
id|tip-&gt;i_d.di_nblocks
op_assign
id|tmp
op_plus
id|taforkblks
op_minus
id|aforkblks
suffix:semicolon
id|tmp
op_assign
(paren
id|__uint64_t
)paren
id|ip-&gt;i_d.di_nextents
suffix:semicolon
id|ip-&gt;i_d.di_nextents
op_assign
id|tip-&gt;i_d.di_nextents
suffix:semicolon
id|tip-&gt;i_d.di_nextents
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
(paren
id|__uint64_t
)paren
id|ip-&gt;i_d.di_format
suffix:semicolon
id|ip-&gt;i_d.di_format
op_assign
id|tip-&gt;i_d.di_format
suffix:semicolon
id|tip-&gt;i_d.di_format
op_assign
id|tmp
suffix:semicolon
id|ilf_fields
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_switch
c_cond
(paren
id|ip-&gt;i_d.di_format
)paren
(brace
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
multiline_comment|/* If the extents fit in the inode, fix the&n;&t;&t; * pointer.  Otherwise it&squot;s already NULL or&n;&t;&t; * pointing to the extent.&n;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_d.di_nextents
op_le
id|XFS_INLINE_EXTS
)paren
(brace
id|ifp-&gt;if_u1.if_extents
op_assign
id|ifp-&gt;if_u2.if_inline_ext
suffix:semicolon
)brace
id|ilf_fields
op_or_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|ilf_fields
op_or_assign
id|XFS_ILOG_DBROOT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tilf_fields
op_assign
id|XFS_ILOG_CORE
suffix:semicolon
r_switch
c_cond
(paren
id|tip-&gt;i_d.di_format
)paren
(brace
r_case
id|XFS_DINODE_FMT_EXTENTS
suffix:colon
multiline_comment|/* If the extents fit in the inode, fix the&n;&t;&t; * pointer.  Otherwise it&squot;s already NULL or&n;&t;&t; * pointing to the extent.&n;&t;&t; */
r_if
c_cond
(paren
id|tip-&gt;i_d.di_nextents
op_le
id|XFS_INLINE_EXTS
)paren
(brace
id|tifp-&gt;if_u1.if_extents
op_assign
id|tifp-&gt;if_u2.if_inline_ext
suffix:semicolon
)brace
id|tilf_fields
op_or_assign
id|XFS_ILOG_DEXT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_DINODE_FMT_BTREE
suffix:colon
id|tilf_fields
op_or_assign
id|XFS_ILOG_DBROOT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Increment vnode ref counts since xfs_trans_commit &amp;&n;&t; * xfs_trans_cancel will both unlock the inodes and&n;&t; * decrement the associated ref counts.&n;&t; */
id|VN_HOLD
c_func
(paren
id|vp
)paren
suffix:semicolon
id|VN_HOLD
c_func
(paren
id|tvp
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_trans_ijoin
c_func
(paren
id|tp
comma
id|tip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|ip
comma
id|ilf_fields
)paren
suffix:semicolon
id|xfs_trans_log_inode
c_func
(paren
id|tp
comma
id|tip
comma
id|tilf_fields
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a synchronous mount, make sure that the&n;&t; * transaction goes to disk before returning to the user.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_WSYNC
)paren
(brace
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|error
op_assign
id|xfs_trans_commit
c_func
(paren
id|tp
comma
id|XFS_TRANS_SWAPEXT
comma
l_int|NULL
)paren
suffix:semicolon
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
id|fput
c_func
(paren
id|tfp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|error0
suffix:colon
r_if
c_cond
(paren
id|locked
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|tip
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fp
op_ne
l_int|NULL
)paren
id|fput
c_func
(paren
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tfp
op_ne
l_int|NULL
)paren
id|fput
c_func
(paren
id|tfp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
