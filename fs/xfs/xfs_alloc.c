multiline_comment|/*&n; * Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
multiline_comment|/*&n; * Free space allocation for XFS.&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_alloc.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
macro_line|#include &quot;xfs_error.h&quot;
DECL|macro|XFS_ABSDIFF
mdefine_line|#define XFS_ABSDIFF(a,b)&t;(((a) &lt;= (b)) ? ((b) - (a)) : ((a) - (b)))
DECL|macro|XFSA_FIXUP_BNO_OK
mdefine_line|#define&t;XFSA_FIXUP_BNO_OK&t;1
DECL|macro|XFSA_FIXUP_CNT_OK
mdefine_line|#define&t;XFSA_FIXUP_CNT_OK&t;2
r_int
id|xfs_alloc_search_busy
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_agnumber_t
id|agno
comma
id|xfs_agblock_t
id|bno
comma
id|xfs_extlen_t
id|len
)paren
suffix:semicolon
macro_line|#if defined(XFS_ALLOC_TRACE)
DECL|variable|xfs_alloc_trace_buf
id|ktrace_t
op_star
id|xfs_alloc_trace_buf
suffix:semicolon
DECL|macro|TRACE_ALLOC
mdefine_line|#define&t;TRACE_ALLOC(s,a)&t;&bslash;&n;&t;xfs_alloc_trace_alloc(fname, s, a, __LINE__)
DECL|macro|TRACE_FREE
mdefine_line|#define&t;TRACE_FREE(s,a,b,x,f)&t;&bslash;&n;&t;xfs_alloc_trace_free(fname, s, mp, a, b, x, f, __LINE__)
DECL|macro|TRACE_MODAGF
mdefine_line|#define&t;TRACE_MODAGF(s,a,f)&t;&bslash;&n;&t;xfs_alloc_trace_modagf(fname, s, mp, a, f, __LINE__)
DECL|macro|TRACE_BUSY
mdefine_line|#define&t;TRACE_BUSY(fname,s,ag,agb,l,sl,tp)&t;&bslash;&n;&t;xfs_alloc_trace_busy(fname, s, mp, ag, agb, l, sl, tp, XFS_ALLOC_KTRACE_BUSY, __LINE__)
DECL|macro|TRACE_UNBUSY
mdefine_line|#define&t;TRACE_UNBUSY(fname,s,ag,sl,tp)&t;&bslash;&n;&t;xfs_alloc_trace_busy(fname, s, mp, ag, -1, -1, sl, tp, XFS_ALLOC_KTRACE_UNBUSY, __LINE__)
DECL|macro|TRACE_BUSYSEARCH
mdefine_line|#define&t;TRACE_BUSYSEARCH(fname,s,ag,agb,l,sl,tp)&t;&bslash;&n;&t;xfs_alloc_trace_busy(fname, s, mp, ag, agb, l, sl, tp, XFS_ALLOC_KTRACE_BUSYSEARCH, __LINE__)
macro_line|#else
DECL|macro|TRACE_ALLOC
mdefine_line|#define&t;TRACE_ALLOC(s,a)
DECL|macro|TRACE_FREE
mdefine_line|#define&t;TRACE_FREE(s,a,b,x,f)
DECL|macro|TRACE_MODAGF
mdefine_line|#define&t;TRACE_MODAGF(s,a,f)
DECL|macro|TRACE_BUSY
mdefine_line|#define&t;TRACE_BUSY(s,a,ag,agb,l,sl,tp)
DECL|macro|TRACE_UNBUSY
mdefine_line|#define&t;TRACE_UNBUSY(fname,s,ag,sl,tp)
DECL|macro|TRACE_BUSYSEARCH
mdefine_line|#define&t;TRACE_BUSYSEARCH(fname,s,ag,agb,l,sl,tp)
macro_line|#endif&t;/* XFS_ALLOC_TRACE */
multiline_comment|/*&n; * Prototypes for per-ag allocation routines&n; */
id|STATIC
r_int
id|xfs_alloc_ag_vextent_exact
c_func
(paren
id|xfs_alloc_arg_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_ag_vextent_near
c_func
(paren
id|xfs_alloc_arg_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_ag_vextent_size
c_func
(paren
id|xfs_alloc_arg_t
op_star
)paren
suffix:semicolon
id|STATIC
r_int
id|xfs_alloc_ag_vextent_small
c_func
(paren
id|xfs_alloc_arg_t
op_star
comma
id|xfs_btree_cur_t
op_star
comma
id|xfs_agblock_t
op_star
comma
id|xfs_extlen_t
op_star
comma
r_int
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * Internal functions.&n; */
multiline_comment|/*&n; * Compute aligned version of the found extent.&n; * Takes alignment and min length into account.&n; */
id|STATIC
r_int
multiline_comment|/* success (&gt;= minlen) */
DECL|function|xfs_alloc_compute_aligned
id|xfs_alloc_compute_aligned
c_func
(paren
id|xfs_agblock_t
id|foundbno
comma
multiline_comment|/* starting block in found extent */
id|xfs_extlen_t
id|foundlen
comma
multiline_comment|/* length in found extent */
id|xfs_extlen_t
id|alignment
comma
multiline_comment|/* alignment for allocation */
id|xfs_extlen_t
id|minlen
comma
multiline_comment|/* minimum length for allocation */
id|xfs_agblock_t
op_star
id|resbno
comma
multiline_comment|/* result block number */
id|xfs_extlen_t
op_star
id|reslen
)paren
multiline_comment|/* result length */
(brace
id|xfs_agblock_t
id|bno
suffix:semicolon
id|xfs_extlen_t
id|diff
suffix:semicolon
id|xfs_extlen_t
id|len
suffix:semicolon
r_if
c_cond
(paren
id|alignment
OG
l_int|1
op_logical_and
id|foundlen
op_ge
id|minlen
)paren
(brace
id|bno
op_assign
id|roundup
c_func
(paren
id|foundbno
comma
id|alignment
)paren
suffix:semicolon
id|diff
op_assign
id|bno
op_minus
id|foundbno
suffix:semicolon
id|len
op_assign
id|diff
op_ge
id|foundlen
ques
c_cond
l_int|0
suffix:colon
id|foundlen
op_minus
id|diff
suffix:semicolon
)brace
r_else
(brace
id|bno
op_assign
id|foundbno
suffix:semicolon
id|len
op_assign
id|foundlen
suffix:semicolon
)brace
op_star
id|resbno
op_assign
id|bno
suffix:semicolon
op_star
id|reslen
op_assign
id|len
suffix:semicolon
r_return
id|len
op_ge
id|minlen
suffix:semicolon
)brace
multiline_comment|/*&n; * Compute best start block and diff for &quot;near&quot; allocations.&n; * freelen &gt;= wantlen already checked by caller.&n; */
id|STATIC
id|xfs_extlen_t
multiline_comment|/* difference value (absolute) */
DECL|function|xfs_alloc_compute_diff
id|xfs_alloc_compute_diff
c_func
(paren
id|xfs_agblock_t
id|wantbno
comma
multiline_comment|/* target starting block */
id|xfs_extlen_t
id|wantlen
comma
multiline_comment|/* target length */
id|xfs_extlen_t
id|alignment
comma
multiline_comment|/* target alignment */
id|xfs_agblock_t
id|freebno
comma
multiline_comment|/* freespace&squot;s starting block */
id|xfs_extlen_t
id|freelen
comma
multiline_comment|/* freespace&squot;s length */
id|xfs_agblock_t
op_star
id|newbnop
)paren
multiline_comment|/* result: best start block from free */
(brace
id|xfs_agblock_t
id|freeend
suffix:semicolon
multiline_comment|/* end of freespace extent */
id|xfs_agblock_t
id|newbno1
suffix:semicolon
multiline_comment|/* return block number */
id|xfs_agblock_t
id|newbno2
suffix:semicolon
multiline_comment|/* other new block number */
id|xfs_extlen_t
id|newlen1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* length with newbno1 */
id|xfs_extlen_t
id|newlen2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* length with newbno2 */
id|xfs_agblock_t
id|wantend
suffix:semicolon
multiline_comment|/* end of target extent */
id|ASSERT
c_func
(paren
id|freelen
op_ge
id|wantlen
)paren
suffix:semicolon
id|freeend
op_assign
id|freebno
op_plus
id|freelen
suffix:semicolon
id|wantend
op_assign
id|wantbno
op_plus
id|wantlen
suffix:semicolon
r_if
c_cond
(paren
id|freebno
op_ge
id|wantbno
)paren
(brace
r_if
c_cond
(paren
(paren
id|newbno1
op_assign
id|roundup
c_func
(paren
id|freebno
comma
id|alignment
)paren
)paren
op_ge
id|freeend
)paren
id|newbno1
op_assign
id|NULLAGBLOCK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|freeend
op_ge
id|wantend
op_logical_and
id|alignment
OG
l_int|1
)paren
(brace
id|newbno1
op_assign
id|roundup
c_func
(paren
id|wantbno
comma
id|alignment
)paren
suffix:semicolon
id|newbno2
op_assign
id|newbno1
op_minus
id|alignment
suffix:semicolon
r_if
c_cond
(paren
id|newbno1
op_ge
id|freeend
)paren
id|newbno1
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_else
id|newlen1
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|wantlen
comma
id|freeend
op_minus
id|newbno1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newbno2
OL
id|freebno
)paren
id|newbno2
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_else
id|newlen2
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|wantlen
comma
id|freeend
op_minus
id|newbno2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newbno1
op_ne
id|NULLAGBLOCK
op_logical_and
id|newbno2
op_ne
id|NULLAGBLOCK
)paren
(brace
r_if
c_cond
(paren
id|newlen1
OL
id|newlen2
op_logical_or
(paren
id|newlen1
op_eq
id|newlen2
op_logical_and
id|XFS_ABSDIFF
c_func
(paren
id|newbno1
comma
id|wantbno
)paren
OG
id|XFS_ABSDIFF
c_func
(paren
id|newbno2
comma
id|wantbno
)paren
)paren
)paren
id|newbno1
op_assign
id|newbno2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|newbno2
op_ne
id|NULLAGBLOCK
)paren
id|newbno1
op_assign
id|newbno2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|freeend
op_ge
id|wantend
)paren
(brace
id|newbno1
op_assign
id|wantbno
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|alignment
OG
l_int|1
)paren
(brace
id|newbno1
op_assign
id|roundup
c_func
(paren
id|freeend
op_minus
id|wantlen
comma
id|alignment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newbno1
OG
id|freeend
op_minus
id|wantlen
op_logical_and
id|newbno1
op_minus
id|alignment
op_ge
id|freebno
)paren
id|newbno1
op_sub_assign
id|alignment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|newbno1
op_ge
id|freeend
)paren
id|newbno1
op_assign
id|NULLAGBLOCK
suffix:semicolon
)brace
r_else
id|newbno1
op_assign
id|freeend
op_minus
id|wantlen
suffix:semicolon
op_star
id|newbnop
op_assign
id|newbno1
suffix:semicolon
r_return
id|newbno1
op_eq
id|NULLAGBLOCK
ques
c_cond
l_int|0
suffix:colon
id|XFS_ABSDIFF
c_func
(paren
id|newbno1
comma
id|wantbno
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Fix up the length, based on mod and prod.&n; * len should be k * prod + mod for some k.&n; * If len is too small it is returned unchanged.&n; * If len hits maxlen it is left alone.&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_fix_len
id|xfs_alloc_fix_len
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
)paren
multiline_comment|/* allocation argument structure */
(brace
id|xfs_extlen_t
id|k
suffix:semicolon
id|xfs_extlen_t
id|rlen
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;mod
OL
id|args-&gt;prod
)paren
suffix:semicolon
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
id|ASSERT
c_func
(paren
id|rlen
op_ge
id|args-&gt;minlen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rlen
op_le
id|args-&gt;maxlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;prod
op_le
l_int|1
op_logical_or
id|rlen
OL
id|args-&gt;mod
op_logical_or
id|rlen
op_eq
id|args-&gt;maxlen
op_logical_or
(paren
id|args-&gt;mod
op_eq
l_int|0
op_logical_and
id|rlen
OL
id|args-&gt;prod
)paren
)paren
r_return
suffix:semicolon
id|k
op_assign
id|rlen
op_mod
id|args-&gt;prod
suffix:semicolon
r_if
c_cond
(paren
id|k
op_eq
id|args-&gt;mod
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|args-&gt;mod
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|rlen
op_assign
id|rlen
op_minus
id|k
op_minus
id|args-&gt;mod
)paren
OL
(paren
r_int
)paren
id|args-&gt;minlen
)paren
r_return
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|rlen
op_assign
id|rlen
op_minus
id|args-&gt;prod
op_minus
(paren
id|args-&gt;mod
op_minus
id|k
)paren
)paren
OL
(paren
r_int
)paren
id|args-&gt;minlen
)paren
r_return
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|rlen
op_ge
id|args-&gt;minlen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|rlen
op_le
id|args-&gt;maxlen
)paren
suffix:semicolon
id|args-&gt;len
op_assign
id|rlen
suffix:semicolon
)brace
multiline_comment|/*&n; * Fix up length if there is too little space left in the a.g.&n; * Return 1 if ok, 0 if too little, should give up.&n; */
id|STATIC
r_int
DECL|function|xfs_alloc_fix_minleft
id|xfs_alloc_fix_minleft
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
)paren
multiline_comment|/* allocation argument structure */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freelist header */
r_int
id|diff
suffix:semicolon
multiline_comment|/* free space difference */
r_if
c_cond
(paren
id|args-&gt;minleft
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
suffix:semicolon
id|diff
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
op_minus
id|args-&gt;len
op_minus
id|args-&gt;minleft
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_ge
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
id|args-&gt;len
op_add_assign
id|diff
suffix:semicolon
multiline_comment|/* shrink the allocated space */
r_if
c_cond
(paren
id|args-&gt;len
op_ge
id|args-&gt;minlen
)paren
r_return
l_int|1
suffix:semicolon
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the two btrees, logically removing from freespace the extent&n; * starting at rbno, rlen blocks.  The extent is contained within the&n; * actual (current) free extent fbno for flen blocks.&n; * Flags are passed in indicating whether the cursors are set to the&n; * relevant records.&n; */
id|STATIC
r_int
multiline_comment|/* error code */
DECL|function|xfs_alloc_fixup_trees
id|xfs_alloc_fixup_trees
c_func
(paren
id|xfs_btree_cur_t
op_star
id|cnt_cur
comma
multiline_comment|/* cursor for by-size btree */
id|xfs_btree_cur_t
op_star
id|bno_cur
comma
multiline_comment|/* cursor for by-block btree */
id|xfs_agblock_t
id|fbno
comma
multiline_comment|/* starting block of free extent */
id|xfs_extlen_t
id|flen
comma
multiline_comment|/* length of free extent */
id|xfs_agblock_t
id|rbno
comma
multiline_comment|/* starting block of returned extent */
id|xfs_extlen_t
id|rlen
comma
multiline_comment|/* length of returned extent */
r_int
id|flags
)paren
multiline_comment|/* flags, XFSA_FIXUP_... */
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* error code */
r_int
id|i
suffix:semicolon
multiline_comment|/* operation results */
id|xfs_agblock_t
id|nfbno1
suffix:semicolon
multiline_comment|/* first new free startblock */
id|xfs_agblock_t
id|nfbno2
suffix:semicolon
multiline_comment|/* second new free startblock */
id|xfs_extlen_t
id|nflen1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* first new free length */
id|xfs_extlen_t
id|nflen2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* second new free length */
multiline_comment|/*&n;&t; * Look up the record in the by-size tree if necessary.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|XFSA_FIXUP_CNT_OK
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|cnt_cur
comma
op_amp
id|nfbno1
comma
op_amp
id|nflen1
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
op_logical_and
id|nfbno1
op_eq
id|fbno
op_logical_and
id|nflen1
op_eq
id|flen
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|fbno
comma
id|flen
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Look up the record in the by-block tree if necessary.&n;&t; */
r_if
c_cond
(paren
id|flags
op_amp
id|XFSA_FIXUP_BNO_OK
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur
comma
op_amp
id|nfbno1
comma
op_amp
id|nflen1
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
op_logical_and
id|nfbno1
op_eq
id|fbno
op_logical_and
id|nflen1
op_eq
id|flen
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|bno_cur
comma
id|fbno
comma
id|flen
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
(brace
id|xfs_alloc_block_t
op_star
id|bnoblock
suffix:semicolon
id|xfs_alloc_block_t
op_star
id|cntblock
suffix:semicolon
r_if
c_cond
(paren
id|bno_cur-&gt;bc_nlevels
op_eq
l_int|1
op_logical_and
id|cnt_cur-&gt;bc_nlevels
op_eq
l_int|1
)paren
(brace
id|bnoblock
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|bno_cur-&gt;bc_bufs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cntblock
op_assign
id|XFS_BUF_TO_ALLOC_BLOCK
c_func
(paren
id|cnt_cur-&gt;bc_bufs
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|INT_GET
c_func
(paren
id|bnoblock-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
op_eq
id|INT_GET
c_func
(paren
id|cntblock-&gt;bb_numrecs
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Deal with all four cases: the allocated record is contained&n;&t; * within the freespace record, so we can have new freespace&n;&t; * at either (or both) end, or no freespace remaining.&n;&t; */
r_if
c_cond
(paren
id|rbno
op_eq
id|fbno
op_logical_and
id|rlen
op_eq
id|flen
)paren
id|nfbno1
op_assign
id|nfbno2
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rbno
op_eq
id|fbno
)paren
(brace
id|nfbno1
op_assign
id|rbno
op_plus
id|rlen
suffix:semicolon
id|nflen1
op_assign
id|flen
op_minus
id|rlen
suffix:semicolon
id|nfbno2
op_assign
id|NULLAGBLOCK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rbno
op_plus
id|rlen
op_eq
id|fbno
op_plus
id|flen
)paren
(brace
id|nfbno1
op_assign
id|fbno
suffix:semicolon
id|nflen1
op_assign
id|flen
op_minus
id|rlen
suffix:semicolon
id|nfbno2
op_assign
id|NULLAGBLOCK
suffix:semicolon
)brace
r_else
(brace
id|nfbno1
op_assign
id|fbno
suffix:semicolon
id|nflen1
op_assign
id|rbno
op_minus
id|fbno
suffix:semicolon
id|nfbno2
op_assign
id|rbno
op_plus
id|rlen
suffix:semicolon
id|nflen2
op_assign
(paren
id|fbno
op_plus
id|flen
)paren
op_minus
id|nfbno2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Delete the entry from the by-size btree.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delete
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Add new by-size btree entry(s).&n;&t; */
r_if
c_cond
(paren
id|nfbno1
op_ne
id|NULLAGBLOCK
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|nfbno1
comma
id|nflen1
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_insert
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nfbno2
op_ne
id|NULLAGBLOCK
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|nfbno2
comma
id|nflen2
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_insert
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fix up the by-block btree entry(s).&n;&t; */
r_if
c_cond
(paren
id|nfbno1
op_eq
id|NULLAGBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t; * No remaining freespace, just delete the by-block tree entry.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delete
c_func
(paren
id|bno_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Update the by-block entry to start later|be shorter.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_update
c_func
(paren
id|bno_cur
comma
id|nfbno1
comma
id|nflen1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nfbno2
op_ne
id|NULLAGBLOCK
)paren
(brace
multiline_comment|/*&n;&t;&t; * 2 resulting free entries, need to add one.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|bno_cur
comma
id|nfbno2
comma
id|nflen2
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_insert
c_func
(paren
id|bno_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|XFS_WANT_CORRUPTED_RETURN
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in the allocation group free block array.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_read_agfl
id|xfs_alloc_read_agfl
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_buf_t
op_star
op_star
id|bpp
)paren
multiline_comment|/* buffer for the ag free block array */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* return value */
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|agno
op_ne
id|NULLAGNUMBER
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGFL_DADDR
c_func
(paren
id|mp
)paren
)paren
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
l_int|0
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|bp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_AGFL
comma
id|XFS_AGFL_REF
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(XFS_ALLOC_TRACE)
multiline_comment|/*&n; * Add an allocation trace entry for an alloc call.&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_trace_alloc
id|xfs_alloc_trace_alloc
c_func
(paren
r_char
op_star
id|name
comma
multiline_comment|/* function tag string */
r_char
op_star
id|str
comma
multiline_comment|/* additional string */
id|xfs_alloc_arg_t
op_star
id|args
comma
multiline_comment|/* allocation argument structure */
r_int
id|line
)paren
multiline_comment|/* source line number */
(brace
id|ktrace_enter
c_func
(paren
id|xfs_alloc_trace_buf
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|XFS_ALLOC_KTRACE_ALLOC
op_or
(paren
id|line
op_lshift
l_int|16
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|name
comma
(paren
r_void
op_star
)paren
id|str
comma
(paren
r_void
op_star
)paren
id|args-&gt;mp
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;agno
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;agbno
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;minlen
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;maxlen
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;mod
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;prod
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;minleft
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;total
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;alignment
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|args-&gt;len
comma
(paren
r_void
op_star
)paren
(paren
(paren
(paren
(paren
id|__psint_t
)paren
id|args-&gt;type
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|__psint_t
)paren
id|args-&gt;otype
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
(paren
id|args-&gt;wasdel
op_lshift
l_int|3
)paren
op_or
(paren
id|args-&gt;wasfromfl
op_lshift
l_int|2
)paren
op_or
(paren
id|args-&gt;isfl
op_lshift
l_int|1
)paren
op_or
(paren
id|args-&gt;userdata
op_lshift
l_int|0
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add an allocation trace entry for a free call.&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_trace_free
id|xfs_alloc_trace_free
c_func
(paren
r_char
op_star
id|name
comma
multiline_comment|/* function tag string */
r_char
op_star
id|str
comma
multiline_comment|/* additional string */
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_agblock_t
id|agbno
comma
multiline_comment|/* a.g. relative block number */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
id|isfl
comma
multiline_comment|/* set if is freelist allocation/free */
r_int
id|line
)paren
multiline_comment|/* source line number */
(brace
id|ktrace_enter
c_func
(paren
id|xfs_alloc_trace_buf
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|XFS_ALLOC_KTRACE_FREE
op_or
(paren
id|line
op_lshift
l_int|16
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|name
comma
(paren
r_void
op_star
)paren
id|str
comma
(paren
r_void
op_star
)paren
id|mp
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|agno
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|agbno
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|len
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|isfl
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add an allocation trace entry for modifying an agf.&n; */
id|STATIC
r_void
DECL|function|xfs_alloc_trace_modagf
id|xfs_alloc_trace_modagf
c_func
(paren
r_char
op_star
id|name
comma
multiline_comment|/* function tag string */
r_char
op_star
id|str
comma
multiline_comment|/* additional string */
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount point */
id|xfs_agf_t
op_star
id|agf
comma
multiline_comment|/* new agf value */
r_int
id|flags
comma
multiline_comment|/* logging flags for agf */
r_int
id|line
)paren
multiline_comment|/* source line number */
(brace
id|ktrace_enter
c_func
(paren
id|xfs_alloc_trace_buf
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|XFS_ALLOC_KTRACE_MODAGF
op_or
(paren
id|line
op_lshift
l_int|16
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|name
comma
(paren
r_void
op_star
)paren
id|str
comma
(paren
r_void
op_star
)paren
id|mp
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|flags
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_roots
(braket
id|XFS_BTNUM_BNO
)braket
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_roots
(braket
id|XFS_BTNUM_CNT
)braket
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|XFS_BTNUM_BNO
)braket
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|XFS_BTNUM_CNT
)braket
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flfirst
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_fllast
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
id|STATIC
r_void
DECL|function|xfs_alloc_trace_busy
id|xfs_alloc_trace_busy
c_func
(paren
r_char
op_star
id|name
comma
multiline_comment|/* function tag string */
r_char
op_star
id|str
comma
multiline_comment|/* additional string */
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount poing */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_agblock_t
id|agbno
comma
multiline_comment|/* a.g. relative block number */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
id|slot
comma
multiline_comment|/* perag Busy slot */
id|xfs_trans_t
op_star
id|tp
comma
r_int
id|trtype
comma
multiline_comment|/* type: add, delete, search */
r_int
id|line
)paren
multiline_comment|/* source line number */
(brace
id|ktrace_enter
c_func
(paren
id|xfs_alloc_trace_buf
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
(paren
id|trtype
op_or
(paren
id|line
op_lshift
l_int|16
)paren
)paren
comma
(paren
r_void
op_star
)paren
id|name
comma
(paren
r_void
op_star
)paren
id|str
comma
(paren
r_void
op_star
)paren
id|mp
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|agno
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|agbno
comma
(paren
r_void
op_star
)paren
(paren
id|__psunsigned_t
)paren
id|len
comma
(paren
r_void
op_star
)paren
(paren
id|__psint_t
)paren
id|slot
comma
(paren
r_void
op_star
)paren
id|tp
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* XFS_ALLOC_TRACE */
multiline_comment|/*&n; * Allocation group level functions.&n; */
multiline_comment|/*&n; * Allocate a variable extent in the allocation group agno.&n; * Type and bno are used to determine where in the allocation group the&n; * extent will start.&n; * Extent&squot;s length (returned in *len) will be between minlen and maxlen,&n; * and of the form k * prod + mod unless there&squot;s nothing that large.&n; * Return the starting a.g. block, or NULLAGBLOCK if we can&squot;t do it.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_ag_vextent
id|xfs_alloc_ag_vextent
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
)paren
multiline_comment|/* argument structure for allocation */
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_ag_vextent&quot;
suffix:semicolon
macro_line|#endif
id|ASSERT
c_func
(paren
id|args-&gt;minlen
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;maxlen
OG
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;minlen
op_le
id|args-&gt;maxlen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;mod
OL
id|args-&gt;prod
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;alignment
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Branch to correct routine based on the type.&n;&t; */
id|args-&gt;wasfromfl
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|args-&gt;type
)paren
(brace
r_case
id|XFS_ALLOCTYPE_THIS_AG
suffix:colon
id|error
op_assign
id|xfs_alloc_ag_vextent_size
c_func
(paren
id|args
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:colon
id|error
op_assign
id|xfs_alloc_ag_vextent_near
c_func
(paren
id|args
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ALLOCTYPE_THIS_BNO
suffix:colon
id|error
op_assign
id|xfs_alloc_ag_vextent_exact
c_func
(paren
id|args
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * If the allocation worked, need to change the agf structure&n;&t; * (and log it), and the superblock.&n;&t; */
r_if
c_cond
(paren
id|args-&gt;agbno
op_ne
id|NULLAGBLOCK
)paren
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* allocation group freelist header */
macro_line|#ifdef XFS_ALLOC_TRACE
id|xfs_mount_t
op_star
id|mp
op_assign
id|args-&gt;mp
suffix:semicolon
macro_line|#endif
r_int
id|slen
op_assign
(paren
r_int
)paren
id|args-&gt;len
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;len
op_ge
id|args-&gt;minlen
op_logical_and
id|args-&gt;len
op_le
id|args-&gt;maxlen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|args-&gt;wasfromfl
)paren
op_logical_or
op_logical_neg
id|args-&gt;isfl
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;agbno
op_mod
id|args-&gt;alignment
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|args-&gt;wasfromfl
)paren
)paren
(brace
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
comma
op_minus
(paren
id|args-&gt;len
)paren
)paren
suffix:semicolon
id|xfs_trans_agblocks_delta
c_func
(paren
id|args-&gt;tp
comma
op_minus
(paren
(paren
r_int
)paren
(paren
id|args-&gt;len
)paren
)paren
)paren
suffix:semicolon
id|args-&gt;pag-&gt;pagf_freeblks
op_sub_assign
id|args-&gt;len
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|TRACE_MODAGF
c_func
(paren
l_int|NULL
comma
id|agf
comma
id|XFS_AGF_FREEBLKS
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|XFS_AGF_FREEBLKS
)paren
suffix:semicolon
multiline_comment|/* search the busylist for these blocks */
id|xfs_alloc_search_busy
c_func
(paren
id|args-&gt;tp
comma
id|args-&gt;agno
comma
id|args-&gt;agbno
comma
id|args-&gt;len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|args-&gt;isfl
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|args-&gt;tp
comma
id|args-&gt;wasdel
ques
c_cond
id|XFS_TRANS_SB_RES_FDBLOCKS
suffix:colon
id|XFS_TRANS_SB_FDBLOCKS
comma
op_minus
id|slen
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_allocx
)paren
suffix:semicolon
id|XFS_STATS_ADD
c_func
(paren
id|xs_allocb
comma
id|args-&gt;len
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a variable extent at exactly agno/bno.&n; * Extent&squot;s length (returned in *len) will be between minlen and maxlen,&n; * and of the form k * prod + mod unless there&squot;s nothing that large.&n; * Return the starting a.g. block (bno), or NULLAGBLOCK if we can&squot;t do it.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_ag_vextent_exact
id|xfs_alloc_ag_vextent_exact
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
)paren
multiline_comment|/* allocation argument structure */
(brace
id|xfs_btree_cur_t
op_star
id|bno_cur
suffix:semicolon
multiline_comment|/* by block-number btree cursor */
id|xfs_btree_cur_t
op_star
id|cnt_cur
suffix:semicolon
multiline_comment|/* by count btree cursor */
id|xfs_agblock_t
id|end
suffix:semicolon
multiline_comment|/* end of allocated extent */
r_int
id|error
suffix:semicolon
id|xfs_agblock_t
id|fbno
suffix:semicolon
multiline_comment|/* start block of found extent */
id|xfs_agblock_t
id|fend
suffix:semicolon
multiline_comment|/* end block of found extent */
id|xfs_extlen_t
id|flen
suffix:semicolon
multiline_comment|/* length of found extent */
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_ag_vextent_exact&quot;
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
multiline_comment|/* success/failure of operation */
id|xfs_agblock_t
id|maxend
suffix:semicolon
multiline_comment|/* end of maximal extent */
id|xfs_agblock_t
id|minend
suffix:semicolon
multiline_comment|/* end of minimal extent */
id|xfs_extlen_t
id|rlen
suffix:semicolon
multiline_comment|/* length of returned extent */
id|ASSERT
c_func
(paren
id|args-&gt;alignment
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate/initialize a cursor for the by-number freespace btree.&n;&t; */
id|bno_cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|args-&gt;agno
comma
id|XFS_BTNUM_BNO
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lookup bno and minlen in the btree (minlen is irrelevant, really).&n;&t; * Look for the closest free block &lt;= bno, it must contain bno&n;&t; * if any free block does.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_le
c_func
(paren
id|bno_cur
comma
id|args-&gt;agbno
comma
id|args-&gt;minlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; * Didn&squot;t find it, return null.&n;&t;&t; */
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Grab the freespace record.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur
comma
op_amp
id|fbno
comma
op_amp
id|flen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|fbno
op_le
id|args-&gt;agbno
)paren
suffix:semicolon
id|minend
op_assign
id|args-&gt;agbno
op_plus
id|args-&gt;minlen
suffix:semicolon
id|maxend
op_assign
id|args-&gt;agbno
op_plus
id|args-&gt;maxlen
suffix:semicolon
id|fend
op_assign
id|fbno
op_plus
id|flen
suffix:semicolon
multiline_comment|/*&n;&t; * Give up if the freespace isn&squot;t long enough for the minimum request.&n;&t; */
r_if
c_cond
(paren
id|fend
OL
id|minend
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * End of extent will be smaller of the freespace end and the&n;&t; * maximal requested end.&n;&t; */
id|end
op_assign
id|XFS_AGBLOCK_MIN
c_func
(paren
id|fend
comma
id|maxend
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Fix the length according to mod and prod if given.&n;&t; */
id|args-&gt;len
op_assign
id|end
op_minus
id|args-&gt;agbno
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_alloc_fix_minleft
c_func
(paren
id|args
)paren
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;agbno
op_plus
id|rlen
op_le
id|fend
)paren
suffix:semicolon
id|end
op_assign
id|args-&gt;agbno
op_plus
id|rlen
suffix:semicolon
multiline_comment|/*&n;&t; * We are allocating agbno for rlen [agbno .. end]&n;&t; * Allocate/initialize a cursor for the by-size btree.&n;&t; */
id|cnt_cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|args-&gt;agno
comma
id|XFS_BTNUM_CNT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;agbno
op_plus
id|args-&gt;len
op_le
id|INT_GET
c_func
(paren
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
op_member_access_from_pointer
id|agf_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_fixup_trees
c_func
(paren
id|cnt_cur
comma
id|bno_cur
comma
id|fbno
comma
id|flen
comma
id|args-&gt;agbno
comma
id|args-&gt;len
comma
id|XFSA_FIXUP_BNO_OK
)paren
)paren
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;normal&quot;
comma
id|args
)paren
suffix:semicolon
id|args-&gt;wasfromfl
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;error&quot;
comma
id|args
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a variable extent near bno in the allocation group agno.&n; * Extent&squot;s length (returned in len) will be between minlen and maxlen,&n; * and of the form k * prod + mod unless there&squot;s nothing that large.&n; * Return the starting a.g. block, or NULLAGBLOCK if we can&squot;t do it.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_ag_vextent_near
id|xfs_alloc_ag_vextent_near
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
)paren
multiline_comment|/* allocation argument structure */
(brace
id|xfs_btree_cur_t
op_star
id|bno_cur_gt
suffix:semicolon
multiline_comment|/* cursor for bno btree, right side */
id|xfs_btree_cur_t
op_star
id|bno_cur_lt
suffix:semicolon
multiline_comment|/* cursor for bno btree, left side */
id|xfs_btree_cur_t
op_star
id|cnt_cur
suffix:semicolon
multiline_comment|/* cursor for count btree */
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_ag_vextent_near&quot;
suffix:semicolon
macro_line|#endif
id|xfs_agblock_t
id|gtbno
suffix:semicolon
multiline_comment|/* start bno of right side entry */
id|xfs_agblock_t
id|gtbnoa
suffix:semicolon
multiline_comment|/* aligned ... */
id|xfs_extlen_t
id|gtdiff
suffix:semicolon
multiline_comment|/* difference to right side entry */
id|xfs_extlen_t
id|gtlen
suffix:semicolon
multiline_comment|/* length of right side entry */
id|xfs_extlen_t
id|gtlena
suffix:semicolon
multiline_comment|/* aligned ... */
id|xfs_agblock_t
id|gtnew
suffix:semicolon
multiline_comment|/* useful start bno of right side */
r_int
id|error
suffix:semicolon
multiline_comment|/* error code */
r_int
id|i
suffix:semicolon
multiline_comment|/* result code, temporary */
r_int
id|j
suffix:semicolon
multiline_comment|/* result code, temporary */
id|xfs_agblock_t
id|ltbno
suffix:semicolon
multiline_comment|/* start bno of left side entry */
id|xfs_agblock_t
id|ltbnoa
suffix:semicolon
multiline_comment|/* aligned ... */
id|xfs_extlen_t
id|ltdiff
suffix:semicolon
multiline_comment|/* difference to left side entry */
multiline_comment|/*REFERENCED*/
id|xfs_agblock_t
id|ltend
suffix:semicolon
multiline_comment|/* end bno of left side entry */
id|xfs_extlen_t
id|ltlen
suffix:semicolon
multiline_comment|/* length of left side entry */
id|xfs_extlen_t
id|ltlena
suffix:semicolon
multiline_comment|/* aligned ... */
id|xfs_agblock_t
id|ltnew
suffix:semicolon
multiline_comment|/* useful start bno of left side */
id|xfs_extlen_t
id|rlen
suffix:semicolon
multiline_comment|/* length of returned extent */
macro_line|#if defined(DEBUG) &amp;&amp; defined(__KERNEL__)
multiline_comment|/*&n;&t; * Randomly don&squot;t execute the first algorithm.&n;&t; */
r_int
id|dofirst
suffix:semicolon
multiline_comment|/* set to do first algorithm */
id|dofirst
op_assign
id|random
c_func
(paren
)paren
op_amp
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Get a cursor for the by-size btree.&n;&t; */
id|cnt_cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|args-&gt;agno
comma
id|XFS_BTNUM_CNT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ltlen
op_assign
l_int|0
suffix:semicolon
id|bno_cur_lt
op_assign
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * See if there are any free extents as big as maxlen.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_ge
c_func
(paren
id|cnt_cur
comma
l_int|0
comma
id|args-&gt;maxlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
multiline_comment|/*&n;&t; * If none, then pick up the last entry in the tree unless the&n;&t; * tree is empty.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_ag_vextent_small
c_func
(paren
id|args
comma
id|cnt_cur
comma
op_amp
id|ltbno
comma
op_amp
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|ltlen
op_eq
l_int|0
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
id|args-&gt;wasfromfl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * First algorithm.&n;&t; * If the requested extent is large wrt the freespaces available&n;&t; * in this a.g., then the cursor will be pointing to a btree entry&n;&t; * near the right edge of the tree.  If it&squot;s in the last btree leaf&n;&t; * block, then we just examine all the entries in that block&n;&t; * that are big enough, and pick the best one.&n;&t; * This is written as a while loop so we can break out of it,&n;&t; * but we never loop back to the top.&n;&t; */
r_while
c_loop
(paren
id|xfs_btree_islastblock
c_func
(paren
id|cnt_cur
comma
l_int|0
)paren
)paren
(brace
id|xfs_extlen_t
id|bdiff
suffix:semicolon
r_int
id|besti
op_assign
l_int|0
suffix:semicolon
id|xfs_extlen_t
id|blen
op_assign
l_int|0
suffix:semicolon
id|xfs_agblock_t
id|bnew
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(DEBUG) &amp;&amp; defined(__KERNEL__)
r_if
c_cond
(paren
op_logical_neg
id|dofirst
)paren
r_break
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Start from the entry that lookup found, sequence through&n;&t;&t; * all larger free blocks.  If we&squot;re actually pointing at a&n;&t;&t; * record smaller than maxlen, go to the start of this block,&n;&t;&t; * and skip all those smaller than minlen.&n;&t;&t; */
r_if
c_cond
(paren
id|ltlen
op_logical_or
id|args-&gt;alignment
OG
l_int|1
)paren
(brace
id|cnt_cur-&gt;bc_ptrs
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|cnt_cur
comma
op_amp
id|ltbno
comma
op_amp
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ltlen
op_ge
id|args-&gt;minlen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|cnt_cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ltlen
op_ge
id|args-&gt;minlen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_break
suffix:semicolon
)brace
id|i
op_assign
id|cnt_cur-&gt;bc_ptrs
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
comma
id|blen
op_assign
l_int|0
comma
id|bdiff
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|error
op_logical_and
id|j
op_logical_and
(paren
id|blen
template_param
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|cnt_cur
comma
l_int|0
comma
op_amp
id|j
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For each entry, decide if it&squot;s better than&n;&t;&t;&t; * the previous best entry.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|cnt_cur
comma
op_amp
id|ltbno
comma
op_amp
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_alloc_compute_aligned
c_func
(paren
id|ltbno
comma
id|ltlen
comma
id|args-&gt;alignment
comma
id|args-&gt;minlen
comma
op_amp
id|ltbnoa
comma
op_amp
id|ltlena
)paren
)paren
r_continue
suffix:semicolon
id|args-&gt;len
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|ltlena
comma
id|args-&gt;maxlen
)paren
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;len
op_ge
id|args-&gt;minlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;len
OL
id|blen
)paren
r_continue
suffix:semicolon
id|ltdiff
op_assign
id|xfs_alloc_compute_diff
c_func
(paren
id|args-&gt;agbno
comma
id|args-&gt;len
comma
id|args-&gt;alignment
comma
id|ltbno
comma
id|ltlen
comma
op_amp
id|ltnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ltnew
op_ne
id|NULLAGBLOCK
op_logical_and
(paren
id|args-&gt;len
OG
id|blen
op_logical_or
id|ltdiff
OL
id|bdiff
)paren
)paren
(brace
id|bdiff
op_assign
id|ltdiff
suffix:semicolon
id|bnew
op_assign
id|ltnew
suffix:semicolon
id|blen
op_assign
id|args-&gt;len
suffix:semicolon
id|besti
op_assign
id|cnt_cur-&gt;bc_ptrs
(braket
l_int|0
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * It didn&squot;t work.  We COULD be in a case where&n;&t;&t; * there&squot;s a good record somewhere, so try again.&n;&t;&t; */
r_if
c_cond
(paren
id|blen
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Point at the best entry, and retrieve it again.&n;&t;&t; */
id|cnt_cur-&gt;bc_ptrs
(braket
l_int|0
)braket
op_assign
id|besti
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|cnt_cur
comma
op_amp
id|ltbno
comma
op_amp
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|ltend
op_assign
id|ltbno
op_plus
id|ltlen
suffix:semicolon
id|ASSERT
c_func
(paren
id|ltend
op_le
id|INT_GET
c_func
(paren
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
op_member_access_from_pointer
id|agf_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|args-&gt;len
op_assign
id|blen
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_alloc_fix_minleft
c_func
(paren
id|args
)paren
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;nominleft&quot;
comma
id|args
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|blen
op_assign
id|args-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are allocating starting at bnew for blen blocks.&n;&t;&t; */
id|args-&gt;agbno
op_assign
id|bnew
suffix:semicolon
id|ASSERT
c_func
(paren
id|bnew
op_ge
id|ltbno
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|bnew
op_plus
id|blen
op_le
id|ltend
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set up a cursor for the by-bno tree.&n;&t;&t; */
id|bno_cur_lt
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|args-&gt;agno
comma
id|XFS_BTNUM_BNO
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fix up the btree entries.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_fixup_trees
c_func
(paren
id|cnt_cur
comma
id|bno_cur_lt
comma
id|ltbno
comma
id|ltlen
comma
id|bnew
comma
id|blen
comma
id|XFSA_FIXUP_CNT_OK
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;first&quot;
comma
id|args
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Second algorithm.&n;&t; * Search in the by-bno tree to the left and to the right&n;&t; * simultaneously, until in each case we find a space big enough,&n;&t; * or run into the edge of the tree.  When we run into the edge,&n;&t; * we deallocate that cursor.&n;&t; * If both searches succeed, we compare the two spaces and pick&n;&t; * the better one.&n;&t; * With alignment, it&squot;s possible for both to fail; the upper&n;&t; * level algorithm that picks allocation groups for allocations&n;&t; * is not supposed to do this.&n;&t; */
multiline_comment|/*&n;&t; * Allocate and initialize the cursor for the leftward search.&n;&t; */
id|bno_cur_lt
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|args-&gt;agno
comma
id|XFS_BTNUM_BNO
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lookup &lt;= bno to find the leftward search&squot;s starting point.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_le
c_func
(paren
id|bno_cur_lt
comma
id|args-&gt;agbno
comma
id|args-&gt;maxlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; * Didn&squot;t find anything; use this cursor for the rightward&n;&t;&t; * search.&n;&t;&t; */
id|bno_cur_gt
op_assign
id|bno_cur_lt
suffix:semicolon
id|bno_cur_lt
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Found something.  Duplicate the cursor for the rightward search.&n;&t; */
r_else
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_btree_dup_cursor
c_func
(paren
id|bno_cur_lt
comma
op_amp
id|bno_cur_gt
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
multiline_comment|/*&n;&t; * Increment the cursor, so we will point at the entry just right&n;&t; * of the leftward entry if any, or to the leftmost entry.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|bno_cur_gt
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; * It failed, there are no rightward entries.&n;&t;&t; */
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Loop going left with the leftward cursor, right with the&n;&t; * rightward cursor, until either both directions give up or&n;&t; * we find an entry at least as big as minlen.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|bno_cur_lt
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur_lt
comma
op_amp
id|ltbno
comma
op_amp
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_alloc_compute_aligned
c_func
(paren
id|ltbno
comma
id|ltlen
comma
id|args-&gt;alignment
comma
id|args-&gt;minlen
comma
op_amp
id|ltbnoa
comma
op_amp
id|ltlena
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|bno_cur_lt
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_lt
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bno_cur_gt
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur_gt
comma
op_amp
id|gtbno
comma
op_amp
id|gtlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xfs_alloc_compute_aligned
c_func
(paren
id|gtbno
comma
id|gtlen
comma
id|args-&gt;alignment
comma
id|args-&gt;minlen
comma
op_amp
id|gtbnoa
comma
op_amp
id|gtlena
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|bno_cur_gt
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|bno_cur_lt
op_logical_or
id|bno_cur_gt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Got both cursors still active, need to find better entry.&n;&t; */
r_if
c_cond
(paren
id|bno_cur_lt
op_logical_and
id|bno_cur_gt
)paren
(brace
multiline_comment|/*&n;&t;&t; * Left side is long enough, look for a right side entry.&n;&t;&t; */
r_if
c_cond
(paren
id|ltlena
op_ge
id|args-&gt;minlen
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Fix up the length.&n;&t;&t;&t; */
id|args-&gt;len
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|ltlena
comma
id|args-&gt;maxlen
)paren
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
id|ltdiff
op_assign
id|xfs_alloc_compute_diff
c_func
(paren
id|args-&gt;agbno
comma
id|rlen
comma
id|args-&gt;alignment
comma
id|ltbno
comma
id|ltlen
comma
op_amp
id|ltnew
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Not perfect.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ltdiff
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Look until we find a better one, run out of&n;&t;&t;&t;&t; * space, or run off the end.&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
id|bno_cur_lt
op_logical_and
id|bno_cur_gt
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur_gt
comma
op_amp
id|gtbno
comma
op_amp
id|gtlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|xfs_alloc_compute_aligned
c_func
(paren
id|gtbno
comma
id|gtlen
comma
id|args-&gt;alignment
comma
id|args-&gt;minlen
comma
op_amp
id|gtbnoa
comma
op_amp
id|gtlena
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * The left one is clearly better.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|gtbnoa
op_ge
id|args-&gt;agbno
op_plus
id|ltdiff
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If we reach a big enough entry,&n;&t;&t;&t;&t;&t; * compare the two and pick the best.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|gtlena
op_ge
id|args-&gt;minlen
)paren
(brace
id|args-&gt;len
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|gtlena
comma
id|args-&gt;maxlen
)paren
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
id|gtdiff
op_assign
id|xfs_alloc_compute_diff
c_func
(paren
id|args-&gt;agbno
comma
id|rlen
comma
id|args-&gt;alignment
comma
id|gtbno
comma
id|gtlen
comma
op_amp
id|gtnew
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Right side is better.&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|gtdiff
OL
id|ltdiff
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_lt
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Left side is better.&n;&t;&t;&t;&t;&t;&t; */
r_else
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Fell off the right end.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|bno_cur_gt
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * The left side is perfect, trash the right side.&n;&t;&t;&t; */
r_else
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * It&squot;s the right side that was found first, look left.&n;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Fix up the length.&n;&t;&t;&t; */
id|args-&gt;len
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|gtlena
comma
id|args-&gt;maxlen
)paren
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
id|gtdiff
op_assign
id|xfs_alloc_compute_diff
c_func
(paren
id|args-&gt;agbno
comma
id|rlen
comma
id|args-&gt;alignment
comma
id|gtbno
comma
id|gtlen
comma
op_amp
id|gtnew
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Right side entry isn&squot;t perfect.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|gtdiff
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Look until we find a better one, run out of&n;&t;&t;&t;&t; * space, or run off the end.&n;&t;&t;&t;&t; */
r_while
c_loop
(paren
id|bno_cur_lt
op_logical_and
id|bno_cur_gt
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur_lt
comma
op_amp
id|ltbno
comma
op_amp
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|xfs_alloc_compute_aligned
c_func
(paren
id|ltbno
comma
id|ltlen
comma
id|args-&gt;alignment
comma
id|args-&gt;minlen
comma
op_amp
id|ltbnoa
comma
op_amp
id|ltlena
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * The right one is clearly better.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ltbnoa
op_le
id|args-&gt;agbno
op_minus
id|gtdiff
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_lt
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If we reach a big enough entry,&n;&t;&t;&t;&t;&t; * compare the two and pick the best.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ltlena
op_ge
id|args-&gt;minlen
)paren
(brace
id|args-&gt;len
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|ltlena
comma
id|args-&gt;maxlen
)paren
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
id|ltdiff
op_assign
id|xfs_alloc_compute_diff
c_func
(paren
id|args-&gt;agbno
comma
id|rlen
comma
id|args-&gt;alignment
comma
id|ltbno
comma
id|ltlen
comma
op_amp
id|ltnew
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Left side is better.&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ltdiff
OL
id|gtdiff
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Right side is better.&n;&t;&t;&t;&t;&t;&t; */
r_else
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_lt
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Fell off the left end.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|bno_cur_lt
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_lt
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t; * The right side is perfect, trash the left side.&n;&t;&t;&t; */
r_else
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur_lt
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If we couldn&squot;t get anything, give up.&n;&t; */
r_if
c_cond
(paren
id|bno_cur_lt
op_eq
l_int|NULL
op_logical_and
id|bno_cur_gt
op_eq
l_int|NULL
)paren
(brace
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;neither&quot;
comma
id|args
)paren
suffix:semicolon
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * At this point we have selected a freespace entry, either to the&n;&t; * left or to the right.  If it&squot;s on the right, copy all the&n;&t; * useful variables to the &quot;left&quot; set so we only have one&n;&t; * copy of this code.&n;&t; */
r_if
c_cond
(paren
id|bno_cur_gt
)paren
(brace
id|bno_cur_lt
op_assign
id|bno_cur_gt
suffix:semicolon
id|bno_cur_gt
op_assign
l_int|NULL
suffix:semicolon
id|ltbno
op_assign
id|gtbno
suffix:semicolon
id|ltbnoa
op_assign
id|gtbnoa
suffix:semicolon
id|ltlen
op_assign
id|gtlen
suffix:semicolon
id|ltlena
op_assign
id|gtlena
suffix:semicolon
id|j
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|j
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the length and compute the useful address.&n;&t; */
id|ltend
op_assign
id|ltbno
op_plus
id|ltlen
suffix:semicolon
id|args-&gt;len
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|ltlena
comma
id|args-&gt;maxlen
)paren
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xfs_alloc_fix_minleft
c_func
(paren
id|args
)paren
)paren
(brace
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;nominleft&quot;
comma
id|args
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
(paren
r_void
)paren
id|xfs_alloc_compute_diff
c_func
(paren
id|args-&gt;agbno
comma
id|rlen
comma
id|args-&gt;alignment
comma
id|ltbno
comma
id|ltlen
comma
op_amp
id|ltnew
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ltnew
op_ge
id|ltbno
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ltnew
op_plus
id|rlen
op_le
id|ltend
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ltnew
op_plus
id|rlen
op_le
id|INT_GET
c_func
(paren
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
op_member_access_from_pointer
id|agf_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|args-&gt;agbno
op_assign
id|ltnew
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_fixup_trees
c_func
(paren
id|cnt_cur
comma
id|bno_cur_lt
comma
id|ltbno
comma
id|ltlen
comma
id|ltnew
comma
id|rlen
comma
id|XFSA_FIXUP_BNO_OK
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
id|j
ques
c_cond
l_string|&quot;gt&quot;
suffix:colon
l_string|&quot;lt&quot;
comma
id|args
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;error&quot;
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt_cur
op_ne
l_int|NULL
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bno_cur_lt
op_ne
l_int|NULL
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_lt
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bno_cur_gt
op_ne
l_int|NULL
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur_gt
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate a variable extent anywhere in the allocation group agno.&n; * Extent&squot;s length (returned in len) will be between minlen and maxlen,&n; * and of the form k * prod + mod unless there&squot;s nothing that large.&n; * Return the starting a.g. block, or NULLAGBLOCK if we can&squot;t do it.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_ag_vextent_size
id|xfs_alloc_ag_vextent_size
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
)paren
multiline_comment|/* allocation argument structure */
(brace
id|xfs_btree_cur_t
op_star
id|bno_cur
suffix:semicolon
multiline_comment|/* cursor for bno btree */
id|xfs_btree_cur_t
op_star
id|cnt_cur
suffix:semicolon
multiline_comment|/* cursor for cnt btree */
r_int
id|error
suffix:semicolon
multiline_comment|/* error result */
id|xfs_agblock_t
id|fbno
suffix:semicolon
multiline_comment|/* start of found freespace */
id|xfs_extlen_t
id|flen
suffix:semicolon
multiline_comment|/* length of found freespace */
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_ag_vextent_size&quot;
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
multiline_comment|/* temp status variable */
id|xfs_agblock_t
id|rbno
suffix:semicolon
multiline_comment|/* returned block number */
id|xfs_extlen_t
id|rlen
suffix:semicolon
multiline_comment|/* length of returned extent */
multiline_comment|/*&n;&t; * Allocate and initialize a cursor for the by-size btree.&n;&t; */
id|cnt_cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|args-&gt;agno
comma
id|XFS_BTNUM_CNT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|bno_cur
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Look for an entry &gt;= maxlen+alignment-1 blocks.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_ge
c_func
(paren
id|cnt_cur
comma
l_int|0
comma
id|args-&gt;maxlen
op_plus
id|args-&gt;alignment
op_minus
l_int|1
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
multiline_comment|/*&n;&t; * If none, then pick up the last entry in the tree unless the&n;&t; * tree is empty.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_ag_vextent_small
c_func
(paren
id|args
comma
id|cnt_cur
comma
op_amp
id|fbno
comma
op_amp
id|flen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|flen
op_eq
l_int|0
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;noentry&quot;
comma
id|args
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
id|i
op_eq
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * There&squot;s a freespace as big as maxlen+alignment-1, get it.&n;&t; */
r_else
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|cnt_cur
comma
op_amp
id|fbno
comma
op_amp
id|flen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * In the first case above, we got the last entry in the&n;&t; * by-size btree.  Now we check to see if the space hits maxlen&n;&t; * once aligned; if not, we search left for something better.&n;&t; * This can&squot;t happen in the second case above.&n;&t; */
id|xfs_alloc_compute_aligned
c_func
(paren
id|fbno
comma
id|flen
comma
id|args-&gt;alignment
comma
id|args-&gt;minlen
comma
op_amp
id|rbno
comma
op_amp
id|rlen
)paren
suffix:semicolon
id|rlen
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|args-&gt;maxlen
comma
id|rlen
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|rlen
op_eq
l_int|0
op_logical_or
(paren
id|rlen
op_le
id|flen
op_logical_and
id|rbno
op_plus
id|rlen
op_le
id|fbno
op_plus
id|flen
)paren
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rlen
OL
id|args-&gt;maxlen
)paren
(brace
id|xfs_agblock_t
id|bestfbno
suffix:semicolon
id|xfs_extlen_t
id|bestflen
suffix:semicolon
id|xfs_agblock_t
id|bestrbno
suffix:semicolon
id|xfs_extlen_t
id|bestrlen
suffix:semicolon
id|bestrlen
op_assign
id|rlen
suffix:semicolon
id|bestrbno
op_assign
id|rbno
suffix:semicolon
id|bestflen
op_assign
id|flen
suffix:semicolon
id|bestfbno
op_assign
id|fbno
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|cnt_cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|cnt_cur
comma
op_amp
id|fbno
comma
op_amp
id|flen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flen
OL
id|bestrlen
)paren
r_break
suffix:semicolon
id|xfs_alloc_compute_aligned
c_func
(paren
id|fbno
comma
id|flen
comma
id|args-&gt;alignment
comma
id|args-&gt;minlen
comma
op_amp
id|rbno
comma
op_amp
id|rlen
)paren
suffix:semicolon
id|rlen
op_assign
id|XFS_EXTLEN_MIN
c_func
(paren
id|args-&gt;maxlen
comma
id|rlen
)paren
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|rlen
op_eq
l_int|0
op_logical_or
(paren
id|rlen
op_le
id|flen
op_logical_and
id|rbno
op_plus
id|rlen
op_le
id|fbno
op_plus
id|flen
)paren
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rlen
OG
id|bestrlen
)paren
(brace
id|bestrlen
op_assign
id|rlen
suffix:semicolon
id|bestrbno
op_assign
id|rbno
suffix:semicolon
id|bestflen
op_assign
id|flen
suffix:semicolon
id|bestfbno
op_assign
id|fbno
suffix:semicolon
r_if
c_cond
(paren
id|rlen
op_eq
id|args-&gt;maxlen
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|bestfbno
comma
id|bestflen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|rlen
op_assign
id|bestrlen
suffix:semicolon
id|rbno
op_assign
id|bestrbno
suffix:semicolon
id|flen
op_assign
id|bestflen
suffix:semicolon
id|fbno
op_assign
id|bestfbno
suffix:semicolon
)brace
id|args-&gt;wasfromfl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the length.&n;&t; */
id|args-&gt;len
op_assign
id|rlen
suffix:semicolon
id|xfs_alloc_fix_len
c_func
(paren
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rlen
OL
id|args-&gt;minlen
op_logical_or
op_logical_neg
id|xfs_alloc_fix_minleft
c_func
(paren
id|args
)paren
)paren
(brace
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;nominleft&quot;
comma
id|args
)paren
suffix:semicolon
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|rlen
op_assign
id|args-&gt;len
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|rlen
op_le
id|flen
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize a cursor for the by-block tree.&n;&t; */
id|bno_cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
id|args-&gt;agno
comma
id|XFS_BTNUM_BNO
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_fixup_trees
c_func
(paren
id|cnt_cur
comma
id|bno_cur
comma
id|fbno
comma
id|flen
comma
id|rbno
comma
id|rlen
comma
id|XFSA_FIXUP_CNT_OK
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|cnt_cur
op_assign
id|bno_cur
op_assign
l_int|NULL
suffix:semicolon
id|args-&gt;len
op_assign
id|rlen
suffix:semicolon
id|args-&gt;agbno
op_assign
id|rbno
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|args-&gt;agbno
op_plus
id|args-&gt;len
op_le
id|INT_GET
c_func
(paren
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
op_member_access_from_pointer
id|agf_length
comma
id|ARCH_CONVERT
)paren
comma
id|error0
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;normal&quot;
comma
id|args
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;error&quot;
comma
id|args
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt_cur
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bno_cur
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Deal with the case where only small freespaces remain.&n; * Either return the contents of the last freespace record,&n; * or allocate space from the freelist if there is nothing in the tree.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_ag_vextent_small
id|xfs_alloc_ag_vextent_small
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
comma
multiline_comment|/* allocation argument structure */
id|xfs_btree_cur_t
op_star
id|ccur
comma
multiline_comment|/* by-size cursor */
id|xfs_agblock_t
op_star
id|fbnop
comma
multiline_comment|/* result block number */
id|xfs_extlen_t
op_star
id|flenp
comma
multiline_comment|/* result length */
r_int
op_star
id|stat
)paren
multiline_comment|/* status: 0-freelist, 1-normal/none */
(brace
r_int
id|error
suffix:semicolon
id|xfs_agblock_t
id|fbno
suffix:semicolon
id|xfs_extlen_t
id|flen
suffix:semicolon
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_ag_vextent_small&quot;
suffix:semicolon
macro_line|#endif
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|ccur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|ccur
comma
op_amp
id|fbno
comma
op_amp
id|flen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Nothing in the btree, try the freelist.  Make sure&n;&t; * to respect minleft even when pulling from the&n;&t; * freelist.&n;&t; */
r_else
r_if
c_cond
(paren
id|args-&gt;minlen
op_eq
l_int|1
op_logical_and
id|args-&gt;alignment
op_eq
l_int|1
op_logical_and
op_logical_neg
id|args-&gt;isfl
op_logical_and
(paren
id|INT_GET
c_func
(paren
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
op_member_access_from_pointer
id|agf_flcount
comma
id|ARCH_CONVERT
)paren
OG
id|args-&gt;minleft
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_freelist
c_func
(paren
id|args-&gt;tp
comma
id|args-&gt;agbp
comma
op_amp
id|fbno
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|fbno
op_ne
id|NULLAGBLOCK
)paren
(brace
r_if
c_cond
(paren
id|args-&gt;userdata
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|xfs_btree_get_bufs
c_func
(paren
id|args-&gt;mp
comma
id|args-&gt;tp
comma
id|args-&gt;agno
comma
id|fbno
comma
l_int|0
)paren
suffix:semicolon
id|xfs_trans_binval
c_func
(paren
id|args-&gt;tp
comma
id|bp
)paren
suffix:semicolon
)brace
id|args-&gt;len
op_assign
l_int|1
suffix:semicolon
id|args-&gt;agbno
op_assign
id|fbno
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|args-&gt;agbno
op_plus
id|args-&gt;len
op_le
id|INT_GET
c_func
(paren
id|XFS_BUF_TO_AGF
c_func
(paren
id|args-&gt;agbp
)paren
op_member_access_from_pointer
id|agf_length
comma
id|ARCH_CONVERT
)paren
comma
id|error0
)paren
suffix:semicolon
id|args-&gt;wasfromfl
op_assign
l_int|1
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;freelist&quot;
comma
id|args
)paren
suffix:semicolon
op_star
id|stat
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Nothing in the freelist.&n;&t;&t; */
r_else
id|flen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Can&squot;t allocate from the freelist for some reason.&n;&t; */
r_else
id|flen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Can&squot;t do the allocation, give up.&n;&t; */
r_if
c_cond
(paren
id|flen
OL
id|args-&gt;minlen
)paren
(brace
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;notenough&quot;
comma
id|args
)paren
suffix:semicolon
id|flen
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|fbnop
op_assign
id|fbno
suffix:semicolon
op_star
id|flenp
op_assign
id|flen
suffix:semicolon
op_star
id|stat
op_assign
l_int|1
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;normal&quot;
comma
id|args
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;error&quot;
comma
id|args
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the extent starting at agno/bno for length.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_free_ag_extent
id|xfs_free_ag_extent
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|agbp
comma
multiline_comment|/* buffer for a.g. freelist header */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
id|xfs_agblock_t
id|bno
comma
multiline_comment|/* starting block number */
id|xfs_extlen_t
id|len
comma
multiline_comment|/* length of extent */
r_int
id|isfl
)paren
multiline_comment|/* set if is freelist blocks - no sb acctg */
(brace
id|xfs_btree_cur_t
op_star
id|bno_cur
suffix:semicolon
multiline_comment|/* cursor for by-block btree */
id|xfs_btree_cur_t
op_star
id|cnt_cur
suffix:semicolon
multiline_comment|/* cursor for by-size btree */
r_int
id|error
suffix:semicolon
multiline_comment|/* error return value */
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_free_ag_extent&quot;
suffix:semicolon
macro_line|#endif
id|xfs_agblock_t
id|gtbno
suffix:semicolon
multiline_comment|/* start of right neighbor block */
id|xfs_extlen_t
id|gtlen
suffix:semicolon
multiline_comment|/* length of right neighbor block */
r_int
id|haveleft
suffix:semicolon
multiline_comment|/* have a left neighbor block */
r_int
id|haveright
suffix:semicolon
multiline_comment|/* have a right neighbor block */
r_int
id|i
suffix:semicolon
multiline_comment|/* temp, result code */
id|xfs_agblock_t
id|ltbno
suffix:semicolon
multiline_comment|/* start of left neighbor block */
id|xfs_extlen_t
id|ltlen
suffix:semicolon
multiline_comment|/* length of left neighbor block */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount point struct for filesystem */
id|xfs_agblock_t
id|nbno
suffix:semicolon
multiline_comment|/* new starting block of freespace */
id|xfs_extlen_t
id|nlen
suffix:semicolon
multiline_comment|/* new length of freespace */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate and initialize a cursor for the by-block btree.&n;&t; */
id|bno_cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
id|agbp
comma
id|agno
comma
id|XFS_BTNUM_BNO
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|cnt_cur
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Look for a neighboring block on the left (lower block numbers)&n;&t; * that is contiguous with this space.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_le
c_func
(paren
id|bno_cur
comma
id|bno
comma
id|len
comma
op_amp
id|haveleft
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|haveleft
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is a block to our left.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur
comma
op_amp
id|ltbno
comma
op_amp
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * It&squot;s not contiguous, though.&n;&t;&t; */
r_if
c_cond
(paren
id|ltbno
op_plus
id|ltlen
OL
id|bno
)paren
id|haveleft
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If this failure happens the request to free this&n;&t;&t;&t; * space was invalid, it&squot;s (partly) already free.&n;&t;&t;&t; * Very bad.&n;&t;&t;&t; */
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|ltbno
op_plus
id|ltlen
op_le
id|bno
comma
id|error0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Look for a neighboring block on the right (higher block numbers)&n;&t; * that is contiguous with this space.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_increment
c_func
(paren
id|bno_cur
comma
l_int|0
comma
op_amp
id|haveright
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_if
c_cond
(paren
id|haveright
)paren
(brace
multiline_comment|/*&n;&t;&t; * There is a block to our right.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur
comma
op_amp
id|gtbno
comma
op_amp
id|gtlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * It&squot;s not contiguous, though.&n;&t;&t; */
r_if
c_cond
(paren
id|bno
op_plus
id|len
OL
id|gtbno
)paren
id|haveright
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If this failure happens the request to free this&n;&t;&t;&t; * space was invalid, it&squot;s (partly) already free.&n;&t;&t;&t; * Very bad.&n;&t;&t;&t; */
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|gtbno
op_ge
id|bno
op_plus
id|len
comma
id|error0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Now allocate and initialize a cursor for the by-size tree.&n;&t; */
id|cnt_cur
op_assign
id|xfs_btree_init_cursor
c_func
(paren
id|mp
comma
id|tp
comma
id|agbp
comma
id|agno
comma
id|XFS_BTNUM_CNT
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Have both left and right contiguous neighbors.&n;&t; * Merge all three into a single free block.&n;&t; */
r_if
c_cond
(paren
id|haveleft
op_logical_and
id|haveright
)paren
(brace
multiline_comment|/*&n;&t;&t; * Delete the old by-size entry on the left.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|ltbno
comma
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delete
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Delete the old by-size entry on the right.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|gtbno
comma
id|gtlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delete
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Delete the old by-block entry for the right block.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delete
c_func
(paren
id|bno_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Move the by-block cursor back to the left neighbor.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|bno_cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t;&t; * Check that this is the right record: delete didn&squot;t&n;&t;&t; * mangle the cursor.&n;&t;&t; */
(brace
id|xfs_agblock_t
id|xxbno
suffix:semicolon
id|xfs_extlen_t
id|xxlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_rec
c_func
(paren
id|bno_cur
comma
op_amp
id|xxbno
comma
op_amp
id|xxlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
op_logical_and
id|xxbno
op_eq
id|ltbno
op_logical_and
id|xxlen
op_eq
id|ltlen
comma
id|error0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Update remaining by-block entry to the new, joined block.&n;&t;&t; */
id|nbno
op_assign
id|ltbno
suffix:semicolon
id|nlen
op_assign
id|len
op_plus
id|ltlen
op_plus
id|gtlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_update
c_func
(paren
id|bno_cur
comma
id|nbno
comma
id|nlen
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Have only a left contiguous neighbor.&n;&t; * Merge it together with the new freespace.&n;&t; */
r_else
r_if
c_cond
(paren
id|haveleft
)paren
(brace
multiline_comment|/*&n;&t;&t; * Delete the old by-size entry on the left.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|ltbno
comma
id|ltlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delete
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Back up the by-block cursor to the left neighbor, and&n;&t;&t; * update its length.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_decrement
c_func
(paren
id|bno_cur
comma
l_int|0
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|nbno
op_assign
id|ltbno
suffix:semicolon
id|nlen
op_assign
id|len
op_plus
id|ltlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_update
c_func
(paren
id|bno_cur
comma
id|nbno
comma
id|nlen
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Have only a right contiguous neighbor.&n;&t; * Merge it together with the new freespace.&n;&t; */
r_else
r_if
c_cond
(paren
id|haveright
)paren
(brace
multiline_comment|/*&n;&t;&t; * Delete the old by-size entry on the right.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|gtbno
comma
id|gtlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_delete
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Update the starting block and length of the right&n;&t;&t; * neighbor in the by-block tree.&n;&t;&t; */
id|nbno
op_assign
id|bno
suffix:semicolon
id|nlen
op_assign
id|len
op_plus
id|gtlen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_update
c_func
(paren
id|bno_cur
comma
id|nbno
comma
id|nlen
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No contiguous neighbors.&n;&t; * Insert the new freespace into the by-block tree.&n;&t; */
r_else
(brace
id|nbno
op_assign
id|bno
suffix:semicolon
id|nlen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_insert
c_func
(paren
id|bno_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
)brace
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|bno_cur
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * In all cases we need to insert the new freespace in the by-size tree.&n;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_lookup_eq
c_func
(paren
id|cnt_cur
comma
id|nbno
comma
id|nlen
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|0
comma
id|error0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_insert
c_func
(paren
id|cnt_cur
comma
op_amp
id|i
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|i
op_eq
l_int|1
comma
id|error0
)paren
suffix:semicolon
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_NOERROR
)paren
suffix:semicolon
id|cnt_cur
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Update the freespace totals in the ag and superblock.&n;&t; */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
multiline_comment|/* per allocation group data */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
comma
id|len
)paren
suffix:semicolon
id|xfs_trans_agblocks_delta
c_func
(paren
id|tp
comma
id|len
)paren
suffix:semicolon
id|pag-&gt;pagf_freeblks
op_add_assign
id|len
suffix:semicolon
id|XFS_WANT_CORRUPTED_GOTO
c_func
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
comma
id|error0
)paren
suffix:semicolon
id|TRACE_MODAGF
c_func
(paren
l_int|NULL
comma
id|agf
comma
id|XFS_AGF_FREEBLKS
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|tp
comma
id|agbp
comma
id|XFS_AGF_FREEBLKS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isfl
)paren
id|xfs_trans_mod_sb
c_func
(paren
id|tp
comma
id|XFS_TRANS_SB_FDBLOCKS
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_freex
)paren
suffix:semicolon
id|XFS_STATS_ADD
c_func
(paren
id|xs_freeb
comma
id|len
)paren
suffix:semicolon
)brace
id|TRACE_FREE
c_func
(paren
id|haveleft
ques
c_cond
(paren
id|haveright
ques
c_cond
l_string|&quot;both&quot;
suffix:colon
l_string|&quot;left&quot;
)paren
suffix:colon
(paren
id|haveright
ques
c_cond
l_string|&quot;right&quot;
suffix:colon
l_string|&quot;none&quot;
)paren
comma
id|agno
comma
id|bno
comma
id|len
comma
id|isfl
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Since blocks move to the free list without the coordination&n;&t; * used in xfs_bmap_finish, we can&squot;t allow block to be available&n;&t; * for reallocation and non-transaction writing (user data)&n;&t; * until we know that the transaction that moved it to the free&n;&t; * list is permanently on disk.  We track the blocks by declaring&n;&t; * these blocks as &quot;busy&quot;; the busy list is maintained on a per-ag&n;&t; * basis and each transaction records which entries should be removed&n;&t; * when the iclog commits to disk.  If a busy block is allocated,&n;&t; * the iclog is pushed up to the LSN that freed the block.&n;&t; */
id|xfs_alloc_mark_busy
c_func
(paren
id|tp
comma
id|agno
comma
id|bno
comma
id|len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|TRACE_FREE
c_func
(paren
l_string|&quot;error&quot;
comma
id|agno
comma
id|bno
comma
id|len
comma
id|isfl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bno_cur
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|bno_cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt_cur
)paren
id|xfs_btree_del_cursor
c_func
(paren
id|cnt_cur
comma
id|XFS_BTREE_ERROR
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Visible (exported) allocation/free functions.&n; * Some of these are used just by xfs_alloc_btree.c and this file.&n; */
multiline_comment|/*&n; * Compute and fill in value of m_ag_maxlevels.&n; */
r_void
DECL|function|xfs_alloc_compute_maxlevels
id|xfs_alloc_compute_maxlevels
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
multiline_comment|/* file system mount structure */
(brace
r_int
id|level
suffix:semicolon
id|uint
id|maxblocks
suffix:semicolon
id|uint
id|maxleafents
suffix:semicolon
r_int
id|minleafrecs
suffix:semicolon
r_int
id|minnoderecs
suffix:semicolon
id|maxleafents
op_assign
(paren
id|mp-&gt;m_sb.sb_agblocks
op_plus
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
id|minleafrecs
op_assign
id|mp-&gt;m_alloc_mnr
(braket
l_int|0
)braket
suffix:semicolon
id|minnoderecs
op_assign
id|mp-&gt;m_alloc_mnr
(braket
l_int|1
)braket
suffix:semicolon
id|maxblocks
op_assign
(paren
id|maxleafents
op_plus
id|minleafrecs
op_minus
l_int|1
)paren
op_div
id|minleafrecs
suffix:semicolon
r_for
c_loop
(paren
id|level
op_assign
l_int|1
suffix:semicolon
id|maxblocks
OG
l_int|1
suffix:semicolon
id|level
op_increment
)paren
id|maxblocks
op_assign
(paren
id|maxblocks
op_plus
id|minnoderecs
op_minus
l_int|1
)paren
op_div
id|minnoderecs
suffix:semicolon
id|mp-&gt;m_ag_maxlevels
op_assign
id|level
suffix:semicolon
)brace
multiline_comment|/*&n; * Decide whether to use this allocation group for this allocation.&n; * If so, fix up the btree freelist&squot;s size.&n; */
id|STATIC
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_fix_freelist
id|xfs_alloc_fix_freelist
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
comma
multiline_comment|/* allocation argument structure */
r_int
id|flags
)paren
multiline_comment|/* XFS_ALLOC_FLAG_... */
(brace
id|xfs_buf_t
op_star
id|agbp
suffix:semicolon
multiline_comment|/* agf buffer pointer */
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freespace structure pointer */
id|xfs_buf_t
op_star
id|agflbp
suffix:semicolon
multiline_comment|/* agfl buffer pointer */
id|xfs_agblock_t
id|bno
suffix:semicolon
multiline_comment|/* freelist block */
id|xfs_extlen_t
id|delta
suffix:semicolon
multiline_comment|/* new blocks needed in freelist */
r_int
id|error
suffix:semicolon
multiline_comment|/* error result code */
id|xfs_extlen_t
id|longest
suffix:semicolon
multiline_comment|/* longest extent in allocation group */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* file system mount point structure */
id|xfs_extlen_t
id|need
suffix:semicolon
multiline_comment|/* total blocks needed in freelist */
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
multiline_comment|/* per-ag information structure */
id|xfs_alloc_arg_t
id|targs
suffix:semicolon
multiline_comment|/* local allocation arguments */
id|xfs_trans_t
op_star
id|tp
suffix:semicolon
multiline_comment|/* transaction pointer */
id|mp
op_assign
id|args-&gt;mp
suffix:semicolon
id|pag
op_assign
id|args-&gt;pag
suffix:semicolon
id|tp
op_assign
id|args-&gt;tp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pag-&gt;pagf_init
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_read_agf
c_func
(paren
id|mp
comma
id|tp
comma
id|args-&gt;agno
comma
id|flags
comma
op_amp
id|agbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pag-&gt;pagf_init
)paren
(brace
id|args-&gt;agbp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|agbp
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* If this is a metadata prefered pag and we are user data&n;&t; * then try somewhere else if we are not being asked to&n;&t; * try harder at this point&n;&t; */
r_if
c_cond
(paren
id|pag-&gt;pagf_metadata
op_logical_and
id|args-&gt;userdata
op_logical_and
id|flags
)paren
(brace
id|args-&gt;agbp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|need
op_assign
id|XFS_MIN_FREELIST_PAG
c_func
(paren
id|pag
comma
id|mp
)paren
suffix:semicolon
id|delta
op_assign
id|need
OG
id|pag-&gt;pagf_flcount
ques
c_cond
id|need
op_minus
id|pag-&gt;pagf_flcount
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If it looks like there isn&squot;t a long enough extent, or enough&n;&t; * total blocks, reject it.&n;&t; */
id|longest
op_assign
(paren
id|pag-&gt;pagf_longest
OG
id|delta
)paren
ques
c_cond
(paren
id|pag-&gt;pagf_longest
op_minus
id|delta
)paren
suffix:colon
(paren
id|pag-&gt;pagf_flcount
OG
l_int|0
op_logical_or
id|pag-&gt;pagf_longest
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;minlen
op_plus
id|args-&gt;alignment
op_plus
id|args-&gt;minalignslop
op_minus
l_int|1
OG
id|longest
op_logical_or
(paren
id|args-&gt;minleft
op_logical_and
(paren
r_int
)paren
(paren
id|pag-&gt;pagf_freeblks
op_plus
id|pag-&gt;pagf_flcount
op_minus
id|need
op_minus
id|args-&gt;total
)paren
OL
(paren
r_int
)paren
id|args-&gt;minleft
)paren
)paren
(brace
r_if
c_cond
(paren
id|agbp
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agbp
)paren
suffix:semicolon
id|args-&gt;agbp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the a.g. freespace buffer.&n;&t; * Can fail if we&squot;re not blocking on locks, and it&squot;s held.&n;&t; */
r_if
c_cond
(paren
id|agbp
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_read_agf
c_func
(paren
id|mp
comma
id|tp
comma
id|args-&gt;agno
comma
id|flags
comma
op_amp
id|agbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|agbp
op_eq
l_int|NULL
)paren
(brace
id|args-&gt;agbp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Figure out how many blocks we should have in the freelist.&n;&t; */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|need
op_assign
id|XFS_MIN_FREELIST
c_func
(paren
id|agf
comma
id|mp
)paren
suffix:semicolon
id|delta
op_assign
id|need
OG
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
ques
c_cond
(paren
id|need
op_minus
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If there isn&squot;t enough total or single-extent, reject it.&n;&t; */
id|longest
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|longest
op_assign
(paren
id|longest
OG
id|delta
)paren
ques
c_cond
(paren
id|longest
op_minus
id|delta
)paren
suffix:colon
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
OG
l_int|0
op_logical_or
id|longest
OG
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;minlen
op_plus
id|args-&gt;alignment
op_plus
id|args-&gt;minalignslop
op_minus
l_int|1
OG
id|longest
op_logical_or
(paren
id|args-&gt;minleft
op_logical_and
(paren
r_int
)paren
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
op_plus
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
op_minus
id|need
op_minus
id|args-&gt;total
)paren
OL
(paren
r_int
)paren
id|args-&gt;minleft
)paren
)paren
(brace
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agbp
)paren
suffix:semicolon
id|args-&gt;agbp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make the freelist shorter if it&squot;s too long.&n;&t; */
r_while
c_loop
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
OG
id|need
)paren
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_get_freelist
c_func
(paren
id|tp
comma
id|agbp
comma
op_amp
id|bno
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_free_ag_extent
c_func
(paren
id|tp
comma
id|agbp
comma
id|args-&gt;agno
comma
id|bno
comma
l_int|1
comma
l_int|1
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|bp
op_assign
id|xfs_btree_get_bufs
c_func
(paren
id|mp
comma
id|tp
comma
id|args-&gt;agno
comma
id|bno
comma
l_int|0
)paren
suffix:semicolon
id|xfs_trans_binval
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize the args structure.&n;&t; */
id|targs.tp
op_assign
id|tp
suffix:semicolon
id|targs.mp
op_assign
id|mp
suffix:semicolon
id|targs.agbp
op_assign
id|agbp
suffix:semicolon
id|targs.agno
op_assign
id|args-&gt;agno
suffix:semicolon
id|targs.mod
op_assign
id|targs.minleft
op_assign
id|targs.wasdel
op_assign
id|targs.userdata
op_assign
id|targs.minalignslop
op_assign
l_int|0
suffix:semicolon
id|targs.alignment
op_assign
id|targs.minlen
op_assign
id|targs.prod
op_assign
id|targs.isfl
op_assign
l_int|1
suffix:semicolon
id|targs.type
op_assign
id|XFS_ALLOCTYPE_THIS_AG
suffix:semicolon
id|targs.pag
op_assign
id|pag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_read_agfl
c_func
(paren
id|mp
comma
id|tp
comma
id|targs.agno
comma
op_amp
id|agflbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Make the freelist longer if it&squot;s too short.&n;&t; */
r_while
c_loop
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
OL
id|need
)paren
(brace
id|targs.agbno
op_assign
l_int|0
suffix:semicolon
id|targs.maxlen
op_assign
id|need
op_minus
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Allocate as many blocks as possible at once.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_ag_vextent
c_func
(paren
op_amp
id|targs
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Stop if we run out.  Won&squot;t happen if callers are obeying&n;&t;&t; * the restrictions correctly.  Can happen for free calls&n;&t;&t; * on a completely full ag.&n;&t;&t; */
r_if
c_cond
(paren
id|targs.agbno
op_eq
id|NULLAGBLOCK
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put each allocated block on the list.&n;&t;&t; */
r_for
c_loop
(paren
id|bno
op_assign
id|targs.agbno
suffix:semicolon
id|bno
OL
id|targs.agbno
op_plus
id|targs.len
suffix:semicolon
id|bno
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_put_freelist
c_func
(paren
id|tp
comma
id|agbp
comma
id|agflbp
comma
id|bno
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
)brace
id|args-&gt;agbp
op_assign
id|agbp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a block from the freelist.&n; * Returns with the buffer for the block gotten.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_get_freelist
id|xfs_alloc_get_freelist
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|agbp
comma
multiline_comment|/* buffer containing the agf structure */
id|xfs_agblock_t
op_star
id|bnop
)paren
multiline_comment|/* block address retrieved from freelist */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freespace structure */
id|xfs_agfl_t
op_star
id|agfl
suffix:semicolon
multiline_comment|/* a.g. freelist structure */
id|xfs_buf_t
op_star
id|agflbp
suffix:semicolon
multiline_comment|/* buffer for a.g. freelist structure */
id|xfs_agblock_t
id|bno
suffix:semicolon
multiline_comment|/* block number returned */
r_int
id|error
suffix:semicolon
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_get_freelist&quot;
suffix:semicolon
macro_line|#endif
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
multiline_comment|/* per allocation group data */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Freelist is empty, give up.&n;&t; */
r_if
c_cond
(paren
id|INT_ISZERO
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
)paren
(brace
op_star
id|bnop
op_assign
id|NULLAGBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the array of free blocks.&n;&t; */
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_read_agfl
c_func
(paren
id|mp
comma
id|tp
comma
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
comma
op_amp
id|agflbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|agfl
op_assign
id|XFS_BUF_TO_AGFL
c_func
(paren
id|agflbp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the block number and update the data structures.&n;&t; */
id|bno
op_assign
id|INT_GET
c_func
(paren
id|agfl-&gt;agfl_bno
(braket
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flfirst
comma
id|ARCH_CONVERT
)paren
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_flfirst
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|agflbp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flfirst
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGFL_SIZE
c_func
(paren
id|mp
)paren
)paren
id|INT_ZERO
c_func
(paren
id|agf-&gt;agf_flfirst
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|xfs_trans_agflist_delta
c_func
(paren
id|tp
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|pag-&gt;pagf_flcount
op_decrement
suffix:semicolon
id|TRACE_MODAGF
c_func
(paren
l_int|NULL
comma
id|agf
comma
id|XFS_AGF_FLFIRST
op_or
id|XFS_AGF_FLCOUNT
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|tp
comma
id|agbp
comma
id|XFS_AGF_FLFIRST
op_or
id|XFS_AGF_FLCOUNT
)paren
suffix:semicolon
op_star
id|bnop
op_assign
id|bno
suffix:semicolon
multiline_comment|/*&n;&t; * As blocks are freed, they are added to the per-ag busy list&n;&t; * and remain there until the freeing transaction is committed to&n;&t; * disk.  Now that we have allocated blocks, this list must be&n;&t; * searched to see if a block is being reused.  If one is, then&n;&t; * the freeing transaction must be pushed to disk NOW by forcing&n;&t; * to disk all iclogs up that transaction&squot;s LSN.&n;&t; */
id|xfs_alloc_search_busy
c_func
(paren
id|tp
comma
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
comma
id|bno
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Log the given fields from the agf structure.&n; */
r_void
DECL|function|xfs_alloc_log_agf
id|xfs_alloc_log_agf
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|bp
comma
multiline_comment|/* buffer for a.g. freelist header */
r_int
id|fields
)paren
multiline_comment|/* mask of fields to be logged (XFS_AGF_...) */
(brace
r_int
id|first
suffix:semicolon
multiline_comment|/* first byte offset */
r_int
id|last
suffix:semicolon
multiline_comment|/* last byte offset */
r_static
r_const
r_int
id|offsets
(braket
)braket
op_assign
(brace
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_magicnum
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_versionnum
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_seqno
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_length
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_roots
(braket
l_int|0
)braket
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_levels
(braket
l_int|0
)braket
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_flfirst
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_fllast
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_flcount
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_freeblks
)paren
comma
m_offsetof
(paren
id|xfs_agf_t
comma
id|agf_longest
)paren
comma
r_sizeof
(paren
id|xfs_agf_t
)paren
)brace
suffix:semicolon
id|xfs_btree_offsets
c_func
(paren
id|fields
comma
id|offsets
comma
id|XFS_AGF_NUM_BITS
comma
op_amp
id|first
comma
op_amp
id|last
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|bp
comma
(paren
id|uint
)paren
id|first
comma
(paren
id|uint
)paren
id|last
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Interface for inode allocation to force the pag data to be initialized.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_pagf_init
id|xfs_alloc_pagf_init
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* file system mount structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
r_int
id|flags
)paren
multiline_comment|/* XFS_ALLOC_FLAGS_... */
(brace
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_read_agf
c_func
(paren
id|mp
comma
id|tp
comma
id|agno
comma
id|flags
comma
op_amp
id|bp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|bp
)paren
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Put the block on the freelist for the allocation group.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_put_freelist
id|xfs_alloc_put_freelist
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_buf_t
op_star
id|agbp
comma
multiline_comment|/* buffer for a.g. freelist header */
id|xfs_buf_t
op_star
id|agflbp
comma
multiline_comment|/* buffer for a.g. free block array */
id|xfs_agblock_t
id|bno
)paren
multiline_comment|/* block being freed */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freespace structure */
id|xfs_agfl_t
op_star
id|agfl
suffix:semicolon
multiline_comment|/* a.g. free block array */
id|xfs_agblock_t
op_star
id|blockp
suffix:semicolon
multiline_comment|/* pointer to array entry */
r_int
id|error
suffix:semicolon
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_put_freelist&quot;
suffix:semicolon
macro_line|#endif
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure */
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
multiline_comment|/* per allocation group data */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|agbp
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|agflbp
op_logical_and
(paren
id|error
op_assign
id|xfs_alloc_read_agfl
c_func
(paren
id|mp
comma
id|tp
comma
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
comma
op_amp
id|agflbp
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|agfl
op_assign
id|XFS_BUF_TO_AGFL
c_func
(paren
id|agflbp
)paren
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_fllast
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_fllast
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGFL_SIZE
c_func
(paren
id|mp
)paren
)paren
id|INT_ZERO
c_func
(paren
id|agf-&gt;agf_fllast
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|INT_GET
c_func
(paren
id|agf-&gt;agf_seqno
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|INT_MOD
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
comma
l_int|1
)paren
suffix:semicolon
id|xfs_trans_agflist_delta
c_func
(paren
id|tp
comma
l_int|1
)paren
suffix:semicolon
id|pag-&gt;pagf_flcount
op_increment
suffix:semicolon
id|ASSERT
c_func
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
op_le
id|XFS_AGFL_SIZE
c_func
(paren
id|mp
)paren
)paren
suffix:semicolon
id|blockp
op_assign
op_amp
id|agfl-&gt;agfl_bno
(braket
id|INT_GET
c_func
(paren
id|agf-&gt;agf_fllast
comma
id|ARCH_CONVERT
)paren
)braket
suffix:semicolon
id|INT_SET
c_func
(paren
op_star
id|blockp
comma
id|ARCH_CONVERT
comma
id|bno
)paren
suffix:semicolon
id|TRACE_MODAGF
c_func
(paren
l_int|NULL
comma
id|agf
comma
id|XFS_AGF_FLLAST
op_or
id|XFS_AGF_FLCOUNT
)paren
suffix:semicolon
id|xfs_alloc_log_agf
c_func
(paren
id|tp
comma
id|agbp
comma
id|XFS_AGF_FLLAST
op_or
id|XFS_AGF_FLCOUNT
)paren
suffix:semicolon
id|xfs_trans_log_buf
c_func
(paren
id|tp
comma
id|agflbp
comma
(paren
r_int
)paren
(paren
(paren
id|xfs_caddr_t
)paren
id|blockp
op_minus
(paren
id|xfs_caddr_t
)paren
id|agfl
)paren
comma
(paren
r_int
)paren
(paren
(paren
id|xfs_caddr_t
)paren
id|blockp
op_minus
(paren
id|xfs_caddr_t
)paren
id|agfl
op_plus
r_sizeof
(paren
id|xfs_agblock_t
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in the allocation group header (free/alloc section).&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_read_agf
id|xfs_alloc_read_agf
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
multiline_comment|/* mount point structure */
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_agnumber_t
id|agno
comma
multiline_comment|/* allocation group number */
r_int
id|flags
comma
multiline_comment|/* XFS_ALLOC_FLAG_... */
id|xfs_buf_t
op_star
op_star
id|bpp
)paren
multiline_comment|/* buffer for the ag freelist header */
(brace
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* ag freelist header */
r_int
id|agf_ok
suffix:semicolon
multiline_comment|/* set if agf is consistent */
id|xfs_buf_t
op_star
id|bp
suffix:semicolon
multiline_comment|/* return value */
id|xfs_perag_t
op_star
id|pag
suffix:semicolon
multiline_comment|/* per allocation group data */
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|agno
op_ne
id|NULLAGNUMBER
)paren
suffix:semicolon
id|error
op_assign
id|xfs_trans_read_buf
c_func
(paren
id|mp
comma
id|tp
comma
id|mp-&gt;m_ddev_targp
comma
id|XFS_AG_DADDR
c_func
(paren
id|mp
comma
id|agno
comma
id|XFS_AGF_DADDR
c_func
(paren
id|mp
)paren
)paren
comma
id|XFS_FSS_TO_BB
c_func
(paren
id|mp
comma
l_int|1
)paren
comma
(paren
id|flags
op_amp
id|XFS_ALLOC_FLAG_TRYLOCK
)paren
ques
c_cond
id|XFS_BUF_TRYLOCK
suffix:colon
l_int|0U
comma
op_amp
id|bp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
id|bp
op_logical_or
op_logical_neg
id|XFS_BUF_GETERROR
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
)paren
(brace
op_star
id|bpp
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Validate the magic number of the agf block.&n;&t; */
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|bp
)paren
suffix:semicolon
id|agf_ok
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_magicnum
comma
id|ARCH_CONVERT
)paren
op_eq
id|XFS_AGF_MAGIC
op_logical_and
id|XFS_AGF_GOOD_VERSION
c_func
(paren
id|INT_GET
c_func
(paren
id|agf-&gt;agf_versionnum
comma
id|ARCH_CONVERT
)paren
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
op_le
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flfirst
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_AGFL_SIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|agf-&gt;agf_fllast
comma
id|ARCH_CONVERT
)paren
OL
id|XFS_AGFL_SIZE
c_func
(paren
id|mp
)paren
op_logical_and
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
op_le
id|XFS_AGFL_SIZE
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|XFS_TEST_ERROR
c_func
(paren
op_logical_neg
id|agf_ok
comma
id|mp
comma
id|XFS_ERRTAG_ALLOC_READ_AGF
comma
id|XFS_RANDOM_ALLOC_READ_AGF
)paren
)paren
)paren
(brace
id|XFS_CORRUPTION_ERROR
c_func
(paren
l_string|&quot;xfs_alloc_read_agf&quot;
comma
id|XFS_ERRLEVEL_LOW
comma
id|mp
comma
id|agf
)paren
suffix:semicolon
id|xfs_trans_brelse
c_func
(paren
id|tp
comma
id|bp
)paren
suffix:semicolon
r_return
id|XFS_ERROR
c_func
(paren
id|EFSCORRUPTED
)paren
suffix:semicolon
)brace
id|pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pag-&gt;pagf_init
)paren
(brace
id|pag-&gt;pagf_freeblks
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pag-&gt;pagf_flcount
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pag-&gt;pagf_longest
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pag-&gt;pagf_levels
(braket
id|XFS_BTNUM_BNOi
)braket
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|XFS_BTNUM_BNOi
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|pag-&gt;pagf_levels
(braket
id|XFS_BTNUM_CNTi
)braket
op_assign
id|INT_GET
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|XFS_BTNUM_CNTi
)braket
comma
id|ARCH_CONVERT
)paren
suffix:semicolon
id|spinlock_init
c_func
(paren
op_amp
id|pag-&gt;pagb_lock
comma
l_string|&quot;xfspagb&quot;
)paren
suffix:semicolon
id|pag-&gt;pagb_list
op_assign
id|kmem_zalloc
c_func
(paren
id|XFS_PAGB_NUM_SLOTS
op_star
r_sizeof
(paren
id|xfs_perag_busy_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|pag-&gt;pagf_init
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_else
r_if
c_cond
(paren
op_logical_neg
id|XFS_FORCED_SHUTDOWN
c_func
(paren
id|mp
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|pag-&gt;pagf_freeblks
op_eq
id|INT_GET
c_func
(paren
id|agf-&gt;agf_freeblks
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pag-&gt;pagf_flcount
op_eq
id|INT_GET
c_func
(paren
id|agf-&gt;agf_flcount
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pag-&gt;pagf_longest
op_eq
id|INT_GET
c_func
(paren
id|agf-&gt;agf_longest
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pag-&gt;pagf_levels
(braket
id|XFS_BTNUM_BNOi
)braket
op_eq
id|INT_GET
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|XFS_BTNUM_BNOi
)braket
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|pag-&gt;pagf_levels
(braket
id|XFS_BTNUM_CNTi
)braket
op_eq
id|INT_GET
c_func
(paren
id|agf-&gt;agf_levels
(braket
id|XFS_BTNUM_CNTi
)braket
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|XFS_BUF_SET_VTYPE_REF
c_func
(paren
id|bp
comma
id|B_FS_AGF
comma
id|XFS_AGF_REF
)paren
suffix:semicolon
op_star
id|bpp
op_assign
id|bp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate an extent (variable-size).&n; * Depending on the allocation type, we either look in a single allocation&n; * group or loop over the allocation groups to find the result.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_alloc_vextent
id|xfs_alloc_vextent
c_func
(paren
id|xfs_alloc_arg_t
op_star
id|args
)paren
multiline_comment|/* allocation argument structure */
(brace
id|xfs_agblock_t
id|agsize
suffix:semicolon
multiline_comment|/* allocation group size */
r_int
id|error
suffix:semicolon
r_int
id|flags
suffix:semicolon
multiline_comment|/* XFS_ALLOC_FLAG_... locking flags */
macro_line|#ifdef XFS_ALLOC_TRACE
r_static
r_char
id|fname
(braket
)braket
op_assign
l_string|&quot;xfs_alloc_vextent&quot;
suffix:semicolon
macro_line|#endif
id|xfs_extlen_t
id|minleft
suffix:semicolon
multiline_comment|/* minimum left value, temp copy */
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
multiline_comment|/* mount structure pointer */
id|xfs_agnumber_t
id|sagno
suffix:semicolon
multiline_comment|/* starting allocation group number */
id|xfs_alloctype_t
id|type
suffix:semicolon
multiline_comment|/* input allocation type */
r_int
id|bump_rotor
op_assign
l_int|0
suffix:semicolon
r_int
id|no_min
op_assign
l_int|0
suffix:semicolon
id|xfs_agnumber_t
id|rotorstep
op_assign
id|xfs_rotorstep
suffix:semicolon
multiline_comment|/* inode32 agf stepper */
id|mp
op_assign
id|args-&gt;mp
suffix:semicolon
id|type
op_assign
id|args-&gt;otype
op_assign
id|args-&gt;type
suffix:semicolon
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
multiline_comment|/*&n;&t; * Just fix this up, for the case where the last a.g. is shorter&n;&t; * (or there&squot;s only one a.g.) and the caller couldn&squot;t easily figure&n;&t; * that out (xfs_bmap_alloc).&n;&t; */
id|agsize
op_assign
id|mp-&gt;m_sb.sb_agblocks
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;maxlen
OG
id|agsize
)paren
id|args-&gt;maxlen
op_assign
id|agsize
suffix:semicolon
r_if
c_cond
(paren
id|args-&gt;alignment
op_eq
l_int|0
)paren
id|args-&gt;alignment
op_assign
l_int|1
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
OL
id|mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
OL
id|agsize
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;minlen
op_le
id|args-&gt;maxlen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;minlen
op_le
id|agsize
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;mod
OL
id|args-&gt;prod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
op_ge
id|mp-&gt;m_sb.sb_agcount
op_logical_or
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
op_ge
id|agsize
op_logical_or
id|args-&gt;minlen
OG
id|args-&gt;maxlen
op_logical_or
id|args-&gt;minlen
OG
id|agsize
op_logical_or
id|args-&gt;mod
op_ge
id|args-&gt;prod
)paren
(brace
id|args-&gt;fsbno
op_assign
id|NULLFSBLOCK
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;badargs&quot;
comma
id|args
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|minleft
op_assign
id|args-&gt;minleft
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|XFS_ALLOCTYPE_THIS_AG
suffix:colon
r_case
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:colon
r_case
id|XFS_ALLOCTYPE_THIS_BNO
suffix:colon
multiline_comment|/*&n;&t;&t; * These three force us into a single a.g.&n;&t;&t; */
id|args-&gt;agno
op_assign
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|args-&gt;pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|args-&gt;agno
)braket
suffix:semicolon
id|args-&gt;minleft
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_alloc_fix_freelist
c_func
(paren
id|args
comma
l_int|0
)paren
suffix:semicolon
id|args-&gt;minleft
op_assign
id|minleft
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;nofix&quot;
comma
id|args
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|args-&gt;agbp
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;noagbp&quot;
comma
id|args
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|args-&gt;agbno
op_assign
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_ag_vextent
c_func
(paren
id|args
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|XFS_ALLOCTYPE_START_BNO
suffix:colon
multiline_comment|/*&n;&t;&t; * Try near allocation first, then anywhere-in-ag after&n;&t;&t; * the first a.g. fails.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|args-&gt;userdata
op_eq
id|XFS_ALLOC_INITIAL_USER_DATA
)paren
op_logical_and
(paren
id|mp-&gt;m_flags
op_amp
id|XFS_MOUNT_32BITINODES
)paren
)paren
(brace
id|args-&gt;fsbno
op_assign
id|XFS_AGB_TO_FSB
c_func
(paren
id|mp
comma
(paren
(paren
id|mp-&gt;m_agfrotor
op_div
id|rotorstep
)paren
op_mod
id|mp-&gt;m_sb.sb_agcount
)paren
comma
l_int|0
)paren
suffix:semicolon
id|bump_rotor
op_assign
l_int|1
suffix:semicolon
)brace
id|args-&gt;agbno
op_assign
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
suffix:semicolon
id|args-&gt;type
op_assign
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|XFS_ALLOCTYPE_ANY_AG
suffix:colon
r_case
id|XFS_ALLOCTYPE_START_AG
suffix:colon
r_case
id|XFS_ALLOCTYPE_FIRST_AG
suffix:colon
multiline_comment|/*&n;&t;&t; * Rotate through the allocation groups looking for a winner.&n;&t;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|XFS_ALLOCTYPE_ANY_AG
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Start with the last place we left off.&n;&t;&t;&t; */
id|args-&gt;agno
op_assign
id|sagno
op_assign
(paren
id|mp-&gt;m_agfrotor
op_div
id|rotorstep
)paren
op_mod
id|mp-&gt;m_sb.sb_agcount
suffix:semicolon
id|args-&gt;type
op_assign
id|XFS_ALLOCTYPE_THIS_AG
suffix:semicolon
id|flags
op_assign
id|XFS_ALLOC_FLAG_TRYLOCK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|XFS_ALLOCTYPE_FIRST_AG
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Start with allocation group given by bno.&n;&t;&t;&t; */
id|args-&gt;agno
op_assign
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
suffix:semicolon
id|args-&gt;type
op_assign
id|XFS_ALLOCTYPE_THIS_AG
suffix:semicolon
id|sagno
op_assign
l_int|0
suffix:semicolon
id|flags
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|type
op_eq
id|XFS_ALLOCTYPE_START_AG
)paren
id|args-&gt;type
op_assign
id|XFS_ALLOCTYPE_THIS_AG
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Start with the given allocation group.&n;&t;&t;&t; */
id|args-&gt;agno
op_assign
id|sagno
op_assign
id|XFS_FSB_TO_AGNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
suffix:semicolon
id|flags
op_assign
id|XFS_ALLOC_FLAG_TRYLOCK
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Loop over allocation groups twice; first time with&n;&t;&t; * trylock set, second time without.&n;&t;&t; */
id|down_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|args-&gt;pag
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|args-&gt;agno
)braket
suffix:semicolon
r_if
c_cond
(paren
id|no_min
)paren
id|args-&gt;minleft
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|xfs_alloc_fix_freelist
c_func
(paren
id|args
comma
id|flags
)paren
suffix:semicolon
id|args-&gt;minleft
op_assign
id|minleft
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;nofix&quot;
comma
id|args
)paren
suffix:semicolon
r_goto
id|error0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we get a buffer back then the allocation will fly.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;agbp
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_ag_vextent
c_func
(paren
id|args
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;loopfailed&quot;
comma
id|args
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Didn&squot;t work, figure out the next iteration.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;agno
op_eq
id|sagno
op_logical_and
id|type
op_eq
id|XFS_ALLOCTYPE_START_BNO
)paren
id|args-&gt;type
op_assign
id|XFS_ALLOCTYPE_THIS_AG
suffix:semicolon
r_if
c_cond
(paren
op_increment
(paren
id|args-&gt;agno
)paren
op_eq
id|mp-&gt;m_sb.sb_agcount
)paren
id|args-&gt;agno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Reached the starting a.g., must either be done&n;&t;&t;&t; * or switch to non-trylock mode.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|args-&gt;agno
op_eq
id|sagno
)paren
(brace
r_if
c_cond
(paren
id|no_min
op_eq
l_int|1
)paren
(brace
id|args-&gt;agbno
op_assign
id|NULLAGBLOCK
suffix:semicolon
id|TRACE_ALLOC
c_func
(paren
l_string|&quot;allfailed&quot;
comma
id|args
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_eq
l_int|0
)paren
(brace
id|no_min
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|XFS_ALLOCTYPE_START_BNO
)paren
(brace
id|args-&gt;agbno
op_assign
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
suffix:semicolon
id|args-&gt;type
op_assign
id|XFS_ALLOCTYPE_NEAR_BNO
suffix:semicolon
)brace
)brace
)brace
)brace
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bump_rotor
op_logical_or
(paren
id|type
op_eq
id|XFS_ALLOCTYPE_ANY_AG
)paren
)paren
(brace
r_if
c_cond
(paren
id|args-&gt;agno
op_eq
id|sagno
)paren
id|mp-&gt;m_agfrotor
op_assign
(paren
id|mp-&gt;m_agfrotor
op_plus
l_int|1
)paren
op_mod
(paren
id|mp-&gt;m_sb.sb_agcount
op_star
id|rotorstep
)paren
suffix:semicolon
r_else
id|mp-&gt;m_agfrotor
op_assign
(paren
id|args-&gt;agno
op_star
id|rotorstep
op_plus
l_int|1
)paren
op_mod
(paren
id|mp-&gt;m_sb.sb_agcount
op_star
id|rotorstep
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ASSERT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
r_if
c_cond
(paren
id|args-&gt;agbno
op_eq
id|NULLAGBLOCK
)paren
id|args-&gt;fsbno
op_assign
id|NULLFSBLOCK
suffix:semicolon
r_else
(brace
id|args-&gt;fsbno
op_assign
id|XFS_AGB_TO_FSB
c_func
(paren
id|mp
comma
id|args-&gt;agno
comma
id|args-&gt;agbno
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|ASSERT
c_func
(paren
id|args-&gt;len
op_ge
id|args-&gt;minlen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;len
op_le
id|args-&gt;maxlen
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args-&gt;agbno
op_mod
id|args-&gt;alignment
op_eq
l_int|0
)paren
suffix:semicolon
id|XFS_AG_CHECK_DADDR
c_func
(paren
id|mp
comma
id|XFS_FSB_TO_DADDR
c_func
(paren
id|mp
comma
id|args-&gt;fsbno
)paren
comma
id|args-&gt;len
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
id|error0
suffix:colon
id|up_read
c_func
(paren
op_amp
id|mp-&gt;m_peraglock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Free an extent.&n; * Just break up the extent address and hand off to xfs_free_ag_extent&n; * after fixing up the freelist.&n; */
r_int
multiline_comment|/* error */
DECL|function|xfs_free_extent
id|xfs_free_extent
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
multiline_comment|/* transaction pointer */
id|xfs_fsblock_t
id|bno
comma
multiline_comment|/* starting block number of extent */
id|xfs_extlen_t
id|len
)paren
multiline_comment|/* length of extent */
(brace
macro_line|#ifdef DEBUG
id|xfs_agf_t
op_star
id|agf
suffix:semicolon
multiline_comment|/* a.g. freespace header */
macro_line|#endif
id|xfs_alloc_arg_t
id|args
suffix:semicolon
multiline_comment|/* allocation argument structure */
r_int
id|error
suffix:semicolon
id|ASSERT
c_func
(paren
id|len
op_ne
l_int|0
)paren
suffix:semicolon
id|args.tp
op_assign
id|tp
suffix:semicolon
id|args.mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|args.agno
op_assign
id|XFS_FSB_TO_AGNO
c_func
(paren
id|args.mp
comma
id|bno
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args.agno
OL
id|args.mp-&gt;m_sb.sb_agcount
)paren
suffix:semicolon
id|args.agbno
op_assign
id|XFS_FSB_TO_AGBNO
c_func
(paren
id|args.mp
comma
id|bno
)paren
suffix:semicolon
id|args.alignment
op_assign
l_int|1
suffix:semicolon
id|args.minlen
op_assign
id|args.minleft
op_assign
id|args.minalignslop
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|args.mp-&gt;m_peraglock
)paren
suffix:semicolon
id|args.pag
op_assign
op_amp
id|args.mp-&gt;m_perag
(braket
id|args.agno
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|xfs_alloc_fix_freelist
c_func
(paren
op_amp
id|args
comma
l_int|0
)paren
)paren
)paren
r_goto
id|error0
suffix:semicolon
macro_line|#ifdef DEBUG
id|ASSERT
c_func
(paren
id|args.agbp
op_ne
l_int|NULL
)paren
suffix:semicolon
id|agf
op_assign
id|XFS_BUF_TO_AGF
c_func
(paren
id|args.agbp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|args.agbno
op_plus
id|len
op_le
id|INT_GET
c_func
(paren
id|agf-&gt;agf_length
comma
id|ARCH_CONVERT
)paren
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|xfs_free_ag_extent
c_func
(paren
id|tp
comma
id|args.agbp
comma
id|args.agno
comma
id|args.agbno
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
id|error0
suffix:colon
id|up_read
c_func
(paren
op_amp
id|args.mp-&gt;m_peraglock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * AG Busy list management&n; * The busy list contains block ranges that have been freed but whose&n; * transacations have not yet hit disk.  If any block listed in a busy&n; * list is reused, the transaction that freed it must be forced to disk&n; * before continuing to use the block.&n; *&n; * xfs_alloc_mark_busy - add to the per-ag busy list&n; * xfs_alloc_clear_busy - remove an item from the per-ag busy list&n; */
r_void
DECL|function|xfs_alloc_mark_busy
id|xfs_alloc_mark_busy
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_agnumber_t
id|agno
comma
id|xfs_agblock_t
id|bno
comma
id|xfs_extlen_t
id|len
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_perag_busy_t
op_star
id|bsy
suffix:semicolon
r_int
id|n
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_lock
)paren
suffix:semicolon
multiline_comment|/* search pagb_list for an open slot */
r_for
c_loop
(paren
id|bsy
op_assign
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
comma
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|XFS_PAGB_NUM_SLOTS
suffix:semicolon
id|bsy
op_increment
comma
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bsy-&gt;busy_tp
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|n
OL
id|XFS_PAGB_NUM_SLOTS
)paren
(brace
id|bsy
op_assign
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
(braket
id|n
)braket
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_count
op_increment
suffix:semicolon
id|TRACE_BUSY
c_func
(paren
l_string|&quot;xfs_alloc_mark_busy&quot;
comma
l_string|&quot;got&quot;
comma
id|agno
comma
id|bno
comma
id|len
comma
id|n
comma
id|tp
)paren
suffix:semicolon
id|bsy-&gt;busy_start
op_assign
id|bno
suffix:semicolon
id|bsy-&gt;busy_length
op_assign
id|len
suffix:semicolon
id|bsy-&gt;busy_tp
op_assign
id|tp
suffix:semicolon
id|xfs_trans_add_busy
c_func
(paren
id|tp
comma
id|agno
comma
id|n
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_BUSY
c_func
(paren
l_string|&quot;xfs_alloc_mark_busy&quot;
comma
l_string|&quot;FULL&quot;
comma
id|agno
comma
id|bno
comma
id|len
comma
op_minus
l_int|1
comma
id|tp
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The busy list is full!  Since it is now not possible to&n;&t;&t; * track the free block, make this a synchronous transaction&n;&t;&t; * to insure that the block is not reused before this&n;&t;&t; * transaction commits.&n;&t;&t; */
id|xfs_trans_set_sync
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_lock
comma
id|s
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_alloc_clear_busy
id|xfs_alloc_clear_busy
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_agnumber_t
id|agno
comma
r_int
id|idx
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_perag_busy_t
op_star
id|list
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_lock
)paren
suffix:semicolon
id|list
op_assign
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
suffix:semicolon
id|ASSERT
c_func
(paren
id|idx
OL
id|XFS_PAGB_NUM_SLOTS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list
(braket
id|idx
)braket
dot
id|busy_tp
op_eq
id|tp
)paren
(brace
id|TRACE_UNBUSY
c_func
(paren
l_string|&quot;xfs_alloc_clear_busy&quot;
comma
l_string|&quot;found&quot;
comma
id|agno
comma
id|idx
comma
id|tp
)paren
suffix:semicolon
id|list
(braket
id|idx
)braket
dot
id|busy_tp
op_assign
l_int|NULL
suffix:semicolon
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|TRACE_UNBUSY
c_func
(paren
l_string|&quot;xfs_alloc_clear_busy&quot;
comma
l_string|&quot;missing&quot;
comma
id|agno
comma
id|idx
comma
id|tp
)paren
suffix:semicolon
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_lock
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * returns non-zero if any of (agno,bno):len is in a busy list&n; */
r_int
DECL|function|xfs_alloc_search_busy
id|xfs_alloc_search_busy
c_func
(paren
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_agnumber_t
id|agno
comma
id|xfs_agblock_t
id|bno
comma
id|xfs_extlen_t
id|len
)paren
(brace
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_perag_busy_t
op_star
id|bsy
suffix:semicolon
r_int
id|n
suffix:semicolon
id|xfs_agblock_t
id|uend
comma
id|bend
suffix:semicolon
id|xfs_lsn_t
id|lsn
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|mp
op_assign
id|tp-&gt;t_mountp
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_lock
)paren
suffix:semicolon
id|cnt
op_assign
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_count
suffix:semicolon
id|uend
op_assign
id|bno
op_plus
id|len
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* search pagb_list for this slot, skipping open slots */
r_for
c_loop
(paren
id|bsy
op_assign
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_list
comma
id|n
op_assign
l_int|0
suffix:semicolon
id|cnt
suffix:semicolon
id|bsy
op_increment
comma
id|n
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * (start1,length1) within (start2, length2)&n;&t;&t; */
r_if
c_cond
(paren
id|bsy-&gt;busy_tp
op_ne
l_int|NULL
)paren
(brace
id|bend
op_assign
id|bsy-&gt;busy_start
op_plus
id|bsy-&gt;busy_length
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bno
OG
id|bend
)paren
op_logical_or
(paren
id|uend
OL
id|bsy-&gt;busy_start
)paren
)paren
(brace
id|cnt
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|TRACE_BUSYSEARCH
c_func
(paren
l_string|&quot;xfs_alloc_search_busy&quot;
comma
l_string|&quot;found1&quot;
comma
id|agno
comma
id|bno
comma
id|len
comma
id|n
comma
id|tp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If a block was found, force the log through the LSN of the&n;&t; * transaction that freed the block&n;&t; */
r_if
c_cond
(paren
id|cnt
)paren
(brace
id|TRACE_BUSYSEARCH
c_func
(paren
l_string|&quot;xfs_alloc_search_busy&quot;
comma
l_string|&quot;found&quot;
comma
id|agno
comma
id|bno
comma
id|len
comma
id|n
comma
id|tp
)paren
suffix:semicolon
id|lsn
op_assign
id|bsy-&gt;busy_tp-&gt;t_commit_lsn
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_lock
comma
id|s
)paren
suffix:semicolon
id|xfs_log_force
c_func
(paren
id|mp
comma
id|lsn
comma
id|XFS_LOG_FORCE
op_or
id|XFS_LOG_SYNC
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_BUSYSEARCH
c_func
(paren
l_string|&quot;xfs_alloc_search_busy&quot;
comma
l_string|&quot;not-found&quot;
comma
id|agno
comma
id|bno
comma
id|len
comma
id|n
comma
id|tp
)paren
suffix:semicolon
id|n
op_assign
op_minus
l_int|1
suffix:semicolon
id|mutex_spinunlock
c_func
(paren
op_amp
id|mp-&gt;m_perag
(braket
id|agno
)braket
dot
id|pagb_lock
comma
id|s
)paren
suffix:semicolon
)brace
r_return
id|n
suffix:semicolon
)brace
eof
