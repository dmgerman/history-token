multiline_comment|/*&n; * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of version 2 of the GNU General Public License as&n; * published by the Free Software Foundation.&n; *&n; * This program is distributed in the hope that it would be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&n; *&n; * Further, this software is distributed without any warranty that it is&n; * free of the rightful claim of any third person regarding infringement&n; * or the like.  Any license provided herein, whether implied or&n; * otherwise, applies only to this software file.  Patent licenses, if&n; * any, provided herein do not apply to combinations of this program with&n; * other software, or any other product whatsoever.&n; *&n; * You should have received a copy of the GNU General Public License along&n; * with this program; if not, write the Free Software Foundation, Inc., 59&n; * Temple Place - Suite 330, Boston MA 02111-1307, USA.&n; *&n; * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,&n; * Mountain View, CA  94043, or:&n; *&n; * http://www.sgi.com&n; *&n; * For further information regarding this notice, see:&n; *&n; * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/&n; */
macro_line|#include &quot;xfs.h&quot;
macro_line|#include &quot;xfs_macros.h&quot;
macro_line|#include &quot;xfs_types.h&quot;
macro_line|#include &quot;xfs_inum.h&quot;
macro_line|#include &quot;xfs_log.h&quot;
macro_line|#include &quot;xfs_trans.h&quot;
macro_line|#include &quot;xfs_sb.h&quot;
macro_line|#include &quot;xfs_ag.h&quot;
macro_line|#include &quot;xfs_dir.h&quot;
macro_line|#include &quot;xfs_dir2.h&quot;
macro_line|#include &quot;xfs_dmapi.h&quot;
macro_line|#include &quot;xfs_mount.h&quot;
macro_line|#include &quot;xfs_alloc_btree.h&quot;
macro_line|#include &quot;xfs_bmap_btree.h&quot;
macro_line|#include &quot;xfs_ialloc_btree.h&quot;
macro_line|#include &quot;xfs_btree.h&quot;
macro_line|#include &quot;xfs_ialloc.h&quot;
macro_line|#include &quot;xfs_attr_sf.h&quot;
macro_line|#include &quot;xfs_dir_sf.h&quot;
macro_line|#include &quot;xfs_dir2_sf.h&quot;
macro_line|#include &quot;xfs_dinode.h&quot;
macro_line|#include &quot;xfs_inode.h&quot;
macro_line|#include &quot;xfs_quota.h&quot;
macro_line|#include &quot;xfs_utils.h&quot;
macro_line|#include &quot;xfs_bit.h&quot;
multiline_comment|/*&n; * Initialize the inode hash table for the newly mounted file system.&n; * Choose an initial table size based on user specified value, else&n; * use a simple algorithm using the maximum number of inodes as an&n; * indicator for table size, and cap it at 16 pages (gettin&squot; big).&n; */
r_void
DECL|function|xfs_ihash_init
id|xfs_ihash_init
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|__uint64_t
id|icount
suffix:semicolon
id|uint
id|i
comma
id|flags
op_assign
id|KM_SLEEP
op_or
id|KM_MAYFAIL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;m_ihsize
)paren
(brace
id|icount
op_assign
id|mp-&gt;m_maxicount
ques
c_cond
id|mp-&gt;m_maxicount
suffix:colon
(paren
id|mp-&gt;m_sb.sb_dblocks
op_lshift
id|mp-&gt;m_sb.sb_inopblog
)paren
suffix:semicolon
id|mp-&gt;m_ihsize
op_assign
l_int|1
op_lshift
id|max_t
c_func
(paren
id|uint
comma
id|xfs_highbit64
c_func
(paren
id|icount
)paren
op_div
l_int|3
comma
l_int|8
)paren
suffix:semicolon
id|mp-&gt;m_ihsize
op_assign
id|min_t
c_func
(paren
id|uint
comma
id|mp-&gt;m_ihsize
comma
l_int|16
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|mp-&gt;m_ihash
op_assign
(paren
id|xfs_ihash_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
id|mp-&gt;m_ihsize
op_star
r_sizeof
(paren
id|xfs_ihash_t
)paren
comma
id|flags
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|mp-&gt;m_ihsize
op_rshift_assign
l_int|1
)paren
op_le
id|NBPP
)paren
id|flags
op_assign
id|KM_SLEEP
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;m_ihsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rwlock_init
c_func
(paren
op_amp
(paren
id|mp-&gt;m_ihash
(braket
id|i
)braket
dot
id|ih_lock
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Free up structures allocated by xfs_ihash_init, at unmount time.&n; */
r_void
DECL|function|xfs_ihash_free
id|xfs_ihash_free
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|kmem_free
c_func
(paren
id|mp-&gt;m_ihash
comma
id|mp-&gt;m_ihsize
op_star
r_sizeof
(paren
id|xfs_ihash_t
)paren
)paren
suffix:semicolon
id|mp-&gt;m_ihash
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the inode cluster hash table for the newly mounted file system.&n; * Its size is based on the ihash table size, with at least a page of entries.&n; */
r_void
DECL|function|xfs_chash_init
id|xfs_chash_init
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
id|uint
id|i
suffix:semicolon
id|mp-&gt;m_chsize
op_assign
id|max_t
c_func
(paren
id|uint
comma
id|NBPP
op_div
r_sizeof
(paren
id|xfs_chash_t
)paren
comma
id|mp-&gt;m_ihsize
op_div
(paren
id|XFS_INODE_CLUSTER_SIZE
c_func
(paren
id|mp
)paren
op_rshift
id|mp-&gt;m_sb.sb_inodelog
)paren
)paren
suffix:semicolon
id|mp-&gt;m_chash
op_assign
(paren
id|xfs_chash_t
op_star
)paren
id|kmem_zalloc
c_func
(paren
id|mp-&gt;m_chsize
op_star
r_sizeof
(paren
id|xfs_chash_t
)paren
comma
id|KM_SLEEP
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;m_chsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|spinlock_init
c_func
(paren
op_amp
id|mp-&gt;m_chash
(braket
id|i
)braket
dot
id|ch_lock
comma
l_string|&quot;xfshash&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Free up structures allocated by xfs_chash_init, at unmount time.&n; */
r_void
DECL|function|xfs_chash_free
id|xfs_chash_free
c_func
(paren
id|xfs_mount_t
op_star
id|mp
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;m_chsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|spinlock_destroy
c_func
(paren
op_amp
id|mp-&gt;m_chash
(braket
id|i
)braket
dot
id|ch_lock
)paren
suffix:semicolon
)brace
id|kmem_free
c_func
(paren
id|mp-&gt;m_chash
comma
id|mp-&gt;m_chsize
op_star
r_sizeof
(paren
id|xfs_chash_t
)paren
)paren
suffix:semicolon
id|mp-&gt;m_chash
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up an inode by number in the given file system.&n; * The inode is looked up in the hash table for the file system&n; * represented by the mount point parameter mp.  Each bucket of&n; * the hash table is guarded by an individual semaphore.&n; *&n; * If the inode is found in the hash table, its corresponding vnode&n; * is obtained with a call to vn_get().  This call takes care of&n; * coordination with the reclamation of the inode and vnode.  Note&n; * that the vmap structure is filled in while holding the hash lock.&n; * This gives us the state of the inode/vnode when we found it and&n; * is used for coordination in vn_get().&n; *&n; * If it is not in core, read it in from the file system&squot;s device and&n; * add the inode into the hash table.&n; *&n; * The inode is locked according to the value of the lock_flags parameter.&n; * This flag parameter indicates how and if the inode&squot;s IO lock and inode lock&n; * should be taken.&n; *&n; * mp -- the mount point structure for the current file system.  It points&n; *       to the inode hash table.&n; * tp -- a pointer to the current transaction if there is one.  This is&n; *       simply passed through to the xfs_iread() call.&n; * ino -- the number of the inode desired.  This is the unique identifier&n; *        within the file system for the inode being requested.&n; * lock_flags -- flags indicating how to lock the inode.  See the comment&n; *&t;&t; for xfs_ilock() for a list of valid values.&n; * bno -- the block number starting the buffer containing the inode,&n; *&t;  if known (as by bulkstat), else 0.&n; */
id|STATIC
r_int
DECL|function|xfs_iget_core
id|xfs_iget_core
c_func
(paren
id|vnode_t
op_star
id|vp
comma
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_ino_t
id|ino
comma
id|uint
id|flags
comma
id|uint
id|lock_flags
comma
id|xfs_inode_t
op_star
op_star
id|ipp
comma
id|xfs_daddr_t
id|bno
)paren
(brace
id|xfs_ihash_t
op_star
id|ih
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|xfs_inode_t
op_star
id|iq
suffix:semicolon
id|vnode_t
op_star
id|inode_vp
suffix:semicolon
id|ulong
id|version
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* REFERENCED */
id|xfs_chash_t
op_star
id|ch
suffix:semicolon
id|xfs_chashlist_t
op_star
id|chl
comma
op_star
id|chlnew
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|ih
op_assign
id|XFS_IHASH
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|again
suffix:colon
id|read_lock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ip
op_assign
id|ih-&gt;ih_next
suffix:semicolon
id|ip
op_ne
l_int|NULL
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_next
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_ino
op_eq
id|ino
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If INEW is set this inode is being set up&n;&t;&t;&t; * we need to pause and try again.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_flags
op_amp
id|XFS_INEW
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
id|delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_frecycle
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|inode_vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode_vp
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * If IRECLAIM is set this inode is&n;&t;&t;&t;&t; * on its way out of the system,&n;&t;&t;&t;&t; * we need to pause and try again.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_flags
op_amp
id|XFS_IRECLAIM
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
id|delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_frecycle
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|vn_trace_exit
c_func
(paren
id|vp
comma
l_string|&quot;xfs_iget.alloc&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_found
)paren
suffix:semicolon
id|ip-&gt;i_flags
op_and_assign
op_complement
id|XFS_IRECLAIMABLE
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|ip-&gt;i_reclaim
)paren
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_goto
id|finish_inode
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|vp
op_ne
id|inode_vp
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|inode_vp
)paren
suffix:semicolon
multiline_comment|/* The inode is being torn down, pause and&n;&t;&t;&t;&t; * try again.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_state
op_amp
(paren
id|I_FREEING
op_or
id|I_CLEAR
)paren
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
id|delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_frecycle
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/* Chances are the other vnode (the one in the inode) is being torn&n; * down right now, and we landed on top of it. Question is, what do&n; * we do? Unhook the old inode and hook up the new one?&n; */
id|cmn_err
c_func
(paren
id|CE_PANIC
comma
l_string|&quot;xfs_iget_core: ambiguous vns: vp/0x%p, invp/0x%p&quot;
comma
id|inode_vp
comma
id|vp
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_found
)paren
suffix:semicolon
id|finish_inode
suffix:colon
r_if
c_cond
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|IGET_CREATE
)paren
)paren
r_return
id|ENOENT
suffix:semicolon
id|xfs_iocore_inode_reinit
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lock_flags
op_ne
l_int|0
)paren
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|ip-&gt;i_flags
op_and_assign
op_complement
id|XFS_ISTALE
suffix:semicolon
id|vn_trace_exit
c_func
(paren
id|vp
comma
l_string|&quot;xfs_iget.found&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
r_goto
id|return_ip
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Inode cache miss: save the hash chain version stamp and unlock&n;&t; * the chain, so we don&squot;t deadlock in vn_alloc.&n;&t; */
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_missed
)paren
suffix:semicolon
id|version
op_assign
id|ih-&gt;ih_version
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read the disk inode attributes into a new inode structure and get&n;&t; * a new vnode for it. This should also initialize i_ino and i_mount.&n;&t; */
id|error
op_assign
id|xfs_iread
c_func
(paren
id|mp
comma
id|tp
comma
id|ino
comma
op_amp
id|ip
comma
id|bno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|vn_trace_exit
c_func
(paren
id|vp
comma
l_string|&quot;xfs_iget.alloc&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|xfs_inode_lock_init
c_func
(paren
id|ip
comma
id|vp
)paren
suffix:semicolon
id|xfs_iocore_inode_init
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_flags
op_ne
l_int|0
)paren
(brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|IGET_CREATE
)paren
)paren
(brace
id|xfs_idestroy
c_func
(paren
id|ip
)paren
suffix:semicolon
r_return
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Put ip on its hash chain, unless someone else hashed a duplicate&n;&t; * after we released the hash lock.&n;&t; */
id|write_lock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ih-&gt;ih_version
op_ne
id|version
)paren
(brace
r_for
c_loop
(paren
id|iq
op_assign
id|ih-&gt;ih_next
suffix:semicolon
id|iq
op_ne
l_int|NULL
suffix:semicolon
id|iq
op_assign
id|iq-&gt;i_next
)paren
(brace
r_if
c_cond
(paren
id|iq-&gt;i_ino
op_eq
id|ino
)paren
(brace
id|write_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
id|xfs_idestroy
c_func
(paren
id|ip
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_dup
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * These values _must_ be set before releasing ihlock!&n;&t; */
id|ip-&gt;i_hash
op_assign
id|ih
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iq
op_assign
id|ih-&gt;ih_next
)paren
)paren
(brace
id|iq-&gt;i_prevp
op_assign
op_amp
id|ip-&gt;i_next
suffix:semicolon
)brace
id|ip-&gt;i_next
op_assign
id|iq
suffix:semicolon
id|ip-&gt;i_prevp
op_assign
op_amp
id|ih-&gt;ih_next
suffix:semicolon
id|ih-&gt;ih_next
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_udquot
op_assign
id|ip-&gt;i_gdquot
op_assign
l_int|NULL
suffix:semicolon
id|ih-&gt;ih_version
op_increment
suffix:semicolon
id|ip-&gt;i_flags
op_or_assign
id|XFS_INEW
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * put ip on its cluster&squot;s hash chain&n;&t; */
id|ASSERT
c_func
(paren
id|ip-&gt;i_chash
op_eq
l_int|NULL
op_logical_and
id|ip-&gt;i_cprev
op_eq
l_int|NULL
op_logical_and
id|ip-&gt;i_cnext
op_eq
l_int|NULL
)paren
suffix:semicolon
id|chlnew
op_assign
l_int|NULL
suffix:semicolon
id|ch
op_assign
id|XFS_CHASH
c_func
(paren
id|mp
comma
id|ip-&gt;i_blkno
)paren
suffix:semicolon
id|chlredo
suffix:colon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|chl
op_assign
id|ch-&gt;ch_list
suffix:semicolon
id|chl
op_ne
l_int|NULL
suffix:semicolon
id|chl
op_assign
id|chl-&gt;chl_next
)paren
(brace
r_if
c_cond
(paren
id|chl-&gt;chl_blkno
op_eq
id|ip-&gt;i_blkno
)paren
(brace
multiline_comment|/* insert this inode into the doubly-linked list&n;&t;&t;&t; * where chl points */
r_if
c_cond
(paren
(paren
id|iq
op_assign
id|chl-&gt;chl_ip
)paren
)paren
(brace
id|ip-&gt;i_cprev
op_assign
id|iq-&gt;i_cprev
suffix:semicolon
id|iq-&gt;i_cprev-&gt;i_cnext
op_assign
id|ip
suffix:semicolon
id|iq-&gt;i_cprev
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_cnext
op_assign
id|iq
suffix:semicolon
)brace
r_else
(brace
id|ip-&gt;i_cnext
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_cprev
op_assign
id|ip
suffix:semicolon
)brace
id|chl-&gt;chl_ip
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_chash
op_assign
id|chl
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* no hash list found for this block; add a new hash list */
r_if
c_cond
(paren
id|chl
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|chlnew
op_eq
l_int|NULL
)paren
(brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|s
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|xfs_chashlist_zone
op_ne
l_int|NULL
)paren
suffix:semicolon
id|chlnew
op_assign
(paren
id|xfs_chashlist_t
op_star
)paren
id|kmem_zone_alloc
c_func
(paren
id|xfs_chashlist_zone
comma
id|KM_SLEEP
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|chlnew
op_ne
l_int|NULL
)paren
suffix:semicolon
r_goto
id|chlredo
suffix:semicolon
)brace
r_else
(brace
id|ip-&gt;i_cnext
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_cprev
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_chash
op_assign
id|chlnew
suffix:semicolon
id|chlnew-&gt;chl_ip
op_assign
id|ip
suffix:semicolon
id|chlnew-&gt;chl_blkno
op_assign
id|ip-&gt;i_blkno
suffix:semicolon
id|chlnew-&gt;chl_next
op_assign
id|ch-&gt;ch_list
suffix:semicolon
id|ch-&gt;ch_list
op_assign
id|chlnew
suffix:semicolon
id|chlnew
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|chlnew
op_ne
l_int|NULL
)paren
(brace
id|kmem_zone_free
c_func
(paren
id|xfs_chashlist_zone
comma
id|chlnew
)paren
suffix:semicolon
)brace
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Link ip to its mount and thread it on the mount&squot;s inode list.&n;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iq
op_assign
id|mp-&gt;m_inodes
)paren
)paren
(brace
id|ASSERT
c_func
(paren
id|iq-&gt;i_mprev-&gt;i_mnext
op_eq
id|iq
)paren
suffix:semicolon
id|ip-&gt;i_mprev
op_assign
id|iq-&gt;i_mprev
suffix:semicolon
id|iq-&gt;i_mprev-&gt;i_mnext
op_assign
id|ip
suffix:semicolon
id|iq-&gt;i_mprev
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_mnext
op_assign
id|iq
suffix:semicolon
)brace
r_else
(brace
id|ip-&gt;i_mnext
op_assign
id|ip
suffix:semicolon
id|ip-&gt;i_mprev
op_assign
id|ip
suffix:semicolon
)brace
id|mp-&gt;m_inodes
op_assign
id|ip
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|return_ip
suffix:colon
id|ASSERT
c_func
(paren
id|ip-&gt;i_df.if_ext_max
op_eq
id|XFS_IFORK_DSIZE
c_func
(paren
id|ip
)paren
op_div
r_sizeof
(paren
id|xfs_bmbt_rec_t
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
(paren
id|ip-&gt;i_d.di_flags
op_amp
id|XFS_DIFLAG_REALTIME
)paren
op_ne
l_int|0
)paren
op_eq
(paren
(paren
id|ip-&gt;i_iocore.io_flags
op_amp
id|XFS_IOCORE_RT
)paren
op_ne
l_int|0
)paren
)paren
suffix:semicolon
op_star
id|ipp
op_assign
id|ip
suffix:semicolon
multiline_comment|/*&n;&t; * If we have a real type for an on-disk inode, we can set ops(&amp;unlock)&n;&t; * now.&t; If it&squot;s a new inode being created, xfs_ialloc will handle it.&n;&t; */
id|VFS_INIT_VNODE
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
comma
id|vp
comma
id|XFS_ITOBHV
c_func
(paren
id|ip
)paren
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The &squot;normal&squot; internal xfs_iget, if needed it will&n; * &squot;allocate&squot;, or &squot;get&squot;, the vnode.&n; */
r_int
DECL|function|xfs_iget
id|xfs_iget
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_trans_t
op_star
id|tp
comma
id|xfs_ino_t
id|ino
comma
id|uint
id|flags
comma
id|uint
id|lock_flags
comma
id|xfs_inode_t
op_star
op_star
id|ipp
comma
id|xfs_daddr_t
id|bno
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|vnode_t
op_star
id|vp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
id|retry
suffix:colon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_attempts
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|iget_locked
c_func
(paren
id|XFS_MTOVFS
c_func
(paren
id|mp
)paren
op_member_access_from_pointer
id|vfs_super
comma
id|ino
)paren
)paren
)paren
(brace
id|bhv_desc_t
op_star
id|bdp
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
r_int
id|newnode
suffix:semicolon
id|vp
op_assign
id|LINVFS_GET_VP
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_state
op_amp
id|I_NEW
)paren
(brace
id|inode_allocate
suffix:colon
id|vn_initialize
c_func
(paren
id|inode
)paren
suffix:semicolon
id|error
op_assign
id|xfs_iget_core
c_func
(paren
id|vp
comma
id|mp
comma
id|tp
comma
id|ino
comma
id|flags
comma
id|lock_flags
comma
id|ipp
comma
id|bno
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|vn_mark_bad
c_func
(paren
id|vp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_state
op_amp
id|I_NEW
)paren
id|unlock_new_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* These are true if the inode is in inactive or&n;&t;&t;&t; * reclaim. The linux inode is about to go away,&n;&t;&t;&t; * wait for that path to finish, and try again.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vp-&gt;v_flag
op_amp
(paren
id|VINACT
op_or
id|VRECLM
)paren
)paren
(brace
id|vn_wait
c_func
(paren
id|vp
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_goto
id|retry
suffix:semicolon
)brace
id|bdp
op_assign
id|vn_bhv_lookup
c_func
(paren
id|VN_BHV_HEAD
c_func
(paren
id|vp
)paren
comma
op_amp
id|xfs_vnodeops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdp
op_eq
l_int|NULL
)paren
(brace
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_dup
)paren
suffix:semicolon
r_goto
id|inode_allocate
suffix:semicolon
)brace
id|ip
op_assign
id|XFS_BHVTOI
c_func
(paren
id|bdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_flags
op_ne
l_int|0
)paren
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|newnode
op_assign
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newnode
)paren
id|xfs_iocore_inode_reinit
c_func
(paren
id|ip
)paren
suffix:semicolon
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_found
)paren
suffix:semicolon
op_star
id|ipp
op_assign
id|ip
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|error
op_assign
id|ENOMEM
suffix:semicolon
multiline_comment|/* If we got no inode we are out of memory */
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Do the setup for the various locks within the incore inode.&n; */
r_void
DECL|function|xfs_inode_lock_init
id|xfs_inode_lock_init
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|vnode_t
op_star
id|vp
)paren
(brace
id|mrlock_init
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MRLOCK_ALLOW_EQUAL_PRI
op_or
id|MRLOCK_BARRIER
comma
l_string|&quot;xfsino&quot;
comma
(paren
r_int
)paren
id|vp-&gt;v_number
)paren
suffix:semicolon
id|mrlock_init
c_func
(paren
op_amp
id|ip-&gt;i_iolock
comma
id|MRLOCK_BARRIER
comma
l_string|&quot;xfsio&quot;
comma
id|vp-&gt;v_number
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ip-&gt;i_ipin_wait
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|ip-&gt;i_pincount
comma
l_int|0
)paren
suffix:semicolon
id|init_sema
c_func
(paren
op_amp
id|ip-&gt;i_flock
comma
l_int|1
comma
l_string|&quot;xfsfino&quot;
comma
id|vp-&gt;v_number
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for the inode corresponding to the given ino in the hash table.&n; * If it is there and its i_transp pointer matches tp, return it.&n; * Otherwise, return NULL.&n; */
id|xfs_inode_t
op_star
DECL|function|xfs_inode_incore
id|xfs_inode_incore
c_func
(paren
id|xfs_mount_t
op_star
id|mp
comma
id|xfs_ino_t
id|ino
comma
id|xfs_trans_t
op_star
id|tp
)paren
(brace
id|xfs_ihash_t
op_star
id|ih
suffix:semicolon
id|xfs_inode_t
op_star
id|ip
suffix:semicolon
id|ih
op_assign
id|XFS_IHASH
c_func
(paren
id|mp
comma
id|ino
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ip
op_assign
id|ih-&gt;ih_next
suffix:semicolon
id|ip
op_ne
l_int|NULL
suffix:semicolon
id|ip
op_assign
id|ip-&gt;i_next
)paren
(brace
r_if
c_cond
(paren
id|ip-&gt;i_ino
op_eq
id|ino
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we find it and tp matches, return it.&n;&t;&t;&t; * Otherwise break from the loop and return&n;&t;&t;&t; * NULL.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ip-&gt;i_transp
op_eq
id|tp
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_return
(paren
id|ip
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement reference count of an inode structure and unlock it.&n; *&n; * ip -- the inode being released&n; * lock_flags -- this parameter indicates the inode&squot;s locks to be&n; *       to be released.  See the comment on xfs_iunlock() for a list&n; *&t; of valid values.&n; */
r_void
DECL|function|xfs_iput
id|xfs_iput
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|lock_flags
)paren
(brace
id|vnode_t
op_star
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
l_string|&quot;xfs_iput&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Special iput for brand-new inodes that are still locked&n; */
r_void
DECL|function|xfs_iput_new
id|xfs_iput_new
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|lock_flags
)paren
(brace
id|vnode_t
op_star
id|vp
op_assign
id|XFS_ITOV
c_func
(paren
id|ip
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|LINVFS_GET_IP
c_func
(paren
id|vp
)paren
suffix:semicolon
id|vn_trace_entry
c_func
(paren
id|vp
comma
l_string|&quot;xfs_iput_new&quot;
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_mode
op_eq
l_int|0
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|ip-&gt;i_flags
op_amp
id|XFS_IRECLAIMABLE
)paren
)paren
suffix:semicolon
id|vn_mark_bad
c_func
(paren
id|vp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_state
op_amp
id|I_NEW
)paren
id|unlock_new_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_flags
)paren
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_flags
)paren
suffix:semicolon
id|VN_RELE
c_func
(paren
id|vp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine embodies the part of the reclaim code that pulls&n; * the inode from the inode hash table and the mount structure&squot;s&n; * inode list.&n; * This should only be called from xfs_reclaim().&n; */
r_void
DECL|function|xfs_ireclaim
id|xfs_ireclaim
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|vnode_t
op_star
id|vp
suffix:semicolon
multiline_comment|/*&n;&t; * Remove from old hash list and mount list.&n;&t; */
id|XFS_STATS_INC
c_func
(paren
id|xs_ig_reclaims
)paren
suffix:semicolon
id|xfs_iextract
c_func
(paren
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Here we do a spurious inode lock in order to coordinate with&n;&t; * xfs_sync().  This is because xfs_sync() references the inodes&n;&t; * in the mount list without taking references on the corresponding&n;&t; * vnodes.  We make that OK here by ensuring that we wait until&n;&t; * the inode is unlocked in xfs_sync() before we go ahead and&n;&t; * free it.  We get both the regular lock and the io lock because&n;&t; * the xfs_sync() code may need to drop the regular one but will&n;&t; * still hold the io lock.&n;&t; */
id|xfs_ilock
c_func
(paren
id|ip
comma
id|XFS_ILOCK_EXCL
op_or
id|XFS_IOLOCK_EXCL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Release dquots (and their references) if any. An inode may escape&n;&t; * xfs_inactive and get here via vn_alloc-&gt;vn_reclaim path.&n;&t; */
id|XFS_QM_DQDETACH
c_func
(paren
id|ip-&gt;i_mount
comma
id|ip
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pull our behavior descriptor from the vnode chain.&n;&t; */
id|vp
op_assign
id|XFS_ITOV_NULL
c_func
(paren
id|ip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vp
)paren
(brace
id|vn_bhv_remove
c_func
(paren
id|VN_BHV_HEAD
c_func
(paren
id|vp
)paren
comma
id|XFS_ITOBHV
c_func
(paren
id|ip
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Free all memory associated with the inode.&n;&t; */
id|xfs_idestroy
c_func
(paren
id|ip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine removes an about-to-be-destroyed inode from&n; * all of the lists in which it is located with the exception&n; * of the behavior chain.&n; */
r_void
DECL|function|xfs_iextract
id|xfs_iextract
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|xfs_ihash_t
op_star
id|ih
suffix:semicolon
id|xfs_inode_t
op_star
id|iq
suffix:semicolon
id|xfs_mount_t
op_star
id|mp
suffix:semicolon
id|xfs_chash_t
op_star
id|ch
suffix:semicolon
id|xfs_chashlist_t
op_star
id|chl
comma
op_star
id|chm
suffix:semicolon
id|SPLDECL
c_func
(paren
id|s
)paren
suffix:semicolon
id|ih
op_assign
id|ip-&gt;i_hash
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iq
op_assign
id|ip-&gt;i_next
)paren
)paren
(brace
id|iq-&gt;i_prevp
op_assign
id|ip-&gt;i_prevp
suffix:semicolon
)brace
op_star
id|ip-&gt;i_prevp
op_assign
id|iq
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|ih-&gt;ih_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove from cluster hash list&n;&t; *   1) delete the chashlist if this is the last inode on the chashlist&n;&t; *   2) unchain from list of inodes&n;&t; *   3) point chashlist-&gt;chl_ip to &squot;chl_next&squot; if to this inode.&n;&t; */
id|mp
op_assign
id|ip-&gt;i_mount
suffix:semicolon
id|ch
op_assign
id|XFS_CHASH
c_func
(paren
id|mp
comma
id|ip-&gt;i_blkno
)paren
suffix:semicolon
id|s
op_assign
id|mutex_spinlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_cnext
op_eq
id|ip
)paren
(brace
multiline_comment|/* Last inode on chashlist */
id|ASSERT
c_func
(paren
id|ip-&gt;i_cnext
op_eq
id|ip
op_logical_and
id|ip-&gt;i_cprev
op_eq
id|ip
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|ip-&gt;i_chash
op_ne
l_int|NULL
)paren
suffix:semicolon
id|chm
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|chl
op_assign
id|ch-&gt;ch_list
suffix:semicolon
id|chl
op_ne
l_int|NULL
suffix:semicolon
id|chl
op_assign
id|chl-&gt;chl_next
)paren
(brace
r_if
c_cond
(paren
id|chl-&gt;chl_blkno
op_eq
id|ip-&gt;i_blkno
)paren
(brace
r_if
c_cond
(paren
id|chm
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* first item on the list */
id|ch-&gt;ch_list
op_assign
id|chl-&gt;chl_next
suffix:semicolon
)brace
r_else
(brace
id|chm-&gt;chl_next
op_assign
id|chl-&gt;chl_next
suffix:semicolon
)brace
id|kmem_zone_free
c_func
(paren
id|xfs_chashlist_zone
comma
id|chl
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|ASSERT
c_func
(paren
id|chl-&gt;chl_ip
op_ne
id|ip
)paren
suffix:semicolon
id|chm
op_assign
id|chl
suffix:semicolon
)brace
)brace
id|ASSERT_ALWAYS
c_func
(paren
id|chl
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* delete one inode from a non-empty list */
id|iq
op_assign
id|ip-&gt;i_cnext
suffix:semicolon
id|iq-&gt;i_cprev
op_assign
id|ip-&gt;i_cprev
suffix:semicolon
id|ip-&gt;i_cprev-&gt;i_cnext
op_assign
id|iq
suffix:semicolon
r_if
c_cond
(paren
id|ip-&gt;i_chash-&gt;chl_ip
op_eq
id|ip
)paren
(brace
id|ip-&gt;i_chash-&gt;chl_ip
op_assign
id|iq
suffix:semicolon
)brace
id|ip-&gt;i_chash
op_assign
id|__return_address
suffix:semicolon
id|ip-&gt;i_cprev
op_assign
id|__return_address
suffix:semicolon
id|ip-&gt;i_cnext
op_assign
id|__return_address
suffix:semicolon
)brace
id|mutex_spinunlock
c_func
(paren
op_amp
id|ch-&gt;ch_lock
comma
id|s
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove from mount&squot;s inode list.&n;&t; */
id|XFS_MOUNT_ILOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|ip-&gt;i_mnext
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|ip-&gt;i_mprev
op_ne
l_int|NULL
)paren
)paren
suffix:semicolon
id|iq
op_assign
id|ip-&gt;i_mnext
suffix:semicolon
id|iq-&gt;i_mprev
op_assign
id|ip-&gt;i_mprev
suffix:semicolon
id|ip-&gt;i_mprev-&gt;i_mnext
op_assign
id|iq
suffix:semicolon
multiline_comment|/*&n;&t; * Fix up the head pointer if it points to the inode being deleted.&n;&t; */
r_if
c_cond
(paren
id|mp-&gt;m_inodes
op_eq
id|ip
)paren
(brace
r_if
c_cond
(paren
id|ip
op_eq
id|iq
)paren
(brace
id|mp-&gt;m_inodes
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|mp-&gt;m_inodes
op_assign
id|iq
suffix:semicolon
)brace
)brace
multiline_comment|/* Deal with the deleted inodes list */
id|list_del_init
c_func
(paren
op_amp
id|ip-&gt;i_reclaim
)paren
suffix:semicolon
id|mp-&gt;m_ireclaims
op_increment
suffix:semicolon
id|XFS_MOUNT_IUNLOCK
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a wrapper routine around the xfs_ilock() routine&n; * used to centralize some grungy code.  It is used in places&n; * that wish to lock the inode solely for reading the extents.&n; * The reason these places can&squot;t just call xfs_ilock(SHARED)&n; * is that the inode lock also guards to bringing in of the&n; * extents from disk for a file in b-tree format.  If the inode&n; * is in b-tree format, then we need to lock the inode exclusively&n; * until the extents are read in.  Locking it exclusively all&n; * the time would limit our parallelism unnecessarily, though.&n; * What we do instead is check to see if the extents have been&n; * read in yet, and only lock the inode exclusively if they&n; * have not.&n; *&n; * The function returns a value which should be given to the&n; * corresponding xfs_iunlock_map_shared().  This value is&n; * the mode in which the lock was actually taken.&n; */
id|uint
DECL|function|xfs_ilock_map_shared
id|xfs_ilock_map_shared
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|uint
id|lock_mode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ip-&gt;i_d.di_format
op_eq
id|XFS_DINODE_FMT_BTREE
)paren
op_logical_and
(paren
(paren
id|ip-&gt;i_df.if_flags
op_amp
id|XFS_IFEXTENTS
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|lock_mode
op_assign
id|XFS_ILOCK_EXCL
suffix:semicolon
)brace
r_else
(brace
id|lock_mode
op_assign
id|XFS_ILOCK_SHARED
suffix:semicolon
)brace
id|xfs_ilock
c_func
(paren
id|ip
comma
id|lock_mode
)paren
suffix:semicolon
r_return
id|lock_mode
suffix:semicolon
)brace
multiline_comment|/*&n; * This is simply the unlock routine to go with xfs_ilock_map_shared().&n; * All it does is call xfs_iunlock() with the given lock_mode.&n; */
r_void
DECL|function|xfs_iunlock_map_shared
id|xfs_iunlock_map_shared
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
r_int
r_int
id|lock_mode
)paren
(brace
id|xfs_iunlock
c_func
(paren
id|ip
comma
id|lock_mode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The xfs inode contains 2 locks: a multi-reader lock called the&n; * i_iolock and a multi-reader lock called the i_lock.  This routine&n; * allows either or both of the locks to be obtained.&n; *&n; * The 2 locks should always be ordered so that the IO lock is&n; * obtained first in order to prevent deadlock.&n; *&n; * ip -- the inode being locked&n; * lock_flags -- this parameter indicates the inode&squot;s locks&n; *       to be locked.  It can be:&n; *&t;&t;XFS_IOLOCK_SHARED,&n; *&t;&t;XFS_IOLOCK_EXCL,&n; *&t;&t;XFS_ILOCK_SHARED,&n; *&t;&t;XFS_ILOCK_EXCL,&n; *&t;&t;XFS_IOLOCK_SHARED | XFS_ILOCK_SHARED,&n; *&t;&t;XFS_IOLOCK_SHARED | XFS_ILOCK_EXCL,&n; *&t;&t;XFS_IOLOCK_EXCL | XFS_ILOCK_SHARED,&n; *&t;&t;XFS_IOLOCK_EXCL | XFS_ILOCK_EXCL&n; */
r_void
DECL|function|xfs_ilock
id|xfs_ilock
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|lock_flags
)paren
(brace
multiline_comment|/*&n;&t; * You can&squot;t set both SHARED and EXCL for the same lock,&n;&t; * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,&n;&t; * and XFS_ILOCK_EXCL are valid values to set in lock_flags.&n;&t; */
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
(paren
id|XFS_IOLOCK_SHARED
op_or
id|XFS_IOLOCK_EXCL
)paren
)paren
op_ne
(paren
id|XFS_IOLOCK_SHARED
op_or
id|XFS_IOLOCK_EXCL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
(paren
id|XFS_ILOCK_SHARED
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
op_ne
(paren
id|XFS_ILOCK_SHARED
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
op_complement
id|XFS_LOCK_MASK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_EXCL
)paren
(brace
id|mrupdate
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_SHARED
)paren
(brace
id|mraccess
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_ILOCK_EXCL
)paren
(brace
id|mrupdate
c_func
(paren
op_amp
id|ip-&gt;i_lock
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_ILOCK_SHARED
)paren
(brace
id|mraccess
c_func
(paren
op_amp
id|ip-&gt;i_lock
)paren
suffix:semicolon
)brace
id|xfs_ilock_trace
c_func
(paren
id|ip
comma
l_int|1
comma
id|lock_flags
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is just like xfs_ilock(), except that the caller&n; * is guaranteed not to sleep.  It returns 1 if it gets&n; * the requested locks and 0 otherwise.  If the IO lock is&n; * obtained but the inode lock cannot be, then the IO lock&n; * is dropped before returning.&n; *&n; * ip -- the inode being locked&n; * lock_flags -- this parameter indicates the inode&squot;s locks to be&n; *       to be locked.  See the comment for xfs_ilock() for a list&n; *&t; of valid values.&n; *&n; */
r_int
DECL|function|xfs_ilock_nowait
id|xfs_ilock_nowait
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|lock_flags
)paren
(brace
r_int
id|iolocked
suffix:semicolon
r_int
id|ilocked
suffix:semicolon
multiline_comment|/*&n;&t; * You can&squot;t set both SHARED and EXCL for the same lock,&n;&t; * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,&n;&t; * and XFS_ILOCK_EXCL are valid values to set in lock_flags.&n;&t; */
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
(paren
id|XFS_IOLOCK_SHARED
op_or
id|XFS_IOLOCK_EXCL
)paren
)paren
op_ne
(paren
id|XFS_IOLOCK_SHARED
op_or
id|XFS_IOLOCK_EXCL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
(paren
id|XFS_ILOCK_SHARED
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
op_ne
(paren
id|XFS_ILOCK_SHARED
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
op_complement
id|XFS_LOCK_MASK
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|iolocked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_EXCL
)paren
(brace
id|iolocked
op_assign
id|mrtryupdate
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iolocked
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_SHARED
)paren
(brace
id|iolocked
op_assign
id|mrtryaccess
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iolocked
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_ILOCK_EXCL
)paren
(brace
id|ilocked
op_assign
id|mrtryupdate
c_func
(paren
op_amp
id|ip-&gt;i_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ilocked
)paren
(brace
r_if
c_cond
(paren
id|iolocked
)paren
(brace
id|mrunlock
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_ILOCK_SHARED
)paren
(brace
id|ilocked
op_assign
id|mrtryaccess
c_func
(paren
op_amp
id|ip-&gt;i_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ilocked
)paren
(brace
r_if
c_cond
(paren
id|iolocked
)paren
(brace
id|mrunlock
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|xfs_ilock_trace
c_func
(paren
id|ip
comma
l_int|2
comma
id|lock_flags
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * xfs_iunlock() is used to drop the inode locks acquired with&n; * xfs_ilock() and xfs_ilock_nowait().  The caller must pass&n; * in the flags given to xfs_ilock() or xfs_ilock_nowait() so&n; * that we know which locks to drop.&n; *&n; * ip -- the inode being unlocked&n; * lock_flags -- this parameter indicates the inode&squot;s locks to be&n; *       to be unlocked.  See the comment for xfs_ilock() for a list&n; *&t; of valid values for this parameter.&n; *&n; */
r_void
DECL|function|xfs_iunlock
id|xfs_iunlock
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|lock_flags
)paren
(brace
multiline_comment|/*&n;&t; * You can&squot;t set both SHARED and EXCL for the same lock,&n;&t; * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,&n;&t; * and XFS_ILOCK_EXCL are valid values to set in lock_flags.&n;&t; */
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
(paren
id|XFS_IOLOCK_SHARED
op_or
id|XFS_IOLOCK_EXCL
)paren
)paren
op_ne
(paren
id|XFS_IOLOCK_SHARED
op_or
id|XFS_IOLOCK_EXCL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
(paren
id|XFS_ILOCK_SHARED
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
op_ne
(paren
id|XFS_ILOCK_SHARED
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
op_complement
(paren
id|XFS_LOCK_MASK
op_or
id|XFS_IUNLOCK_NONOTIFY
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|lock_flags
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_flags
op_amp
(paren
id|XFS_IOLOCK_SHARED
op_or
id|XFS_IOLOCK_EXCL
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_SHARED
)paren
op_logical_or
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_iolock
comma
id|MR_ACCESS
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_EXCL
)paren
op_logical_or
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_iolock
comma
id|MR_UPDATE
)paren
)paren
)paren
suffix:semicolon
id|mrunlock
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lock_flags
op_amp
(paren
id|XFS_ILOCK_SHARED
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
(brace
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_ILOCK_SHARED
)paren
op_logical_or
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_ACCESS
)paren
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_ILOCK_EXCL
)paren
op_logical_or
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
)paren
)paren
suffix:semicolon
id|mrunlock
c_func
(paren
op_amp
id|ip-&gt;i_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Let the AIL know that this item has been unlocked in case&n;&t;&t; * it is in the AIL and anyone is waiting on it.  Don&squot;t do&n;&t;&t; * this if the caller has asked us not to.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|lock_flags
op_amp
id|XFS_IUNLOCK_NONOTIFY
)paren
op_logical_and
id|ip-&gt;i_itemp
op_ne
l_int|NULL
)paren
(brace
id|xfs_trans_unlocked_item
c_func
(paren
id|ip-&gt;i_mount
comma
(paren
id|xfs_log_item_t
op_star
)paren
(paren
id|ip-&gt;i_itemp
)paren
)paren
suffix:semicolon
)brace
)brace
id|xfs_ilock_trace
c_func
(paren
id|ip
comma
l_int|3
comma
id|lock_flags
comma
(paren
id|inst_t
op_star
)paren
id|__return_address
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * give up write locks.  the i/o lock cannot be held nested&n; * if it is being demoted.&n; */
r_void
DECL|function|xfs_ilock_demote
id|xfs_ilock_demote
c_func
(paren
id|xfs_inode_t
op_star
id|ip
comma
id|uint
id|lock_flags
)paren
(brace
id|ASSERT
c_func
(paren
id|lock_flags
op_amp
(paren
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
(paren
id|lock_flags
op_amp
op_complement
(paren
id|XFS_IOLOCK_EXCL
op_or
id|XFS_ILOCK_EXCL
)paren
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_ILOCK_EXCL
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_lock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|mrdemote
c_func
(paren
op_amp
id|ip-&gt;i_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lock_flags
op_amp
id|XFS_IOLOCK_EXCL
)paren
(brace
id|ASSERT
c_func
(paren
id|ismrlocked
c_func
(paren
op_amp
id|ip-&gt;i_iolock
comma
id|MR_UPDATE
)paren
)paren
suffix:semicolon
id|mrdemote
c_func
(paren
op_amp
id|ip-&gt;i_iolock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The following three routines simply manage the i_flock&n; * semaphore embedded in the inode.  This semaphore synchronizes&n; * processes attempting to flush the in-core inode back to disk.&n; */
r_void
DECL|function|xfs_iflock
id|xfs_iflock
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|psema
c_func
(paren
op_amp
(paren
id|ip-&gt;i_flock
)paren
comma
id|PINOD
op_or
id|PLTWAIT
)paren
suffix:semicolon
)brace
r_int
DECL|function|xfs_iflock_nowait
id|xfs_iflock_nowait
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
r_return
(paren
id|cpsema
c_func
(paren
op_amp
(paren
id|ip-&gt;i_flock
)paren
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|xfs_ifunlock
id|xfs_ifunlock
c_func
(paren
id|xfs_inode_t
op_star
id|ip
)paren
(brace
id|ASSERT
c_func
(paren
id|valusema
c_func
(paren
op_amp
(paren
id|ip-&gt;i_flock
)paren
)paren
op_le
l_int|0
)paren
suffix:semicolon
id|vsema
c_func
(paren
op_amp
(paren
id|ip-&gt;i_flock
)paren
)paren
suffix:semicolon
)brace
eof
