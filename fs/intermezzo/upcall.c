multiline_comment|/*&n; * Mostly platform independent upcall operations to Venus:&n; *  -- upcalls&n; *  -- upcall routines&n; *&n; * Linux 2.0 version&n; * Copyright (C) 1996 Peter J. Braam &lt;braam@cs.cmu.edu&gt;,&n; * Michael Callahan &lt;callahan@maths.ox.ac.uk&gt;&n; *&n; * Redone for Linux 2.1&n; * Copyright (C) 1997 Carnegie Mellon University&n; *&n; * Carnegie Mellon University encourages users of this code to contribute&n; * improvements to the Coda project. Contact Peter Braam &lt;coda@cs.cmu.edu&gt;.&n; *&n; * Much cleaned up for InterMezzo&n; * Copyright (C) 1998 Peter J. Braam &lt;braam@cs.cmu.edu&gt;,&n; * Copyright (C) 1999 Carnegie Mellon University&n; *&n; */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/signal.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/intermezzo_fs.h&gt;
macro_line|#include &lt;linux/intermezzo_upcall.h&gt;
macro_line|#include &lt;linux/intermezzo_psdev.h&gt;
multiline_comment|/*&n;  At present: four upcalls&n;  - opendir: fetch a directory (synchronous &amp; asynchronous)&n;  - open: fetch file (synchronous)&n;  - journal: send a journal page (asynchronous)&n;  - permit: get a permit (synchronous)&n;&n;  Errors returned here are positive.&n;&n; */
DECL|macro|INSIZE
mdefine_line|#define INSIZE(tag) sizeof(struct lento_ ## tag ## _in)
DECL|macro|OUTSIZE
mdefine_line|#define OUTSIZE(tag) sizeof(struct lento_ ## tag ## _out)
DECL|macro|SIZE
mdefine_line|#define SIZE(tag)  ( (INSIZE(tag)&gt;OUTSIZE(tag)) ? INSIZE(tag) : OUTSIZE(tag) )
DECL|macro|UPARG
mdefine_line|#define UPARG(op)&bslash;&n;do {&bslash;&n;        PRESTO_ALLOC(inp, union up_args *, insize);&bslash;&n;        if ( !inp ) { return -ENOMEM; }&bslash;&n;        outp = (union down_args *) (inp);&bslash;&n;        inp-&gt;uh.opcode = (op);&bslash;&n;        inp-&gt;uh.pid = current-&gt;pid;&bslash;&n;        inp-&gt;uh.uid = current-&gt;fsuid;&bslash;&n;        outsize = insize;&bslash;&n;} while (0)
DECL|macro|BUFF_ALLOC
mdefine_line|#define BUFF_ALLOC(buffer)                              &bslash;&n;        PRESTO_ALLOC(buffer, char *, PAGE_SIZE);        &bslash;&n;        if ( !buffer ) {                                &bslash;&n;                printk(&quot;PRESTO: out of memory!&bslash;n&quot;);     &bslash;&n;                return -ENOMEM;                         &bslash;&n;        }
multiline_comment|/* the upcalls */
DECL|function|lento_kml
r_int
id|lento_kml
c_func
(paren
r_int
id|minor
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|first_recno
comma
r_int
r_int
id|length
comma
r_int
r_int
id|last_recno
comma
r_int
id|namelen
comma
r_char
op_star
id|fsetname
)paren
(brace
r_union
id|up_args
op_star
id|inp
suffix:semicolon
r_union
id|down_args
op_star
id|outp
suffix:semicolon
r_int
id|insize
comma
id|outsize
comma
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_lento_up
c_func
(paren
id|minor
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|insize
op_assign
id|SIZE
c_func
(paren
id|kml
)paren
op_plus
id|namelen
op_plus
l_int|1
suffix:semicolon
id|UPARG
c_func
(paren
id|LENTO_KML
)paren
suffix:semicolon
id|inp-&gt;lento_kml.namelen
op_assign
id|namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|inp-&gt;lento_kml.fsetname
comma
id|fsetname
comma
id|namelen
)paren
suffix:semicolon
id|inp-&gt;lento_kml.fsetname
(braket
id|namelen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|inp-&gt;lento_kml.offset
op_assign
id|offset
suffix:semicolon
id|inp-&gt;lento_kml.first_recno
op_assign
id|first_recno
suffix:semicolon
id|inp-&gt;lento_kml.length
op_assign
id|length
suffix:semicolon
id|inp-&gt;lento_kml.last_recno
op_assign
id|last_recno
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_UPCALL
comma
l_string|&quot;KML: fileset %s, offset %d, length %d, &quot;
l_string|&quot;first %d, last %d; minor %d&bslash;n&quot;
comma
id|inp-&gt;lento_kml.fsetname
comma
id|inp-&gt;lento_kml.offset
comma
id|inp-&gt;lento_kml.length
comma
id|inp-&gt;lento_kml.first_recno
comma
id|inp-&gt;lento_kml.last_recno
comma
id|minor
)paren
suffix:semicolon
id|error
op_assign
id|lento_upcall
c_func
(paren
id|minor
comma
id|insize
comma
op_amp
id|outsize
comma
id|inp
comma
id|ASYNCHRONOUS
comma
l_int|NULL
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|lento_release_permit
r_int
id|lento_release_permit
c_func
(paren
r_int
id|minor
comma
r_int
id|mycookie
)paren
(brace
r_union
id|up_args
op_star
id|inp
suffix:semicolon
r_union
id|down_args
op_star
id|outp
suffix:semicolon
r_int
id|insize
comma
id|outsize
comma
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_lento_up
c_func
(paren
id|minor
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|insize
op_assign
id|SIZE
c_func
(paren
id|response_cookie
)paren
suffix:semicolon
id|UPARG
c_func
(paren
id|LENTO_COOKIE
)paren
suffix:semicolon
id|inp-&gt;lento_response_cookie.cookie
op_assign
id|mycookie
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_UPCALL
comma
l_string|&quot;cookie %d&bslash;n&quot;
comma
id|mycookie
)paren
suffix:semicolon
id|error
op_assign
id|lento_upcall
c_func
(paren
id|minor
comma
id|insize
comma
op_amp
id|outsize
comma
id|inp
comma
id|ASYNCHRONOUS
comma
l_int|NULL
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|lento_opendir
r_int
id|lento_opendir
c_func
(paren
r_int
id|minor
comma
r_int
id|pathlen
comma
r_char
op_star
id|path
comma
r_int
id|async
)paren
(brace
r_union
id|up_args
op_star
id|inp
suffix:semicolon
r_union
id|down_args
op_star
id|outp
suffix:semicolon
r_int
id|insize
comma
id|outsize
comma
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|insize
op_assign
id|SIZE
c_func
(paren
id|opendir
)paren
op_plus
id|pathlen
op_plus
l_int|1
suffix:semicolon
id|UPARG
c_func
(paren
id|LENTO_OPENDIR
)paren
suffix:semicolon
id|inp-&gt;lento_opendir.async
op_assign
id|async
suffix:semicolon
id|inp-&gt;lento_opendir.pathlen
op_assign
id|pathlen
suffix:semicolon
id|memcpy
c_func
(paren
id|inp-&gt;lento_opendir.path
comma
id|path
comma
id|pathlen
)paren
suffix:semicolon
id|inp-&gt;lento_opendir.path
(braket
id|pathlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_UPCALL
comma
l_string|&quot;path %s&bslash;n&quot;
comma
id|inp-&gt;lento_opendir.path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|async
)paren
(brace
id|error
op_assign
id|lento_upcall
c_func
(paren
id|minor
comma
id|insize
comma
op_amp
id|outsize
comma
id|inp
comma
id|ASYNCHRONOUS
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|lento_upcall
c_func
(paren
id|minor
comma
id|insize
comma
op_amp
id|outsize
comma
id|inp
comma
id|SYNCHRONOUS
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_and
id|error
op_ne
id|EISFSETROOT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lento_opendir: error %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|lento_open
r_int
id|lento_open
c_func
(paren
r_int
id|minor
comma
r_int
id|pathlen
comma
r_char
op_star
id|path
)paren
(brace
r_union
id|up_args
op_star
id|inp
suffix:semicolon
r_union
id|down_args
op_star
id|outp
suffix:semicolon
r_int
id|insize
comma
id|outsize
comma
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|insize
op_assign
id|SIZE
c_func
(paren
id|open
)paren
op_plus
id|pathlen
op_plus
l_int|1
suffix:semicolon
id|UPARG
c_func
(paren
id|LENTO_OPEN
)paren
suffix:semicolon
id|inp-&gt;lento_open.pathlen
op_assign
id|pathlen
suffix:semicolon
id|memcpy
c_func
(paren
id|inp-&gt;lento_open.path
comma
id|path
comma
id|pathlen
)paren
suffix:semicolon
id|inp-&gt;lento_open.path
(braket
id|pathlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_UPCALL
comma
l_string|&quot;path %s&bslash;n&quot;
comma
id|inp-&gt;lento_open.path
)paren
suffix:semicolon
id|error
op_assign
id|lento_upcall
c_func
(paren
id|minor
comma
id|insize
comma
op_amp
id|outsize
comma
id|inp
comma
id|SYNCHRONOUS
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lento_open: error %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|lento_permit
r_int
id|lento_permit
c_func
(paren
r_int
id|minor
comma
r_int
id|pathlen
comma
r_int
id|fsetnamelen
comma
r_char
op_star
id|path
comma
r_char
op_star
id|fsetname
)paren
(brace
r_union
id|up_args
op_star
id|inp
suffix:semicolon
r_union
id|down_args
op_star
id|outp
suffix:semicolon
r_int
id|insize
comma
id|outsize
comma
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|insize
op_assign
id|SIZE
c_func
(paren
id|permit
)paren
op_plus
id|pathlen
op_plus
l_int|1
op_plus
id|fsetnamelen
op_plus
l_int|1
suffix:semicolon
id|UPARG
c_func
(paren
id|LENTO_PERMIT
)paren
suffix:semicolon
id|inp-&gt;lento_permit.pathlen
op_assign
id|pathlen
suffix:semicolon
id|inp-&gt;lento_permit.fsetnamelen
op_assign
id|fsetnamelen
suffix:semicolon
id|memcpy
c_func
(paren
id|inp-&gt;lento_permit.path
comma
id|path
comma
id|pathlen
)paren
suffix:semicolon
id|inp-&gt;lento_permit.path
(braket
id|pathlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|inp-&gt;lento_permit.path
(braket
id|pathlen
op_plus
l_int|1
)braket
)paren
comma
id|fsetname
comma
id|fsetnamelen
)paren
suffix:semicolon
id|inp-&gt;lento_permit.path
(braket
id|fsetnamelen
op_plus
l_int|1
op_plus
id|pathlen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_UPCALL
comma
l_string|&quot;Permit minor %d path %s&bslash;n&quot;
comma
id|minor
comma
id|inp-&gt;lento_permit.path
)paren
suffix:semicolon
id|error
op_assign
id|lento_upcall
c_func
(paren
id|minor
comma
id|insize
comma
op_amp
id|outsize
comma
id|inp
comma
id|SYNCHRONOUS
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EROFS
)paren
(brace
r_int
id|err
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;lento_permit: ERROR - requested permit for &quot;
l_string|&quot;read-only fileset.&bslash;n&quot;
l_string|&quot;   Setting &bslash;&quot;%s&bslash;&quot; read-only!&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
id|err
op_assign
id|presto_mark_cache
c_func
(paren
id|path
comma
l_int|0xFFFFFFFF
comma
id|CACHE_CLIENT_RO
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ERROR : mark_cache %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;lento_permit: error %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
)brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
