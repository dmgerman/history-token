multiline_comment|/*&n; * intermezzo.c&n; *&n; * This file implements basic routines supporting the semantics&n; *&n; * Author: Peter J. Braam  &lt;braam@cs.cmu.edu&gt;&n; * Copyright (C) 1998 Stelias Computing Inc&n; * Copyright (C) 1999 Red Hat Inc.&n; *&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/intermezzo_fs.h&gt;
macro_line|#include &lt;linux/intermezzo_upcall.h&gt;
macro_line|#include &lt;linux/intermezzo_psdev.h&gt;
macro_line|#include &lt;linux/intermezzo_kml.h&gt;
r_extern
r_int
id|presto_init_last_rcvd_file
c_func
(paren
r_struct
id|presto_file_set
op_star
)paren
suffix:semicolon
r_extern
r_int
id|presto_init_lml_file
c_func
(paren
r_struct
id|presto_file_set
op_star
)paren
suffix:semicolon
r_extern
r_int
id|presto_init_kml_file
c_func
(paren
r_struct
id|presto_file_set
op_star
)paren
suffix:semicolon
DECL|function|presto_walk
r_int
id|presto_walk
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* we do not follow symlinks to support symlink operations &n;           correctly. The vfs should always hand us resolved dentries&n;           so we should not be required to use LOOKUP_FOLLOW. At the&n;&t;   reintegrating end, lento again should be working with the &n;           resolved pathname and not the symlink. SHP&n;           XXX: This code implies that direct symlinks do not work. SHP&n;        */
r_int
r_int
id|flags
op_assign
id|LOOKUP_POSITIVE
suffix:semicolon
id|ENTRY
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|name
comma
id|flags
comma
id|nd
)paren
)paren
id|err
op_assign
id|path_walk
c_func
(paren
id|name
comma
id|nd
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|presto_d2d
r_inline
r_struct
id|presto_dentry_data
op_star
id|presto_d2d
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
(paren
r_struct
id|presto_dentry_data
op_star
)paren
id|dentry-&gt;d_fsdata
suffix:semicolon
)brace
DECL|function|presto_dentry2fset
r_static
r_inline
r_struct
id|presto_file_set
op_star
id|presto_dentry2fset
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_fsdata
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fucked dentry: %p&bslash;n&quot;
comma
id|dentry
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_fset
suffix:semicolon
)brace
multiline_comment|/* find the presto minor device for this inode */
DECL|function|presto_i2m
r_int
id|presto_i2m
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|presto_cache
op_star
id|cache
suffix:semicolon
id|ENTRY
suffix:semicolon
id|cache
op_assign
id|presto_get_cache
c_func
(paren
id|inode
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_PSDEV
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PRESTO: BAD: cannot find cache for dev %s, ino %ld&bslash;n&quot;
comma
id|inode-&gt;i_sb-&gt;s_id
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|EXIT
suffix:semicolon
r_return
id|cache-&gt;cache_psdev-&gt;uc_minor
suffix:semicolon
)brace
DECL|function|presto_f2m
r_inline
r_int
id|presto_f2m
c_func
(paren
r_struct
id|presto_file_set
op_star
id|fset
)paren
(brace
r_return
id|fset-&gt;fset_cache-&gt;cache_psdev-&gt;uc_minor
suffix:semicolon
)brace
DECL|function|presto_c2m
r_inline
r_int
id|presto_c2m
c_func
(paren
r_struct
id|presto_cache
op_star
id|cache
)paren
(brace
r_return
id|cache-&gt;cache_psdev-&gt;uc_minor
suffix:semicolon
)brace
DECL|function|presto_has_all_data
r_int
id|presto_has_all_data
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|ENTRY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;i_size
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
OG
id|inode-&gt;i_blocks
)paren
(brace
id|EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|EXIT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* find the fileset dentry for this dentry */
DECL|function|presto_fset
r_struct
id|presto_file_set
op_star
id|presto_fset
c_func
(paren
r_struct
id|dentry
op_star
id|de
)paren
(brace
r_struct
id|dentry
op_star
id|fsde
suffix:semicolon
id|ENTRY
suffix:semicolon
id|fsde
op_assign
id|de
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|presto_dentry2fset
c_func
(paren
id|fsde
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|presto_dentry2fset
c_func
(paren
id|fsde
)paren
suffix:semicolon
)brace
multiline_comment|/* are we at the cache &quot;/&quot; ?? */
r_if
c_cond
(paren
id|fsde-&gt;d_parent
op_eq
id|fsde
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;d_inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning %*s has no fileset inode.&bslash;n&quot;
comma
id|de-&gt;d_name.len
comma
id|de-&gt;d_name.name
)paren
suffix:semicolon
)brace
multiline_comment|/* better to return a BAD thing */
id|EXIT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|fsde
op_assign
id|fsde-&gt;d_parent
suffix:semicolon
)brace
multiline_comment|/* not reached */
id|EXIT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* XXX check this out */
DECL|function|presto_path2fileset
r_struct
id|presto_file_set
op_star
id|presto_path2fileset
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fileset
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|name
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
macro_line|#if 0
id|error
op_assign
id|do_revalidate
c_func
(paren
id|nd.dentry
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|fileset
op_assign
id|presto_fset
c_func
(paren
id|nd.dentry
)paren
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
)brace
r_else
id|fileset
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
id|fileset
suffix:semicolon
)brace
multiline_comment|/* check a flag on this dentry or fset root.  Semantics:&n;   - most flags: test if it is set&n;   - PRESTO_ATTR, PRESTO_DATA return 1 if PRESTO_FSETINSYNC is set&n;*/
DECL|function|presto_chk
r_int
id|presto_chk
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|flag
)paren
(brace
r_int
id|minor
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|ENTRY
suffix:semicolon
id|minor
op_assign
id|presto_i2m
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|upc_comms
(braket
id|minor
)braket
dot
id|uc_no_filter
)paren
(brace
id|EXIT
suffix:semicolon
r_return
op_complement
l_int|0
suffix:semicolon
)brace
multiline_comment|/* if the fileset is in sync DATA and ATTR are OK */
r_if
c_cond
(paren
id|fset
op_logical_and
(paren
id|flag
op_eq
id|PRESTO_ATTR
op_logical_or
id|flag
op_eq
id|PRESTO_DATA
)paren
op_logical_and
(paren
id|fset-&gt;fset_flags
op_amp
id|FSET_INSYNC
)paren
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;fset in sync (ino %ld)!&bslash;n&quot;
comma
id|fset-&gt;fset_mtpt-&gt;d_inode-&gt;i_ino
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|EXIT
suffix:semicolon
r_return
(paren
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_flags
op_amp
id|flag
)paren
suffix:semicolon
)brace
multiline_comment|/* set a bit in the dentry flags */
DECL|function|presto_set
r_void
id|presto_set
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|flag
)paren
(brace
id|ENTRY
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;SET ino %ld, flag %x&bslash;n&quot;
comma
id|dentry-&gt;d_inode-&gt;i_ino
comma
id|flag
)paren
suffix:semicolon
)brace
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_flags
op_or_assign
id|flag
suffix:semicolon
id|EXIT
suffix:semicolon
)brace
multiline_comment|/* given a path: complete the closes on the fset */
DECL|function|lento_complete_closes
r_int
id|lento_complete_closes
c_func
(paren
r_char
op_star
id|path
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|out_complete
suffix:semicolon
)brace
id|fset
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No fileset!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_complete
suffix:semicolon
)brace
multiline_comment|/* transactions and locking are internal to this function */
id|error
op_assign
id|presto_complete_lml
c_func
(paren
id|fset
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
id|out_complete
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* set the fset recno and offset to a given value */
DECL|function|lento_reset_fset
r_int
id|lento_reset_fset
c_func
(paren
r_char
op_star
id|path
comma
id|__u64
id|offset
comma
id|__u32
id|recno
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|out_complete
suffix:semicolon
)brace
id|fset
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No fileset!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_complete
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|fset-&gt;fset_kml.fd_lock
)paren
suffix:semicolon
id|fset-&gt;fset_kml.fd_recno
op_assign
id|recno
suffix:semicolon
id|fset-&gt;fset_kml.fd_offset
op_assign
id|offset
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|fset-&gt;fset_kml.fd_lock
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
id|out_complete
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* given a path, write an LML record for it - thus must have root&squot;s &n;   group array settings, since lento is doing this &n;*/
DECL|function|lento_write_lml
r_int
id|lento_write_lml
c_func
(paren
r_char
op_star
id|path
comma
id|__u64
id|remote_ino
comma
id|__u32
id|remote_generation
comma
id|__u32
id|remote_version
comma
r_struct
id|presto_version
op_star
id|remote_file_version
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|rec_info
id|rec
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|file.f_dentry
op_assign
id|dentry
suffix:semicolon
id|file.private_data
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|out_lml
suffix:semicolon
)brace
id|fset
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No fileset!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_lml
suffix:semicolon
)brace
multiline_comment|/* setting offset to -1 appends */
id|rec.offset
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* this only requires a transaction below which is automatic */
id|error
op_assign
id|presto_write_lml_close
c_func
(paren
op_amp
id|rec
comma
id|fset
comma
op_amp
id|file
comma
id|remote_ino
comma
id|remote_generation
comma
id|remote_version
comma
id|remote_file_version
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
id|out_lml
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* given a path: write a close record and cancel an LML record, finally&n;   call truncate LML.  Lento is doing this so it goes in with uid/gid&squot;s &n;   root. &n;*/
DECL|function|lento_cancel_lml
r_int
id|lento_cancel_lml
c_func
(paren
r_char
op_star
id|path
comma
id|__u64
id|lml_offset
comma
id|__u64
id|remote_ino
comma
id|__u32
id|remote_generation
comma
id|__u32
id|remote_version
comma
r_struct
id|lento_vfs_context
op_star
id|info
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|rec_info
id|rec
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_void
op_star
id|handle
suffix:semicolon
r_struct
id|presto_version
id|new_ver
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|out_cancel_lml
suffix:semicolon
)brace
id|fset
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|fset
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No fileset!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_cancel_lml
suffix:semicolon
)brace
multiline_comment|/* this only requires a transaction below which is automatic */
id|handle
op_assign
id|presto_trans_start
c_func
(paren
id|fset
comma
id|dentry-&gt;d_inode
comma
id|PRESTO_OP_RELEASE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_cancel_lml
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|LENTO_FL_CANCEL_LML
)paren
(brace
id|error
op_assign
id|presto_clear_lml_close
c_func
(paren
id|fset
comma
id|lml_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|presto_trans_commit
c_func
(paren
id|fset
comma
id|handle
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_cancel_lml
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|LENTO_FL_WRITE_KML
)paren
(brace
r_struct
id|file
id|file
suffix:semicolon
id|file.private_data
op_assign
l_int|NULL
suffix:semicolon
id|file.f_dentry
op_assign
id|dentry
suffix:semicolon
id|presto_getversion
c_func
(paren
op_amp
id|new_ver
comma
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|error
op_assign
id|presto_journal_close
c_func
(paren
op_amp
id|rec
comma
id|fset
comma
op_amp
id|file
comma
id|dentry
comma
op_amp
id|new_ver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
id|presto_trans_commit
c_func
(paren
id|fset
comma
id|handle
)paren
suffix:semicolon
r_goto
id|out_cancel_lml
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|LENTO_FL_WRITE_EXPECT
)paren
(brace
id|error
op_assign
id|presto_write_last_rcvd
c_func
(paren
op_amp
id|rec
comma
id|fset
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
id|presto_trans_commit
c_func
(paren
id|fset
comma
id|handle
)paren
suffix:semicolon
r_goto
id|out_cancel_lml
suffix:semicolon
)brace
)brace
id|presto_trans_commit
c_func
(paren
id|fset
comma
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|LENTO_FL_CANCEL_LML
)paren
(brace
id|presto_truncate_lml
c_func
(paren
id|fset
)paren
suffix:semicolon
)brace
id|out_cancel_lml
suffix:colon
id|EXIT
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* given a path, operate on the flags in its dentry.  Used by downcalls */
DECL|function|presto_mark_dentry
r_int
id|presto_mark_dentry
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|and_flag
comma
r_int
id|or_flag
comma
r_int
op_star
id|res
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|name
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;name: %s, and flag %x, or flag %x, dd_flags %x&bslash;n&quot;
comma
id|name
comma
id|and_flag
comma
id|or_flag
comma
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_flags
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_flags
op_and_assign
id|and_flag
suffix:semicolon
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_flags
op_or_assign
id|or_flag
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
op_star
id|res
op_assign
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_flags
suffix:semicolon
singleline_comment|// XXX this check makes no sense as d_count can change anytime.
multiline_comment|/* indicate if we were the only users while changing the flag */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
OG
l_int|1
)paren
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|out
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* given a path, operate on the flags in its cache.  Used by mark_ioctl */
DECL|function|presto_mark_cache
r_int
id|presto_mark_cache
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|and_flag
comma
r_int
id|or_flag
comma
r_int
op_star
id|res
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|presto_cache
op_star
id|cache
suffix:semicolon
r_int
id|error
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;presto_mark_cache :: name: %s, and flag %x, or flag %x&bslash;n&quot;
comma
id|name
comma
id|and_flag
comma
id|or_flag
)paren
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|name
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|cache
op_assign
id|presto_get_cache
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PRESTO: BAD: cannot find cache in presto_mark_cache&bslash;n&quot;
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
(paren
(paren
r_int
)paren
id|cache-&gt;cache_flags
)paren
op_and_assign
id|and_flag
suffix:semicolon
(paren
(paren
r_int
)paren
id|cache-&gt;cache_flags
)paren
op_or_assign
id|or_flag
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
op_star
id|res
op_assign
(paren
r_int
)paren
id|cache-&gt;cache_flags
suffix:semicolon
)brace
id|out
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|presto_mark_fset_dentry
r_int
id|presto_mark_fset_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|and_flag
comma
r_int
id|or_flag
comma
r_int
op_star
id|res
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|fset
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PRESTO: BAD: cannot find cache in presto_mark_cache&bslash;n&quot;
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
(paren
(paren
r_int
)paren
id|fset-&gt;fset_flags
)paren
op_and_assign
id|and_flag
suffix:semicolon
(paren
(paren
r_int
)paren
id|fset-&gt;fset_flags
)paren
op_or_assign
id|or_flag
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
op_star
id|res
op_assign
(paren
r_int
)paren
id|fset-&gt;fset_flags
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* given a path, operate on the flags in its cache.  Used by mark_ioctl */
DECL|function|presto_mark_fset
r_inline
r_int
id|presto_mark_fset
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|and_flag
comma
r_int
id|or_flag
comma
r_int
op_star
id|res
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|name
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
id|presto_mark_fset_dentry
c_func
(paren
id|dentry
comma
id|and_flag
comma
id|or_flag
comma
id|res
)paren
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* talk to Lento about the permit */
DECL|function|presto_permit_upcall
r_static
r_int
id|presto_permit_upcall
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|rc
suffix:semicolon
r_char
op_star
id|path
comma
op_star
id|buffer
suffix:semicolon
r_int
id|pathlen
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_int
id|fsetnamelen
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|minor
op_assign
id|presto_i2m
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|fset
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|EXIT
suffix:semicolon
r_return
op_minus
id|ENOTCONN
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|presto_lento_up
c_func
(paren
id|minor
)paren
)paren
(brace
r_if
c_cond
(paren
id|fset-&gt;fset_flags
op_amp
id|FSET_STEAL_PERMIT
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENOTCONN
suffix:semicolon
)brace
)brace
id|PRESTO_ALLOC
c_func
(paren
id|buffer
comma
r_char
op_star
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PRESTO: out of memory!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|path
op_assign
id|presto_path
c_func
(paren
id|dentry
comma
id|fset-&gt;fset_mtpt
comma
id|buffer
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|pathlen
op_assign
id|MYPATHLEN
c_func
(paren
id|buffer
comma
id|path
)paren
suffix:semicolon
id|fsetnamelen
op_assign
id|strlen
c_func
(paren
id|fset-&gt;fset_name
)paren
suffix:semicolon
id|rc
op_assign
id|lento_permit
c_func
(paren
id|minor
comma
id|pathlen
comma
id|fsetnamelen
comma
id|path
comma
id|fset-&gt;fset_name
)paren
suffix:semicolon
id|PRESTO_FREE
c_func
(paren
id|buffer
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* get a write permit for the fileset of this inode&n; *  - if this returns a negative value there was an error&n; *  - if 0 is returned the permit was already in the kernel -- or --&n; *    Lento gave us the permit without reintegration&n; *  - lento returns the number of records it reintegrated &n; */
DECL|function|presto_get_permit
r_int
id|presto_get_permit
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|de
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_int
id|minor
op_assign
id|presto_i2m
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|ENTRY
suffix:semicolon
r_if
c_cond
(paren
id|minor
OL
l_int|0
)paren
(brace
id|EXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ISLENTO
c_func
(paren
id|minor
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;i_dentry
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No alias for inode %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|de
op_assign
id|list_entry
c_func
(paren
id|inode-&gt;i_dentry.next
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
id|fset
op_assign
id|presto_fset
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Presto: no fileset in presto_get_permit!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fset-&gt;fset_flags
op_amp
id|FSET_HASPERMIT
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|fset-&gt;fset_permit_count
op_increment
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;permit count now %d, inode %lx&bslash;n&quot;
comma
id|fset-&gt;fset_permit_count
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Allow reintegration to proceed without locks -SHP */
id|rc
op_assign
id|presto_permit_upcall
c_func
(paren
id|fset-&gt;fset_mtpt
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|presto_mark_fset_dentry
(paren
id|fset-&gt;fset_mtpt
comma
op_complement
l_int|0
comma
id|FSET_HASPERMIT
comma
l_int|NULL
)paren
suffix:semicolon
id|fset-&gt;fset_permit_count
op_increment
suffix:semicolon
)brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;permit count now %d, ino %lx (likely 1), rc %d&bslash;n&quot;
comma
id|fset-&gt;fset_permit_count
comma
id|inode-&gt;i_ino
comma
id|rc
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
)brace
DECL|function|presto_put_permit
r_int
id|presto_put_permit
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|de
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_int
id|minor
op_assign
id|presto_i2m
c_func
(paren
id|inode
)paren
suffix:semicolon
id|ENTRY
suffix:semicolon
r_if
c_cond
(paren
id|minor
OL
l_int|0
)paren
(brace
id|EXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ISLENTO
c_func
(paren
id|minor
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;i_dentry
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No alias for inode %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|de
op_assign
id|list_entry
c_func
(paren
id|inode-&gt;i_dentry.next
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
id|fset
op_assign
id|presto_fset
c_func
(paren
id|de
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Presto: no fileset in presto_get_permit!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fset-&gt;fset_flags
op_amp
id|FSET_HASPERMIT
)paren
(brace
r_if
c_cond
(paren
id|fset-&gt;fset_permit_count
OG
l_int|0
)paren
id|fset-&gt;fset_permit_count
op_decrement
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Put permit while permit count is 0, inode %lx!&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
)brace
r_else
(brace
id|fset-&gt;fset_permit_count
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Put permit while no permit, inode %lx, flags %x!&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|fset-&gt;fset_flags
)paren
suffix:semicolon
)brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;permit count now %d, inode %lx&bslash;n&quot;
comma
id|fset-&gt;fset_permit_count
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fset-&gt;fset_flags
op_amp
id|FSET_PERMIT_WAITING
op_logical_and
id|fset-&gt;fset_permit_count
op_eq
l_int|0
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;permit count now 0, ino %lx, notify Lento&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|presto_mark_fset_dentry
c_func
(paren
id|fset-&gt;fset_mtpt
comma
op_complement
id|FSET_PERMIT_WAITING
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|presto_mark_fset_dentry
c_func
(paren
id|fset-&gt;fset_mtpt
comma
op_complement
id|FSET_HASPERMIT
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|lento_release_permit
c_func
(paren
id|fset-&gt;fset_cache-&gt;cache_psdev-&gt;uc_minor
comma
id|fset-&gt;fset_permit_cookie
)paren
suffix:semicolon
id|fset-&gt;fset_permit_cookie
op_assign
l_int|0
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|presto_getversion
r_void
id|presto_getversion
c_func
(paren
r_struct
id|presto_version
op_star
id|presto_version
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|presto_version-&gt;pv_mtime
op_assign
id|cpu_to_le64
c_func
(paren
(paren
id|__u64
)paren
id|inode-&gt;i_mtime
)paren
suffix:semicolon
id|presto_version-&gt;pv_ctime
op_assign
id|cpu_to_le64
c_func
(paren
(paren
id|__u64
)paren
id|inode-&gt;i_ctime
)paren
suffix:semicolon
id|presto_version-&gt;pv_size
op_assign
id|cpu_to_le64
c_func
(paren
(paren
id|__u64
)paren
id|inode-&gt;i_size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  note: this routine &quot;pins&quot; a dentry for a fileset root&n; */
DECL|function|presto_set_fsetroot
r_int
id|presto_set_fsetroot
c_func
(paren
r_char
op_star
id|path
comma
r_char
op_star
id|fsetname
comma
r_int
r_int
id|fsetid
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset2
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|presto_cache
op_star
id|cache
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|PRESTO_ALLOC
c_func
(paren
id|fset
comma
r_struct
id|presto_file_set
op_star
comma
r_sizeof
(paren
op_star
id|fset
)paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No memory allocating fset for %s&bslash;n&quot;
comma
id|fsetname
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;fset at %p&bslash;n&quot;
comma
id|fset
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;presto: fsetroot: path %s, fileset name %s&bslash;n&quot;
comma
id|path
comma
id|fsetname
)paren
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|fset-&gt;fset_nd
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|dentry
op_assign
id|fset-&gt;fset_nd.dentry
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|cache
op_assign
id|presto_get_cache
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;No cache found for %s&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;cache_mtpt
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Presto - no mountpoint: fsetroot fails!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;cache_root_fileset
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Presto - no file set: fsetroot fails!&bslash;n&quot;
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_INODE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|fset2
op_assign
id|presto_fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fset2
op_logical_and
(paren
id|fset2-&gt;fset_mtpt
op_eq
id|dentry
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Fsetroot already set (path %s)&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|fset-&gt;fset_cache
op_assign
id|cache
suffix:semicolon
id|fset-&gt;fset_mtpt
op_assign
id|dentry
suffix:semicolon
id|fset-&gt;fset_name
op_assign
id|fsetname
suffix:semicolon
id|fset-&gt;fset_chunkbits
op_assign
id|CHUNK_BITS
suffix:semicolon
id|fset-&gt;fset_flags
op_assign
id|flags
suffix:semicolon
id|fset-&gt;fset_file_maxio
op_assign
id|FSET_DEFAULT_MAX_FILEIO
suffix:semicolon
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_fset
op_assign
id|fset
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|fset-&gt;fset_list
comma
op_amp
id|cache-&gt;cache_fset_list
)paren
suffix:semicolon
id|error
op_assign
id|presto_init_kml_file
c_func
(paren
id|fset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_JOURNAL
comma
l_string|&quot;Error init_kml %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_goto
id|out_list_del
suffix:semicolon
)brace
id|error
op_assign
id|presto_init_last_rcvd_file
c_func
(paren
id|fset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_int
id|rc
suffix:semicolon
id|EXIT
suffix:semicolon
id|rc
op_assign
id|presto_close_journal_file
c_func
(paren
id|fset
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_JOURNAL
comma
l_string|&quot;Error init_lastrcvd %d, cleanup %d&bslash;n&quot;
comma
id|error
comma
id|rc
)paren
suffix:semicolon
r_goto
id|out_list_del
suffix:semicolon
)brace
id|error
op_assign
id|presto_init_lml_file
c_func
(paren
id|fset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_int
id|rc
suffix:semicolon
id|EXIT
suffix:semicolon
id|rc
op_assign
id|presto_close_journal_file
c_func
(paren
id|fset
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_JOURNAL
comma
l_string|&quot;Error init_lml %d, cleanup %d&bslash;n&quot;
comma
id|error
comma
id|rc
)paren
suffix:semicolon
r_goto
id|out_list_del
suffix:semicolon
)brace
macro_line|#ifdef  CONFIG_KREINT
multiline_comment|/* initialize kml reint buffer */
id|error
op_assign
id|kml_init
(paren
id|fset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_int
id|rc
suffix:semicolon
id|EXIT
suffix:semicolon
id|rc
op_assign
id|presto_close_journal_file
c_func
(paren
id|fset
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_JOURNAL
comma
l_string|&quot;Error init kml reint %d, cleanup %d&bslash;n&quot;
comma
id|error
comma
id|rc
)paren
suffix:semicolon
r_goto
id|out_list_del
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_eq
id|dentry-&gt;d_inode-&gt;i_sb-&gt;s_root-&gt;d_inode
)paren
(brace
id|cache-&gt;cache_flags
op_or_assign
id|CACHE_FSETROOT_SET
suffix:semicolon
)brace
id|CDEBUG
c_func
(paren
id|D_PIOCTL
comma
l_string|&quot;-------&gt; fset at %p, dentry at %p, mtpt %p, fset %s, cache %p, presto_d2d(dentry)-&gt;dd_fset %p&bslash;n&quot;
comma
id|fset
comma
id|dentry
comma
id|fset-&gt;fset_mtpt
comma
id|fset-&gt;fset_name
comma
id|cache
comma
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_fset
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_list_del
suffix:colon
id|list_del
c_func
(paren
op_amp
id|fset-&gt;fset_list
)paren
suffix:semicolon
id|presto_d2d
c_func
(paren
id|dentry
)paren
op_member_access_from_pointer
id|dd_fset
op_assign
l_int|NULL
suffix:semicolon
id|out_dput
suffix:colon
id|path_release
c_func
(paren
op_amp
id|fset-&gt;fset_nd
)paren
suffix:semicolon
id|out_free
suffix:colon
id|PRESTO_FREE
c_func
(paren
id|fset
comma
r_sizeof
(paren
op_star
id|fset
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|presto_get_kmlsize
r_int
id|presto_get_kmlsize
c_func
(paren
r_char
op_star
id|path
comma
r_int
op_star
id|size
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|kml_out
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|kml_out
suffix:semicolon
)brace
id|fset
op_assign
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|kml_out
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
op_star
id|size
op_assign
id|fset-&gt;fset_kml.fd_offset
suffix:semicolon
id|kml_out
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|presto_cleanup_fset
r_static
r_void
id|presto_cleanup_fset
c_func
(paren
r_struct
id|presto_file_set
op_star
id|fset
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|presto_cache
op_star
id|cache
suffix:semicolon
id|ENTRY
suffix:semicolon
macro_line|#ifdef  CONFIG_KREINT
id|error
op_assign
id|kml_cleanup
(paren
id|fset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;InterMezzo: Closing kml for fset %s: %d&bslash;n&quot;
comma
id|fset-&gt;fset_name
comma
id|error
)paren
suffix:semicolon
)brace
macro_line|#endif
id|error
op_assign
id|presto_close_journal_file
c_func
(paren
id|fset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;InterMezzo: Closing journal for fset %s: %d&bslash;n&quot;
comma
id|fset-&gt;fset_name
comma
id|error
)paren
suffix:semicolon
)brace
id|cache
op_assign
id|fset-&gt;fset_cache
suffix:semicolon
id|cache-&gt;cache_flags
op_and_assign
op_complement
id|CACHE_FSETROOT_SET
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|fset-&gt;fset_list
)paren
suffix:semicolon
id|presto_d2d
c_func
(paren
id|fset-&gt;fset_mtpt
)paren
op_member_access_from_pointer
id|dd_fset
op_assign
l_int|NULL
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|fset-&gt;fset_nd
)paren
suffix:semicolon
id|fset-&gt;fset_mtpt
op_assign
l_int|NULL
suffix:semicolon
id|PRESTO_FREE
c_func
(paren
id|fset-&gt;fset_name
comma
id|strlen
c_func
(paren
id|fset-&gt;fset_name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|PRESTO_FREE
c_func
(paren
id|fset
comma
r_sizeof
(paren
op_star
id|fset
)paren
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
)brace
DECL|function|presto_clear_fsetroot
r_int
id|presto_clear_fsetroot
c_func
(paren
r_char
op_star
id|path
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|put_out
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|put_out
suffix:semicolon
)brace
id|fset
op_assign
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|put_out
suffix:semicolon
)brace
id|presto_cleanup_fset
c_func
(paren
id|fset
)paren
suffix:semicolon
id|EXIT
suffix:semicolon
id|put_out
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
multiline_comment|/* for our lookup */
r_return
id|error
suffix:semicolon
)brace
DECL|function|presto_clear_all_fsetroots
r_int
id|presto_clear_all_fsetroots
c_func
(paren
r_char
op_star
id|path
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|presto_cache
op_star
id|cache
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|tmpnext
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|put_out
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|put_out
suffix:semicolon
)brace
id|fset
op_assign
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|put_out
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|cache
op_assign
id|fset-&gt;fset_cache
suffix:semicolon
id|cache-&gt;cache_flags
op_and_assign
op_complement
id|CACHE_FSETROOT_SET
suffix:semicolon
id|tmp
op_assign
op_amp
id|cache-&gt;cache_fset_list
suffix:semicolon
id|tmpnext
op_assign
id|tmp-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|tmpnext
op_ne
op_amp
id|cache-&gt;cache_fset_list
)paren
(brace
id|tmp
op_assign
id|tmpnext
suffix:semicolon
id|tmpnext
op_assign
id|tmp-&gt;next
suffix:semicolon
id|fset
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|presto_file_set
comma
id|fset_list
)paren
suffix:semicolon
id|presto_cleanup_fset
c_func
(paren
id|fset
)paren
suffix:semicolon
)brace
id|EXIT
suffix:semicolon
id|put_out
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
multiline_comment|/* for our lookup */
r_return
id|error
suffix:semicolon
)brace
DECL|function|presto_get_lastrecno
r_int
id|presto_get_lastrecno
c_func
(paren
r_char
op_star
id|path
comma
id|off_t
op_star
id|recno
)paren
(brace
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ENTRY
suffix:semicolon
id|error
op_assign
id|presto_walk
c_func
(paren
id|path
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_ispresto
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|kml_out
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|kml_out
suffix:semicolon
)brace
id|fset
op_assign
id|presto_dentry2fset
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fset
)paren
(brace
id|EXIT
suffix:semicolon
r_goto
id|kml_out
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
op_star
id|recno
op_assign
id|fset-&gt;fset_kml.fd_recno
suffix:semicolon
id|kml_out
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* &n;   if *cookie != 0, lento must wait for this cookie&n;   before releasing the permit, operations are in progress. &n;*/
DECL|function|presto_permit_downcall
r_int
id|presto_permit_downcall
c_func
(paren
r_const
r_char
op_star
id|path
comma
r_int
op_star
id|cookie
)paren
(brace
r_int
id|result
suffix:semicolon
r_struct
id|presto_file_set
op_star
id|fset
suffix:semicolon
id|fset
op_assign
id|presto_path2fileset
c_func
(paren
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|fset
)paren
)paren
(brace
id|EXIT
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|fset
)paren
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fset-&gt;fset_permit_count
op_ne
l_int|0
)paren
(brace
multiline_comment|/* is there are previous cookie? */
r_if
c_cond
(paren
id|fset-&gt;fset_permit_cookie
op_eq
l_int|0
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;presto installing cookie 0x%x, %s&bslash;n&quot;
comma
op_star
id|cookie
comma
id|path
)paren
suffix:semicolon
id|fset-&gt;fset_permit_cookie
op_assign
op_star
id|cookie
suffix:semicolon
)brace
r_else
(brace
op_star
id|cookie
op_assign
id|fset-&gt;fset_permit_cookie
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;presto has cookie 0x%x, %s&bslash;n&quot;
comma
op_star
id|cookie
comma
id|path
)paren
suffix:semicolon
)brace
id|result
op_assign
id|presto_mark_fset
c_func
(paren
id|path
comma
l_int|0
comma
id|FSET_PERMIT_WAITING
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|cookie
op_assign
l_int|0
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;presto releasing permit %s&bslash;n&quot;
comma
id|path
)paren
suffix:semicolon
id|result
op_assign
id|presto_mark_fset
c_func
(paren
id|path
comma
op_complement
id|FSET_HASPERMIT
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|presto_is_read_only
r_inline
r_int
id|presto_is_read_only
c_func
(paren
r_struct
id|presto_file_set
op_star
id|fset
)paren
(brace
r_int
id|minor
comma
id|mask
suffix:semicolon
r_struct
id|presto_cache
op_star
id|cache
op_assign
id|fset-&gt;fset_cache
suffix:semicolon
id|minor
op_assign
id|cache-&gt;cache_psdev-&gt;uc_minor
suffix:semicolon
id|mask
op_assign
(paren
id|ISLENTO
c_func
(paren
id|minor
)paren
ques
c_cond
id|FSET_LENTO_RO
suffix:colon
id|FSET_CLIENT_RO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fset-&gt;fset_flags
op_amp
id|mask
)paren
r_return
l_int|1
suffix:semicolon
id|mask
op_assign
(paren
id|ISLENTO
c_func
(paren
id|minor
)paren
ques
c_cond
id|CACHE_LENTO_RO
suffix:colon
id|CACHE_CLIENT_RO
)paren
suffix:semicolon
r_return
(paren
(paren
id|cache-&gt;cache_flags
op_amp
id|mask
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
eof
