multiline_comment|/*&n; * fs/dcache.c&n; *&n; * Complete reimplementation&n; * (C) 1997 Thomas Schoebel-Theuer,&n; * with heavy changes by Linus Torvalds&n; */
multiline_comment|/*&n; * Notes on the allocation strategy:&n; *&n; * The dcache is a master of the icache - whenever a dcache entry&n; * exists, the inode will always exist. &quot;iput()&quot; is done either when&n; * the dcache entry is deleted or garbage collected.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|DCACHE_PARANOIA
mdefine_line|#define DCACHE_PARANOIA 1
multiline_comment|/* #define DCACHE_DEBUG 1 */
DECL|variable|__cacheline_aligned_in_smp
id|spinlock_t
id|dcache_lock
id|__cacheline_aligned_in_smp
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|__cacheline_aligned_in_smp
id|rwlock_t
id|dparent_lock
id|__cacheline_aligned_in_smp
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|dentry_cache
r_static
id|kmem_cache_t
op_star
id|dentry_cache
suffix:semicolon
multiline_comment|/*&n; * This is the single most critical data structure when it comes&n; * to the dcache: the hashtable for lookups. Somebody should try&n; * to make this good - I&squot;ve just made it work.&n; *&n; * This hash-function tries to avoid losing too many bits of hash&n; * information, yet avoid using a prime hash-size or similar.&n; */
DECL|macro|D_HASHBITS
mdefine_line|#define D_HASHBITS     d_hash_shift
DECL|macro|D_HASHMASK
mdefine_line|#define D_HASHMASK     d_hash_mask
DECL|variable|d_hash_mask
r_static
r_int
r_int
id|d_hash_mask
suffix:semicolon
DECL|variable|d_hash_shift
r_static
r_int
r_int
id|d_hash_shift
suffix:semicolon
DECL|variable|dentry_hashtable
r_static
r_struct
id|list_head
op_star
id|dentry_hashtable
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|dentry_unused
)paren
suffix:semicolon
multiline_comment|/* Statistics gathering. */
DECL|variable|dentry_stat
r_struct
id|dentry_stat_t
id|dentry_stat
op_assign
(brace
dot
id|age_limit
op_assign
l_int|45
comma
)brace
suffix:semicolon
multiline_comment|/* no dcache_lock, please */
DECL|function|d_free
r_static
r_inline
r_void
id|d_free
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_release
)paren
id|dentry-&gt;d_op
op_member_access_from_pointer
id|d_release
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dname_external
c_func
(paren
id|dentry
)paren
)paren
id|kfree
c_func
(paren
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|dentry_cache
comma
id|dentry
)paren
suffix:semicolon
id|dentry_stat.nr_dentry
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * Release the dentry&squot;s inode, using the filesystem&n; * d_iput() operation if defined.&n; * Called with dcache_lock held, drops it.&n; */
DECL|function|dentry_iput
r_static
r_inline
r_void
id|dentry_iput
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|dentry-&gt;d_inode
op_assign
l_int|NULL
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|dentry-&gt;d_alias
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_iput
)paren
id|dentry-&gt;d_op
op_member_access_from_pointer
id|d_iput
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_else
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * This is dput&n; *&n; * This is complicated by the fact that we do not want to put&n; * dentries that are no longer on any hash chain on the unused&n; * list: we&squot;d much rather just get rid of them immediately.&n; *&n; * However, that implies that we have to traverse the dentry&n; * tree upwards to the parents which might _also_ now be&n; * scheduled for deletion (it may have been only waiting for&n; * its last child to go away).&n; *&n; * This tail recursion is done by hand as we don&squot;t want to depend&n; * on the compiler to always get this right (gcc generally doesn&squot;t).&n; * Real recursion would eat up our stack space.&n; */
multiline_comment|/*&n; * dput - release a dentry&n; * @dentry: dentry to release &n; *&n; * Release a dentry. This will drop the usage count and if appropriate&n; * call the dentry unlink method as well as removing it from the queues and&n; * releasing its resources. If the parent dentries were scheduled for release&n; * they too may now get deleted.&n; *&n; * no dcache lock, please.&n; */
DECL|function|dput
r_void
id|dput
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_lock
c_func
(paren
op_amp
id|dentry-&gt;d_count
comma
op_amp
id|dcache_lock
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* dput on a free dentry? */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_lru
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * AV: -&gt;d_delete() is _NOT_ allowed to block now.&n;&t; */
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_delete
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_member_access_from_pointer
id|d_delete
c_func
(paren
id|dentry
)paren
)paren
r_goto
id|unhash_it
suffix:semicolon
)brace
multiline_comment|/* Unreachable? Get rid of it */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
)paren
r_goto
id|kill_it
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dentry-&gt;d_lru
comma
op_amp
id|dentry_unused
)paren
suffix:semicolon
id|dentry_stat.nr_unused
op_increment
suffix:semicolon
id|dentry-&gt;d_vfs_flags
op_or_assign
id|DCACHE_REFERENCED
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
id|unhash_it
suffix:colon
id|list_del_init
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
suffix:semicolon
id|kill_it
suffix:colon
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dentry-&gt;d_child
)paren
suffix:semicolon
multiline_comment|/* drops the lock, at that point nobody can reach this dentry */
id|dentry_iput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|parent
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
id|d_free
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|parent
)paren
r_return
suffix:semicolon
id|dentry
op_assign
id|parent
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * d_invalidate - invalidate a dentry&n; * @dentry: dentry to invalidate&n; *&n; * Try to invalidate the dentry if it turns out to be&n; * possible. If there are other dentries that can be&n; * reached through this one we can&squot;t delete it and we&n; * return -EBUSY. On success we return 0.&n; *&n; * no dcache lock.&n; */
DECL|function|d_invalidate
r_int
id|d_invalidate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
multiline_comment|/*&n;&t; * If it&squot;s already been dropped, return OK.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check whether to do a partial shrink_dcache&n;&t; * to get rid of unused child entries.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|shrink_dcache_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Somebody else still using it?&n;&t; *&n;&t; * If it&squot;s a directory, we can&squot;t drop it&n;&t; * for fear of somebody re-populating it&n;&t; * with children (even though dropping it&n;&t; * would make it unreachable from the root,&n;&t; * we might still populate it if it was a&n;&t; * working directory or similar).&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_logical_and
id|S_ISDIR
c_func
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
)brace
id|list_del_init
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This should be called _only_ with dcache_lock held */
DECL|function|__dget_locked
r_static
r_inline
r_struct
id|dentry
op_star
id|__dget_locked
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
op_eq
l_int|1
)paren
(brace
id|dentry_stat.nr_unused
op_decrement
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|dentry-&gt;d_lru
)paren
suffix:semicolon
)brace
r_return
id|dentry
suffix:semicolon
)brace
DECL|function|dget_locked
r_struct
id|dentry
op_star
id|dget_locked
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
id|__dget_locked
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * d_find_alias - grab a hashed alias of inode&n; * @inode: inode in question&n; *&n; * If inode has a hashed alias - acquire the reference to alias and&n; * return it. Otherwise return NULL. Notice that if inode is a directory&n; * there can be only one alias and it can be unhashed only if it has&n; * no children.&n; *&n; * If the inode has a DCACHE_DISCONNECTED alias, then prefer&n; * any other hashed alias over that one.&n; */
DECL|function|d_find_alias
r_struct
id|dentry
op_star
id|d_find_alias
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|list_head
op_star
id|head
comma
op_star
id|next
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|dentry
op_star
id|alias
comma
op_star
id|discon_alias
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|inode-&gt;i_dentry
suffix:semicolon
id|next
op_assign
id|inode-&gt;i_dentry.next
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
id|head
)paren
(brace
id|tmp
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|tmp-&gt;next
suffix:semicolon
id|alias
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|alias-&gt;d_hash
)paren
)paren
(brace
r_if
c_cond
(paren
id|alias-&gt;d_flags
op_amp
id|DCACHE_DISCONNECTED
)paren
id|discon_alias
op_assign
id|alias
suffix:semicolon
r_else
(brace
id|__dget_locked
c_func
(paren
id|alias
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
id|alias
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|discon_alias
)paren
id|__dget_locked
c_func
(paren
id|discon_alias
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
id|discon_alias
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Try to kill dentries associated with this inode.&n; * WARNING: you must own a reference to inode.&n; */
DECL|function|d_prune_aliases
r_void
id|d_prune_aliases
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|head
op_assign
op_amp
id|inode-&gt;i_dentry
suffix:semicolon
id|restart
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|tmp
op_assign
id|head
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|tmp-&gt;next
)paren
op_ne
id|head
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
)paren
(brace
id|__dget_locked
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Throw away a dentry - free the inode, dput the parent.&n; * This requires that the LRU list has already been&n; * removed.&n; * Called with dcache_lock, drops it and then regains.&n; */
DECL|function|prune_one_dentry
r_static
r_inline
r_void
id|prune_one_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dentry-&gt;d_child
)paren
suffix:semicolon
id|dentry_iput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|parent
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
id|d_free
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_ne
id|dentry
)paren
id|dput
c_func
(paren
id|parent
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * prune_dcache - shrink the dcache&n; * @count: number of entries to try and free&n; *&n; * Shrink the dcache. This is done when we need&n; * more memory, or simply when we need to unmount&n; * something (at which point we need to unuse&n; * all dentries).&n; *&n; * This function may fail to free any resources if&n; * all the dentries are in use.&n; */
DECL|function|prune_dcache
r_static
r_void
id|prune_dcache
c_func
(paren
r_int
id|count
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|count
suffix:semicolon
id|count
op_decrement
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|dentry_unused.prev
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
op_amp
id|dentry_unused
)paren
r_break
suffix:semicolon
id|list_del_init
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_lru
)paren
suffix:semicolon
multiline_comment|/* If the dentry was recently referenced, don&squot;t free it. */
r_if
c_cond
(paren
id|dentry-&gt;d_vfs_flags
op_amp
id|DCACHE_REFERENCED
)paren
(brace
id|dentry-&gt;d_vfs_flags
op_and_assign
op_complement
id|DCACHE_REFERENCED
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dentry-&gt;d_lru
comma
op_amp
id|dentry_unused
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dentry_stat.nr_unused
op_decrement
suffix:semicolon
multiline_comment|/* Unused dentry with a count? */
id|BUG_ON
c_func
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
)paren
suffix:semicolon
id|prune_one_dentry
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Shrink the dcache for the specified super block.&n; * This allows us to unmount a device without disturbing&n; * the dcache for the other devices.&n; *&n; * This implementation makes just two traversals of the&n; * unused list.  On the first pass we move the selected&n; * dentries to the most recent end, and on the second&n; * pass we free them.  The second pass must restart after&n; * each dput(), but since the target dentries are all at&n; * the end, it&squot;s really just a single traversal.&n; */
multiline_comment|/**&n; * shrink_dcache_sb - shrink dcache for a superblock&n; * @sb: superblock&n; *&n; * Shrink the dcache for the specified super block. This&n; * is used to free the dcache before unmounting a file&n; * system&n; */
DECL|function|shrink_dcache_sb
r_void
id|shrink_dcache_sb
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|next
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
multiline_comment|/*&n;&t; * Pass one ... move the dentries for the specified&n;&t; * superblock to the most recent end of the unused list.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|next
op_assign
id|dentry_unused.next
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|dentry_unused
)paren
(brace
id|tmp
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|tmp-&gt;next
suffix:semicolon
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_sb
op_ne
id|sb
)paren
r_continue
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|tmp
comma
op_amp
id|dentry_unused
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Pass two ... free the dentries for this superblock.&n;&t; */
id|repeat
suffix:colon
id|next
op_assign
id|dentry_unused.next
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|dentry_unused
)paren
(brace
id|tmp
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|tmp-&gt;next
suffix:semicolon
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_sb
op_ne
id|sb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
)paren
r_continue
suffix:semicolon
id|dentry_stat.nr_unused
op_decrement
suffix:semicolon
id|list_del_init
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|prune_one_dentry
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Search for at least 1 mount point in the dentry&squot;s subdirs.&n; * We descend to the next level whenever the d_subdirs&n; * list is non-empty and continue searching.&n; */
multiline_comment|/**&n; * have_submounts - check for mounts over a dentry&n; * @parent: dentry to check.&n; *&n; * Return true if the parent or its subdirectories contain&n; * a mount point&n; */
DECL|function|have_submounts
r_int
id|have_submounts
c_func
(paren
r_struct
id|dentry
op_star
id|parent
)paren
(brace
r_struct
id|dentry
op_star
id|this_parent
op_assign
id|parent
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|parent
)paren
)paren
r_goto
id|positive
suffix:semicolon
id|repeat
suffix:colon
id|next
op_assign
id|this_parent-&gt;d_subdirs.next
suffix:semicolon
id|resume
suffix:colon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|this_parent-&gt;d_subdirs
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|next
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
id|next
op_assign
id|tmp-&gt;next
suffix:semicolon
multiline_comment|/* Have we found a mount point ? */
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
r_goto
id|positive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
)paren
(brace
id|this_parent
op_assign
id|dentry
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * All done at this level ... ascend and resume the search.&n;&t; */
r_if
c_cond
(paren
id|this_parent
op_ne
id|parent
)paren
(brace
id|next
op_assign
id|this_parent-&gt;d_child.next
suffix:semicolon
id|this_parent
op_assign
id|this_parent-&gt;d_parent
suffix:semicolon
r_goto
id|resume
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* No mount points found in tree */
id|positive
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Search the dentry child list for the specified parent,&n; * and move any unused dentries to the end of the unused&n; * list for prune_dcache(). We descend to the next level&n; * whenever the d_subdirs list is non-empty and continue&n; * searching.&n; */
DECL|function|select_parent
r_static
r_int
id|select_parent
c_func
(paren
r_struct
id|dentry
op_star
id|parent
)paren
(brace
r_struct
id|dentry
op_star
id|this_parent
op_assign
id|parent
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|repeat
suffix:colon
id|next
op_assign
id|this_parent-&gt;d_subdirs.next
suffix:semicolon
id|resume
suffix:colon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|this_parent-&gt;d_subdirs
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|next
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
id|next
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|dentry-&gt;d_lru
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dentry-&gt;d_lru
comma
id|dentry_unused.prev
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Descend a level if the d_subdirs list is non-empty.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
)paren
(brace
id|this_parent
op_assign
id|dentry
suffix:semicolon
macro_line|#ifdef DCACHE_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;select_parent: descending to %s/%s, found=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|found
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * All done at this level ... ascend and resume the search.&n;&t; */
r_if
c_cond
(paren
id|this_parent
op_ne
id|parent
)paren
(brace
id|next
op_assign
id|this_parent-&gt;d_child.next
suffix:semicolon
id|this_parent
op_assign
id|this_parent-&gt;d_parent
suffix:semicolon
macro_line|#ifdef DCACHE_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;select_parent: ascending to %s/%s, found=%d&bslash;n&quot;
comma
id|this_parent-&gt;d_parent-&gt;d_name.name
comma
id|this_parent-&gt;d_name.name
comma
id|found
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|resume
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/**&n; * shrink_dcache_parent - prune dcache&n; * @parent: parent of entries to prune&n; *&n; * Prune the dcache to remove unused children of the parent dentry.&n; */
DECL|function|shrink_dcache_parent
r_void
id|shrink_dcache_parent
c_func
(paren
r_struct
id|dentry
op_star
id|parent
)paren
(brace
r_int
id|found
suffix:semicolon
r_while
c_loop
(paren
(paren
id|found
op_assign
id|select_parent
c_func
(paren
id|parent
)paren
)paren
op_ne
l_int|0
)paren
id|prune_dcache
c_func
(paren
id|found
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * shrink_dcache_anon - further prune the cache&n; * @head: head of d_hash list of dentries to prune&n; *&n; * Prune the dentries that are anonymous&n; *&n; */
DECL|function|shrink_dcache_anon
r_void
id|shrink_dcache_anon
c_func
(paren
r_struct
id|list_head
op_star
id|head
)paren
(brace
r_struct
id|list_head
op_star
id|lp
suffix:semicolon
r_int
id|found
suffix:semicolon
r_do
(brace
id|found
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lp
comma
id|head
)paren
(brace
r_struct
id|dentry
op_star
id|this
op_assign
id|list_entry
c_func
(paren
id|lp
comma
r_struct
id|dentry
comma
id|d_hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|this-&gt;d_count
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|this-&gt;d_lru
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|this-&gt;d_lru
comma
op_amp
id|dentry_unused
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|prune_dcache
c_func
(paren
id|found
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|found
)paren
(brace
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is called from kswapd when we think we need some&n; * more memory. &n; */
DECL|function|shrink_dcache_memory
r_static
r_int
id|shrink_dcache_memory
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|gfp_mask
)paren
(brace
r_if
c_cond
(paren
id|nr
)paren
(brace
multiline_comment|/*&n;&t;&t; * Nasty deadlock avoidance.&n;&t;&t; *&n;&t; &t; * ext2_new_block-&gt;getblk-&gt;GFP-&gt;shrink_dcache_memory-&gt;&n;&t;&t; * prune_dcache-&gt;prune_one_dentry-&gt;dput-&gt;dentry_iput-&gt;iput-&gt;&n;&t;&t; * inode-&gt;i_sb-&gt;s_op-&gt;put_inode-&gt;ext2_discard_prealloc-&gt;&n;&t;&t; * ext2_free_blocks-&gt;lock_super-&gt;DEADLOCK.&n;&t; &t; *&n;&t; &t; * We should make sure we don&squot;t hold the superblock lock over&n;&t; &t; * block allocations, but for now:&n;&t;&t; */
r_if
c_cond
(paren
id|gfp_mask
op_amp
id|__GFP_FS
)paren
id|prune_dcache
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
r_return
id|dentry_stat.nr_dentry
suffix:semicolon
)brace
DECL|macro|NAME_ALLOC_LEN
mdefine_line|#define NAME_ALLOC_LEN(len)&t;((len+16) &amp; ~15)
multiline_comment|/**&n; * d_alloc&t;-&t;allocate a dcache entry&n; * @parent: parent of entry to allocate&n; * @name: qstr of the name&n; *&n; * Allocates a dentry. It returns %NULL if there is insufficient memory&n; * available. On a success the dentry is returned. The name passed in is&n; * copied and the copy passed in may be reused after this call.&n; */
DECL|function|d_alloc
r_struct
id|dentry
op_star
id|d_alloc
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_const
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_char
op_star
id|str
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|kmem_cache_alloc
c_func
(paren
id|dentry_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;len
OG
id|DNAME_INLINE_LEN
op_minus
l_int|1
)paren
(brace
id|str
op_assign
id|kmalloc
c_func
(paren
id|NAME_ALLOC_LEN
c_func
(paren
id|name-&gt;len
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|dentry_cache
comma
id|dentry
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
id|str
op_assign
id|dentry-&gt;d_iname
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|name-&gt;name
comma
id|name-&gt;len
)paren
suffix:semicolon
id|str
(braket
id|name-&gt;len
)braket
op_assign
l_int|0
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|dentry-&gt;d_count
comma
l_int|1
)paren
suffix:semicolon
id|dentry-&gt;d_vfs_flags
op_assign
l_int|0
suffix:semicolon
id|dentry-&gt;d_flags
op_assign
l_int|0
suffix:semicolon
id|dentry-&gt;d_inode
op_assign
l_int|NULL
suffix:semicolon
id|dentry-&gt;d_parent
op_assign
l_int|NULL
suffix:semicolon
id|dentry-&gt;d_sb
op_assign
l_int|NULL
suffix:semicolon
id|dentry-&gt;d_name.name
op_assign
id|str
suffix:semicolon
id|dentry-&gt;d_name.len
op_assign
id|name-&gt;len
suffix:semicolon
id|dentry-&gt;d_name.hash
op_assign
id|name-&gt;hash
suffix:semicolon
id|dentry-&gt;d_op
op_assign
l_int|NULL
suffix:semicolon
id|dentry-&gt;d_fsdata
op_assign
l_int|NULL
suffix:semicolon
id|dentry-&gt;d_mounted
op_assign
l_int|0
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dentry-&gt;d_lru
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dentry-&gt;d_alias
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
(brace
id|dentry-&gt;d_parent
op_assign
id|dget
c_func
(paren
id|parent
)paren
suffix:semicolon
id|dentry-&gt;d_sb
op_assign
id|parent-&gt;d_sb
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dentry-&gt;d_child
comma
op_amp
id|parent-&gt;d_subdirs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
r_else
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dentry-&gt;d_child
)paren
suffix:semicolon
id|dentry_stat.nr_dentry
op_increment
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/**&n; * d_instantiate - fill in inode information for a dentry&n; * @entry: dentry to complete&n; * @inode: inode to attach to this dentry&n; *&n; * Fill in inode information in the entry.&n; *&n; * This turns negative dentries into productive full members&n; * of society.&n; *&n; * NOTE! This assumes that the inode count has been incremented&n; * (or otherwise set) by the caller to indicate that it is now&n; * in use by the dcache.&n; */
DECL|function|d_instantiate
r_void
id|d_instantiate
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|entry-&gt;d_alias
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|list_add
c_func
(paren
op_amp
id|entry-&gt;d_alias
comma
op_amp
id|inode-&gt;i_dentry
)paren
suffix:semicolon
id|entry-&gt;d_inode
op_assign
id|inode
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * d_alloc_root - allocate root dentry&n; * @root_inode: inode to allocate the root for&n; *&n; * Allocate a root (&quot;/&quot;) dentry for the inode given. The inode is&n; * instantiated and returned. %NULL is returned if there is insufficient&n; * memory or the inode passed is %NULL.&n; */
DECL|function|d_alloc_root
r_struct
id|dentry
op_star
id|d_alloc_root
c_func
(paren
r_struct
id|inode
op_star
id|root_inode
)paren
(brace
r_struct
id|dentry
op_star
id|res
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|root_inode
)paren
(brace
id|res
op_assign
id|d_alloc
c_func
(paren
l_int|NULL
comma
op_amp
(paren
r_const
r_struct
id|qstr
)paren
(brace
l_string|&quot;/&quot;
comma
l_int|1
comma
l_int|0
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|res-&gt;d_sb
op_assign
id|root_inode-&gt;i_sb
suffix:semicolon
id|res-&gt;d_parent
op_assign
id|res
suffix:semicolon
id|d_instantiate
c_func
(paren
id|res
comma
id|root_inode
)paren
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|d_hash
r_static
r_inline
r_struct
id|list_head
op_star
id|d_hash
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_int
r_int
id|hash
)paren
(brace
id|hash
op_add_assign
(paren
r_int
r_int
)paren
id|parent
op_div
id|L1_CACHE_BYTES
suffix:semicolon
id|hash
op_assign
id|hash
op_xor
(paren
id|hash
op_rshift
id|D_HASHBITS
)paren
suffix:semicolon
r_return
id|dentry_hashtable
op_plus
(paren
id|hash
op_amp
id|D_HASHMASK
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * d_alloc_anon - allocate an anonymous dentry&n; * @inode: inode to allocate the dentry for&n; *&n; * This is similar to d_alloc_root.  It is used by filesystems when&n; * creating a dentry for a given inode, often in the process of &n; * mapping a filehandle to a dentry.  The returned dentry may be&n; * anonymous, or may have a full name (if the inode was already&n; * in the cache).  The file system may need to make further&n; * efforts to connect this dentry into the dcache properly.&n; *&n; * When called on a directory inode, we must ensure that&n; * the inode only ever has one dentry.  If a dentry is&n; * found, that is returned instead of allocating a new one.&n; *&n; * On successful return, the reference to the inode has been transferred&n; * to the dentry.  If %NULL is returned (indicating kmalloc failure),&n; * the reference on the inode has not been released.&n; */
DECL|function|d_alloc_anon
r_struct
id|dentry
op_star
id|d_alloc_anon
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|tmp
suffix:semicolon
r_struct
id|dentry
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res
op_assign
id|d_find_alias
c_func
(paren
id|inode
)paren
)paren
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|tmp
op_assign
id|d_alloc
c_func
(paren
l_int|NULL
comma
op_amp
(paren
r_const
r_struct
id|qstr
)paren
(brace
l_string|&quot;&quot;
comma
l_int|0
comma
l_int|0
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
l_int|NULL
suffix:semicolon
id|tmp-&gt;d_parent
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* make sure dput doesn&squot;t croak */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;i_dentry
)paren
)paren
(brace
multiline_comment|/* A directory can only have one dentry.&n;&t;&t; * This (now) has one, so use it.&n;&t;&t; */
id|res
op_assign
id|list_entry
c_func
(paren
id|inode-&gt;i_dentry.next
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
id|__dget_locked
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* attach a disconnected dentry */
id|res
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|res-&gt;d_sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
id|res-&gt;d_parent
op_assign
id|res
suffix:semicolon
id|res-&gt;d_inode
op_assign
id|inode
suffix:semicolon
id|res-&gt;d_flags
op_or_assign
id|DCACHE_DISCONNECTED
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|res-&gt;d_alias
comma
op_amp
id|inode-&gt;i_dentry
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|res-&gt;d_hash
comma
op_amp
id|inode-&gt;i_sb-&gt;s_anon
)paren
suffix:semicolon
)brace
id|inode
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* don&squot;t drop reference */
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|dput
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * d_splice_alias - splice a disconnected dentry into the tree if one exists&n; * @inode:  the inode which may have a disconnected dentry&n; * @dentry: a negative dentry which we want to point to the inode.&n; *&n; * If inode is a directory and has a &squot;disconnected&squot; dentry (i.e. IS_ROOT and&n; * DCACHE_DISCONNECTED), then d_move that in place of the given dentry&n; * and return it, else simply d_add the inode to the dentry and return NULL.&n; *&n; * This is (will be) needed in the lookup routine of any filesystem that is exportable&n; * (via knfsd) so that we can build dcache paths to directories effectively.&n; *&n; * If a dentry was found and moved, then it is returned.  Otherwise NULL&n; * is returned.  This matches the expected return value of -&gt;lookup.&n; *&n; */
DECL|function|d_splice_alias
r_struct
id|dentry
op_star
id|d_splice_alias
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
r_new
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;i_dentry
)paren
)paren
(brace
r_new
op_assign
id|list_entry
c_func
(paren
id|inode-&gt;i_dentry.next
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
id|__dget_locked
c_func
(paren
r_new
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|d_rehash
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|d_move
c_func
(paren
r_new
comma
id|dentry
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* d_instantiate takes dcache_lock, so we do it by hand */
id|list_add
c_func
(paren
op_amp
id|dentry-&gt;d_alias
comma
op_amp
id|inode-&gt;i_dentry
)paren
suffix:semicolon
id|dentry-&gt;d_inode
op_assign
id|inode
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|d_rehash
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
)brace
r_else
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/**&n; * d_lookup - search for a dentry&n; * @parent: parent dentry&n; * @name: qstr of name we wish to find&n; *&n; * Searches the children of the parent dentry for the name in question. If&n; * the dentry is found its reference count is incremented and the dentry&n; * is returned. The caller must use d_put to free the entry when it has&n; * finished using it. %NULL is returned on failure.&n; */
DECL|function|d_lookup
r_struct
id|dentry
op_star
id|d_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dentry
op_assign
id|__d_lookup
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
id|__dget_locked
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
DECL|function|__d_lookup
r_struct
id|dentry
op_star
id|__d_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_int
r_int
id|len
op_assign
id|name-&gt;len
suffix:semicolon
r_int
r_int
id|hash
op_assign
id|name-&gt;hash
suffix:semicolon
r_const
r_int
r_char
op_star
id|str
op_assign
id|name-&gt;name
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
id|d_hash
c_func
(paren
id|parent
comma
id|hash
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|head-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|head
)paren
r_break
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.hash
op_ne
id|hash
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_parent
op_ne
id|parent
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;d_op
op_logical_and
id|parent-&gt;d_op-&gt;d_compare
)paren
(brace
r_if
c_cond
(paren
id|parent-&gt;d_op
op_member_access_from_pointer
id|d_compare
c_func
(paren
id|parent
comma
op_amp
id|dentry-&gt;d_name
comma
id|name
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
op_ne
id|len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|dentry-&gt;d_name.name
comma
id|str
comma
id|len
)paren
)paren
r_continue
suffix:semicolon
)brace
r_return
id|dentry
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * d_validate - verify dentry provided from insecure source&n; * @dentry: The dentry alleged to be valid child of @dparent&n; * @dparent: The parent dentry (known to be valid)&n; * @hash: Hash of the dentry&n; * @len: Length of the name&n; *&n; * An insecure source has sent us a dentry, here we verify it and dget() it.&n; * This is used by ncpfs in its readdir implementation.&n; * Zero is returned in the dentry is invalid.&n; */
DECL|function|d_validate
r_int
id|d_validate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|dentry
op_star
id|dparent
)paren
(brace
r_int
r_int
id|dent_addr
op_assign
(paren
r_int
r_int
)paren
id|dentry
suffix:semicolon
r_int
r_int
id|min_addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
r_int
r_int
id|align_mask
op_assign
l_int|0x0F
suffix:semicolon
r_struct
id|list_head
op_star
id|base
comma
op_star
id|lhp
suffix:semicolon
r_if
c_cond
(paren
id|dent_addr
OL
id|min_addr
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|dent_addr
OG
(paren
r_int
r_int
)paren
id|high_memory
op_minus
r_sizeof
(paren
r_struct
id|dentry
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|dent_addr
op_amp
id|align_mask
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|kern_addr_valid
c_func
(paren
id|dent_addr
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|kern_addr_valid
c_func
(paren
id|dent_addr
op_minus
l_int|1
op_plus
r_sizeof
(paren
r_struct
id|dentry
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_parent
op_ne
id|dparent
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|lhp
op_assign
id|base
op_assign
id|d_hash
c_func
(paren
id|dparent
comma
id|dentry-&gt;d_name.hash
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|lhp
op_assign
id|lhp-&gt;next
)paren
op_ne
id|base
)paren
(brace
r_if
c_cond
(paren
id|dentry
op_eq
id|list_entry
c_func
(paren
id|lhp
comma
r_struct
id|dentry
comma
id|d_hash
)paren
)paren
(brace
id|__dget_locked
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * When a file is deleted, we have two options:&n; * - turn this dentry into a negative dentry&n; * - unhash this dentry and free it.&n; *&n; * Usually, we want to just turn this into&n; * a negative dentry, but if anybody else is&n; * currently using the dentry or the inode&n; * we can&squot;t do that and we fall back on removing&n; * it from the hash queues and waiting for&n; * it to be deleted later when it has no users&n; */
multiline_comment|/**&n; * d_delete - delete a dentry&n; * @dentry: The dentry to delete&n; *&n; * Turn the dentry into a negative dentry if possible, otherwise&n; * remove it from the hash queues so it can be deleted later&n; */
DECL|function|d_delete
r_void
id|d_delete
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
multiline_comment|/*&n;&t; * Are we the only user?&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
op_eq
l_int|1
)paren
(brace
id|dentry_iput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If not, just drop the dentry and let dput&n;&t; * pick up the tab..&n;&t; */
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * d_rehash&t;- add an entry back to the hash&n; * @entry: dentry to add to the hash&n; *&n; * Adds a dentry to the hash according to its name.&n; */
DECL|function|d_rehash
r_void
id|d_rehash
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_struct
id|list_head
op_star
id|list
op_assign
id|d_hash
c_func
(paren
id|entry-&gt;d_parent
comma
id|entry-&gt;d_name.hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|entry-&gt;d_hash
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;d_hash
comma
id|list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
DECL|macro|do_switch
mdefine_line|#define do_switch(x,y) do { &bslash;&n;&t;__typeof__ (x) __tmp = x; &bslash;&n;&t;x = y; y = __tmp; } while (0)
multiline_comment|/*&n; * When switching names, the actual string doesn&squot;t strictly have to&n; * be preserved in the target - because we&squot;re dropping the target&n; * anyway. As such, we can just do a simple memcpy() to copy over&n; * the new name before we switch.&n; *&n; * Note that we have to be a lot more careful about getting the hash&n; * switched - we have to switch the hash value properly even if it&n; * then no longer matches the actual (corrupted) string of the target.&n; * The hash value has to match the hash queue that the dentry is on..&n; */
DECL|function|switch_names
r_static
r_inline
r_void
id|switch_names
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|dentry
op_star
id|target
)paren
(brace
r_const
r_int
r_char
op_star
id|old_name
comma
op_star
id|new_name
suffix:semicolon
id|memcpy
c_func
(paren
id|dentry-&gt;d_iname
comma
id|target-&gt;d_iname
comma
id|DNAME_INLINE_LEN
)paren
suffix:semicolon
id|old_name
op_assign
id|target-&gt;d_name.name
suffix:semicolon
id|new_name
op_assign
id|dentry-&gt;d_name.name
suffix:semicolon
r_if
c_cond
(paren
id|old_name
op_eq
id|target-&gt;d_iname
)paren
id|old_name
op_assign
id|dentry-&gt;d_iname
suffix:semicolon
r_if
c_cond
(paren
id|new_name
op_eq
id|dentry-&gt;d_iname
)paren
id|new_name
op_assign
id|target-&gt;d_iname
suffix:semicolon
id|target-&gt;d_name.name
op_assign
id|new_name
suffix:semicolon
id|dentry-&gt;d_name.name
op_assign
id|old_name
suffix:semicolon
)brace
multiline_comment|/*&n; * We cannibalize &quot;target&quot; when moving dentry on top of it,&n; * because it&squot;s going to be thrown away anyway. We could be more&n; * polite about it, though.&n; *&n; * This forceful removal will result in ugly /proc output if&n; * somebody holds a file open that got deleted due to a rename.&n; * We could be nicer about the deleted file, and let it show&n; * up under the name it got deleted rather than the name that&n; * deleted it.&n; *&n; * Careful with the hash switch. The hash switch depends on&n; * the fact that any list-entry can be a head of the list.&n; * Think about it.&n; */
multiline_comment|/**&n; * d_move - move a dentry&n; * @dentry: entry to move&n; * @target: new dentry&n; *&n; * Update the dcache to reflect the move of a file name. Negative&n; * dcache entries should not be moved in this way.&n; */
DECL|function|d_move
r_void
id|d_move
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|dentry
op_star
id|target
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFS: moving negative dcache entry&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
multiline_comment|/* Move the dentry to the target hash queue */
id|list_del
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dentry-&gt;d_hash
comma
op_amp
id|target-&gt;d_hash
)paren
suffix:semicolon
multiline_comment|/* Unhash the target: dput() will then get rid of it */
id|list_del_init
c_func
(paren
op_amp
id|target-&gt;d_hash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dentry-&gt;d_child
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|target-&gt;d_child
)paren
suffix:semicolon
multiline_comment|/* Switch the names.. */
id|switch_names
c_func
(paren
id|dentry
comma
id|target
)paren
suffix:semicolon
id|do_switch
c_func
(paren
id|dentry-&gt;d_name.len
comma
id|target-&gt;d_name.len
)paren
suffix:semicolon
id|do_switch
c_func
(paren
id|dentry-&gt;d_name.hash
comma
id|target-&gt;d_name.hash
)paren
suffix:semicolon
multiline_comment|/* ... and switch the parents */
id|write_lock
c_func
(paren
op_amp
id|dparent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ROOT
c_func
(paren
id|dentry
)paren
)paren
(brace
id|dentry-&gt;d_parent
op_assign
id|target-&gt;d_parent
suffix:semicolon
id|target-&gt;d_parent
op_assign
id|target
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|target-&gt;d_child
)paren
suffix:semicolon
)brace
r_else
(brace
id|do_switch
c_func
(paren
id|dentry-&gt;d_parent
comma
id|target-&gt;d_parent
)paren
suffix:semicolon
multiline_comment|/* And add them back to the (new) parent lists */
id|list_add
c_func
(paren
op_amp
id|target-&gt;d_child
comma
op_amp
id|target-&gt;d_parent-&gt;d_subdirs
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|dparent_lock
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dentry-&gt;d_child
comma
op_amp
id|dentry-&gt;d_parent-&gt;d_subdirs
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * d_path - return the path of a dentry&n; * @dentry: dentry to report&n; * @vfsmnt: vfsmnt to which the dentry belongs&n; * @root: root dentry&n; * @rootmnt: vfsmnt to which the root dentry belongs&n; * @buffer: buffer to return value in&n; * @buflen: buffer length&n; *&n; * Convert a dentry into an ASCII path name. If the entry has been deleted&n; * the string &quot; (deleted)&quot; is appended. Note that this is ambiguous. Returns&n; * the buffer.&n; *&n; * &quot;buflen&quot; should be %PAGE_SIZE or more. Caller holds the dcache_lock.&n; */
DECL|function|__d_path
r_char
op_star
id|__d_path
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
id|vfsmnt
comma
r_struct
id|dentry
op_star
id|root
comma
r_struct
id|vfsmount
op_star
id|rootmnt
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_char
op_star
id|end
op_assign
id|buffer
op_plus
id|buflen
suffix:semicolon
r_char
op_star
id|retval
suffix:semicolon
r_int
id|namelen
suffix:semicolon
op_star
op_decrement
id|end
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|buflen
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ROOT
c_func
(paren
id|dentry
)paren
op_logical_and
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
)paren
(brace
id|buflen
op_sub_assign
l_int|10
suffix:semicolon
id|end
op_sub_assign
l_int|10
suffix:semicolon
id|memcpy
c_func
(paren
id|end
comma
l_string|&quot; (deleted)&quot;
comma
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* Get &squot;/&squot; right */
id|retval
op_assign
id|end
op_minus
l_int|1
suffix:semicolon
op_star
id|retval
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|root
op_logical_and
id|vfsmnt
op_eq
id|rootmnt
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|vfsmnt-&gt;mnt_root
op_logical_or
id|IS_ROOT
c_func
(paren
id|dentry
)paren
)paren
(brace
multiline_comment|/* Global root? */
r_if
c_cond
(paren
id|vfsmnt-&gt;mnt_parent
op_eq
id|vfsmnt
)paren
r_goto
id|global_root
suffix:semicolon
id|dentry
op_assign
id|vfsmnt-&gt;mnt_mountpoint
suffix:semicolon
id|vfsmnt
op_assign
id|vfsmnt-&gt;mnt_parent
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|parent
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
id|namelen
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
id|buflen
op_sub_assign
id|namelen
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|buflen
OL
l_int|0
)paren
r_break
suffix:semicolon
id|end
op_sub_assign
id|namelen
suffix:semicolon
id|memcpy
c_func
(paren
id|end
comma
id|dentry-&gt;d_name.name
comma
id|namelen
)paren
suffix:semicolon
op_star
op_decrement
id|end
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|retval
op_assign
id|end
suffix:semicolon
id|dentry
op_assign
id|parent
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
id|global_root
suffix:colon
id|namelen
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
id|buflen
op_sub_assign
id|namelen
suffix:semicolon
r_if
c_cond
(paren
id|buflen
op_ge
l_int|0
)paren
(brace
id|retval
op_sub_assign
id|namelen
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* hit the slash */
id|memcpy
c_func
(paren
id|retval
comma
id|dentry-&gt;d_name.name
comma
id|namelen
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE! The user-level library version returns a&n; * character pointer. The kernel system call just&n; * returns the length of the buffer filled (which&n; * includes the ending &squot;&bslash;0&squot; character), or a negative&n; * error value. So libc would do something like&n; *&n; *&t;char *getcwd(char * buf, size_t size)&n; *&t;{&n; *&t;&t;int retval;&n; *&n; *&t;&t;retval = sys_getcwd(buf, size);&n; *&t;&t;if (retval &gt;= 0)&n; *&t;&t;&t;return buf;&n; *&t;&t;errno = -retval;&n; *&t;&t;return NULL;&n; *&t;}&n; */
DECL|function|sys_getcwd
id|asmlinkage
r_int
id|sys_getcwd
c_func
(paren
r_char
op_star
id|buf
comma
r_int
r_int
id|size
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|vfsmount
op_star
id|pwdmnt
comma
op_star
id|rootmnt
suffix:semicolon
r_struct
id|dentry
op_star
id|pwd
comma
op_star
id|root
suffix:semicolon
r_char
op_star
id|page
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|pwdmnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;pwdmnt
)paren
suffix:semicolon
id|pwd
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;pwd
)paren
suffix:semicolon
id|rootmnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;rootmnt
)paren
suffix:semicolon
id|root
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* Has the current directory has been unlinked? */
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pwd-&gt;d_parent
op_eq
id|pwd
op_logical_or
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pwd-&gt;d_hash
)paren
)paren
(brace
r_int
r_int
id|len
suffix:semicolon
r_char
op_star
id|cwd
suffix:semicolon
id|cwd
op_assign
id|__d_path
c_func
(paren
id|pwd
comma
id|pwdmnt
comma
id|root
comma
id|rootmnt
comma
id|page
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ERANGE
suffix:semicolon
id|len
op_assign
id|PAGE_SIZE
op_plus
id|page
op_minus
id|cwd
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|size
)paren
(brace
id|error
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|cwd
comma
id|len
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
id|pwd
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|pwdmnt
)paren
suffix:semicolon
id|dput
c_func
(paren
id|root
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|rootmnt
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Test whether new_dentry is a subdirectory of old_dentry.&n; *&n; * Trivially implemented using the dcache structure&n; */
multiline_comment|/**&n; * is_subdir - is new dentry a subdirectory of old_dentry&n; * @new_dentry: new dentry&n; * @old_dentry: old dentry&n; *&n; * Returns 1 if new_dentry is a subdirectory of the parent (at any depth).&n; * Returns 0 otherwise.&n; */
DECL|function|is_subdir
r_int
id|is_subdir
c_func
(paren
r_struct
id|dentry
op_star
id|new_dentry
comma
r_struct
id|dentry
op_star
id|old_dentry
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|new_dentry
op_ne
id|old_dentry
)paren
(brace
r_struct
id|dentry
op_star
id|parent
op_assign
id|new_dentry-&gt;d_parent
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
id|new_dentry
)paren
r_break
suffix:semicolon
id|new_dentry
op_assign
id|parent
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|result
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|d_genocide
r_void
id|d_genocide
c_func
(paren
r_struct
id|dentry
op_star
id|root
)paren
(brace
r_struct
id|dentry
op_star
id|this_parent
op_assign
id|root
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|repeat
suffix:colon
id|next
op_assign
id|this_parent-&gt;d_subdirs.next
suffix:semicolon
id|resume
suffix:colon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|this_parent-&gt;d_subdirs
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|next
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
id|next
op_assign
id|tmp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|d_unhashed
c_func
(paren
id|dentry
)paren
op_logical_or
op_logical_neg
id|dentry-&gt;d_inode
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
)paren
(brace
id|this_parent
op_assign
id|dentry
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this_parent
op_ne
id|root
)paren
(brace
id|next
op_assign
id|this_parent-&gt;d_child.next
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|this_parent-&gt;d_count
)paren
suffix:semicolon
id|this_parent
op_assign
id|this_parent-&gt;d_parent
suffix:semicolon
r_goto
id|resume
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * find_inode_number - check for dentry with name&n; * @dir: directory to check&n; * @name: Name to find.&n; *&n; * Check whether a dentry already exists for the given name,&n; * and return the inode number if it has an inode. Otherwise&n; * 0 is returned.&n; *&n; * This routine is used to post-process directory listings for&n; * filesystems using synthetic inode numbers, and is necessary&n; * to keep getcwd() working.&n; */
DECL|function|find_inode_number
id|ino_t
id|find_inode_number
c_func
(paren
r_struct
id|dentry
op_star
id|dir
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|ino_t
id|ino
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Check for a fs-specific hash function. Note that we must&n;&t; * calculate the standard hash first, as the d_op-&gt;d_hash()&n;&t; * routine may choose to leave the hash value unchanged.&n;&t; */
id|name-&gt;hash
op_assign
id|full_name_hash
c_func
(paren
id|name-&gt;name
comma
id|name-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_op
op_logical_and
id|dir-&gt;d_op-&gt;d_hash
)paren
(brace
r_if
c_cond
(paren
id|dir-&gt;d_op
op_member_access_from_pointer
id|d_hash
c_func
(paren
id|dir
comma
id|name
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
id|dentry
op_assign
id|d_lookup
c_func
(paren
id|dir
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
id|ino
op_assign
id|dentry-&gt;d_inode-&gt;i_ino
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ino
suffix:semicolon
)brace
DECL|function|dcache_init
r_static
r_void
id|__init
id|dcache_init
c_func
(paren
r_int
r_int
id|mempages
)paren
(brace
r_struct
id|list_head
op_star
id|d
suffix:semicolon
r_int
r_int
id|order
suffix:semicolon
r_int
r_int
id|nr_hash
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* &n;&t; * A constructor could be added for stable state like the lists,&n;&t; * but it is probably not worth it because of the cache nature&n;&t; * of the dcache. &n;&t; * If fragmentation is too bad then the SLAB_HWCACHE_ALIGN&n;&t; * flag could be removed here, to hint to the allocator that&n;&t; * it should not try to get multiple page regions.  &n;&t; */
id|dentry_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dentry_cache&quot;
comma
r_sizeof
(paren
r_struct
id|dentry
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry_cache
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create dentry cache&quot;
)paren
suffix:semicolon
id|set_shrinker
c_func
(paren
id|DEFAULT_SEEKS
comma
id|shrink_dcache_memory
)paren
suffix:semicolon
macro_line|#if PAGE_SHIFT &lt; 13
id|mempages
op_rshift_assign
(paren
l_int|13
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
macro_line|#endif
id|mempages
op_mul_assign
r_sizeof
(paren
r_struct
id|list_head
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
(paren
(paren
l_int|1UL
op_lshift
id|order
)paren
op_lshift
id|PAGE_SHIFT
)paren
OL
id|mempages
suffix:semicolon
id|order
op_increment
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|nr_hash
op_assign
(paren
l_int|1UL
op_lshift
id|order
)paren
op_star
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|list_head
)paren
suffix:semicolon
id|d_hash_mask
op_assign
(paren
id|nr_hash
op_minus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|nr_hash
suffix:semicolon
id|d_hash_shift
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_rshift_assign
l_int|1UL
)paren
op_ne
l_int|0UL
)paren
id|d_hash_shift
op_increment
suffix:semicolon
id|dentry_hashtable
op_assign
(paren
r_struct
id|list_head
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dentry_hashtable
op_eq
l_int|NULL
op_logical_and
op_decrement
id|order
op_ge
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Dentry cache hash table entries: %d (order: %ld, %ld bytes)&bslash;n&quot;
comma
id|nr_hash
comma
id|order
comma
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry_hashtable
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate dcache hash table&bslash;n&quot;
)paren
suffix:semicolon
id|d
op_assign
id|dentry_hashtable
suffix:semicolon
id|i
op_assign
id|nr_hash
suffix:semicolon
r_do
(brace
id|INIT_LIST_HEAD
c_func
(paren
id|d
)paren
suffix:semicolon
id|d
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* SLAB cache for __getname() consumers */
DECL|variable|names_cachep
id|kmem_cache_t
op_star
id|names_cachep
suffix:semicolon
multiline_comment|/* SLAB cache for file structures */
DECL|variable|filp_cachep
id|kmem_cache_t
op_star
id|filp_cachep
suffix:semicolon
DECL|variable|d_genocide
id|EXPORT_SYMBOL
c_func
(paren
id|d_genocide
)paren
suffix:semicolon
r_extern
r_void
id|bdev_cache_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|cdev_cache_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|vfs_caches_init
r_void
id|__init
id|vfs_caches_init
c_func
(paren
r_int
r_int
id|mempages
)paren
(brace
id|names_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;names_cache&quot;
comma
id|PATH_MAX
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|names_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;Cannot create names SLAB cache&quot;
)paren
suffix:semicolon
id|filp_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;filp&quot;
comma
r_sizeof
(paren
r_struct
id|file
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Cannot create filp SLAB cache&quot;
)paren
suffix:semicolon
)brace
id|dcache_init
c_func
(paren
id|mempages
)paren
suffix:semicolon
id|inode_init
c_func
(paren
id|mempages
)paren
suffix:semicolon
id|files_init
c_func
(paren
id|mempages
)paren
suffix:semicolon
id|mnt_init
c_func
(paren
id|mempages
)paren
suffix:semicolon
id|bdev_cache_init
c_func
(paren
)paren
suffix:semicolon
id|cdev_cache_init
c_func
(paren
)paren
suffix:semicolon
)brace
eof
