multiline_comment|/*&n; *  drivers/char/eventpoll.c ( Efficent event polling implementation )&n; *  Copyright (C) 2001,...,2002&t; Davide Libenzi&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  Davide Libenzi &lt;davidel@xmailserver.org&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mman.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/eventpoll.h&gt;
DECL|macro|EVENTPOLLFS_MAGIC
mdefine_line|#define EVENTPOLLFS_MAGIC 0x03111965 /* My birthday should work for this :) */
DECL|macro|DEBUG_EPOLL
mdefine_line|#define DEBUG_EPOLL 0
macro_line|#if DEBUG_EPOLL &gt; 0
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x) printk x
DECL|macro|DNPRINTK
mdefine_line|#define DNPRINTK(n, x) do { if ((n) &lt;= DEBUG_EPOLL) printk x; } while (0)
macro_line|#else /* #if DEBUG_EPOLL &gt; 0 */
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x) (void) 0
DECL|macro|DNPRINTK
mdefine_line|#define DNPRINTK(n, x) (void) 0
macro_line|#endif /* #if DEBUG_EPOLL &gt; 0 */
DECL|macro|DEBUG_DPI
mdefine_line|#define DEBUG_DPI 0
macro_line|#if DEBUG_DPI != 0
DECL|macro|DPI_SLAB_DEBUG
mdefine_line|#define DPI_SLAB_DEBUG (SLAB_DEBUG_FREE | SLAB_RED_ZONE /* | SLAB_POISON */)
macro_line|#else /* #if DEBUG_DPI != 0 */
DECL|macro|DPI_SLAB_DEBUG
mdefine_line|#define DPI_SLAB_DEBUG 0
macro_line|#endif /* #if DEBUG_DPI != 0 */
multiline_comment|/* Maximum storage for the eventpoll interest set */
DECL|macro|EP_MAX_FDS_SIZE
mdefine_line|#define EP_MAX_FDS_SIZE (1024 * 128)
multiline_comment|/* We don&squot;t want the hash to be smaller than this */
DECL|macro|EP_MIN_HASH_SIZE
mdefine_line|#define EP_MIN_HASH_SIZE 101
multiline_comment|/*&n; * Event buffer dimension used to cache events before sending them in&n; * userspace with a __copy_to_user(). The event buffer is in stack,&n; * so keep this size fairly small.&n; */
DECL|macro|EP_EVENT_BUFF_SIZE
mdefine_line|#define EP_EVENT_BUFF_SIZE 32
multiline_comment|/* Maximum number of wait queue we can attach to */
DECL|macro|EP_MAX_POLL_QUEUE
mdefine_line|#define EP_MAX_POLL_QUEUE 2
multiline_comment|/* Number of hash entries ( &quot;struct list_head&quot; ) inside a page */
DECL|macro|EP_HENTRY_X_PAGE
mdefine_line|#define EP_HENTRY_X_PAGE (PAGE_SIZE / sizeof(struct list_head))
multiline_comment|/* Maximum size of the hash in pages */
DECL|macro|EP_MAX_HPAGES
mdefine_line|#define EP_MAX_HPAGES (EP_MAX_FDS_SIZE / EP_HENTRY_X_PAGE + 1)
multiline_comment|/* Macro to allocate a &quot;struct epitem&quot; from the slab cache */
DECL|macro|DPI_MEM_ALLOC
mdefine_line|#define DPI_MEM_ALLOC()&t;(struct epitem *) kmem_cache_alloc(dpi_cache, SLAB_KERNEL)
multiline_comment|/* Macro to free a &quot;struct epitem&quot; to the slab cache */
DECL|macro|DPI_MEM_FREE
mdefine_line|#define DPI_MEM_FREE(p) kmem_cache_free(dpi_cache, p)
multiline_comment|/* Fast test to see if the file is an evenpoll file */
DECL|macro|IS_FILE_EPOLL
mdefine_line|#define IS_FILE_EPOLL(f) ((f)-&gt;f_op == &amp;eventpoll_fops)
multiline_comment|/*&n; * Remove the item from the list and perform its initialization.&n; * This is usefull for us because we can test if the item is linked&n; * using &quot;EP_IS_LINKED(p)&quot;.&n; */
DECL|macro|EP_LIST_DEL
mdefine_line|#define EP_LIST_DEL(p) do { list_del(p); INIT_LIST_HEAD(p); } while (0)
multiline_comment|/* Tells us if the item is currently linked */
DECL|macro|EP_IS_LINKED
mdefine_line|#define EP_IS_LINKED(p) (!list_empty(p))
multiline_comment|/* Get the &quot;struct epitem&quot; from a wait queue pointer */
DECL|macro|EP_ITEM_FROM_WAIT
mdefine_line|#define EP_ITEM_FROM_WAIT(p) ((struct epitem *) container_of(p, struct eppoll_entry, wait)-&gt;base)
multiline_comment|/*&n; * This structure is stored inside the &quot;private_data&quot; member of the file&n; * structure and rapresent the main data sructure for the eventpoll&n; * interface.&n; */
DECL|struct|eventpoll
r_struct
id|eventpoll
(brace
multiline_comment|/* Used to link to the &quot;struct eventpoll&quot; list ( eplist ) */
DECL|member|llink
r_struct
id|list_head
id|llink
suffix:semicolon
multiline_comment|/* Protect the this structure access */
DECL|member|lock
id|rwlock_t
id|lock
suffix:semicolon
multiline_comment|/* Wait queue used by sys_epoll_wait() */
DECL|member|wq
id|wait_queue_head_t
id|wq
suffix:semicolon
multiline_comment|/* Wait queue used by file-&gt;poll() */
DECL|member|poll_wait
id|wait_queue_head_t
id|poll_wait
suffix:semicolon
multiline_comment|/* List of ready file descriptors */
DECL|member|rdllist
r_struct
id|list_head
id|rdllist
suffix:semicolon
multiline_comment|/* Size of the hash */
DECL|member|hsize
r_int
id|hsize
suffix:semicolon
multiline_comment|/* Number of pages currently allocated for the hash */
DECL|member|nhpages
r_int
id|nhpages
suffix:semicolon
multiline_comment|/* Pages for the &quot;struct epitem&quot; hash */
DECL|member|hpages
r_char
op_star
id|hpages
(braket
id|EP_MAX_HPAGES
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Wait structure used by the poll hooks */
DECL|struct|eppoll_entry
r_struct
id|eppoll_entry
(brace
multiline_comment|/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */
DECL|member|base
r_void
op_star
id|base
suffix:semicolon
multiline_comment|/*&n;&t; * Wait queue item that will be linked to the target file wait&n;&t; * queue head.&n;&t; */
DECL|member|wait
id|wait_queue_t
id|wait
suffix:semicolon
multiline_comment|/* The wait queue head that linked the &quot;wait&quot; wait queue item */
DECL|member|whead
id|wait_queue_head_t
op_star
id|whead
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Each file descriptor added to the eventpoll interface will&n; * have an entry of this type linked to the hash.&n; */
DECL|struct|epitem
r_struct
id|epitem
(brace
multiline_comment|/* List header used to link this structure to the eventpoll hash */
DECL|member|llink
r_struct
id|list_head
id|llink
suffix:semicolon
multiline_comment|/* List header used to link this structure to the eventpoll ready list */
DECL|member|rdllink
r_struct
id|list_head
id|rdllink
suffix:semicolon
multiline_comment|/* Number of active wait queue attached to poll operations */
DECL|member|nwait
r_int
id|nwait
suffix:semicolon
multiline_comment|/* Wait queue used to attach poll operations */
DECL|member|wait
r_struct
id|eppoll_entry
id|wait
(braket
id|EP_MAX_POLL_QUEUE
)braket
suffix:semicolon
multiline_comment|/* The &quot;container&quot; of this item */
DECL|member|ep
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
multiline_comment|/* The file this item refers to */
DECL|member|file
r_struct
id|file
op_star
id|file
suffix:semicolon
multiline_comment|/* The structure that describe the interested events and the source fd */
DECL|member|pfd
r_struct
id|pollfd
id|pfd
suffix:semicolon
multiline_comment|/*&n;&t; * Used to keep track of the usage count of the structure. This avoids&n;&t; * that the structure will desappear from underneath our processing.&n;&t; */
DECL|member|usecnt
id|atomic_t
id|usecnt
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|ep_is_prime
c_func
(paren
r_int
id|n
)paren
suffix:semicolon
r_static
r_int
id|ep_getfd
c_func
(paren
r_int
op_star
id|efd
comma
r_struct
id|inode
op_star
op_star
id|einode
comma
r_struct
id|file
op_star
op_star
id|efile
)paren
suffix:semicolon
r_static
r_int
id|ep_alloc_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
suffix:semicolon
r_static
r_int
id|ep_free_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
suffix:semicolon
r_static
r_int
id|ep_file_init
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
id|hsize
)paren
suffix:semicolon
r_static
r_int
id|ep_hash_index
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_struct
id|list_head
op_star
id|ep_hash_entry
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|index
)paren
suffix:semicolon
r_static
r_int
id|ep_init
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|hsize
)paren
suffix:semicolon
r_static
r_void
id|ep_free
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
suffix:semicolon
r_static
r_struct
id|epitem
op_star
id|ep_find
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|ep_use_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|dpi
)paren
suffix:semicolon
r_static
r_void
id|ep_release_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|dpi
)paren
suffix:semicolon
r_static
r_void
id|ep_ptable_queue_proc
c_func
(paren
r_void
op_star
id|priv
comma
id|wait_queue_head_t
op_star
id|whead
)paren
suffix:semicolon
r_static
r_int
id|ep_insert
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|pfd
comma
r_struct
id|file
op_star
id|tfile
)paren
suffix:semicolon
r_static
r_int
r_int
id|ep_get_file_events
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|ep_modify
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
comma
r_int
r_int
id|events
)paren
suffix:semicolon
r_static
r_int
id|ep_unlink
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
)paren
suffix:semicolon
r_static
r_int
id|ep_remove
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
)paren
suffix:semicolon
r_static
r_int
id|ep_poll_callback
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
)paren
suffix:semicolon
r_static
r_int
id|ep_eventpoll_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
r_int
id|ep_eventpoll_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|ep_events_transfer
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|events
comma
r_int
id|maxevents
)paren
suffix:semicolon
r_static
r_int
id|ep_poll
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|events
comma
r_int
id|maxevents
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_int
id|eventpollfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
suffix:semicolon
r_static
r_struct
id|inode
op_star
id|ep_eventpoll_inode
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|super_block
op_star
id|eventpollfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/* Use to link togheter all the &quot;struct eventpoll&quot; */
DECL|variable|eplist
r_static
r_struct
id|list_head
id|eplist
suffix:semicolon
multiline_comment|/* Serialize the access to &quot;eplist&quot; */
DECL|variable|eplock
r_static
id|rwlock_t
id|eplock
suffix:semicolon
multiline_comment|/* Slab cache used to allocate &quot;struct epitem&quot; */
DECL|variable|dpi_cache
r_static
id|kmem_cache_t
op_star
id|dpi_cache
suffix:semicolon
multiline_comment|/* Virtual fs used to allocate inodes for eventpoll files */
DECL|variable|eventpoll_mnt
r_static
r_struct
id|vfsmount
op_star
id|eventpoll_mnt
suffix:semicolon
multiline_comment|/* File callbacks that implement the eventpoll file behaviour */
DECL|variable|eventpoll_fops
r_static
r_struct
id|file_operations
id|eventpoll_fops
op_assign
(brace
dot
id|release
op_assign
id|ep_eventpoll_close
comma
dot
id|poll
op_assign
id|ep_eventpoll_poll
)brace
suffix:semicolon
multiline_comment|/*&n; * This is used to register the virtual file system from where&n; * eventpoll inodes are allocated.&n; */
DECL|variable|eventpoll_fs_type
r_static
r_struct
id|file_system_type
id|eventpoll_fs_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;eventpollfs&quot;
comma
dot
id|get_sb
op_assign
id|eventpollfs_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_anon_super
comma
)brace
suffix:semicolon
multiline_comment|/* Very basic directory entry operations for the eventpoll virtual file system */
DECL|variable|eventpollfs_dentry_operations
r_static
r_struct
id|dentry_operations
id|eventpollfs_dentry_operations
op_assign
(brace
dot
id|d_delete
op_assign
id|eventpollfs_delete_dentry
comma
)brace
suffix:semicolon
multiline_comment|/* Report if the number is prime. Needed to correctly size the hash  */
DECL|function|ep_is_prime
r_static
r_int
id|ep_is_prime
c_func
(paren
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|n
OG
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|n
op_amp
l_int|1
)paren
(brace
r_int
id|i
comma
id|hn
op_assign
id|n
op_div
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
OL
id|hn
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|n
op_mod
id|i
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from inside fs/file_table.c:__fput() to unlink files&n; * from the eventpoll interface. We need to have this facility to cleanup&n; * correctly files that are closed without being removed from the eventpoll&n; * interface.&n; */
DECL|function|ep_notify_file_close
r_void
id|ep_notify_file_close
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|lnk
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|eplock
comma
id|flags
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lnk
comma
op_amp
id|eplist
)paren
(brace
id|ep
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|eventpoll
comma
id|llink
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dpi
op_assign
id|ep_find
c_func
(paren
id|ep
comma
id|file
)paren
)paren
)paren
(brace
id|ep_remove
c_func
(paren
id|ep
comma
id|dpi
)paren
suffix:semicolon
id|ep_release_epitem
c_func
(paren
id|dpi
)paren
suffix:semicolon
)brace
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|eplock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * It opens an eventpoll file descriptor by suggesting a storage of &quot;size&quot;&n; * file descriptors. It is the kernel part of the userspace epoll_create(2).&n; */
DECL|function|sys_epoll_create
id|asmlinkage
r_int
id|sys_epoll_create
c_func
(paren
r_int
id|size
)paren
(brace
r_int
id|error
comma
id|fd
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d)&bslash;n&quot;
comma
id|current
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/* Search the nearest prime number higher than &quot;size&quot; */
r_for
c_loop
(paren
suffix:semicolon
op_logical_neg
id|ep_is_prime
c_func
(paren
id|size
)paren
suffix:semicolon
id|size
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
id|EP_MIN_HASH_SIZE
)paren
id|size
op_assign
id|EP_MIN_HASH_SIZE
suffix:semicolon
multiline_comment|/*&n;&t; * Creates all the items needed to setup an eventpoll file. That is,&n;&t; * a file structure, and inode and a free file descriptor.&n;&t; */
id|error
op_assign
id|ep_getfd
c_func
(paren
op_amp
id|fd
comma
op_amp
id|inode
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Setup the file internal data structure ( &quot;struct eventpoll&quot; ) */
id|error
op_assign
id|ep_file_init
c_func
(paren
id|file
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_2
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d) = %d&bslash;n&quot;
comma
id|current
comma
id|size
comma
id|fd
)paren
)paren
suffix:semicolon
r_return
id|fd
suffix:semicolon
id|eexit_2
suffix:colon
id|sys_close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d) = %d&bslash;n&quot;
comma
id|current
comma
id|size
comma
id|error
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The following function implement the controller interface for the eventpoll&n; * file that enable the insertion/removal/change of file descriptors inside&n; * the interest set. It rapresents the kernel part of the user spcae epoll_ctl(2).&n; */
DECL|function|sys_epoll_ctl
id|asmlinkage
r_int
id|sys_epoll_ctl
c_func
(paren
r_int
id|epfd
comma
r_int
id|op
comma
r_int
id|fd
comma
r_int
r_int
id|events
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
comma
op_star
id|tfile
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
r_struct
id|pollfd
id|pfd
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u)&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|op
comma
id|fd
comma
id|events
)paren
)paren
suffix:semicolon
multiline_comment|/* Get the &quot;struct file *&quot; for the eventpoll file */
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|epfd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Get the &quot;struct file *&quot; for the target file */
id|tfile
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tfile
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* The target file descriptor must support poll */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tfile-&gt;f_op
op_logical_or
op_logical_neg
id|tfile-&gt;f_op-&gt;poll
)paren
r_goto
id|eexit_3
suffix:semicolon
multiline_comment|/*&n;&t; * We have to check that the file structure underneath the file descriptor&n;&t; * the user passed to us _is_ an eventpoll file.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_FILE_EPOLL
c_func
(paren
id|file
)paren
)paren
r_goto
id|eexit_3
suffix:semicolon
multiline_comment|/*&n;&t; * At this point it is safe to assume that the &quot;private_data&quot; contains&n;&t; * our own data structure.&n;&t; */
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/*&n;&t; * Try to lookup the file inside our hash table. When an item is found&n;&t; * ep_find() increases the usage count of the item so that it won&squot;t&n;&t; * desappear underneath us. The only thing that might happen, if someone&n;&t; * tries very hard, is a double insertion of the same file descriptor.&n;&t; * This does not rapresent a problem though and we don&squot;t really want&n;&t; * to put an extra syncronization object to deal with this harmless condition.&n;&t; */
id|dpi
op_assign
id|ep_find
c_func
(paren
id|ep
comma
id|tfile
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|EP_CTL_ADD
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dpi
)paren
(brace
id|pfd.fd
op_assign
id|fd
suffix:semicolon
id|pfd.events
op_assign
id|events
op_or
id|POLLERR
op_or
id|POLLHUP
suffix:semicolon
id|pfd.revents
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|ep_insert
c_func
(paren
id|ep
comma
op_amp
id|pfd
comma
id|tfile
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EP_CTL_DEL
suffix:colon
r_if
c_cond
(paren
id|dpi
)paren
id|error
op_assign
id|ep_remove
c_func
(paren
id|ep
comma
id|dpi
)paren
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EP_CTL_MOD
suffix:colon
r_if
c_cond
(paren
id|dpi
)paren
id|error
op_assign
id|ep_modify
c_func
(paren
id|ep
comma
id|dpi
comma
id|events
op_or
id|POLLERR
op_or
id|POLLHUP
)paren
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The function ep_find() increments the usage count of the structure&n;&t; * so, if this is not NULL, we need to release it.&n;&t; */
r_if
c_cond
(paren
id|dpi
)paren
id|ep_release_epitem
c_func
(paren
id|dpi
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %u) = %d&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|op
comma
id|fd
comma
id|events
comma
id|error
)paren
)paren
suffix:semicolon
id|eexit_3
suffix:colon
id|fput
c_func
(paren
id|tfile
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Implement the event wait interface for the eventpoll file. It is the kernel&n; * part of the user space epoll_wait(2).&n; */
DECL|function|sys_epoll_wait
id|asmlinkage
r_int
id|sys_epoll_wait
c_func
(paren
r_int
id|epfd
comma
r_struct
id|pollfd
op_star
id|events
comma
r_int
id|maxevents
comma
r_int
id|timeout
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d)&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|events
comma
id|maxevents
comma
id|timeout
)paren
)paren
suffix:semicolon
multiline_comment|/* Verify that the area passed by the user is writeable */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|events
comma
id|maxevents
op_star
r_sizeof
(paren
r_struct
id|pollfd
)paren
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Get the &quot;struct file *&quot; for the eventpoll file */
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|epfd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * We have to check that the file structure underneath the file descriptor&n;&t; * the user passed to us _is_ an eventpoll file.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_FILE_EPOLL
c_func
(paren
id|file
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/*&n;&t; * At this point it is safe to assume that the &quot;private_data&quot; contains&n;&t; * our own data structure.&n;&t; */
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/* Time to fish for events ... */
id|error
op_assign
id|ep_poll
c_func
(paren
id|ep
comma
id|events
comma
id|maxevents
comma
id|timeout
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d) = %d&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|events
comma
id|maxevents
comma
id|timeout
comma
id|error
)paren
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Creates the file descriptor to be used by the epoll interface.&n; */
DECL|function|ep_getfd
r_static
r_int
id|ep_getfd
c_func
(paren
r_int
op_star
id|efd
comma
r_struct
id|inode
op_star
op_star
id|einode
comma
r_struct
id|file
op_star
op_star
id|efile
)paren
(brace
r_struct
id|qstr
id|this
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
id|error
comma
id|fd
suffix:semicolon
multiline_comment|/* Get an ready to use file */
id|error
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Allocates an inode from the eventpoll file system */
id|inode
op_assign
id|ep_eventpoll_inode
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|inode
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* Allocates a free descriptor to plug the file onto */
id|error
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|eexit_3
suffix:semicolon
id|fd
op_assign
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Link the inode to a directory entry by creating a unique name&n;&t; * using the inode number.&n;&t; */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;[%lu]&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|eventpoll_mnt-&gt;mnt_sb-&gt;s_root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|eexit_4
suffix:semicolon
id|dentry-&gt;d_op
op_assign
op_amp
id|eventpollfs_dentry_operations
suffix:semicolon
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
id|file-&gt;f_dentry
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the file as read/write because it could be used&n;&t; * with write() to add/remove/change interest sets.&n;&t; */
id|file-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|file-&gt;f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|eventpoll_fops
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_READ
suffix:semicolon
id|file-&gt;f_version
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Install the new setup file into the allocated fd. */
id|fd_install
c_func
(paren
id|fd
comma
id|file
)paren
suffix:semicolon
op_star
id|efd
op_assign
id|fd
suffix:semicolon
op_star
id|einode
op_assign
id|inode
suffix:semicolon
op_star
id|efile
op_assign
id|file
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_4
suffix:colon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
id|eexit_3
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ep_alloc_pages
r_static
r_int
id|ep_alloc_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numpages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pages
(braket
id|i
)braket
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pages
(braket
id|i
)braket
)paren
(brace
r_for
c_loop
(paren
op_decrement
id|i
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|SetPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_free_pages
r_static
r_int
id|ep_free_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numpages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_file_init
r_static
r_int
id|ep_file_init
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
id|hsize
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ep
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eventpoll
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|ep
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ep
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ep_init
c_func
(paren
id|ep
comma
id|hsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|file-&gt;private_data
op_assign
id|ep
suffix:semicolon
multiline_comment|/* Add the structure to the linked list that links &quot;struct eventpoll&quot; */
id|write_lock_irqsave
c_func
(paren
op_amp
id|eplock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|ep-&gt;llink
comma
op_amp
id|eplist
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|eplock
comma
id|flags
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_file_init() ep=%p&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate the index of the hash relative to &quot;file&quot;.&n; */
DECL|function|ep_hash_index
r_static
r_int
id|ep_hash_index
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
(paren
r_int
)paren
(paren
(paren
(paren
(paren
r_int
r_int
)paren
id|file
)paren
op_div
r_sizeof
(paren
r_struct
id|file
)paren
)paren
op_mod
id|ep-&gt;hsize
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the hash entry ( struct list_head * ) of the passed index.&n; */
DECL|function|ep_hash_entry
r_static
r_struct
id|list_head
op_star
id|ep_hash_entry
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|index
)paren
(brace
r_return
(paren
r_struct
id|list_head
op_star
)paren
(paren
id|ep-&gt;hpages
(braket
id|index
op_div
id|EP_HENTRY_X_PAGE
)braket
op_plus
(paren
id|index
op_mod
id|EP_HENTRY_X_PAGE
)paren
op_star
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
suffix:semicolon
)brace
DECL|function|ep_init
r_static
r_int
id|ep_init
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
id|hsize
)paren
(brace
r_int
id|error
comma
id|i
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ep-&gt;llink
)paren
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
multiline_comment|/* Hash allocation and setup */
id|ep-&gt;hsize
op_assign
id|hsize
suffix:semicolon
id|ep-&gt;nhpages
op_assign
id|hsize
op_div
id|EP_HENTRY_X_PAGE
op_plus
(paren
id|hsize
op_mod
id|EP_HENTRY_X_PAGE
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|ep_alloc_pages
c_func
(paren
id|ep-&gt;hpages
comma
id|ep-&gt;nhpages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Initialize hash buckets */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ep-&gt;hsize
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|i
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ep_free
r_static
r_void
id|ep_free
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
suffix:semicolon
multiline_comment|/*&n;&t; * Walks through the whole hash by unregistering file callbacks and&n;&t; * freeing each &quot;struct epitem&quot;.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ep-&gt;hsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lsthead
op_assign
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We need to lock this because we could be hit by&n;&t;&t; * ep_notify_file_close() while we&squot;re freeing this.&n;&t;&t; */
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|lsthead
)paren
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
op_assign
id|list_entry
c_func
(paren
id|lsthead-&gt;next
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
multiline_comment|/* The function ep_unlink() must be called with held lock */
id|ep_unlink
c_func
(paren
id|ep
comma
id|dpi
)paren
suffix:semicolon
multiline_comment|/* We release the lock before releasing the &quot;struct epitem&quot; */
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|ep_release_epitem
c_func
(paren
id|dpi
)paren
suffix:semicolon
multiline_comment|/* And then we reaquire the lock ... */
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove the structure to the linked list that links &quot;struct eventpoll&quot; */
id|write_lock_irqsave
c_func
(paren
op_amp
id|eplock
comma
id|flags
)paren
suffix:semicolon
id|EP_LIST_DEL
c_func
(paren
op_amp
id|ep-&gt;llink
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|eplock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Free hash pages */
r_if
c_cond
(paren
id|ep-&gt;nhpages
OG
l_int|0
)paren
id|ep_free_pages
c_func
(paren
id|ep-&gt;hpages
comma
id|ep-&gt;nhpages
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Search the file inside the eventpoll hash. It add usage count to&n; * the returned item, so the caller must call ep_release_epitem()&n; * after finished using the &quot;struct epitem&quot;.&n; */
DECL|function|ep_find
r_static
r_struct
id|epitem
op_star
id|ep_find
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
comma
op_star
id|lnk
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
op_assign
l_int|NULL
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|lsthead
op_assign
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|ep_hash_index
c_func
(paren
id|ep
comma
id|file
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lnk
comma
id|lsthead
)paren
(brace
id|dpi
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dpi-&gt;file
op_eq
id|file
)paren
(brace
id|ep_use_epitem
c_func
(paren
id|dpi
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dpi
op_assign
l_int|NULL
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_find(%p) -&gt; %p&bslash;n&quot;
comma
id|current
comma
id|file
comma
id|dpi
)paren
)paren
suffix:semicolon
r_return
id|dpi
suffix:semicolon
)brace
multiline_comment|/*&n; * Increment the usage count of the &quot;struct epitem&quot; making it sure&n; * that the user will have a valid pointer to reference.&n; */
DECL|function|ep_use_epitem
r_static
r_void
id|ep_use_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|dpi
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|dpi-&gt;usecnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement ( release ) the usage count by signaling that the user&n; * has finished using the structure. It might lead to freeing the&n; * structure itself if the count goes to zero.&n; */
DECL|function|ep_release_epitem
r_static
r_void
id|ep_release_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|dpi
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|dpi-&gt;usecnt
)paren
)paren
id|DPI_MEM_FREE
c_func
(paren
id|dpi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the callback that is used to add our wait queue to the&n; * target file wakeup lists.&n; */
DECL|function|ep_ptable_queue_proc
r_static
r_void
id|ep_ptable_queue_proc
c_func
(paren
r_void
op_star
id|priv
comma
id|wait_queue_head_t
op_star
id|whead
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
op_assign
id|priv
suffix:semicolon
multiline_comment|/* No more than EP_MAX_POLL_QUEUE wait queue are supported */
r_if
c_cond
(paren
id|dpi-&gt;nwait
OL
id|EP_MAX_POLL_QUEUE
)paren
(brace
id|add_wait_queue
c_func
(paren
id|whead
comma
op_amp
id|dpi-&gt;wait
(braket
id|dpi-&gt;nwait
)braket
dot
id|wait
)paren
suffix:semicolon
id|dpi-&gt;wait
(braket
id|dpi-&gt;nwait
)braket
dot
id|whead
op_assign
id|whead
suffix:semicolon
id|dpi-&gt;nwait
op_increment
suffix:semicolon
)brace
)brace
DECL|function|ep_insert
r_static
r_int
id|ep_insert
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|pfd
comma
r_struct
id|file
op_star
id|tfile
)paren
(brace
r_int
id|error
comma
id|i
comma
id|revents
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
suffix:semicolon
id|poll_table
id|pt
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dpi
op_assign
id|DPI_MEM_ALLOC
c_func
(paren
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Item initialization follow here ... */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dpi-&gt;llink
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dpi-&gt;rdllink
)paren
suffix:semicolon
id|dpi-&gt;ep
op_assign
id|ep
suffix:semicolon
id|dpi-&gt;file
op_assign
id|tfile
suffix:semicolon
id|dpi-&gt;pfd
op_assign
op_star
id|pfd
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|dpi-&gt;usecnt
comma
l_int|1
)paren
suffix:semicolon
id|dpi-&gt;nwait
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EP_MAX_POLL_QUEUE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|init_waitqueue_func_entry
c_func
(paren
op_amp
id|dpi-&gt;wait
(braket
id|i
)braket
dot
id|wait
comma
id|ep_poll_callback
)paren
suffix:semicolon
id|dpi-&gt;wait
(braket
id|i
)braket
dot
id|whead
op_assign
l_int|NULL
suffix:semicolon
id|dpi-&gt;wait
(braket
id|i
)braket
dot
id|base
op_assign
id|dpi
suffix:semicolon
)brace
multiline_comment|/* Attach the item to the poll hooks */
id|poll_initwait_ex
c_func
(paren
op_amp
id|pt
comma
l_int|1
comma
id|ep_ptable_queue_proc
comma
id|dpi
)paren
suffix:semicolon
id|revents
op_assign
id|tfile-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|tfile
comma
op_amp
id|pt
)paren
suffix:semicolon
id|poll_freewait
c_func
(paren
op_amp
id|pt
)paren
suffix:semicolon
multiline_comment|/* We have to drop the new item inside our item list to keep track of it */
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dpi-&gt;llink
comma
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|ep_hash_index
c_func
(paren
id|ep
comma
id|tfile
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* If the file is already &quot;ready&quot; we drop it inside the ready list */
r_if
c_cond
(paren
(paren
id|revents
op_amp
id|pfd-&gt;events
)paren
op_logical_and
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|dpi-&gt;rdllink
)paren
)paren
id|list_add
c_func
(paren
op_amp
id|dpi-&gt;rdllink
comma
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_insert(%p, %d)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|pfd-&gt;fd
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the current events of the given file. It uses the special&n; * poll table initialization to avoid any poll queue insertion.&n; */
DECL|function|ep_get_file_events
r_static
r_int
r_int
id|ep_get_file_events
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|revents
suffix:semicolon
id|poll_table
id|pt
suffix:semicolon
multiline_comment|/*&n;&t; * This is a special poll table initialization that will&n;&t; * make poll_wait() to not perform any wait queue insertion when&n;&t; * called by file-&gt;f_op-&gt;poll(). This is a fast way to retrieve&n;&t; * file events with perform any queue insertion, hence saving CPU cycles.&n;&t; */
id|poll_initwait_ex
c_func
(paren
op_amp
id|pt
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|revents
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|file
comma
op_amp
id|pt
)paren
suffix:semicolon
id|poll_freewait
c_func
(paren
op_amp
id|pt
)paren
suffix:semicolon
r_return
id|revents
suffix:semicolon
)brace
multiline_comment|/*&n; * Modify the interest event mask by dropping an event if the new mask&n; * has a match in the current file status.&n; */
DECL|function|ep_modify
r_static
r_int
id|ep_modify
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
comma
r_int
r_int
id|events
)paren
(brace
r_int
r_int
id|revents
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|revents
op_assign
id|ep_get_file_events
c_func
(paren
id|dpi-&gt;file
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|dpi-&gt;pfd.events
op_assign
id|events
suffix:semicolon
multiline_comment|/* If the file is already &quot;ready&quot; we drop it inside the ready list */
r_if
c_cond
(paren
(paren
id|revents
op_amp
id|events
)paren
op_logical_and
id|EP_IS_LINKED
c_func
(paren
op_amp
id|dpi-&gt;llink
)paren
op_logical_and
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|dpi-&gt;rdllink
)paren
)paren
id|list_add
c_func
(paren
op_amp
id|dpi-&gt;rdllink
comma
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlink the &quot;struct epitem&quot; from all places it might have been hooked up.&n; * This function must be called with write IRQ lock on &quot;ep-&gt;lock&quot;.&n; */
DECL|function|ep_unlink
r_static
r_int
id|ep_unlink
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * It can happen that this one is called for an item already unlinked.&n;&t; * The check protect us from doing a double unlink ( crash ).&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|dpi-&gt;llink
)paren
)paren
r_goto
id|not_linked
suffix:semicolon
multiline_comment|/*&n;&t; * At this point is safe to do the job, unlink the item from our list.&n;&t; * This operation togheter with the above check closes the door to&n;&t; * double unlinks.&n;&t; */
id|EP_LIST_DEL
c_func
(paren
op_amp
id|dpi-&gt;llink
)paren
suffix:semicolon
multiline_comment|/* Removes poll wait queue hooks */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dpi-&gt;nwait
suffix:semicolon
id|i
op_increment
)paren
id|remove_wait_queue
c_func
(paren
id|dpi-&gt;wait
(braket
id|i
)braket
dot
id|whead
comma
op_amp
id|dpi-&gt;wait
(braket
id|i
)braket
dot
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the item we are going to remove is inside the ready file descriptors&n;&t; * we want to remove it from this list to avoid stale events.&n;&t; */
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|dpi-&gt;rdllink
)paren
)paren
id|EP_LIST_DEL
c_func
(paren
op_amp
id|dpi-&gt;rdllink
)paren
suffix:semicolon
id|not_linked
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_unlink(%p, %d)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|dpi-&gt;pfd.fd
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Removes a &quot;struct epitem&quot; from the eventpoll hash and deallocates&n; * all the associated resources.&n; */
DECL|function|ep_remove
r_static
r_int
id|ep_remove
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|dpi
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* We need to acquire the write IRQ lock before calling ep_unlink() */
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Really unlink the item from the hash */
id|error
op_assign
id|ep_unlink
c_func
(paren
id|ep
comma
id|dpi
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_1
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_remove(%p, %d)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|dpi-&gt;pfd.fd
)paren
)paren
suffix:semicolon
multiline_comment|/* At this point it is safe to free the eventpoll item */
id|ep_release_epitem
c_func
(paren
id|dpi
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the callback that is passed to the wait queue wakeup&n; * machanism. It is called by the stored file descriptors when they&n; * have events to report.&n; */
DECL|function|ep_poll_callback
r_static
r_int
id|ep_poll_callback
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|epitem
op_star
id|dpi
op_assign
id|EP_ITEM_FROM_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|dpi-&gt;ep
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: poll_callback(%p) dpi=%p ep=%p&bslash;n&quot;
comma
id|current
comma
id|dpi-&gt;file
comma
id|dpi
comma
id|ep
)paren
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* If this file is already in the ready list we exit soon */
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|dpi-&gt;rdllink
)paren
)paren
r_goto
id|is_linked
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dpi-&gt;rdllink
comma
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
id|is_linked
suffix:colon
multiline_comment|/*&n;&t; * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()&n;&t; * wait list.&n;&t; */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ep_eventpoll_close
r_static
r_int
id|ep_eventpoll_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ep
)paren
(brace
id|ep_free
c_func
(paren
id|ep
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: close() ep=%p&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_eventpoll_poll
r_static
r_int
r_int
id|ep_eventpoll_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|pollflags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/* Insert inside our poll wait queue */
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|ep-&gt;poll_wait
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* Check our condition */
id|read_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
)paren
id|pollflags
op_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|pollflags
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform the transfer of events to user space. Optimize the copy by&n; * caching EP_EVENT_BUFF_SIZE events at a time and then copying it to user space.&n; */
DECL|function|ep_events_transfer
r_static
r_int
id|ep_events_transfer
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|events
comma
r_int
id|maxevents
)paren
(brace
r_int
id|eventcnt
comma
id|ebufcnt
comma
id|revents
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
op_assign
op_amp
id|ep-&gt;rdllist
suffix:semicolon
r_struct
id|pollfd
id|eventbuf
(braket
id|EP_EVENT_BUFF_SIZE
)braket
suffix:semicolon
id|poll_table
id|pt
suffix:semicolon
multiline_comment|/*&n;&t; * This is a special poll table initialization that will&n;&t; * make poll_wait() to not perform any wait queue insertion when&n;&t; * called by file-&gt;f_op-&gt;poll(). This is a fast way to retrieve&n;&t; * file events with perform any queue insertion, hence saving CPU cycles.&n;&t; */
id|poll_initwait_ex
c_func
(paren
op_amp
id|pt
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|eventcnt
op_assign
l_int|0
comma
id|ebufcnt
op_assign
l_int|0
suffix:semicolon
id|eventcnt
OL
id|maxevents
op_logical_and
op_logical_neg
id|list_empty
c_func
(paren
id|lsthead
)paren
suffix:semicolon
)paren
(brace
r_struct
id|epitem
op_star
id|dpi
op_assign
id|list_entry
c_func
(paren
id|lsthead-&gt;next
comma
r_struct
id|epitem
comma
id|rdllink
)paren
suffix:semicolon
multiline_comment|/* Remove the item from the ready list */
id|EP_LIST_DEL
c_func
(paren
op_amp
id|dpi-&gt;rdllink
)paren
suffix:semicolon
multiline_comment|/* Fetch event bits from the signaled file */
id|revents
op_assign
id|dpi-&gt;file-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|dpi-&gt;file
comma
op_amp
id|pt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|revents
op_amp
id|dpi-&gt;pfd.events
)paren
(brace
id|eventbuf
(braket
id|ebufcnt
)braket
op_assign
id|dpi-&gt;pfd
suffix:semicolon
id|eventbuf
(braket
id|ebufcnt
)braket
dot
id|revents
op_assign
id|revents
op_amp
id|eventbuf
(braket
id|ebufcnt
)braket
dot
id|events
suffix:semicolon
id|ebufcnt
op_increment
suffix:semicolon
multiline_comment|/* If our buffer page is full we need to flush it to user space */
r_if
c_cond
(paren
id|ebufcnt
op_eq
id|EP_EVENT_BUFF_SIZE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We need to drop the irqlock before using the function&n;&t;&t;&t;&t; * __copy_to_user() because it might fault.&n;&t;&t;&t;&t; */
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
op_amp
id|events
(braket
id|eventcnt
)braket
comma
id|eventbuf
comma
id|ebufcnt
op_star
r_sizeof
(paren
r_struct
id|pollfd
)paren
)paren
)paren
(brace
id|poll_freewait
c_func
(paren
op_amp
id|pt
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|eventcnt
op_add_assign
id|ebufcnt
suffix:semicolon
id|ebufcnt
op_assign
l_int|0
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* There might be still something inside our event buffer */
r_if
c_cond
(paren
id|ebufcnt
)paren
(brace
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
op_amp
id|events
(braket
id|eventcnt
)braket
comma
id|eventbuf
comma
id|ebufcnt
op_star
r_sizeof
(paren
r_struct
id|pollfd
)paren
)paren
)paren
id|eventcnt
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|eventcnt
op_add_assign
id|ebufcnt
suffix:semicolon
)brace
id|poll_freewait
c_func
(paren
op_amp
id|pt
)paren
suffix:semicolon
r_return
id|eventcnt
suffix:semicolon
)brace
DECL|function|ep_poll
r_static
r_int
id|ep_poll
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|pollfd
op_star
id|events
comma
r_int
id|maxevents
comma
r_int
id|timeout
)paren
(brace
r_int
id|res
op_assign
l_int|0
comma
id|eavail
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|jtimeout
suffix:semicolon
id|wait_queue_t
id|wait
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the timeout by checking for the &quot;infinite&quot; value ( -1 )&n;&t; * and the overflow condition ( &gt; MAX_SCHEDULE_TIMEOUT / HZ ). The&n;&t; * passed timeout is in milliseconds, that why (t * HZ) / 1000.&n;&t; */
id|jtimeout
op_assign
id|timeout
op_eq
op_minus
l_int|1
op_logical_or
id|timeout
OG
id|MAX_SCHEDULE_TIMEOUT
op_div
id|HZ
ques
c_cond
id|MAX_SCHEDULE_TIMEOUT
suffix:colon
(paren
id|timeout
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
id|retry
suffix:colon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t have any available event to return to the caller.&n;&t;&t; * We need to sleep here, and we will be wake up by&n;&t;&t; * ep_poll_callback() when events will become available.&n;&t;&t; */
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t want to sleep if the ep_poll_callback() sends us&n;&t;&t;&t; * a wakeup in between. That&squot;s why we set the task state&n;&t;&t;&t; * to TASK_INTERRUPTIBLE before doing the checks.&n;&t;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
op_logical_or
op_logical_neg
id|jtimeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|res
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|jtimeout
op_assign
id|schedule_timeout
c_func
(paren
id|jtimeout
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
multiline_comment|/* Is it worth to try to dig for events ? */
id|eavail
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to transfer events to user space. In case we get 0 events and&n;&t; * there&squot;s still timeout left over, we go trying again in search of&n;&t; * more luck.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|res
op_logical_and
id|eavail
op_logical_and
op_logical_neg
(paren
id|res
op_assign
id|ep_events_transfer
c_func
(paren
id|ep
comma
id|events
comma
id|maxevents
)paren
)paren
op_logical_and
id|jtimeout
)paren
r_goto
id|retry
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|eventpollfs_delete_dentry
r_static
r_int
id|eventpollfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ep_eventpoll_inode
r_static
r_struct
id|inode
op_star
id|ep_eventpoll_inode
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|new_inode
c_func
(paren
id|eventpoll_mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|eexit_1
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|eventpoll_fops
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the inode dirty from the very beginning,&n;&t; * that way it will never be moved to the dirty&n;&t; * list because mark_inode_dirty() will think&n;&t; * that it already _is_ on the dirty list.&n;&t; */
id|inode-&gt;i_state
op_assign
id|I_DIRTY
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_SIZE
suffix:semicolon
r_return
id|inode
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
DECL|function|eventpollfs_get_sb
r_static
r_struct
id|super_block
op_star
id|eventpollfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_pseudo
c_func
(paren
id|fs_type
comma
l_string|&quot;eventpoll:&quot;
comma
l_int|NULL
comma
id|EVENTPOLLFS_MAGIC
)paren
suffix:semicolon
)brace
DECL|function|eventpoll_init
r_static
r_int
id|__init
id|eventpoll_init
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/* Initialize the list that will link &quot;struct eventpoll&quot; */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|eplist
)paren
suffix:semicolon
multiline_comment|/* Initialize the rwlock used to access &quot;eplist&quot; */
id|rwlock_init
c_func
(paren
op_amp
id|eplock
)paren
suffix:semicolon
multiline_comment|/* Allocates slab cache used to allocate &quot;struct epitem&quot; items */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|dpi_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;eventpoll&quot;
comma
r_sizeof
(paren
r_struct
id|epitem
)paren
comma
l_int|0
comma
id|DPI_SLAB_DEBUG
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dpi_cache
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * Register the virtual file system that will be the source of inodes&n;&t; * for the eventpoll files&n;&t; */
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* Mount the above commented virtual file system */
id|eventpoll_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|eventpoll_mnt
)paren
)paren
r_goto
id|eexit_3
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: driver installed.&bslash;n&quot;
comma
id|current
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_3
suffix:colon
id|unregister_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|dpi_cache
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|eventpoll_exit
r_static
r_void
id|__exit
id|eventpoll_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Undo all operations done inside eventpoll_init() */
id|unregister_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|dpi_cache
)paren
suffix:semicolon
)brace
DECL|variable|eventpoll_init
id|module_init
c_func
(paren
id|eventpoll_init
)paren
suffix:semicolon
DECL|variable|eventpoll_exit
id|module_exit
c_func
(paren
id|eventpoll_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
