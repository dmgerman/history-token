multiline_comment|/*&n; *  fs/eventpoll.c ( Efficent event polling implementation )&n; *  Copyright (C) 2001,...,2003&t; Davide Libenzi&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  Davide Libenzi &lt;davidel@xmailserver.org&gt;&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/hash.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/rwsem.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/eventpoll.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/mman.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
multiline_comment|/*&n; * LOCKING:&n; * There are three level of locking required by epoll :&n; *&n; * 1) epsem (semaphore)&n; * 2) ep-&gt;sem (rw_semaphore)&n; * 3) ep-&gt;lock (rw_lock)&n; *&n; * The acquire order is the one listed above, from 1 to 3.&n; * We need a spinlock (ep-&gt;lock) because we manipulate objects&n; * from inside the poll callback, that might be triggered from&n; * a wake_up() that in turn might be called from IRQ context.&n; * So we can&squot;t sleep inside the poll callback and hence we need&n; * a spinlock. During the event transfer loop (from kernel to&n; * user space) we could end up sleeping due a copy_to_user(), so&n; * we need a lock that will allow us to sleep. This lock is a&n; * read-write semaphore (ep-&gt;sem). It is acquired on read during&n; * the event transfer loop and in write during epoll_ctl(EPOLL_CTL_DEL)&n; * and during eventpoll_release(). Then we also need a global&n; * semaphore to serialize eventpoll_release() and ep_free().&n; * This semaphore is acquired by ep_free() during the epoll file&n; * cleanup path and it is also acquired by eventpoll_release()&n; * if a file has been pushed inside an epoll set and it is then&n; * close()d without a previous call toepoll_ctl(EPOLL_CTL_DEL).&n; * It is possible to drop the &quot;ep-&gt;sem&quot; and to use the global&n; * semaphore &quot;epsem&quot; (together with &quot;ep-&gt;lock&quot;) to have it working,&n; * but having &quot;ep-&gt;sem&quot; will make the interface more scalable.&n; * Events that require holding &quot;epsem&quot; are very rare, while for&n; * normal operations the epoll private &quot;ep-&gt;sem&quot; will guarantee&n; * a greater scalability.&n; */
DECL|macro|EVENTPOLLFS_MAGIC
mdefine_line|#define EVENTPOLLFS_MAGIC 0x03111965 /* My birthday should work for this :) */
DECL|macro|DEBUG_EPOLL
mdefine_line|#define DEBUG_EPOLL 0
macro_line|#if DEBUG_EPOLL &gt; 0
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x) printk x
DECL|macro|DNPRINTK
mdefine_line|#define DNPRINTK(n, x) do { if ((n) &lt;= DEBUG_EPOLL) printk x; } while (0)
macro_line|#else /* #if DEBUG_EPOLL &gt; 0 */
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(x) (void) 0
DECL|macro|DNPRINTK
mdefine_line|#define DNPRINTK(n, x) (void) 0
macro_line|#endif /* #if DEBUG_EPOLL &gt; 0 */
DECL|macro|DEBUG_EPI
mdefine_line|#define DEBUG_EPI 0
macro_line|#if DEBUG_EPI != 0
DECL|macro|EPI_SLAB_DEBUG
mdefine_line|#define EPI_SLAB_DEBUG (SLAB_DEBUG_FREE | SLAB_RED_ZONE /* | SLAB_POISON */)
macro_line|#else /* #if DEBUG_EPI != 0 */
DECL|macro|EPI_SLAB_DEBUG
mdefine_line|#define EPI_SLAB_DEBUG 0
macro_line|#endif /* #if DEBUG_EPI != 0 */
multiline_comment|/* Maximum number of poll wake up nests we are allowing */
DECL|macro|EP_MAX_POLLWAKE_NESTS
mdefine_line|#define EP_MAX_POLLWAKE_NESTS 4
multiline_comment|/* Maximum size of the hash in bits ( 2^N ) */
DECL|macro|EP_MAX_HASH_BITS
mdefine_line|#define EP_MAX_HASH_BITS 17
multiline_comment|/* Minimum size of the hash in bits ( 2^N ) */
DECL|macro|EP_MIN_HASH_BITS
mdefine_line|#define EP_MIN_HASH_BITS 9
multiline_comment|/* Number of hash entries ( &quot;struct list_head&quot; ) inside a page */
DECL|macro|EP_HENTRY_X_PAGE
mdefine_line|#define EP_HENTRY_X_PAGE (PAGE_SIZE / sizeof(struct list_head))
multiline_comment|/* Maximum size of the hash in pages */
DECL|macro|EP_MAX_HPAGES
mdefine_line|#define EP_MAX_HPAGES ((1 &lt;&lt; EP_MAX_HASH_BITS) / EP_HENTRY_X_PAGE + 1)
multiline_comment|/* Number of pages allocated for an &quot;hbits&quot; sized hash table */
DECL|macro|EP_HASH_PAGES
mdefine_line|#define EP_HASH_PAGES(hbits) ((int) ((1 &lt;&lt; (hbits)) / EP_HENTRY_X_PAGE + &bslash;&n;&t;&t;&t;&t;     ((1 &lt;&lt; (hbits)) % EP_HENTRY_X_PAGE ? 1: 0)))
multiline_comment|/* Macro to allocate a &quot;struct epitem&quot; from the slab cache */
DECL|macro|EPI_MEM_ALLOC
mdefine_line|#define EPI_MEM_ALLOC()&t;(struct epitem *) kmem_cache_alloc(epi_cache, SLAB_KERNEL)
multiline_comment|/* Macro to free a &quot;struct epitem&quot; to the slab cache */
DECL|macro|EPI_MEM_FREE
mdefine_line|#define EPI_MEM_FREE(p) kmem_cache_free(epi_cache, p)
multiline_comment|/* Macro to allocate a &quot;struct eppoll_entry&quot; from the slab cache */
DECL|macro|PWQ_MEM_ALLOC
mdefine_line|#define PWQ_MEM_ALLOC()&t;(struct eppoll_entry *) kmem_cache_alloc(pwq_cache, SLAB_KERNEL)
multiline_comment|/* Macro to free a &quot;struct eppoll_entry&quot; to the slab cache */
DECL|macro|PWQ_MEM_FREE
mdefine_line|#define PWQ_MEM_FREE(p) kmem_cache_free(pwq_cache, p)
multiline_comment|/* Fast test to see if the file is an evenpoll file */
DECL|macro|IS_FILE_EPOLL
mdefine_line|#define IS_FILE_EPOLL(f) ((f)-&gt;f_op == &amp;eventpoll_fops)
multiline_comment|/*&n; * Remove the item from the list and perform its initialization.&n; * This is useful for us because we can test if the item is linked&n; * using &quot;EP_IS_LINKED(p)&quot;.&n; */
DECL|macro|EP_LIST_DEL
mdefine_line|#define EP_LIST_DEL(p) do { list_del(p); INIT_LIST_HEAD(p); } while (0)
multiline_comment|/* Tells us if the item is currently linked */
DECL|macro|EP_IS_LINKED
mdefine_line|#define EP_IS_LINKED(p) (!list_empty(p))
multiline_comment|/* Get the &quot;struct epitem&quot; from a wait queue pointer */
DECL|macro|EP_ITEM_FROM_WAIT
mdefine_line|#define EP_ITEM_FROM_WAIT(p) ((struct epitem *) container_of(p, struct eppoll_entry, wait)-&gt;base)
multiline_comment|/* Get the &quot;struct epitem&quot; from an epoll queue wrapper */
DECL|macro|EP_ITEM_FROM_EPQUEUE
mdefine_line|#define EP_ITEM_FROM_EPQUEUE(p) (container_of(p, struct ep_pqueue, pt)-&gt;epi)
multiline_comment|/*&n; * This is used to optimize the event transfer to userspace. Since this&n; * is kept on stack, it should be pretty small.&n; */
DECL|macro|EP_MAX_BUF_EVENTS
mdefine_line|#define EP_MAX_BUF_EVENTS 32
multiline_comment|/*&n; * Node that is linked into the &quot;wake_task_list&quot; member of the &quot;struct poll_safewake&quot;.&n; * It is used to keep track on all tasks that are currently inside the wake_up() code&n; * to 1) short-circuit the one coming from the same task and same wait queue head&n; * ( loop ) 2) allow a maximum number of epoll descriptors inclusion nesting&n; * 3) let go the ones coming from other tasks.&n; */
DECL|struct|wake_task_node
r_struct
id|wake_task_node
(brace
DECL|member|llink
r_struct
id|list_head
id|llink
suffix:semicolon
DECL|member|task
id|task_t
op_star
id|task
suffix:semicolon
DECL|member|wq
id|wait_queue_head_t
op_star
id|wq
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This is used to implement the safe poll wake up avoiding to reenter&n; * the poll callback from inside wake_up().&n; */
DECL|struct|poll_safewake
r_struct
id|poll_safewake
(brace
DECL|member|wake_task_list
r_struct
id|list_head
id|wake_task_list
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This structure is stored inside the &quot;private_data&quot; member of the file&n; * structure and rapresent the main data sructure for the eventpoll&n; * interface.&n; */
DECL|struct|eventpoll
r_struct
id|eventpoll
(brace
multiline_comment|/* Protect the this structure access */
DECL|member|lock
id|rwlock_t
id|lock
suffix:semicolon
multiline_comment|/*&n;&t; * This semaphore is used to ensure that files are not removed&n;&t; * while epoll is using them. This is read-held during the event&n;&t; * collection loop and it is write-held during the file cleanup&n;&t; * path, the epoll file exit code and the ctl operations.&n;&t; */
DECL|member|sem
r_struct
id|rw_semaphore
id|sem
suffix:semicolon
multiline_comment|/* Wait queue used by sys_epoll_wait() */
DECL|member|wq
id|wait_queue_head_t
id|wq
suffix:semicolon
multiline_comment|/* Wait queue used by file-&gt;poll() */
DECL|member|poll_wait
id|wait_queue_head_t
id|poll_wait
suffix:semicolon
multiline_comment|/* List of ready file descriptors */
DECL|member|rdllist
r_struct
id|list_head
id|rdllist
suffix:semicolon
multiline_comment|/* Size of the hash */
DECL|member|hashbits
r_int
r_int
id|hashbits
suffix:semicolon
multiline_comment|/* Pages for the &quot;struct epitem&quot; hash */
DECL|member|hpages
r_char
op_star
id|hpages
(braket
id|EP_MAX_HPAGES
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Wait structure used by the poll hooks */
DECL|struct|eppoll_entry
r_struct
id|eppoll_entry
(brace
multiline_comment|/* List header used to link this structure to the &quot;struct epitem&quot; */
DECL|member|llink
r_struct
id|list_head
id|llink
suffix:semicolon
multiline_comment|/* The &quot;base&quot; pointer is set to the container &quot;struct epitem&quot; */
DECL|member|base
r_void
op_star
id|base
suffix:semicolon
multiline_comment|/*&n;&t; * Wait queue item that will be linked to the target file wait&n;&t; * queue head.&n;&t; */
DECL|member|wait
id|wait_queue_t
id|wait
suffix:semicolon
multiline_comment|/* The wait queue head that linked the &quot;wait&quot; wait queue item */
DECL|member|whead
id|wait_queue_head_t
op_star
id|whead
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Each file descriptor added to the eventpoll interface will&n; * have an entry of this type linked to the hash.&n; */
DECL|struct|epitem
r_struct
id|epitem
(brace
multiline_comment|/* List header used to link this structure to the eventpoll hash */
DECL|member|llink
r_struct
id|list_head
id|llink
suffix:semicolon
multiline_comment|/* List header used to link this structure to the eventpoll ready list */
DECL|member|rdllink
r_struct
id|list_head
id|rdllink
suffix:semicolon
multiline_comment|/* Number of active wait queue attached to poll operations */
DECL|member|nwait
r_int
id|nwait
suffix:semicolon
multiline_comment|/* List containing poll wait queues */
DECL|member|pwqlist
r_struct
id|list_head
id|pwqlist
suffix:semicolon
multiline_comment|/* The &quot;container&quot; of this item */
DECL|member|ep
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
multiline_comment|/* The file this item refers to */
DECL|member|file
r_struct
id|file
op_star
id|file
suffix:semicolon
multiline_comment|/* The structure that describe the interested events and the source fd */
DECL|member|event
r_struct
id|epoll_event
id|event
suffix:semicolon
multiline_comment|/*&n;&t; * Used to keep track of the usage count of the structure. This avoids&n;&t; * that the structure will desappear from underneath our processing.&n;&t; */
DECL|member|usecnt
id|atomic_t
id|usecnt
suffix:semicolon
multiline_comment|/* List header used to link this item to the &quot;struct file&quot; items list */
DECL|member|fllink
r_struct
id|list_head
id|fllink
suffix:semicolon
multiline_comment|/* List header used to link the item to the transfer list */
DECL|member|txlink
r_struct
id|list_head
id|txlink
suffix:semicolon
multiline_comment|/*&n;&t; * This is used during the collection/transfer of events to userspace&n;&t; * to pin items empty events set.&n;&t; */
DECL|member|revents
r_int
r_int
id|revents
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Wrapper struct used by poll queueing */
DECL|struct|ep_pqueue
r_struct
id|ep_pqueue
(brace
DECL|member|pt
id|poll_table
id|pt
suffix:semicolon
DECL|member|epi
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
)brace
suffix:semicolon
r_static
r_void
id|ep_poll_safewake_init
c_func
(paren
r_struct
id|poll_safewake
op_star
id|psw
)paren
suffix:semicolon
r_static
r_void
id|ep_poll_safewake
c_func
(paren
r_struct
id|poll_safewake
op_star
id|psw
comma
id|wait_queue_head_t
op_star
id|wq
)paren
suffix:semicolon
r_static
r_int
r_int
id|ep_get_hash_bits
c_func
(paren
r_int
r_int
id|hintsize
)paren
suffix:semicolon
r_static
r_int
id|ep_getfd
c_func
(paren
r_int
op_star
id|efd
comma
r_struct
id|inode
op_star
op_star
id|einode
comma
r_struct
id|file
op_star
op_star
id|efile
)paren
suffix:semicolon
r_static
r_int
id|ep_alloc_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
suffix:semicolon
r_static
r_int
id|ep_free_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
suffix:semicolon
r_static
r_int
id|ep_file_init
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|hashbits
)paren
suffix:semicolon
r_static
r_int
r_int
id|ep_hash_index
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_struct
id|list_head
op_star
id|ep_hash_entry
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
r_int
id|index
)paren
suffix:semicolon
r_static
r_int
id|ep_init
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
r_int
id|hashbits
)paren
suffix:semicolon
r_static
r_void
id|ep_free
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
suffix:semicolon
r_static
r_struct
id|epitem
op_star
id|ep_find
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|ep_use_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|epi
)paren
suffix:semicolon
r_static
r_void
id|ep_release_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|epi
)paren
suffix:semicolon
r_static
r_void
id|ep_ptable_queue_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|wait_queue_head_t
op_star
id|whead
comma
id|poll_table
op_star
id|pt
)paren
suffix:semicolon
r_static
r_int
id|ep_insert
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epoll_event
op_star
id|event
comma
r_struct
id|file
op_star
id|tfile
)paren
suffix:semicolon
r_static
r_int
id|ep_modify
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
comma
r_struct
id|epoll_event
op_star
id|event
)paren
suffix:semicolon
r_static
r_void
id|ep_unregister_pollwait
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
)paren
suffix:semicolon
r_static
r_int
id|ep_unlink
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
)paren
suffix:semicolon
r_static
r_int
id|ep_remove
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
)paren
suffix:semicolon
r_static
r_int
id|ep_poll_callback
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
)paren
suffix:semicolon
r_static
r_int
id|ep_eventpoll_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
r_int
id|ep_eventpoll_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|ep_collect_ready_items
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|list_head
op_star
id|txlist
comma
r_int
id|maxevents
)paren
suffix:semicolon
r_static
r_int
id|ep_send_events
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|list_head
op_star
id|txlist
comma
r_struct
id|epoll_event
op_star
id|events
)paren
suffix:semicolon
r_static
r_void
id|ep_reinject_items
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|list_head
op_star
id|txlist
)paren
suffix:semicolon
r_static
r_int
id|ep_events_transfer
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epoll_event
op_star
id|events
comma
r_int
id|maxevents
)paren
suffix:semicolon
r_static
r_int
id|ep_poll
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epoll_event
op_star
id|events
comma
r_int
id|maxevents
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_int
id|eventpollfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
suffix:semicolon
r_static
r_struct
id|inode
op_star
id|ep_eventpoll_inode
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|super_block
op_star
id|eventpollfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/*&n; * This semaphore is used to serialize ep_free() and eventpoll_release().&n; */
DECL|variable|epsem
r_struct
id|semaphore
id|epsem
suffix:semicolon
multiline_comment|/* Safe wake up implementation */
DECL|variable|psw
r_static
r_struct
id|poll_safewake
id|psw
suffix:semicolon
multiline_comment|/* Slab cache used to allocate &quot;struct epitem&quot; */
DECL|variable|epi_cache
r_static
id|kmem_cache_t
op_star
id|epi_cache
suffix:semicolon
multiline_comment|/* Slab cache used to allocate &quot;struct eppoll_entry&quot; */
DECL|variable|pwq_cache
r_static
id|kmem_cache_t
op_star
id|pwq_cache
suffix:semicolon
multiline_comment|/* Virtual fs used to allocate inodes for eventpoll files */
DECL|variable|eventpoll_mnt
r_static
r_struct
id|vfsmount
op_star
id|eventpoll_mnt
suffix:semicolon
multiline_comment|/* File callbacks that implement the eventpoll file behaviour */
DECL|variable|eventpoll_fops
r_static
r_struct
id|file_operations
id|eventpoll_fops
op_assign
(brace
dot
id|release
op_assign
id|ep_eventpoll_close
comma
dot
id|poll
op_assign
id|ep_eventpoll_poll
)brace
suffix:semicolon
multiline_comment|/*&n; * This is used to register the virtual file system from where&n; * eventpoll inodes are allocated.&n; */
DECL|variable|eventpoll_fs_type
r_static
r_struct
id|file_system_type
id|eventpoll_fs_type
op_assign
(brace
dot
id|name
op_assign
l_string|&quot;eventpollfs&quot;
comma
dot
id|get_sb
op_assign
id|eventpollfs_get_sb
comma
dot
id|kill_sb
op_assign
id|kill_anon_super
comma
)brace
suffix:semicolon
multiline_comment|/* Very basic directory entry operations for the eventpoll virtual file system */
DECL|variable|eventpollfs_dentry_operations
r_static
r_struct
id|dentry_operations
id|eventpollfs_dentry_operations
op_assign
(brace
dot
id|d_delete
op_assign
id|eventpollfs_delete_dentry
comma
)brace
suffix:semicolon
multiline_comment|/* Initialize the poll safe wake up structure */
DECL|function|ep_poll_safewake_init
r_static
r_void
id|ep_poll_safewake_init
c_func
(paren
r_struct
id|poll_safewake
op_star
id|psw
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|psw-&gt;wake_task_list
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|psw-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform a safe wake up of the poll wait list. The problem is that&n; * with the new callback&squot;d wake up system, it is possible that the&n; * poll callback is reentered from inside the call to wake_up() done&n; * on the poll wait queue head. The rule is that we cannot reenter the&n; * wake up code from the same task more than EP_MAX_POLLWAKE_NESTS times,&n; * and we cannot reenter the same wait queue head at all. This will&n; * enable to have a hierarchy of epoll file descriptor of no more than&n; * EP_MAX_POLLWAKE_NESTS deep. We need the irq version of the spin lock&n; * because this one gets called by the poll callback, that in turn is called&n; * from inside a wake_up(), that might be called from irq context.&n; */
DECL|function|ep_poll_safewake
r_static
r_void
id|ep_poll_safewake
c_func
(paren
r_struct
id|poll_safewake
op_star
id|psw
comma
id|wait_queue_head_t
op_star
id|wq
)paren
(brace
r_int
id|wake_nests
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|task_t
op_star
id|this_task
op_assign
id|current
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
op_assign
op_amp
id|psw-&gt;wake_task_list
comma
op_star
id|lnk
suffix:semicolon
r_struct
id|wake_task_node
op_star
id|tncur
suffix:semicolon
r_struct
id|wake_task_node
id|tnode
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|psw-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Try to see if the current task is already inside this wakeup call */
id|list_for_each
c_func
(paren
id|lnk
comma
id|lsthead
)paren
(brace
id|tncur
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|wake_task_node
comma
id|llink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tncur-&gt;wq
op_eq
id|wq
op_logical_or
(paren
id|tncur-&gt;task
op_eq
id|this_task
op_logical_and
op_increment
id|wake_nests
OG
id|EP_MAX_POLLWAKE_NESTS
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Ops ... loop detected or maximum nest level reached.&n;&t;&t;&t; * We abort this wake by breaking the cycle itself.&n;&t;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|psw-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Add the current task to the list */
id|tnode.task
op_assign
id|this_task
suffix:semicolon
id|tnode.wq
op_assign
id|wq
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|tnode.llink
comma
id|lsthead
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|psw-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Do really wake up now */
id|wake_up
c_func
(paren
id|wq
)paren
suffix:semicolon
multiline_comment|/* Remove the current task from the list */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|psw-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|tnode.llink
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|psw-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate the size of the hash in bits. The returned size will be&n; * bounded between EP_MIN_HASH_BITS and EP_MAX_HASH_BITS.&n; */
DECL|function|ep_get_hash_bits
r_static
r_int
r_int
id|ep_get_hash_bits
c_func
(paren
r_int
r_int
id|hintsize
)paren
(brace
r_int
r_int
id|i
comma
id|val
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|val
op_assign
l_int|1
suffix:semicolon
id|val
OL
id|hintsize
op_logical_and
id|i
OL
id|EP_MAX_HASH_BITS
suffix:semicolon
id|i
op_increment
comma
id|val
op_lshift_assign
l_int|1
)paren
suffix:semicolon
r_return
id|i
OL
id|EP_MIN_HASH_BITS
ques
c_cond
id|EP_MIN_HASH_BITS
suffix:colon
id|i
suffix:semicolon
)brace
multiline_comment|/* Used to initialize the epoll bits inside the &quot;struct file&quot; */
DECL|function|eventpoll_init_file
r_void
id|eventpoll_init_file
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|file-&gt;f_ep_links
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|file-&gt;f_ep_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called from eventpoll_release() to unlink files from the eventpoll&n; * interface. We need to have this facility to cleanup correctly files that are&n; * closed without being removed from the eventpoll interface.&n; */
DECL|function|eventpoll_release_file
r_void
id|eventpoll_release_file
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|list_head
op_star
id|lsthead
op_assign
op_amp
id|file-&gt;f_ep_links
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t want to get &quot;file-&gt;f_ep_lock&quot; because it is not&n;&t; * necessary. It is not necessary because we&squot;re in the &quot;struct file&quot;&n;&t; * cleanup path, and this means that noone is using this file anymore.&n;&t; * The only hit might come from ep_free() but by holding the semaphore&n;&t; * will correctly serialize the operation. We do need to acquire&n;&t; * &quot;ep-&gt;sem&quot; after &quot;epsem&quot; because ep_remove() requires it when called&n;&t; * from anywhere but ep_free().&n;&t; */
id|down
c_func
(paren
op_amp
id|epsem
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|lsthead
)paren
)paren
(brace
id|epi
op_assign
id|list_entry
c_func
(paren
id|lsthead-&gt;next
comma
r_struct
id|epitem
comma
id|fllink
)paren
suffix:semicolon
id|ep
op_assign
id|epi-&gt;ep
suffix:semicolon
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;fllink
)paren
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
id|ep_remove
c_func
(paren
id|ep
comma
id|epi
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|epsem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * It opens an eventpoll file descriptor by suggesting a storage of &quot;size&quot;&n; * file descriptors. The size parameter is just an hint about how to size&n; * data structures. It won&squot;t prevent the user to store more than &quot;size&quot;&n; * file descriptors inside the epoll interface. It is the kernel part of&n; * the userspace epoll_create(2).&n; */
DECL|function|sys_epoll_create
id|asmlinkage
r_int
id|sys_epoll_create
c_func
(paren
r_int
id|size
)paren
(brace
r_int
id|error
comma
id|fd
suffix:semicolon
r_int
r_int
id|hashbits
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d)&bslash;n&quot;
comma
id|current
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/* Correctly size the hash */
id|hashbits
op_assign
id|ep_get_hash_bits
c_func
(paren
(paren
r_int
r_int
)paren
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Creates all the items needed to setup an eventpoll file. That is,&n;&t; * a file structure, and inode and a free file descriptor.&n;&t; */
id|error
op_assign
id|ep_getfd
c_func
(paren
op_amp
id|fd
comma
op_amp
id|inode
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Setup the file internal data structure ( &quot;struct eventpoll&quot; ) */
id|error
op_assign
id|ep_file_init
c_func
(paren
id|file
comma
id|hashbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_2
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d) = %d&bslash;n&quot;
comma
id|current
comma
id|size
comma
id|fd
)paren
)paren
suffix:semicolon
r_return
id|fd
suffix:semicolon
id|eexit_2
suffix:colon
id|sys_close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_create(%d) = %d&bslash;n&quot;
comma
id|current
comma
id|size
comma
id|error
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The following function implement the controller interface for the eventpoll&n; * file that enable the insertion/removal/change of file descriptors inside&n; * the interest set. It rapresents the kernel part of the user space epoll_ctl(2).&n; */
DECL|function|sys_epoll_ctl
id|asmlinkage
r_int
id|sys_epoll_ctl
c_func
(paren
r_int
id|epfd
comma
r_int
id|op
comma
r_int
id|fd
comma
r_struct
id|epoll_event
op_star
id|event
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
comma
op_star
id|tfile
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
r_struct
id|epoll_event
id|epds
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|op
comma
id|fd
comma
id|event
)paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|epds
comma
id|event
comma
r_sizeof
(paren
r_struct
id|epoll_event
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Get the &quot;struct file *&quot; for the eventpoll file */
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|epfd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Get the &quot;struct file *&quot; for the target file */
id|tfile
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tfile
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* The target file descriptor must support poll */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tfile-&gt;f_op
op_logical_or
op_logical_neg
id|tfile-&gt;f_op-&gt;poll
)paren
r_goto
id|eexit_3
suffix:semicolon
multiline_comment|/*&n;&t; * We have to check that the file structure underneath the file descriptor&n;&t; * the user passed to us _is_ an eventpoll file. And also we do not permit&n;&t; * adding an epoll file descriptor inside itself.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file
op_eq
id|tfile
op_logical_or
op_logical_neg
id|IS_FILE_EPOLL
c_func
(paren
id|file
)paren
)paren
r_goto
id|eexit_3
suffix:semicolon
multiline_comment|/*&n;&t; * At this point it is safe to assume that the &quot;private_data&quot; contains&n;&t; * our own data structure.&n;&t; */
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* Try to lookup the file inside our hash table */
id|epi
op_assign
id|ep_find
c_func
(paren
id|ep
comma
id|tfile
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|op
)paren
(brace
r_case
id|EPOLL_CTL_ADD
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|epi
)paren
(brace
id|epds.events
op_or_assign
id|POLLERR
op_or
id|POLLHUP
suffix:semicolon
id|error
op_assign
id|ep_insert
c_func
(paren
id|ep
comma
op_amp
id|epds
comma
id|tfile
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EPOLL_CTL_DEL
suffix:colon
r_if
c_cond
(paren
id|epi
)paren
id|error
op_assign
id|ep_remove
c_func
(paren
id|ep
comma
id|epi
)paren
suffix:semicolon
r_else
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EPOLL_CTL_MOD
suffix:colon
r_if
c_cond
(paren
id|epi
)paren
(brace
id|epds.events
op_or_assign
id|POLLERR
op_or
id|POLLHUP
suffix:semicolon
id|error
op_assign
id|ep_modify
c_func
(paren
id|ep
comma
id|epi
comma
op_amp
id|epds
)paren
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The function ep_find() increments the usage count of the structure&n;&t; * so, if this is not NULL, we need to release it.&n;&t; */
r_if
c_cond
(paren
id|epi
)paren
id|ep_release_epitem
c_func
(paren
id|epi
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
id|eexit_3
suffix:colon
id|fput
c_func
(paren
id|tfile
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|op
comma
id|fd
comma
id|event
comma
id|error
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Implement the event wait interface for the eventpoll file. It is the kernel&n; * part of the user space epoll_wait(2).&n; */
DECL|function|sys_epoll_wait
id|asmlinkage
r_int
id|sys_epoll_wait
c_func
(paren
r_int
id|epfd
comma
r_struct
id|epoll_event
op_star
id|events
comma
r_int
id|maxevents
comma
r_int
id|timeout
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d)&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|events
comma
id|maxevents
comma
id|timeout
)paren
)paren
suffix:semicolon
multiline_comment|/* The maximum number of event must be greater than zero */
r_if
c_cond
(paren
id|maxevents
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Verify that the area passed by the user is writeable */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|events
comma
id|maxevents
op_star
r_sizeof
(paren
r_struct
id|epoll_event
)paren
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Get the &quot;struct file *&quot; for the eventpoll file */
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|epfd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * We have to check that the file structure underneath the file descriptor&n;&t; * the user passed to us _is_ an eventpoll file.&n;&t; */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_FILE_EPOLL
c_func
(paren
id|file
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/*&n;&t; * At this point it is safe to assume that the &quot;private_data&quot; contains&n;&t; * our own data structure.&n;&t; */
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/* Time to fish for events ... */
id|error
op_assign
id|ep_poll
c_func
(paren
id|ep
comma
id|events
comma
id|maxevents
comma
id|timeout
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: sys_epoll_wait(%d, %p, %d, %d) = %d&bslash;n&quot;
comma
id|current
comma
id|epfd
comma
id|events
comma
id|maxevents
comma
id|timeout
comma
id|error
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Creates the file descriptor to be used by the epoll interface.&n; */
DECL|function|ep_getfd
r_static
r_int
id|ep_getfd
c_func
(paren
r_int
op_star
id|efd
comma
r_struct
id|inode
op_star
op_star
id|einode
comma
r_struct
id|file
op_star
op_star
id|efile
)paren
(brace
r_struct
id|qstr
id|this
suffix:semicolon
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
id|error
comma
id|fd
suffix:semicolon
multiline_comment|/* Get an ready to use file */
id|error
op_assign
op_minus
id|ENFILE
suffix:semicolon
id|file
op_assign
id|get_empty_filp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Allocates an inode from the eventpoll file system */
id|inode
op_assign
id|ep_eventpoll_inode
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|inode
)paren
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* Allocates a free descriptor to plug the file onto */
id|error
op_assign
id|get_unused_fd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|eexit_3
suffix:semicolon
id|fd
op_assign
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Link the inode to a directory entry by creating a unique name&n;&t; * using the inode number.&n;&t; */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|sprintf
c_func
(paren
id|name
comma
l_string|&quot;[%lu]&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|this.len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|this.hash
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|eventpoll_mnt-&gt;mnt_sb-&gt;s_root
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|eexit_4
suffix:semicolon
id|dentry-&gt;d_op
op_assign
op_amp
id|eventpollfs_dentry_operations
suffix:semicolon
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|file-&gt;f_vfsmnt
op_assign
id|mntget
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
id|file-&gt;f_dentry
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|file-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|file-&gt;f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|file-&gt;f_op
op_assign
op_amp
id|eventpoll_fops
suffix:semicolon
id|file-&gt;f_mode
op_assign
id|FMODE_READ
suffix:semicolon
id|file-&gt;f_version
op_assign
l_int|0
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Install the new setup file into the allocated fd. */
id|fd_install
c_func
(paren
id|fd
comma
id|file
)paren
suffix:semicolon
op_star
id|efd
op_assign
id|fd
suffix:semicolon
op_star
id|einode
op_assign
id|inode
suffix:semicolon
op_star
id|efile
op_assign
id|file
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_4
suffix:colon
id|put_unused_fd
c_func
(paren
id|fd
)paren
suffix:semicolon
id|eexit_3
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|put_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ep_alloc_pages
r_static
r_int
id|ep_alloc_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numpages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pages
(braket
id|i
)braket
op_assign
(paren
r_char
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pages
(braket
id|i
)braket
)paren
(brace
r_for
c_loop
(paren
op_decrement
id|i
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|SetPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_free_pages
r_static
r_int
id|ep_free_pages
c_func
(paren
r_char
op_star
op_star
id|pages
comma
r_int
id|numpages
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|numpages
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ClearPageReserved
c_func
(paren
id|virt_to_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|pages
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_file_init
r_static
r_int
id|ep_file_init
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|hashbits
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ep
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|eventpoll
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|memset
c_func
(paren
id|ep
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ep
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ep_init
c_func
(paren
id|ep
comma
id|hashbits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|file-&gt;private_data
op_assign
id|ep
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_file_init() ep=%p&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate the index of the hash relative to &quot;file&quot;.&n; */
DECL|function|ep_hash_index
r_static
r_int
r_int
id|ep_hash_index
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_return
(paren
r_int
r_int
)paren
id|hash_ptr
c_func
(paren
id|file
comma
id|ep-&gt;hashbits
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns the hash entry ( struct list_head * ) of the passed index.&n; */
DECL|function|ep_hash_entry
r_static
r_struct
id|list_head
op_star
id|ep_hash_entry
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
r_int
id|index
)paren
(brace
r_return
(paren
r_struct
id|list_head
op_star
)paren
(paren
id|ep-&gt;hpages
(braket
id|index
op_div
id|EP_HENTRY_X_PAGE
)braket
op_plus
(paren
id|index
op_mod
id|EP_HENTRY_X_PAGE
)paren
op_star
r_sizeof
(paren
r_struct
id|list_head
)paren
)paren
suffix:semicolon
)brace
DECL|function|ep_init
r_static
r_int
id|ep_init
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_int
r_int
id|hashbits
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|i
comma
id|hsize
suffix:semicolon
id|rwlock_init
c_func
(paren
op_amp
id|ep-&gt;lock
)paren
suffix:semicolon
id|init_rwsem
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
multiline_comment|/* Hash allocation and setup */
id|ep-&gt;hashbits
op_assign
id|hashbits
suffix:semicolon
id|error
op_assign
id|ep_alloc_pages
c_func
(paren
id|ep-&gt;hpages
comma
id|EP_HASH_PAGES
c_func
(paren
id|ep-&gt;hashbits
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Initialize hash buckets */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|hsize
op_assign
l_int|1
op_lshift
id|hashbits
suffix:semicolon
id|i
OL
id|hsize
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|i
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ep_free
r_static
r_void
id|ep_free
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
)paren
(brace
r_int
r_int
id|i
comma
id|hsize
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
comma
op_star
id|lnk
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
multiline_comment|/* We need to release all tasks waiting for these file */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
)paren
id|ep_poll_safewake
c_func
(paren
op_amp
id|psw
comma
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to lock this because we could be hit by&n;&t; * eventpoll_release() while we&squot;re freeing the &quot;struct eventpoll&quot;.&n;&t; * We do not need to hold &quot;ep-&gt;sem&quot; here because the epoll file&n;&t; * is on the way to be removed and no one has references to it&n;&t; * anymore. The only hit might come from eventpoll_release() but&n;&t; * holding &quot;epsem&quot; is sufficent here.&n;&t; */
id|down
c_func
(paren
op_amp
id|epsem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Walks through the whole hash by unregistering poll callbacks.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|hsize
op_assign
l_int|1
op_lshift
id|ep-&gt;hashbits
suffix:semicolon
id|i
OL
id|hsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lsthead
op_assign
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|i
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lnk
comma
id|lsthead
)paren
(brace
id|epi
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
id|ep_unregister_pollwait
c_func
(paren
id|ep
comma
id|epi
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Walks through the whole hash by freeing each &quot;struct epitem&quot;. At this&n;&t; * point we are sure no poll callbacks will be lingering around, and also by&n;&t; * write-holding &quot;sem&quot; we can be sure that no file cleanup code will hit&n;&t; * us during this operation. So we can avoid the lock on &quot;ep-&gt;lock&quot;.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|hsize
op_assign
l_int|1
op_lshift
id|ep-&gt;hashbits
suffix:semicolon
id|i
OL
id|hsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lsthead
op_assign
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|i
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|lsthead
)paren
)paren
(brace
id|epi
op_assign
id|list_entry
c_func
(paren
id|lsthead-&gt;next
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
id|ep_remove
c_func
(paren
id|ep
comma
id|epi
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|epsem
)paren
suffix:semicolon
multiline_comment|/* Free hash pages */
id|ep_free_pages
c_func
(paren
id|ep-&gt;hpages
comma
id|EP_HASH_PAGES
c_func
(paren
id|ep-&gt;hashbits
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Search the file inside the eventpoll hash. It add usage count to&n; * the returned item, so the caller must call ep_release_epitem()&n; * after finished using the &quot;struct epitem&quot;.&n; */
DECL|function|ep_find
r_static
r_struct
id|epitem
op_star
id|ep_find
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
comma
op_star
id|lnk
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
op_assign
l_int|NULL
suffix:semicolon
id|read_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|lsthead
op_assign
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|ep_hash_index
c_func
(paren
id|ep
comma
id|file
)paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|lnk
comma
id|lsthead
)paren
(brace
id|epi
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|epitem
comma
id|llink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|epi-&gt;file
op_eq
id|file
)paren
(brace
id|ep_use_epitem
c_func
(paren
id|epi
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|epi
op_assign
l_int|NULL
suffix:semicolon
)brace
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_find(%p) -&gt; %p&bslash;n&quot;
comma
id|current
comma
id|file
comma
id|epi
)paren
)paren
suffix:semicolon
r_return
id|epi
suffix:semicolon
)brace
multiline_comment|/*&n; * Increment the usage count of the &quot;struct epitem&quot; making it sure&n; * that the user will have a valid pointer to reference.&n; */
DECL|function|ep_use_epitem
r_static
r_void
id|ep_use_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|epi
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|epi-&gt;usecnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Decrement ( release ) the usage count by signaling that the user&n; * has finished using the structure. It might lead to freeing the&n; * structure itself if the count goes to zero.&n; */
DECL|function|ep_release_epitem
r_static
r_void
id|ep_release_epitem
c_func
(paren
r_struct
id|epitem
op_star
id|epi
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|epi-&gt;usecnt
)paren
)paren
id|EPI_MEM_FREE
c_func
(paren
id|epi
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the callback that is used to add our wait queue to the&n; * target file wakeup lists.&n; */
DECL|function|ep_ptable_queue_proc
r_static
r_void
id|ep_ptable_queue_proc
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|wait_queue_head_t
op_star
id|whead
comma
id|poll_table
op_star
id|pt
)paren
(brace
r_struct
id|epitem
op_star
id|epi
op_assign
id|EP_ITEM_FROM_EPQUEUE
c_func
(paren
id|pt
)paren
suffix:semicolon
r_struct
id|eppoll_entry
op_star
id|pwq
suffix:semicolon
r_if
c_cond
(paren
id|epi-&gt;nwait
op_ge
l_int|0
op_logical_and
(paren
id|pwq
op_assign
id|PWQ_MEM_ALLOC
c_func
(paren
)paren
)paren
)paren
(brace
id|init_waitqueue_func_entry
c_func
(paren
op_amp
id|pwq-&gt;wait
comma
id|ep_poll_callback
)paren
suffix:semicolon
id|pwq-&gt;whead
op_assign
id|whead
suffix:semicolon
id|pwq-&gt;base
op_assign
id|epi
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|whead
comma
op_amp
id|pwq-&gt;wait
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|pwq-&gt;llink
comma
op_amp
id|epi-&gt;pwqlist
)paren
suffix:semicolon
id|epi-&gt;nwait
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We have to signal that an error occurred */
id|epi-&gt;nwait
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|ep_insert
r_static
r_int
id|ep_insert
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epoll_event
op_star
id|event
comma
r_struct
id|file
op_star
id|tfile
)paren
(brace
r_int
id|error
comma
id|revents
comma
id|pwake
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
r_struct
id|ep_pqueue
id|epq
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|epi
op_assign
id|EPI_MEM_ALLOC
c_func
(paren
)paren
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Item initialization follow here ... */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|epi-&gt;llink
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|epi-&gt;fllink
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|epi-&gt;txlink
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|epi-&gt;pwqlist
)paren
suffix:semicolon
id|epi-&gt;ep
op_assign
id|ep
suffix:semicolon
id|epi-&gt;file
op_assign
id|tfile
suffix:semicolon
id|epi-&gt;event
op_assign
op_star
id|event
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|epi-&gt;usecnt
comma
l_int|1
)paren
suffix:semicolon
id|epi-&gt;nwait
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the poll table using the queue callback */
id|epq.epi
op_assign
id|epi
suffix:semicolon
id|init_poll_funcptr
c_func
(paren
op_amp
id|epq.pt
comma
id|ep_ptable_queue_proc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Attach the item to the poll hooks and get current event bits.&n;&t; * We can safely use the file* here because its usage count has&n;&t; * been increased by the caller of this function.&n;&t; */
id|revents
op_assign
id|tfile-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|tfile
comma
op_amp
id|epq.pt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to check if something went wrong during the poll wait queue&n;&t; * install process. Namely an allocation for a wait queue failed due&n;&t; * high memory pressure.&n;&t; */
r_if
c_cond
(paren
id|epi-&gt;nwait
OL
l_int|0
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/* Add the current item to the list of active epoll hook for this file */
id|spin_lock
c_func
(paren
op_amp
id|tfile-&gt;f_ep_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|epi-&gt;fllink
comma
op_amp
id|tfile-&gt;f_ep_links
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tfile-&gt;f_ep_lock
)paren
suffix:semicolon
multiline_comment|/* We have to drop the new item inside our item list to keep track of it */
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Add the current item to the hash table */
id|list_add
c_func
(paren
op_amp
id|epi-&gt;llink
comma
id|ep_hash_entry
c_func
(paren
id|ep
comma
id|ep_hash_index
c_func
(paren
id|ep
comma
id|tfile
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* If the file is already &quot;ready&quot; we drop it inside the ready list */
r_if
c_cond
(paren
(paren
id|revents
op_amp
id|event-&gt;events
)paren
op_logical_and
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|epi-&gt;rdllink
comma
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
multiline_comment|/* Notify waiting tasks that events are available */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
)paren
id|pwake
op_increment
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We have to call this outside the lock */
r_if
c_cond
(paren
id|pwake
)paren
id|ep_poll_safewake
c_func
(paren
op_amp
id|psw
comma
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_insert(%p, %p)&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|tfile
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_2
suffix:colon
id|ep_unregister_pollwait
c_func
(paren
id|ep
comma
id|epi
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to do this because an event could have been arrived on some&n;&t; * allocated wait queue.&n;&t; */
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
)paren
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|EPI_MEM_FREE
c_func
(paren
id|epi
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Modify the interest event mask by dropping an event if the new mask&n; * has a match in the current file status.&n; */
DECL|function|ep_modify
r_static
r_int
id|ep_modify
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
comma
r_struct
id|epoll_event
op_star
id|event
)paren
(brace
r_int
id|pwake
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|revents
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Set the new event interest mask before calling f_op-&gt;poll(), otherwise&n;&t; * a potential race might occur. In fact if we do this operation inside&n;&t; * the lock, an event might happen between the f_op-&gt;poll() call and the&n;&t; * new event set registering.&n;&t; */
id|epi-&gt;event.events
op_assign
id|event-&gt;events
suffix:semicolon
multiline_comment|/*&n;&t; * Get current event bits. We can safely use the file* here because&n;&t; * its usage count has been increased by the caller of this function.&n;&t; */
id|revents
op_assign
id|epi-&gt;file-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|epi-&gt;file
comma
l_int|NULL
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Copy the data member from inside the lock */
id|epi-&gt;event.data
op_assign
id|event-&gt;data
suffix:semicolon
multiline_comment|/*&n;&t; * If the item is not linked to the hash it means that it&squot;s on its&n;&t; * way toward the removal. Do nothing in this case.&n;&t; */
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;llink
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the item is &quot;hot&quot; and it is not registered inside the ready&n;&t;&t; * list, push it inside. If the item is not &quot;hot&quot; and it is currently&n;&t;&t; * registered inside the ready list, unlink it.&n;&t;&t; */
r_if
c_cond
(paren
id|revents
op_amp
id|event-&gt;events
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|epi-&gt;rdllink
comma
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
multiline_comment|/* Notify waiting tasks that events are available */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
)paren
id|pwake
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
)paren
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We have to call this outside the lock */
r_if
c_cond
(paren
id|pwake
)paren
id|ep_poll_safewake
c_func
(paren
op_amp
id|psw
comma
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function unregister poll callbacks from the associated file descriptor.&n; * Since this must be called without holding &quot;ep-&gt;lock&quot; the atomic exchange trick&n; * will protect us from multiple unregister.&n; */
DECL|function|ep_unregister_pollwait
r_static
r_void
id|ep_unregister_pollwait
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
)paren
(brace
r_int
id|nwait
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
op_assign
op_amp
id|epi-&gt;pwqlist
suffix:semicolon
r_struct
id|eppoll_entry
op_star
id|pwq
suffix:semicolon
multiline_comment|/* This is called without locks, so we need the atomic exchange */
id|nwait
op_assign
id|xchg
c_func
(paren
op_amp
id|epi-&gt;nwait
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nwait
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|lsthead
)paren
)paren
(brace
id|pwq
op_assign
id|list_entry
c_func
(paren
id|lsthead-&gt;next
comma
r_struct
id|eppoll_entry
comma
id|llink
)paren
suffix:semicolon
id|EP_LIST_DEL
c_func
(paren
op_amp
id|pwq-&gt;llink
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|pwq-&gt;whead
comma
op_amp
id|pwq-&gt;wait
)paren
suffix:semicolon
id|PWQ_MEM_FREE
c_func
(paren
id|pwq
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Unlink the &quot;struct epitem&quot; from all places it might have been hooked up.&n; * This function must be called with write IRQ lock on &quot;ep-&gt;lock&quot;.&n; */
DECL|function|ep_unlink
r_static
r_int
id|ep_unlink
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
)paren
(brace
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * It can happen that this one is called for an item already unlinked.&n;&t; * The check protect us from doing a double unlink ( crash ).&n;&t; */
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;llink
)paren
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the event mask for the unlinked item. This will avoid item&n;&t; * notifications to be sent after the unlink operation from inside&n;&t; * the kernel-&gt;userspace event transfer loop.&n;&t; */
id|epi-&gt;event.events
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * At this point is safe to do the job, unlink the item from our list.&n;&t; * This operation togheter with the above check closes the door to&n;&t; * double unlinks.&n;&t; */
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;llink
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the item we are going to remove is inside the ready file descriptors&n;&t; * we want to remove it from this list to avoid stale events.&n;&t; */
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
)paren
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_unlink(%p, %p) = %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|epi-&gt;file
comma
id|error
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Removes a &quot;struct epitem&quot; from the eventpoll hash and deallocates&n; * all the associated resources.&n; */
DECL|function|ep_remove
r_static
r_int
id|ep_remove
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epitem
op_star
id|epi
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|epi-&gt;file
suffix:semicolon
multiline_comment|/*&n;&t; * Removes poll wait queue hooks. We _have_ to do this without holding&n;&t; * the &quot;ep-&gt;lock&quot; otherwise a deadlock might occur. This because of the&n;&t; * sequence of the lock acquisition. Here we do &quot;ep-&gt;lock&quot; then the wait&n;&t; * queue head lock when unregistering the wait queue. The wakeup callback&n;&t; * will run by holding the wait queue head lock and will call our callback&n;&t; * that will try to get &quot;ep-&gt;lock&quot;.&n;&t; */
id|ep_unregister_pollwait
c_func
(paren
id|ep
comma
id|epi
)paren
suffix:semicolon
multiline_comment|/* Remove the current item from the list of epoll hooks */
id|spin_lock
c_func
(paren
op_amp
id|file-&gt;f_ep_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;fllink
)paren
)paren
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;fllink
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|file-&gt;f_ep_lock
)paren
suffix:semicolon
multiline_comment|/* We need to acquire the write IRQ lock before calling ep_unlink() */
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Really unlink the item from the hash */
id|error
op_assign
id|ep_unlink
c_func
(paren
id|ep
comma
id|epi
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* At this point it is safe to free the eventpoll item */
id|ep_release_epitem
c_func
(paren
id|epi
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|eexit_1
suffix:colon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: ep_remove(%p, %p) = %d&bslash;n&quot;
comma
id|current
comma
id|ep
comma
id|file
comma
id|error
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the callback that is passed to the wait queue wakeup&n; * machanism. It is called by the stored file descriptors when they&n; * have events to report.&n; */
DECL|function|ep_poll_callback
r_static
r_int
id|ep_poll_callback
c_func
(paren
id|wait_queue_t
op_star
id|wait
comma
r_int
id|mode
comma
r_int
id|sync
)paren
(brace
r_int
id|pwake
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
op_assign
id|EP_ITEM_FROM_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|epi-&gt;ep
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: poll_callback(%p) epi=%p ep=%p&bslash;n&quot;
comma
id|current
comma
id|epi-&gt;file
comma
id|epi
comma
id|ep
)paren
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* If this file is already in the ready list we exit soon */
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
)paren
r_goto
id|is_linked
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|epi-&gt;rdllink
comma
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
id|is_linked
suffix:colon
multiline_comment|/*&n;&t; * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()&n;&t; * wait list.&n;&t; */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
)paren
id|pwake
op_increment
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We have to call this outside the lock */
r_if
c_cond
(paren
id|pwake
)paren
id|ep_poll_safewake
c_func
(paren
op_amp
id|psw
comma
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ep_eventpoll_close
r_static
r_int
id|ep_eventpoll_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|ep
)paren
(brace
id|ep_free
c_func
(paren
id|ep
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ep
)paren
suffix:semicolon
)brace
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: close() ep=%p&bslash;n&quot;
comma
id|current
comma
id|ep
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ep_eventpoll_poll
r_static
r_int
r_int
id|ep_eventpoll_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|pollflags
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|eventpoll
op_star
id|ep
op_assign
id|file-&gt;private_data
suffix:semicolon
multiline_comment|/* Insert inside our poll wait queue */
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|ep-&gt;poll_wait
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* Check our condition */
id|read_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
)paren
id|pollflags
op_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
id|read_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|pollflags
suffix:semicolon
)brace
multiline_comment|/*&n; * Since we have to release the lock during the __copy_to_user() operation and&n; * during the f_op-&gt;poll() call, we try to collect the maximum number of items&n; * by reducing the irqlock/irqunlock switching rate.&n; */
DECL|function|ep_collect_ready_items
r_static
r_int
id|ep_collect_ready_items
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|list_head
op_star
id|txlist
comma
r_int
id|maxevents
)paren
(brace
r_int
id|nepi
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|list_head
op_star
id|lsthead
op_assign
op_amp
id|ep-&gt;rdllist
comma
op_star
id|lnk
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nepi
op_assign
l_int|0
comma
id|lnk
op_assign
id|lsthead-&gt;next
suffix:semicolon
id|lnk
op_ne
id|lsthead
op_logical_and
id|nepi
OL
id|maxevents
suffix:semicolon
)paren
(brace
id|epi
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|epitem
comma
id|rdllink
)paren
suffix:semicolon
id|lnk
op_assign
id|lnk-&gt;next
suffix:semicolon
multiline_comment|/* If this file is already in the ready list we exit soon */
r_if
c_cond
(paren
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;txlink
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * This is initialized in this way so that the default&n;&t;&t;&t; * behaviour of the reinjecting code will be to push back&n;&t;&t;&t; * the item inside the ready list.&n;&t;&t;&t; */
id|epi-&gt;revents
op_assign
id|epi-&gt;event.events
suffix:semicolon
multiline_comment|/* Link the ready item into the transfer list */
id|list_add
c_func
(paren
op_amp
id|epi-&gt;txlink
comma
id|txlist
)paren
suffix:semicolon
id|nepi
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Unlink the item from the ready list.&n;&t;&t;&t; */
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
suffix:semicolon
)brace
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|nepi
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called without holding the &quot;ep-&gt;lock&quot; since the call to&n; * __copy_to_user() might sleep, and also f_op-&gt;poll() might reenable the IRQ&n; * because of the way poll() is traditionally implemented in Linux.&n; */
DECL|function|ep_send_events
r_static
r_int
id|ep_send_events
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|list_head
op_star
id|txlist
comma
r_struct
id|epoll_event
op_star
id|events
)paren
(brace
r_int
id|eventcnt
op_assign
l_int|0
comma
id|eventbuf
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|revents
suffix:semicolon
r_struct
id|list_head
op_star
id|lnk
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
r_struct
id|epoll_event
id|event
(braket
id|EP_MAX_BUF_EVENTS
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * We can loop without lock because this is a task private list.&n;&t; * The test done during the collection loop will guarantee us that&n;&t; * another task will not try to collect this file. Also, items&n;&t; * cannot vanish during the loop because we are holding &quot;sem&quot;.&n;&t; */
id|list_for_each
c_func
(paren
id|lnk
comma
id|txlist
)paren
(brace
id|epi
op_assign
id|list_entry
c_func
(paren
id|lnk
comma
r_struct
id|epitem
comma
id|txlink
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the ready file event set. We can safely use the file&n;&t;&t; * because we are holding the &quot;sem&quot; in read and this will&n;&t;&t; * guarantee that both the file and the item will not vanish.&n;&t;&t; */
id|revents
op_assign
id|epi-&gt;file-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|epi-&gt;file
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the return event set for the current file descriptor.&n;&t;&t; * Note that only the task task was successfully able to link&n;&t;&t; * the item to its &quot;txlist&quot; will write this field.&n;&t;&t; */
id|epi-&gt;revents
op_assign
id|revents
op_amp
id|epi-&gt;event.events
suffix:semicolon
r_if
c_cond
(paren
id|epi-&gt;revents
)paren
(brace
id|event
(braket
id|eventbuf
)braket
op_assign
id|epi-&gt;event
suffix:semicolon
id|event
(braket
id|eventbuf
)braket
dot
id|events
op_and_assign
id|revents
suffix:semicolon
id|eventbuf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|eventbuf
op_eq
id|EP_MAX_BUF_EVENTS
)paren
(brace
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
op_amp
id|events
(braket
id|eventcnt
)braket
comma
id|event
comma
id|eventbuf
op_star
r_sizeof
(paren
r_struct
id|epoll_event
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|eventcnt
op_add_assign
id|eventbuf
suffix:semicolon
id|eventbuf
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|eventbuf
)paren
(brace
r_if
c_cond
(paren
id|__copy_to_user
c_func
(paren
op_amp
id|events
(braket
id|eventcnt
)braket
comma
id|event
comma
id|eventbuf
op_star
r_sizeof
(paren
r_struct
id|epoll_event
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|eventcnt
op_add_assign
id|eventbuf
suffix:semicolon
)brace
r_return
id|eventcnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Walk through the transfer list we collected with ep_collect_ready_items()&n; * and, if 1) the item is still &quot;alive&quot; 2) its event set is not empty 3) it&squot;s&n; * not already linked, links it to the ready list. Same as above, we are holding&n; * &quot;sem&quot; so items cannot vanish underneath our nose.&n; */
DECL|function|ep_reinject_items
r_static
r_void
id|ep_reinject_items
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|list_head
op_star
id|txlist
)paren
(brace
r_int
id|ricnt
op_assign
l_int|0
comma
id|pwake
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|epitem
op_star
id|epi
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|txlist
)paren
)paren
(brace
id|epi
op_assign
id|list_entry
c_func
(paren
id|txlist-&gt;next
comma
r_struct
id|epitem
comma
id|txlink
)paren
suffix:semicolon
multiline_comment|/* Unlink the current item from the transfer list */
id|EP_LIST_DEL
c_func
(paren
op_amp
id|epi-&gt;txlink
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the item is no more linked to the interest set, we don&squot;t&n;&t;&t; * have to push it inside the ready list because the following&n;&t;&t; * ep_release_epitem() is going to drop it. Also, if the current&n;&t;&t; * item is set to have an Edge Triggered behaviour, we don&squot;t have&n;&t;&t; * to push it back either.&n;&t;&t; */
r_if
c_cond
(paren
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;llink
)paren
op_logical_and
op_logical_neg
(paren
id|epi-&gt;event.events
op_amp
id|EPOLLET
)paren
op_logical_and
(paren
id|epi-&gt;revents
op_amp
id|epi-&gt;event.events
)paren
op_logical_and
op_logical_neg
id|EP_IS_LINKED
c_func
(paren
op_amp
id|epi-&gt;rdllink
)paren
)paren
(brace
id|list_add_tail
c_func
(paren
op_amp
id|epi-&gt;rdllink
comma
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
id|ricnt
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ricnt
)paren
(brace
multiline_comment|/*&n;&t;&t; * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()&n;&t;&t; * wait list.&n;&t;&t; */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|ep-&gt;wq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ep-&gt;poll_wait
)paren
)paren
id|pwake
op_increment
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* We have to call this outside the lock */
r_if
c_cond
(paren
id|pwake
)paren
id|ep_poll_safewake
c_func
(paren
op_amp
id|psw
comma
op_amp
id|ep-&gt;poll_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform the transfer of events to user space.&n; */
DECL|function|ep_events_transfer
r_static
r_int
id|ep_events_transfer
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epoll_event
op_star
id|events
comma
r_int
id|maxevents
)paren
(brace
r_int
id|eventcnt
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
id|txlist
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|txlist
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We need to lock this because we could be hit by&n;&t; * eventpoll_release() and epoll_ctl(EPOLL_CTL_DEL).&n;&t; */
id|down_read
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
multiline_comment|/* Collect/extract ready items */
r_if
c_cond
(paren
id|ep_collect_ready_items
c_func
(paren
id|ep
comma
op_amp
id|txlist
comma
id|maxevents
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* Build result set in userspace */
id|eventcnt
op_assign
id|ep_send_events
c_func
(paren
id|ep
comma
op_amp
id|txlist
comma
id|events
)paren
suffix:semicolon
multiline_comment|/* Reinject ready items into the ready list */
id|ep_reinject_items
c_func
(paren
id|ep
comma
op_amp
id|txlist
)paren
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|ep-&gt;sem
)paren
suffix:semicolon
r_return
id|eventcnt
suffix:semicolon
)brace
DECL|function|ep_poll
r_static
r_int
id|ep_poll
c_func
(paren
r_struct
id|eventpoll
op_star
id|ep
comma
r_struct
id|epoll_event
op_star
id|events
comma
r_int
id|maxevents
comma
r_int
id|timeout
)paren
(brace
r_int
id|res
comma
id|eavail
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|jtimeout
suffix:semicolon
id|wait_queue_t
id|wait
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the timeout by checking for the &quot;infinite&quot; value ( -1 )&n;&t; * and the overflow condition. The passed timeout is in milliseconds,&n;&t; * that why (t * HZ) / 1000.&n;&t; */
id|jtimeout
op_assign
id|timeout
op_eq
op_minus
l_int|1
op_logical_or
id|timeout
OG
(paren
id|MAX_SCHEDULE_TIMEOUT
op_minus
l_int|1000
)paren
op_div
id|HZ
ques
c_cond
id|MAX_SCHEDULE_TIMEOUT
suffix:colon
(paren
id|timeout
op_star
id|HZ
op_plus
l_int|999
)paren
op_div
l_int|1000
suffix:semicolon
id|retry
suffix:colon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t have any available event to return to the caller.&n;&t;&t; * We need to sleep here, and we will be wake up by&n;&t;&t; * ep_poll_callback() when events will become available.&n;&t;&t; */
id|init_waitqueue_entry
c_func
(paren
op_amp
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t want to sleep if the ep_poll_callback() sends us&n;&t;&t;&t; * a wakeup in between. That&squot;s why we set the task state&n;&t;&t;&t; * to TASK_INTERRUPTIBLE before doing the checks.&n;&t;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
op_logical_or
op_logical_neg
id|jtimeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|res
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|jtimeout
op_assign
id|schedule_timeout
c_func
(paren
id|jtimeout
)paren
suffix:semicolon
id|write_lock_irqsave
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|ep-&gt;wq
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
multiline_comment|/* Is it worth to try to dig for events ? */
id|eavail
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|ep-&gt;rdllist
)paren
suffix:semicolon
id|write_unlock_irqrestore
c_func
(paren
op_amp
id|ep-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to transfer events to user space. In case we get 0 events and&n;&t; * there&squot;s still timeout left over, we go trying again in search of&n;&t; * more luck.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|res
op_logical_and
id|eavail
op_logical_and
op_logical_neg
(paren
id|res
op_assign
id|ep_events_transfer
c_func
(paren
id|ep
comma
id|events
comma
id|maxevents
)paren
)paren
op_logical_and
id|jtimeout
)paren
r_goto
id|retry
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|eventpollfs_delete_dentry
r_static
r_int
id|eventpollfs_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ep_eventpoll_inode
r_static
r_struct
id|inode
op_star
id|ep_eventpoll_inode
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|new_inode
c_func
(paren
id|eventpoll_mnt-&gt;mnt_sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|eexit_1
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|eventpoll_fops
suffix:semicolon
multiline_comment|/*&n;&t; * Mark the inode dirty from the very beginning,&n;&t; * that way it will never be moved to the dirty&n;&t; * list because mark_inode_dirty() will think&n;&t; * that it already _is_ on the dirty list.&n;&t; */
id|inode-&gt;i_state
op_assign
id|I_DIRTY
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|current-&gt;fsgid
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|PAGE_SIZE
suffix:semicolon
r_return
id|inode
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
r_static
r_struct
id|super_block
op_star
DECL|function|eventpollfs_get_sb
id|eventpollfs_get_sb
c_func
(paren
r_struct
id|file_system_type
op_star
id|fs_type
comma
r_int
id|flags
comma
r_const
r_char
op_star
id|dev_name
comma
r_void
op_star
id|data
)paren
(brace
r_return
id|get_sb_pseudo
c_func
(paren
id|fs_type
comma
l_string|&quot;eventpoll:&quot;
comma
l_int|NULL
comma
id|EVENTPOLLFS_MAGIC
)paren
suffix:semicolon
)brace
DECL|function|eventpoll_init
r_static
r_int
id|__init
id|eventpoll_init
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|epsem
)paren
suffix:semicolon
multiline_comment|/* Initialize the structure used to perform safe poll wait head wake ups */
id|ep_poll_safewake_init
c_func
(paren
op_amp
id|psw
)paren
suffix:semicolon
multiline_comment|/* Allocates slab cache used to allocate &quot;struct epitem&quot; items */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|epi_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;eventpoll_epi&quot;
comma
r_sizeof
(paren
r_struct
id|epitem
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
op_or
id|EPI_SLAB_DEBUG
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|epi_cache
)paren
r_goto
id|eexit_1
suffix:semicolon
multiline_comment|/* Allocates slab cache used to allocate &quot;struct eppoll_entry&quot; */
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|pwq_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;eventpoll_pwq&quot;
comma
r_sizeof
(paren
r_struct
id|eppoll_entry
)paren
comma
l_int|0
comma
id|EPI_SLAB_DEBUG
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pwq_cache
)paren
r_goto
id|eexit_2
suffix:semicolon
multiline_comment|/*&n;&t; * Register the virtual file system that will be the source of inodes&n;&t; * for the eventpoll files&n;&t; */
id|error
op_assign
id|register_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|eexit_3
suffix:semicolon
multiline_comment|/* Mount the above commented virtual file system */
id|eventpoll_mnt
op_assign
id|kern_mount
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|eventpoll_mnt
)paren
)paren
r_goto
id|eexit_4
suffix:semicolon
id|DNPRINTK
c_func
(paren
l_int|3
comma
(paren
id|KERN_INFO
l_string|&quot;[%p] eventpoll: successfully initialized.&bslash;n&quot;
comma
id|current
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|eexit_4
suffix:colon
id|unregister_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|eexit_3
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|pwq_cache
)paren
suffix:semicolon
id|eexit_2
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|epi_cache
)paren
suffix:semicolon
id|eexit_1
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|eventpoll_exit
r_static
r_void
id|__exit
id|eventpoll_exit
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Undo all operations done inside eventpoll_init() */
id|unregister_filesystem
c_func
(paren
op_amp
id|eventpoll_fs_type
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|eventpoll_mnt
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|pwq_cache
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|epi_cache
)paren
suffix:semicolon
)brace
DECL|variable|eventpoll_init
id|module_init
c_func
(paren
id|eventpoll_init
)paren
suffix:semicolon
DECL|variable|eventpoll_exit
id|module_exit
c_func
(paren
id|eventpoll_exit
)paren
suffix:semicolon
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
eof
