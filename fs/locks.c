multiline_comment|/*&n; *  linux/fs/locks.c&n; *&n; *  Provide support for fcntl()&squot;s F_GETLK, F_SETLK, and F_SETLKW calls.&n; *  Doug Evans (dje@spiff.uucp), August 07, 1992&n; *&n; *  Deadlock detection added.&n; *  FIXME: one thing isn&squot;t handled yet:&n; *&t;- mandatory locks (requires lots of changes elsewhere)&n; *  Kelly Carmichael (kelly@[142.24.8.65]), September 17, 1994.&n; *&n; *  Miscellaneous edits, and a total rewrite of posix_lock_file() code.&n; *  Kai Petzke (wpp@marie.physik.tu-berlin.de), 1994&n; *  &n; *  Converted file_lock_table to a linked list from an array, which eliminates&n; *  the limits on how many active file locks are open.&n; *  Chad Page (pageone@netcom.com), November 27, 1994&n; * &n; *  Removed dependency on file descriptors. dup()&squot;ed file descriptors now&n; *  get the same locks as the original file descriptors, and a close() on&n; *  any file descriptor removes ALL the locks on the file for the current&n; *  process. Since locks still depend on the process id, locks are inherited&n; *  after an exec() but not after a fork(). This agrees with POSIX, and both&n; *  BSD and SVR4 practice.&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 14, 1995&n; *&n; *  Scrapped free list which is redundant now that we allocate locks&n; *  dynamically with kmalloc()/kfree().&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 21, 1995&n; *&n; *  Implemented two lock personalities - FL_FLOCK and FL_POSIX.&n; *&n; *  FL_POSIX locks are created with calls to fcntl() and lockf() through the&n; *  fcntl() system call. They have the semantics described above.&n; *&n; *  FL_FLOCK locks are created with calls to flock(), through the flock()&n; *  system call, which is new. Old C libraries implement flock() via fcntl()&n; *  and will continue to use the old, broken implementation.&n; *&n; *  FL_FLOCK locks follow the 4.4 BSD flock() semantics. They are associated&n; *  with a file pointer (filp). As a result they can be shared by a parent&n; *  process and its children after a fork(). They are removed when the last&n; *  file descriptor referring to the file pointer is closed (unless explicitly&n; *  unlocked). &n; *&n; *  FL_FLOCK locks never deadlock, an existing lock is always removed before&n; *  upgrading from shared to exclusive (or vice versa). When this happens&n; *  any processes blocked by the current lock are woken up and allowed to&n; *  run before the new lock is applied.&n; *  Andy Walker (andy@lysaker.kvaerner.no), June 09, 1995&n; *&n; *  Removed some race conditions in flock_lock_file(), marked other possible&n; *  races. Just grep for FIXME to see them. &n; *  Dmitry Gorodchanin (pgmdsg@ibi.com), February 09, 1996.&n; *&n; *  Addressed Dmitry&squot;s concerns. Deadlock checking no longer recursive.&n; *  Lock allocation changed to GFP_ATOMIC as we can&squot;t afford to sleep&n; *  once we&squot;ve checked for blocking and deadlocking.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 03, 1996.&n; *&n; *  Initial implementation of mandatory locks. SunOS turned out to be&n; *  a rotten model, so I implemented the &quot;obvious&quot; semantics.&n; *  See &squot;linux/Documentation/mandatory.txt&squot; for details.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 06, 1996.&n; *&n; *  Don&squot;t allow mandatory locks on mmap()&squot;ed files. Added simple functions to&n; *  check if a file has mandatory locks, used by mmap(), open() and creat() to&n; *  see if system call should be rejected. Ref. HP-UX/SunOS/Solaris Reference&n; *  Manual, Section 2.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 09, 1996.&n; *&n; *  Tidied up block list handling. Added &squot;/proc/locks&squot; interface.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 24, 1996.&n; *&n; *  Fixed deadlock condition for pathological code that mixes calls to&n; *  flock() and fcntl().&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 29, 1996.&n; *&n; *  Allow only one type of locking scheme (FL_POSIX or FL_FLOCK) to be in use&n; *  for a given file at a time. Changed the CONFIG_LOCK_MANDATORY scheme to&n; *  guarantee sensible behaviour in the case where file system modules might&n; *  be compiled with different options than the kernel itself.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.&n; *&n; *  Added a couple of missing wake_up() calls. Thanks to Thomas Meckel&n; *  (Thomas.Meckel@mni.fh-giessen.de) for spotting this.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.&n; *&n; *  Changed FL_POSIX locks to use the block list in the same way as FL_FLOCK&n; *  locks. Changed process synchronisation to avoid dereferencing locks that&n; *  have already been freed.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Sep 21, 1996.&n; *&n; *  Made the block list a circular list to minimise searching in the list.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Sep 25, 1996.&n; *&n; *  Made mandatory locking a mount option. Default is not to allow mandatory&n; *  locking.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Oct 04, 1996.&n; *&n; *  Some adaptations for NFS support.&n; *  Olaf Kirch (okir@monad.swb.de), Dec 1996,&n; *&n; *  Fixed /proc/locks interface so that we can&squot;t overrun the buffer we are handed.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 12, 1997.&n; *&n; *  Use slab allocator instead of kmalloc/kfree.&n; *  Use generic list implementation from &lt;linux/list.h&gt;.&n; *  Sped up posix_locks_deadlock by only considering blocked locks.&n; *  Matthew Wilcox &lt;willy@debian.org&gt;, March, 2000.&n; *&n; *  Leases and LOCK_MAND&n; *  Matthew Wilcox &lt;willy@debian.org&gt;, June, 2000.&n; *  Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;, June, 2000.&n; */
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/security.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|IS_POSIX
mdefine_line|#define IS_POSIX(fl)&t;(fl-&gt;fl_flags &amp; FL_POSIX)
DECL|macro|IS_FLOCK
mdefine_line|#define IS_FLOCK(fl)&t;(fl-&gt;fl_flags &amp; FL_FLOCK)
DECL|macro|IS_LEASE
mdefine_line|#define IS_LEASE(fl)&t;(fl-&gt;fl_flags &amp; FL_LEASE)
DECL|variable|leases_enable
r_int
id|leases_enable
op_assign
l_int|1
suffix:semicolon
DECL|variable|lease_break_time
r_int
id|lease_break_time
op_assign
l_int|45
suffix:semicolon
DECL|macro|for_each_lock
mdefine_line|#define for_each_lock(inode, lockp) &bslash;&n;&t;for (lockp = &amp;inode-&gt;i_flock; *lockp != NULL; lockp = &amp;(*lockp)-&gt;fl_next)
DECL|variable|file_lock_list
id|LIST_HEAD
c_func
(paren
id|file_lock_list
)paren
suffix:semicolon
DECL|variable|file_lock_list
id|EXPORT_SYMBOL
c_func
(paren
id|file_lock_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|blocked_list
)paren
suffix:semicolon
DECL|variable|filelock_cache
r_static
id|kmem_cache_t
op_star
id|filelock_cache
suffix:semicolon
multiline_comment|/* Allocate an empty lock structure. */
DECL|function|locks_alloc_lock
r_static
r_struct
id|file_lock
op_star
id|locks_alloc_lock
c_func
(paren
r_void
)paren
(brace
r_return
id|kmem_cache_alloc
c_func
(paren
id|filelock_cache
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
)brace
multiline_comment|/* Free a lock which is not in use. */
DECL|function|locks_free_lock
r_static
r_inline
r_void
id|locks_free_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_if
c_cond
(paren
id|fl
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempting to free lock with active wait queue&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fl-&gt;fl_block
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempting to free lock with active block list&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fl-&gt;fl_link
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempting to free lock on active lock list&quot;
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|filelock_cache
comma
id|fl
)paren
suffix:semicolon
)brace
DECL|function|locks_init_lock
r_void
id|locks_init_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fl-&gt;fl_link
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fl-&gt;fl_block
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
id|fl-&gt;fl_next
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_fasync
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_file
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_type
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|fl-&gt;fl_end
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|locks_init_lock
id|EXPORT_SYMBOL
c_func
(paren
id|locks_init_lock
)paren
suffix:semicolon
multiline_comment|/*&n; * Initialises the fields of the file lock which are invariant for&n; * free file_locks.&n; */
DECL|function|init_once
r_static
r_void
id|init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cache
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|file_lock
op_star
id|lock
op_assign
(paren
r_struct
id|file_lock
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_ne
id|SLAB_CTOR_CONSTRUCTOR
)paren
r_return
suffix:semicolon
id|locks_init_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a new lock from an existing file_lock structure.&n; */
DECL|function|locks_copy_lock
r_void
id|locks_copy_lock
c_func
(paren
r_struct
id|file_lock
op_star
r_new
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_new
op_member_access_from_pointer
id|fl_owner
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_file
op_assign
id|fl-&gt;fl_file
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_flags
op_assign
id|fl-&gt;fl_flags
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_notify
op_assign
id|fl-&gt;fl_notify
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_insert
op_assign
id|fl-&gt;fl_insert
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_remove
op_assign
id|fl-&gt;fl_remove
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_u
op_assign
id|fl-&gt;fl_u
suffix:semicolon
)brace
DECL|variable|locks_copy_lock
id|EXPORT_SYMBOL
c_func
(paren
id|locks_copy_lock
)paren
suffix:semicolon
DECL|function|flock_translate_cmd
r_static
r_inline
r_int
id|flock_translate_cmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_amp
id|LOCK_MAND
)paren
r_return
id|cmd
op_amp
(paren
id|LOCK_MAND
op_or
id|LOCK_RW
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|LOCK_SH
suffix:colon
r_return
id|F_RDLCK
suffix:semicolon
r_case
id|LOCK_EX
suffix:colon
r_return
id|F_WRLCK
suffix:semicolon
r_case
id|LOCK_UN
suffix:colon
r_return
id|F_UNLCK
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Fill in a file_lock structure with an appropriate FLOCK lock. */
DECL|function|flock_make_lock
r_static
r_int
id|flock_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
op_star
id|lock
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|type
op_assign
id|flock_translate_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
l_int|0
)paren
r_return
id|type
suffix:semicolon
id|fl
op_assign
id|locks_alloc_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_FLOCK
suffix:semicolon
id|fl-&gt;fl_type
op_assign
id|type
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
op_star
id|lock
op_assign
id|fl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|assign_type
r_static
r_int
id|assign_type
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_case
id|F_WRLCK
suffix:colon
r_case
id|F_UNLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Verify a &quot;struct flock&quot; and copy it to a &quot;struct file_lock&quot; as a POSIX&n; * style lock.&n; */
DECL|function|flock_to_posix_lock
r_static
r_int
id|flock_to_posix_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
id|off_t
id|start
comma
id|end
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_whence
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*SEEK_SET*/
id|start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*SEEK_CUR*/
id|start
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*SEEK_END*/
id|start
op_assign
id|i_size_read
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* POSIX-1996 leaves the case l-&gt;l_len &lt; 0 undefined;&n;&t;   POSIX-2001 defines it. */
id|start
op_add_assign
id|l-&gt;l_start
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|l-&gt;l_len
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;l_len
OL
l_int|0
)paren
(brace
id|end
op_assign
id|start
op_minus
l_int|1
suffix:semicolon
id|start
op_add_assign
id|l-&gt;l_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;l_len
OG
l_int|0
op_logical_and
id|end
OL
l_int|0
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|start
suffix:semicolon
multiline_comment|/* we record the absolute position */
id|fl-&gt;fl_end
op_assign
id|end
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;l_len
op_eq
l_int|0
)paren
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
r_return
id|assign_type
c_func
(paren
id|fl
comma
id|l-&gt;l_type
)paren
suffix:semicolon
)brace
macro_line|#if BITS_PER_LONG == 32
DECL|function|flock64_to_posix_lock
r_static
r_int
id|flock64_to_posix_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock64
op_star
id|l
)paren
(brace
id|loff_t
id|start
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_whence
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*SEEK_SET*/
id|start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*SEEK_CUR*/
id|start
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*SEEK_END*/
id|start
op_assign
id|i_size_read
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|start
op_add_assign
id|l-&gt;l_start
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|l-&gt;l_len
OL
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|start
op_plus
id|l-&gt;l_len
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;l_len
OG
l_int|0
op_logical_and
id|fl-&gt;fl_end
OL
l_int|0
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|start
suffix:semicolon
multiline_comment|/* we record the absolute position */
r_if
c_cond
(paren
id|l-&gt;l_len
op_eq
l_int|0
)paren
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_case
id|F_WRLCK
suffix:colon
r_case
id|F_UNLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|l-&gt;l_type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Allocate a file_lock initialised to this type of lease */
DECL|function|lease_alloc
r_static
r_int
id|lease_alloc
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
id|type
comma
r_struct
id|file_lock
op_star
op_star
id|flp
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
id|locks_alloc_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_LEASE
suffix:semicolon
r_if
c_cond
(paren
id|assign_type
c_func
(paren
id|fl
comma
id|type
)paren
op_ne
l_int|0
)paren
(brace
id|locks_free_lock
c_func
(paren
id|fl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|fl-&gt;fl_start
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
op_star
id|flp
op_assign
id|fl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check if two locks overlap each other.&n; */
DECL|function|locks_overlap
r_static
r_inline
r_int
id|locks_overlap
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_return
(paren
(paren
id|fl1-&gt;fl_end
op_ge
id|fl2-&gt;fl_start
)paren
op_logical_and
(paren
id|fl2-&gt;fl_end
op_ge
id|fl1-&gt;fl_start
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether two locks have the same owner.  The apparently superfluous&n; * check for fl_pid enables us to distinguish between locks set by lockd.&n; */
r_static
r_inline
r_int
DECL|function|posix_same_owner
id|posix_same_owner
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_return
(paren
id|fl1-&gt;fl_owner
op_eq
id|fl2-&gt;fl_owner
)paren
op_logical_and
(paren
id|fl1-&gt;fl_pid
op_eq
id|fl2-&gt;fl_pid
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove waiter from blocker&squot;s block list.&n; * When blocker ends up pointing to itself then the list is empty.&n; */
DECL|function|__locks_delete_block
r_static
r_inline
r_void
id|__locks_delete_block
c_func
(paren
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|waiter-&gt;fl_block
)paren
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|waiter-&gt;fl_link
)paren
suffix:semicolon
id|waiter-&gt;fl_next
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|function|locks_delete_block
r_static
r_void
id|locks_delete_block
c_func
(paren
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|__locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert waiter into blocker&squot;s block list.&n; * We use a circular list so that processes can be easily woken up in&n; * the order they blocked. The documentation doesn&squot;t require this but&n; * it seems like the reasonable thing to do.&n; */
DECL|function|locks_insert_block
r_static
r_void
id|locks_insert_block
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|waiter-&gt;fl_block
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;locks_insert_block: removing duplicated lock &quot;
l_string|&quot;(pid=%d %Ld-%Ld type=%d)&bslash;n&quot;
comma
id|waiter-&gt;fl_pid
comma
id|waiter-&gt;fl_start
comma
id|waiter-&gt;fl_end
comma
id|waiter-&gt;fl_type
)paren
suffix:semicolon
id|__locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|waiter-&gt;fl_block
comma
op_amp
id|blocker-&gt;fl_block
)paren
suffix:semicolon
id|waiter-&gt;fl_next
op_assign
id|blocker
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|waiter-&gt;fl_link
comma
op_amp
id|blocked_list
)paren
suffix:semicolon
)brace
multiline_comment|/* Wake up processes blocked waiting for blocker.&n; * If told to wait then schedule the processes until the block list&n; * is empty, otherwise empty the block list ourselves.&n; */
DECL|function|locks_wake_up_blocks
r_static
r_void
id|locks_wake_up_blocks
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|blocker-&gt;fl_block
)paren
)paren
(brace
r_struct
id|file_lock
op_star
id|waiter
op_assign
id|list_entry
c_func
(paren
id|blocker-&gt;fl_block.next
comma
r_struct
id|file_lock
comma
id|fl_block
)paren
suffix:semicolon
id|__locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waiter-&gt;fl_notify
)paren
id|waiter
op_member_access_from_pointer
id|fl_notify
c_func
(paren
id|waiter
)paren
suffix:semicolon
r_else
id|wake_up
c_func
(paren
op_amp
id|waiter-&gt;fl_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Insert file lock fl into an inode&squot;s lock list at the position indicated&n; * by pos. At the same time add the lock to the global file lock list.&n; */
DECL|function|locks_insert_lock
r_static
r_void
id|locks_insert_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|pos
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|fl-&gt;fl_link
comma
op_amp
id|file_lock_list
)paren
suffix:semicolon
multiline_comment|/* insert into file&squot;s list */
id|fl-&gt;fl_next
op_assign
op_star
id|pos
suffix:semicolon
op_star
id|pos
op_assign
id|fl
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_insert
)paren
id|fl
op_member_access_from_pointer
id|fl_insert
c_func
(paren
id|fl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Delete a lock and then free it.&n; * Wake up processes that are blocked waiting for this lock,&n; * notify the FS that the lock has been cleared and&n; * finally free the lock.&n; */
DECL|function|locks_delete_lock
r_static
r_void
id|locks_delete_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|thisfl_p
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|thisfl_p
suffix:semicolon
op_star
id|thisfl_p
op_assign
id|fl-&gt;fl_next
suffix:semicolon
id|fl-&gt;fl_next
op_assign
l_int|NULL
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|fl-&gt;fl_link
)paren
suffix:semicolon
id|fasync_helper
c_func
(paren
l_int|0
comma
id|fl-&gt;fl_file
comma
l_int|0
comma
op_amp
id|fl-&gt;fl_fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_fasync
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;locks_delete_lock: fasync == %p&bslash;n&quot;
comma
id|fl-&gt;fl_fasync
)paren
suffix:semicolon
id|fl-&gt;fl_fasync
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl-&gt;fl_remove
)paren
id|fl
op_member_access_from_pointer
id|fl_remove
c_func
(paren
id|fl
)paren
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|fl
)paren
suffix:semicolon
id|locks_free_lock
c_func
(paren
id|fl
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. Common functionality&n; * checks for shared/exclusive status of overlapping locks.&n; */
DECL|function|locks_conflict
r_static
r_int
id|locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
r_if
c_cond
(paren
id|sys_fl-&gt;fl_type
op_eq
id|F_WRLCK
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|caller_fl-&gt;fl_type
op_eq
id|F_WRLCK
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. POSIX specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|posix_locks_conflict
r_static
r_int
id|posix_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* POSIX locks owned by the same process do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|IS_POSIX
c_func
(paren
id|sys_fl
)paren
op_logical_or
id|posix_same_owner
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Check whether they overlap */
r_if
c_cond
(paren
op_logical_neg
id|locks_overlap
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. FLOCK specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|flock_locks_conflict
r_static
r_int
id|flock_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* FLOCK locks referring to the same filp do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|IS_FLOCK
c_func
(paren
id|sys_fl
)paren
op_logical_or
(paren
id|caller_fl-&gt;fl_file
op_eq
id|sys_fl-&gt;fl_file
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|caller_fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
op_logical_or
(paren
id|sys_fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
DECL|function|interruptible_sleep_on_locked
r_static
r_int
id|interruptible_sleep_on_locked
c_func
(paren
id|wait_queue_head_t
op_star
id|fl_wait
comma
r_int
id|timeout
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|fl_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_else
id|result
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
id|result
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|fl_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|locks_block_on_timeout
r_static
r_int
id|locks_block_on_timeout
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
comma
r_int
id|time
)paren
(brace
r_int
id|result
suffix:semicolon
id|locks_insert_block
c_func
(paren
id|blocker
comma
id|waiter
)paren
suffix:semicolon
id|result
op_assign
id|interruptible_sleep_on_locked
c_func
(paren
op_amp
id|waiter-&gt;fl_wait
comma
id|time
)paren
suffix:semicolon
id|__locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_struct
id|file_lock
op_star
DECL|function|posix_test_lock
id|posix_test_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_struct
id|file_lock
op_star
id|cfl
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfl
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock
suffix:semicolon
id|cfl
suffix:semicolon
id|cfl
op_assign
id|cfl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_POSIX
c_func
(paren
id|cfl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_conflict
c_func
(paren
id|cfl
comma
id|fl
)paren
)paren
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|cfl
)paren
suffix:semicolon
)brace
DECL|variable|posix_test_lock
id|EXPORT_SYMBOL
c_func
(paren
id|posix_test_lock
)paren
suffix:semicolon
multiline_comment|/* This function tests for deadlock condition before putting a process to&n; * sleep. The detection scheme is no longer recursive. Recursive was neat,&n; * but dangerous - we risked stack corruption if the lock data was bad, or&n; * if the recursion was too deep for any other reason.&n; *&n; * We rely on the fact that a task can only be on one lock&squot;s wait queue&n; * at a time. When we find blocked_task on a wait queue we can re-search&n; * with blocked_task equal to that queue&squot;s owner, until either blocked_task&n; * isn&squot;t found, or blocked_task is found on a queue owned by my_task.&n; *&n; * Note: the above assumption may not be true when handling lock requests&n; * from a broken NFS client. But broken NFS clients have a lot more to&n; * worry about than proper deadlock detection anyway... --okir&n; */
DECL|function|posix_locks_deadlock
r_int
id|posix_locks_deadlock
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|block_fl
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|fl_owner_t
id|caller_owner
comma
id|blocked_owner
suffix:semicolon
r_int
r_int
id|caller_pid
comma
id|blocked_pid
suffix:semicolon
id|caller_owner
op_assign
id|caller_fl-&gt;fl_owner
suffix:semicolon
id|caller_pid
op_assign
id|caller_fl-&gt;fl_pid
suffix:semicolon
id|blocked_owner
op_assign
id|block_fl-&gt;fl_owner
suffix:semicolon
id|blocked_pid
op_assign
id|block_fl-&gt;fl_pid
suffix:semicolon
id|next_task
suffix:colon
r_if
c_cond
(paren
id|caller_owner
op_eq
id|blocked_owner
op_logical_and
id|caller_pid
op_eq
id|blocked_pid
)paren
r_return
l_int|1
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|blocked_list
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|file_lock
comma
id|fl_link
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_owner
op_eq
id|blocked_owner
)paren
op_logical_and
(paren
id|fl-&gt;fl_pid
op_eq
id|blocked_pid
)paren
)paren
(brace
id|fl
op_assign
id|fl-&gt;fl_next
suffix:semicolon
id|blocked_owner
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
id|blocked_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
r_goto
id|next_task
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|posix_locks_deadlock
id|EXPORT_SYMBOL
c_func
(paren
id|posix_locks_deadlock
)paren
suffix:semicolon
multiline_comment|/* Try to create a FLOCK lock on filp. We always insert new FLOCK locks&n; * at the head of the list, but that&squot;s secret knowledge known only to&n; * flock_lock_file and posix_lock_file.&n; */
DECL|function|flock_lock_file
r_static
r_int
id|flock_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|new_fl
)paren
(brace
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|for_each_lock
c_func
(paren
id|inode
comma
id|before
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|before
suffix:semicolon
r_if
c_cond
(paren
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|IS_LEASE
c_func
(paren
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_ne
id|fl-&gt;fl_file
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|new_fl-&gt;fl_type
op_eq
id|fl-&gt;fl_type
)paren
r_goto
id|out
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
id|locks_delete_lock
c_func
(paren
id|before
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_fl-&gt;fl_type
op_eq
id|F_UNLCK
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If a higher-priority process was blocked on the old file lock,&n;&t; * give it the opportunity to lock the file.&n;&t; */
r_if
c_cond
(paren
id|found
)paren
id|cond_resched
c_func
(paren
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|for_each_lock
c_func
(paren
id|inode
comma
id|before
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|before
suffix:semicolon
r_if
c_cond
(paren
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|IS_LEASE
c_func
(paren
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flock_locks_conflict
c_func
(paren
id|new_fl
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|new_fl-&gt;fl_flags
op_amp
id|FL_SLEEP
)paren
(brace
id|locks_insert_block
c_func
(paren
id|fl
comma
id|new_fl
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|locks_insert_lock
c_func
(paren
op_amp
id|inode-&gt;i_flock
comma
id|new_fl
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|posix_lock_file
id|EXPORT_SYMBOL
c_func
(paren
id|posix_lock_file
)paren
suffix:semicolon
DECL|function|__posix_lock_file
r_static
r_int
id|__posix_lock_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file_lock
op_star
id|request
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
comma
op_star
id|new_fl2
suffix:semicolon
r_struct
id|file_lock
op_star
id|left
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
id|right
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_int
id|error
comma
id|added
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We may need two file_lock structures for this operation,&n;&t; * so we get them in advance to avoid races.&n;&t; */
id|new_fl
op_assign
id|locks_alloc_lock
c_func
(paren
)paren
suffix:semicolon
id|new_fl2
op_assign
id|locks_alloc_lock
c_func
(paren
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request-&gt;fl_type
op_ne
id|F_UNLCK
)paren
(brace
id|for_each_lock
c_func
(paren
id|inode
comma
id|before
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|before
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|posix_locks_conflict
c_func
(paren
id|request
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|request-&gt;fl_flags
op_amp
id|FL_SLEEP
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EDEADLK
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_deadlock
c_func
(paren
id|request
comma
id|fl
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
id|locks_insert_block
c_func
(paren
id|fl
comma
id|request
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* If we&squot;re just looking for a conflict, we&squot;re done. */
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|request-&gt;fl_flags
op_amp
id|FL_ACCESS
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|ENOLCK
suffix:semicolon
multiline_comment|/* &quot;no luck&quot; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|new_fl
op_logical_and
id|new_fl2
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;ve allocated the new locks in advance, so there are no&n;&t; * errors possible (and no blocking operations) from here on.&n;&t; * &n;&t; * Find the first old lock with the same owner as the new lock.&n;&t; */
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
multiline_comment|/* First skip locks owned by other processes.  */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
(paren
op_logical_neg
id|IS_POSIX
c_func
(paren
id|fl
)paren
op_logical_or
op_logical_neg
id|posix_same_owner
c_func
(paren
id|request
comma
id|fl
)paren
)paren
)paren
(brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
multiline_comment|/* Process locks with this owner.  */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
id|posix_same_owner
c_func
(paren
id|request
comma
id|fl
)paren
)paren
(brace
multiline_comment|/* Detect adjacent or overlapping regions (if same lock type)&n;&t;&t; */
r_if
c_cond
(paren
id|request-&gt;fl_type
op_eq
id|fl-&gt;fl_type
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|request-&gt;fl_start
op_minus
l_int|1
)paren
r_goto
id|next_lock
suffix:semicolon
multiline_comment|/* If the next lock in the list has entirely bigger&n;&t;&t;&t; * addresses than the new one, insert the lock here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|request-&gt;fl_end
op_plus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* If we come here, the new and old lock are of the&n;&t;&t;&t; * same type and adjacent or overlapping. Make one&n;&t;&t;&t; * lock yielding from the lower start address of both&n;&t;&t;&t; * locks to the higher end address.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|request-&gt;fl_start
)paren
id|fl-&gt;fl_start
op_assign
id|request-&gt;fl_start
suffix:semicolon
r_else
id|request-&gt;fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|request-&gt;fl_end
)paren
id|fl-&gt;fl_end
op_assign
id|request-&gt;fl_end
suffix:semicolon
r_else
id|request-&gt;fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|request
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Processing for different lock types is a bit&n;&t;&t;&t; * more complex.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|request-&gt;fl_start
)paren
r_goto
id|next_lock
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|request-&gt;fl_end
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|request-&gt;fl_type
op_eq
id|F_UNLCK
)paren
id|added
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OL
id|request-&gt;fl_start
)paren
id|left
op_assign
id|fl
suffix:semicolon
multiline_comment|/* If the next lock in the list has a higher end&n;&t;&t;&t; * address than the new one, insert the new one here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OG
id|request-&gt;fl_end
)paren
(brace
id|right
op_assign
id|fl
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl-&gt;fl_start
op_ge
id|request-&gt;fl_start
)paren
(brace
multiline_comment|/* The new lock completely replaces an old&n;&t;&t;&t;&t; * one (This may happen several times).&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Replace the old lock with the new one.&n;&t;&t;&t;&t; * Wake up anybody waiting for the old one,&n;&t;&t;&t;&t; * as the change in lock type might satisfy&n;&t;&t;&t;&t; * their needs.&n;&t;&t;&t;&t; */
id|locks_wake_up_blocks
c_func
(paren
id|fl
)paren
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|request-&gt;fl_start
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|request-&gt;fl_end
suffix:semicolon
id|fl-&gt;fl_type
op_assign
id|request-&gt;fl_type
suffix:semicolon
id|fl-&gt;fl_u
op_assign
id|request-&gt;fl_u
suffix:semicolon
id|request
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Go on to next lock.&n;&t;&t; */
id|next_lock
suffix:colon
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|added
)paren
(brace
r_if
c_cond
(paren
id|request-&gt;fl_type
op_eq
id|F_UNLCK
)paren
r_goto
id|out
suffix:semicolon
id|locks_copy_lock
c_func
(paren
id|new_fl
comma
id|request
)paren
suffix:semicolon
id|locks_insert_lock
c_func
(paren
id|before
comma
id|new_fl
)paren
suffix:semicolon
id|new_fl
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|right
)paren
(brace
r_if
c_cond
(paren
id|left
op_eq
id|right
)paren
(brace
multiline_comment|/* The new lock breaks the old one in two pieces,&n;&t;&t;&t; * so we have to use the second new lock.&n;&t;&t;&t; */
id|left
op_assign
id|new_fl2
suffix:semicolon
id|new_fl2
op_assign
l_int|NULL
suffix:semicolon
id|locks_copy_lock
c_func
(paren
id|left
comma
id|right
)paren
suffix:semicolon
id|locks_insert_lock
c_func
(paren
id|before
comma
id|left
)paren
suffix:semicolon
)brace
id|right-&gt;fl_start
op_assign
id|request-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|right
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
)paren
(brace
id|left-&gt;fl_end
op_assign
id|request-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|left
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free any unused locks.&n;&t; */
r_if
c_cond
(paren
id|new_fl
)paren
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_fl2
)paren
id|locks_free_lock
c_func
(paren
id|new_fl2
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; * posix_lock_file - Apply a POSIX-style lock to a file&n; * @filp: The file to apply the lock to&n; * @fl: The lock to be applied&n; *&n; * Add a POSIX style lock to a file.&n; * We merge adjacent &amp; overlapping locks whenever possible.&n; * POSIX locks are sorted by owner task, then by starting address&n; */
DECL|function|posix_lock_file
r_int
id|posix_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_return
id|__posix_lock_file
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
comma
id|fl
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * locks_mandatory_locked - Check for an active lock&n; * @inode: the file to check&n; *&n; * Searches the inode&squot;s list of locks to find any POSIX locks which conflict.&n; * This function is called from locks_verify_locked() only.&n; */
DECL|function|locks_mandatory_locked
r_int
id|locks_mandatory_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|fl_owner_t
id|owner
op_assign
id|current-&gt;files
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
multiline_comment|/*&n;&t; * Search the lock list for this inode for any POSIX locks.&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_ne
id|owner
)paren
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|fl
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * locks_mandatory_area - Check for a conflicting lock&n; * @read_write: %FLOCK_VERIFY_WRITE for exclusive access, %FLOCK_VERIFY_READ&n; *&t;&t;for shared&n; * @inode:      the file to check&n; * @filp:       how the file was opened (if it was)&n; * @offset:     start of area to check&n; * @count:      length of area to check&n; *&n; * Searches the inode&squot;s list of locks to find any POSIX locks which conflict.&n; * This function is called from locks_verify_area() and&n; * locks_verify_truncate().&n; */
DECL|function|locks_mandatory_area
r_int
id|locks_mandatory_area
c_func
(paren
r_int
id|read_write
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
id|loff_t
id|offset
comma
r_int
id|count
)paren
(brace
r_struct
id|file_lock
id|fl
suffix:semicolon
r_int
id|error
suffix:semicolon
id|locks_init_lock
c_func
(paren
op_amp
id|fl
)paren
suffix:semicolon
id|fl.fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|fl.fl_pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|fl.fl_file
op_assign
id|filp
suffix:semicolon
id|fl.fl_flags
op_assign
id|FL_POSIX
op_or
id|FL_ACCESS
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
id|fl.fl_flags
op_or_assign
id|FL_SLEEP
suffix:semicolon
id|fl.fl_type
op_assign
(paren
id|read_write
op_eq
id|FLOCK_VERIFY_WRITE
)paren
ques
c_cond
id|F_WRLCK
suffix:colon
id|F_RDLCK
suffix:semicolon
id|fl.fl_start
op_assign
id|offset
suffix:semicolon
id|fl.fl_end
op_assign
id|offset
op_plus
id|count
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|error
op_assign
id|__posix_lock_file
c_func
(paren
id|inode
comma
op_amp
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|EAGAIN
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl.fl_flags
op_amp
id|FL_SLEEP
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
id|wait_event_interruptible
c_func
(paren
id|fl.fl_wait
comma
op_logical_neg
id|fl.fl_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve been sleeping someone might have&n;&t;&t;&t; * changed the permissions behind our back.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
r_continue
suffix:semicolon
)brace
id|locks_delete_block
c_func
(paren
op_amp
id|fl
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|variable|locks_mandatory_area
id|EXPORT_SYMBOL
c_func
(paren
id|locks_mandatory_area
)paren
suffix:semicolon
multiline_comment|/* We already had a lease on this file; just change its type */
DECL|function|lease_modify
r_static
r_int
id|lease_modify
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|before
comma
r_int
id|arg
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|before
suffix:semicolon
r_int
id|error
op_assign
id|assign_type
c_func
(paren
id|fl
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|F_UNLCK
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|fl-&gt;fl_file
suffix:semicolon
id|f_delown
c_func
(paren
id|filp
)paren
suffix:semicolon
id|filp-&gt;f_owner.signum
op_assign
l_int|0
suffix:semicolon
id|locks_delete_lock
c_func
(paren
id|before
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|time_out_leases
r_static
r_void
id|time_out_leases
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
id|IS_LEASE
c_func
(paren
id|fl
)paren
op_logical_and
(paren
id|fl-&gt;fl_type
op_amp
id|F_INPROGRESS
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_break_time
op_eq
l_int|0
)paren
op_logical_or
id|time_before
c_func
(paren
id|jiffies
comma
id|fl-&gt;fl_break_time
)paren
)paren
(brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lease broken - owner pid = %d&bslash;n&quot;
comma
id|fl-&gt;fl_pid
)paren
suffix:semicolon
id|lease_modify
c_func
(paren
id|before
comma
id|fl-&gt;fl_type
op_amp
op_complement
id|F_INPROGRESS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_eq
op_star
id|before
)paren
multiline_comment|/* lease_modify may have freed fl */
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;__break_lease&t;-&t;revoke all outstanding leases on file&n; *&t;@inode: the inode of the file to return&n; *&t;@mode: the open mode (read or write)&n; *&n; *&t;break_lease (inlined for speed) has checked there already&n; *&t;is a lease on this file.  Leases are broken on a call to open()&n; *&t;or truncate().  This function can sleep unless you&n; *&t;specified %O_NONBLOCK to your open().&n; */
DECL|function|__break_lease
r_int
id|__break_lease
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|mode
)paren
(brace
r_int
id|error
op_assign
l_int|0
comma
id|future
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
comma
op_star
id|flock
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|alloc_err
suffix:semicolon
r_int
r_int
id|break_time
suffix:semicolon
r_int
id|i_have_this_lease
op_assign
l_int|0
suffix:semicolon
id|alloc_err
op_assign
id|lease_alloc
c_func
(paren
l_int|NULL
comma
id|mode
op_amp
id|FMODE_WRITE
ques
c_cond
id|F_WRLCK
suffix:colon
id|F_RDLCK
comma
op_amp
id|new_fl
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|time_out_leases
c_func
(paren
id|inode
)paren
suffix:semicolon
id|flock
op_assign
id|inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flock
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
id|IS_LEASE
c_func
(paren
id|flock
)paren
)paren
r_goto
id|out
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|flock
suffix:semicolon
id|fl
op_logical_and
id|IS_LEASE
c_func
(paren
id|fl
)paren
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
id|current-&gt;files
)paren
id|i_have_this_lease
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_amp
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* If we want write access, we have to revoke any lease. */
id|future
op_assign
id|F_UNLCK
op_or
id|F_INPROGRESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flock-&gt;fl_type
op_amp
id|F_INPROGRESS
)paren
(brace
multiline_comment|/* If the lease is already being broken, we just leave it */
id|future
op_assign
id|flock-&gt;fl_type
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flock-&gt;fl_type
op_amp
id|F_WRLCK
)paren
(brace
multiline_comment|/* Downgrade the exclusive lease to a read-only lease. */
id|future
op_assign
id|F_RDLCK
op_or
id|F_INPROGRESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the existing lease was read-only, so we can read too. */
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_err
op_logical_and
op_logical_neg
id|i_have_this_lease
op_logical_and
(paren
(paren
id|mode
op_amp
id|O_NONBLOCK
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|error
op_assign
id|alloc_err
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|break_time
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lease_break_time
OG
l_int|0
)paren
(brace
id|break_time
op_assign
id|jiffies
op_plus
id|lease_break_time
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|break_time
op_eq
l_int|0
)paren
id|break_time
op_increment
suffix:semicolon
multiline_comment|/* so that 0 means no break time */
)brace
r_for
c_loop
(paren
id|fl
op_assign
id|flock
suffix:semicolon
id|fl
op_logical_and
id|IS_LEASE
c_func
(paren
id|fl
)paren
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_ne
id|future
)paren
(brace
id|fl-&gt;fl_type
op_assign
id|future
suffix:semicolon
id|fl-&gt;fl_break_time
op_assign
id|break_time
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|fl-&gt;fl_fasync
comma
id|SIGIO
comma
id|POLL_MSG
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i_have_this_lease
op_logical_or
(paren
id|mode
op_amp
id|O_NONBLOCK
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|restart
suffix:colon
id|break_time
op_assign
id|flock-&gt;fl_break_time
suffix:semicolon
r_if
c_cond
(paren
id|break_time
op_ne
l_int|0
)paren
(brace
id|break_time
op_sub_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|break_time
op_eq
l_int|0
)paren
id|break_time
op_increment
suffix:semicolon
)brace
id|error
op_assign
id|locks_block_on_timeout
c_func
(paren
id|flock
comma
id|new_fl
comma
id|break_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|time_out_leases
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* Wait for the next lease that has not been broken yet */
r_for
c_loop
(paren
id|flock
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|flock
op_logical_and
id|IS_LEASE
c_func
(paren
id|flock
)paren
suffix:semicolon
id|flock
op_assign
id|flock-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|flock-&gt;fl_type
op_amp
id|F_INPROGRESS
)paren
r_goto
id|restart
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alloc_err
)paren
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|__break_lease
id|EXPORT_SYMBOL
c_func
(paren
id|__break_lease
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;lease_get_mtime&n; *&t;@inode: the inode&n; *      @time:  pointer to a timespec which will contain the last modified time&n; *&n; * This is to force NFS clients to flush their caches for files with&n; * exclusive leases.  The justification is that if someone has an&n; * exclusive lease, then they could be modifiying it.&n; */
DECL|function|lease_get_mtime
r_void
id|lease_get_mtime
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|timespec
op_star
id|time
)paren
(brace
r_struct
id|file_lock
op_star
id|flock
op_assign
id|inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
id|flock
op_logical_and
id|IS_LEASE
c_func
(paren
id|flock
)paren
op_logical_and
(paren
id|flock-&gt;fl_type
op_amp
id|F_WRLCK
)paren
)paren
op_star
id|time
op_assign
id|CURRENT_TIME
suffix:semicolon
r_else
op_star
id|time
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
)brace
DECL|variable|lease_get_mtime
id|EXPORT_SYMBOL
c_func
(paren
id|lease_get_mtime
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;fcntl_getlease - Enquire what lease is currently active&n; *&t;@filp: the file&n; *&n; *&t;The value returned by this function will be one of&n; *&t;(if no lease break is pending):&n; *&n; *&t;%F_RDLCK to indicate a shared lease is held.&n; *&n; *&t;%F_WRLCK to indicate an exclusive lease is held.&n; *&n; *&t;%F_UNLCK to indicate no lease is held.&n; *&n; *&t;(if a lease break is pending):&n; *&n; *&t;%F_RDLCK to indicate an exclusive lease needs to be&n; *&t;&t;changed to a shared lease (or removed).&n; *&n; *&t;%F_UNLCK to indicate the lease needs to be removed.&n; *&n; *&t;XXX: sfr &amp; willy disagree over whether F_INPROGRESS&n; *&t;should be returned to userspace.&n; */
DECL|function|fcntl_getlease
r_int
id|fcntl_getlease
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|type
op_assign
id|F_UNLCK
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|time_out_leases
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock
suffix:semicolon
id|fl
op_logical_and
id|IS_LEASE
c_func
(paren
id|fl
)paren
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_file
op_eq
id|filp
)paren
(brace
id|type
op_assign
id|fl-&gt;fl_type
op_amp
op_complement
id|F_INPROGRESS
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|type
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fcntl_setlease&t;-&t;sets a lease on an open file&n; *&t;@fd: open file descriptor&n; *&t;@filp: file pointer&n; *&t;@arg: type of lease to obtain&n; *&n; *&t;Call this fcntl to establish a lease on the file.&n; *&t;Note that you also need to call %F_SETSIG to&n; *&t;receive a signal when the lease is broken.&n; */
DECL|function|fcntl_setlease
r_int
id|fcntl_setlease
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|arg
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
comma
op_star
op_star
id|before
comma
op_star
op_star
id|my_before
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
comma
id|rdlease_count
op_assign
l_int|0
comma
id|wrlease_count
op_assign
l_int|0
suffix:semicolon
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;fsuid
op_ne
id|inode-&gt;i_uid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_LEASE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|error
op_assign
id|security_file_lock
c_func
(paren
id|filp
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|time_out_leases
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: What about F_RDLCK and files open for writing?&n;&t; */
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
op_eq
id|F_WRLCK
)paren
op_logical_and
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
OG
l_int|1
)paren
op_logical_or
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
)paren
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/*&n;&t; * At this point, we know that if there is an exclusive&n;&t; * lease on this file, then we hold it on this filp&n;&t; * (otherwise our open of this file would have blocked).&n;&t; * And if we are trying to acquire an exclusive lease,&n;&t; * then the file is not open by anyone (including us)&n;&t; * except for this filp.&n;&t; */
r_for
c_loop
(paren
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
op_logical_and
id|IS_LEASE
c_func
(paren
id|fl
)paren
suffix:semicolon
id|before
op_assign
op_amp
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_file
op_eq
id|filp
)paren
id|my_before
op_assign
id|before
suffix:semicolon
r_else
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_eq
(paren
id|F_INPROGRESS
op_or
id|F_UNLCK
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; * Someone is in the process of opening this&n;&t;&t;&t; * file for writing so we may not take an&n;&t;&t;&t; * exclusive lease on it.&n;&t;&t;&t; */
id|wrlease_count
op_increment
suffix:semicolon
r_else
id|rdlease_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|arg
op_eq
id|F_RDLCK
op_logical_and
(paren
id|wrlease_count
OG
l_int|0
)paren
)paren
op_logical_or
(paren
id|arg
op_eq
id|F_WRLCK
op_logical_and
(paren
(paren
id|rdlease_count
op_plus
id|wrlease_count
)paren
OG
l_int|0
)paren
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
id|my_before
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
id|lease_modify
c_func
(paren
id|my_before
comma
id|arg
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|F_UNLCK
)paren
r_goto
id|out_unlock
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|leases_enable
)paren
r_goto
id|out_unlock
suffix:semicolon
id|error
op_assign
id|lease_alloc
c_func
(paren
id|filp
comma
id|arg
comma
op_amp
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_unlock
suffix:semicolon
id|error
op_assign
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
l_int|1
comma
op_amp
id|fl-&gt;fl_fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|locks_free_lock
c_func
(paren
id|fl
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|locks_insert_lock
c_func
(paren
id|before
comma
id|fl
)paren
suffix:semicolon
id|error
op_assign
id|f_setown
c_func
(paren
id|filp
comma
id|current-&gt;pid
comma
l_int|0
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sys_flock: - flock() system call.&n; *&t;@fd: the file descriptor to lock.&n; *&t;@cmd: the type of lock to apply.&n; *&n; *&t;Apply a %FL_FLOCK style lock to an open file descriptor.&n; *&t;The @cmd can be one of&n; *&n; *&t;%LOCK_SH -- a shared lock.&n; *&n; *&t;%LOCK_EX -- an exclusive lock.&n; *&n; *&t;%LOCK_UN -- remove an existing lock.&n; *&n; *&t;%LOCK_MAND -- a `mandatory&squot; flock.  This exists to emulate Windows Share Modes.&n; *&n; *&t;%LOCK_MAND can be combined with %LOCK_READ or %LOCK_WRITE to allow other&n; *&t;processes read and write access respectively.&n; */
DECL|function|sys_flock
id|asmlinkage
r_int
id|sys_flock
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|lock
suffix:semicolon
r_int
id|can_sleep
comma
id|unlock
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|can_sleep
op_assign
op_logical_neg
(paren
id|cmd
op_amp
id|LOCK_NB
)paren
suffix:semicolon
id|cmd
op_and_assign
op_complement
id|LOCK_NB
suffix:semicolon
id|unlock
op_assign
(paren
id|cmd
op_eq
id|LOCK_UN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unlock
op_logical_and
op_logical_neg
(paren
id|cmd
op_amp
id|LOCK_MAND
)paren
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
id|error
op_assign
id|flock_make_lock
c_func
(paren
id|filp
comma
op_amp
id|lock
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_putf
suffix:semicolon
r_if
c_cond
(paren
id|can_sleep
)paren
id|lock-&gt;fl_flags
op_or_assign
id|FL_SLEEP
suffix:semicolon
id|error
op_assign
id|security_file_lock
c_func
(paren
id|filp
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_free
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|error
op_assign
id|flock_lock_file
c_func
(paren
id|filp
comma
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_ne
op_minus
id|EAGAIN
)paren
op_logical_or
op_logical_neg
id|can_sleep
)paren
r_break
suffix:semicolon
id|error
op_assign
id|wait_event_interruptible
c_func
(paren
id|lock-&gt;fl_wait
comma
op_logical_neg
id|lock-&gt;fl_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_continue
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out_free
suffix:colon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|lock-&gt;fl_link
)paren
)paren
(brace
id|locks_free_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Report the first existing lock that would conflict with l.&n; * This implements the F_GETLK command of fcntl().&n; */
DECL|function|fcntl_getlk
r_int
id|fcntl_getlk
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|flock
id|__user
op_star
id|l
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flock.l_type
op_ne
id|F_RDLCK
)paren
op_logical_and
(paren
id|flock.l_type
op_ne
id|F_WRLCK
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|flock_to_posix_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|F_GETLK
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_else
r_if
c_cond
(paren
id|error
op_eq
id|LOCK_USE_CLNT
)paren
multiline_comment|/* Bypass for NFS with no locking - 2.0.36 compat */
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_else
id|fl
op_assign
(paren
id|file_lock.fl_type
op_eq
id|F_UNLCK
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
id|flock.l_type
op_assign
id|F_UNLCK
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_ne
l_int|NULL
)paren
(brace
id|flock.l_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
macro_line|#if BITS_PER_LONG == 32
multiline_comment|/*&n;&t;&t; * Make sure we can represent the posix lock via&n;&t;&t; * legacy 32bit flock.&n;&t;&t; */
id|error
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|OFFT_OFFSET_MAX
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_end
op_ne
id|OFFSET_MAX
)paren
op_logical_and
(paren
id|fl-&gt;fl_end
OG
id|OFFT_OFFSET_MAX
)paren
)paren
r_goto
id|out
suffix:semicolon
macro_line|#endif
id|flock.l_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|flock.l_len
op_assign
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
ques
c_cond
l_int|0
suffix:colon
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|flock.l_whence
op_assign
l_int|0
suffix:semicolon
id|flock.l_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Apply the lock described by l to an open file descriptor.&n; * This implements both the F_SETLK and F_SETLKW commands of fcntl().&n; */
DECL|function|fcntl_setlk
r_int
id|fcntl_setlk
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_struct
id|flock
id|__user
op_star
id|l
)paren
(brace
r_struct
id|file_lock
op_star
id|file_lock
op_assign
id|locks_alloc_lock
c_func
(paren
)paren
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|file_lock
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOLCK
suffix:semicolon
multiline_comment|/*&n;&t; * This might block, so we do it before checking the inode.&n;&t; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* Don&squot;t allow mandatory locks on files that may be memory mapped&n;&t; * and shared.&n;&t; */
r_if
c_cond
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|filp-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_shared
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|error
op_assign
id|flock_to_posix_lock
c_func
(paren
id|filp
comma
id|file_lock
comma
op_amp
id|flock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|F_SETLKW
)paren
(brace
id|file_lock-&gt;fl_flags
op_or_assign
id|FL_SLEEP
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|flock.l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_UNLCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|security_file_lock
c_func
(paren
id|filp
comma
id|file_lock-&gt;fl_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|cmd
comma
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|error
op_assign
id|__posix_lock_file
c_func
(paren
id|inode
comma
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_ne
op_minus
id|EAGAIN
)paren
op_logical_or
(paren
id|cmd
op_eq
id|F_SETLK
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
id|wait_event_interruptible
c_func
(paren
id|file_lock-&gt;fl_wait
comma
op_logical_neg
id|file_lock-&gt;fl_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_continue
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|file_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|locks_free_lock
c_func
(paren
id|file_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#if BITS_PER_LONG == 32
multiline_comment|/* Report the first existing lock that would conflict with l.&n; * This implements the F_GETLK command of fcntl().&n; */
DECL|function|fcntl_getlk64
r_int
id|fcntl_getlk64
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|flock64
id|__user
op_star
id|l
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_struct
id|flock64
id|flock
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flock.l_type
op_ne
id|F_RDLCK
)paren
op_logical_and
(paren
id|flock.l_type
op_ne
id|F_WRLCK
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|flock64_to_posix_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|F_GETLK
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_else
r_if
c_cond
(paren
id|error
op_eq
id|LOCK_USE_CLNT
)paren
multiline_comment|/* Bypass for NFS with no locking - 2.0.36 compat */
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_else
id|fl
op_assign
(paren
id|file_lock.fl_type
op_eq
id|F_UNLCK
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
id|flock.l_type
op_assign
id|F_UNLCK
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_ne
l_int|NULL
)paren
(brace
id|flock.l_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
id|flock.l_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|flock.l_len
op_assign
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
ques
c_cond
l_int|0
suffix:colon
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|flock.l_whence
op_assign
l_int|0
suffix:semicolon
id|flock.l_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Apply the lock described by l to an open file descriptor.&n; * This implements both the F_SETLK and F_SETLKW commands of fcntl().&n; */
DECL|function|fcntl_setlk64
r_int
id|fcntl_setlk64
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_struct
id|flock64
id|__user
op_star
id|l
)paren
(brace
r_struct
id|file_lock
op_star
id|file_lock
op_assign
id|locks_alloc_lock
c_func
(paren
)paren
suffix:semicolon
r_struct
id|flock64
id|flock
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|file_lock
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOLCK
suffix:semicolon
multiline_comment|/*&n;&t; * This might block, so we do it before checking the inode.&n;&t; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* Don&squot;t allow mandatory locks on files that may be memory mapped&n;&t; * and shared.&n;&t; */
r_if
c_cond
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|filp-&gt;f_mapping
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|mapping-&gt;i_mmap_shared
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|error
op_assign
id|flock64_to_posix_lock
c_func
(paren
id|filp
comma
id|file_lock
comma
op_amp
id|flock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|F_SETLKW64
)paren
(brace
id|file_lock-&gt;fl_flags
op_or_assign
id|FL_SLEEP
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|flock.l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_UNLCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|security_file_lock
c_func
(paren
id|filp
comma
id|file_lock-&gt;fl_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|cmd
comma
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|error
op_assign
id|__posix_lock_file
c_func
(paren
id|inode
comma
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_ne
op_minus
id|EAGAIN
)paren
op_logical_or
(paren
id|cmd
op_eq
id|F_SETLK64
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
id|wait_event_interruptible
c_func
(paren
id|file_lock-&gt;fl_wait
comma
op_logical_neg
id|file_lock-&gt;fl_next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
r_continue
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|file_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|locks_free_lock
c_func
(paren
id|file_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif /* BITS_PER_LONG == 32 */
multiline_comment|/*&n; * This function is called when the file is being removed&n; * from the task&squot;s fd array.  POSIX locks belonging to this task&n; * are deleted at this time.&n; */
DECL|function|locks_remove_posix
r_void
id|locks_remove_posix
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|fl_owner_t
id|owner
)paren
(brace
r_struct
id|file_lock
id|lock
comma
op_star
op_star
id|before
suffix:semicolon
multiline_comment|/*&n;&t; * If there are no locks held on this file, we don&squot;t need to call&n;&t; * posix_lock_file().  Another process could be setting a lock on this&n;&t; * file at the same time, but we wouldn&squot;t remove that lock anyway.&n;&t; */
id|before
op_assign
op_amp
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
op_star
id|before
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|lock.fl_type
op_assign
id|F_UNLCK
suffix:semicolon
id|lock.fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|lock.fl_start
op_assign
l_int|0
suffix:semicolon
id|lock.fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|lock.fl_owner
op_assign
id|owner
suffix:semicolon
id|lock.fl_pid
op_assign
id|current-&gt;tgid
suffix:semicolon
id|lock.fl_file
op_assign
id|filp
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
op_ne
l_int|NULL
)paren
(brace
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|F_SETLK
comma
op_amp
id|lock
)paren
suffix:semicolon
multiline_comment|/* Ignore any error -- we must remove the locks anyway */
)brace
multiline_comment|/* Can&squot;t use posix_lock_file here; we need to remove it no matter&n;&t; * which pid we have.&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|before
op_ne
l_int|NULL
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|before
suffix:semicolon
r_if
c_cond
(paren
id|IS_POSIX
c_func
(paren
id|fl
)paren
op_logical_and
(paren
id|fl-&gt;fl_owner
op_eq
id|owner
)paren
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|locks_remove_posix
id|EXPORT_SYMBOL
c_func
(paren
id|locks_remove_posix
)paren
suffix:semicolon
multiline_comment|/*&n; * This function is called on the last close of an open file.&n; */
DECL|function|locks_remove_flock
r_void
id|locks_remove_flock
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_flock
)paren
r_return
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_file
op_eq
id|filp
)paren
(brace
r_if
c_cond
(paren
id|IS_FLOCK
c_func
(paren
id|fl
)paren
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_LEASE
c_func
(paren
id|fl
)paren
)paren
(brace
id|lease_modify
c_func
(paren
id|before
comma
id|F_UNLCK
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;posix_block_lock - blocks waiting for a file lock&n; *&t;@blocker: the lock which is blocking&n; *&t;@waiter: the lock which conflicts and has to wait&n; *&n; * lockd needs to block waiting for locks.&n; */
r_void
DECL|function|posix_block_lock
id|posix_block_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
id|locks_insert_block
c_func
(paren
id|blocker
comma
id|waiter
)paren
suffix:semicolon
)brace
DECL|variable|posix_block_lock
id|EXPORT_SYMBOL
c_func
(paren
id|posix_block_lock
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;posix_unblock_lock - stop waiting for a file lock&n; *      @filp:   how the file was opened&n; *&t;@waiter: the lock which was waiting&n; *&n; *&t;lockd needs to block waiting for locks.&n; */
r_void
DECL|function|posix_unblock_lock
id|posix_unblock_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
multiline_comment|/* &n;&t; * A remote machine may cancel the lock request after it&squot;s been&n;&t; * granted locally.  If that happens, we need to delete the lock.&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waiter-&gt;fl_next
)paren
(brace
id|__locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|waiter-&gt;fl_type
op_assign
id|F_UNLCK
suffix:semicolon
id|posix_lock_file
c_func
(paren
id|filp
comma
id|waiter
)paren
suffix:semicolon
)brace
)brace
DECL|variable|posix_unblock_lock
id|EXPORT_SYMBOL
c_func
(paren
id|posix_unblock_lock
)paren
suffix:semicolon
DECL|function|lock_get_status
r_static
r_void
id|lock_get_status
c_func
(paren
r_char
op_star
id|out
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_int
id|id
comma
r_char
op_star
id|pfx
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_file
op_ne
l_int|NULL
)paren
id|inode
op_assign
id|fl-&gt;fl_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%d:%s &quot;
comma
id|id
comma
id|pfx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%6s %s &quot;
comma
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_ACCESS
)paren
ques
c_cond
l_string|&quot;ACCESS&quot;
suffix:colon
l_string|&quot;POSIX &quot;
comma
(paren
id|inode
op_eq
l_int|NULL
)paren
ques
c_cond
l_string|&quot;*NOINODE*&quot;
suffix:colon
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_IXGRP
op_or
id|S_ISGID
)paren
)paren
op_eq
id|S_ISGID
)paren
ques
c_cond
l_string|&quot;MANDATORY&quot;
suffix:colon
l_string|&quot;ADVISORY &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_FLOCK
c_func
(paren
id|fl
)paren
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;FLOCK  MSNFS     &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;FLOCK  ADVISORY  &quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IS_LEASE
c_func
(paren
id|fl
)paren
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;LEASE  &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|F_INPROGRESS
)paren
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;BREAKING  &quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|fl-&gt;fl_file
)paren
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;ACTIVE    &quot;
)paren
suffix:semicolon
r_else
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;BREAKER   &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;UNKNOWN UNKNOWN  &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%s &quot;
comma
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_READ
)paren
ques
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_WRITE
)paren
ques
c_cond
l_string|&quot;RW   &quot;
suffix:colon
l_string|&quot;READ &quot;
suffix:colon
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_WRITE
)paren
ques
c_cond
l_string|&quot;WRITE&quot;
suffix:colon
l_string|&quot;NONE &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%s &quot;
comma
(paren
id|fl-&gt;fl_type
op_amp
id|F_INPROGRESS
)paren
ques
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|F_UNLCK
)paren
ques
c_cond
l_string|&quot;UNLCK&quot;
suffix:colon
l_string|&quot;READ &quot;
suffix:colon
(paren
id|fl-&gt;fl_type
op_amp
id|F_WRLCK
)paren
ques
c_cond
l_string|&quot;WRITE&quot;
suffix:colon
l_string|&quot;READ &quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode
)paren
(brace
macro_line|#if WE_CAN_BREAK_LSLK_NOW
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%d %s:%ld &quot;
comma
id|fl-&gt;fl_pid
comma
id|inode-&gt;i_sb-&gt;s_id
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* userspace relies on this representation of dev_t ;-( */
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%d %02x:%02x:%ld &quot;
comma
id|fl-&gt;fl_pid
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_sb-&gt;s_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_sb-&gt;s_dev
)paren
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%d &lt;none&gt;:0 &quot;
comma
id|fl-&gt;fl_pid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
)paren
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%Ld EOF&bslash;n&quot;
comma
id|fl-&gt;fl_start
)paren
suffix:semicolon
r_else
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%Ld %Ld&bslash;n&quot;
comma
id|fl-&gt;fl_start
comma
id|fl-&gt;fl_end
)paren
suffix:semicolon
)brace
r_else
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;0 EOF&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|move_lock_status
r_static
r_void
id|move_lock_status
c_func
(paren
r_char
op_star
op_star
id|p
comma
id|off_t
op_star
id|pos
comma
id|off_t
id|offset
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|offset
)paren
(brace
multiline_comment|/* the complete line is valid */
op_star
id|p
op_add_assign
id|len
suffix:semicolon
op_star
id|pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pos
op_plus
id|len
OG
id|offset
)paren
(brace
multiline_comment|/* use the second part of the line */
r_int
id|i
op_assign
id|offset
op_minus
op_star
id|pos
suffix:semicolon
id|memmove
c_func
(paren
op_star
id|p
comma
op_star
id|p
op_plus
id|i
comma
id|len
op_minus
id|i
)paren
suffix:semicolon
op_star
id|p
op_add_assign
id|len
op_minus
id|i
suffix:semicolon
op_star
id|pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* discard the complete line */
op_star
id|pos
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;get_locks_status&t;-&t;reports lock usage in /proc/locks&n; *&t;@buffer: address in userspace to write into&n; *&t;@start: ?&n; *&t;@offset: how far we are through the buffer&n; *&t;@length: how much to read&n; */
DECL|function|get_locks_status
r_int
id|get_locks_status
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_char
op_star
id|q
op_assign
id|buffer
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|file_lock_list
)paren
(brace
r_struct
id|list_head
op_star
id|btmp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|file_lock
comma
id|fl_link
)paren
suffix:semicolon
id|lock_get_status
c_func
(paren
id|q
comma
id|fl
comma
op_increment
id|i
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|move_lock_status
c_func
(paren
op_amp
id|q
comma
op_amp
id|pos
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|btmp
comma
op_amp
id|fl-&gt;fl_block
)paren
(brace
r_struct
id|file_lock
op_star
id|bfl
op_assign
id|list_entry
c_func
(paren
id|btmp
comma
r_struct
id|file_lock
comma
id|fl_block
)paren
suffix:semicolon
id|lock_get_status
c_func
(paren
id|q
comma
id|bfl
comma
id|i
comma
l_string|&quot; -&gt;&quot;
)paren
suffix:semicolon
id|move_lock_status
c_func
(paren
op_amp
id|q
comma
op_amp
id|pos
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
)brace
)brace
id|done
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|q
op_minus
id|buffer
OL
id|length
)paren
(brace
r_return
(paren
id|q
op_minus
id|buffer
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;lock_may_read - checks that the region is free of locks&n; *&t;@inode: the inode that is being read&n; *&t;@start: the first byte to read&n; *&t;@len: the number of bytes to read&n; *&n; *&t;Emulates Windows locking requirements.  Whole-file&n; *&t;mandatory locks (share modes) can prohibit a read and&n; *&t;byte-range POSIX locks can prohibit a read if they overlap.&n; *&n; *&t;N.B. this function is only ever called&n; *&t;from knfsd and ownership of locks is never checked.&n; */
DECL|function|lock_may_read
r_int
id|lock_may_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|start
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|result
op_assign
l_int|1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_eq
id|F_RDLCK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_end
OL
id|start
)paren
op_logical_or
(paren
id|fl-&gt;fl_start
OG
(paren
id|start
op_plus
id|len
)paren
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_FLOCK
c_func
(paren
id|fl
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_READ
)paren
r_continue
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|variable|lock_may_read
id|EXPORT_SYMBOL
c_func
(paren
id|lock_may_read
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;lock_may_write - checks that the region is free of locks&n; *&t;@inode: the inode that is being written&n; *&t;@start: the first byte to write&n; *&t;@len: the number of bytes to write&n; *&n; *&t;Emulates Windows locking requirements.  Whole-file&n; *&t;mandatory locks (share modes) can prohibit a write and&n; *&t;byte-range POSIX locks can prohibit a write if they overlap.&n; *&n; *&t;N.B. this function is only ever called&n; *&t;from knfsd and ownership of locks is never checked.&n; */
DECL|function|lock_may_write
r_int
id|lock_may_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|start
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|result
op_assign
l_int|1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|IS_POSIX
c_func
(paren
id|fl
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_end
OL
id|start
)paren
op_logical_or
(paren
id|fl-&gt;fl_start
OG
(paren
id|start
op_plus
id|len
)paren
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_FLOCK
c_func
(paren
id|fl
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_WRITE
)paren
r_continue
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|variable|lock_may_write
id|EXPORT_SYMBOL
c_func
(paren
id|lock_may_write
)paren
suffix:semicolon
DECL|function|steal_locks
r_void
id|steal_locks
c_func
(paren
id|fl_owner_t
id|from
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|from
op_eq
id|current-&gt;files
)paren
r_return
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|file_lock_list
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|file_lock
comma
id|fl_link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
id|from
)paren
id|fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|steal_locks
id|EXPORT_SYMBOL
c_func
(paren
id|steal_locks
)paren
suffix:semicolon
DECL|function|filelock_init
r_static
r_int
id|__init
id|filelock_init
c_func
(paren
r_void
)paren
(brace
id|filelock_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;file_lock_cache&quot;
comma
r_sizeof
(paren
r_struct
id|file_lock
)paren
comma
l_int|0
comma
l_int|0
comma
id|init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filelock_cache
)paren
id|panic
c_func
(paren
l_string|&quot;cannot create file lock slab cache&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|filelock_init
)paren
eof
