multiline_comment|/*&n; * linux/fs/journal.c&n; *&n; * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1998&n; *&n; * Copyright 1998 Red Hat corp --- All Rights Reserved&n; *&n; * This file is part of the Linux kernel and is made available under&n; * the terms of the GNU General Public License, version 2, or at your&n; * option, any later version, incorporated herein by reference.&n; *&n; * Generic filesystem journal-writing code; part of the ext2fs&n; * journaling system.&n; *&n; * This file manages journals: areas of disk reserved for logging&n; * transactional updates.  This includes the kernel journaling thread&n; * which is responsible for scheduling updates to the log.&n; *&n; * We do not actually manage the physical storage of the journal in this&n; * file: that is left to a per-journal policy function, which allows us&n; * to store the journal within a filesystem-specified area for ext2&n; * journaling (ext2 can use a reserved inode for storing the log).&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/jbd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
DECL|variable|journal_start
id|EXPORT_SYMBOL
c_func
(paren
id|journal_start
)paren
suffix:semicolon
DECL|variable|journal_try_start
id|EXPORT_SYMBOL
c_func
(paren
id|journal_try_start
)paren
suffix:semicolon
DECL|variable|journal_restart
id|EXPORT_SYMBOL
c_func
(paren
id|journal_restart
)paren
suffix:semicolon
DECL|variable|journal_extend
id|EXPORT_SYMBOL
c_func
(paren
id|journal_extend
)paren
suffix:semicolon
DECL|variable|journal_stop
id|EXPORT_SYMBOL
c_func
(paren
id|journal_stop
)paren
suffix:semicolon
DECL|variable|journal_lock_updates
id|EXPORT_SYMBOL
c_func
(paren
id|journal_lock_updates
)paren
suffix:semicolon
DECL|variable|journal_unlock_updates
id|EXPORT_SYMBOL
c_func
(paren
id|journal_unlock_updates
)paren
suffix:semicolon
DECL|variable|journal_get_write_access
id|EXPORT_SYMBOL
c_func
(paren
id|journal_get_write_access
)paren
suffix:semicolon
DECL|variable|journal_get_create_access
id|EXPORT_SYMBOL
c_func
(paren
id|journal_get_create_access
)paren
suffix:semicolon
DECL|variable|journal_get_undo_access
id|EXPORT_SYMBOL
c_func
(paren
id|journal_get_undo_access
)paren
suffix:semicolon
DECL|variable|journal_dirty_data
id|EXPORT_SYMBOL
c_func
(paren
id|journal_dirty_data
)paren
suffix:semicolon
DECL|variable|journal_dirty_metadata
id|EXPORT_SYMBOL
c_func
(paren
id|journal_dirty_metadata
)paren
suffix:semicolon
macro_line|#if 0
id|EXPORT_SYMBOL
c_func
(paren
id|journal_release_buffer
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|journal_forget
id|EXPORT_SYMBOL
c_func
(paren
id|journal_forget
)paren
suffix:semicolon
macro_line|#if 0
id|EXPORT_SYMBOL
c_func
(paren
id|journal_sync_buffer
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|journal_flush
id|EXPORT_SYMBOL
c_func
(paren
id|journal_flush
)paren
suffix:semicolon
DECL|variable|journal_revoke
id|EXPORT_SYMBOL
c_func
(paren
id|journal_revoke
)paren
suffix:semicolon
DECL|variable|journal_init_dev
id|EXPORT_SYMBOL
c_func
(paren
id|journal_init_dev
)paren
suffix:semicolon
DECL|variable|journal_init_inode
id|EXPORT_SYMBOL
c_func
(paren
id|journal_init_inode
)paren
suffix:semicolon
DECL|variable|journal_update_format
id|EXPORT_SYMBOL
c_func
(paren
id|journal_update_format
)paren
suffix:semicolon
DECL|variable|journal_check_used_features
id|EXPORT_SYMBOL
c_func
(paren
id|journal_check_used_features
)paren
suffix:semicolon
DECL|variable|journal_check_available_features
id|EXPORT_SYMBOL
c_func
(paren
id|journal_check_available_features
)paren
suffix:semicolon
DECL|variable|journal_set_features
id|EXPORT_SYMBOL
c_func
(paren
id|journal_set_features
)paren
suffix:semicolon
DECL|variable|journal_create
id|EXPORT_SYMBOL
c_func
(paren
id|journal_create
)paren
suffix:semicolon
DECL|variable|journal_load
id|EXPORT_SYMBOL
c_func
(paren
id|journal_load
)paren
suffix:semicolon
DECL|variable|journal_destroy
id|EXPORT_SYMBOL
c_func
(paren
id|journal_destroy
)paren
suffix:semicolon
DECL|variable|journal_recover
id|EXPORT_SYMBOL
c_func
(paren
id|journal_recover
)paren
suffix:semicolon
DECL|variable|journal_update_superblock
id|EXPORT_SYMBOL
c_func
(paren
id|journal_update_superblock
)paren
suffix:semicolon
DECL|variable|journal_abort
id|EXPORT_SYMBOL
c_func
(paren
id|journal_abort
)paren
suffix:semicolon
DECL|variable|journal_errno
id|EXPORT_SYMBOL
c_func
(paren
id|journal_errno
)paren
suffix:semicolon
DECL|variable|journal_ack_err
id|EXPORT_SYMBOL
c_func
(paren
id|journal_ack_err
)paren
suffix:semicolon
DECL|variable|journal_clear_err
id|EXPORT_SYMBOL
c_func
(paren
id|journal_clear_err
)paren
suffix:semicolon
DECL|variable|log_wait_commit
id|EXPORT_SYMBOL
c_func
(paren
id|log_wait_commit
)paren
suffix:semicolon
DECL|variable|log_start_commit
id|EXPORT_SYMBOL
c_func
(paren
id|log_start_commit
)paren
suffix:semicolon
DECL|variable|journal_wipe
id|EXPORT_SYMBOL
c_func
(paren
id|journal_wipe
)paren
suffix:semicolon
DECL|variable|journal_blocks_per_page
id|EXPORT_SYMBOL
c_func
(paren
id|journal_blocks_per_page
)paren
suffix:semicolon
DECL|variable|journal_flushpage
id|EXPORT_SYMBOL
c_func
(paren
id|journal_flushpage
)paren
suffix:semicolon
DECL|variable|journal_try_to_free_buffers
id|EXPORT_SYMBOL
c_func
(paren
id|journal_try_to_free_buffers
)paren
suffix:semicolon
DECL|variable|journal_bmap
id|EXPORT_SYMBOL
c_func
(paren
id|journal_bmap
)paren
suffix:semicolon
DECL|variable|journal_force_commit
id|EXPORT_SYMBOL
c_func
(paren
id|journal_force_commit
)paren
suffix:semicolon
r_static
r_int
id|journal_convert_superblock_v1
c_func
(paren
id|journal_t
op_star
comma
id|journal_superblock_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * journal_datalist_lock is used to protect data buffers:&n; *&n; *&t;bh-&gt;b_transaction&n; *&t;bh-&gt;b_tprev&n; *&t;bh-&gt;b_tnext&n; *&n; * journal_free_buffer() is called from journal_try_to_free_buffer(), and is&n; * async wrt everything else.&n; *&n; * It is also used for checkpoint data, also to protect against&n; * journal_try_to_free_buffer():&n; *&n; *&t;bh-&gt;b_cp_transaction&n; *&t;bh-&gt;b_cpnext&n; *&t;bh-&gt;b_cpprev&n; *&t;transaction-&gt;t_checkpoint_list&n; *&t;transaction-&gt;t_cpnext&n; *&t;transaction-&gt;t_cpprev&n; *&t;journal-&gt;j_checkpoint_transactions&n; *&n; * It is global at this time rather than per-journal because it&squot;s&n; * impossible for __journal_free_buffer to go from a buffer_head&n; * back to a journal_t unracily (well, not true.  Fix later)&n; *&n; *&n; * The `datalist&squot; and `checkpoint list&squot; functions are quite&n; * separate and we could use two spinlocks here.&n; *&n; * lru_list_lock nests inside journal_datalist_lock.&n; */
DECL|variable|journal_datalist_lock
id|spinlock_t
id|journal_datalist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * jh_splice_lock needs explantion.&n; *&n; * In a number of places we want to do things like:&n; *&n; *&t;if (buffer_jbd(bh) &amp;&amp; bh2jh(bh)-&gt;foo)&n; *&n; * This is racy on SMP, because another CPU could remove the journal_head&n; * in the middle of this expression.  We need locking.&n; *&n; * But we can greatly optimise the locking cost by testing BH_JBD&n; * outside the lock.  So, effectively:&n; *&n; *&t;ret = 0;&n; *&t;if (buffer_jbd(bh)) {&n; *&t;&t;spin_lock(&amp;jh_splice_lock);&n; *&t;&t;if (buffer_jbd(bh)) {&t; (* Still there? *)&n; *&t;&t;&t;ret = bh2jh(bh)-&gt;foo;&n; *&t;&t;}&n; *&t;&t;spin_unlock(&amp;jh_splice_lock);&n; *&t;}&n; *&t;return ret;&n; *&n; * Now, that protects us from races where another CPU can remove the&n; * journal_head.  But it doesn&squot;t defend us from the situation where another&n; * CPU can *add* a journal_head.  This is a correctness issue.  But it&squot;s not&n; * a problem because a) the calling code was *already* racy and b) it often&n; * can&squot;t happen at the call site and c) the places where we add journal_heads&n; * tend to be under external locking.&n; */
DECL|variable|jh_splice_lock
id|spinlock_t
id|jh_splice_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * List of all journals in the system.  Protected by the BKL.&n; */
r_static
id|LIST_HEAD
c_func
(paren
id|all_journals
)paren
suffix:semicolon
multiline_comment|/*&n; * Helper function used to manage commit timeouts&n; */
DECL|function|commit_timeout
r_static
r_void
id|commit_timeout
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Static check for data structure consistency.  There&squot;s no code&n; * invoked --- we&squot;ll just get a linker failure if things aren&squot;t right.&n; */
DECL|function|__journal_internal_check
r_void
id|__journal_internal_check
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
id|journal_bad_superblock_size
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|journal_superblock_s
)paren
op_ne
l_int|1024
)paren
id|journal_bad_superblock_size
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * kjournald: The main thread function used to manage a logging device&n; * journal.&n; *&n; * This kernel thread is responsible for two things:&n; *&n; * 1) COMMIT:  Every so often we need to commit the current state of the&n; *    filesystem to disk.  The journal thread is responsible for writing&n; *    all of the metadata buffers to disk.&n; *&n; * 2) CHECKPOINT: We cannot reuse a used section of the log file until all&n; *    of the data in that part of the log has been rewritten elsewhere on&n; *    the disk.  Flushing these old buffers to reclaim space in the log is&n; *    known as checkpointing, and this thread is responsible for that job.&n; */
DECL|variable|current_journal
id|journal_t
op_star
id|current_journal
suffix:semicolon
singleline_comment|// AKPM: debug
DECL|function|kjournald
r_int
id|kjournald
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
(paren
id|journal_t
op_star
)paren
id|arg
suffix:semicolon
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_struct
id|timer_list
id|timer
suffix:semicolon
id|current_journal
op_assign
id|journal
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|daemonize
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kjournald&quot;
)paren
suffix:semicolon
multiline_comment|/* Set up an interval timer which can be used to trigger a&n;           commit wakeup after the commit interval expires */
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|timer.function
op_assign
id|commit_timeout
suffix:semicolon
id|journal-&gt;j_commit_timer
op_assign
op_amp
id|timer
suffix:semicolon
multiline_comment|/* Record that the journal thread is running */
id|journal-&gt;j_task
op_assign
id|current
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;kjournald starting.  Commit interval %ld seconds&bslash;n&quot;
comma
id|journal-&gt;j_commit_interval
op_div
id|HZ
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|journal-&gt;j_all_journals
comma
op_amp
id|all_journals
)paren
suffix:semicolon
multiline_comment|/* And now, wait forever for commit wakeup events. */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_UNMOUNT
)paren
r_break
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;commit_sequence=%d, commit_request=%d&bslash;n&quot;
comma
id|journal-&gt;j_commit_sequence
comma
id|journal-&gt;j_commit_request
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_commit_sequence
op_ne
id|journal-&gt;j_commit_request
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;OK, requests differ&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_commit_timer_active
)paren
(brace
id|journal-&gt;j_commit_timer_active
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
id|journal-&gt;j_commit_timer
)paren
suffix:semicolon
)brace
id|journal_commit_transaction
c_func
(paren
id|journal
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_commit
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;kjournald wakes&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Were we woken up by a commit wakeup event? */
r_if
c_cond
(paren
(paren
id|transaction
op_assign
id|journal-&gt;j_running_transaction
)paren
op_ne
l_int|NULL
op_logical_and
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|transaction-&gt;t_expires
)paren
)paren
(brace
id|journal-&gt;j_commit_request
op_assign
id|transaction-&gt;t_tid
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;woke because of timeout&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|journal-&gt;j_commit_timer_active
)paren
(brace
id|journal-&gt;j_commit_timer_active
op_assign
l_int|0
suffix:semicolon
id|del_timer_sync
c_func
(paren
id|journal-&gt;j_commit_timer
)paren
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|journal-&gt;j_all_journals
)paren
suffix:semicolon
id|journal-&gt;j_task
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;Journal thread exiting.&bslash;n&quot;
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|journal_start_thread
r_static
r_void
id|journal_start_thread
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|kernel_thread
c_func
(paren
id|kjournald
comma
(paren
r_void
op_star
)paren
id|journal
comma
id|CLONE_VM
op_or
id|CLONE_FS
op_or
id|CLONE_FILES
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|journal-&gt;j_task
)paren
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
)brace
DECL|function|journal_kill_thread
r_static
r_void
id|journal_kill_thread
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|journal-&gt;j_flags
op_or_assign
id|JFS_UNMOUNT
suffix:semicolon
r_while
c_loop
(paren
id|journal-&gt;j_task
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_commit
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|This
id|is
id|no
id|longer
id|needed
op_minus
id|we
r_do
id|it
id|in
id|commit
id|quite
id|efficiently
dot
id|Note
id|that
r_if
c_cond
id|this
id|function
id|is
id|resurrected
comma
id|the
id|loop
id|needs
id|to
id|be
id|reorganised
id|into
id|the
id|next_jh
op_div
id|last_jh
id|algorithm
dot
multiline_comment|/*&n; * journal_clean_data_list: cleanup after data IO.&n; *&n; * Once the IO system has finished writing the buffers on the transaction&squot;s&n; * data list, we can remove those buffers from the list.  This function&n; * scans the list for such buffers and removes them cleanly.&n; *&n; * We assume that the journal is already locked.&n; * We are called with journal_datalist_lock held.&n; *&n; * AKPM: This function looks inefficient.  Approximately O(n^2)&n; * for potentially thousands of buffers.  It no longer shows on profiles&n; * because these buffers are mainly dropped in journal_commit_transaction().&n; */
r_void
id|__journal_clean_data_list
c_func
(paren
id|transaction_t
op_star
id|transaction
)paren
(brace
r_struct
id|journal_head
op_star
id|jh
comma
op_star
id|next
suffix:semicolon
id|assert_spin_locked
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|restart
suffix:colon
id|jh
op_assign
id|transaction-&gt;t_sync_datalist
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jh
)paren
r_goto
id|out
suffix:semicolon
r_do
(brace
id|next
op_assign
id|jh-&gt;b_tnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
op_logical_and
op_logical_neg
id|buffer_dirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;data writeout complete: unfile&quot;
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
l_int|NULL
suffix:semicolon
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|jh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|transaction-&gt;t_sync_datalist
op_logical_and
id|jh
op_ne
id|transaction-&gt;t_sync_datalist
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * journal_write_metadata_buffer: write a metadata buffer to the journal.&n; *&n; * Writes a metadata buffer to a given disk block.  The actual IO is not&n; * performed but a new buffer_head is constructed which labels the data&n; * to be written with the correct destination disk block.&n; *&n; * Any magic-number escaping which needs to be done will cause a&n; * copy-out here.  If the buffer happens to start with the&n; * JFS_MAGIC_NUMBER, then we can&squot;t write it to the log directly: the&n; * magic number is only written to the log for descripter blocks.  In&n; * this case, we copy the data and replace the first word with 0, and we&n; * return a result code which indicates that this buffer needs to be&n; * marked as an escaped buffer in the corresponding log descriptor&n; * block.  The missing word can then be restored when the block is read&n; * during recovery.&n; *&n; * If the source buffer has already been modified by a new transaction&n; * since we took the last commit snapshot, we use the frozen copy of&n; * that data for IO.  If we end up using the existing buffer_head&squot;s data&n; * for the write, then we *have* to lock the buffer to prevent anyone&n; * else from using and possibly modifying it while the IO is in&n; * progress.&n; *&n; * The function returns a pointer to the buffer_heads to be used for IO.&n; *&n; * We assume that the journal has already been locked in this function.&n; *&n; * Return value:&n; *  &lt;0: Error&n; * &gt;=0: Finished OK&n; *&n; * On success:&n; * Bit 0 set == escape performed on the data&n; * Bit 1 set == buffer copy-out performed (kfree the data after IO)&n; */
DECL|function|virt_to_offset
r_static
r_inline
r_int
r_int
id|virt_to_offset
c_func
(paren
r_void
op_star
id|p
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|p
)paren
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
)brace
DECL|function|journal_write_metadata_buffer
r_int
id|journal_write_metadata_buffer
c_func
(paren
id|transaction_t
op_star
id|transaction
comma
r_struct
id|journal_head
op_star
id|jh_in
comma
r_struct
id|journal_head
op_star
op_star
id|jh_out
comma
r_int
id|blocknr
)paren
(brace
r_int
id|need_copy_out
op_assign
l_int|0
suffix:semicolon
r_int
id|done_copy_out
op_assign
l_int|0
suffix:semicolon
r_int
id|do_escape
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|mapped_data
suffix:semicolon
r_struct
id|buffer_head
op_star
id|new_bh
suffix:semicolon
r_struct
id|journal_head
op_star
id|new_jh
suffix:semicolon
r_struct
id|page
op_star
id|new_page
suffix:semicolon
r_int
r_int
id|new_offset
suffix:semicolon
multiline_comment|/*&n;&t; * The buffer really shouldn&squot;t be locked: only the current committing&n;&t; * transaction is allowed to write it, so nobody else is allowed&n;&t; * to do any IO.&n;&t; *&n;&t; * akpm: except if we&squot;re journalling data, and write() output is&n;&t; * also part of a shared mapping, and another thread has&n;&t; * decided to launch a writepage() against this buffer.&n;&t; */
id|J_ASSERT_JH
c_func
(paren
id|jh_in
comma
id|buffer_jdirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh_in
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If a new transaction has already done a buffer copy-out, then&n;&t; * we use that version of the data for the commit.&n;&t; */
r_if
c_cond
(paren
id|jh_in-&gt;b_frozen_data
)paren
(brace
id|done_copy_out
op_assign
l_int|1
suffix:semicolon
id|new_page
op_assign
id|virt_to_page
c_func
(paren
id|jh_in-&gt;b_frozen_data
)paren
suffix:semicolon
id|new_offset
op_assign
id|virt_to_offset
c_func
(paren
id|jh_in-&gt;b_frozen_data
)paren
suffix:semicolon
)brace
r_else
(brace
id|new_page
op_assign
id|jh2bh
c_func
(paren
id|jh_in
)paren
op_member_access_from_pointer
id|b_page
suffix:semicolon
id|new_offset
op_assign
id|virt_to_offset
c_func
(paren
id|jh2bh
c_func
(paren
id|jh_in
)paren
op_member_access_from_pointer
id|b_data
)paren
suffix:semicolon
)brace
id|mapped_data
op_assign
(paren
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|new_page
)paren
)paren
op_plus
id|new_offset
suffix:semicolon
multiline_comment|/*&n;&t; * Check for escaping&n;&t; */
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|mapped_data
)paren
op_eq
id|htonl
c_func
(paren
id|JFS_MAGIC_NUMBER
)paren
)paren
(brace
id|need_copy_out
op_assign
l_int|1
suffix:semicolon
id|do_escape
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Do we need to do a data copy?&n;&t; */
r_if
c_cond
(paren
id|need_copy_out
op_logical_and
op_logical_neg
id|done_copy_out
)paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|jbd_rep_kmalloc
c_func
(paren
id|jh2bh
c_func
(paren
id|jh_in
)paren
op_member_access_from_pointer
id|b_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
id|jh_in-&gt;b_frozen_data
op_assign
id|tmp
suffix:semicolon
id|memcpy
(paren
id|tmp
comma
id|mapped_data
comma
id|jh2bh
c_func
(paren
id|jh_in
)paren
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
multiline_comment|/* If we get to this path, we&squot;ll always need the new&n;&t;&t;   address kmapped so that we can clear the escaped&n;&t;&t;   magic number below. */
id|kunmap
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|new_page
op_assign
id|virt_to_page
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|new_offset
op_assign
id|virt_to_offset
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|mapped_data
op_assign
(paren
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|new_page
)paren
)paren
op_plus
id|new_offset
suffix:semicolon
id|done_copy_out
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Right, time to make up the new buffer_head.&n;&t; */
r_do
(brace
id|new_bh
op_assign
id|alloc_buffer_head
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_bh
)paren
(brace
id|printk
(paren
id|KERN_NOTICE
id|__FUNCTION__
l_string|&quot;: ENOMEM at alloc_buffer_head, &quot;
l_string|&quot;trying again.&bslash;n&quot;
)paren
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|new_bh
)paren
suffix:semicolon
multiline_comment|/* keep subsequent assertions sane */
id|new_bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|init_buffer
c_func
(paren
id|new_bh
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|new_bh-&gt;b_count
comma
l_int|1
)paren
suffix:semicolon
id|new_jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|set_bh_page
c_func
(paren
id|new_bh
comma
id|new_page
comma
id|new_offset
)paren
suffix:semicolon
id|new_jh-&gt;b_transaction
op_assign
l_int|NULL
suffix:semicolon
id|new_bh-&gt;b_size
op_assign
id|jh2bh
c_func
(paren
id|jh_in
)paren
op_member_access_from_pointer
id|b_size
suffix:semicolon
id|new_bh-&gt;b_bdev
op_assign
id|transaction-&gt;t_journal-&gt;j_dev
suffix:semicolon
id|new_bh-&gt;b_blocknr
op_assign
id|blocknr
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|new_bh
)paren
suffix:semicolon
id|set_buffer_dirty
c_func
(paren
id|new_bh
)paren
suffix:semicolon
op_star
id|jh_out
op_assign
id|new_jh
suffix:semicolon
multiline_comment|/*&n;&t; * Did we need to do an escaping?  Now we&squot;ve done all the&n;&t; * copying, we can finally do so.&n;&t; */
r_if
c_cond
(paren
id|do_escape
)paren
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|mapped_data
)paren
op_assign
l_int|0
suffix:semicolon
id|kunmap
c_func
(paren
id|new_page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The to-be-written buffer needs to get moved to the io queue,&n;&t; * and the original buffer whose contents we are shadowing or&n;&t; * copying is moved to the transaction&squot;s shadow queue.&n;&t; */
id|JBUFFER_TRACE
c_func
(paren
id|jh_in
comma
l_string|&quot;file as BJ_Shadow&quot;
)paren
suffix:semicolon
id|journal_file_buffer
c_func
(paren
id|jh_in
comma
id|transaction
comma
id|BJ_Shadow
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|new_jh
comma
l_string|&quot;file as BJ_IO&quot;
)paren
suffix:semicolon
id|journal_file_buffer
c_func
(paren
id|new_jh
comma
id|transaction
comma
id|BJ_IO
)paren
suffix:semicolon
r_return
id|do_escape
op_or
(paren
id|done_copy_out
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocation code for the journal file.  Manage the space left in the&n; * journal, so that we can begin checkpointing when appropriate.&n; */
multiline_comment|/*&n; * log_space_left: Return the number of free blocks left in the journal.&n; *&n; * Called with the journal already locked.&n; */
DECL|function|log_space_left
r_int
id|log_space_left
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_int
id|left
op_assign
id|journal-&gt;j_free
suffix:semicolon
multiline_comment|/* Be pessimistic here about the number of those free blocks&n;&t; * which might be required for log descriptor control blocks. */
DECL|macro|MIN_LOG_RESERVED_BLOCKS
mdefine_line|#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */
id|left
op_sub_assign
id|MIN_LOG_RESERVED_BLOCKS
suffix:semicolon
r_if
c_cond
(paren
id|left
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|left
op_sub_assign
(paren
id|left
op_rshift
l_int|3
)paren
suffix:semicolon
r_return
id|left
suffix:semicolon
)brace
multiline_comment|/*&n; * This function must be non-allocating for PF_MEMALLOC tasks&n; */
DECL|function|log_start_commit
id|tid_t
id|log_start_commit
(paren
id|journal_t
op_star
id|journal
comma
id|transaction_t
op_star
id|transaction
)paren
(brace
id|tid_t
id|target
op_assign
id|journal-&gt;j_commit_request
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Protect journal-&gt;j_running_transaction */
multiline_comment|/*&n;&t; * A NULL transaction asks us to commit the currently running&n;&t; * transaction, if there is one.  &n;&t; */
r_if
c_cond
(paren
id|transaction
)paren
id|target
op_assign
id|transaction-&gt;t_tid
suffix:semicolon
r_else
(brace
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction
)paren
r_goto
id|out
suffix:semicolon
id|target
op_assign
id|transaction-&gt;t_tid
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Are we already doing a recent enough commit?&n;&t; */
r_if
c_cond
(paren
id|tid_geq
c_func
(paren
id|journal-&gt;j_commit_request
comma
id|target
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * We want a new commit: OK, mark the request and wakup the&n;&t; * commit thread.  We do _not_ do the commit ourselves.&n;&t; */
id|journal-&gt;j_commit_request
op_assign
id|target
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;JBD: requesting commit %d/%d&bslash;n&quot;
comma
id|journal-&gt;j_commit_request
comma
id|journal-&gt;j_commit_sequence
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_commit
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|target
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a specified commit to complete.&n; * The caller may not hold the journal lock.&n; */
DECL|function|log_wait_commit
r_void
id|log_wait_commit
(paren
id|journal_t
op_star
id|journal
comma
id|tid_t
id|tid
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_JBD_DEBUG
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tid_geq
c_func
(paren
id|journal-&gt;j_commit_request
comma
id|tid
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
id|__FUNCTION__
l_string|&quot;: error: j_commit_request=%d, tid=%d&bslash;n&quot;
comma
id|journal-&gt;j_commit_request
comma
id|tid
)paren
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|tid_gt
c_func
(paren
id|tid
comma
id|journal-&gt;j_commit_sequence
)paren
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;JBD: want %d, j_commit_sequence=%d&bslash;n&quot;
comma
id|tid
comma
id|journal-&gt;j_commit_sequence
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_commit
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Log buffer allocation routines:&n; */
DECL|function|journal_next_log_block
r_int
id|journal_next_log_block
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_int
r_int
op_star
id|retp
)paren
(brace
r_int
r_int
id|blocknr
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_free
OG
l_int|1
)paren
suffix:semicolon
id|blocknr
op_assign
id|journal-&gt;j_head
suffix:semicolon
id|journal-&gt;j_head
op_increment
suffix:semicolon
id|journal-&gt;j_free
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_head
op_eq
id|journal-&gt;j_last
)paren
id|journal-&gt;j_head
op_assign
id|journal-&gt;j_first
suffix:semicolon
r_return
id|journal_bmap
c_func
(paren
id|journal
comma
id|blocknr
comma
id|retp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Conversion of logical to physical block numbers for the journal&n; *&n; * On external journals the journal blocks are identity-mapped, so&n; * this is a no-op.  If needed, we can use j_blk_offset - everything is&n; * ready.&n; */
DECL|function|journal_bmap
r_int
id|journal_bmap
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_int
r_int
id|blocknr
comma
r_int
r_int
op_star
id|retp
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_inode
)paren
(brace
id|ret
op_assign
id|bmap
c_func
(paren
id|journal-&gt;j_inode
comma
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
op_star
id|retp
op_assign
id|ret
suffix:semicolon
r_else
(brace
id|printk
(paren
id|KERN_ALERT
id|__FUNCTION__
l_string|&quot;: journal block not found &quot;
l_string|&quot;at offset %lu on %s&bslash;n&quot;
comma
id|blocknr
comma
id|bdevname
c_func
(paren
id|journal-&gt;j_dev
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|__journal_abort_soft
c_func
(paren
id|journal
comma
id|err
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|retp
op_assign
id|blocknr
suffix:semicolon
multiline_comment|/* +journal-&gt;j_blk_offset */
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * We play buffer_head aliasing tricks to write data/metadata blocks to&n; * the journal without copying their contents, but for journal&n; * descriptor blocks we do need to generate bona fide buffers.&n; */
DECL|function|journal_get_descriptor_buffer
r_struct
id|journal_head
op_star
id|journal_get_descriptor_buffer
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
r_int
id|blocknr
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|journal_next_log_block
c_func
(paren
id|journal
comma
op_amp
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|__getblk
c_func
(paren
id|journal-&gt;j_dev
comma
id|blocknr
comma
id|journal-&gt;j_blocksize
)paren
suffix:semicolon
id|bh-&gt;b_state
op_or_assign
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;return this buffer&quot;
)paren
suffix:semicolon
r_return
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Management for journal control blocks: functions to create and&n; * destroy journal_t structures, and to initialise and read existing&n; * journal blocks from disk.  */
multiline_comment|/* First: create and setup a journal_t object in memory.  We initialise&n; * very few fields yet: that has to wait until we have created the&n; * journal structures from from scratch, or loaded them from disk. */
DECL|function|journal_init_common
r_static
id|journal_t
op_star
id|journal_init_common
(paren
r_void
)paren
(brace
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|err
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|journal
op_assign
id|jbd_kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|journal
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
r_goto
id|fail
suffix:semicolon
id|memset
c_func
(paren
id|journal
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|journal
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|journal-&gt;j_wait_logspace
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|journal-&gt;j_wait_checkpoint
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|journal-&gt;j_wait_commit
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|journal-&gt;j_barrier
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|journal-&gt;j_checkpoint_sem
)paren
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|journal-&gt;j_sem
)paren
suffix:semicolon
id|journal-&gt;j_commit_interval
op_assign
(paren
id|HZ
op_star
l_int|5
)paren
suffix:semicolon
multiline_comment|/* The journal is marked for error until we succeed with recovery! */
id|journal-&gt;j_flags
op_assign
id|JFS_ABORT
suffix:semicolon
multiline_comment|/* Set up a default-sized revoke table for the new mount. */
id|err
op_assign
id|journal_init_revoke
c_func
(paren
id|journal
comma
id|JOURNAL_REVOKE_DEFAULT_HASH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|kfree
c_func
(paren
id|journal
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
r_return
id|journal
suffix:semicolon
id|fail
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* journal_init_dev and journal_init_inode:&n; *&n; * Create a journal structure assigned some fixed set of disk blocks to&n; * the journal.  We don&squot;t actually touch those disk blocks yet, but we&n; * need to set up all of the mapping information to tell the journaling&n; * system where the journal blocks are.&n; *&n; * journal_init_dev creates a journal which maps a fixed contiguous&n; * range of blocks on an arbitrary block device.&n; *&n; * journal_init_inode creates a journal which maps an on-disk inode as&n; * the journal.  The inode must exist already, must support bmap() and&n; * must have all data blocks preallocated.&n; */
DECL|function|journal_init_dev
id|journal_t
op_star
id|journal_init_dev
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_struct
id|block_device
op_star
id|fs_dev
comma
r_int
id|start
comma
r_int
id|len
comma
r_int
id|blocksize
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|journal_init_common
c_func
(paren
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
r_return
l_int|NULL
suffix:semicolon
id|journal-&gt;j_dev
op_assign
id|bdev
suffix:semicolon
id|journal-&gt;j_fs_dev
op_assign
id|fs_dev
suffix:semicolon
id|journal-&gt;j_blk_offset
op_assign
id|start
suffix:semicolon
id|journal-&gt;j_maxlen
op_assign
id|len
suffix:semicolon
id|journal-&gt;j_blocksize
op_assign
id|blocksize
suffix:semicolon
id|bh
op_assign
id|__getblk
c_func
(paren
id|journal-&gt;j_dev
comma
id|start
comma
id|journal-&gt;j_blocksize
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
id|journal-&gt;j_sb_buffer
op_assign
id|bh
suffix:semicolon
id|journal-&gt;j_superblock
op_assign
(paren
id|journal_superblock_t
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_return
id|journal
suffix:semicolon
)brace
DECL|function|journal_init_inode
id|journal_t
op_star
id|journal_init_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|journal_init_common
c_func
(paren
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|blocknr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
r_return
l_int|NULL
suffix:semicolon
id|journal-&gt;j_dev
op_assign
id|journal-&gt;j_fs_dev
op_assign
id|inode-&gt;i_sb-&gt;s_bdev
suffix:semicolon
id|journal-&gt;j_inode
op_assign
id|inode
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld&bslash;n&quot;
comma
id|journal
comma
id|inode-&gt;i_sb-&gt;s_id
comma
id|inode-&gt;i_ino
comma
(paren
r_int
r_int
)paren
id|inode-&gt;i_size
comma
id|inode-&gt;i_sb-&gt;s_blocksize_bits
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|journal-&gt;j_maxlen
op_assign
id|inode-&gt;i_size
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
suffix:semicolon
id|journal-&gt;j_blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
id|err
op_assign
id|journal_bmap
c_func
(paren
id|journal
comma
l_int|0
comma
op_amp
id|blocknr
)paren
suffix:semicolon
multiline_comment|/* If that failed, give up */
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot;: Cannnot locate journal &quot;
l_string|&quot;superblock&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|bh
op_assign
id|__getblk
c_func
(paren
id|journal-&gt;j_dev
comma
id|blocknr
comma
id|journal-&gt;j_blocksize
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
id|journal-&gt;j_sb_buffer
op_assign
id|bh
suffix:semicolon
id|journal-&gt;j_superblock
op_assign
(paren
id|journal_superblock_t
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_return
id|journal
suffix:semicolon
)brace
multiline_comment|/* &n; * If the journal init or create aborts, we need to mark the journal&n; * superblock as being NULL to prevent the journal destroy from writing&n; * back a bogus superblock. &n; */
DECL|function|journal_fail_superblock
r_static
r_void
id|journal_fail_superblock
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|journal-&gt;j_sb_buffer
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|journal-&gt;j_sb_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a journal_t structure, initialise the various fields for&n; * startup of a new journaling session.  We use this both when creating&n; * a journal, and after recovering an old journal to reset it for&n; * subsequent use.&n; */
DECL|function|journal_reset
r_static
r_int
id|journal_reset
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|journal_superblock_t
op_star
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
r_int
r_int
id|first
comma
id|last
suffix:semicolon
id|first
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_first
)paren
suffix:semicolon
id|last
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_maxlen
)paren
suffix:semicolon
id|journal-&gt;j_first
op_assign
id|first
suffix:semicolon
id|journal-&gt;j_last
op_assign
id|last
suffix:semicolon
id|journal-&gt;j_head
op_assign
id|first
suffix:semicolon
id|journal-&gt;j_tail
op_assign
id|first
suffix:semicolon
id|journal-&gt;j_free
op_assign
id|last
op_minus
id|first
suffix:semicolon
id|journal-&gt;j_tail_sequence
op_assign
id|journal-&gt;j_transaction_sequence
suffix:semicolon
id|journal-&gt;j_commit_sequence
op_assign
id|journal-&gt;j_transaction_sequence
op_minus
l_int|1
suffix:semicolon
id|journal-&gt;j_commit_request
op_assign
id|journal-&gt;j_commit_sequence
suffix:semicolon
id|journal-&gt;j_max_transaction_buffers
op_assign
id|journal-&gt;j_maxlen
op_div
l_int|4
suffix:semicolon
multiline_comment|/* Add the dynamic fields and write it to disk. */
id|journal_update_superblock
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|journal_start_thread
c_func
(paren
id|journal
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a journal_t structure which tells us which disk blocks we can&n; * use, create a new journal superblock and initialise all of the&n; * journal fields from scratch.  */
DECL|function|journal_create
r_int
id|journal_create
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_int
r_int
id|blocknr
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
r_int
id|i
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_maxlen
OL
id|JFS_MIN_JOURNAL_BLOCKS
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Journal length (%d blocks) too short.&bslash;n&quot;
comma
id|journal-&gt;j_maxlen
)paren
suffix:semicolon
id|journal_fail_superblock
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_inode
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t know what block to start at!&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_EMERG
id|__FUNCTION__
l_string|&quot;: creation of journal on external device!&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero out the entire journal on disk.  We cannot afford to&n;&t;   have any blocks on disk beginning with JFS_MAGIC_NUMBER. */
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;JBD: Zeroing out journal blocks...&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|journal-&gt;j_maxlen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|err
op_assign
id|journal_bmap
c_func
(paren
id|journal
comma
id|i
comma
op_amp
id|blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|bh
op_assign
id|__getblk
c_func
(paren
id|journal-&gt;j_dev
comma
id|blocknr
comma
id|journal-&gt;j_blocksize
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|memset
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|journal-&gt;j_blocksize
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;marking dirty&quot;
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;marking uptodate&quot;
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|fsync_bdev
c_func
(paren
id|journal-&gt;j_dev
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;JBD: journal cleared.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* OK, fill in the initial static fields in the new superblock */
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
id|sb-&gt;s_header.h_magic
op_assign
id|htonl
c_func
(paren
id|JFS_MAGIC_NUMBER
)paren
suffix:semicolon
id|sb-&gt;s_header.h_blocktype
op_assign
id|htonl
c_func
(paren
id|JFS_SUPERBLOCK_V2
)paren
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
id|htonl
c_func
(paren
id|journal-&gt;j_blocksize
)paren
suffix:semicolon
id|sb-&gt;s_maxlen
op_assign
id|htonl
c_func
(paren
id|journal-&gt;j_maxlen
)paren
suffix:semicolon
id|sb-&gt;s_first
op_assign
id|htonl
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|journal-&gt;j_transaction_sequence
op_assign
l_int|1
suffix:semicolon
id|journal-&gt;j_flags
op_and_assign
op_complement
id|JFS_ABORT
suffix:semicolon
id|journal-&gt;j_format_version
op_assign
l_int|2
suffix:semicolon
r_return
id|journal_reset
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update a journal&squot;s dynamic superblock fields and write it to disk,&n; * optionally waiting for the IO to complete.&n;*/
DECL|function|journal_update_superblock
r_void
id|journal_update_superblock
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|wait
)paren
(brace
id|journal_superblock_t
op_star
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|journal-&gt;j_sb_buffer
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;JBD: updating superblock (start %ld, seq %d, errno %d)&bslash;n&quot;
comma
id|journal-&gt;j_tail
comma
id|journal-&gt;j_tail_sequence
comma
id|journal-&gt;j_errno
)paren
suffix:semicolon
id|sb-&gt;s_sequence
op_assign
id|htonl
c_func
(paren
id|journal-&gt;j_tail_sequence
)paren
suffix:semicolon
id|sb-&gt;s_start
op_assign
id|htonl
c_func
(paren
id|journal-&gt;j_tail
)paren
suffix:semicolon
id|sb-&gt;s_errno
op_assign
id|htonl
c_func
(paren
id|journal-&gt;j_errno
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;marking dirty&quot;
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* If we have just flushed the log (by marking s_start==0), then&n;&t; * any future commit will have to be careful to update the&n;&t; * superblock again to re-record the true start of the log. */
r_if
c_cond
(paren
id|sb-&gt;s_start
)paren
id|journal-&gt;j_flags
op_and_assign
op_complement
id|JFS_FLUSHED
suffix:semicolon
r_else
id|journal-&gt;j_flags
op_or_assign
id|JFS_FLUSHED
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the superblock for a given journal, performing initial&n; * validation of the format.&n; */
DECL|function|journal_get_superblock
r_static
r_int
id|journal_get_superblock
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|bh
op_assign
id|journal-&gt;j_sb_buffer
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;JBD: IO error reading journal superblock&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_header.h_magic
op_ne
id|htonl
c_func
(paren
id|JFS_MAGIC_NUMBER
)paren
op_logical_or
id|sb-&gt;s_blocksize
op_ne
id|htonl
c_func
(paren
id|journal-&gt;j_blocksize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JBD: no valid journal superblock found&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ntohl
c_func
(paren
id|sb-&gt;s_header.h_blocktype
)paren
)paren
(brace
r_case
id|JFS_SUPERBLOCK_V1
suffix:colon
id|journal-&gt;j_format_version
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|JFS_SUPERBLOCK_V2
suffix:colon
id|journal-&gt;j_format_version
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JBD: unrecognised superblock format ID&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|sb-&gt;s_maxlen
)paren
OL
id|journal-&gt;j_maxlen
)paren
id|journal-&gt;j_maxlen
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_maxlen
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ntohl
c_func
(paren
id|sb-&gt;s_maxlen
)paren
OG
id|journal-&gt;j_maxlen
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;JBD: journal file too short&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
id|journal_fail_superblock
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Load the on-disk journal superblock and read the key fields into the&n; * journal_t.&n; */
DECL|function|load_superblock
r_static
r_int
id|load_superblock
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_int
id|err
suffix:semicolon
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
id|err
op_assign
id|journal_get_superblock
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
id|journal-&gt;j_tail_sequence
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_sequence
)paren
suffix:semicolon
id|journal-&gt;j_tail
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_start
)paren
suffix:semicolon
id|journal-&gt;j_first
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_first
)paren
suffix:semicolon
id|journal-&gt;j_last
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_maxlen
)paren
suffix:semicolon
id|journal-&gt;j_errno
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_errno
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Given a journal_t structure which tells us which disk blocks contain&n; * a journal, read the journal from disk to initialise the in-memory&n; * structures.&n; */
DECL|function|journal_load
r_int
id|journal_load
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_int
id|err
suffix:semicolon
id|err
op_assign
id|load_superblock
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* If this is a V2 superblock, then we have to check the&n;&t; * features flags on it. */
r_if
c_cond
(paren
id|journal-&gt;j_format_version
op_ge
l_int|2
)paren
(brace
id|journal_superblock_t
op_star
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sb-&gt;s_feature_ro_compat
op_amp
op_complement
id|cpu_to_be32
c_func
(paren
id|JFS_KNOWN_ROCOMPAT_FEATURES
)paren
)paren
op_logical_or
(paren
id|sb-&gt;s_feature_incompat
op_amp
op_complement
id|cpu_to_be32
c_func
(paren
id|JFS_KNOWN_INCOMPAT_FEATURES
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;JBD: Unrecognised features on journal&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* Let the recovery code check whether it needs to recover any&n;&t; * data from the journal. */
r_if
c_cond
(paren
id|journal_recover
c_func
(paren
id|journal
)paren
)paren
r_goto
id|recovery_error
suffix:semicolon
multiline_comment|/* OK, we&squot;ve finished with the dynamic journal bits:&n;&t; * reinitialise the dynamic contents of the superblock in memory&n;&t; * and reset them on disk. */
r_if
c_cond
(paren
id|journal_reset
c_func
(paren
id|journal
)paren
)paren
r_goto
id|recovery_error
suffix:semicolon
id|journal-&gt;j_flags
op_and_assign
op_complement
id|JFS_ABORT
suffix:semicolon
id|journal-&gt;j_flags
op_or_assign
id|JFS_LOADED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|recovery_error
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;JBD: recovery failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * Release a journal_t structure once it is no longer in use by the&n; * journaled object.&n; */
DECL|function|journal_destroy
r_void
id|journal_destroy
(paren
id|journal_t
op_star
id|journal
)paren
(brace
multiline_comment|/* Wait for the commit thread to wake up and die. */
id|journal_kill_thread
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* Force a final log commit */
r_if
c_cond
(paren
id|journal-&gt;j_running_transaction
)paren
id|journal_commit_transaction
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* Force any old transactions to disk */
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_while
c_loop
(paren
id|journal-&gt;j_checkpoint_transactions
op_ne
l_int|NULL
)paren
id|log_do_checkpoint
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_running_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_committing_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_checkpoint_transactions
op_eq
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* We can now mark the journal as empty. */
id|journal-&gt;j_tail
op_assign
l_int|0
suffix:semicolon
id|journal-&gt;j_tail_sequence
op_assign
op_increment
id|journal-&gt;j_transaction_sequence
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_sb_buffer
)paren
(brace
id|journal_update_superblock
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|journal-&gt;j_sb_buffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_inode
)paren
id|iput
c_func
(paren
id|journal-&gt;j_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_revoke
)paren
id|journal_destroy_revoke
c_func
(paren
id|journal
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|journal
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* Published API: Check whether the journal uses all of a given set of&n; * features.  Return true (non-zero) if it does. */
DECL|function|journal_check_used_features
r_int
id|journal_check_used_features
(paren
id|journal_t
op_star
id|journal
comma
r_int
r_int
id|compat
comma
r_int
r_int
id|ro
comma
r_int
r_int
id|incompat
)paren
(brace
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|compat
op_logical_and
op_logical_neg
id|ro
op_logical_and
op_logical_neg
id|incompat
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_format_version
op_eq
l_int|1
)paren
r_return
l_int|0
suffix:semicolon
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|sb-&gt;s_feature_compat
)paren
op_amp
id|compat
)paren
op_eq
id|compat
)paren
op_logical_and
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|sb-&gt;s_feature_ro_compat
)paren
op_amp
id|ro
)paren
op_eq
id|ro
)paren
op_logical_and
(paren
(paren
id|be32_to_cpu
c_func
(paren
id|sb-&gt;s_feature_incompat
)paren
op_amp
id|incompat
)paren
op_eq
id|incompat
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Published API: Check whether the journaling code supports the use of&n; * all of a given set of features on this journal.  Return true&n; * (non-zero) if it can. */
DECL|function|journal_check_available_features
r_int
id|journal_check_available_features
(paren
id|journal_t
op_star
id|journal
comma
r_int
r_int
id|compat
comma
r_int
r_int
id|ro
comma
r_int
r_int
id|incompat
)paren
(brace
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|compat
op_logical_and
op_logical_neg
id|ro
op_logical_and
op_logical_neg
id|incompat
)paren
r_return
l_int|1
suffix:semicolon
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
multiline_comment|/* We can support any known requested features iff the&n;&t; * superblock is in version 2.  Otherwise we fail to support any&n;&t; * extended sb features. */
r_if
c_cond
(paren
id|journal-&gt;j_format_version
op_ne
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|compat
op_amp
id|JFS_KNOWN_COMPAT_FEATURES
)paren
op_eq
id|compat
op_logical_and
(paren
id|ro
op_amp
id|JFS_KNOWN_ROCOMPAT_FEATURES
)paren
op_eq
id|ro
op_logical_and
(paren
id|incompat
op_amp
id|JFS_KNOWN_INCOMPAT_FEATURES
)paren
op_eq
id|incompat
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Published API: Mark a given journal feature as present on the&n; * superblock.  Returns true if the requested features could be set. */
DECL|function|journal_set_features
r_int
id|journal_set_features
(paren
id|journal_t
op_star
id|journal
comma
r_int
r_int
id|compat
comma
r_int
r_int
id|ro
comma
r_int
r_int
id|incompat
)paren
(brace
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
r_if
c_cond
(paren
id|journal_check_used_features
c_func
(paren
id|journal
comma
id|compat
comma
id|ro
comma
id|incompat
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal_check_available_features
c_func
(paren
id|journal
comma
id|compat
comma
id|ro
comma
id|incompat
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;Setting new features 0x%lx/0x%lx/0x%lx&bslash;n&quot;
comma
id|compat
comma
id|ro
comma
id|incompat
)paren
suffix:semicolon
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
id|sb-&gt;s_feature_compat
op_or_assign
id|cpu_to_be32
c_func
(paren
id|compat
)paren
suffix:semicolon
id|sb-&gt;s_feature_ro_compat
op_or_assign
id|cpu_to_be32
c_func
(paren
id|ro
)paren
suffix:semicolon
id|sb-&gt;s_feature_incompat
op_or_assign
id|cpu_to_be32
c_func
(paren
id|incompat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Published API:&n; * Given an initialised but unloaded journal struct, poke about in the&n; * on-disk structure to update it to the most recent supported version.&n; */
DECL|function|journal_update_format
r_int
id|journal_update_format
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|journal_get_superblock
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
r_switch
c_cond
(paren
id|ntohl
c_func
(paren
id|sb-&gt;s_header.h_blocktype
)paren
)paren
(brace
r_case
id|JFS_SUPERBLOCK_V2
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|JFS_SUPERBLOCK_V1
suffix:colon
r_return
id|journal_convert_superblock_v1
c_func
(paren
id|journal
comma
id|sb
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|journal_convert_superblock_v1
r_static
r_int
id|journal_convert_superblock_v1
c_func
(paren
id|journal_t
op_star
id|journal
comma
id|journal_superblock_t
op_star
id|sb
)paren
(brace
r_int
id|offset
comma
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JBD: Converting superblock from version 1 to 2.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Pre-initialise new fields to zero */
id|offset
op_assign
(paren
(paren
r_char
op_star
)paren
op_amp
(paren
id|sb-&gt;s_feature_compat
)paren
)paren
op_minus
(paren
(paren
r_char
op_star
)paren
id|sb
)paren
suffix:semicolon
id|blocksize
op_assign
id|ntohl
c_func
(paren
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sb-&gt;s_feature_compat
comma
l_int|0
comma
id|blocksize
op_minus
id|offset
)paren
suffix:semicolon
id|sb-&gt;s_nr_users
op_assign
id|cpu_to_be32
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|sb-&gt;s_header.h_blocktype
op_assign
id|cpu_to_be32
c_func
(paren
id|JFS_SUPERBLOCK_V2
)paren
suffix:semicolon
id|journal-&gt;j_format_version
op_assign
l_int|2
suffix:semicolon
id|bh
op_assign
id|journal-&gt;j_sb_buffer
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;marking dirty&quot;
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush all data for a given journal to disk and empty the journal.&n; * Filesystems can use this when remounting readonly to ensure that&n; * recovery does not need to happen on remount.&n; */
DECL|function|journal_flush
r_int
id|journal_flush
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|transaction_t
op_star
id|transaction
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|old_tail
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Force everything buffered to the log... */
r_if
c_cond
(paren
id|journal-&gt;j_running_transaction
)paren
(brace
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
id|log_start_commit
c_func
(paren
id|journal
comma
id|transaction
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|journal-&gt;j_committing_transaction
)paren
id|transaction
op_assign
id|journal-&gt;j_committing_transaction
suffix:semicolon
multiline_comment|/* Wait for the log commit to complete... */
r_if
c_cond
(paren
id|transaction
)paren
id|log_wait_commit
c_func
(paren
id|journal
comma
id|transaction-&gt;t_tid
)paren
suffix:semicolon
multiline_comment|/* ...and flush everything in the log out to disk. */
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|err
op_logical_and
id|journal-&gt;j_checkpoint_transactions
op_ne
l_int|NULL
)paren
id|err
op_assign
id|log_do_checkpoint
c_func
(paren
id|journal
comma
id|journal-&gt;j_maxlen
)paren
suffix:semicolon
id|cleanup_journal_tail
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* Finally, mark the journal as really needing no recovery.&n;&t; * This sets s_start==0 in the underlying superblock, which is&n;&t; * the magic code for a fully-recovered superblock.  Any future&n;&t; * commits of data to the journal will restore the current&n;&t; * s_start value. */
id|old_tail
op_assign
id|journal-&gt;j_tail
suffix:semicolon
id|journal-&gt;j_tail
op_assign
l_int|0
suffix:semicolon
id|journal_update_superblock
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
id|journal-&gt;j_tail
op_assign
id|old_tail
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
op_logical_neg
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
op_logical_neg
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
op_logical_neg
id|journal-&gt;j_checkpoint_transactions
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_head
op_eq
id|journal-&gt;j_tail
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_tail_sequence
op_eq
id|journal-&gt;j_transaction_sequence
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Wipe out all of the contents of a journal, safely.  This will produce&n; * a warning if the journal contains any valid recovery information.&n; * Must be called between journal_init_*() and journal_load().&n; *&n; * If (write) is non-zero, then we wipe out the journal on disk; otherwise&n; * we merely suppress recovery.&n; */
DECL|function|journal_wipe
r_int
id|journal_wipe
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|write
)paren
(brace
id|journal_superblock_t
op_star
id|sb
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|J_ASSERT
(paren
op_logical_neg
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_LOADED
)paren
)paren
suffix:semicolon
id|err
op_assign
id|load_superblock
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|sb
op_assign
id|journal-&gt;j_superblock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_tail
)paren
r_goto
id|no_recovery
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;JBD: %s recovery information on journal&bslash;n&quot;
comma
id|write
ques
c_cond
l_string|&quot;Clearing&quot;
suffix:colon
l_string|&quot;Ignoring&quot;
)paren
suffix:semicolon
id|err
op_assign
id|journal_skip_recovery
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
)paren
id|journal_update_superblock
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
id|no_recovery
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_dev_name: format a character string to describe on what&n; * device this journal is present.&n; */
DECL|function|journal_dev_name
r_const
r_char
op_star
id|journal_dev_name
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_struct
id|block_device
op_star
id|bdev
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_inode
)paren
id|bdev
op_assign
id|journal-&gt;j_inode-&gt;i_sb-&gt;s_bdev
suffix:semicolon
r_else
id|bdev
op_assign
id|journal-&gt;j_dev
suffix:semicolon
r_return
id|bdevname
c_func
(paren
id|bdev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_abort: perform a complete, immediate shutdown of the ENTIRE&n; * journal (not of a single transaction).  This operation cannot be&n; * undone without closing and reopening the journal.&n; *&n; * The journal_abort function is intended to support higher level error&n; * recovery mechanisms such as the ext2/ext3 remount-readonly error&n; * mode.&n; *&n; * Journal abort has very specific semantics.  Any existing dirty,&n; * unjournaled buffers in the main filesystem will still be written to&n; * disk by bdflush, but the journaling mechanism will be suspended&n; * immediately and no further transaction commits will be honoured.&n; *&n; * Any dirty, journaled buffers will be written back to disk without&n; * hitting the journal.  Atomicity cannot be guaranteed on an aborted&n; * filesystem, but we _do_ attempt to leave as much data as possible&n; * behind for fsck to use for cleanup.&n; *&n; * Any attempt to get a new transaction handle on a journal which is in&n; * ABORT state will just result in an -EROFS error return.  A&n; * journal_stop on an existing handle will return -EIO if we have&n; * entered abort state during the update.&n; *&n; * Recursive transactions are not disturbed by journal abort until the&n; * final journal_stop, which will receive the -EIO error.&n; *&n; * Finally, the journal_abort call allows the caller to supply an errno&n; * which will be recored (if possible) in the journal superblock.  This&n; * allows a client to record failure conditions in the middle of a&n; * transaction without having to complete the transaction to record the&n; * failure to disk.  ext3_error, for example, now uses this&n; * functionality.&n; *&n; * Errors which originate from within the journaling layer will NOT&n; * supply an errno; a null errno implies that absolutely no further&n; * writes are done to the journal (unless there are any already in&n; * progress).&n; */
multiline_comment|/* Quick version for internal journal use (doesn&squot;t lock the journal).&n; * Aborts hard --- we mark the abort as occurred, but do _nothing_ else,&n; * and don&squot;t attempt to make any other journal updates. */
DECL|function|__journal_abort_hard
r_void
id|__journal_abort_hard
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_ABORT
)paren
r_return
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;Aborting journal on device %s.&bslash;n&quot;
comma
id|journal_dev_name
c_func
(paren
id|journal
)paren
)paren
suffix:semicolon
id|journal-&gt;j_flags
op_or_assign
id|JFS_ABORT
suffix:semicolon
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
r_if
c_cond
(paren
id|transaction
)paren
id|log_start_commit
c_func
(paren
id|journal
comma
id|transaction
)paren
suffix:semicolon
)brace
multiline_comment|/* Soft abort: record the abort error status in the journal superblock,&n; * but don&squot;t do any other IO. */
DECL|function|__journal_abort_soft
r_void
id|__journal_abort_soft
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|errno
)paren
(brace
r_if
c_cond
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_ABORT
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_errno
)paren
id|journal-&gt;j_errno
op_assign
id|errno
suffix:semicolon
id|__journal_abort_hard
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
id|journal_update_superblock
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Full version for external use */
DECL|function|journal_abort
r_void
id|journal_abort
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|errno
)paren
(brace
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|__journal_abort_soft
c_func
(paren
id|journal
comma
id|errno
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
DECL|function|journal_errno
r_int
id|journal_errno
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_int
id|err
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_ABORT
)paren
id|err
op_assign
op_minus
id|EROFS
suffix:semicolon
r_else
id|err
op_assign
id|journal-&gt;j_errno
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|journal_clear_err
r_int
id|journal_clear_err
(paren
id|journal_t
op_star
id|journal
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_ABORT
)paren
id|err
op_assign
op_minus
id|EROFS
suffix:semicolon
r_else
id|journal-&gt;j_errno
op_assign
l_int|0
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|journal_ack_err
r_void
id|journal_ack_err
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_errno
)paren
id|journal-&gt;j_flags
op_or_assign
id|JFS_ACK_ERR
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
DECL|function|journal_blocks_per_page
r_int
id|journal_blocks_per_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
l_int|1
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * shrink_journal_memory().&n; * Called when we&squot;re under memory pressure.  Free up all the written-back&n; * checkpointed metadata buffers.&n; */
DECL|function|shrink_journal_memory
r_void
id|shrink_journal_memory
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|list
comma
op_amp
id|all_journals
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|list_entry
c_func
(paren
id|list
comma
id|journal_t
comma
id|j_all_journals
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|__journal_clean_checkpoint_list
c_func
(paren
id|journal
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Simple support for retying memory allocations.  Introduced to help to&n; * debug different VM deadlock avoidance strategies. &n; */
multiline_comment|/*&n; * Simple support for retying memory allocations.  Introduced to help to&n; * debug different VM deadlock avoidance strategies. &n; */
DECL|function|__jbd_kmalloc
r_void
op_star
id|__jbd_kmalloc
(paren
r_char
op_star
id|where
comma
r_int
id|size
comma
r_int
id|flags
comma
r_int
id|retry
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
r_static
r_int
r_int
id|last_warning
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|p
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
r_return
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Log every retry for debugging.  Also log them to the&n;&t;&t; * syslog, but do rate-limiting on the non-debugging&n;&t;&t; * messages. */
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;ENOMEM in %s, retrying.&bslash;n&quot;
comma
id|where
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|last_warning
op_plus
l_int|5
op_star
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ENOMEM in %s, retrying.&bslash;n&quot;
comma
id|where
)paren
suffix:semicolon
id|last_warning
op_assign
id|jiffies
suffix:semicolon
)brace
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Journal_head storage management&n; */
DECL|variable|journal_head_cache
r_static
id|kmem_cache_t
op_star
id|journal_head_cache
suffix:semicolon
macro_line|#ifdef CONFIG_JBD_DEBUG
DECL|variable|nr_journal_heads
r_static
id|atomic_t
id|nr_journal_heads
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
DECL|function|journal_init_journal_head_cache
r_static
r_int
id|journal_init_journal_head_cache
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal_head_cache
op_eq
l_int|0
)paren
suffix:semicolon
id|journal_head_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;journal_head&quot;
comma
r_sizeof
(paren
r_struct
id|journal_head
)paren
comma
l_int|0
comma
multiline_comment|/* offset */
l_int|0
comma
multiline_comment|/* flags */
l_int|NULL
comma
multiline_comment|/* ctor */
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* dtor */
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|journal_head_cache
op_eq
l_int|0
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;JBD: no memory for journal_head cache&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|journal_destroy_journal_head_cache
r_static
r_void
id|journal_destroy_journal_head_cache
c_func
(paren
r_void
)paren
(brace
id|J_ASSERT
c_func
(paren
id|journal_head_cache
op_ne
l_int|NULL
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|journal_head_cache
)paren
suffix:semicolon
id|journal_head_cache
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_head splicing and dicing&n; */
DECL|function|journal_alloc_journal_head
r_static
r_struct
id|journal_head
op_star
id|journal_alloc_journal_head
c_func
(paren
r_void
)paren
(brace
r_struct
id|journal_head
op_star
id|ret
suffix:semicolon
r_static
r_int
r_int
id|last_warning
suffix:semicolon
macro_line|#ifdef CONFIG_JBD_DEBUG
id|atomic_inc
c_func
(paren
op_amp
id|nr_journal_heads
)paren
suffix:semicolon
macro_line|#endif
id|ret
op_assign
id|kmem_cache_alloc
c_func
(paren
id|journal_head_cache
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|1
comma
l_string|&quot;out of memory for journal_head&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|last_warning
op_plus
l_int|5
op_star
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ENOMEM in &quot;
id|__FUNCTION__
l_string|&quot;, retrying.&bslash;n&quot;
)paren
suffix:semicolon
id|last_warning
op_assign
id|jiffies
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|yield
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|kmem_cache_alloc
c_func
(paren
id|journal_head_cache
comma
id|GFP_NOFS
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|journal_free_journal_head
r_static
r_void
id|journal_free_journal_head
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
macro_line|#ifdef CONFIG_JBD_DEBUG
id|atomic_dec
c_func
(paren
op_amp
id|nr_journal_heads
)paren
suffix:semicolon
id|memset
c_func
(paren
id|jh
comma
l_int|0x5b
comma
r_sizeof
(paren
op_star
id|jh
)paren
)paren
suffix:semicolon
macro_line|#endif
id|kmem_cache_free
c_func
(paren
id|journal_head_cache
comma
id|jh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A journal_head is attached to a buffer_head whenever JBD has an&n; * interest in the buffer.&n; *&n; * Whenever a buffer has an attached journal_head, its -&gt;b_state:BH_JBD bit&n; * is set.  This bit is tested in core kernel code where we need to take&n; * JBD-specific actions.  Testing the zeroness of -&gt;b_private is not reliable&n; * there.&n; *&n; * When a buffer has its BH_JBD bit set, its -&gt;b_count is elevated by one.&n; *&n; * When a buffer has its BH_JBD bit set it is immune from being released by&n; * core kernel code, mainly via -&gt;b_count.&n; *&n; * A journal_head may be detached from its buffer_head when the journal_head&squot;s&n; * b_transaction, b_cp_transaction and b_next_transaction pointers are NULL.&n; * Various places in JBD call journal_remove_journal_head() to indicate that the&n; * journal_head can be dropped if needed.&n; *&n; * Various places in the kernel want to attach a journal_head to a buffer_head&n; * _before_ attaching the journal_head to a transaction.  To protect the&n; * journal_head in this situation, journal_add_journal_head elevates the&n; * journal_head&squot;s b_jcount refcount by one.  The caller must call&n; * journal_unlock_journal_head() to undo this.&n; *&n; * So the typical usage would be:&n; *&n; *&t;(Attach a journal_head if needed.  Increments b_jcount)&n; *&t;struct journal_head *jh = journal_add_journal_head(bh);&n; *&t;...&n; *&t;jh-&gt;b_transaction = xxx;&n; *&t;journal_unlock_journal_head(jh);&n; *&n; * Now, the journal_head&squot;s b_jcount is zero, but it is safe from being released&n; * because it has a non-zero b_transaction.&n; */
multiline_comment|/*&n; * Give a buffer_head a journal_head.&n; *&n; * Doesn&squot;t need the journal lock.&n; * May sleep.&n; * Cannot be called with journal_datalist_lock held.&n; */
DECL|function|journal_add_journal_head
r_struct
id|journal_head
op_star
id|journal_add_journal_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
(brace
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|J_ASSERT_BH
c_func
(paren
id|bh
comma
(paren
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
OG
l_int|0
)paren
op_logical_or
(paren
id|bh-&gt;b_page
op_logical_and
id|bh-&gt;b_page-&gt;mapping
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|jh
op_assign
id|journal_alloc_journal_head
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|jh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|jh
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Someone did it for us! */
id|J_ASSERT_BH
c_func
(paren
id|bh
comma
id|bh-&gt;b_private
op_ne
l_int|NULL
)paren
suffix:semicolon
id|journal_free_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh
op_assign
id|bh-&gt;b_private
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We actually don&squot;t need jh_splice_lock when&n;&t;&t;&t; * adding a journal_head - only on removal.&n;&t;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|jh_splice_lock
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_JBD
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|bh-&gt;b_private
op_assign
id|jh
suffix:semicolon
id|jh-&gt;b_bh
op_assign
id|bh
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|jh_splice_lock
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;added journal_head&quot;
)paren
suffix:semicolon
)brace
)brace
id|jh-&gt;b_jcount
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_return
id|bh-&gt;b_private
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_remove_journal_head(): if the buffer isn&squot;t attached to a transaction&n; * and has a zero b_jcount then remove and release its journal_head.   If we did&n; * see that the buffer is not used by any transaction we also &quot;logically&quot;&n; * decrement -&gt;b_count.&n; *&n; * We in fact take an additional increment on -&gt;b_count as a convenience,&n; * because the caller usually wants to do additional things with the bh&n; * after calling here.&n; * The caller of journal_remove_journal_head() *must* run __brelse(bh) at some&n; * time.  Once the caller has run __brelse(), the buffer is eligible for&n; * reaping by try_to_free_buffers().&n; *&n; * Requires journal_datalist_lock.&n; */
DECL|function|__journal_remove_journal_head
r_void
id|__journal_remove_journal_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|journal_head
op_star
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|assert_spin_locked
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jcount
op_ge
l_int|0
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_jcount
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
l_int|NULL
op_logical_and
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
op_logical_and
id|jh-&gt;b_cp_transaction
op_eq
l_int|NULL
)paren
(brace
id|J_ASSERT_BH
c_func
(paren
id|bh
comma
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|J_ASSERT_BH
c_func
(paren
id|bh
comma
id|jh2bh
c_func
(paren
id|jh
)paren
op_eq
id|bh
)paren
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;remove journal_head&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|jh_splice_lock
)paren
suffix:semicolon
id|bh-&gt;b_private
op_assign
l_int|NULL
suffix:semicolon
id|jh-&gt;b_bh
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* debug, really */
id|clear_bit
c_func
(paren
id|BH_JBD
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|jh_splice_lock
)paren
suffix:semicolon
id|journal_free_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
)brace
r_else
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;journal_head was locked&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|journal_unlock_journal_head
r_void
id|journal_unlock_journal_head
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jcount
OG
l_int|0
)paren
suffix:semicolon
op_decrement
id|jh-&gt;b_jcount
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_jcount
op_logical_and
op_logical_neg
id|jh-&gt;b_transaction
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
)brace
DECL|function|journal_remove_journal_head
r_void
id|journal_remove_journal_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * /proc tunables&n; */
macro_line|#if defined(CONFIG_JBD_DEBUG)
DECL|variable|journal_enable_debug
r_int
id|journal_enable_debug
suffix:semicolon
DECL|variable|journal_enable_debug
id|EXPORT_SYMBOL
c_func
(paren
id|journal_enable_debug
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_JBD_DEBUG) &amp;&amp; defined(CONFIG_PROC_FS)
DECL|variable|proc_jbd_debug
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_jbd_debug
suffix:semicolon
DECL|function|read_jbd_debug
r_int
id|read_jbd_debug
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|sprintf
c_func
(paren
id|page
op_plus
id|off
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|journal_enable_debug
)paren
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|write_jbd_debug
r_int
id|write_jbd_debug
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_char
id|buf
(braket
l_int|32
)braket
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|ARRAY_SIZE
c_func
(paren
id|buf
)paren
op_minus
l_int|1
)paren
id|count
op_assign
id|ARRAY_SIZE
c_func
(paren
id|buf
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|buffer
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
(braket
id|ARRAY_SIZE
c_func
(paren
id|buf
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|journal_enable_debug
op_assign
id|simple_strtoul
c_func
(paren
id|buf
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|macro|JBD_PROC_NAME
mdefine_line|#define JBD_PROC_NAME &quot;sys/fs/jbd-debug&quot;
DECL|function|create_jbd_proc_entry
r_static
r_void
id|__init
id|create_jbd_proc_entry
c_func
(paren
r_void
)paren
(brace
id|proc_jbd_debug
op_assign
id|create_proc_entry
c_func
(paren
id|JBD_PROC_NAME
comma
l_int|0644
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|proc_jbd_debug
)paren
(brace
multiline_comment|/* Why is this so hard? */
id|proc_jbd_debug-&gt;read_proc
op_assign
id|read_jbd_debug
suffix:semicolon
id|proc_jbd_debug-&gt;write_proc
op_assign
id|write_jbd_debug
suffix:semicolon
)brace
)brace
DECL|function|remove_jbd_proc_entry
r_static
r_void
id|__exit
id|remove_jbd_proc_entry
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|proc_jbd_debug
)paren
id|remove_proc_entry
c_func
(paren
id|JBD_PROC_NAME
comma
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|create_jbd_proc_entry
mdefine_line|#define create_jbd_proc_entry() do {} while (0)
DECL|macro|remove_jbd_proc_entry
mdefine_line|#define remove_jbd_proc_entry() do {} while (0)
macro_line|#endif
multiline_comment|/*&n; * Module startup and shutdown&n; */
DECL|function|journal_init_caches
r_static
r_int
id|__init
id|journal_init_caches
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|journal_init_revoke_caches
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|journal_init_journal_head_cache
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|journal_destroy_caches
r_static
r_void
id|journal_destroy_caches
c_func
(paren
r_void
)paren
(brace
id|journal_destroy_revoke_caches
c_func
(paren
)paren
suffix:semicolon
id|journal_destroy_journal_head_cache
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|journal_init
r_static
r_int
id|__init
id|journal_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Journalled Block Device driver loaded&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|journal_init_caches
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
id|journal_destroy_caches
c_func
(paren
)paren
suffix:semicolon
id|create_jbd_proc_entry
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|journal_exit
r_static
r_void
id|__exit
id|journal_exit
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_JBD_DEBUG
r_int
id|n
op_assign
id|atomic_read
c_func
(paren
op_amp
id|nr_journal_heads
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;JBD: leaked %d journal_heads!&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
macro_line|#endif
id|remove_jbd_proc_entry
c_func
(paren
)paren
suffix:semicolon
id|journal_destroy_caches
c_func
(paren
)paren
suffix:semicolon
)brace
id|MODULE_LICENSE
c_func
(paren
l_string|&quot;GPL&quot;
)paren
suffix:semicolon
DECL|variable|journal_init
id|module_init
c_func
(paren
id|journal_init
)paren
suffix:semicolon
DECL|variable|journal_exit
id|module_exit
c_func
(paren
id|journal_exit
)paren
suffix:semicolon
eof
