multiline_comment|/*&n; * linux/fs/transaction.c&n; * &n; * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1998&n; *&n; * Copyright 1998 Red Hat corp --- All Rights Reserved&n; *&n; * This file is part of the Linux kernel and is made available under&n; * the terms of the GNU General Public License, version 2, or at your&n; * option, any later version, incorporated herein by reference.&n; *&n; * Generic filesystem transaction handling code; part of the ext2fs&n; * journaling system.  &n; *&n; * This file manages transactions (compound commits managed by the&n; * journaling code) and handles (individual atomic operations by the&n; * filesystem).&n; */
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/jbd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
r_extern
id|spinlock_t
id|journal_datalist_lock
suffix:semicolon
multiline_comment|/*&n; * get_transaction: obtain a new transaction_t object.&n; *&n; * Simply allocate and initialise a new transaction.  Create it in&n; * RUNNING state and add it to the current journal (which should not&n; * have an existing running transaction: we only make a new transaction&n; * once we have started to commit the old one).&n; *&n; * Preconditions:&n; *&t;The journal MUST be locked.  We don&squot;t perform atomic mallocs on the&n; *&t;new transaction&t;and we can&squot;t block without protecting against other&n; *&t;processes trying to touch the journal while it is in transition.&n; */
DECL|function|get_transaction
r_static
id|transaction_t
op_star
id|get_transaction
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|is_try
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
id|transaction
op_assign
id|jbd_kmalloc
(paren
r_sizeof
(paren
id|transaction_t
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
(paren
id|transaction
comma
l_int|0
comma
r_sizeof
(paren
id|transaction_t
)paren
)paren
suffix:semicolon
id|transaction-&gt;t_journal
op_assign
id|journal
suffix:semicolon
id|transaction-&gt;t_state
op_assign
id|T_RUNNING
suffix:semicolon
id|transaction-&gt;t_tid
op_assign
id|journal-&gt;j_transaction_sequence
op_increment
suffix:semicolon
id|transaction-&gt;t_expires
op_assign
id|jiffies
op_plus
id|journal-&gt;j_commit_interval
suffix:semicolon
multiline_comment|/* Set up the commit timer for the new transaction. */
id|J_ASSERT
(paren
op_logical_neg
id|journal-&gt;j_commit_timer_active
)paren
suffix:semicolon
id|journal-&gt;j_commit_timer_active
op_assign
l_int|1
suffix:semicolon
id|journal-&gt;j_commit_timer-&gt;expires
op_assign
id|transaction-&gt;t_expires
suffix:semicolon
id|add_timer
c_func
(paren
id|journal-&gt;j_commit_timer
)paren
suffix:semicolon
id|J_ASSERT
(paren
id|journal-&gt;j_running_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|journal-&gt;j_running_transaction
op_assign
id|transaction
suffix:semicolon
r_return
id|transaction
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle management.&n; *&n; * A handle_t is an object which represents a single atomic update to a&n; * filesystem, and which tracks all of the modifications which form part&n; * of that one update.&n; */
multiline_comment|/*&n; * start_this_handle: Given a handle, deal with any locking or stalling&n; * needed to make sure that there is enough journal space for the handle&n; * to begin.  Attach the handle to a transaction and set up the&n; * transaction&squot;s buffer credits.  &n; */
DECL|function|start_this_handle
r_static
r_int
id|start_this_handle
c_func
(paren
id|journal_t
op_star
id|journal
comma
id|handle_t
op_star
id|handle
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_int
id|needed
suffix:semicolon
r_int
id|nblocks
op_assign
id|handle-&gt;h_buffer_credits
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;New handle %p going live.&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|repeat
suffix:colon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_journal_aborted
c_func
(paren
id|journal
)paren
op_logical_or
(paren
id|journal-&gt;j_errno
op_ne
l_int|0
op_logical_and
op_logical_neg
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_ACK_ERR
)paren
)paren
)paren
(brace
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
multiline_comment|/* Wait on the journal&squot;s transaction barrier if necessary */
r_if
c_cond
(paren
id|journal-&gt;j_barrier_count
)paren
(brace
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|repeat_locked
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_running_transaction
)paren
id|get_transaction
c_func
(paren
id|journal
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* @@@ Error? */
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
multiline_comment|/* If the current transaction is locked down for commit, wait&n;&t; * for the lock to be released. */
r_if
c_cond
(paren
id|transaction-&gt;t_state
op_eq
id|T_LOCKED
)paren
(brace
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;Handle %p stalling...&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* If there is not enough space left in the log to write all&n;&t; * potential buffers requested by this operation, we need to&n;&t; * stall pending a log checkpoint to free some more log&n;&t; * space. */
id|needed
op_assign
id|transaction-&gt;t_outstanding_credits
op_plus
id|nblocks
suffix:semicolon
r_if
c_cond
(paren
id|needed
OG
id|journal-&gt;j_max_transaction_buffers
)paren
(brace
multiline_comment|/* If the current transaction is already too large, then&n;&t;&t; * start to commit it: we can then go back and attach&n;&t;&t; * this handle to a new transaction. */
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;Handle %p starting new commit...&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|log_start_commit
c_func
(paren
id|journal
comma
id|transaction
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_goto
id|repeat_locked
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * The commit code assumes that it can get enough log space&n;&t; * without forcing a checkpoint.  This is *critical* for&n;&t; * correctness: a checkpoint of a buffer which is also&n;&t; * associated with a committing transaction creates a deadlock,&n;&t; * so commit simply cannot force through checkpoints.&n;&t; *&n;&t; * We must therefore ensure the necessary space in the journal&n;&t; * *before* starting to dirty potentially checkpointed buffers&n;&t; * in the new transaction. &n;&t; *&n;&t; * The worst part is, any transaction currently committing can&n;&t; * reduce the free space arbitrarily.  Be careful to account for&n;&t; * those buffers when checkpointing.&n;&t; */
multiline_comment|/*&n;&t; * @@@ AKPM: This seems rather over-defensive.  We&squot;re giving commit&n;&t; * a _lot_ of headroom: 1/4 of the journal plus the size of&n;&t; * the committing transaction.  Really, we only need to give it&n;&t; * committing_transaction-&gt;t_outstanding_credits plus &quot;enough&quot; for&n;&t; * the log control blocks.&n;&t; * Also, this test is inconsitent with the matching one in&n;&t; * journal_extend().&n;&t; */
id|needed
op_assign
id|journal-&gt;j_max_transaction_buffers
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_committing_transaction
)paren
id|needed
op_add_assign
id|journal-&gt;j_committing_transaction
op_member_access_from_pointer
id|t_outstanding_credits
suffix:semicolon
r_if
c_cond
(paren
id|log_space_left
c_func
(paren
id|journal
)paren
OL
id|needed
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;Handle %p waiting for checkpoint...&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|log_wait_for_space
c_func
(paren
id|journal
comma
id|needed
)paren
suffix:semicolon
r_goto
id|repeat_locked
suffix:semicolon
)brace
multiline_comment|/* OK, account for the buffers that this operation expects to&n;&t; * use and add the handle to the running transaction. */
id|handle-&gt;h_transaction
op_assign
id|transaction
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_add_assign
id|nblocks
suffix:semicolon
id|transaction-&gt;t_updates
op_increment
suffix:semicolon
id|transaction-&gt;t_handle_count
op_increment
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;Handle %p given %d credits (total %d, free %d)&bslash;n&quot;
comma
id|handle
comma
id|nblocks
comma
id|transaction-&gt;t_outstanding_credits
comma
id|log_space_left
c_func
(paren
id|journal
)paren
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain a new handle.  &n; *&n; * We make sure that the transaction can guarantee at least nblocks of&n; * modified buffers in the log.  We block until the log can guarantee&n; * that much space.  &n; *&n; * This function is visible to journal users (like ext2fs), so is not&n; * called with the journal already locked.&n; *&n; * Return a pointer to a newly allocated handle, or NULL on failure&n; */
DECL|function|journal_start
id|handle_t
op_star
id|journal_start
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|nblocks
)paren
(brace
id|handle_t
op_star
id|handle
op_assign
id|journal_current_handle
c_func
(paren
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EROFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle
)paren
(brace
id|J_ASSERT
c_func
(paren
id|handle-&gt;h_transaction-&gt;t_journal
op_eq
id|journal
)paren
suffix:semicolon
id|handle-&gt;h_ref
op_increment
suffix:semicolon
r_return
id|handle
suffix:semicolon
)brace
id|handle
op_assign
id|jbd_kmalloc
c_func
(paren
r_sizeof
(paren
id|handle_t
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
(paren
id|handle
comma
l_int|0
comma
r_sizeof
(paren
id|handle_t
)paren
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_assign
id|nblocks
suffix:semicolon
id|handle-&gt;h_ref
op_assign
l_int|1
suffix:semicolon
id|current-&gt;journal_info
op_assign
id|handle
suffix:semicolon
id|err
op_assign
id|start_this_handle
c_func
(paren
id|journal
comma
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|handle
)paren
suffix:semicolon
id|current-&gt;journal_info
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|handle
suffix:semicolon
)brace
multiline_comment|/*&n; * Return zero on success&n; */
DECL|function|try_start_this_handle
r_static
r_int
id|try_start_this_handle
c_func
(paren
id|journal_t
op_star
id|journal
comma
id|handle_t
op_star
id|handle
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_int
id|needed
suffix:semicolon
r_int
id|nblocks
op_assign
id|handle-&gt;h_buffer_credits
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;New handle %p maybe going live.&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_journal_aborted
c_func
(paren
id|journal
)paren
op_logical_or
(paren
id|journal-&gt;j_errno
op_ne
l_int|0
op_logical_and
op_logical_neg
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_ACK_ERR
)paren
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|fail_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|journal-&gt;j_barrier_count
)paren
r_goto
id|fail_unlock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_running_transaction
op_logical_and
id|get_transaction
c_func
(paren
id|journal
comma
l_int|1
)paren
op_eq
l_int|0
)paren
r_goto
id|fail_unlock
suffix:semicolon
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
r_if
c_cond
(paren
id|transaction-&gt;t_state
op_eq
id|T_LOCKED
)paren
r_goto
id|fail_unlock
suffix:semicolon
id|needed
op_assign
id|transaction-&gt;t_outstanding_credits
op_plus
id|nblocks
suffix:semicolon
multiline_comment|/* We could run log_start_commit here */
r_if
c_cond
(paren
id|needed
OG
id|journal-&gt;j_max_transaction_buffers
)paren
r_goto
id|fail_unlock
suffix:semicolon
id|needed
op_assign
id|journal-&gt;j_max_transaction_buffers
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_committing_transaction
)paren
id|needed
op_add_assign
id|journal-&gt;j_committing_transaction
op_member_access_from_pointer
id|t_outstanding_credits
suffix:semicolon
r_if
c_cond
(paren
id|log_space_left
c_func
(paren
id|journal
)paren
OL
id|needed
)paren
r_goto
id|fail_unlock
suffix:semicolon
id|handle-&gt;h_transaction
op_assign
id|transaction
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_add_assign
id|nblocks
suffix:semicolon
id|transaction-&gt;t_updates
op_increment
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;Handle %p given %d credits (total %d, free %d)&bslash;n&quot;
comma
id|handle
comma
id|nblocks
comma
id|transaction-&gt;t_outstanding_credits
comma
id|log_space_left
c_func
(paren
id|journal
)paren
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail_unlock
suffix:colon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
id|ret
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to start a handle, but non-blockingly.  If we weren&squot;t able&n; * to, return an ERR_PTR value.&n; */
DECL|function|journal_try_start
id|handle_t
op_star
id|journal_try_start
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|nblocks
)paren
(brace
id|handle_t
op_star
id|handle
op_assign
id|journal_current_handle
c_func
(paren
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EROFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;h_ref %d -&gt; %d&bslash;n&quot;
comma
id|handle-&gt;h_ref
comma
id|handle-&gt;h_ref
op_plus
l_int|1
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|handle-&gt;h_transaction-&gt;t_journal
op_eq
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|handle-&gt;h_ref
op_increment
suffix:semicolon
r_return
id|handle
suffix:semicolon
)brace
r_else
(brace
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;no current transaction&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_journal_aborted
c_func
(paren
id|journal
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|handle
op_assign
id|jbd_kmalloc
c_func
(paren
r_sizeof
(paren
id|handle_t
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|memset
(paren
id|handle
comma
l_int|0
comma
r_sizeof
(paren
id|handle_t
)paren
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_assign
id|nblocks
suffix:semicolon
id|handle-&gt;h_ref
op_assign
l_int|1
suffix:semicolon
id|current-&gt;journal_info
op_assign
id|handle
suffix:semicolon
id|err
op_assign
id|try_start_this_handle
c_func
(paren
id|journal
comma
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|handle
)paren
suffix:semicolon
id|current-&gt;journal_info
op_assign
l_int|NULL
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|handle
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_extend: extend buffer credits.&n; *&n; * Some transactions, such as large extends and truncates, can be done&n; * atomically all at once or in several stages.  The operation requests&n; * a credit for a number of buffer modications in advance, but can&n; * extend its credit if it needs more.  &n; *&n; * journal_extend tries to give the running handle more buffer credits.&n; * It does not guarantee that allocation: this is a best-effort only.&n; * The calling process MUST be able to deal cleanly with a failure to&n; * extend here.&n; *&n; * Return 0 on success, non-zero on failure.&n; *&n; * return code &lt; 0 implies an error&n; * return code &gt; 0 implies normal transaction-full status.&n; */
DECL|function|journal_extend
r_int
id|journal_extend
(paren
id|handle_t
op_star
id|handle
comma
r_int
id|nblocks
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|wanted
suffix:semicolon
id|lock_journal
(paren
id|journal
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_goto
id|error_out
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Don&squot;t extend a locked-down transaction! */
r_if
c_cond
(paren
id|handle-&gt;h_transaction-&gt;t_state
op_ne
id|T_RUNNING
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;denied handle %p %d blocks: &quot;
l_string|&quot;transaction not running&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
id|wanted
op_assign
id|transaction-&gt;t_outstanding_credits
op_plus
id|nblocks
suffix:semicolon
r_if
c_cond
(paren
id|wanted
OG
id|journal-&gt;j_max_transaction_buffers
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;denied handle %p %d blocks: &quot;
l_string|&quot;transaction too large&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wanted
OG
id|log_space_left
c_func
(paren
id|journal
)paren
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;denied handle %p %d blocks: &quot;
l_string|&quot;insufficient log space&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
id|handle-&gt;h_buffer_credits
op_add_assign
id|nblocks
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_add_assign
id|nblocks
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;extended handle %p by %d&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
id|error_out
suffix:colon
id|unlock_journal
(paren
id|journal
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_restart: restart a handle for a multi-transaction filesystem&n; * operation.&n; *&n; * If the journal_extend() call above fails to grant new buffer credits&n; * to a running handle, a call to journal_restart will commit the&n; * handle&squot;s transaction so far and reattach the handle to a new&n; * transaction capabable of guaranteeing the requested number of&n; * credits.&n; */
DECL|function|journal_restart
r_int
id|journal_restart
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_int
id|nblocks
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* If we&squot;ve had an abort of any type, don&squot;t even think about&n;&t; * actually doing the restart! */
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* First unlink the handle from its current transaction, and&n;&t; * start the commit on that. */
id|J_ASSERT
(paren
id|transaction-&gt;t_updates
OG
l_int|0
)paren
suffix:semicolon
id|J_ASSERT
(paren
id|journal_current_handle
c_func
(paren
)paren
op_eq
id|handle
)paren
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_sub_assign
id|handle-&gt;h_buffer_credits
suffix:semicolon
id|transaction-&gt;t_updates
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction-&gt;t_updates
)paren
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;restarting handle %p&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|log_start_commit
c_func
(paren
id|journal
comma
id|transaction
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_assign
id|nblocks
suffix:semicolon
id|ret
op_assign
id|start_this_handle
c_func
(paren
id|journal
comma
id|handle
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* &n; * Barrier operation: establish a transaction barrier. &n; *&n; * This locks out any further updates from being started, and blocks&n; * until all existing updates have completed, returning only once the&n; * journal is in a quiescent state with no updates running.&n; *&n; * The journal lock should not be held on entry.&n; */
DECL|function|journal_lock_updates
r_void
id|journal_lock_updates
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
op_increment
id|journal-&gt;j_barrier_count
suffix:semicolon
multiline_comment|/* Wait until there are no running updates */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction-&gt;t_updates
)paren
r_break
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* We have now established a barrier against other normal&n;&t; * updates, but we also need to barrier against other&n;&t; * journal_lock_updates() calls to make sure that we serialise&n;&t; * special journal-locked operations too. */
id|down
c_func
(paren
op_amp
id|journal-&gt;j_barrier
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release a transaction barrier obtained with journal_lock_updates().&n; *&n; * Should be called without the journal lock held.&n; */
DECL|function|journal_unlock_updates
r_void
id|journal_unlock_updates
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|J_ASSERT
(paren
id|journal-&gt;j_barrier_count
op_ne
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|journal-&gt;j_barrier
)paren
suffix:semicolon
op_decrement
id|journal-&gt;j_barrier_count
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_get_write_access: notify intent to modify a buffer for metadata&n; * (not data) update.&n; *&n; * If the buffer is already part of the current transaction, then there&n; * is nothing we need to do.  If it is already part of a prior&n; * transaction which we are still committing to disk, then we need to&n; * make sure that we do not overwrite the old copy: we do copy-out to&n; * preserve the copy going to disk.  We also account the buffer against&n; * the handle&squot;s metadata buffer credits (unless the buffer is already&n; * part of the transaction, that is).&n; *&n; * Returns an error code or 0 on success.&n; *&n; * In full data journalling mode the buffer may be of type BJ_AsyncData,&n; * because we&squot;re write()ing a buffer which is also part of a shared mapping.&n; */
r_static
r_int
DECL|function|do_get_write_access
id|do_get_write_access
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|journal_head
op_star
id|jh
comma
r_int
id|force_copy
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_int
id|error
suffix:semicolon
r_char
op_star
id|frozen_buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
id|need_copy
op_assign
l_int|0
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;buffer_head %p, force_copy %d&bslash;n&quot;
comma
id|jh
comma
id|force_copy
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|repeat
suffix:colon
multiline_comment|/* @@@ Need to check for errors here at some point. */
multiline_comment|/*&n;&t; * AKPM: neither bdflush nor kupdate run with the BKL.   There&squot;s&n;&t; * nothing we can do to prevent them from starting writeout of a&n;&t; * BUF_DIRTY buffer at any time.  And checkpointing buffers are on&n;&t; * BUF_DIRTY.  So.  We no longer assert that the buffer is unlocked.&n;&t; *&n;&t; * However.  It is very wrong for us to allow ext3 to start directly&n;&t; * altering the -&gt;b_data of buffers which may at that very time be&n;&t; * undergoing writeout to the client filesystem.  This can leave&n;&t; * the filesystem in an inconsistent, transient state if we crash.&n;&t; * So what we do is to steal the buffer if it is in checkpoint&n;&t; * mode and dirty.  The journal lock will keep out checkpoint-mode&n;&t; * state transitions within journal_remove_checkpoint() and the buffer&n;&t; * is locked to keep bdflush/kupdate/whoever away from it as well.&n;&t; *&n;&t; * AKPM: we have replaced all the lock_journal_bh_wait() stuff with a&n;&t; * simple lock_journal().  This code here will care for locked buffers.&n;&t; */
multiline_comment|/*&n;&t; * The buffer_locked() || buffer_dirty() tests here are simply an&n;&t; * optimisation tweak.  If anyone else in the system decides to&n;&t; * lock this buffer later on, we&squot;ll blow up.  There doesn&squot;t seem&n;&t; * to be a good reason why they should do this.&n;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
op_logical_and
(paren
id|buffer_locked
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
op_logical_or
id|buffer_dirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
)paren
(brace
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
op_logical_and
id|buffer_dirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
(brace
multiline_comment|/* OK, we need to steal it */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;stealing from checkpoint mode&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_frozen_data
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|handle-&gt;h_buffer_credits
OG
l_int|0
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_decrement
suffix:semicolon
multiline_comment|/* This will clear BH_Dirty and set BH_JBDDirty. */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as BJ_Reserved&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Reserved
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The buffer is now hidden from bdflush.   It is&n;&t;&t;&t; * metadata against the current transaction.&n;&t;&t;&t; */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;steal from cp mode is complete&quot;
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|buffer_locked
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_goto
id|out_unlocked
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
multiline_comment|/* The buffer is already part of this transaction if&n;&t; * b_transaction or b_next_transaction points to it. */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_or
id|jh-&gt;b_next_transaction
op_eq
id|transaction
)paren
r_goto
id|done_locked
suffix:semicolon
multiline_comment|/* If there is already a copy-out version of this buffer, then&n;&t; * we don&squot;t need to make another one. */
r_if
c_cond
(paren
id|jh-&gt;b_frozen_data
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;has frozen data&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
id|transaction
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|handle-&gt;h_buffer_credits
OG
l_int|0
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_decrement
suffix:semicolon
r_goto
id|done_locked
suffix:semicolon
)brace
multiline_comment|/* Is there data here we need to preserve? */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_logical_and
id|jh-&gt;b_transaction
op_ne
id|transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;owned by older transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
multiline_comment|/* There is one case we have to be very careful about.&n;&t;&t; * If the committing transaction is currently writing&n;&t;&t; * this buffer out to disk and has NOT made a copy-out,&n;&t;&t; * then we cannot modify the buffer contents at all&n;&t;&t; * right now.  The essence of copy-out is that it is the&n;&t;&t; * extra copy, not the primary copy, which gets&n;&t;&t; * journaled.  If the primary copy is already going to&n;&t;&t; * disk then we cannot do copy-out here. */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|BJ_Shadow
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on shadow: sleep&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* commit wakes up all shadow buffers after IO */
id|sleep_on
c_func
(paren
op_amp
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_wait
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* Only do the copy if the currently-owning transaction&n;&t;&t; * still needs it.  If it is on the Forget list, the&n;&t;&t; * committing transaction is past that stage.  The&n;&t;&t; * buffer had better remain locked during the kmalloc,&n;&t;&t; * but that should be true --- we hold the journal lock&n;&t;&t; * still and the buffer is already on the BUF_JOURNAL&n;&t;&t; * list so won&squot;t be flushed. &n;&t;&t; *&n;&t;&t; * Subtle point, though: if this is a get_undo_access,&n;&t;&t; * then we will be relying on the frozen_data to contain&n;&t;&t; * the new value of the committed_data record after the&n;&t;&t; * transaction, so we HAVE to force the frozen_data copy&n;&t;&t; * in that case. */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_Forget
op_logical_or
id|force_copy
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;generate frozen data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frozen_buffer
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;allocate memory for buffer&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|frozen_buffer
op_assign
id|jbd_kmalloc
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frozen_buffer
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
id|__FUNCTION__
l_string|&quot;OOM for frozen_buffer&bslash;n&quot;
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;oom!&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_goto
id|done_locked
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
id|jh-&gt;b_frozen_data
op_assign
id|frozen_buffer
suffix:semicolon
id|frozen_buffer
op_assign
l_int|NULL
suffix:semicolon
id|need_copy
op_assign
l_int|1
suffix:semicolon
)brace
id|jh-&gt;b_next_transaction
op_assign
id|transaction
suffix:semicolon
)brace
id|J_ASSERT
c_func
(paren
id|handle-&gt;h_buffer_credits
OG
l_int|0
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_decrement
suffix:semicolon
multiline_comment|/* Finally, if the buffer is not journaled right now, we need to&n;&t; * make sure it doesn&squot;t get written to disk before the caller&n;&t; * actually commits the new data. */
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;no transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_next_transaction
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
id|transaction
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as BJ_Reserved&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Reserved
)paren
suffix:semicolon
)brace
id|done_locked
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_copy
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_char
op_star
id|source
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|buffer_uptodate
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
suffix:semicolon
id|page
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_page
suffix:semicolon
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_data
)paren
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|source
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|jh-&gt;b_frozen_data
comma
id|source
op_plus
id|offset
comma
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* If we are about to journal a buffer, then any revoke pending&n;           on it is no longer valid. */
id|journal_cancel_revoke
c_func
(paren
id|handle
comma
id|jh
)paren
suffix:semicolon
id|out_unlocked
suffix:colon
r_if
c_cond
(paren
id|frozen_buffer
)paren
id|kfree
c_func
(paren
id|frozen_buffer
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|journal_get_write_access
r_int
id|journal_get_write_access
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* We do not want to get caught playing with fields which the&n;&t; * log thread also manipulates.  Make sure that the buffer&n;&t; * completes any outstanding IO before proceeding. */
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|rc
op_assign
id|do_get_write_access
c_func
(paren
id|handle
comma
id|jh
comma
l_int|0
)paren
suffix:semicolon
id|journal_unlock_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * When the user wants to journal a newly created buffer_head&n; * (ie. getblk() returned a new buffer and we are going to populate it&n; * manually rather than reading off disk), then we need to keep the&n; * buffer_head locked until it has been completely filled with new&n; * data.  In this case, we should be able to make the assertion that&n; * the bh is not already part of an existing transaction.  &n; * &n; * The buffer should already be locked by the caller by this point.&n; * There is no lock ranking violation: it was a newly created,&n; * unlocked buffer beforehand. */
DECL|function|journal_get_create_access
r_int
id|journal_get_create_access
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;journal_head %p&bslash;n&quot;
comma
id|jh
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
multiline_comment|/* The buffer may already belong to this transaction due to&n;&t; * pre-zeroing in the filesystem&squot;s new_block code.  It may also&n;&t; * be on the previous, committing transaction&squot;s lists, but it&n;&t; * HAS to be in Forget state in that case: the transaction must&n;&t; * have deleted the buffer for it to be reused here. */
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
(paren
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_or
id|jh-&gt;b_transaction
op_eq
l_int|NULL
op_logical_or
(paren
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
op_logical_and
id|jh-&gt;b_jlist
op_eq
id|BJ_Forget
)paren
)paren
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|buffer_locked
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|handle-&gt;h_buffer_credits
OG
l_int|0
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_decrement
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
l_int|NULL
)paren
(brace
id|jh-&gt;b_transaction
op_assign
id|transaction
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as BJ_Reserved&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Reserved
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;set next transaction&quot;
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
id|transaction
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * akpm: I added this.  ext3_alloc_branch can pick up new indirect&n;&t; * blocks which contain freed but then revoked metadata.  We need&n;&t; * to cancel the revoke in case we end up freeing it yet again&n;&t; * and the reallocating as data - this would cause a second revoke,&n;&t; * which hits an assertion error.&n;&t; */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;cancelling revoke&quot;
)paren
suffix:semicolon
id|journal_cancel_revoke
c_func
(paren
id|handle
comma
id|jh
)paren
suffix:semicolon
id|journal_unlock_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_get_undo_access: Notify intent to modify metadata with non-&n; * rewindable consequences&n; *&n; * Sometimes there is a need to distinguish between metadata which has&n; * been committed to disk and that which has not.  The ext3fs code uses&n; * this for freeing and allocating space: we have to make sure that we&n; * do not reuse freed space until the deallocation has been committed,&n; * since if we overwrote that space we would make the delete&n; * un-rewindable in case of a crash.&n; * &n; * To deal with that, journal_get_undo_access requests write access to a&n; * buffer for parts of non-rewindable operations such as delete&n; * operations on the bitmaps.  The journaling code must keep a copy of&n; * the buffer&squot;s contents prior to the undo_access call until such time&n; * as we know that the buffer has definitely been committed to disk.&n; * &n; * We never need to know which transaction the committed data is part&n; * of: buffers touched here are guaranteed to be dirtied later and so&n; * will be committed to a new transaction in due course, at which point&n; * we can discard the old committed data pointer.&n; *&n; * Returns error number or 0 on success.  &n; */
DECL|function|journal_get_undo_access
r_int
id|journal_get_undo_access
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|handle-&gt;h_transaction-&gt;t_journal
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
multiline_comment|/* Do this first --- it can drop the journal lock, so we want to&n;&t; * make sure that obtaining the committed_data is done&n;&t; * atomically wrt. completion of any outstanding commits. */
id|err
op_assign
id|do_get_write_access
(paren
id|handle
comma
id|jh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_committed_data
)paren
(brace
multiline_comment|/* Copy out the current buffer contents into the&n;&t;&t; * preserved, committed copy. */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;generate b_committed data&quot;
)paren
suffix:semicolon
id|jh-&gt;b_committed_data
op_assign
id|jbd_kmalloc
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_committed_data
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
id|__FUNCTION__
l_string|&quot;: No memory for committed data!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memcpy
(paren
id|jh-&gt;b_committed_data
comma
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_data
comma
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_committed_data
)paren
suffix:semicolon
id|journal_unlock_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* &n; * journal_dirty_data: mark a buffer as containing dirty data which&n; * needs to be flushed before we can commit the current transaction.  &n; *&n; * The buffer is placed on the transaction&squot;s data list and is marked as&n; * belonging to the transaction.&n; *&n; * If `async&squot; is set then the writebask will be initiated by the caller&n; * using submit_bh -&gt; end_buffer_io_async.  We put the buffer onto&n; * t_async_datalist.&n; * &n; * Returns error number or 0 on success.  &n; *&n; * journal_dirty_data() can be called via page_launder-&gt;ext3_writepage&n; * by kswapd.  So it cannot block.  Happily, there&squot;s nothing here&n; * which needs lock_journal if `async&squot; is set.&n; *&n; * When the buffer is on the current transaction we freely move it&n; * between BJ_AsyncData and BJ_SyncData according to who tried to&n; * change its state last.&n; */
DECL|function|journal_dirty_data
r_int
id|journal_dirty_data
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|async
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|handle-&gt;h_transaction-&gt;t_journal
suffix:semicolon
r_int
id|need_brelse
op_assign
l_int|0
suffix:semicolon
r_int
id|wanted_jlist
op_assign
id|async
ques
c_cond
id|BJ_AsyncData
suffix:colon
id|BJ_SyncData
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The buffer could *already* be dirty.  Writeout can start&n;&t; * at any time.&n;&t; */
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;jh: %p, tid:%d&bslash;n&quot;
comma
id|jh
comma
id|handle-&gt;h_transaction-&gt;t_tid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * What if the buffer is already part of a running transaction?&n;&t; * &n;&t; * There are two cases:&n;&t; * 1) It is part of the current running transaction.  Refile it,&n;&t; *    just in case we have allocated it as metadata, deallocated&n;&t; *    it, then reallocated it as data. &n;&t; * 2) It is part of the previous, still-committing transaction.&n;&t; *    If all we want to do is to guarantee that the buffer will be&n;&t; *    written to disk before this new transaction commits, then&n;&t; *    being sure that the *previous* transaction has this same &n;&t; *    property is sufficient for us!  Just leave it on its old&n;&t; *    transaction.&n;&t; *&n;&t; * In case (2), the buffer must not already exist as metadata&n;&t; * --- that would violate write ordering (a transaction is free&n;&t; * to write its data at any point, even before the previous&n;&t; * committing transaction has committed).  The caller must&n;&t; * never, ever allow this to happen: there&squot;s nothing we can do&n;&t; * about it in this layer.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;has transaction&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
id|handle-&gt;h_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;belongs to older transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
multiline_comment|/* @@@ IS THIS TRUE  ? */
multiline_comment|/*&n;&t;&t;&t; * Not any more.  Scenario: someone does a write()&n;&t;&t;&t; * in data=journal mode.  The buffer&squot;s transaction has&n;&t;&t;&t; * moved into commit.  Then someone does another&n;&t;&t;&t; * write() to the file.  We do the frozen data copyout&n;&t;&t;&t; * and set b_next_transaction to point to j_running_t.&n;&t;&t;&t; * And while we&squot;re in that state, someone does a&n;&t;&t;&t; * writepage() in an attempt to pageout the same area&n;&t;&t;&t; * of the file via a shared mapping.  At present that&n;&t;&t;&t; * calls journal_dirty_data(), and we get right here.&n;&t;&t;&t; * It may be too late to journal the data.  Simply&n;&t;&t;&t; * falling through to the next test will suffice: the&n;&t;&t;&t; * data will be dirty and wil be checkpointed.  The&n;&t;&t;&t; * ordering comments in the next comment block still&n;&t;&t;&t; * apply.&n;&t;&t;&t; */
singleline_comment|//J_ASSERT_JH(jh, jh-&gt;b_next_transaction == NULL);
multiline_comment|/*&n;&t;&t;&t; * If we&squot;re journalling data, and this buffer was&n;&t;&t;&t; * subject to a write(), it could be metadata, forget&n;&t;&t;&t; * or shadow against the committing transaction.  Now,&n;&t;&t;&t; * someone has dirtied the same darn page via a mapping&n;&t;&t;&t; * and it is being writepage()&squot;d.&n;&t;&t;&t; * We *could* just steal the page from commit, with some&n;&t;&t;&t; * fancy locking there.  Instead, we just skip it -&n;&t;&t;&t; * don&squot;t tie the page&squot;s buffers to the new transaction&n;&t;&t;&t; * at all.&n;&t;&t;&t; * Implication: if we crash before the writepage() data&n;&t;&t;&t; * is written into the filesystem, recovery will replay&n;&t;&t;&t; * the write() data.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_None
op_logical_and
id|jh-&gt;b_jlist
op_ne
id|BJ_SyncData
op_logical_and
id|jh-&gt;b_jlist
op_ne
id|BJ_AsyncData
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;Not stealing&quot;
)paren
suffix:semicolon
r_goto
id|no_journal
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This buffer may be undergoing writeout in commit.  We&n;&t;&t;&t; * can&squot;t return from here and let the caller dirty it&n;&t;&t;&t; * again because that can cause the write-out loop in&n;&t;&t;&t; * commit to never terminate.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|async
op_logical_and
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|need_brelse
op_assign
l_int|1
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
multiline_comment|/* The buffer may become locked again at any&n;&t;&t;&t;&t;   time if it is redirtied */
)brace
multiline_comment|/* journal_clean_data_list() may have got there first */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
l_int|NULL
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;unfile from commit&quot;
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* The buffer will be refiled below */
)brace
multiline_comment|/*&n;&t;&t; * Special case --- the buffer might actually have been&n;&t;&t; * allocated and then immediately deallocated in the previous,&n;&t;&t; * committing transaction, so might still be left on that&n;&t;&t; * transaction&squot;s metadata lists.&n;&t;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|wanted_jlist
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;not on correct data list: unfile&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jlist
op_ne
id|BJ_Shadow
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
l_int|NULL
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as data&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|handle-&gt;h_transaction
comma
id|wanted_jlist
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;not on a transaction&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|handle-&gt;h_transaction
comma
id|wanted_jlist
)paren
suffix:semicolon
)brace
id|no_journal
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_brelse
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;brelse&quot;
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
id|journal_unlock_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * journal_dirty_metadata: mark a buffer as containing dirty metadata&n; * which needs to be journaled as part of the current transaction.&n; *&n; * The buffer is placed on the transaction&squot;s metadata list and is marked&n; * as belonging to the transaction.  &n; *&n; * Special care needs to be taken if the buffer already belongs to the&n; * current committing transaction (in which case we should have frozen&n; * data present for that commit).  In that case, we don&squot;t relink the&n; * buffer: that only gets done when the old transaction finally&n; * completes its commit.&n; * &n; * Returns error number or 0 on success.  &n; */
DECL|function|journal_dirty_metadata
r_int
id|journal_dirty_metadata
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;journal_head %p&bslash;n&quot;
comma
id|jh
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_JBDDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Metadata already on the current transaction list doesn&squot;t&n;&t; * need to be filed.  Metadata on another transaction&squot;s list must&n;&t; * be committing, and will be refiled once the commit completes:&n;&t; * leave it alone for now. &n;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
id|transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;already on other transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
id|transaction
)paren
suffix:semicolon
multiline_comment|/* And this case is illegal: we can&squot;t reuse another&n;&t;&t; * transaction&squot;s data buffer, ever. */
multiline_comment|/* FIXME: writepage() should be journalled */
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jlist
op_ne
id|BJ_SyncData
)paren
suffix:semicolon
r_goto
id|done_locked
suffix:semicolon
)brace
multiline_comment|/* That test should have eliminated the following case: */
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_frozen_data
op_eq
l_int|0
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as BJ_Metadata&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|handle-&gt;h_transaction
comma
id|BJ_Metadata
)paren
suffix:semicolon
id|done_locked
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* &n; * journal_release_buffer: undo a get_write_access without any buffer&n; * updates, if the update decided in the end that it didn&squot;t need access.&n; *&n; * journal_get_write_access() can block, so it is quite possible for a&n; * journaling component to decide after the write access is returned&n; * that global state has changed and the update is no longer required.  */
r_void
id|journal_release_buffer
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
multiline_comment|/* If the buffer is reserved but not modified by this&n;&t; * transaction, then it is safe to release it.  In all other&n;&t; * cases, just leave the buffer as it is. */
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|BJ_Reserved
op_logical_and
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_and
op_logical_neg
id|buffer_jdirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;unused: refiling it&quot;
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_increment
suffix:semicolon
id|__journal_refile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* &n; * journal_forget: bforget() for potentially-journaled buffers.  We can&n; * only do the bforget if there are no commits pending against the&n; * buffer.  If the buffer is dirty in the current running transaction we&n; * can safely unlink it. &n; *&n; * bh may not be a journalled buffer at all - it may be a non-JBD&n; * buffer which came off the hashtable.  Check for this.&n; *&n; * Decrements bh-&gt;b_count by one.&n; * &n; * Allow this call even if the handle has aborted --- it may be part of&n; * the caller&squot;s cleanup after an abort.&n; */
DECL|function|journal_forget
r_void
id|journal_forget
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
r_goto
id|not_jbd
suffix:semicolon
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
id|handle-&gt;h_transaction
)paren
(brace
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_frozen_data
)paren
suffix:semicolon
multiline_comment|/* If we are forgetting a buffer which is already part&n;&t;&t; * of this transaction, then we can just drop it from&n;&t;&t; * the transaction immediately. */
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_JBDDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;belongs to current transaction: unfile&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_committed_data
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t; * We are no longer going to journal this buffer.&n;&t;&t; * However, the commit of this transaction is still&n;&t;&t; * important to the buffer: the delete that we are now&n;&t;&t; * processing might obsolete an old log entry, so by&n;&t;&t; * committing, we can satisfy the buffer&squot;s checkpoint.&n;&t;&t; *&n;&t;&t; * So, if we have a checkpoint on the buffer, we should&n;&t;&t; * now refile the buffer on our BJ_Forget list so that&n;&t;&t; * we know to remove the checkpoint after we commit. &n;&t;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
)paren
(brace
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Forget
)paren
suffix:semicolon
)brace
r_else
(brace
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|__bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
(brace
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
(paren
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
)paren
suffix:semicolon
multiline_comment|/* However, if the buffer is still owned by a prior&n;&t;&t; * (committing) transaction, we can&squot;t drop it yet... */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;belongs to older transaction&quot;
)paren
suffix:semicolon
multiline_comment|/* ... but we CAN drop it from the new transaction if we&n;&t;&t; * have also modified it since the original commit. */
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
)paren
(brace
id|J_ASSERT
c_func
(paren
id|jh-&gt;b_next_transaction
op_eq
id|transaction
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|not_jbd
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 0&t;/* Unused */
multiline_comment|/*&n; * journal_sync_buffer: flush a potentially-journaled buffer to disk.&n; *&n; * Used for O_SYNC filesystem operations.  If the buffer is journaled,&n; * we need to complete the O_SYNC by waiting for the transaction to&n; * complete.  It is an error to call journal_sync_buffer before&n; * journal_stop!&n; */
r_void
id|journal_sync_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|sequence
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
multiline_comment|/* If the buffer isn&squot;t journaled, this is easy: just sync it to&n;&t; * disk.  */
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* If the buffer has already been journaled, then this&n;&t;&t; * is a noop. */
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|ll_rw_block
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Otherwise, just wait until the transaction is synced to disk. */
id|transaction
op_assign
id|jh-&gt;b_transaction
suffix:semicolon
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
id|sequence
op_assign
id|transaction-&gt;t_tid
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;requesting commit for jh %p&bslash;n&quot;
comma
id|jh
)paren
suffix:semicolon
id|log_start_commit
(paren
id|journal
comma
id|transaction
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tid_gt
c_func
(paren
id|sequence
comma
id|journal-&gt;j_commit_sequence
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|journal-&gt;j_wait_done_commit
)paren
suffix:semicolon
)brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * All done for a particular handle.&n; *&n; * There is not much action needed here.  We just return any remaining&n; * buffer credits to the transaction and remove the handle.  The only&n; * complication is that we need to start a commit operation if the&n; * filesystem is marked for synchronous update.&n; *&n; * journal_stop itself will not usually return an error, but it may&n; * do so in unusual circumstances.  In particular, expect it to &n; * return -EIO if a journal_abort has been executed since the&n; * transaction began.&n; */
DECL|function|journal_stop
r_int
id|journal_stop
c_func
(paren
id|handle_t
op_star
id|handle
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_int
id|old_handle_count
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
l_int|0
suffix:semicolon
id|J_ASSERT
(paren
id|transaction-&gt;t_updates
OG
l_int|0
)paren
suffix:semicolon
id|J_ASSERT
(paren
id|journal_current_handle
c_func
(paren
)paren
op_eq
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_else
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|handle-&gt;h_ref
OG
l_int|0
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;h_ref %d -&gt; %d&bslash;n&quot;
comma
id|handle-&gt;h_ref
op_plus
l_int|1
comma
id|handle-&gt;h_ref
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;Handle %p going down&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Implement synchronous transaction batching.  If the handle&n;&t; * was synchronous, don&squot;t force a commit immediately.  Let&squot;s&n;&t; * yield and let another thread piggyback onto this transaction.&n;&t; * Keep doing that while new threads continue to arrive.&n;&t; * It doesn&squot;t cost much - we&squot;re about to run a commit and sleep&n;&t; * on IO anyway.  Speeds up many-threaded, many-dir operations&n;&t; * by 30x or more...&n;&t; */
r_if
c_cond
(paren
id|handle-&gt;h_sync
)paren
(brace
r_do
(brace
id|old_handle_count
op_assign
id|transaction-&gt;t_handle_count
suffix:semicolon
id|yield
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|old_handle_count
op_ne
id|transaction-&gt;t_handle_count
)paren
suffix:semicolon
)brace
id|current-&gt;journal_info
op_assign
l_int|NULL
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_sub_assign
id|handle-&gt;h_buffer_credits
suffix:semicolon
id|transaction-&gt;t_updates
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction-&gt;t_updates
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_barrier_count
)paren
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * If the handle is marked SYNC, we need to set another commit&n;&t; * going!  We also want to force a commit if the current&n;&t; * transaction is occupying too much of the log, or if the&n;&t; * transaction is too old now.&n;&t; */
r_if
c_cond
(paren
id|handle-&gt;h_sync
op_logical_or
id|transaction-&gt;t_outstanding_credits
OG
id|journal-&gt;j_max_transaction_buffers
op_logical_or
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|transaction-&gt;t_expires
)paren
)paren
(brace
multiline_comment|/* Do this even for aborted journals: an abort still&n;&t;&t; * completes the commit thread, it just doesn&squot;t write&n;&t;&t; * anything to disk. */
id|tid_t
id|tid
op_assign
id|transaction-&gt;t_tid
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;transaction too old, requesting commit for &quot;
l_string|&quot;handle %p&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
multiline_comment|/* This is non-blocking */
id|log_start_commit
c_func
(paren
id|journal
comma
id|transaction
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Special case: JFS_SYNC synchronous updates require us&n;&t;&t; * to wait for the commit to complete.  &n;&t;&t; */
r_if
c_cond
(paren
id|handle-&gt;h_sync
op_logical_and
op_logical_neg
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
)paren
id|log_wait_commit
c_func
(paren
id|journal
comma
id|tid
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|handle
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * For synchronous operations: force any uncommitted trasnactions&n; * to disk.  May seem kludgy, but it reuses all the handle batching&n; * code in a very simple manner.&n; */
DECL|function|journal_force_commit
r_int
id|journal_force_commit
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|handle
op_assign
id|journal_start
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|journal_stop
c_func
(paren
id|handle
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * List management code snippets: various functions for manipulating the&n; * transaction buffer lists.&n; *&n; */
multiline_comment|/*&n; * Append a buffer to a transaction list, given the transaction&squot;s list head&n; * pointer.&n; * journal_datalist_lock is held.&n; */
r_static
r_inline
r_void
DECL|function|__blist_add_buffer
id|__blist_add_buffer
c_func
(paren
r_struct
id|journal_head
op_star
op_star
id|list
comma
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|list
)paren
(brace
id|jh-&gt;b_tnext
op_assign
id|jh-&gt;b_tprev
op_assign
id|jh
suffix:semicolon
op_star
id|list
op_assign
id|jh
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Insert at the tail of the list to preserve order */
r_struct
id|journal_head
op_star
id|first
op_assign
op_star
id|list
comma
op_star
id|last
op_assign
id|first-&gt;b_tprev
suffix:semicolon
id|jh-&gt;b_tprev
op_assign
id|last
suffix:semicolon
id|jh-&gt;b_tnext
op_assign
id|first
suffix:semicolon
id|last-&gt;b_tnext
op_assign
id|first-&gt;b_tprev
op_assign
id|jh
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Remove a buffer from a transaction list, given the transaction&squot;s list&n; * head pointer.&n; *&n; * Called with journal_datalist_lock held, and the journal may not&n; * be locked.&n; */
r_static
r_inline
r_void
DECL|function|__blist_del_buffer
id|__blist_del_buffer
c_func
(paren
r_struct
id|journal_head
op_star
op_star
id|list
comma
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_if
c_cond
(paren
op_star
id|list
op_eq
id|jh
)paren
(brace
op_star
id|list
op_assign
id|jh-&gt;b_tnext
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
op_eq
id|jh
)paren
op_star
id|list
op_assign
l_int|0
suffix:semicolon
)brace
id|jh-&gt;b_tprev-&gt;b_tnext
op_assign
id|jh-&gt;b_tnext
suffix:semicolon
id|jh-&gt;b_tnext-&gt;b_tprev
op_assign
id|jh-&gt;b_tprev
suffix:semicolon
)brace
multiline_comment|/* &n; * Remove a buffer from the appropriate transaction list.&n; *&n; * Note that this function can *change* the value of&n; * bh-&gt;b_transaction-&gt;t_sync_datalist, t_async_datalist, t_buffers, t_forget,&n; * t_iobuf_list, t_shadow_list, t_log_list or t_reserved_list.  If the caller&n; * is holding onto a copy of one of thee pointers, it could go bad.&n; * Generally the caller needs to re-read the pointer from the transaction_t.&n; *&n; * If bh-&gt;b_jlist is BJ_SyncData or BJ_AsyncData then we may have been called&n; * via journal_try_to_free_buffer() or journal_clean_data_list().  In that&n; * case, journal_datalist_lock will be held, and the journal may not be locked.&n; */
DECL|function|__journal_unfile_buffer
r_void
id|__journal_unfile_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_struct
id|journal_head
op_star
op_star
id|list
op_assign
l_int|0
suffix:semicolon
id|transaction_t
op_star
id|transaction
suffix:semicolon
id|assert_spin_locked
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|transaction
op_assign
id|jh-&gt;b_transaction
suffix:semicolon
macro_line|#ifdef __SMP__
id|J_ASSERT
(paren
id|current-&gt;lock_depth
op_ge
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jlist
OL
id|BJ_Types
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_None
)paren
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|transaction
op_ne
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|jh-&gt;b_jlist
)paren
(brace
r_case
id|BJ_None
suffix:colon
r_return
suffix:semicolon
r_case
id|BJ_SyncData
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_sync_datalist
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_AsyncData
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_async_datalist
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Metadata
suffix:colon
id|transaction-&gt;t_nr_buffers
op_decrement
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|transaction-&gt;t_nr_buffers
op_ge
l_int|0
)paren
suffix:semicolon
id|list
op_assign
op_amp
id|transaction-&gt;t_buffers
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Forget
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_forget
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_IO
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_iobuf_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Shadow
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_shadow_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_LogCtl
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_log_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Reserved
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_reserved_list
suffix:semicolon
r_break
suffix:semicolon
)brace
id|__blist_del_buffer
c_func
(paren
id|list
comma
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_jlist
op_assign
id|BJ_None
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|BH_JBDDirty
comma
op_amp
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_state
)paren
)paren
id|set_buffer_dirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
suffix:semicolon
)brace
DECL|function|journal_unfile_buffer
r_void
id|journal_unfile_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from journal_try_to_free_buffers().  The journal is not&n; * locked. lru_list_lock is not held.&n; *&n; * Here we see why journal_datalist_lock is global and not per-journal.&n; * We cannot get back to this buffer&squot;s journal pointer without locking&n; * out journal_clean_data_list() in some manner.&n; *&n; * One could use journal_datalist_lock to get unracy access to a&n; * per-journal lock.&n; *&n; * Called with journal_datalist_lock held.&n; *&n; * Returns non-zero iff we were able to free the journal_head.&n; */
DECL|function|__journal_try_to_free_buffer
r_static
r_int
id|__journal_try_to_free_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
op_star
id|locked_or_dirty
)paren
(brace
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
id|assert_spin_locked
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
op_star
id|locked_or_dirty
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
l_int|0
op_logical_and
id|jh-&gt;b_cp_transaction
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|BJ_SyncData
op_logical_or
id|jh-&gt;b_jlist
op_eq
id|BJ_AsyncData
)paren
(brace
multiline_comment|/* A written-back ordered data buffer */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;release data&quot;
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
l_int|0
suffix:semicolon
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
op_ne
l_int|0
op_logical_and
id|jh-&gt;b_transaction
op_eq
l_int|0
)paren
(brace
multiline_comment|/* written-back checkpointed metadata buffer */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|BJ_None
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;remove from checkpoint list&quot;
)paren
suffix:semicolon
id|__journal_remove_checkpoint
c_func
(paren
id|jh
)paren
suffix:semicolon
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_return
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_try_to_free_buffers().  For all the buffers on this page,&n; * if they are fully written out ordered data, move them onto BUF_CLEAN&n; * so try_to_free_buffers() can reap them.  Called with lru_list_lock&n; * not held.  Does its own locking.&n; *&n; * This complicates JBD locking somewhat.  We aren&squot;t protected by the&n; * BKL here.  We wish to remove the buffer from its committing or&n; * running transaction&squot;s -&gt;t_datalist via __journal_unfile_buffer.&n; *&n; * This may *change* the value of transaction_t-&gt;t_datalist, so anyone&n; * who looks at t_datalist needs to lock against this function.&n; *&n; * Even worse, someone may be doing a journal_dirty_data on this&n; * buffer.  So we need to lock against that.  journal_dirty_data()&n; * will come out of the lock with the buffer dirty, which makes it&n; * ineligible for release here.&n; *&n; * Who else is affected by this?  hmm...  Really the only contender&n; * is do_get_write_access() - it could be looking at the buffer while&n; * journal_try_to_free_buffer() is changing its state.  But that&n; * cannot happen because we never reallocate freed data as metadata&n; * while the data is part of a transaction.  Yes?&n; *&n; * This function returns non-zero if we wish try_to_free_buffers()&n; * to be called. We do this is the page is releasable by try_to_free_buffers().&n; * We also do it if the page has locked or dirty buffers and the caller wants&n; * us to perform sync or async writeout.&n; */
DECL|function|journal_try_to_free_buffers
r_int
id|journal_try_to_free_buffers
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|gfp_mask
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_int
id|locked_or_dirty
op_assign
l_int|0
suffix:semicolon
r_int
id|call_ttfb
op_assign
l_int|1
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|p
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_jbd
c_func
(paren
id|p
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|__journal_try_to_free_buffer
c_func
(paren
id|p
comma
op_amp
id|locked_or_dirty
)paren
)paren
id|call_ttfb
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|gfp_mask
op_amp
(paren
id|__GFP_IO
op_or
id|__GFP_WAIT
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|locked_or_dirty
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * The VM wants us to do writeout, or to block on IO, or both.&n;&t; * So we allow try_to_free_buffers to be called even if the page&n;&t; * still has journalled buffers.&n;&t; */
id|call_ttfb
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|call_ttfb
)paren
id|ret
op_assign
id|try_to_free_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This buffer is no longer needed.  If it is on an older transaction&squot;s&n; * checkpoint list we need to record it on this transaction&squot;s forget list&n; * to pin this buffer (and hence its checkpointing transaction) down until&n; * this transaction commits.  If the buffer isn&squot;t on a checkpoint list, we&n; * release it.&n; * Returns non-zero if JBD no longer has an interest in the buffer.&n; */
DECL|function|dispose_buffer
r_static
r_int
id|dispose_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
comma
id|transaction_t
op_star
id|transaction
)paren
(brace
r_int
id|may_free
op_assign
l_int|1
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on running+cp transaction&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Forget
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_JBDDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|may_free
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on running transaction&quot;
)paren
suffix:semicolon
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
r_return
id|may_free
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_flushpage &n; *&n; * This code is tricky.  It has a number of cases to deal with.&n; *&n; * There are two invariants which this code relies on:&n; *&n; * i_size must be updated on disk before we start calling flushpage on the&n; * data.&n; * &n; *  This is done in ext3 by defining an ext3_setattr method which&n; *  updates i_size before truncate gets going.  By maintaining this&n; *  invariant, we can be sure that it is safe to throw away any buffers&n; *  attached to the current transaction: once the transaction commits,&n; *  we know that the data will not be needed.&n; * &n; *  Note however that we can *not* throw away data belonging to the&n; *  previous, committing transaction!  &n; *&n; * Any disk blocks which *are* part of the previous, committing&n; * transaction (and which therefore cannot be discarded immediately) are&n; * not going to be reused in the new running transaction&n; *&n; *  The bitmap committed_data images guarantee this: any block which is&n; *  allocated in one transaction and removed in the next will be marked&n; *  as in-use in the committed_data bitmap, so cannot be reused until&n; *  the next transaction to delete the block commits.  This means that&n; *  leaving committing buffers dirty is quite safe: the disk blocks&n; *  cannot be reallocated to a different file and so buffer aliasing is&n; *  not possible.&n; *&n; *&n; * The above applies mainly to ordered data mode.  In writeback mode we&n; * don&squot;t make guarantees about the order in which data hits disk --- in&n; * particular we don&squot;t guarantee that new dirty data is flushed before&n; * transaction commit --- so it is always safe just to discard data&n; * immediately in that mode.  --sct &n; */
multiline_comment|/*&n; * The journal_unmap_buffer helper function returns zero if the buffer&n; * concerned remains pinned as an anonymous buffer belonging to an older&n; * transaction.&n; *&n; * We&squot;re outside-transaction here.  Either or both of j_running_transaction&n; * and j_committing_transaction may be NULL.&n; */
DECL|function|journal_unmap_buffer
r_static
r_int
id|journal_unmap_buffer
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
r_int
id|may_free
op_assign
l_int|1
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* It is safe to proceed here without the&n;&t; * journal_datalist_spinlock because the buffers cannot be&n;&t; * stolen by try_to_free_buffers as long as we are holding the&n;&t; * page lock. --sct */
r_if
c_cond
(paren
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
r_goto
id|zap_buffer
suffix:semicolon
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|transaction
op_assign
id|jh-&gt;b_transaction
suffix:semicolon
r_if
c_cond
(paren
id|transaction
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* First case: not on any transaction.  If it&n;&t;&t; * has no checkpoint link, then we can zap it:&n;&t;&t; * it&squot;s a writeback-mode buffer so we don&squot;t care&n;&t;&t; * if it hits disk safely. */
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_cp_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;not on any transaction: zap&quot;
)paren
suffix:semicolon
r_goto
id|zap_buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* bdflush has written it.  We can drop it now */
r_goto
id|zap_buffer
suffix:semicolon
)brace
multiline_comment|/* OK, it must be in the journal but still not&n;&t;&t; * written fully to disk: it&squot;s metadata or&n;&t;&t; * journaled data... */
r_if
c_cond
(paren
id|journal-&gt;j_running_transaction
)paren
(brace
multiline_comment|/* ... and once the current transaction has&n;&t;&t;&t; * committed, the buffer won&squot;t be needed any&n;&t;&t;&t; * longer. */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;checkpointed: add to BJ_Forget&quot;
)paren
suffix:semicolon
r_return
id|dispose_buffer
c_func
(paren
id|jh
comma
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is no currently-running transaction. So the&n;&t;&t;&t; * orphan record which we wrote for this file must have&n;&t;&t;&t; * passed into commit.  We must attach this buffer to&n;&t;&t;&t; * the committing transaction, if it exists. */
r_if
c_cond
(paren
id|journal-&gt;j_committing_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;give to committing trans&quot;
)paren
suffix:semicolon
r_return
id|dispose_buffer
c_func
(paren
id|jh
comma
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The orphan record&squot;s transaction has&n;&t;&t;&t;&t; * committed.  We can cleanse this buffer */
id|clear_bit
c_func
(paren
id|BH_JBDDirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_goto
id|zap_buffer
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
(brace
multiline_comment|/* If it is committing, we simply cannot touch it.  We&n;&t;&t; * can remove it&squot;s next_transaction pointer from the&n;&t;&t; * running transaction if that is set, but nothing&n;&t;&t; * else. */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on committing transaction&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
)paren
(brace
id|J_ASSERT
c_func
(paren
id|jh-&gt;b_next_transaction
op_eq
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Good, the buffer belongs to the running transaction.&n;&t;&t; * We are writing our own transaction&squot;s data, not any&n;&t;&t; * previous one&squot;s, so it is safe to throw it away&n;&t;&t; * (remember that we expect the filesystem to have set&n;&t;&t; * i_size already for this truncate so recovery will not&n;&t;&t; * expose the disk blocks we are discarding here.) */
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|transaction
op_eq
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
id|may_free
op_assign
id|dispose_buffer
c_func
(paren
id|jh
comma
id|transaction
)paren
suffix:semicolon
)brace
id|zap_buffer
suffix:colon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|J_ASSERT_BH
c_func
(paren
id|bh
comma
op_logical_neg
id|buffer_jdirty
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|clear_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_req
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_bdev
op_assign
l_int|NULL
suffix:semicolon
r_return
id|may_free
suffix:semicolon
)brace
multiline_comment|/*&n; * Return non-zero if the page&squot;s buffers were successfully reaped&n; */
DECL|function|journal_flushpage
r_int
id|journal_flushpage
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_int
r_int
id|curr_off
op_assign
l_int|0
suffix:semicolon
r_int
id|may_free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* We will potentially be playing with lists other than just the&n;&t; * data lists (especially for journaled data mode), so be&n;&t; * cautious in our locking. */
id|lock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
id|head
op_assign
id|bh
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|next_off
op_assign
id|curr_off
op_plus
id|bh-&gt;b_size
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
multiline_comment|/* AKPM: doing lock_buffer here may be overly paranoid */
r_if
c_cond
(paren
id|offset
op_le
id|curr_off
)paren
(brace
multiline_comment|/* This block is wholly outside the truncation point */
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|may_free
op_and_assign
id|journal_unmap_buffer
c_func
(paren
id|journal
comma
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|curr_off
op_assign
id|next_off
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
id|unlock_journal
c_func
(paren
id|journal
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|may_free
op_logical_or
op_logical_neg
id|try_to_free_buffers
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|J_ASSERT
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * File a buffer on the given transaction list. &n; */
DECL|function|__journal_file_buffer
r_void
id|__journal_file_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
comma
id|transaction_t
op_star
id|transaction
comma
r_int
id|jlist
)paren
(brace
r_struct
id|journal_head
op_star
op_star
id|list
op_assign
l_int|0
suffix:semicolon
id|assert_spin_locked
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
id|J_ASSERT
(paren
id|current-&gt;lock_depth
op_ge
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jlist
OL
id|BJ_Types
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_or
id|jh-&gt;b_transaction
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
(brace
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|jlist
)paren
r_return
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
)brace
r_else
(brace
id|jh-&gt;b_transaction
op_assign
id|transaction
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|jlist
)paren
(brace
r_case
id|BJ_None
suffix:colon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_committed_data
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_frozen_data
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|BJ_SyncData
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_sync_datalist
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_AsyncData
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_async_datalist
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Metadata
suffix:colon
id|transaction-&gt;t_nr_buffers
op_increment
suffix:semicolon
id|list
op_assign
op_amp
id|transaction-&gt;t_buffers
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Forget
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_forget
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_IO
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_iobuf_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Shadow
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_shadow_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_LogCtl
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_log_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Reserved
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_reserved_list
suffix:semicolon
r_break
suffix:semicolon
)brace
id|__blist_add_buffer
c_func
(paren
id|list
comma
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_jlist
op_assign
id|jlist
suffix:semicolon
r_if
c_cond
(paren
id|jlist
op_eq
id|BJ_Metadata
op_logical_or
id|jlist
op_eq
id|BJ_Reserved
op_logical_or
id|jlist
op_eq
id|BJ_Shadow
op_logical_or
id|jlist
op_eq
id|BJ_Forget
)paren
(brace
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JBDDirty
comma
op_amp
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|journal_file_buffer
r_void
id|journal_file_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
comma
id|transaction_t
op_star
id|transaction
comma
r_int
id|jlist
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|jlist
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Remove a buffer from its current buffer list in preparation for&n; * dropping it from its current transaction entirely.  If the buffer has&n; * already started to be used by a subsequent transaction, refile the&n; * buffer on that transaction&squot;s metadata list.&n; */
DECL|function|__journal_refile_buffer
r_void
id|__journal_refile_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
id|assert_spin_locked
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|current-&gt;lock_depth
op_ge
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
multiline_comment|/* If the buffer is now unused, just drop it.  If it has been&n;&t;   modified by a later transaction, add it to the new&n;&t;   transaction&squot;s metadata list. */
id|jh-&gt;b_transaction
op_assign
id|jh-&gt;b_next_transaction
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
l_int|NULL
)paren
(brace
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
comma
id|BJ_Metadata
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction-&gt;t_state
op_eq
id|T_RUNNING
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * For the unlocked version of this call, also make sure that any&n; * hanging journal_head is cleaned up if necessary.&n; *&n; * __journal_refile_buffer is usually called as part of a single locked&n; * operation on a buffer_head, in which the caller is probably going to&n; * be hooking the journal_head onto other lists.  In that case it is up&n; * to the caller to remove the journal_head if necessary.  For the&n; * unlocked journal_refile_buffer call, the caller isn&squot;t going to be&n; * doing anything else to the buffer so we need to do the cleanup&n; * ourselves to avoid a jh leak. &n; *&n; * *** The journal_head may be freed by this call! ***&n; */
DECL|function|journal_refile_buffer
r_void
id|journal_refile_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|__journal_refile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|__journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal_datalist_lock
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
eof
