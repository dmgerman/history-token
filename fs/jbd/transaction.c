multiline_comment|/*&n; * linux/fs/transaction.c&n; * &n; * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1998&n; *&n; * Copyright 1998 Red Hat corp --- All Rights Reserved&n; *&n; * This file is part of the Linux kernel and is made available under&n; * the terms of the GNU General Public License, version 2, or at your&n; * option, any later version, incorporated herein by reference.&n; *&n; * Generic filesystem transaction handling code; part of the ext2fs&n; * journaling system.  &n; *&n; * This file manages transactions (compound commits managed by the&n; * journaling code) and handles (individual atomic operations by the&n; * filesystem).&n; */
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/jbd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
multiline_comment|/*&n; * get_transaction: obtain a new transaction_t object.&n; *&n; * Simply allocate and initialise a new transaction.  Create it in&n; * RUNNING state and add it to the current journal (which should not&n; * have an existing running transaction: we only make a new transaction&n; * once we have started to commit the old one).&n; *&n; * Preconditions:&n; *&t;The journal MUST be locked.  We don&squot;t perform atomic mallocs on the&n; *&t;new transaction&t;and we can&squot;t block without protecting against other&n; *&t;processes trying to touch the journal while it is in transition.&n; *&n; * Called under j_state_lock&n; */
r_static
id|transaction_t
op_star
DECL|function|get_transaction
id|get_transaction
c_func
(paren
id|journal_t
op_star
id|journal
comma
id|transaction_t
op_star
id|transaction
)paren
(brace
id|transaction-&gt;t_journal
op_assign
id|journal
suffix:semicolon
id|transaction-&gt;t_state
op_assign
id|T_RUNNING
suffix:semicolon
id|transaction-&gt;t_tid
op_assign
id|journal-&gt;j_transaction_sequence
op_increment
suffix:semicolon
id|transaction-&gt;t_expires
op_assign
id|jiffies
op_plus
id|journal-&gt;j_commit_interval
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|transaction-&gt;t_jcb
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|transaction-&gt;t_jcb_lock
)paren
suffix:semicolon
multiline_comment|/* Set up the commit timer for the new transaction. */
id|journal-&gt;j_commit_timer-&gt;expires
op_assign
id|transaction-&gt;t_expires
suffix:semicolon
id|add_timer
c_func
(paren
id|journal-&gt;j_commit_timer
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_running_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|journal-&gt;j_running_transaction
op_assign
id|transaction
suffix:semicolon
r_return
id|transaction
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle management.&n; *&n; * A handle_t is an object which represents a single atomic update to a&n; * filesystem, and which tracks all of the modifications which form part&n; * of that one update.&n; */
multiline_comment|/*&n; * start_this_handle: Given a handle, deal with any locking or stalling&n; * needed to make sure that there is enough journal space for the handle&n; * to begin.  Attach the handle to a transaction and set up the&n; * transaction&squot;s buffer credits.  &n; */
DECL|function|start_this_handle
r_static
r_int
id|start_this_handle
c_func
(paren
id|journal_t
op_star
id|journal
comma
id|handle_t
op_star
id|handle
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_int
id|needed
suffix:semicolon
r_int
id|nblocks
op_assign
id|handle-&gt;h_buffer_credits
suffix:semicolon
id|transaction_t
op_star
id|new_transaction
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
OG
id|journal-&gt;j_max_transaction_buffers
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JBD: %s wants too many credits (%d &gt; %d)&bslash;n&quot;
comma
id|current-&gt;comm
comma
id|nblocks
comma
id|journal-&gt;j_max_transaction_buffers
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|alloc_transaction
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_running_transaction
)paren
(brace
id|new_transaction
op_assign
id|jbd_kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_transaction
)paren
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_transaction
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memset
c_func
(paren
id|new_transaction
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|new_transaction
)paren
)paren
suffix:semicolon
)brace
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;New handle %p going live.&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|repeat
suffix:colon
multiline_comment|/*&n;&t; * We need to hold j_state_lock until t_updates has been incremented,&n;&t; * for proper journal barrier handling&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|repeat_locked
suffix:colon
r_if
c_cond
(paren
id|is_journal_aborted
c_func
(paren
id|journal
)paren
op_logical_or
(paren
id|journal-&gt;j_errno
op_ne
l_int|0
op_logical_and
op_logical_neg
(paren
id|journal-&gt;j_flags
op_amp
id|JFS_ACK_ERR
)paren
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Wait on the journal&squot;s transaction barrier if necessary */
r_if
c_cond
(paren
id|journal-&gt;j_barrier_count
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|wait_event
c_func
(paren
id|journal-&gt;j_wait_transaction_locked
comma
id|journal-&gt;j_barrier_count
op_eq
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|journal-&gt;j_running_transaction
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|new_transaction
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
r_goto
id|alloc_transaction
suffix:semicolon
)brace
id|get_transaction
c_func
(paren
id|journal
comma
id|new_transaction
)paren
suffix:semicolon
id|new_transaction
op_assign
l_int|NULL
suffix:semicolon
)brace
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
multiline_comment|/*&n;&t; * If the current transaction is locked down for commit, wait for the&n;&t; * lock to be released.&n;&t; */
r_if
c_cond
(paren
id|transaction-&gt;t_state
op_eq
id|T_LOCKED
)paren
(brace
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
comma
op_amp
id|wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there is not enough space left in the log to write all potential&n;&t; * buffers requested by this operation, we need to stall pending a log&n;&t; * checkpoint to free some more log space.&n;&t; */
id|spin_lock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|needed
op_assign
id|transaction-&gt;t_outstanding_credits
op_plus
id|nblocks
suffix:semicolon
r_if
c_cond
(paren
id|needed
OG
id|journal-&gt;j_max_transaction_buffers
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the current transaction is already too large, then start&n;&t;&t; * to commit it: we can then go back and attach this handle to&n;&t;&t; * a new transaction.&n;&t;&t; */
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;Handle %p starting new commit...&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|prepare_to_wait
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
comma
op_amp
id|wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|__log_start_commit
c_func
(paren
id|journal
comma
id|transaction-&gt;t_tid
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
comma
op_amp
id|wait
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * The commit code assumes that it can get enough log space&n;&t; * without forcing a checkpoint.  This is *critical* for&n;&t; * correctness: a checkpoint of a buffer which is also&n;&t; * associated with a committing transaction creates a deadlock,&n;&t; * so commit simply cannot force through checkpoints.&n;&t; *&n;&t; * We must therefore ensure the necessary space in the journal&n;&t; * *before* starting to dirty potentially checkpointed buffers&n;&t; * in the new transaction. &n;&t; *&n;&t; * The worst part is, any transaction currently committing can&n;&t; * reduce the free space arbitrarily.  Be careful to account for&n;&t; * those buffers when checkpointing.&n;&t; */
multiline_comment|/*&n;&t; * @@@ AKPM: This seems rather over-defensive.  We&squot;re giving commit&n;&t; * a _lot_ of headroom: 1/4 of the journal plus the size of&n;&t; * the committing transaction.  Really, we only need to give it&n;&t; * committing_transaction-&gt;t_outstanding_credits plus &quot;enough&quot; for&n;&t; * the log control blocks.&n;&t; * Also, this test is inconsitent with the matching one in&n;&t; * journal_extend().&n;&t; */
r_if
c_cond
(paren
id|__log_space_left
c_func
(paren
id|journal
)paren
OL
id|jbd_space_needed
c_func
(paren
id|journal
)paren
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;Handle %p waiting for checkpoint...&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|__log_wait_for_space
c_func
(paren
id|journal
)paren
suffix:semicolon
r_goto
id|repeat_locked
suffix:semicolon
)brace
multiline_comment|/* OK, account for the buffers that this operation expects to&n;&t; * use and add the handle to the running transaction. */
id|handle-&gt;h_transaction
op_assign
id|transaction
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_add_assign
id|nblocks
suffix:semicolon
id|transaction-&gt;t_updates
op_increment
suffix:semicolon
id|transaction-&gt;t_handle_count
op_increment
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;Handle %p given %d credits (total %d, free %d)&bslash;n&quot;
comma
id|handle
comma
id|nblocks
comma
id|transaction-&gt;t_outstanding_credits
comma
id|__log_space_left
c_func
(paren
id|journal
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|new_transaction
)paren
id|kfree
c_func
(paren
id|new_transaction
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Allocate a new handle.  This should probably be in a slab... */
DECL|function|new_handle
r_static
id|handle_t
op_star
id|new_handle
c_func
(paren
r_int
id|nblocks
)paren
(brace
id|handle_t
op_star
id|handle
op_assign
id|jbd_alloc_handle
c_func
(paren
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|handle
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|handle
)paren
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_assign
id|nblocks
suffix:semicolon
id|handle-&gt;h_ref
op_assign
l_int|1
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|handle-&gt;h_jcb
)paren
suffix:semicolon
r_return
id|handle
suffix:semicolon
)brace
multiline_comment|/**&n; * handle_t *journal_start() - Obtain a new handle.  &n; * @journal: Journal to start transaction on.&n; * @nblocks: number of block buffer we might modify&n; *&n; * We make sure that the transaction can guarantee at least nblocks of&n; * modified buffers in the log.  We block until the log can guarantee&n; * that much space.  &n; *&n; * This function is visible to journal users (like ext3fs), so is not&n; * called with the journal already locked.&n; *&n; * Return a pointer to a newly allocated handle, or NULL on failure&n; */
DECL|function|journal_start
id|handle_t
op_star
id|journal_start
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_int
id|nblocks
)paren
(brace
id|handle_t
op_star
id|handle
op_assign
id|journal_current_handle
c_func
(paren
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|journal
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EROFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handle
)paren
(brace
id|J_ASSERT
c_func
(paren
id|handle-&gt;h_transaction-&gt;t_journal
op_eq
id|journal
)paren
suffix:semicolon
id|handle-&gt;h_ref
op_increment
suffix:semicolon
r_return
id|handle
suffix:semicolon
)brace
id|handle
op_assign
id|new_handle
c_func
(paren
id|nblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|current-&gt;journal_info
op_assign
id|handle
suffix:semicolon
id|err
op_assign
id|start_this_handle
c_func
(paren
id|journal
comma
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|jbd_free_handle
c_func
(paren
id|handle
)paren
suffix:semicolon
id|current-&gt;journal_info
op_assign
l_int|NULL
suffix:semicolon
id|handle
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
r_return
id|handle
suffix:semicolon
)brace
multiline_comment|/**&n; * int journal_extend() - extend buffer credits.&n; * @handle:  handle to &squot;extend&squot;&n; * @nblocks: nr blocks to try to extend by.&n; * &n; * Some transactions, such as large extends and truncates, can be done&n; * atomically all at once or in several stages.  The operation requests&n; * a credit for a number of buffer modications in advance, but can&n; * extend its credit if it needs more.  &n; *&n; * journal_extend tries to give the running handle more buffer credits.&n; * It does not guarantee that allocation - this is a best-effort only.&n; * The calling process MUST be able to deal cleanly with a failure to&n; * extend here.&n; *&n; * Return 0 on success, non-zero on failure.&n; *&n; * return code &lt; 0 implies an error&n; * return code &gt; 0 implies normal transaction-full status.&n; */
DECL|function|journal_extend
r_int
id|journal_extend
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_int
id|nblocks
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|wanted
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_goto
id|out
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t extend a locked-down transaction! */
r_if
c_cond
(paren
id|handle-&gt;h_transaction-&gt;t_state
op_ne
id|T_RUNNING
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;denied handle %p %d blocks: &quot;
l_string|&quot;transaction not running&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
r_goto
id|error_out
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|wanted
op_assign
id|transaction-&gt;t_outstanding_credits
op_plus
id|nblocks
suffix:semicolon
r_if
c_cond
(paren
id|wanted
OG
id|journal-&gt;j_max_transaction_buffers
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;denied handle %p %d blocks: &quot;
l_string|&quot;transaction too large&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wanted
OG
id|__log_space_left
c_func
(paren
id|journal
)paren
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;denied handle %p %d blocks: &quot;
l_string|&quot;insufficient log space&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
r_goto
id|unlock
suffix:semicolon
)brace
id|handle-&gt;h_buffer_credits
op_add_assign
id|nblocks
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_add_assign
id|nblocks
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|3
comma
l_string|&quot;extended handle %p by %d&bslash;n&quot;
comma
id|handle
comma
id|nblocks
)paren
suffix:semicolon
id|unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|error_out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * int journal_restart() - restart a handle .&n; * @handle:  handle to restart&n; * @nblocks: nr credits requested&n; * &n; * Restart a handle for a multi-transaction filesystem&n; * operation.&n; *&n; * If the journal_extend() call above fails to grant new buffer credits&n; * to a running handle, a call to journal_restart will commit the&n; * handle&squot;s transaction so far and reattach the handle to a new&n; * transaction capabable of guaranteeing the requested number of&n; * credits.&n; */
DECL|function|journal_restart
r_int
id|journal_restart
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_int
id|nblocks
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* If we&squot;ve had an abort of any type, don&squot;t even think about&n;&t; * actually doing the restart! */
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * First unlink the handle from its current transaction, and start the&n;&t; * commit on that.&n;&t; */
id|J_ASSERT
c_func
(paren
id|transaction-&gt;t_updates
OG
l_int|0
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal_current_handle
c_func
(paren
)paren
op_eq
id|handle
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_sub_assign
id|handle-&gt;h_buffer_credits
suffix:semicolon
id|transaction-&gt;t_updates
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction-&gt;t_updates
)paren
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;restarting handle %p&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
id|__log_start_commit
c_func
(paren
id|journal
comma
id|transaction-&gt;t_tid
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_assign
id|nblocks
suffix:semicolon
id|ret
op_assign
id|start_this_handle
c_func
(paren
id|journal
comma
id|handle
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * void journal_lock_updates () - establish a transaction barrier.&n; * @journal:  Journal to establish a barrier on.&n; *&n; * This locks out any further updates from being started, and blocks&n; * until all existing updates have completed, returning only once the&n; * journal is in a quiescent state with no updates running.&n; *&n; * The journal lock should not be held on entry.&n; */
DECL|function|journal_lock_updates
r_void
id|journal_lock_updates
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|DEFINE_WAIT
c_func
(paren
id|wait
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
op_increment
id|journal-&gt;j_barrier_count
suffix:semicolon
multiline_comment|/* Wait until there are no running updates */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|journal-&gt;j_running_transaction
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction
)paren
r_break
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction-&gt;t_updates
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prepare_to_wait
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
comma
op_amp
id|wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|finish_wait
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
comma
op_amp
id|wait
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have now established a barrier against other normal updates, but&n;&t; * we also need to barrier against other journal_lock_updates() calls&n;&t; * to make sure that we serialise special journal-locked operations&n;&t; * too.&n;&t; */
id|down
c_func
(paren
op_amp
id|journal-&gt;j_barrier
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * void journal_unlock_updates (journal_t* journal) - release barrier&n; * @journal:  Journal to release the barrier on.&n; * &n; * Release a transaction barrier obtained with journal_lock_updates().&n; *&n; * Should be called without the journal lock held.&n; */
DECL|function|journal_unlock_updates
r_void
id|journal_unlock_updates
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|J_ASSERT
c_func
(paren
id|journal-&gt;j_barrier_count
op_ne
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|journal-&gt;j_barrier
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
op_decrement
id|journal-&gt;j_barrier_count
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Report any unexpected dirty buffers which turn up.  Normally those&n; * indicate an error, but they can occur if the user is running (say)&n; * tune2fs to modify the live filesystem, so we need the option of&n; * continuing as gracefully as possible.  #&n; *&n; * The caller should already hold the journal lock and&n; * j_list_lock spinlock: most callers will need those anyway&n; * in order to probe the buffer&squot;s journaling state safely.&n; */
DECL|function|jbd_unexpected_dirty_buffer
r_static
r_void
id|jbd_unexpected_dirty_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
r_int
id|jlist
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* If this buffer is one which might reasonably be dirty&n;&t;&t; * --- ie. data, or not part of this journal --- then&n;&t;&t; * we&squot;re OK to leave it alone, but otherwise we need to&n;&t;&t; * move the dirty bit to the journal&squot;s own internal&n;&t;&t; * JBDDirty bit. */
id|jlist
op_assign
id|jh-&gt;b_jlist
suffix:semicolon
r_if
c_cond
(paren
id|jlist
op_eq
id|BJ_Metadata
op_logical_or
id|jlist
op_eq
id|BJ_Reserved
op_logical_or
id|jlist
op_eq
id|BJ_Shadow
op_logical_or
id|jlist
op_eq
id|BJ_Forget
)paren
(brace
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_JBDDirty
comma
op_amp
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * If the buffer is already part of the current transaction, then there&n; * is nothing we need to do.  If it is already part of a prior&n; * transaction which we are still committing to disk, then we need to&n; * make sure that we do not overwrite the old copy: we do copy-out to&n; * preserve the copy going to disk.  We also account the buffer against&n; * the handle&squot;s metadata buffer credits (unless the buffer is already&n; * part of the transaction, that is).&n; *&n; */
r_static
r_int
DECL|function|do_get_write_access
id|do_get_write_access
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|journal_head
op_star
id|jh
comma
r_int
id|force_copy
comma
r_int
op_star
id|credits
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|transaction_t
op_star
id|transaction
suffix:semicolon
id|journal_t
op_star
id|journal
suffix:semicolon
r_int
id|error
suffix:semicolon
r_char
op_star
id|frozen_buffer
op_assign
l_int|NULL
suffix:semicolon
r_int
id|need_copy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;buffer_head %p, force_copy %d&bslash;n&quot;
comma
id|jh
comma
id|force_copy
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|repeat
suffix:colon
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
multiline_comment|/* @@@ Need to check for errors here at some point. */
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* We now hold the buffer lock so it is safe to query the buffer&n;&t; * state.  Is the buffer dirty? &n;&t; * &n;&t; * If so, there are two possibilities.  The buffer may be&n;&t; * non-journaled, and undergoing a quite legitimate writeback.&n;&t; * Otherwise, it is journaled, and we don&squot;t expect dirty buffers&n;&t; * in that state (the buffers should be marked JBD_Dirty&n;&t; * instead.)  So either the IO is being done under our own&n;&t; * control and this is a bug, or it&squot;s a third party IO such as&n;&t; * dump(8) (which may leave the buffer scheduled for read ---&n;&t; * ie. locked but not dirty) or tune2fs (which may actually have&n;&t; * the buffer dirtied, ugh.)  */
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * First question: is this buffer already part of the current&n;&t;&t; * transaction or the existing committing transaction?&n;&t;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
(brace
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_or
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
)paren
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
id|transaction
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;Unexpected dirty buffer&quot;
)paren
suffix:semicolon
id|jbd_unexpected_dirty_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
)brace
)brace
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
(brace
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The buffer is already part of this transaction if b_transaction or&n;&t; * b_next_transaction points to it&n;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_or
id|jh-&gt;b_next_transaction
op_eq
id|transaction
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/*&n;&t; * If there is already a copy-out version of this buffer, then we don&squot;t&n;&t; * need to make another one&n;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_frozen_data
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;has frozen data&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
id|transaction
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|handle-&gt;h_buffer_credits
OG
l_int|0
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|credits
)paren
(paren
op_star
id|credits
)paren
op_increment
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Is there data here we need to preserve? */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_logical_and
id|jh-&gt;b_transaction
op_ne
id|transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;owned by older transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
multiline_comment|/* There is one case we have to be very careful about.&n;&t;&t; * If the committing transaction is currently writing&n;&t;&t; * this buffer out to disk and has NOT made a copy-out,&n;&t;&t; * then we cannot modify the buffer contents at all&n;&t;&t; * right now.  The essence of copy-out is that it is the&n;&t;&t; * extra copy, not the primary copy, which gets&n;&t;&t; * journaled.  If the primary copy is already going to&n;&t;&t; * disk then we cannot do copy-out here. */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|BJ_Shadow
)paren
(brace
id|DEFINE_WAIT_BIT
c_func
(paren
id|wait
comma
op_amp
id|bh-&gt;b_state
comma
id|BH_Unshadow
)paren
suffix:semicolon
id|wait_queue_head_t
op_star
id|wqh
suffix:semicolon
id|wqh
op_assign
id|bit_waitqueue
c_func
(paren
op_amp
id|bh-&gt;b_state
comma
id|BH_Unshadow
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on shadow: sleep&quot;
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* commit wakes up all shadow buffers after IO */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|prepare_to_wait
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_Shadow
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|finish_wait
c_func
(paren
id|wqh
comma
op_amp
id|wait.wait
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* Only do the copy if the currently-owning transaction&n;&t;&t; * still needs it.  If it is on the Forget list, the&n;&t;&t; * committing transaction is past that stage.  The&n;&t;&t; * buffer had better remain locked during the kmalloc,&n;&t;&t; * but that should be true --- we hold the journal lock&n;&t;&t; * still and the buffer is already on the BUF_JOURNAL&n;&t;&t; * list so won&squot;t be flushed. &n;&t;&t; *&n;&t;&t; * Subtle point, though: if this is a get_undo_access,&n;&t;&t; * then we will be relying on the frozen_data to contain&n;&t;&t; * the new value of the committed_data record after the&n;&t;&t; * transaction, so we HAVE to force the frozen_data copy&n;&t;&t; * in that case. */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_Forget
op_logical_or
id|force_copy
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;generate frozen data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frozen_buffer
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;allocate memory for buffer&quot;
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|frozen_buffer
op_assign
id|jbd_kmalloc
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frozen_buffer
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: OOM for frozen_buffer&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;oom!&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
id|jh-&gt;b_frozen_data
op_assign
id|frozen_buffer
suffix:semicolon
id|frozen_buffer
op_assign
l_int|NULL
suffix:semicolon
id|need_copy
op_assign
l_int|1
suffix:semicolon
)brace
id|jh-&gt;b_next_transaction
op_assign
id|transaction
suffix:semicolon
)brace
id|J_ASSERT
c_func
(paren
id|handle-&gt;h_buffer_credits
OG
l_int|0
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|credits
)paren
(paren
op_star
id|credits
)paren
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Finally, if the buffer is not journaled right now, we need to make&n;&t; * sure it doesn&squot;t get written to disk before the caller actually&n;&t; * commits the new data&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;no transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_next_transaction
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
id|transaction
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as BJ_Reserved&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Reserved
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|need_copy
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_char
op_star
id|source
suffix:semicolon
id|J_EXPECT_JH
c_func
(paren
id|jh
comma
id|buffer_uptodate
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
comma
l_string|&quot;Possible IO failure.&bslash;n&quot;
)paren
suffix:semicolon
id|page
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_page
suffix:semicolon
id|offset
op_assign
(paren
(paren
r_int
r_int
)paren
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_data
)paren
op_amp
op_complement
id|PAGE_MASK
suffix:semicolon
id|source
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|jh-&gt;b_frozen_data
comma
id|source
op_plus
id|offset
comma
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|source
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we are about to journal a buffer, then any revoke pending on it is&n;&t; * no longer valid&n;&t; */
id|journal_cancel_revoke
c_func
(paren
id|handle
comma
id|jh
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|frozen_buffer
)paren
id|kfree
c_func
(paren
id|frozen_buffer
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; * int journal_get_write_access() - notify intent to modify a buffer for metadata (not data) update.&n; * @handle: transaction to add buffer modifications to&n; * @bh:     bh to be used for metadata writes&n; *&n; * Returns an error code or 0 on success.&n; *&n; * In full data journalling mode the buffer may be of type BJ_AsyncData,&n; * because we&squot;re write()ing a buffer which is also part of a shared mapping.&n; */
DECL|function|journal_get_write_access
r_int
id|journal_get_write_access
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
op_star
id|credits
)paren
(brace
r_struct
id|journal_head
op_star
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* We do not want to get caught playing with fields which the&n;&t; * log thread also manipulates.  Make sure that the buffer&n;&t; * completes any outstanding IO before proceeding. */
id|rc
op_assign
id|do_get_write_access
c_func
(paren
id|handle
comma
id|jh
comma
l_int|0
comma
id|credits
)paren
suffix:semicolon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * When the user wants to journal a newly created buffer_head&n; * (ie. getblk() returned a new buffer and we are going to populate it&n; * manually rather than reading off disk), then we need to keep the&n; * buffer_head locked until it has been completely filled with new&n; * data.  In this case, we should be able to make the assertion that&n; * the bh is not already part of an existing transaction.  &n; * &n; * The buffer should already be locked by the caller by this point.&n; * There is no lock ranking violation: it was a newly created,&n; * unlocked buffer beforehand. */
multiline_comment|/**&n; * int journal_get_create_access () - notify intent to use newly created bh&n; * @handle: transaction to new buffer to&n; * @bh: new buffer.&n; *&n; * Call this if you create a new bh.&n; */
DECL|function|journal_get_create_access
r_int
id|journal_get_create_access
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
r_int
id|err
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;journal_head %p&bslash;n&quot;
comma
id|jh
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The buffer may already belong to this transaction due to pre-zeroing&n;&t; * in the filesystem&squot;s new_block code.  It may also be on the previous,&n;&t; * committing transaction&squot;s lists, but it HAS to be in Forget state in&n;&t; * that case: the transaction must have deleted the buffer for it to be&n;&t; * reused here.&n;&t; */
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
(paren
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_or
id|jh-&gt;b_transaction
op_eq
l_int|NULL
op_logical_or
(paren
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
op_logical_and
id|jh-&gt;b_jlist
op_eq
id|BJ_Forget
)paren
)paren
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|buffer_locked
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|handle-&gt;h_buffer_credits
OG
l_int|0
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
l_int|NULL
)paren
(brace
id|jh-&gt;b_transaction
op_assign
id|transaction
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as BJ_Reserved&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Reserved
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;set next transaction&quot;
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
id|transaction
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * akpm: I added this.  ext3_alloc_branch can pick up new indirect&n;&t; * blocks which contain freed but then revoked metadata.  We need&n;&t; * to cancel the revoke in case we end up freeing it yet again&n;&t; * and the reallocating as data - this would cause a second revoke,&n;&t; * which hits an assertion error.&n;&t; */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;cancelling revoke&quot;
)paren
suffix:semicolon
id|journal_cancel_revoke
c_func
(paren
id|handle
comma
id|jh
)paren
suffix:semicolon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * int journal_get_undo_access() -  Notify intent to modify metadata with&n; *     non-rewindable consequences&n; * @handle: transaction&n; * @bh: buffer to undo&n; * @credits: store the number of taken credits here (if not NULL)&n; *&n; * Sometimes there is a need to distinguish between metadata which has&n; * been committed to disk and that which has not.  The ext3fs code uses&n; * this for freeing and allocating space, we have to make sure that we&n; * do not reuse freed space until the deallocation has been committed,&n; * since if we overwrote that space we would make the delete&n; * un-rewindable in case of a crash.&n; * &n; * To deal with that, journal_get_undo_access requests write access to a&n; * buffer for parts of non-rewindable operations such as delete&n; * operations on the bitmaps.  The journaling code must keep a copy of&n; * the buffer&squot;s contents prior to the undo_access call until such time&n; * as we know that the buffer has definitely been committed to disk.&n; * &n; * We never need to know which transaction the committed data is part&n; * of, buffers touched here are guaranteed to be dirtied later and so&n; * will be committed to a new transaction in due course, at which point&n; * we can discard the old committed data pointer.&n; *&n; * Returns error number or 0 on success.&n; */
DECL|function|journal_get_undo_access
r_int
id|journal_get_undo_access
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
op_star
id|credits
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
r_char
op_star
id|committed_data
op_assign
l_int|NULL
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do this first --- it can drop the journal lock, so we want to&n;&t; * make sure that obtaining the committed_data is done&n;&t; * atomically wrt. completion of any outstanding commits.&n;&t; */
id|err
op_assign
id|do_get_write_access
c_func
(paren
id|handle
comma
id|jh
comma
l_int|1
comma
id|credits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_committed_data
)paren
(brace
id|committed_data
op_assign
id|jbd_kmalloc
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
op_member_access_from_pointer
id|b_size
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|committed_data
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;%s: No memory for committed data&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_committed_data
)paren
(brace
multiline_comment|/* Copy out the current buffer contents into the&n;&t;&t; * preserved, committed copy. */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;generate b_committed data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|committed_data
)paren
(brace
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|jh-&gt;b_committed_data
op_assign
id|committed_data
suffix:semicolon
id|committed_data
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|jh-&gt;b_committed_data
comma
id|bh-&gt;b_data
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
)brace
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|out
suffix:colon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|committed_data
)paren
id|kfree
c_func
(paren
id|committed_data
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/** &n; * int journal_dirty_data() -  mark a buffer as containing dirty data which&n; *                             needs to be flushed before we can commit the&n; *                             current transaction.  &n; * @handle: transaction&n; * @bh: bufferhead to mark&n; * &n; * The buffer is placed on the transaction&squot;s data list and is marked as&n; * belonging to the transaction.&n; *&n; * Returns error number or 0 on success.&n; *&n; * journal_dirty_data() can be called via page_launder-&gt;ext3_writepage&n; * by kswapd.&n; */
DECL|function|journal_dirty_data
r_int
id|journal_dirty_data
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|journal_t
op_star
id|journal
op_assign
id|handle-&gt;h_transaction-&gt;t_journal
suffix:semicolon
r_int
id|need_brelse
op_assign
l_int|0
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|jh
op_assign
id|journal_add_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The buffer could *already* be dirty.  Writeout can start&n;&t; * at any time.&n;&t; */
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;jh: %p, tid:%d&bslash;n&quot;
comma
id|jh
comma
id|handle-&gt;h_transaction-&gt;t_tid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * What if the buffer is already part of a running transaction?&n;&t; * &n;&t; * There are two cases:&n;&t; * 1) It is part of the current running transaction.  Refile it,&n;&t; *    just in case we have allocated it as metadata, deallocated&n;&t; *    it, then reallocated it as data. &n;&t; * 2) It is part of the previous, still-committing transaction.&n;&t; *    If all we want to do is to guarantee that the buffer will be&n;&t; *    written to disk before this new transaction commits, then&n;&t; *    being sure that the *previous* transaction has this same &n;&t; *    property is sufficient for us!  Just leave it on its old&n;&t; *    transaction.&n;&t; *&n;&t; * In case (2), the buffer must not already exist as metadata&n;&t; * --- that would violate write ordering (a transaction is free&n;&t; * to write its data at any point, even before the previous&n;&t; * committing transaction has committed).  The caller must&n;&t; * never, ever allow this to happen: there&squot;s nothing we can do&n;&t; * about it in this layer.&n;&t; */
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;has transaction&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
id|handle-&gt;h_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;belongs to older transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
multiline_comment|/* @@@ IS THIS TRUE  ? */
multiline_comment|/*&n;&t;&t;&t; * Not any more.  Scenario: someone does a write()&n;&t;&t;&t; * in data=journal mode.  The buffer&squot;s transaction has&n;&t;&t;&t; * moved into commit.  Then someone does another&n;&t;&t;&t; * write() to the file.  We do the frozen data copyout&n;&t;&t;&t; * and set b_next_transaction to point to j_running_t.&n;&t;&t;&t; * And while we&squot;re in that state, someone does a&n;&t;&t;&t; * writepage() in an attempt to pageout the same area&n;&t;&t;&t; * of the file via a shared mapping.  At present that&n;&t;&t;&t; * calls journal_dirty_data(), and we get right here.&n;&t;&t;&t; * It may be too late to journal the data.  Simply&n;&t;&t;&t; * falling through to the next test will suffice: the&n;&t;&t;&t; * data will be dirty and wil be checkpointed.  The&n;&t;&t;&t; * ordering comments in the next comment block still&n;&t;&t;&t; * apply.&n;&t;&t;&t; */
singleline_comment|//J_ASSERT_JH(jh, jh-&gt;b_next_transaction == NULL);
multiline_comment|/*&n;&t;&t;&t; * If we&squot;re journalling data, and this buffer was&n;&t;&t;&t; * subject to a write(), it could be metadata, forget&n;&t;&t;&t; * or shadow against the committing transaction.  Now,&n;&t;&t;&t; * someone has dirtied the same darn page via a mapping&n;&t;&t;&t; * and it is being writepage()&squot;d.&n;&t;&t;&t; * We *could* just steal the page from commit, with some&n;&t;&t;&t; * fancy locking there.  Instead, we just skip it -&n;&t;&t;&t; * don&squot;t tie the page&squot;s buffers to the new transaction&n;&t;&t;&t; * at all.&n;&t;&t;&t; * Implication: if we crash before the writepage() data&n;&t;&t;&t; * is written into the filesystem, recovery will replay&n;&t;&t;&t; * the write() data.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_None
op_logical_and
id|jh-&gt;b_jlist
op_ne
id|BJ_SyncData
op_logical_and
id|jh-&gt;b_jlist
op_ne
id|BJ_Locked
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;Not stealing&quot;
)paren
suffix:semicolon
r_goto
id|no_journal
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This buffer may be undergoing writeout in commit.  We&n;&t;&t;&t; * can&squot;t return from here and let the caller dirty it&n;&t;&t;&t; * again because that can cause the write-out loop in&n;&t;&t;&t; * commit to never terminate.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|need_brelse
op_assign
l_int|1
suffix:semicolon
id|sync_dirty_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
multiline_comment|/* The buffer may become locked again at any&n;&t;&t;&t;&t;   time if it is redirtied */
)brace
multiline_comment|/* journal_clean_data_list() may have got there first */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
l_int|NULL
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;unfile from commit&quot;
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
)brace
multiline_comment|/* The buffer will be refiled below */
)brace
multiline_comment|/*&n;&t;&t; * Special case --- the buffer might actually have been&n;&t;&t; * allocated and then immediately deallocated in the previous,&n;&t;&t; * committing transaction, so might still be left on that&n;&t;&t; * transaction&squot;s metadata lists.&n;&t;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_SyncData
op_logical_and
id|jh-&gt;b_jlist
op_ne
id|BJ_Locked
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;not on correct data list: unfile&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jlist
op_ne
id|BJ_Shadow
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as data&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|handle-&gt;h_transaction
comma
id|BJ_SyncData
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;not on a transaction&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|handle-&gt;h_transaction
comma
id|BJ_SyncData
)paren
suffix:semicolon
)brace
id|no_journal
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_brelse
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;brelse&quot;
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/** &n; * int journal_dirty_metadata() -  mark a buffer as containing dirty metadata&n; * @handle: transaction to add buffer to.&n; * @bh: buffer to mark &n; * &n; * mark dirty metadata which needs to be journaled as part of the current&n; * transaction.&n; *&n; * The buffer is placed on the transaction&squot;s metadata list and is marked&n; * as belonging to the transaction.  &n; *&n; * Returns error number or 0 on success.  &n; *&n; * Special care needs to be taken if the buffer already belongs to the&n; * current committing transaction (in which case we should have frozen&n; * data present for that commit).  In that case, we don&squot;t relink the&n; * buffer: that only gets done when the old transaction finally&n; * completes its commit.&n; */
DECL|function|journal_dirty_metadata
r_int
id|journal_dirty_metadata
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|5
comma
l_string|&quot;journal_head %p&bslash;n&quot;
comma
id|jh
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
r_goto
id|out
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * fastpath, to avoid expensive locking.  If this buffer is already&n;&t; * on the running transaction&squot;s metadata list there is nothing to do.&n;&t; * Nobody can take it off again because there is a handle open.&n;&t; * I _think_ we&squot;re OK here with SMP barriers - a mistaken decision will&n;&t; * result in this test being false, so we go in and take the locks.&n;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_and
id|jh-&gt;b_jlist
op_eq
id|BJ_Metadata
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;fastpath&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
r_goto
id|out_unlock_bh
suffix:semicolon
)brace
id|set_buffer_jbddirty
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Metadata already on the current transaction list doesn&squot;t&n;&t; * need to be filed.  Metadata on another transaction&squot;s list must&n;&t; * be committing, and will be refiled once the commit completes:&n;&t; * leave it alone for now. &n;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
id|transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;already on other transaction&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_next_transaction
op_eq
id|transaction
)paren
suffix:semicolon
multiline_comment|/* And this case is illegal: we can&squot;t reuse another&n;&t;&t; * transaction&squot;s data buffer, ever. */
r_goto
id|out_unlock_bh
suffix:semicolon
)brace
multiline_comment|/* That test should have eliminated the following case: */
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_frozen_data
op_eq
l_int|0
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;file as BJ_Metadata&quot;
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|handle-&gt;h_transaction
comma
id|BJ_Metadata
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|out_unlock_bh
suffix:colon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|out
suffix:colon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;exit&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * journal_release_buffer: undo a get_write_access without any buffer&n; * updates, if the update decided in the end that it didn&squot;t need access.&n; *&n; * The caller passes in the number of credits which should be put back for&n; * this buffer (zero or one).&n; *&n; * We leave the buffer attached to t_reserved_list because even though this&n; * handle doesn&squot;t want it, some other concurrent handle may want to journal&n; * this buffer.  If that handle is curently in between get_write_access() and&n; * journal_dirty_metadata() then it expects the buffer to be reserved.  If&n; * we were to rip it off t_reserved_list here, the other handle will explode&n; * when journal_dirty_metadata is presented with a non-reserved buffer.&n; *&n; * If nobody really wants to journal this buffer then it will be thrown&n; * away at the start of commit.&n; */
r_void
DECL|function|journal_release_buffer
id|journal_release_buffer
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|credits
)paren
(brace
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|handle-&gt;h_buffer_credits
op_add_assign
id|credits
suffix:semicolon
)brace
multiline_comment|/** &n; * void journal_forget() - bforget() for potentially-journaled buffers.&n; * @handle: transaction handle&n; * @bh:     bh to &squot;forget&squot;&n; *&n; * We can only do the bforget if there are no commits pending against the&n; * buffer.  If the buffer is dirty in the current running transaction we&n; * can safely unlink it. &n; *&n; * bh may not be a journalled buffer at all - it may be a non-JBD&n; * buffer which came off the hashtable.  Check for this.&n; *&n; * Decrements bh-&gt;b_count by one.&n; * &n; * Allow this call even if the handle has aborted --- it may be part of&n; * the caller&squot;s cleanup after an abort.&n; */
DECL|function|journal_forget
r_void
id|journal_forget
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
r_goto
id|not_jbd
suffix:semicolon
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_eq
id|handle-&gt;h_transaction
)paren
(brace
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_frozen_data
)paren
suffix:semicolon
multiline_comment|/* If we are forgetting a buffer which is already part&n;&t;&t; * of this transaction, then we can just drop it from&n;&t;&t; * the transaction immediately. */
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_jbddirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;belongs to current transaction: unfile&quot;
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_committed_data
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t; * We are no longer going to journal this buffer.&n;&t;&t; * However, the commit of this transaction is still&n;&t;&t; * important to the buffer: the delete that we are now&n;&t;&t; * processing might obsolete an old log entry, so by&n;&t;&t; * committing, we can satisfy the buffer&squot;s checkpoint.&n;&t;&t; *&n;&t;&t; * So, if we have a checkpoint on the buffer, we should&n;&t;&t; * now refile the buffer on our BJ_Forget list so that&n;&t;&t; * we know to remove the checkpoint after we commit. &n;&t;&t; */
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
)paren
(brace
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Forget
)paren
suffix:semicolon
)brace
r_else
(brace
id|journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
(brace
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
(paren
id|jh-&gt;b_transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
)paren
suffix:semicolon
multiline_comment|/* However, if the buffer is still owned by a prior&n;&t;&t; * (committing) transaction, we can&squot;t drop it yet... */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;belongs to older transaction&quot;
)paren
suffix:semicolon
multiline_comment|/* ... but we CAN drop it from the new transaction if we&n;&t;&t; * have also modified it since the original commit. */
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
)paren
(brace
id|J_ASSERT
c_func
(paren
id|jh-&gt;b_next_transaction
op_eq
id|transaction
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|not_jbd
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * void journal_callback_set() -  Register a callback function for this handle.&n; * @handle: handle to attach the callback to.&n; * @func: function to callback.&n; * @jcb:  structure with additional information required by func() , and&n; *        some space for jbd internal information.&n; * &n; * The function will be&n; * called when the transaction that this handle is part of has been&n; * committed to disk with the original callback data struct and the&n; * error status of the journal as parameters.  There is no guarantee of&n; * ordering between handles within a single transaction, nor between&n; * callbacks registered on the same handle.&n; *&n; * The caller is responsible for allocating the journal_callback struct.&n; * This is to allow the caller to add as much extra data to the callback&n; * as needed, but reduce the overhead of multiple allocations.  The caller&n; * allocated struct must start with a struct journal_callback at offset 0,&n; * and has the caller-specific data afterwards.&n; */
DECL|function|journal_callback_set
r_void
id|journal_callback_set
c_func
(paren
id|handle_t
op_star
id|handle
comma
r_void
(paren
op_star
id|func
)paren
(paren
r_struct
id|journal_callback
op_star
id|jcb
comma
r_int
id|error
)paren
comma
r_struct
id|journal_callback
op_star
id|jcb
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|handle-&gt;h_transaction-&gt;t_jcb_lock
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|jcb-&gt;jcb_list
comma
op_amp
id|handle-&gt;h_jcb
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|handle-&gt;h_transaction-&gt;t_jcb_lock
)paren
suffix:semicolon
id|jcb-&gt;jcb_func
op_assign
id|func
suffix:semicolon
)brace
multiline_comment|/**&n; * int journal_stop() - complete a transaction&n; * @handle: tranaction to complete.&n; * &n; * All done for a particular handle.&n; *&n; * There is not much action needed here.  We just return any remaining&n; * buffer credits to the transaction and remove the handle.  The only&n; * complication is that we need to start a commit operation if the&n; * filesystem is marked for synchronous update.&n; *&n; * journal_stop itself will not usually return an error, but it may&n; * do so in unusual circumstances.  In particular, expect it to &n; * return -EIO if a journal_abort has been executed since the&n; * transaction began.&n; */
DECL|function|journal_stop
r_int
id|journal_stop
c_func
(paren
id|handle_t
op_star
id|handle
)paren
(brace
id|transaction_t
op_star
id|transaction
op_assign
id|handle-&gt;h_transaction
suffix:semicolon
id|journal_t
op_star
id|journal
op_assign
id|transaction-&gt;t_journal
suffix:semicolon
r_int
id|old_handle_count
comma
id|err
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|transaction-&gt;t_updates
OG
l_int|0
)paren
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|journal_current_handle
c_func
(paren
)paren
op_eq
id|handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_handle_aborted
c_func
(paren
id|handle
)paren
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_else
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|handle-&gt;h_ref
OG
l_int|0
)paren
(brace
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;h_ref %d -&gt; %d&bslash;n&quot;
comma
id|handle-&gt;h_ref
op_plus
l_int|1
comma
id|handle-&gt;h_ref
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|jbd_debug
c_func
(paren
l_int|4
comma
l_string|&quot;Handle %p going down&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Implement synchronous transaction batching.  If the handle&n;&t; * was synchronous, don&squot;t force a commit immediately.  Let&squot;s&n;&t; * yield and let another thread piggyback onto this transaction.&n;&t; * Keep doing that while new threads continue to arrive.&n;&t; * It doesn&squot;t cost much - we&squot;re about to run a commit and sleep&n;&t; * on IO anyway.  Speeds up many-threaded, many-dir operations&n;&t; * by 30x or more...&n;&t; */
r_if
c_cond
(paren
id|handle-&gt;h_sync
)paren
(brace
r_do
(brace
id|old_handle_count
op_assign
id|transaction-&gt;t_handle_count
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|old_handle_count
op_ne
id|transaction-&gt;t_handle_count
)paren
suffix:semicolon
)brace
id|current-&gt;journal_info
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|transaction-&gt;t_outstanding_credits
op_sub_assign
id|handle-&gt;h_buffer_credits
suffix:semicolon
id|transaction-&gt;t_updates
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|transaction-&gt;t_updates
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_updates
)paren
suffix:semicolon
r_if
c_cond
(paren
id|journal-&gt;j_barrier_count
)paren
id|wake_up
c_func
(paren
op_amp
id|journal-&gt;j_wait_transaction_locked
)paren
suffix:semicolon
)brace
multiline_comment|/* Move callbacks from the handle to the transaction. */
id|spin_lock
c_func
(paren
op_amp
id|transaction-&gt;t_jcb_lock
)paren
suffix:semicolon
id|list_splice
c_func
(paren
op_amp
id|handle-&gt;h_jcb
comma
op_amp
id|transaction-&gt;t_jcb
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_jcb_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the handle is marked SYNC, we need to set another commit&n;&t; * going!  We also want to force a commit if the current&n;&t; * transaction is occupying too much of the log, or if the&n;&t; * transaction is too old now.&n;&t; */
r_if
c_cond
(paren
id|handle-&gt;h_sync
op_logical_or
id|transaction-&gt;t_outstanding_credits
OG
id|journal-&gt;j_max_transaction_buffers
op_logical_or
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|transaction-&gt;t_expires
)paren
)paren
(brace
multiline_comment|/* Do this even for aborted journals: an abort still&n;&t;&t; * completes the commit thread, it just doesn&squot;t write&n;&t;&t; * anything to disk. */
id|tid_t
id|tid
op_assign
id|transaction-&gt;t_tid
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|jbd_debug
c_func
(paren
l_int|2
comma
l_string|&quot;transaction too old, requesting commit for &quot;
l_string|&quot;handle %p&bslash;n&quot;
comma
id|handle
)paren
suffix:semicolon
multiline_comment|/* This is non-blocking */
id|__log_start_commit
c_func
(paren
id|journal
comma
id|transaction-&gt;t_tid
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Special case: JFS_SYNC synchronous updates require us&n;&t;&t; * to wait for the commit to complete.  &n;&t;&t; */
r_if
c_cond
(paren
id|handle-&gt;h_sync
op_logical_and
op_logical_neg
(paren
id|current-&gt;flags
op_amp
id|PF_MEMALLOC
)paren
)paren
id|err
op_assign
id|log_wait_commit
c_func
(paren
id|journal
comma
id|tid
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_handle_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
)brace
id|jbd_free_handle
c_func
(paren
id|handle
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**int journal_force_commit() - force any uncommitted transactions&n; * @journal: journal to force&n; *&n; * For synchronous operations: force any uncommitted transactions&n; * to disk.  May seem kludgy, but it reuses all the handle batching&n; * code in a very simple manner.&n; */
DECL|function|journal_force_commit
r_int
id|journal_force_commit
c_func
(paren
id|journal_t
op_star
id|journal
)paren
(brace
id|handle_t
op_star
id|handle
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|handle
op_assign
id|journal_start
c_func
(paren
id|journal
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|handle
)paren
)paren
(brace
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|handle
)paren
suffix:semicolon
)brace
r_else
(brace
id|handle-&gt;h_sync
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|journal_stop
c_func
(paren
id|handle
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * List management code snippets: various functions for manipulating the&n; * transaction buffer lists.&n; *&n; */
multiline_comment|/*&n; * Append a buffer to a transaction list, given the transaction&squot;s list head&n; * pointer.&n; *&n; * j_list_lock is held.&n; *&n; * jbd_lock_bh_state(jh2bh(jh)) is held.&n; */
r_static
r_inline
r_void
DECL|function|__blist_add_buffer
id|__blist_add_buffer
c_func
(paren
r_struct
id|journal_head
op_star
op_star
id|list
comma
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|list
)paren
(brace
id|jh-&gt;b_tnext
op_assign
id|jh-&gt;b_tprev
op_assign
id|jh
suffix:semicolon
op_star
id|list
op_assign
id|jh
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Insert at the tail of the list to preserve order */
r_struct
id|journal_head
op_star
id|first
op_assign
op_star
id|list
comma
op_star
id|last
op_assign
id|first-&gt;b_tprev
suffix:semicolon
id|jh-&gt;b_tprev
op_assign
id|last
suffix:semicolon
id|jh-&gt;b_tnext
op_assign
id|first
suffix:semicolon
id|last-&gt;b_tnext
op_assign
id|first-&gt;b_tprev
op_assign
id|jh
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Remove a buffer from a transaction list, given the transaction&squot;s list&n; * head pointer.&n; *&n; * Called with j_list_lock held, and the journal may not be locked.&n; *&n; * jbd_lock_bh_state(jh2bh(jh)) is held.&n; */
r_static
r_inline
r_void
DECL|function|__blist_del_buffer
id|__blist_del_buffer
c_func
(paren
r_struct
id|journal_head
op_star
op_star
id|list
comma
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_if
c_cond
(paren
op_star
id|list
op_eq
id|jh
)paren
(brace
op_star
id|list
op_assign
id|jh-&gt;b_tnext
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
op_eq
id|jh
)paren
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
)brace
id|jh-&gt;b_tprev-&gt;b_tnext
op_assign
id|jh-&gt;b_tnext
suffix:semicolon
id|jh-&gt;b_tnext-&gt;b_tprev
op_assign
id|jh-&gt;b_tprev
suffix:semicolon
)brace
multiline_comment|/* &n; * Remove a buffer from the appropriate transaction list.&n; *&n; * Note that this function can *change* the value of&n; * bh-&gt;b_transaction-&gt;t_sync_datalist, t_buffers, t_forget,&n; * t_iobuf_list, t_shadow_list, t_log_list or t_reserved_list.  If the caller&n; * is holding onto a copy of one of thee pointers, it could go bad.&n; * Generally the caller needs to re-read the pointer from the transaction_t.&n; *&n; * Called under j_list_lock.  The journal may not be locked.&n; */
DECL|function|__journal_unfile_buffer
r_void
id|__journal_unfile_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_struct
id|journal_head
op_star
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jbd_is_locked_bh_state
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|transaction
op_assign
id|jh-&gt;b_transaction
suffix:semicolon
r_if
c_cond
(paren
id|transaction
)paren
id|assert_spin_locked
c_func
(paren
op_amp
id|transaction-&gt;t_journal-&gt;j_list_lock
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jlist
OL
id|BJ_Types
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_ne
id|BJ_None
)paren
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|transaction
op_ne
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|jh-&gt;b_jlist
)paren
(brace
r_case
id|BJ_None
suffix:colon
r_goto
id|out
suffix:semicolon
r_case
id|BJ_SyncData
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_sync_datalist
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Metadata
suffix:colon
id|transaction-&gt;t_nr_buffers
op_decrement
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|transaction-&gt;t_nr_buffers
op_ge
l_int|0
)paren
suffix:semicolon
id|list
op_assign
op_amp
id|transaction-&gt;t_buffers
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Forget
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_forget
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_IO
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_iobuf_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Shadow
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_shadow_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_LogCtl
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_log_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Reserved
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_reserved_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Locked
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_locked_list
suffix:semicolon
r_break
suffix:semicolon
)brace
id|__blist_del_buffer
c_func
(paren
id|list
comma
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_jlist
op_assign
id|BJ_None
suffix:semicolon
r_if
c_cond
(paren
id|test_clear_buffer_jbddirty
c_func
(paren
id|bh
)paren
)paren
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Expose it to the VM */
id|out
suffix:colon
id|jh-&gt;b_transaction
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|journal_unfile_buffer
r_void
id|journal_unfile_buffer
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
id|jbd_lock_bh_state
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from journal_try_to_free_buffers().&n; *&n; * Called under jbd_lock_bh_state(bh)&n; */
r_static
r_void
DECL|function|__journal_try_to_free_buffer
id|__journal_try_to_free_buffer
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
id|jh
op_assign
id|bh2jh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_ne
l_int|0
op_logical_and
id|jh-&gt;b_cp_transaction
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|BJ_SyncData
op_logical_or
id|jh-&gt;b_jlist
op_eq
id|BJ_Locked
)paren
(brace
multiline_comment|/* A written-back ordered data buffer */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;release data&quot;
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
op_ne
l_int|0
op_logical_and
id|jh-&gt;b_transaction
op_eq
l_int|0
)paren
(brace
multiline_comment|/* written-back checkpointed metadata buffer */
r_if
c_cond
(paren
id|jh-&gt;b_jlist
op_eq
id|BJ_None
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;remove from checkpoint list&quot;
)paren
suffix:semicolon
id|__journal_remove_checkpoint
c_func
(paren
id|jh
)paren
suffix:semicolon
id|journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/** &n; * int journal_try_to_free_buffers() - try to free page buffers.&n; * @journal: journal for operation&n; * @page: to try and free&n; * @gfp_mask: &squot;IO&squot; mode for try_to_free_buffers()&n; *&n; * &n; * For all the buffers on this page,&n; * if they are fully written out ordered data, move them onto BUF_CLEAN&n; * so try_to_free_buffers() can reap them.&n; * &n; * This function returns non-zero if we wish try_to_free_buffers()&n; * to be called. We do this if the page is releasable by try_to_free_buffers().&n; * We also do it if the page has locked or dirty buffers and the caller wants&n; * us to perform sync or async writeout.&n; *&n; * This complicates JBD locking somewhat.  We aren&squot;t protected by the&n; * BKL here.  We wish to remove the buffer from its committing or&n; * running transaction&squot;s -&gt;t_datalist via __journal_unfile_buffer.&n; *&n; * This may *change* the value of transaction_t-&gt;t_datalist, so anyone&n; * who looks at t_datalist needs to lock against this function.&n; *&n; * Even worse, someone may be doing a journal_dirty_data on this&n; * buffer.  So we need to lock against that.  journal_dirty_data()&n; * will come out of the lock with the buffer dirty, which makes it&n; * ineligible for release here.&n; *&n; * Who else is affected by this?  hmm...  Really the only contender&n; * is do_get_write_access() - it could be looking at the buffer while&n; * journal_try_to_free_buffer() is changing its state.  But that&n; * cannot happen because we never reallocate freed data as metadata&n; * while the data is part of a transaction.  Yes?&n; */
DECL|function|journal_try_to_free_buffers
r_int
id|journal_try_to_free_buffers
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|unused_gfp_mask
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|J_ASSERT
c_func
(paren
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We take our own ref against the journal_head here to avoid&n;&t;&t; * having to add tons of locking around each instance of&n;&t;&t; * journal_remove_journal_head() and journal_put_journal_head().&n;&t;&t; */
id|jh
op_assign
id|journal_grab_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jh
)paren
r_continue
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__journal_try_to_free_buffer
c_func
(paren
id|journal
comma
id|bh
)paren
suffix:semicolon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
r_goto
id|busy
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
id|ret
op_assign
id|try_to_free_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|busy
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This buffer is no longer needed.  If it is on an older transaction&squot;s&n; * checkpoint list we need to record it on this transaction&squot;s forget list&n; * to pin this buffer (and hence its checkpointing transaction) down until&n; * this transaction commits.  If the buffer isn&squot;t on a checkpoint list, we&n; * release it.&n; * Returns non-zero if JBD no longer has an interest in the buffer.&n; *&n; * Called under j_list_lock.&n; *&n; * Called under jbd_lock_bh_state(bh).&n; */
DECL|function|__dispose_buffer
r_static
r_int
id|__dispose_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
comma
id|transaction_t
op_star
id|transaction
)paren
(brace
r_int
id|may_free
op_assign
l_int|1
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_cp_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on running+cp transaction&quot;
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|BJ_Forget
)paren
suffix:semicolon
id|clear_buffer_jbddirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|may_free
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on running transaction&quot;
)paren
suffix:semicolon
id|journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_return
id|may_free
suffix:semicolon
)brace
multiline_comment|/*&n; * journal_invalidatepage &n; *&n; * This code is tricky.  It has a number of cases to deal with.&n; *&n; * There are two invariants which this code relies on:&n; *&n; * i_size must be updated on disk before we start calling invalidatepage on the&n; * data.&n; * &n; *  This is done in ext3 by defining an ext3_setattr method which&n; *  updates i_size before truncate gets going.  By maintaining this&n; *  invariant, we can be sure that it is safe to throw away any buffers&n; *  attached to the current transaction: once the transaction commits,&n; *  we know that the data will not be needed.&n; * &n; *  Note however that we can *not* throw away data belonging to the&n; *  previous, committing transaction!  &n; *&n; * Any disk blocks which *are* part of the previous, committing&n; * transaction (and which therefore cannot be discarded immediately) are&n; * not going to be reused in the new running transaction&n; *&n; *  The bitmap committed_data images guarantee this: any block which is&n; *  allocated in one transaction and removed in the next will be marked&n; *  as in-use in the committed_data bitmap, so cannot be reused until&n; *  the next transaction to delete the block commits.  This means that&n; *  leaving committing buffers dirty is quite safe: the disk blocks&n; *  cannot be reallocated to a different file and so buffer aliasing is&n; *  not possible.&n; *&n; *&n; * The above applies mainly to ordered data mode.  In writeback mode we&n; * don&squot;t make guarantees about the order in which data hits disk --- in&n; * particular we don&squot;t guarantee that new dirty data is flushed before&n; * transaction commit --- so it is always safe just to discard data&n; * immediately in that mode.  --sct &n; */
multiline_comment|/*&n; * The journal_unmap_buffer helper function returns zero if the buffer&n; * concerned remains pinned as an anonymous buffer belonging to an older&n; * transaction.&n; *&n; * We&squot;re outside-transaction here.  Either or both of j_running_transaction&n; * and j_committing_transaction may be NULL.&n; */
DECL|function|journal_unmap_buffer
r_static
r_int
id|journal_unmap_buffer
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|transaction_t
op_star
id|transaction
suffix:semicolon
r_struct
id|journal_head
op_star
id|jh
suffix:semicolon
r_int
id|may_free
op_assign
l_int|1
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|BUFFER_TRACE
c_func
(paren
id|bh
comma
l_string|&quot;entry&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * It is safe to proceed here without the j_list_lock because the&n;&t; * buffers cannot be stolen by try_to_free_buffers as long as we are&n;&t; * holding the page lock. --sct&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_jbd
c_func
(paren
id|bh
)paren
)paren
r_goto
id|zap_buffer_unlocked
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jh
op_assign
id|journal_grab_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|jh
)paren
r_goto
id|zap_buffer_no_jh
suffix:semicolon
id|transaction
op_assign
id|jh-&gt;b_transaction
suffix:semicolon
r_if
c_cond
(paren
id|transaction
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* First case: not on any transaction.  If it&n;&t;&t; * has no checkpoint link, then we can zap it:&n;&t;&t; * it&squot;s a writeback-mode buffer so we don&squot;t care&n;&t;&t; * if it hits disk safely. */
r_if
c_cond
(paren
op_logical_neg
id|jh-&gt;b_cp_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;not on any transaction: zap&quot;
)paren
suffix:semicolon
r_goto
id|zap_buffer
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* bdflush has written it.  We can drop it now */
r_goto
id|zap_buffer
suffix:semicolon
)brace
multiline_comment|/* OK, it must be in the journal but still not&n;&t;&t; * written fully to disk: it&squot;s metadata or&n;&t;&t; * journaled data... */
r_if
c_cond
(paren
id|journal-&gt;j_running_transaction
)paren
(brace
multiline_comment|/* ... and once the current transaction has&n;&t;&t;&t; * committed, the buffer won&squot;t be needed any&n;&t;&t;&t; * longer. */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;checkpointed: add to BJ_Forget&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|__dispose_buffer
c_func
(paren
id|jh
comma
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is no currently-running transaction. So the&n;&t;&t;&t; * orphan record which we wrote for this file must have&n;&t;&t;&t; * passed into commit.  We must attach this buffer to&n;&t;&t;&t; * the committing transaction, if it exists. */
r_if
c_cond
(paren
id|journal-&gt;j_committing_transaction
)paren
(brace
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;give to committing trans&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|__dispose_buffer
c_func
(paren
id|jh
comma
id|journal-&gt;j_committing_transaction
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The orphan record&squot;s transaction has&n;&t;&t;&t;&t; * committed.  We can cleanse this buffer */
id|clear_buffer_jbddirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|zap_buffer
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|transaction
op_eq
id|journal-&gt;j_committing_transaction
)paren
(brace
multiline_comment|/* If it is committing, we simply cannot touch it.  We&n;&t;&t; * can remove it&squot;s next_transaction pointer from the&n;&t;&t; * running transaction if that is set, but nothing&n;&t;&t; * else. */
id|JBUFFER_TRACE
c_func
(paren
id|jh
comma
l_string|&quot;on committing transaction&quot;
)paren
suffix:semicolon
id|set_buffer_freed
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
)paren
(brace
id|J_ASSERT
c_func
(paren
id|jh-&gt;b_next_transaction
op_eq
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Good, the buffer belongs to the running transaction.&n;&t;&t; * We are writing our own transaction&squot;s data, not any&n;&t;&t; * previous one&squot;s, so it is safe to throw it away&n;&t;&t; * (remember that we expect the filesystem to have set&n;&t;&t; * i_size already for this truncate so recovery will not&n;&t;&t; * expose the disk blocks we are discarding here.) */
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|transaction
op_eq
id|journal-&gt;j_running_transaction
)paren
suffix:semicolon
id|may_free
op_assign
id|__dispose_buffer
c_func
(paren
id|jh
comma
id|transaction
)paren
suffix:semicolon
)brace
id|zap_buffer
suffix:colon
id|journal_put_journal_head
c_func
(paren
id|jh
)paren
suffix:semicolon
id|zap_buffer_no_jh
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_state_lock
)paren
suffix:semicolon
id|zap_buffer_unlocked
suffix:colon
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|J_ASSERT_BH
c_func
(paren
id|bh
comma
op_logical_neg
id|buffer_jbddirty
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|clear_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_req
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_bdev
op_assign
l_int|NULL
suffix:semicolon
r_return
id|may_free
suffix:semicolon
)brace
multiline_comment|/** &n; * int journal_invalidatepage() &n; * @journal: journal to use for flush... &n; * @page:    page to flush&n; * @offset:  length of page to invalidate.&n; *&n; * Reap page buffers containing data after offset in page.&n; *&n; * Return non-zero if the page&squot;s buffers were successfully reaped.&n; */
DECL|function|journal_invalidatepage
r_int
id|journal_invalidatepage
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_int
r_int
id|curr_off
op_assign
l_int|0
suffix:semicolon
r_int
id|may_free
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* We will potentially be playing with lists other than just the&n;&t; * data lists (especially for journaled data mode), so be&n;&t; * cautious in our locking. */
id|head
op_assign
id|bh
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|next_off
op_assign
id|curr_off
op_plus
id|bh-&gt;b_size
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
multiline_comment|/* AKPM: doing lock_buffer here may be overly paranoid */
r_if
c_cond
(paren
id|offset
op_le
id|curr_off
)paren
(brace
multiline_comment|/* This block is wholly outside the truncation point */
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|may_free
op_and_assign
id|journal_unmap_buffer
c_func
(paren
id|journal
comma
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|curr_off
op_assign
id|next_off
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|may_free
op_logical_or
op_logical_neg
id|try_to_free_buffers
c_func
(paren
id|page
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|J_ASSERT
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * File a buffer on the given transaction list. &n; */
DECL|function|__journal_file_buffer
r_void
id|__journal_file_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
comma
id|transaction_t
op_star
id|transaction
comma
r_int
id|jlist
)paren
(brace
r_struct
id|journal_head
op_star
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
r_int
id|was_dirty
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jbd_is_locked_bh_state
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|assert_spin_locked
c_func
(paren
op_amp
id|transaction-&gt;t_journal-&gt;j_list_lock
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_jlist
OL
id|BJ_Types
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
op_eq
id|transaction
op_logical_or
id|jh-&gt;b_transaction
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
op_logical_and
id|jh-&gt;b_jlist
op_eq
id|jlist
)paren
r_return
suffix:semicolon
multiline_comment|/* The following list of buffer states needs to be consistent&n;&t; * with __jbd_unexpected_dirty_buffer()&squot;s handling of dirty&n;&t; * state. */
r_if
c_cond
(paren
id|jlist
op_eq
id|BJ_Metadata
op_logical_or
id|jlist
op_eq
id|BJ_Reserved
op_logical_or
id|jlist
op_eq
id|BJ_Shadow
op_logical_or
id|jlist
op_eq
id|BJ_Forget
)paren
(brace
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
id|test_clear_buffer_jbddirty
c_func
(paren
id|bh
)paren
)paren
id|was_dirty
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
id|transaction
suffix:semicolon
r_switch
c_cond
(paren
id|jlist
)paren
(brace
r_case
id|BJ_None
suffix:colon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_committed_data
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
op_logical_neg
id|jh-&gt;b_frozen_data
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|BJ_SyncData
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_sync_datalist
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Metadata
suffix:colon
id|transaction-&gt;t_nr_buffers
op_increment
suffix:semicolon
id|list
op_assign
op_amp
id|transaction-&gt;t_buffers
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Forget
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_forget
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_IO
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_iobuf_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Shadow
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_shadow_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_LogCtl
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_log_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Reserved
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_reserved_list
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BJ_Locked
suffix:colon
id|list
op_assign
op_amp
id|transaction-&gt;t_locked_list
suffix:semicolon
r_break
suffix:semicolon
)brace
id|__blist_add_buffer
c_func
(paren
id|list
comma
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_jlist
op_assign
id|jlist
suffix:semicolon
r_if
c_cond
(paren
id|was_dirty
)paren
id|set_buffer_jbddirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|journal_file_buffer
r_void
id|journal_file_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
comma
id|transaction_t
op_star
id|transaction
comma
r_int
id|jlist
)paren
(brace
id|jbd_lock_bh_state
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|transaction-&gt;t_journal-&gt;j_list_lock
)paren
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|transaction
comma
id|jlist
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|transaction-&gt;t_journal-&gt;j_list_lock
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|jh2bh
c_func
(paren
id|jh
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Remove a buffer from its current buffer list in preparation for&n; * dropping it from its current transaction entirely.  If the buffer has&n; * already started to be used by a subsequent transaction, refile the&n; * buffer on that transaction&squot;s metadata list.&n; *&n; * Called under journal-&gt;j_list_lock&n; *&n; * Called under jbd_lock_bh_state(jh2bh(jh))&n; */
DECL|function|__journal_refile_buffer
r_void
id|__journal_refile_buffer
c_func
(paren
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_int
id|was_dirty
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jbd_is_locked_bh_state
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jh-&gt;b_transaction
)paren
id|assert_spin_locked
c_func
(paren
op_amp
id|jh-&gt;b_transaction-&gt;t_journal-&gt;j_list_lock
)paren
suffix:semicolon
multiline_comment|/* If the buffer is now unused, just drop it. */
r_if
c_cond
(paren
id|jh-&gt;b_next_transaction
op_eq
l_int|NULL
)paren
(brace
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It has been modified by a later transaction: add it to the new&n;&t; * transaction&squot;s metadata list.&n;&t; */
id|was_dirty
op_assign
id|test_clear_buffer_jbddirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__journal_unfile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jh-&gt;b_transaction
op_assign
id|jh-&gt;b_next_transaction
suffix:semicolon
id|jh-&gt;b_next_transaction
op_assign
l_int|NULL
suffix:semicolon
id|__journal_file_buffer
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction
comma
id|BJ_Metadata
)paren
suffix:semicolon
id|J_ASSERT_JH
c_func
(paren
id|jh
comma
id|jh-&gt;b_transaction-&gt;t_state
op_eq
id|T_RUNNING
)paren
suffix:semicolon
r_if
c_cond
(paren
id|was_dirty
)paren
id|set_buffer_jbddirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For the unlocked version of this call, also make sure that any&n; * hanging journal_head is cleaned up if necessary.&n; *&n; * __journal_refile_buffer is usually called as part of a single locked&n; * operation on a buffer_head, in which the caller is probably going to&n; * be hooking the journal_head onto other lists.  In that case it is up&n; * to the caller to remove the journal_head if necessary.  For the&n; * unlocked journal_refile_buffer call, the caller isn&squot;t going to be&n; * doing anything else to the buffer so we need to do the cleanup&n; * ourselves to avoid a jh leak. &n; *&n; * *** The journal_head may be freed by this call! ***&n; */
DECL|function|journal_refile_buffer
r_void
id|journal_refile_buffer
c_func
(paren
id|journal_t
op_star
id|journal
comma
r_struct
id|journal_head
op_star
id|jh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|jh2bh
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jbd_lock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|__journal_refile_buffer
c_func
(paren
id|jh
)paren
suffix:semicolon
id|jbd_unlock_bh_state
c_func
(paren
id|bh
)paren
suffix:semicolon
id|journal_remove_journal_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|journal-&gt;j_list_lock
)paren
suffix:semicolon
id|__brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
eof
