multiline_comment|/**&n; * ldm - Support for Windows Logical Disk Manager (Dynamic Disks)&n; *&n; * Copyright (C) 2001,2002 Richard Russon &lt;ldm@flatcap.org&gt;&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (C) 2001,2002 Jakob Kemi &lt;jakob.kemi@telia.com&gt;&n; *&n; * Documentation is available at http://linux-ntfs.sf.net/ldm&n; *&n; * This program is free software; you can redistribute it and/or modify it under&n; * the terms of the GNU General Public License as published by the Free Software&n; * Foundation; either version 2 of the License, or (at your option) any later&n; * version.&n; *&n; * This program is distributed in the hope that it will be useful, but WITHOUT&n; * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS&n; * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more&n; * details.&n; *&n; * You should have received a copy of the GNU General Public License along with&n; * this program (in the main directory of the source in the file COPYING); if&n; * not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,&n; * Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/stringify.h&gt;
macro_line|#include &quot;ldm.h&quot;
macro_line|#include &quot;check.h&quot;
macro_line|#include &quot;msdos.h&quot;
r_typedef
r_enum
(brace
DECL|enumerator|FALSE
id|FALSE
op_assign
l_int|0
comma
DECL|enumerator|TRUE
id|TRUE
op_assign
l_int|1
DECL|typedef|BOOL
)brace
id|BOOL
suffix:semicolon
multiline_comment|/**&n; * ldm_debug/info/error/crit - Output an error message&n; * @f:    A printf format string containing the message&n; * @...:  Variables to substitute into @f&n; *&n; * ldm_debug() writes a DEBUG level message to the syslog but only if the&n; * driver was compiled with debug enabled. Otherwise, the call turns into a NOP.&n; */
macro_line|#ifndef CONFIG_LDM_DEBUG
DECL|macro|ldm_debug
mdefine_line|#define ldm_debug(...)&t;do {} while (0)
macro_line|#else
DECL|macro|ldm_debug
mdefine_line|#define ldm_debug(f, a...) _ldm_printk (KERN_DEBUG, __FUNCTION__, f, ##a)
macro_line|#endif
DECL|macro|ldm_crit
mdefine_line|#define ldm_crit(f, a...)  _ldm_printk (KERN_CRIT,  __FUNCTION__, f, ##a)
DECL|macro|ldm_error
mdefine_line|#define ldm_error(f, a...) _ldm_printk (KERN_ERR,   __FUNCTION__, f, ##a)
DECL|macro|ldm_info
mdefine_line|#define ldm_info(f, a...)  _ldm_printk (KERN_INFO,  __FUNCTION__, f, ##a)
id|__attribute__
(paren
(paren
id|format
(paren
id|printf
comma
l_int|3
comma
l_int|4
)paren
)paren
)paren
DECL|function|_ldm_printk
r_static
r_void
id|_ldm_printk
(paren
r_const
r_char
op_star
id|level
comma
r_const
r_char
op_star
id|function
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|128
)braket
suffix:semicolon
id|va_list
id|args
suffix:semicolon
id|va_start
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
id|vsnprintf
(paren
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
id|fmt
comma
id|args
)paren
suffix:semicolon
id|va_end
(paren
id|args
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s%s(): %s&bslash;n&quot;
comma
id|level
comma
id|function
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_hexbyte - Convert a ASCII hex number to a byte&n; * @src:  Pointer to at least 2 characters to convert.&n; *&n; * Convert a two character ASCII hex string to a number.&n; *&n; * Return:  0-255  Success, the byte was parsed correctly&n; *          -1     Error, an invalid character was supplied&n; */
DECL|function|ldm_parse_hexbyte
r_static
r_int
id|ldm_parse_hexbyte
(paren
r_const
id|u8
op_star
id|src
)paren
(brace
r_int
r_int
id|x
suffix:semicolon
multiline_comment|/* For correct wrapping */
r_int
id|h
suffix:semicolon
multiline_comment|/* high part */
r_if
c_cond
(paren
(paren
id|x
op_assign
id|src
(braket
l_int|0
)braket
op_minus
l_char|&squot;0&squot;
)paren
op_le
l_char|&squot;9&squot;
op_minus
l_char|&squot;0&squot;
)paren
id|h
op_assign
id|x
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|x
op_assign
id|src
(braket
l_int|0
)braket
op_minus
l_char|&squot;a&squot;
)paren
op_le
l_char|&squot;f&squot;
op_minus
l_char|&squot;a&squot;
)paren
id|h
op_assign
id|x
op_plus
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|x
op_assign
id|src
(braket
l_int|0
)braket
op_minus
l_char|&squot;A&squot;
)paren
op_le
l_char|&squot;F&squot;
op_minus
l_char|&squot;A&squot;
)paren
id|h
op_assign
id|x
op_plus
l_int|10
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
id|h
op_lshift_assign
l_int|4
suffix:semicolon
multiline_comment|/* low part */
r_if
c_cond
(paren
(paren
id|x
op_assign
id|src
(braket
l_int|1
)braket
op_minus
l_char|&squot;0&squot;
)paren
op_le
l_char|&squot;9&squot;
op_minus
l_char|&squot;0&squot;
)paren
r_return
id|h
op_or
id|x
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|src
(braket
l_int|1
)braket
op_minus
l_char|&squot;a&squot;
)paren
op_le
l_char|&squot;f&squot;
op_minus
l_char|&squot;a&squot;
)paren
r_return
id|h
op_or
(paren
id|x
op_plus
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
op_assign
id|src
(braket
l_int|1
)braket
op_minus
l_char|&squot;A&squot;
)paren
op_le
l_char|&squot;F&squot;
op_minus
l_char|&squot;A&squot;
)paren
r_return
id|h
op_or
(paren
id|x
op_plus
l_int|10
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_guid - Convert GUID from ASCII to binary&n; * @src:   36 char string of the form fa50ff2b-f2e8-45de-83fa-65417f2f49ba&n; * @dest:  Memory block to hold binary GUID (16 bytes)&n; *&n; * N.B. The GUID need not be NULL terminated.&n; *&n; * Return:  TRUE   @dest contains binary GUID&n; *          FALSE  @dest contents are undefined&n; */
DECL|function|ldm_parse_guid
r_static
id|BOOL
id|ldm_parse_guid
(paren
r_const
id|u8
op_star
id|src
comma
id|u8
op_star
id|dest
)paren
(brace
r_static
r_const
r_int
id|size
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|6
)brace
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|v
suffix:semicolon
r_if
c_cond
(paren
id|src
(braket
l_int|8
)braket
op_ne
l_char|&squot;-&squot;
op_logical_or
id|src
(braket
l_int|13
)braket
op_ne
l_char|&squot;-&squot;
op_logical_or
id|src
(braket
l_int|18
)braket
op_ne
l_char|&squot;-&squot;
op_logical_or
id|src
(braket
l_int|23
)braket
op_ne
l_char|&squot;-&squot;
)paren
r_return
id|FALSE
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|5
suffix:semicolon
id|j
op_increment
comma
id|src
op_increment
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
(braket
id|j
)braket
suffix:semicolon
id|i
op_increment
comma
id|src
op_add_assign
l_int|2
comma
op_star
id|dest
op_increment
op_assign
id|v
)paren
r_if
c_cond
(paren
(paren
id|v
op_assign
id|ldm_parse_hexbyte
(paren
id|src
)paren
)paren
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_privhead - Read the LDM Database PRIVHEAD structure&n; * @data:  Raw database PRIVHEAD structure loaded from the device&n; * @ph:    In-memory privhead structure in which to return parsed information&n; *&n; * This parses the LDM database PRIVHEAD structure supplied in @data and&n; * sets up the in-memory privhead structure @ph with the obtained information.&n; *&n; * Return:  TRUE   @ph contains the PRIVHEAD data&n; *          FALSE  @ph contents are undefined&n; */
DECL|function|ldm_parse_privhead
r_static
id|BOOL
id|ldm_parse_privhead
(paren
r_const
id|u8
op_star
id|data
comma
r_struct
id|privhead
op_star
id|ph
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|data
op_logical_or
op_logical_neg
id|ph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAGIC_PRIVHEAD
op_ne
id|BE64
(paren
id|data
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;Cannot find PRIVHEAD structure. LDM database is&quot;
l_string|&quot; corrupt. Aborting.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ph-&gt;ver_major
op_assign
id|BE16
(paren
id|data
op_plus
l_int|0x000C
)paren
suffix:semicolon
id|ph-&gt;ver_minor
op_assign
id|BE16
(paren
id|data
op_plus
l_int|0x000E
)paren
suffix:semicolon
id|ph-&gt;logical_disk_start
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x011B
)paren
suffix:semicolon
id|ph-&gt;logical_disk_size
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x0123
)paren
suffix:semicolon
id|ph-&gt;config_start
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x012B
)paren
suffix:semicolon
id|ph-&gt;config_size
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x0133
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ph-&gt;ver_major
op_ne
l_int|2
)paren
op_logical_or
(paren
id|ph-&gt;ver_minor
op_ne
l_int|11
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;Expected PRIVHEAD version %d.%d, got %d.%d.&quot;
l_string|&quot; Aborting.&quot;
comma
l_int|2
comma
l_int|11
comma
id|ph-&gt;ver_major
comma
id|ph-&gt;ver_minor
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ph-&gt;config_size
op_ne
id|LDM_DB_SIZE
)paren
(brace
multiline_comment|/* 1 MiB in sectors. */
multiline_comment|/* Warn the user and continue, carefully */
id|ldm_info
(paren
l_string|&quot;Database is normally %u bytes, it claims to &quot;
l_string|&quot;be %llu bytes.&quot;
comma
id|LDM_DB_SIZE
comma
(paren
r_int
r_int
r_int
)paren
id|ph-&gt;config_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ph-&gt;logical_disk_size
op_eq
l_int|0
)paren
op_logical_or
(paren
id|ph-&gt;logical_disk_start
op_plus
id|ph-&gt;logical_disk_size
OG
id|ph-&gt;config_start
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;PRIVHEAD disk size doesn&squot;t match real disk size&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_parse_guid
(paren
id|data
op_plus
l_int|0x0030
comma
id|ph-&gt;disk_id
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;PRIVHEAD contains an invalid GUID.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ldm_debug
(paren
l_string|&quot;Parsed PRIVHEAD successfully.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_tocblock - Read the LDM Database TOCBLOCK structure&n; * @data:  Raw database TOCBLOCK structure loaded from the device&n; * @toc:   In-memory toc structure in which to return parsed information&n; *&n; * This parses the LDM Database TOCBLOCK (table of contents) structure supplied&n; * in @data and sets up the in-memory tocblock structure @toc with the obtained&n; * information.&n; *&n; * N.B.  The *_start and *_size values returned in @toc are not range-checked.&n; *&n; * Return:  TRUE   @toc contains the TOCBLOCK data&n; *          FALSE  @toc contents are undefined&n; */
DECL|function|ldm_parse_tocblock
r_static
id|BOOL
id|ldm_parse_tocblock
(paren
r_const
id|u8
op_star
id|data
comma
r_struct
id|tocblock
op_star
id|toc
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|data
op_logical_or
op_logical_neg
id|toc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAGIC_TOCBLOCK
op_ne
id|BE64
(paren
id|data
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Cannot find TOCBLOCK, database may be corrupt.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|strncpy
(paren
id|toc-&gt;bitmap1_name
comma
id|data
op_plus
l_int|0x24
comma
r_sizeof
(paren
id|toc-&gt;bitmap1_name
)paren
)paren
suffix:semicolon
id|toc-&gt;bitmap1_name
(braket
r_sizeof
(paren
id|toc-&gt;bitmap1_name
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|toc-&gt;bitmap1_start
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x2E
)paren
suffix:semicolon
id|toc-&gt;bitmap1_size
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x36
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|toc-&gt;bitmap1_name
comma
id|TOC_BITMAP1
comma
r_sizeof
(paren
id|toc-&gt;bitmap1_name
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;TOCBLOCK&squot;s first bitmap is &squot;%s&squot;, should be &squot;%s&squot;.&quot;
comma
id|TOC_BITMAP1
comma
id|toc-&gt;bitmap1_name
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|strncpy
(paren
id|toc-&gt;bitmap2_name
comma
id|data
op_plus
l_int|0x46
comma
r_sizeof
(paren
id|toc-&gt;bitmap2_name
)paren
)paren
suffix:semicolon
id|toc-&gt;bitmap2_name
(braket
r_sizeof
(paren
id|toc-&gt;bitmap2_name
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|toc-&gt;bitmap2_start
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x50
)paren
suffix:semicolon
id|toc-&gt;bitmap2_size
op_assign
id|BE64
(paren
id|data
op_plus
l_int|0x58
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|toc-&gt;bitmap2_name
comma
id|TOC_BITMAP2
comma
r_sizeof
(paren
id|toc-&gt;bitmap2_name
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;TOCBLOCK&squot;s second bitmap is &squot;%s&squot;, should be &squot;%s&squot;.&quot;
comma
id|TOC_BITMAP2
comma
id|toc-&gt;bitmap2_name
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|ldm_debug
(paren
l_string|&quot;Parsed TOCBLOCK successfully.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_vmdb - Read the LDM Database VMDB structure&n; * @data:  Raw database VMDB structure loaded from the device&n; * @vm:    In-memory vmdb structure in which to return parsed information&n; *&n; * This parses the LDM Database VMDB structure supplied in @data and sets up&n; * the in-memory vmdb structure @vm with the obtained information.&n; *&n; * N.B.  The *_start, *_size and *_seq values will be range-checked later.&n; *&n; * Return:  TRUE   @vm contains VMDB info&n; *          FALSE  @vm contents are undefined&n; */
DECL|function|ldm_parse_vmdb
r_static
id|BOOL
id|ldm_parse_vmdb
(paren
r_const
id|u8
op_star
id|data
comma
r_struct
id|vmdb
op_star
id|vm
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|data
op_logical_or
op_logical_neg
id|vm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAGIC_VMDB
op_ne
id|BE32
(paren
id|data
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Cannot find the VMDB, database may be corrupt.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vm-&gt;ver_major
op_assign
id|BE16
(paren
id|data
op_plus
l_int|0x12
)paren
suffix:semicolon
id|vm-&gt;ver_minor
op_assign
id|BE16
(paren
id|data
op_plus
l_int|0x14
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vm-&gt;ver_major
op_ne
l_int|4
)paren
op_logical_or
(paren
id|vm-&gt;ver_minor
op_ne
l_int|10
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;Expected VMDB version %d.%d, got %d.%d. &quot;
l_string|&quot;Aborting.&quot;
comma
l_int|4
comma
l_int|10
comma
id|vm-&gt;ver_major
comma
id|vm-&gt;ver_minor
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vm-&gt;vblk_size
op_assign
id|BE32
(paren
id|data
op_plus
l_int|0x08
)paren
suffix:semicolon
id|vm-&gt;vblk_offset
op_assign
id|BE32
(paren
id|data
op_plus
l_int|0x0C
)paren
suffix:semicolon
id|vm-&gt;last_vblk_seq
op_assign
id|BE32
(paren
id|data
op_plus
l_int|0x04
)paren
suffix:semicolon
id|ldm_debug
(paren
l_string|&quot;Parsed VMDB successfully.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_compare_privheads - Compare two privhead objects&n; * @ph1:  First privhead&n; * @ph2:  Second privhead&n; *&n; * This compares the two privhead structures @ph1 and @ph2.&n; *&n; * Return:  TRUE   Identical&n; *          FALSE  Different&n; */
DECL|function|ldm_compare_privheads
r_static
id|BOOL
id|ldm_compare_privheads
(paren
r_const
r_struct
id|privhead
op_star
id|ph1
comma
r_const
r_struct
id|privhead
op_star
id|ph2
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|ph1
op_logical_or
op_logical_neg
id|ph2
)paren
suffix:semicolon
r_return
(paren
(paren
id|ph1-&gt;ver_major
op_eq
id|ph2-&gt;ver_major
)paren
op_logical_and
(paren
id|ph1-&gt;ver_minor
op_eq
id|ph2-&gt;ver_minor
)paren
op_logical_and
(paren
id|ph1-&gt;logical_disk_start
op_eq
id|ph2-&gt;logical_disk_start
)paren
op_logical_and
(paren
id|ph1-&gt;logical_disk_size
op_eq
id|ph2-&gt;logical_disk_size
)paren
op_logical_and
(paren
id|ph1-&gt;config_start
op_eq
id|ph2-&gt;config_start
)paren
op_logical_and
(paren
id|ph1-&gt;config_size
op_eq
id|ph2-&gt;config_size
)paren
op_logical_and
op_logical_neg
id|memcmp
(paren
id|ph1-&gt;disk_id
comma
id|ph2-&gt;disk_id
comma
id|GUID_SIZE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_compare_tocblocks - Compare two tocblock objects&n; * @toc1:  First toc&n; * @toc2:  Second toc&n; *&n; * This compares the two tocblock structures @toc1 and @toc2.&n; *&n; * Return:  TRUE   Identical&n; *          FALSE  Different&n; */
DECL|function|ldm_compare_tocblocks
r_static
id|BOOL
id|ldm_compare_tocblocks
(paren
r_const
r_struct
id|tocblock
op_star
id|toc1
comma
r_const
r_struct
id|tocblock
op_star
id|toc2
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|toc1
op_logical_or
op_logical_neg
id|toc2
)paren
suffix:semicolon
r_return
(paren
(paren
id|toc1-&gt;bitmap1_start
op_eq
id|toc2-&gt;bitmap1_start
)paren
op_logical_and
(paren
id|toc1-&gt;bitmap1_size
op_eq
id|toc2-&gt;bitmap1_size
)paren
op_logical_and
(paren
id|toc1-&gt;bitmap2_start
op_eq
id|toc2-&gt;bitmap2_start
)paren
op_logical_and
(paren
id|toc1-&gt;bitmap2_size
op_eq
id|toc2-&gt;bitmap2_size
)paren
op_logical_and
op_logical_neg
id|strncmp
(paren
id|toc1-&gt;bitmap1_name
comma
id|toc2-&gt;bitmap1_name
comma
r_sizeof
(paren
id|toc1-&gt;bitmap1_name
)paren
)paren
op_logical_and
op_logical_neg
id|strncmp
(paren
id|toc1-&gt;bitmap2_name
comma
id|toc2-&gt;bitmap2_name
comma
r_sizeof
(paren
id|toc1-&gt;bitmap2_name
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_validate_privheads - Compare the primary privhead with its backups&n; * @bdev:  Device holding the LDM Database&n; * @ph1:   Memory struct to fill with ph contents&n; *&n; * Read and compare all three privheads from disk.&n; *&n; * The privheads on disk show the size and location of the main disk area and&n; * the configuration area (the database).  The values are range-checked against&n; * @hd, which contains the real size of the disk.&n; *&n; * Return:  TRUE   Success&n; *          FALSE  Error&n; */
DECL|function|ldm_validate_privheads
r_static
id|BOOL
id|ldm_validate_privheads
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_struct
id|privhead
op_star
id|ph1
)paren
(brace
r_static
r_const
r_int
id|off
(braket
l_int|3
)braket
op_assign
(brace
id|OFF_PRIV1
comma
id|OFF_PRIV2
comma
id|OFF_PRIV3
)brace
suffix:semicolon
r_struct
id|privhead
op_star
id|ph
(braket
l_int|3
)braket
op_assign
(brace
id|ph1
)brace
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
id|BOOL
id|result
op_assign
id|FALSE
suffix:semicolon
r_int
id|num_sects
suffix:semicolon
r_int
id|i
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|bdev
op_logical_or
op_logical_neg
id|ph1
)paren
suffix:semicolon
id|ph
(braket
l_int|1
)braket
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|ph
(braket
l_int|1
)braket
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|ph
(braket
l_int|2
)braket
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|ph
(braket
l_int|2
)braket
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ph
(braket
l_int|1
)braket
op_logical_or
op_logical_neg
id|ph
(braket
l_int|2
)braket
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Out of memory.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* off[1 &amp; 2] are relative to ph[0]-&gt;config_start */
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|config_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Read and parse privheads */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|read_dev_sector
(paren
id|bdev
comma
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|config_start
op_plus
id|off
(braket
id|i
)braket
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Disk read failed.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|result
op_assign
id|ldm_parse_privhead
(paren
id|data
comma
id|ph
(braket
id|i
)braket
)paren
suffix:semicolon
id|put_dev_sector
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|ldm_error
(paren
l_string|&quot;Cannot find PRIVHEAD %d.&quot;
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Log again */
r_if
c_cond
(paren
id|i
OL
l_int|2
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Already logged */
r_else
r_break
suffix:semicolon
multiline_comment|/* FIXME ignore for now, 3rd PH can fail on odd-sized disks */
)brace
)brace
id|num_sects
op_assign
id|bdev-&gt;bd_inode-&gt;i_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|config_start
OG
id|num_sects
)paren
op_logical_or
(paren
(paren
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|config_start
op_plus
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|config_size
)paren
OG
id|num_sects
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Database extends beyond the end of the disk.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|logical_disk_start
OG
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|config_start
)paren
op_logical_or
(paren
(paren
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|logical_disk_start
op_plus
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|logical_disk_size
)paren
OG
id|ph
(braket
l_int|0
)braket
op_member_access_from_pointer
id|config_start
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Disk and database overlap.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_compare_privheads
(paren
id|ph
(braket
l_int|0
)braket
comma
id|ph
(braket
l_int|1
)braket
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Primary and backup PRIVHEADs don&squot;t match.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* FIXME ignore this for now&n;&t;if (!ldm_compare_privheads (ph[0], ph[2])) {&n;&t;&t;ldm_crit (&quot;Primary and backup PRIVHEADs don&squot;t match.&quot;);&n;&t;&t;goto out;&n;&t;}*/
id|ldm_debug
(paren
l_string|&quot;Validated PRIVHEADs successfully.&quot;
)paren
suffix:semicolon
id|result
op_assign
id|TRUE
suffix:semicolon
id|out
suffix:colon
id|kfree
(paren
id|ph
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|ph
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_validate_tocblocks - Validate the table of contents and its backups&n; * @bdev:  Device holding the LDM Database&n; * @base:  Offset, into @bdev, of the database&n; * @ldb:   Cache of the database structures&n; *&n; * Find and compare the four tables of contents of the LDM Database stored on&n; * @bdev and return the parsed information into @toc1.&n; *&n; * The offsets and sizes of the configs are range-checked against a privhead.&n; *&n; * Return:  TRUE   @toc1 contains validated TOCBLOCK info&n; *          FALSE  @toc1 contents are undefined&n; */
DECL|function|ldm_validate_tocblocks
r_static
id|BOOL
id|ldm_validate_tocblocks
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
r_int
id|base
comma
r_struct
id|ldmdb
op_star
id|ldb
)paren
(brace
r_static
r_const
r_int
id|off
(braket
l_int|4
)braket
op_assign
(brace
id|OFF_TOCB1
comma
id|OFF_TOCB2
comma
id|OFF_TOCB3
comma
id|OFF_TOCB4
)brace
suffix:semicolon
r_struct
id|tocblock
op_star
id|tb
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|privhead
op_star
id|ph
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
id|BOOL
id|result
op_assign
id|FALSE
suffix:semicolon
r_int
id|i
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|bdev
op_logical_or
op_logical_neg
id|ldb
)paren
suffix:semicolon
id|ph
op_assign
op_amp
id|ldb-&gt;ph
suffix:semicolon
id|tb
(braket
l_int|0
)braket
op_assign
op_amp
id|ldb-&gt;toc
suffix:semicolon
id|tb
(braket
l_int|1
)braket
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|tb
(braket
l_int|1
)braket
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tb
(braket
l_int|2
)braket
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|tb
(braket
l_int|2
)braket
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tb
(braket
l_int|3
)braket
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|tb
(braket
l_int|3
)braket
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tb
(braket
l_int|1
)braket
op_logical_or
op_logical_neg
id|tb
(braket
l_int|2
)braket
op_logical_or
op_logical_neg
id|tb
(braket
l_int|3
)braket
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Out of memory.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* Read and parse all four toc&squot;s. */
(brace
id|data
op_assign
id|read_dev_sector
(paren
id|bdev
comma
id|base
op_plus
id|off
(braket
id|i
)braket
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Disk read failed.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|result
op_assign
id|ldm_parse_tocblock
(paren
id|data
comma
id|tb
(braket
id|i
)braket
)paren
suffix:semicolon
id|put_dev_sector
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Already logged */
)brace
multiline_comment|/* Range check the toc against a privhead. */
r_if
c_cond
(paren
(paren
(paren
id|tb
(braket
l_int|0
)braket
op_member_access_from_pointer
id|bitmap1_start
op_plus
id|tb
(braket
l_int|0
)braket
op_member_access_from_pointer
id|bitmap1_size
)paren
OG
id|ph-&gt;config_size
)paren
op_logical_or
(paren
(paren
id|tb
(braket
l_int|0
)braket
op_member_access_from_pointer
id|bitmap2_start
op_plus
id|tb
(braket
l_int|0
)braket
op_member_access_from_pointer
id|bitmap2_size
)paren
OG
id|ph-&gt;config_size
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;The bitmaps are out of range.  Giving up.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_compare_tocblocks
(paren
id|tb
(braket
l_int|0
)braket
comma
id|tb
(braket
l_int|1
)braket
)paren
op_logical_or
multiline_comment|/* Compare all tocs. */
op_logical_neg
id|ldm_compare_tocblocks
(paren
id|tb
(braket
l_int|0
)braket
comma
id|tb
(braket
l_int|2
)braket
)paren
op_logical_or
op_logical_neg
id|ldm_compare_tocblocks
(paren
id|tb
(braket
l_int|0
)braket
comma
id|tb
(braket
l_int|3
)braket
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;The TOCBLOCKs don&squot;t match.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ldm_debug
(paren
l_string|&quot;Validated TOCBLOCKs successfully.&quot;
)paren
suffix:semicolon
id|result
op_assign
id|TRUE
suffix:semicolon
id|out
suffix:colon
id|kfree
(paren
id|tb
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|tb
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|kfree
(paren
id|tb
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_validate_vmdb - Read the VMDB and validate it&n; * @bdev:  Device holding the LDM Database&n; * @base:  Offset, into @bdev, of the database&n; * @ldb:   Cache of the database structures&n; *&n; * Find the vmdb of the LDM Database stored on @bdev and return the parsed&n; * information in @ldb.&n; *&n; * Return:  TRUE   @ldb contains validated VBDB info&n; *          FALSE  @ldb contents are undefined&n; */
DECL|function|ldm_validate_vmdb
r_static
id|BOOL
id|ldm_validate_vmdb
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
r_int
id|base
comma
r_struct
id|ldmdb
op_star
id|ldb
)paren
(brace
id|Sector
id|sect
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
id|BOOL
id|result
op_assign
id|FALSE
suffix:semicolon
r_struct
id|vmdb
op_star
id|vm
suffix:semicolon
r_struct
id|tocblock
op_star
id|toc
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|bdev
op_logical_or
op_logical_neg
id|ldb
)paren
suffix:semicolon
id|vm
op_assign
op_amp
id|ldb-&gt;vm
suffix:semicolon
id|toc
op_assign
op_amp
id|ldb-&gt;toc
suffix:semicolon
id|data
op_assign
id|read_dev_sector
(paren
id|bdev
comma
id|base
op_plus
id|OFF_VMDB
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Disk read failed.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_parse_vmdb
(paren
id|data
comma
id|vm
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Already logged */
multiline_comment|/* Are there uncommitted transactions? */
r_if
c_cond
(paren
id|BE16
c_func
(paren
id|data
op_plus
l_int|0x10
)paren
op_ne
l_int|0x01
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Database is not in a consistent state.  Aborting.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vm-&gt;vblk_offset
op_ne
l_int|512
)paren
id|ldm_info
(paren
l_string|&quot;VBLKs start at offset 0x%04x.&quot;
comma
id|vm-&gt;vblk_offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The last_vblkd_seq can be before the end of the vmdb, just make sure&n;&t; * it is not out of bounds.&n;&t; */
r_if
c_cond
(paren
(paren
id|vm-&gt;vblk_size
op_star
id|vm-&gt;last_vblk_seq
)paren
OG
(paren
id|toc-&gt;bitmap1_size
op_lshift
l_int|9
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;VMDB exceeds allowed size specified by TOCBLOCK.  &quot;
l_string|&quot;Database is corrupt.  Aborting.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|result
op_assign
id|TRUE
suffix:semicolon
id|out
suffix:colon
id|put_dev_sector
(paren
id|sect
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_validate_partition_table - Determine whether bdev might be a dynamic disk&n; * @bdev:  Device holding the LDM Database&n; *&n; * This function provides a weak test to decide whether the device is a dynamic&n; * disk or not.  It looks for an MS-DOS-style partition table containing at&n; * least one partition of type 0x42 (formerly SFS, now used by Windows for&n; * dynamic disks).&n; *&n; * N.B.  The only possible error can come from the read_dev_sector and that is&n; *       only likely to happen if the underlying device is strange.  If that IS&n; *       the case we should return zero to let someone else try.&n; *&n; * Return:  TRUE   @bdev is a dynamic disk&n; *          FALSE  @bdev is not a dynamic disk, or an error occurred&n; */
DECL|function|ldm_validate_partition_table
r_static
id|BOOL
id|ldm_validate_partition_table
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
id|Sector
id|sect
suffix:semicolon
id|u8
op_star
id|data
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|BOOL
id|result
op_assign
id|FALSE
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|bdev
)paren
suffix:semicolon
id|data
op_assign
id|read_dev_sector
(paren
id|bdev
comma
l_int|0
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Disk read failed.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
(paren
id|u16
op_star
)paren
(paren
id|data
op_plus
l_int|0x01FE
)paren
op_ne
id|cpu_to_le16
(paren
id|MSDOS_LABEL_MAGIC
)paren
)paren
r_goto
id|out
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|data
op_plus
l_int|0x01BE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
id|SYS_IND
(paren
id|p
)paren
op_eq
id|WIN2K_DYNAMIC_PARTITION
)paren
(brace
id|result
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
id|ldm_debug
(paren
l_string|&quot;Found W2K dynamic disk partition type.&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|put_dev_sector
(paren
id|sect
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_get_disk_objid - Search a linked list of vblk&squot;s for a given Disk Id&n; * @ldb:  Cache of the database structures&n; *&n; * The LDM Database contains a list of all partitions on all dynamic disks.&n; * The primary PRIVHEAD, at the beginning of the physical disk, tells us&n; * the GUID of this disk.  This function searches for the GUID in a linked&n; * list of vblk&squot;s.&n; *&n; * Return:  Pointer, A matching vblk was found&n; *          NULL,    No match, or an error&n; */
DECL|function|ldm_get_disk_objid
r_static
r_struct
id|vblk
op_star
id|ldm_get_disk_objid
(paren
r_const
r_struct
id|ldmdb
op_star
id|ldb
)paren
(brace
r_struct
id|list_head
op_star
id|item
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|ldb
)paren
suffix:semicolon
id|list_for_each
(paren
id|item
comma
op_amp
id|ldb-&gt;v_disk
)paren
(brace
r_struct
id|vblk
op_star
id|v
op_assign
id|list_entry
(paren
id|item
comma
r_struct
id|vblk
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
(paren
id|v-&gt;vblk.disk.disk_id
comma
id|ldb-&gt;ph.disk_id
comma
id|GUID_SIZE
)paren
)paren
r_return
id|v
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_create_data_partitions - Create data partitions for this device&n; * @pp:   List of the partitions parsed so far&n; * @ldb:  Cache of the database structures&n; *&n; * The database contains ALL the partitions for ALL disk groups, so we need to&n; * filter out this specific disk. Using the disk&squot;s object id, we can find all&n; * the partitions in the database that belong to this disk.&n; *&n; * Add each partition in our database, to the parsed_partitions structure.&n; *&n; * N.B.  This function creates the partitions in the order it finds partition&n; *       objects in the linked list.&n; *&n; * Return:  TRUE   Partition created&n; *          FALSE  Error, probably a range checking problem&n; */
DECL|function|ldm_create_data_partitions
r_static
id|BOOL
id|ldm_create_data_partitions
(paren
r_struct
id|parsed_partitions
op_star
id|pp
comma
r_const
r_struct
id|ldmdb
op_star
id|ldb
)paren
(brace
r_struct
id|list_head
op_star
id|item
suffix:semicolon
r_struct
id|vblk
op_star
id|vb
suffix:semicolon
r_struct
id|vblk
op_star
id|disk
suffix:semicolon
r_struct
id|vblk_part
op_star
id|part
suffix:semicolon
r_int
id|part_num
op_assign
l_int|1
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|pp
op_logical_or
op_logical_neg
id|ldb
)paren
suffix:semicolon
id|disk
op_assign
id|ldm_get_disk_objid
(paren
id|ldb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Can&squot;t find the ID of this disk in the database.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot; [LDM]&quot;
)paren
suffix:semicolon
multiline_comment|/* Create the data partitions */
id|list_for_each
(paren
id|item
comma
op_amp
id|ldb-&gt;v_part
)paren
(brace
id|vb
op_assign
id|list_entry
(paren
id|item
comma
r_struct
id|vblk
comma
id|list
)paren
suffix:semicolon
id|part
op_assign
op_amp
id|vb-&gt;vblk.part
suffix:semicolon
r_if
c_cond
(paren
id|part-&gt;disk_id
op_ne
id|disk-&gt;obj_id
)paren
r_continue
suffix:semicolon
id|put_partition
(paren
id|pp
comma
id|part_num
comma
id|ldb-&gt;ph.logical_disk_start
op_plus
id|part-&gt;start
comma
id|part-&gt;size
)paren
suffix:semicolon
id|part_num
op_increment
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_relative - Calculate the next relative offset&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @base:    Size of the previous fixed width fields&n; * @offset:  Cumulative size of the previous variable-width fields&n; *&n; * Because many of the VBLK fields are variable-width, it&squot;s necessary&n; * to calculate each offset based on the previous one and the length&n; * of the field it pointed to.&n; *&n; * Return:  -1 Error, the calculated offset exceeded the size of the buffer&n; *           n OK, a range-checked offset into buffer&n; */
DECL|function|ldm_relative
r_static
r_int
id|ldm_relative
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_int
id|base
comma
r_int
id|offset
)paren
(brace
id|base
op_add_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|buffer
)paren
op_logical_or
(paren
id|offset
OL
l_int|0
)paren
op_logical_or
(paren
id|base
OG
id|buflen
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_plus
id|buffer
(braket
id|base
)braket
)paren
op_ge
id|buflen
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|buffer
(braket
id|base
)braket
op_plus
id|offset
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_get_vnum - Convert a variable-width, big endian number, into cpu order&n; * @block:  Pointer to the variable-width number to convert&n; *&n; * Large numbers in the LDM Database are often stored in a packed format.  Each&n; * number is prefixed by a one byte width marker.  All numbers in the database&n; * are stored in big-endian byte order.  This function reads one of these&n; * numbers and returns the result&n; *&n; * N.B.  This function DOES NOT perform any range checking, though the most&n; *       it will read is eight bytes.&n; *&n; * Return:  n A number&n; *          0 Zero, or an error occurred&n; */
DECL|function|ldm_get_vnum
r_static
id|u64
id|ldm_get_vnum
(paren
r_const
id|u8
op_star
id|block
)paren
(brace
id|u64
id|tmp
op_assign
l_int|0
suffix:semicolon
id|u8
id|length
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|block
)paren
suffix:semicolon
id|length
op_assign
op_star
id|block
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|length
op_logical_and
id|length
op_le
l_int|8
)paren
r_while
c_loop
(paren
id|length
op_decrement
)paren
id|tmp
op_assign
(paren
id|tmp
op_lshift
l_int|8
)paren
op_or
op_star
id|block
op_increment
suffix:semicolon
r_else
id|ldm_error
(paren
l_string|&quot;Illegal length %d.&quot;
comma
id|length
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_get_vstr - Read a length-prefixed string into a buffer&n; * @block:   Pointer to the length marker&n; * @buffer:  Location to copy string to&n; * @buflen:  Size of the output buffer&n; *&n; * Many of the strings in the LDM Database are not NULL terminated.  Instead&n; * they are prefixed by a one byte length marker.  This function copies one of&n; * these strings into a buffer.&n; *&n; * N.B.  This function DOES NOT perform any range checking on the input.&n; *       If the buffer is too small, the output will be truncated.&n; *&n; * Return:  0, Error and @buffer contents are undefined&n; *          n, String length in characters (excluding NULL)&n; *          buflen-1, String was truncated.&n; */
DECL|function|ldm_get_vstr
r_static
r_int
id|ldm_get_vstr
(paren
r_const
id|u8
op_star
id|block
comma
id|u8
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_int
id|length
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|block
op_logical_or
op_logical_neg
id|buffer
)paren
suffix:semicolon
id|length
op_assign
id|block
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|length
op_ge
id|buflen
)paren
(brace
id|ldm_error
(paren
l_string|&quot;Truncating string %d -&gt; %d.&quot;
comma
id|length
comma
id|buflen
)paren
suffix:semicolon
id|length
op_assign
id|buflen
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
(paren
id|buffer
comma
id|block
op_plus
l_int|1
comma
id|length
)paren
suffix:semicolon
id|buffer
(braket
id|length
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_cmp3 - Read a raw VBLK Component object into a vblk structure&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @vb:      In-memory vblk in which to return information&n; *&n; * Read a raw VBLK Component object (version 3) into a vblk structure.&n; *&n; * Return:  TRUE   @vb contains a Component VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_cmp3
r_static
id|BOOL
id|ldm_parse_cmp3
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|r_objid
comma
id|r_name
comma
id|r_vstate
comma
id|r_child
comma
id|r_parent
comma
id|r_stripe
comma
id|r_cols
comma
id|len
suffix:semicolon
r_struct
id|vblk_comp
op_star
id|comp
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
id|r_name
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_objid
)paren
suffix:semicolon
id|r_vstate
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_name
)paren
suffix:semicolon
id|r_child
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x1D
comma
id|r_vstate
)paren
suffix:semicolon
id|r_parent
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x2D
comma
id|r_child
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_COMP_STRIPE
)paren
(brace
id|r_stripe
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x2E
comma
id|r_parent
)paren
suffix:semicolon
id|r_cols
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x2E
comma
id|r_stripe
)paren
suffix:semicolon
id|len
op_assign
id|r_cols
suffix:semicolon
)brace
r_else
(brace
id|r_stripe
op_assign
l_int|0
suffix:semicolon
id|r_cols
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|r_parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
id|len
op_add_assign
id|VBLK_SIZE_CMP3
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|BE32
(paren
id|buffer
op_plus
l_int|0x14
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|comp
op_assign
op_amp
id|vb-&gt;vblk.comp
suffix:semicolon
id|ldm_get_vstr
(paren
id|buffer
op_plus
l_int|0x18
op_plus
id|r_name
comma
id|comp-&gt;state
comma
r_sizeof
(paren
id|comp-&gt;state
)paren
)paren
suffix:semicolon
id|comp-&gt;type
op_assign
id|buffer
(braket
l_int|0x18
op_plus
id|r_vstate
)braket
suffix:semicolon
id|comp-&gt;children
op_assign
id|ldm_get_vnum
(paren
id|buffer
op_plus
l_int|0x1D
op_plus
id|r_vstate
)paren
suffix:semicolon
id|comp-&gt;parent_id
op_assign
id|ldm_get_vnum
(paren
id|buffer
op_plus
l_int|0x2D
op_plus
id|r_child
)paren
suffix:semicolon
id|comp-&gt;chunksize
op_assign
id|r_stripe
ques
c_cond
id|ldm_get_vnum
(paren
id|buffer
op_plus
id|r_parent
op_plus
l_int|0x2E
)paren
suffix:colon
l_int|0
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_dgr3 - Read a raw VBLK Disk Group object into a vblk structure&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @vb:      In-memory vblk in which to return information&n; *&n; * Read a raw VBLK Disk Group object (version 3) into a vblk structure.&n; *&n; * Return:  TRUE   @vb contains a Disk Group VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_dgr3
r_static
r_int
id|ldm_parse_dgr3
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|r_objid
comma
id|r_name
comma
id|r_diskid
comma
id|r_id1
comma
id|r_id2
comma
id|len
suffix:semicolon
r_struct
id|vblk_dgrp
op_star
id|dgrp
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
id|r_name
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_objid
)paren
suffix:semicolon
id|r_diskid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_DGR3_IDS
)paren
(brace
id|r_id1
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x24
comma
id|r_diskid
)paren
suffix:semicolon
id|r_id2
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x24
comma
id|r_id1
)paren
suffix:semicolon
id|len
op_assign
id|r_id2
suffix:semicolon
)brace
r_else
(brace
id|r_id1
op_assign
l_int|0
suffix:semicolon
id|r_id2
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|r_diskid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
id|len
op_add_assign
id|VBLK_SIZE_DGR3
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|BE32
(paren
id|buffer
op_plus
l_int|0x14
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|dgrp
op_assign
op_amp
id|vb-&gt;vblk.dgrp
suffix:semicolon
id|ldm_get_vstr
(paren
id|buffer
op_plus
l_int|0x18
op_plus
id|r_name
comma
id|dgrp-&gt;disk_id
comma
r_sizeof
(paren
id|dgrp-&gt;disk_id
)paren
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_dgr4 - Read a raw VBLK Disk Group object into a vblk structure&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @vb:      In-memory vblk in which to return information&n; *&n; * Read a raw VBLK Disk Group object (version 4) into a vblk structure.&n; *&n; * Return:  TRUE   @vb contains a Disk Group VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_dgr4
r_static
id|BOOL
id|ldm_parse_dgr4
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|r_objid
comma
id|r_name
comma
id|r_id1
comma
id|r_id2
comma
id|len
suffix:semicolon
r_struct
id|vblk_dgrp
op_star
id|dgrp
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
id|r_name
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_objid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_DGR4_IDS
)paren
(brace
id|r_id1
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x44
comma
id|r_name
)paren
suffix:semicolon
id|r_id2
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x44
comma
id|r_id1
)paren
suffix:semicolon
id|len
op_assign
id|r_id2
suffix:semicolon
)brace
r_else
(brace
id|r_id1
op_assign
l_int|0
suffix:semicolon
id|r_id2
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|r_name
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
id|len
op_add_assign
id|VBLK_SIZE_DGR4
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|BE32
(paren
id|buffer
op_plus
l_int|0x14
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|dgrp
op_assign
op_amp
id|vb-&gt;vblk.dgrp
suffix:semicolon
id|ldm_get_vstr
(paren
id|buffer
op_plus
l_int|0x18
op_plus
id|r_objid
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_dsk3 - Read a raw VBLK Disk object into a vblk structure&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @vb:      In-memory vblk in which to return information&n; *&n; * Read a raw VBLK Disk object (version 3) into a vblk structure.&n; *&n; * Return:  TRUE   @vb contains a Disk VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_dsk3
r_static
id|BOOL
id|ldm_parse_dsk3
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|r_objid
comma
id|r_name
comma
id|r_diskid
comma
id|r_altname
comma
id|len
suffix:semicolon
r_struct
id|vblk_disk
op_star
id|disk
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
id|r_name
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_objid
)paren
suffix:semicolon
id|r_diskid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_name
)paren
suffix:semicolon
id|r_altname
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_diskid
)paren
suffix:semicolon
id|len
op_assign
id|r_altname
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
id|len
op_add_assign
id|VBLK_SIZE_DSK3
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|BE32
(paren
id|buffer
op_plus
l_int|0x14
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|disk
op_assign
op_amp
id|vb-&gt;vblk.disk
suffix:semicolon
id|ldm_get_vstr
(paren
id|buffer
op_plus
l_int|0x18
op_plus
id|r_diskid
comma
id|disk-&gt;alt_name
comma
r_sizeof
(paren
id|disk-&gt;alt_name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ldm_parse_guid
(paren
id|buffer
op_plus
l_int|0x19
op_plus
id|r_name
comma
id|disk-&gt;disk_id
)paren
)paren
r_return
id|FALSE
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_dsk4 - Read a raw VBLK Disk object into a vblk structure&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @vb:      In-memory vblk in which to return information&n; *&n; * Read a raw VBLK Disk object (version 4) into a vblk structure.&n; *&n; * Return:  TRUE   @vb contains a Disk VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_dsk4
r_static
id|BOOL
id|ldm_parse_dsk4
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|r_objid
comma
id|r_name
comma
id|len
suffix:semicolon
r_struct
id|vblk_disk
op_star
id|disk
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
id|r_name
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_objid
)paren
suffix:semicolon
id|len
op_assign
id|r_name
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
id|len
op_add_assign
id|VBLK_SIZE_DSK4
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|BE32
(paren
id|buffer
op_plus
l_int|0x14
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|disk
op_assign
op_amp
id|vb-&gt;vblk.disk
suffix:semicolon
id|memcpy
(paren
id|disk-&gt;disk_id
comma
id|buffer
op_plus
l_int|0x18
op_plus
id|r_name
comma
id|GUID_SIZE
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_prt3 - Read a raw VBLK Partition object into a vblk structure&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @vb:      In-memory vblk in which to return information&n; *&n; * Read a raw VBLK Partition object (version 3) into a vblk structure.&n; *&n; * Return:  TRUE   @vb contains a Partition VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_prt3
r_static
id|BOOL
id|ldm_parse_prt3
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|r_objid
comma
id|r_name
comma
id|r_size
comma
id|r_parent
comma
id|r_diskid
comma
id|r_index
comma
id|len
suffix:semicolon
r_struct
id|vblk_part
op_star
id|part
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
id|r_name
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_objid
)paren
suffix:semicolon
id|r_size
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x34
comma
id|r_name
)paren
suffix:semicolon
id|r_parent
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x34
comma
id|r_size
)paren
suffix:semicolon
id|r_diskid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x34
comma
id|r_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_PART_INDEX
)paren
(brace
id|r_index
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x34
comma
id|r_diskid
)paren
suffix:semicolon
id|len
op_assign
id|r_index
suffix:semicolon
)brace
r_else
(brace
id|r_index
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|r_diskid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
id|len
op_add_assign
id|VBLK_SIZE_PRT3
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|BE32
(paren
id|buffer
op_plus
l_int|0x14
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|part
op_assign
op_amp
id|vb-&gt;vblk.part
suffix:semicolon
id|part-&gt;start
op_assign
id|BE64
(paren
id|buffer
op_plus
l_int|0x24
op_plus
id|r_name
)paren
suffix:semicolon
id|part-&gt;volume_offset
op_assign
id|BE64
(paren
id|buffer
op_plus
l_int|0x2C
op_plus
id|r_name
)paren
suffix:semicolon
id|part-&gt;size
op_assign
id|ldm_get_vnum
(paren
id|buffer
op_plus
l_int|0x34
op_plus
id|r_name
)paren
suffix:semicolon
id|part-&gt;parent_id
op_assign
id|ldm_get_vnum
(paren
id|buffer
op_plus
l_int|0x34
op_plus
id|r_size
)paren
suffix:semicolon
id|part-&gt;disk_id
op_assign
id|ldm_get_vnum
(paren
id|buffer
op_plus
l_int|0x34
op_plus
id|r_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vb-&gt;flags
op_amp
id|VBLK_FLAG_PART_INDEX
)paren
id|part-&gt;partnum
op_assign
id|buffer
(braket
l_int|0x35
op_plus
id|r_diskid
)braket
suffix:semicolon
r_else
id|part-&gt;partnum
op_assign
l_int|0
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_vol5 - Read a raw VBLK Volume object into a vblk structure&n; * @buffer:  Block of data being worked on&n; * @buflen:  Size of the block of data&n; * @vb:      In-memory vblk in which to return information&n; *&n; * Read a raw VBLK Volume object (version 5) into a vblk structure.&n; *&n; * Return:  TRUE   @vb contains a Volume VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_vol5
r_static
id|BOOL
id|ldm_parse_vol5
(paren
r_const
id|u8
op_star
id|buffer
comma
r_int
id|buflen
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|r_objid
comma
id|r_name
comma
id|r_vtype
comma
id|r_child
comma
id|r_size
comma
id|r_id1
comma
id|r_id2
comma
id|r_size2
suffix:semicolon
r_int
id|r_drive
comma
id|len
suffix:semicolon
r_struct
id|vblk_volu
op_star
id|volu
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
id|r_name
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_objid
)paren
suffix:semicolon
id|r_vtype
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x18
comma
id|r_name
)paren
suffix:semicolon
id|r_child
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x2E
comma
id|r_vtype
)paren
suffix:semicolon
id|r_size
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x3E
comma
id|r_child
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_VOLU_ID1
)paren
id|r_id1
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x53
comma
id|r_size
)paren
suffix:semicolon
r_else
id|r_id1
op_assign
id|r_size
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_VOLU_ID2
)paren
id|r_id2
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x53
comma
id|r_id1
)paren
suffix:semicolon
r_else
id|r_id2
op_assign
id|r_id1
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_VOLU_SIZE
)paren
id|r_size2
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x53
comma
id|r_id2
)paren
suffix:semicolon
r_else
id|r_size2
op_assign
id|r_id2
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_VOLU_DRIVE
)paren
id|r_drive
op_assign
id|ldm_relative
(paren
id|buffer
comma
id|buflen
comma
l_int|0x53
comma
id|r_size2
)paren
suffix:semicolon
r_else
id|r_drive
op_assign
id|r_size2
suffix:semicolon
id|len
op_assign
id|r_drive
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
id|len
op_add_assign
id|VBLK_SIZE_VOL5
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|BE32
(paren
id|buffer
op_plus
l_int|0x14
)paren
)paren
r_return
id|FALSE
suffix:semicolon
id|volu
op_assign
op_amp
id|vb-&gt;vblk.volu
suffix:semicolon
id|ldm_get_vstr
(paren
id|buffer
op_plus
l_int|0x18
op_plus
id|r_name
comma
id|volu-&gt;volume_type
comma
r_sizeof
(paren
id|volu-&gt;volume_type
)paren
)paren
suffix:semicolon
id|memcpy
(paren
id|volu-&gt;volume_state
comma
id|buffer
op_plus
l_int|0x19
op_plus
id|r_vtype
comma
r_sizeof
(paren
id|volu-&gt;volume_state
)paren
)paren
suffix:semicolon
id|volu-&gt;size
op_assign
id|ldm_get_vnum
(paren
id|buffer
op_plus
l_int|0x3E
op_plus
id|r_child
)paren
suffix:semicolon
id|volu-&gt;partition_type
op_assign
id|buffer
(braket
l_int|0x42
op_plus
id|r_size
)braket
suffix:semicolon
id|memcpy
(paren
id|volu-&gt;guid
comma
id|buffer
op_plus
l_int|0x43
op_plus
id|r_size
comma
r_sizeof
(paren
id|volu-&gt;guid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
l_int|0x12
)braket
op_amp
id|VBLK_FLAG_VOLU_DRIVE
)paren
(brace
id|ldm_get_vstr
(paren
id|buffer
op_plus
l_int|0x53
op_plus
id|r_size
comma
id|volu-&gt;drive_hint
comma
r_sizeof
(paren
id|volu-&gt;drive_hint
)paren
)paren
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_parse_vblk - Read a raw VBLK object into a vblk structure&n; * @buf:  Block of data being worked on&n; * @len:  Size of the block of data&n; * @vb:   In-memory vblk in which to return information&n; *&n; * Read a raw VBLK object into a vblk structure.  This function just reads the&n; * information common to all VBLK types, then delegates the rest of the work to&n; * helper functions: ldm_parse_*.&n; *&n; * Return:  TRUE   @vb contains a VBLK&n; *          FALSE  @vb contents are not defined&n; */
DECL|function|ldm_parse_vblk
r_static
id|BOOL
id|ldm_parse_vblk
(paren
r_const
id|u8
op_star
id|buf
comma
r_int
id|len
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
id|BOOL
id|result
op_assign
id|FALSE
suffix:semicolon
r_int
id|r_objid
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|buf
op_logical_or
op_logical_neg
id|vb
)paren
suffix:semicolon
id|r_objid
op_assign
id|ldm_relative
(paren
id|buf
comma
id|len
comma
l_int|0x18
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r_objid
OL
l_int|0
)paren
(brace
id|ldm_error
(paren
l_string|&quot;VBLK header is corrupt.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|vb-&gt;flags
op_assign
id|buf
(braket
l_int|0x12
)braket
suffix:semicolon
id|vb-&gt;type
op_assign
id|buf
(braket
l_int|0x13
)braket
suffix:semicolon
id|vb-&gt;obj_id
op_assign
id|ldm_get_vnum
(paren
id|buf
op_plus
l_int|0x18
)paren
suffix:semicolon
id|ldm_get_vstr
(paren
id|buf
op_plus
l_int|0x18
op_plus
id|r_objid
comma
id|vb-&gt;name
comma
r_sizeof
(paren
id|vb-&gt;name
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|vb-&gt;type
)paren
(brace
r_case
id|VBLK_CMP3
suffix:colon
id|result
op_assign
id|ldm_parse_cmp3
(paren
id|buf
comma
id|len
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_DSK3
suffix:colon
id|result
op_assign
id|ldm_parse_dsk3
(paren
id|buf
comma
id|len
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_DSK4
suffix:colon
id|result
op_assign
id|ldm_parse_dsk4
(paren
id|buf
comma
id|len
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_DGR3
suffix:colon
id|result
op_assign
id|ldm_parse_dgr3
(paren
id|buf
comma
id|len
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_DGR4
suffix:colon
id|result
op_assign
id|ldm_parse_dgr4
(paren
id|buf
comma
id|len
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_PRT3
suffix:colon
id|result
op_assign
id|ldm_parse_prt3
(paren
id|buf
comma
id|len
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_VOL5
suffix:colon
id|result
op_assign
id|ldm_parse_vol5
(paren
id|buf
comma
id|len
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
)paren
id|ldm_debug
(paren
l_string|&quot;Parsed VBLK 0x%llx (type: 0x%02x) ok.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vb-&gt;obj_id
comma
id|vb-&gt;type
)paren
suffix:semicolon
r_else
id|ldm_error
(paren
l_string|&quot;Failed to parse VBLK 0x%llx (type: 0x%02x).&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vb-&gt;obj_id
comma
id|vb-&gt;type
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_ldmdb_add - Adds a raw VBLK entry to the ldmdb database&n; * @data:  Raw VBLK to add to the database&n; * @len:   Size of the raw VBLK&n; * @ldb:   Cache of the database structures&n; *&n; * The VBLKs are sorted into categories.  Partitions are also sorted by offset.&n; *&n; * N.B.  This function does not check the validity of the VBLKs.&n; *&n; * Return:  TRUE   The VBLK was added&n; *          FALSE  An error occurred&n; */
DECL|function|ldm_ldmdb_add
r_static
id|BOOL
id|ldm_ldmdb_add
(paren
id|u8
op_star
id|data
comma
r_int
id|len
comma
r_struct
id|ldmdb
op_star
id|ldb
)paren
(brace
r_struct
id|vblk
op_star
id|vb
suffix:semicolon
r_struct
id|list_head
op_star
id|item
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|data
op_logical_or
op_logical_neg
id|ldb
)paren
suffix:semicolon
id|vb
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|vb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vb
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Out of memory.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_parse_vblk
(paren
id|data
comma
id|len
comma
id|vb
)paren
)paren
(brace
id|kfree
c_func
(paren
id|vb
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* Already logged */
)brace
multiline_comment|/* Put vblk into the correct list. */
r_switch
c_cond
(paren
id|vb-&gt;type
)paren
(brace
r_case
id|VBLK_DGR3
suffix:colon
r_case
id|VBLK_DGR4
suffix:colon
id|list_add
(paren
op_amp
id|vb-&gt;list
comma
op_amp
id|ldb-&gt;v_dgrp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_DSK3
suffix:colon
r_case
id|VBLK_DSK4
suffix:colon
id|list_add
(paren
op_amp
id|vb-&gt;list
comma
op_amp
id|ldb-&gt;v_disk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_VOL5
suffix:colon
id|list_add
(paren
op_amp
id|vb-&gt;list
comma
op_amp
id|ldb-&gt;v_volu
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_CMP3
suffix:colon
id|list_add
(paren
op_amp
id|vb-&gt;list
comma
op_amp
id|ldb-&gt;v_comp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|VBLK_PRT3
suffix:colon
multiline_comment|/* Sort by the partition&squot;s start sector. */
id|list_for_each
(paren
id|item
comma
op_amp
id|ldb-&gt;v_part
)paren
(brace
r_struct
id|vblk
op_star
id|v
op_assign
id|list_entry
(paren
id|item
comma
r_struct
id|vblk
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v-&gt;vblk.part.disk_id
op_eq
id|vb-&gt;vblk.part.disk_id
)paren
op_logical_and
(paren
id|v-&gt;vblk.part.start
OG
id|vb-&gt;vblk.part.start
)paren
)paren
(brace
id|list_add_tail
(paren
op_amp
id|vb-&gt;list
comma
op_amp
id|v-&gt;list
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
)brace
id|list_add_tail
(paren
op_amp
id|vb-&gt;list
comma
op_amp
id|ldb-&gt;v_part
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_frag_add - Add a VBLK fragment to a list&n; * @data:   Raw fragment to be added to the list&n; * @size:   Size of the raw fragment&n; * @frags:  Linked list of VBLK fragments&n; *&n; * Fragmented VBLKs may not be consecutive in the database, so they are placed&n; * in a list so they can be pieced together later.&n; *&n; * Return:  TRUE   Success, the VBLK was added to the list&n; *          FALSE  Error, a problem occurred&n; */
DECL|function|ldm_frag_add
r_static
id|BOOL
id|ldm_frag_add
(paren
r_const
id|u8
op_star
id|data
comma
r_int
id|size
comma
r_struct
id|list_head
op_star
id|frags
)paren
(brace
r_struct
id|frag
op_star
id|f
suffix:semicolon
r_struct
id|list_head
op_star
id|item
suffix:semicolon
r_int
id|rec
comma
id|num
comma
id|group
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|data
op_logical_or
op_logical_neg
id|frags
)paren
suffix:semicolon
id|group
op_assign
id|BE32
(paren
id|data
op_plus
l_int|0x08
)paren
suffix:semicolon
id|rec
op_assign
id|BE16
(paren
id|data
op_plus
l_int|0x0C
)paren
suffix:semicolon
id|num
op_assign
id|BE16
(paren
id|data
op_plus
l_int|0x0E
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|num
OL
l_int|1
)paren
op_logical_or
(paren
id|num
OG
l_int|4
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;A VBLK claims to have %d parts.&quot;
comma
id|num
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|list_for_each
(paren
id|item
comma
id|frags
)paren
(brace
id|f
op_assign
id|list_entry
(paren
id|item
comma
r_struct
id|frag
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;group
op_eq
id|group
)paren
r_goto
id|found
suffix:semicolon
)brace
id|f
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|f
)paren
op_plus
id|size
op_star
id|num
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Out of memory.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|f-&gt;group
op_assign
id|group
suffix:semicolon
id|f-&gt;num
op_assign
id|num
suffix:semicolon
id|f-&gt;rec
op_assign
id|rec
suffix:semicolon
id|f-&gt;map
op_assign
l_int|0xFF
op_lshift
id|num
suffix:semicolon
id|list_add_tail
(paren
op_amp
id|f-&gt;list
comma
id|frags
)paren
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|f-&gt;map
op_amp
(paren
l_int|1
op_lshift
id|rec
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;Duplicate VBLK, part %d.&quot;
comma
id|rec
)paren
suffix:semicolon
id|f-&gt;map
op_and_assign
l_int|0x7F
suffix:semicolon
multiline_comment|/* Mark the group as broken */
r_return
id|FALSE
suffix:semicolon
)brace
id|f-&gt;map
op_or_assign
(paren
l_int|1
op_lshift
id|rec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num
OG
l_int|0
)paren
(brace
id|data
op_add_assign
id|VBLK_SIZE_HEAD
suffix:semicolon
id|size
op_sub_assign
id|VBLK_SIZE_HEAD
suffix:semicolon
)brace
id|memcpy
(paren
id|f-&gt;data
op_plus
id|rec
op_star
(paren
id|size
op_minus
id|VBLK_SIZE_HEAD
)paren
op_plus
id|VBLK_SIZE_HEAD
comma
id|data
comma
id|size
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_frag_free - Free a linked list of VBLK fragments&n; * @list:  Linked list of fragments&n; *&n; * Free a linked list of VBLK fragments&n; *&n; * Return:  none&n; */
DECL|function|ldm_frag_free
r_static
r_void
id|ldm_frag_free
(paren
r_struct
id|list_head
op_star
id|list
)paren
(brace
r_struct
id|list_head
op_star
id|item
comma
op_star
id|tmp
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|list
)paren
suffix:semicolon
id|list_for_each_safe
(paren
id|item
comma
id|tmp
comma
id|list
)paren
id|kfree
(paren
id|list_entry
(paren
id|item
comma
r_struct
id|frag
comma
id|list
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_frag_commit - Validate fragmented VBLKs and add them to the database&n; * @frags:  Linked list of VBLK fragments&n; * @ldb:    Cache of the database structures&n; *&n; * Now that all the fragmented VBLKs have been collected, they must be added to&n; * the database for later use.&n; *&n; * Return:  TRUE   All the fragments we added successfully&n; *          FALSE  One or more of the fragments we invalid&n; */
DECL|function|ldm_frag_commit
r_static
id|BOOL
id|ldm_frag_commit
(paren
r_struct
id|list_head
op_star
id|frags
comma
r_struct
id|ldmdb
op_star
id|ldb
)paren
(brace
r_struct
id|frag
op_star
id|f
suffix:semicolon
r_struct
id|list_head
op_star
id|item
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|frags
op_logical_or
op_logical_neg
id|ldb
)paren
suffix:semicolon
id|list_for_each
(paren
id|item
comma
id|frags
)paren
(brace
id|f
op_assign
id|list_entry
(paren
id|item
comma
r_struct
id|frag
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;map
op_ne
l_int|0xFF
)paren
(brace
id|ldm_error
(paren
l_string|&quot;VBLK group %d is incomplete (0x%02x).&quot;
comma
id|f-&gt;group
comma
id|f-&gt;map
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_ldmdb_add
(paren
id|f-&gt;data
comma
id|f-&gt;num
op_star
id|ldb-&gt;vm.vblk_size
comma
id|ldb
)paren
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* Already logged */
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_get_vblks - Read the on-disk database of VBLKs into memory&n; * @bdev:  Device holding the LDM Database&n; * @base:  Offset, into @bdev, of the database&n; * @ldb:   Cache of the database structures&n; *&n; * To use the information from the VBLKs, they need to be read from the disk,&n; * unpacked and validated.  We cache them in @ldb according to their type.&n; *&n; * Return:  TRUE   All the VBLKs were read successfully&n; *          FALSE  An error occurred&n; */
DECL|function|ldm_get_vblks
r_static
id|BOOL
id|ldm_get_vblks
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_int
r_int
id|base
comma
r_struct
id|ldmdb
op_star
id|ldb
)paren
(brace
r_int
id|size
comma
id|perbuf
comma
id|skip
comma
id|finish
comma
id|s
comma
id|v
comma
id|recs
suffix:semicolon
id|u8
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
id|BOOL
id|result
op_assign
id|FALSE
suffix:semicolon
id|LIST_HEAD
(paren
id|frags
)paren
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|bdev
op_logical_or
op_logical_neg
id|ldb
)paren
suffix:semicolon
id|size
op_assign
id|ldb-&gt;vm.vblk_size
suffix:semicolon
id|perbuf
op_assign
l_int|512
op_div
id|size
suffix:semicolon
id|skip
op_assign
id|ldb-&gt;vm.vblk_offset
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/* Bytes to sectors */
id|finish
op_assign
(paren
id|size
op_star
id|ldb-&gt;vm.last_vblk_seq
)paren
op_rshift
l_int|9
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|skip
suffix:semicolon
id|s
OL
id|finish
suffix:semicolon
id|s
op_increment
)paren
(brace
multiline_comment|/* For each sector */
id|data
op_assign
id|read_dev_sector
(paren
id|bdev
comma
id|base
op_plus
id|OFF_VMDB
op_plus
id|s
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Disk read failed.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
id|v
op_assign
l_int|0
suffix:semicolon
id|v
OL
id|perbuf
suffix:semicolon
id|v
op_increment
comma
id|data
op_add_assign
id|size
)paren
(brace
multiline_comment|/* For each vblk */
r_if
c_cond
(paren
id|MAGIC_VBLK
op_ne
id|BE32
(paren
id|data
)paren
)paren
(brace
id|ldm_error
(paren
l_string|&quot;Expected to find a VBLK.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|recs
op_assign
id|BE16
(paren
id|data
op_plus
l_int|0x0E
)paren
suffix:semicolon
multiline_comment|/* Number of records */
r_if
c_cond
(paren
id|recs
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_ldmdb_add
(paren
id|data
comma
id|size
comma
id|ldb
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Already logged */
)brace
r_else
r_if
c_cond
(paren
id|recs
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ldm_frag_add
(paren
id|data
comma
id|size
comma
op_amp
id|frags
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Already logged */
)brace
multiline_comment|/* else Record is not in use, ignore it. */
)brace
id|put_dev_sector
(paren
id|sect
)paren
suffix:semicolon
id|data
op_assign
l_int|NULL
suffix:semicolon
)brace
id|result
op_assign
id|ldm_frag_commit
(paren
op_amp
id|frags
comma
id|ldb
)paren
suffix:semicolon
multiline_comment|/* Failures, already logged */
id|out
suffix:colon
r_if
c_cond
(paren
id|data
)paren
id|put_dev_sector
(paren
id|sect
)paren
suffix:semicolon
id|ldm_frag_free
(paren
op_amp
id|frags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_free_vblks - Free a linked list of vblk&squot;s&n; * @lh:  Head of a linked list of struct vblk&n; *&n; * Free a list of vblk&squot;s and free the memory used to maintain the list.&n; *&n; * Return:  none&n; */
DECL|function|ldm_free_vblks
r_static
r_void
id|ldm_free_vblks
(paren
r_struct
id|list_head
op_star
id|lh
)paren
(brace
r_struct
id|list_head
op_star
id|item
comma
op_star
id|tmp
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|lh
)paren
suffix:semicolon
id|list_for_each_safe
(paren
id|item
comma
id|tmp
comma
id|lh
)paren
id|kfree
(paren
id|list_entry
(paren
id|item
comma
r_struct
id|vblk
comma
id|list
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_partition - Find out whether a device is a dynamic disk and handle it&n; * @pp:    List of the partitions parsed so far&n; * @bdev:  Device holding the LDM Database&n; *&n; * This determines whether the device @bdev is a dynamic disk and if so creates&n; * the partitions necessary in the gendisk structure pointed to by @hd.&n; *&n; * We create a dummy device 1, which contains the LDM database, and then create&n; * each partition described by the LDM database in sequence as devices 2+. For&n; * example, if the device is hda, we would have: hda1: LDM database, hda2, hda3,&n; * and so on: the actual data containing partitions.&n; *&n; * Return:  1 Success, @bdev is a dynamic disk and we handled it&n; *          0 Success, @bdev is not a dynamic disk&n; *         -1 An error occurred before enough information had been read&n; *            Or @bdev is a dynamic disk, but it may be corrupted&n; */
DECL|function|ldm_partition
r_int
id|ldm_partition
(paren
r_struct
id|parsed_partitions
op_star
id|pp
comma
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
r_struct
id|ldmdb
op_star
id|ldb
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|pp
op_logical_or
op_logical_neg
id|bdev
)paren
suffix:semicolon
multiline_comment|/* Look for signs of a Dynamic Disk */
r_if
c_cond
(paren
op_logical_neg
id|ldm_validate_partition_table
(paren
id|bdev
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ldb
op_assign
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|ldb
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ldb
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Out of memory.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Parse and check privheads. */
r_if
c_cond
(paren
op_logical_neg
id|ldm_validate_privheads
(paren
id|bdev
comma
op_amp
id|ldb-&gt;ph
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Already logged */
multiline_comment|/* All further references are relative to base (database start). */
id|base
op_assign
id|ldb-&gt;ph.config_start
suffix:semicolon
multiline_comment|/* Parse and check tocs and vmdb. */
r_if
c_cond
(paren
op_logical_neg
id|ldm_validate_tocblocks
(paren
id|bdev
comma
id|base
comma
id|ldb
)paren
op_logical_or
op_logical_neg
id|ldm_validate_vmdb
(paren
id|bdev
comma
id|base
comma
id|ldb
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Already logged */
multiline_comment|/* Initialize vblk lists in ldmdb struct */
id|INIT_LIST_HEAD
(paren
op_amp
id|ldb-&gt;v_dgrp
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|ldb-&gt;v_disk
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|ldb-&gt;v_volu
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|ldb-&gt;v_comp
)paren
suffix:semicolon
id|INIT_LIST_HEAD
(paren
op_amp
id|ldb-&gt;v_part
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ldm_get_vblks
(paren
id|bdev
comma
id|base
comma
id|ldb
)paren
)paren
(brace
id|ldm_crit
(paren
l_string|&quot;Failed to read the VBLKs from the database.&quot;
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Finally, create the data partition devices. */
r_if
c_cond
(paren
id|ldm_create_data_partitions
(paren
id|pp
comma
id|ldb
)paren
)paren
(brace
id|ldm_debug
(paren
l_string|&quot;Parsed LDM database successfully.&quot;
)paren
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* else Already logged */
id|cleanup
suffix:colon
id|ldm_free_vblks
(paren
op_amp
id|ldb-&gt;v_dgrp
)paren
suffix:semicolon
id|ldm_free_vblks
(paren
op_amp
id|ldb-&gt;v_disk
)paren
suffix:semicolon
id|ldm_free_vblks
(paren
op_amp
id|ldb-&gt;v_volu
)paren
suffix:semicolon
id|ldm_free_vblks
(paren
op_amp
id|ldb-&gt;v_comp
)paren
suffix:semicolon
id|ldm_free_vblks
(paren
op_amp
id|ldb-&gt;v_part
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
(paren
id|ldb
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
