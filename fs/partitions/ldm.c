multiline_comment|/*&n; * ldm - Part of the Linux-NTFS project.&n; *&n; * Copyright (C) 2001 Richard Russon &lt;ldm@flatcap.org&gt;&n; * Copyright (C) 2001 Anton Altaparmakov &lt;antona@users.sf.net&gt; (AIA)&n; *&n; * Documentation is available at http://linux-ntfs.sf.net/ldm&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the Free&n; * Software Foundation; either version 2 of the License, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS source&n; * in the file COPYING); if not, write to the Free Software Foundation,&n; * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; *&n; * 28/10/2001 - Added sorting of ldm partitions. (AIA)&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &quot;check.h&quot;
macro_line|#include &quot;ldm.h&quot;
macro_line|#include &quot;msdos.h&quot;
macro_line|#if 0 /* Fool kernel-doc since it doesn&squot;t do macros yet. */
multiline_comment|/**&n; * ldm_debug - output an error message if debugging was enabled at compile time&n; * @f:&t;&t;a printf format string containing the message&n; * @...:&t;the variables to substitute into @f&n; *&n; * ldm_debug() writes a DEBUG level message to the syslog but only if the&n; * driver was compiled with debug enabled. Otherwise, the call turns into a NOP.&n; */
r_static
r_void
id|ldm_debug
c_func
(paren
r_const
r_char
op_star
id|f
comma
dot
dot
dot
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_LDM_DEBUG
DECL|macro|ldm_debug
mdefine_line|#define ldm_debug(f, a...)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;printk(LDM_DEBUG &quot; DEBUG (%s, %d): %s: &quot;,&t;&t;&bslash;&n;&t;&t;&t;&t;__FILE__, __LINE__, __FUNCTION__);&t;&bslash;&n;&t;&t;printk(f, ##a);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}
macro_line|#else&t;/* !CONFIG_LDM_DEBUG */
DECL|macro|ldm_debug
mdefine_line|#define ldm_debug(f, a...)&t;do {} while (0)
macro_line|#endif&t;/* !CONFIG_LDM_DEBUG */
multiline_comment|/* Necessary forward declarations. */
r_static
r_int
id|create_partition
c_func
(paren
r_struct
id|gendisk
op_star
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|parse_privhead
c_func
(paren
r_const
id|u8
op_star
comma
r_struct
id|privhead
op_star
)paren
suffix:semicolon
r_static
id|u64
id|get_vnum
c_func
(paren
r_const
id|u8
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_static
r_int
id|get_vstr
c_func
(paren
r_const
id|u8
op_star
comma
id|u8
op_star
comma
r_const
r_int
)paren
suffix:semicolon
multiline_comment|/**&n; * parse_vblk_part - parse a LDM database vblk partition record&n; * @buffer:&t;vblk partition record loaded from the LDM database&n; * @buf_size:&t;size of @buffer in bytes&n; * @vb:&t;&t;in memory vblk structure to return parsed information in&n; *&n; * This parses the LDM database vblk record of type VBLK_PART, i.e. a partition&n; * record, supplied in @buffer and sets up the in memory vblk structure @vb&n; * with the obtained information.&n; *&n; * Return 1 on success and -1 on error, in which case @vb is undefined.&n; */
DECL|function|parse_vblk_part
r_static
r_int
id|parse_vblk_part
c_func
(paren
r_const
id|u8
op_star
id|buffer
comma
r_const
r_int
id|buf_size
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|err
comma
id|rel_objid
comma
id|rel_name
comma
id|rel_size
comma
id|rel_parent
suffix:semicolon
r_if
c_cond
(paren
l_int|0x34
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Calculate relative offsets. */
id|rel_objid
op_assign
l_int|1
op_plus
id|buffer
(braket
l_int|0x18
)braket
suffix:semicolon
r_if
c_cond
(paren
l_int|0x18
op_plus
id|rel_objid
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|rel_name
op_assign
l_int|1
op_plus
id|buffer
(braket
l_int|0x18
op_plus
id|rel_objid
)braket
op_plus
id|rel_objid
suffix:semicolon
r_if
c_cond
(paren
l_int|0x34
op_plus
id|rel_name
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|rel_size
op_assign
l_int|1
op_plus
id|buffer
(braket
l_int|0x34
op_plus
id|rel_name
)braket
op_plus
id|rel_name
suffix:semicolon
r_if
c_cond
(paren
l_int|0x34
op_plus
id|rel_size
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|rel_parent
op_assign
l_int|1
op_plus
id|buffer
(braket
l_int|0x34
op_plus
id|rel_size
)braket
op_plus
id|rel_size
suffix:semicolon
r_if
c_cond
(paren
l_int|0x34
op_plus
id|rel_parent
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Setup @vb. */
id|vb-&gt;vblk_type
op_assign
id|VBLK_PART
suffix:semicolon
id|vb-&gt;obj_id
op_assign
id|get_vnum
c_func
(paren
id|buffer
op_plus
l_int|0x18
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
l_int|0x34
op_plus
id|rel_parent
op_plus
id|buffer
(braket
l_int|0x34
op_plus
id|rel_parent
)braket
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|vb-&gt;disk_id
op_assign
id|get_vnum
c_func
(paren
id|buffer
op_plus
l_int|0x34
op_plus
id|rel_parent
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
l_int|0x24
op_plus
id|rel_name
op_plus
l_int|8
OG
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|vb-&gt;start_sector
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x24
op_plus
id|rel_name
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0x34
op_plus
id|rel_name
op_plus
id|buffer
(braket
l_int|0x34
op_plus
id|rel_name
)braket
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|vb-&gt;num_sectors
op_assign
id|get_vnum
c_func
(paren
id|buffer
op_plus
l_int|0x34
op_plus
id|rel_name
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
l_int|0x18
op_plus
id|rel_objid
op_plus
id|buffer
(braket
l_int|0x18
op_plus
id|rel_objid
)braket
op_ge
id|buf_size
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|err
op_assign
id|get_vstr
c_func
(paren
id|buffer
op_plus
l_int|0x18
op_plus
id|rel_objid
comma
id|vb-&gt;name
comma
r_sizeof
(paren
id|vb-&gt;name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
l_int|1
)paren
r_return
id|err
suffix:semicolon
id|ldm_debug
c_func
(paren
l_string|&quot;Parsed Partition VBLK successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_vblk - parse a LDM database vblk record&n; * @buffer:&t;vblk record loaded from the LDM database&n; * @buf_size:&t;size of @buffer in bytes&n; * @vb:&t;&t;in memory vblk structure to return parsed information in&n; *&n; * This parses the LDM database vblk record supplied in @buffer and sets up&n; * the in memory vblk structure @vb with the obtained information.&n; *&n; * Return 1 on success, 0 if successful but record not in use, and -1 on error.&n; * If the return value is 0 or -1, @vb is undefined.&n; *&n; * NOTE: Currently the only record type we handle is VBLK_PART, i.e. records&n; * describing a partition. For all others, we just set @vb-&gt;vblk_type to 0 and&n; * return success. This of course means that if @vb-&gt;vblk_type is zero, all&n; * other fields in @vb are undefined.&n; */
DECL|function|parse_vblk
r_static
r_int
id|parse_vblk
c_func
(paren
r_const
id|u8
op_star
id|buffer
comma
r_const
r_int
id|buf_size
comma
r_struct
id|vblk
op_star
id|vb
)paren
(brace
r_int
id|err
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|buf_size
OL
l_int|0x14
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|MAGIC_VBLK
op_ne
id|BE32
c_func
(paren
id|buffer
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Cannot find VBLK, database may be corrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|BE16
c_func
(paren
id|buffer
op_plus
l_int|0x0E
)paren
op_eq
l_int|0
)paren
op_logical_or
multiline_comment|/* Record is not in use. */
(paren
id|BE16
c_func
(paren
id|buffer
op_plus
l_int|0x0C
)paren
op_ne
l_int|0
)paren
)paren
multiline_comment|/* Part 2 of an ext. record */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: What about extended VBLKs? */
r_switch
c_cond
(paren
id|buffer
(braket
l_int|0x13
)braket
)paren
(brace
r_case
id|VBLK_PART
suffix:colon
id|err
op_assign
id|parse_vblk_part
c_func
(paren
id|buffer
comma
id|buf_size
comma
id|vb
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|vb-&gt;vblk_type
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_ne
op_minus
l_int|1
)paren
id|ldm_debug
c_func
(paren
l_string|&quot;Parsed VBLK successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * add_partition_to_list - insert partition into a partition list&n; * @pl:&t;&t;sorted list of partitions&n; * @hd:&t;&t;gendisk structure to which the data partition belongs&n; * @disk_minor:&t;minor number of the disk device&n; * @start:&t;first sector within the disk device&n; * @size:&t;number of sectors on the partition device&n; *&n; * This sanity checks the partition specified by @start and @size against the&n; * device specified by @hd and inserts the partition into the sorted partition&n; * list @pl if the checks pass.&n; *&n; * On success return 1, otherwise return -1.&n; *&n; * TODO: Add sanity check for overlapping partitions. (AIA)&n; */
DECL|function|add_partition_to_list
r_static
r_int
id|add_partition_to_list
c_func
(paren
r_struct
id|list_head
op_star
id|pl
comma
r_const
r_struct
id|gendisk
op_star
id|hd
comma
r_const
r_int
id|disk_minor
comma
r_const
r_int
r_int
id|start
comma
r_const
r_int
r_int
id|size
)paren
(brace
r_struct
id|ldm_part
op_star
id|lp
comma
op_star
id|lptmp
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hd-&gt;part
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
OL
l_int|1
)paren
op_logical_or
(paren
(paren
id|start
op_plus
id|size
)paren
OG
id|hd-&gt;part
(braket
id|disk_minor
)braket
dot
id|nr_sects
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;LDM partition exceeds physical disk. &quot;
l_string|&quot;Skipping.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|ldm_part
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ldm_part
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Not enough memory! Aborting LDM partition &quot;
l_string|&quot;parsing.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|lp-&gt;part_list
)paren
suffix:semicolon
id|lp-&gt;start
op_assign
id|start
suffix:semicolon
id|lp-&gt;size
op_assign
id|size
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
id|pl
)paren
(brace
id|lptmp
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|ldm_part
comma
id|part_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
OG
id|lptmp-&gt;start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|lptmp-&gt;start
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Duplicate LDM partition entry! Skipping.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lp
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|lp-&gt;part_list
comma
id|tmp
)paren
suffix:semicolon
id|ldm_debug
c_func
(paren
l_string|&quot;Added LDM partition successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * create_data_partitions - create the data partition devices&n; * @hd:&t;&t;&t;gendisk structure in which to create the data partitions&n; * @first_sector:&t;first sector within the disk device&n; * @first_part_minor:&t;first minor number of data partition devices&n; * @dev:&t;&t;partition device holding the LDM database&n; * @vm:&t;&t;&t;in memory vmdb structure of @dev&n; * @ph:&t;&t;&t;in memory privhead structure of the disk device&n; * @dk:&t;&t;&t;in memory ldmdisk structure of the disk device&n; *&n; * The database contains ALL the partitions for ALL the disks, so we need to&n; * filter out this specific disk. Using the disk&squot;s object id, we can find all&n; * the partitions in the database that belong to this disk.&n; *&n; * For each found partition, we create a corresponding partition device starting&n; * with minor number @first_part_minor. But we do this in such a way that we&n; * actually sort the partitions in order of on-disk position. Any invalid&n; * partitions are completely ignored/skipped (an error is output but that&squot;s&n; * all).&n; *&n; * Return 1 on success and -1 on error.&n; */
DECL|function|create_data_partitions
r_static
r_int
id|create_data_partitions
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_const
r_int
r_int
id|first_sector
comma
r_int
id|first_part_minor
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_const
r_struct
id|vmdb
op_star
id|vm
comma
r_const
r_struct
id|privhead
op_star
id|ph
comma
r_const
r_struct
id|ldmdisk
op_star
id|dk
comma
r_int
r_int
id|base
)paren
(brace
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_struct
id|vblk
op_star
id|vb
suffix:semicolon
id|LIST_HEAD
c_func
(paren
id|pl
)paren
suffix:semicolon
multiline_comment|/* Sorted list of partitions. */
r_struct
id|ldm_part
op_star
id|lp
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|vblk
suffix:semicolon
r_int
id|vsize
suffix:semicolon
multiline_comment|/* VBLK size. */
r_int
id|perbuf
suffix:semicolon
multiline_comment|/* VBLKs per buffer. */
r_int
id|buffer
comma
id|lastbuf
comma
id|lastofs
comma
id|err
comma
id|disk_minor
suffix:semicolon
id|vb
op_assign
(paren
r_struct
id|vblk
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|vblk
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vb
)paren
r_goto
id|no_mem
suffix:semicolon
id|vsize
op_assign
id|vm-&gt;vblk_size
suffix:semicolon
r_if
c_cond
(paren
id|vsize
template_param
l_int|512
)paren
r_goto
id|err_out
suffix:semicolon
id|perbuf
op_assign
l_int|512
op_div
id|vsize
suffix:semicolon
r_if
c_cond
(paren
id|perbuf
OL
l_int|1
op_logical_or
l_int|512
op_mod
id|vsize
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* 512 == VMDB size */
id|lastbuf
op_assign
id|vm-&gt;last_vblk_seq
op_div
id|perbuf
op_minus
l_int|1
suffix:semicolon
id|lastofs
op_assign
id|vm-&gt;last_vblk_seq
op_mod
id|perbuf
suffix:semicolon
r_if
c_cond
(paren
id|lastofs
)paren
id|lastbuf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|OFF_VBLK
op_star
id|LDM_BLOCKSIZE
op_plus
id|vm-&gt;last_vblk_seq
op_star
id|vsize
OG
id|ph-&gt;config_size
op_star
l_int|512
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/*&n;&t; * Get the minor number of the parent device so we can check we don&squot;t&n;&t; * go beyond the end of the device.&n;&t; */
id|disk_minor
op_assign
(paren
id|first_part_minor
op_rshift
id|hd-&gt;minor_shift
)paren
op_lshift
id|hd-&gt;minor_shift
suffix:semicolon
r_for
c_loop
(paren
id|buffer
op_assign
l_int|0
suffix:semicolon
id|buffer
OL
id|lastbuf
suffix:semicolon
id|buffer
op_increment
)paren
(brace
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
l_int|2
op_star
id|OFF_VBLK
op_plus
id|buffer
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|read_err
suffix:semicolon
r_for
c_loop
(paren
id|vblk
op_assign
l_int|0
suffix:semicolon
id|vblk
OL
id|perbuf
suffix:semicolon
id|vblk
op_increment
)paren
(brace
id|u8
op_star
id|block
suffix:semicolon
r_if
c_cond
(paren
id|lastofs
op_logical_and
id|buffer
op_eq
id|lastbuf
op_minus
l_int|1
op_logical_and
id|vblk
op_ge
id|lastofs
)paren
r_break
suffix:semicolon
id|block
op_assign
id|data
op_plus
id|vsize
op_star
id|vblk
suffix:semicolon
r_if
c_cond
(paren
id|block
op_plus
id|vsize
OG
id|data
op_plus
l_int|512
)paren
r_goto
id|brelse_out
suffix:semicolon
r_if
c_cond
(paren
id|parse_vblk
c_func
(paren
id|block
comma
id|vsize
comma
id|vb
)paren
op_ne
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|vb-&gt;vblk_type
op_ne
id|VBLK_PART
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dk-&gt;obj_id
op_ne
id|vb-&gt;disk_id
)paren
r_continue
suffix:semicolon
multiline_comment|/* Ignore invalid partition errors. */
r_if
c_cond
(paren
id|add_partition_to_list
c_func
(paren
op_amp
id|pl
comma
id|hd
comma
id|disk_minor
comma
id|first_sector
op_plus
id|vb-&gt;start_sector
op_plus
id|ph-&gt;logical_disk_start
comma
id|vb-&gt;num_sectors
)paren
OL
op_minus
l_int|1
)paren
r_goto
id|brelse_out
suffix:semicolon
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
)brace
id|err
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* Finally create the nicely sorted data partitions. */
id|printk
c_func
(paren
l_string|&quot; &lt;&quot;
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|pl
)paren
(brace
id|lp
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|ldm_part
comma
id|part_list
)paren
suffix:semicolon
id|add_gd_partition
c_func
(paren
id|hd
comma
id|first_part_minor
op_increment
comma
id|lp-&gt;start
comma
id|lp-&gt;size
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; &gt;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|pl
)paren
)paren
(brace
r_struct
id|list_head
op_star
id|tmp2
suffix:semicolon
multiline_comment|/* Cleanup the partition list which is now superfluous. */
id|list_for_each_safe
c_func
(paren
id|tmp
comma
id|tmp2
comma
op_amp
id|pl
)paren
(brace
id|lp
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|ldm_part
comma
id|part_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lp
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|vb
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|brelse_out
suffix:colon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
id|no_mem
suffix:colon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Not enough memory to allocate required buffers.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
id|read_err
suffix:colon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read failed in create_partitions.&bslash;n&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/**&n; * get_vnum - convert a variable-width, big endian number, to cpu u64 one&n; * @block:&t;pointer to the variable-width number to convert&n; * @err:&t;address of an integer into which to return the error code.&n; *&n; * This converts a variable-width, big endian number into a 64-bit, CPU format&n; * number and returns the result with err set to 0. If an error occurs return 0&n; * with err set to -1.&n; *&n; * The first byte of a variable-width number is the size of the number in bytes.&n; */
DECL|function|get_vnum
r_static
id|u64
id|get_vnum
c_func
(paren
r_const
id|u8
op_star
id|block
comma
r_int
op_star
id|err
)paren
(brace
id|u64
id|tmp
op_assign
l_int|0ULL
suffix:semicolon
id|u8
id|length
op_assign
op_star
id|block
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|length
op_logical_and
id|length
op_le
l_int|8
)paren
(brace
r_while
c_loop
(paren
id|length
op_decrement
)paren
id|tmp
op_assign
(paren
id|tmp
op_lshift
l_int|8
)paren
op_or
op_star
id|block
op_increment
suffix:semicolon
op_star
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|LDM_ERR
l_string|&quot;Illegal length in get_vnum(): %d.&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
op_star
id|err
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/**&n; * get_vstr - convert a counted, non-null-terminated ASCII string to C-style one&n; * @block:&t;string to convert&n; * @buffer:&t;output buffer&n; * @buflen:&t;size of output buffer&n; *&n; * This converts @block, a counted, non-null-terminated ASCII string, into a&n; * C-style, null-terminated, ASCII string and returns this in @buffer. The&n; * maximum number of characters converted is given by @buflen.&n; *&n; * The first bytes of a counted string stores the length of the string in bytes.&n; *&n; * Return the number of characters written to @buffer, not including the&n; * terminating null character, on success, and -1 on error, in which case&n; * @buffer is not defined.&n; */
DECL|function|get_vstr
r_static
r_int
id|get_vstr
c_func
(paren
r_const
id|u8
op_star
id|block
comma
id|u8
op_star
id|buffer
comma
r_const
r_int
id|buflen
)paren
(brace
r_int
id|length
op_assign
id|block
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|length
op_ge
id|buflen
)paren
(brace
id|printk
c_func
(paren
id|LDM_ERR
l_string|&quot;String too long for buffer in get_vstr(): &quot;
l_string|&quot;(%d/%d). Truncating.&bslash;n&quot;
comma
id|length
comma
id|buflen
)paren
suffix:semicolon
id|length
op_assign
id|buflen
op_minus
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buffer
comma
id|block
op_plus
l_int|1
comma
id|length
)paren
suffix:semicolon
id|buffer
(braket
id|length
)braket
op_assign
(paren
id|u8
)paren
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/**&n; * get_disk_objid - obtain the object id for the device we are working on&n; * @dev:&t;partition device holding the LDM database&n; * @vm:&t;&t;in memory vmdb structure of the LDM database&n; * @ph:&t;&t;in memory privhead structure of the device we are working on&n; * @dk:&t;&t;in memory ldmdisk structure to return information into&n; *&n; * This obtains the object id for the device we are working on as defined by&n; * the private header @ph. The obtained object id, together with the disk&squot;s&n; * GUID from @ph are returned in the ldmdisk structure pointed to by @dk.&n; *&n; * A Disk has two Ids. The main one is a GUID in string format. The second,&n; * used internally for cross-referencing, is a small, sequentially allocated,&n; * number. The PRIVHEAD, just after the partition table, tells us the disk&squot;s&n; * GUID. To find the disk&squot;s object id, we have to look through the database.&n; *&n; * Return 1 on success and -1 on error, in which case @dk is undefined.&n; */
DECL|function|get_disk_objid
r_static
r_int
id|get_disk_objid
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_const
r_struct
id|vmdb
op_star
id|vm
comma
r_const
r_struct
id|privhead
op_star
id|ph
comma
r_struct
id|ldmdisk
op_star
id|dk
comma
r_int
r_int
id|base
)paren
(brace
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|u8
op_star
id|disk_id
suffix:semicolon
r_int
id|vblk
suffix:semicolon
r_int
id|vsize
suffix:semicolon
multiline_comment|/* VBLK size. */
r_int
id|perbuf
suffix:semicolon
multiline_comment|/* VBLKs per buffer. */
r_int
id|buffer
comma
id|lastbuf
comma
id|lastofs
comma
id|err
suffix:semicolon
id|disk_id
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|DISK_ID_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|disk_id
)paren
r_goto
id|no_mem
suffix:semicolon
id|vsize
op_assign
id|vm-&gt;vblk_size
suffix:semicolon
r_if
c_cond
(paren
id|vsize
template_param
l_int|512
)paren
r_goto
id|err_out
suffix:semicolon
id|perbuf
op_assign
l_int|512
op_div
id|vsize
suffix:semicolon
r_if
c_cond
(paren
id|perbuf
OL
l_int|1
op_logical_or
l_int|512
op_mod
id|vsize
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* 512 == VMDB size */
id|lastbuf
op_assign
id|vm-&gt;last_vblk_seq
op_div
id|perbuf
op_minus
l_int|1
suffix:semicolon
id|lastofs
op_assign
id|vm-&gt;last_vblk_seq
op_mod
id|perbuf
suffix:semicolon
r_if
c_cond
(paren
id|lastofs
)paren
id|lastbuf
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|OFF_VBLK
op_star
id|LDM_BLOCKSIZE
op_plus
id|vm-&gt;last_vblk_seq
op_star
id|vsize
OG
id|ph-&gt;config_size
op_star
l_int|512
)paren
r_goto
id|err_out
suffix:semicolon
r_for
c_loop
(paren
id|buffer
op_assign
l_int|0
suffix:semicolon
id|buffer
OL
id|lastbuf
suffix:semicolon
id|buffer
op_increment
)paren
(brace
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
l_int|2
op_star
id|OFF_VBLK
op_plus
id|buffer
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|read_err
suffix:semicolon
r_for
c_loop
(paren
id|vblk
op_assign
l_int|0
suffix:semicolon
id|vblk
OL
id|perbuf
suffix:semicolon
id|vblk
op_increment
)paren
(brace
r_int
id|rel_objid
comma
id|rel_name
comma
id|delta
suffix:semicolon
id|u8
op_star
id|block
suffix:semicolon
r_if
c_cond
(paren
id|lastofs
op_logical_and
id|buffer
op_eq
id|lastbuf
op_minus
l_int|1
op_logical_and
id|vblk
op_ge
id|lastofs
)paren
r_break
suffix:semicolon
id|block
op_assign
id|data
op_plus
id|vblk
op_star
id|vsize
suffix:semicolon
id|delta
op_assign
id|vblk
op_star
id|vsize
op_plus
l_int|0x18
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_ge
l_int|512
)paren
r_goto
id|brelse_out
suffix:semicolon
r_if
c_cond
(paren
id|block
(braket
l_int|0x0D
)braket
op_ne
l_int|0
)paren
multiline_comment|/* Extended VBLK, ignore */
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|block
(braket
l_int|0x13
)braket
op_ne
id|VBLK_DSK1
)paren
op_logical_and
(paren
id|block
(braket
l_int|0x13
)braket
op_ne
id|VBLK_DSK2
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Calculate relative offsets. */
id|rel_objid
op_assign
l_int|1
op_plus
id|block
(braket
l_int|0x18
)braket
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_plus
id|rel_objid
op_ge
l_int|512
)paren
r_goto
id|brelse_out
suffix:semicolon
id|rel_name
op_assign
l_int|1
op_plus
id|block
(braket
l_int|0x18
op_plus
id|rel_objid
)braket
op_plus
id|rel_objid
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_plus
id|rel_name
op_ge
l_int|512
op_logical_or
id|delta
op_plus
id|rel_name
op_plus
id|block
(braket
l_int|0x18
op_plus
id|rel_name
)braket
op_ge
l_int|512
)paren
r_goto
id|brelse_out
suffix:semicolon
id|err
op_assign
id|get_vstr
c_func
(paren
id|block
op_plus
l_int|0x18
op_plus
id|rel_name
comma
id|disk_id
comma
id|DISK_ID_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
l_int|1
)paren
r_goto
id|brelse_out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|disk_id
comma
id|ph-&gt;disk_id
comma
id|DISK_ID_SIZE
)paren
)paren
(brace
id|dk-&gt;obj_id
op_assign
id|get_vnum
c_func
(paren
id|block
op_plus
l_int|0x18
comma
op_amp
id|err
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|strncpy
c_func
(paren
id|dk-&gt;disk_id
comma
id|ph-&gt;disk_id
comma
r_sizeof
(paren
id|dk-&gt;disk_id
)paren
)paren
suffix:semicolon
id|dk-&gt;disk_id
(braket
r_sizeof
(paren
id|dk-&gt;disk_id
)paren
op_minus
l_int|1
)braket
op_assign
(paren
id|u8
)paren
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|err
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
)brace
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|disk_id
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|brelse_out
suffix:colon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
id|no_mem
suffix:colon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Not enough memory to allocate required buffers.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
id|read_err
suffix:colon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read failed in get_disk_objid.&bslash;n&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_vmdb - parse the LDM database vmdb structure&n; * @buffer:&t;LDM database vmdb structure loaded from the device&n; * @vm:&t;&t;in memory vmdb structure to return parsed information in&n; *&n; * This parses the LDM database vmdb structure supplied in @buffer and sets up&n; * the in memory vmdb structure @vm with the obtained information.&n; *&n; * Return 1 on success and -1 on error, in which case @vm is undefined.&n; *&n; * NOTE: The *_start, *_size and *_seq values returned in @vm have not been&n; * checked for validity, so make sure to check them when using them.&n; */
DECL|function|parse_vmdb
r_static
r_int
id|parse_vmdb
c_func
(paren
r_const
id|u8
op_star
id|buffer
comma
r_struct
id|vmdb
op_star
id|vm
)paren
(brace
r_if
c_cond
(paren
id|MAGIC_VMDB
op_ne
id|BE32
c_func
(paren
id|buffer
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Cannot find VMDB, database may be corrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|vm-&gt;ver_major
op_assign
id|BE16
c_func
(paren
id|buffer
op_plus
l_int|0x12
)paren
suffix:semicolon
id|vm-&gt;ver_minor
op_assign
id|BE16
c_func
(paren
id|buffer
op_plus
l_int|0x14
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vm-&gt;ver_major
op_ne
l_int|4
)paren
op_logical_or
(paren
id|vm-&gt;ver_minor
op_ne
l_int|10
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_ERR
l_string|&quot;Expected VMDB version %d.%d, got %d.%d. &quot;
l_string|&quot;Aborting.&bslash;n&quot;
comma
l_int|4
comma
l_int|10
comma
id|vm-&gt;ver_major
comma
id|vm-&gt;ver_minor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|vm-&gt;vblk_size
op_assign
id|BE32
c_func
(paren
id|buffer
op_plus
l_int|0x08
)paren
suffix:semicolon
id|vm-&gt;vblk_offset
op_assign
id|BE32
c_func
(paren
id|buffer
op_plus
l_int|0x0C
)paren
suffix:semicolon
id|vm-&gt;last_vblk_seq
op_assign
id|BE32
c_func
(paren
id|buffer
op_plus
l_int|0x04
)paren
suffix:semicolon
id|ldm_debug
c_func
(paren
l_string|&quot;Parsed VMDB successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * validate_vmdb - validate the vmdb&n; * @dev:&t;partition device holding the LDM database&n; * @vm:&t;&t;in memory vmdb in which to return information&n; *&n; * Find the vmdb of the LDM database stored on @dev and return the parsed&n; * information into @vm.&n; *&n; * Return 1 on success and -1 on error, in which case @vm is undefined.&n; */
DECL|function|validate_vmdb
r_static
r_int
id|validate_vmdb
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_struct
id|vmdb
op_star
id|vm
comma
r_int
r_int
id|base
)paren
(brace
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
id|OFF_VMDB
op_star
l_int|2
op_plus
l_int|1
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read failed in validate_vmdb.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ret
op_assign
id|parse_vmdb
c_func
(paren
id|data
comma
id|vm
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * compare_tocblocks - compare two tables of contents&n; * @toc1:&t;first toc&n; * @toc2:&t;second toc&n; *&n; * This compares the two tables of contents @toc1 and @toc2.&n; *&n; * Return 1 if @toc1 and @toc2 are equal and -1 otherwise.&n; */
DECL|function|compare_tocblocks
r_static
r_int
id|compare_tocblocks
c_func
(paren
r_const
r_struct
id|tocblock
op_star
id|toc1
comma
r_const
r_struct
id|tocblock
op_star
id|toc2
)paren
(brace
r_if
c_cond
(paren
(paren
id|toc1-&gt;bitmap1_start
op_eq
id|toc2-&gt;bitmap1_start
)paren
op_logical_and
(paren
id|toc1-&gt;bitmap1_size
op_eq
id|toc2-&gt;bitmap1_size
)paren
op_logical_and
(paren
id|toc1-&gt;bitmap2_start
op_eq
id|toc2-&gt;bitmap2_start
)paren
op_logical_and
(paren
id|toc1-&gt;bitmap2_size
op_eq
id|toc2-&gt;bitmap2_size
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|toc1-&gt;bitmap1_name
comma
id|toc2-&gt;bitmap1_name
comma
r_sizeof
(paren
id|toc1-&gt;bitmap1_name
)paren
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|toc1-&gt;bitmap2_name
comma
id|toc2-&gt;bitmap2_name
comma
r_sizeof
(paren
id|toc1-&gt;bitmap2_name
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_tocblock - parse the LDM database table of contents structure&n; * @buffer:&t;LDM database toc structure loaded from the device&n; * @toc:&t;in memory toc structure to return parsed information in&n; *&n; * This parses the LDM database table of contents structure supplied in @buffer&n; * and sets up the in memory table of contents structure @toc with the obtained&n; * information.&n; *&n; * Return 1 on success and -1 on error, in which case @toc is undefined.&n; *&n; * FIXME: The *_start and *_size values returned in @toc are not been checked&n; * for validity but as we don&squot;t use the actual values for anything other than&n; * comparing between the toc and its backups, the values are not important.&n; */
DECL|function|parse_tocblock
r_static
r_int
id|parse_tocblock
c_func
(paren
r_const
id|u8
op_star
id|buffer
comma
r_struct
id|tocblock
op_star
id|toc
)paren
(brace
r_if
c_cond
(paren
id|MAGIC_TOCBLOCK
op_ne
id|BE64
c_func
(paren
id|buffer
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Cannot find TOCBLOCK, database may be &quot;
l_string|&quot;corrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|toc-&gt;bitmap1_name
comma
id|buffer
op_plus
l_int|0x24
comma
r_sizeof
(paren
id|toc-&gt;bitmap1_name
)paren
)paren
suffix:semicolon
id|toc-&gt;bitmap1_name
(braket
r_sizeof
(paren
id|toc-&gt;bitmap1_name
)paren
op_minus
l_int|1
)braket
op_assign
(paren
id|u8
)paren
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|toc-&gt;bitmap1_start
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x2E
)paren
suffix:semicolon
id|toc-&gt;bitmap1_size
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x36
)paren
suffix:semicolon
multiline_comment|/*toc-&gt;bitmap1_flags = BE64(buffer + 0x3E);*/
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|toc-&gt;bitmap1_name
comma
id|TOC_BITMAP1
comma
r_sizeof
(paren
id|toc-&gt;bitmap1_name
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;TOCBLOCK&squot;s first bitmap should be %s, but is &quot;
l_string|&quot;%s.&bslash;n&quot;
comma
id|TOC_BITMAP1
comma
id|toc-&gt;bitmap1_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|toc-&gt;bitmap2_name
comma
id|buffer
op_plus
l_int|0x46
comma
r_sizeof
(paren
id|toc-&gt;bitmap2_name
)paren
)paren
suffix:semicolon
id|toc-&gt;bitmap2_name
(braket
r_sizeof
(paren
id|toc-&gt;bitmap2_name
)paren
op_minus
l_int|1
)braket
op_assign
(paren
id|u8
)paren
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|toc-&gt;bitmap2_start
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x50
)paren
suffix:semicolon
id|toc-&gt;bitmap2_size
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x58
)paren
suffix:semicolon
multiline_comment|/*toc-&gt;bitmap2_flags = BE64(buffer + 0x60);*/
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|toc-&gt;bitmap2_name
comma
id|TOC_BITMAP2
comma
r_sizeof
(paren
id|toc-&gt;bitmap2_name
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;TOCBLOCK&squot;s second bitmap should be %s, but is &quot;
l_string|&quot;%s.&bslash;n&quot;
comma
id|TOC_BITMAP2
comma
id|toc-&gt;bitmap2_name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ldm_debug
c_func
(paren
l_string|&quot;Parsed TOCBLOCK successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * validate_tocblocks - validate the table of contents and its backups&n; * @dev:&t;partition device holding the LDM database&n; * @toc1:&t;in memory table of contents in which to return information&n; *&n; * Find and compare the four tables of contents of the LDM database stored on&n; * @dev and return the parsed information into @toc1.&n; *&n; * Return 1 on success and -1 on error, in which case @toc1 is undefined.&n; */
DECL|function|validate_tocblocks
r_static
r_int
id|validate_tocblocks
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_struct
id|tocblock
op_star
id|toc1
comma
r_int
r_int
id|base
)paren
(brace
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_struct
id|tocblock
op_star
id|toc2
op_assign
l_int|NULL
comma
op_star
id|toc3
op_assign
l_int|NULL
comma
op_star
id|toc4
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
id|toc2
op_assign
(paren
r_struct
id|tocblock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|toc2
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|toc2
)paren
r_goto
id|no_mem
suffix:semicolon
id|toc3
op_assign
(paren
r_struct
id|tocblock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|toc3
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|toc3
)paren
r_goto
id|no_mem
suffix:semicolon
id|toc4
op_assign
(paren
r_struct
id|tocblock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|toc4
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|toc4
)paren
r_goto
id|no_mem
suffix:semicolon
multiline_comment|/* Read and parse first toc. */
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
id|OFF_TOCBLOCK1
op_star
l_int|2
op_plus
l_int|1
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read 1 failed in validate_tocblocks.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|parse_tocblock
c_func
(paren
id|data
comma
id|toc1
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Read and parse second toc. */
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
id|OFF_TOCBLOCK2
op_star
l_int|2
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read 2 failed in validate_tocblocks.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|parse_tocblock
c_func
(paren
id|data
comma
id|toc2
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Read and parse third toc. */
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
id|OFF_TOCBLOCK3
op_star
l_int|2
op_plus
l_int|1
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read 3 failed in validate_tocblocks.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|parse_tocblock
c_func
(paren
id|data
comma
id|toc3
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Read and parse fourth toc. */
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
id|OFF_TOCBLOCK4
op_star
l_int|2
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read 4 failed in validate_tocblocks.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|parse_tocblock
c_func
(paren
id|data
comma
id|toc4
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Compare all tocs. */
id|err
op_assign
id|compare_tocblocks
c_func
(paren
id|toc1
comma
id|toc2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;First and second TOCBLOCKs don&squot;t match.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|compare_tocblocks
c_func
(paren
id|toc3
comma
id|toc4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Third and fourth TOCBLOCKs don&squot;t match.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|compare_tocblocks
c_func
(paren
id|toc1
comma
id|toc3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;First and third TOCBLOCKs don&squot;t match.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|ldm_debug
c_func
(paren
l_string|&quot;Validated TOCBLOCKs successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|toc2
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|toc3
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|toc4
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|no_mem
suffix:colon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Not enough memory to allocate required buffers.&bslash;n&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/**&n; * compare_privheads - compare two privheads&n; * @ph1:&t;first privhead&n; * @ph2:&t;second privhead&n; *&n; * This compares the two privheads @ph1 and @ph2.&n; *&n; * Return 1 if @ph1 and @ph2 are equal and -1 otherwise.&n; */
DECL|function|compare_privheads
r_static
r_int
id|compare_privheads
c_func
(paren
r_const
r_struct
id|privhead
op_star
id|ph1
comma
r_const
r_struct
id|privhead
op_star
id|ph2
)paren
(brace
r_if
c_cond
(paren
(paren
id|ph1-&gt;ver_major
op_eq
id|ph2-&gt;ver_major
)paren
op_logical_and
(paren
id|ph1-&gt;ver_minor
op_eq
id|ph2-&gt;ver_minor
)paren
op_logical_and
(paren
id|ph1-&gt;logical_disk_start
op_eq
id|ph2-&gt;logical_disk_start
)paren
op_logical_and
(paren
id|ph1-&gt;logical_disk_size
op_eq
id|ph2-&gt;logical_disk_size
)paren
op_logical_and
(paren
id|ph1-&gt;config_start
op_eq
id|ph2-&gt;config_start
)paren
op_logical_and
(paren
id|ph1-&gt;config_size
op_eq
id|ph2-&gt;config_size
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|ph1-&gt;disk_id
comma
id|ph2-&gt;disk_id
comma
r_sizeof
(paren
id|ph1-&gt;disk_id
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * validate_privheads - compare the privhead backups to the first one&n; * @dev:&t;partition device holding the LDM database&n; * @ph1:&t;first privhead which we have already validated before&n; *&n; * We already have one privhead from the beginning of the disk.&n; * Now we compare the two other copies for safety.&n; *&n; * Return 1 on succes and -1 on error.&n; */
DECL|function|validate_privheads
r_static
r_int
id|validate_privheads
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
comma
r_const
r_struct
id|privhead
op_star
id|ph1
comma
r_int
r_int
id|base
)paren
(brace
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_struct
id|privhead
op_star
id|ph2
op_assign
l_int|NULL
comma
op_star
id|ph3
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ph2
op_assign
(paren
r_struct
id|privhead
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ph2
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ph2
)paren
r_goto
id|no_mem
suffix:semicolon
id|ph3
op_assign
(paren
r_struct
id|privhead
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ph3
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ph3
)paren
r_goto
id|no_mem
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
id|OFF_PRIVHEAD2
op_star
l_int|2
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read 1 failed in validate_privheads.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|parse_privhead
c_func
(paren
id|data
comma
id|ph2
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|base
op_plus
id|OFF_PRIVHEAD3
op_star
l_int|2
op_plus
l_int|1
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Disk read 2 failed in validate_privheads.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|parse_privhead
c_func
(paren
id|data
comma
id|ph3
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|compare_privheads
c_func
(paren
id|ph1
comma
id|ph2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;First and second PRIVHEADs don&squot;t match.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|compare_privheads
c_func
(paren
id|ph1
comma
id|ph3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;First and third PRIVHEADs don&squot;t match.&bslash;n&quot;
)paren
suffix:semicolon
r_else
multiline_comment|/* We _could_ have checked more. */
id|ldm_debug
c_func
(paren
l_string|&quot;Validated PRIVHEADs successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|ph2
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ph3
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|no_mem
suffix:colon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Not enough memory to allocate required buffers.&bslash;n&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/**&n; * create_partition - validate input and create a kernel partition device&n; * @hd:&t;&t;gendisk structure in which to create partition&n; * @minor:&t;minor number for device to create&n; * @start:&t;starting offset of the partition into the parent device&n; * @size:&t;size of the partition&n; *&n; * This validates the range, then puts an entry into the kernel&squot;s partition&n; * table.&n; *&n; * @start and @size are numbers of sectors.&n; *&n; * Return 1 on succes and -1 on error.&n; */
DECL|function|create_partition
r_static
r_int
id|create_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_const
r_int
id|minor
comma
r_const
r_int
id|start
comma
r_const
r_int
id|size
)paren
(brace
r_int
id|disk_minor
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hd-&gt;part
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Get the minor number of the parent device so we can check we don&squot;t&n;&t; * go beyond the end of the device.&n;&t; */
id|disk_minor
op_assign
(paren
id|minor
op_rshift
id|hd-&gt;minor_shift
)paren
op_lshift
id|hd-&gt;minor_shift
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
OL
l_int|1
)paren
op_logical_or
(paren
(paren
id|start
op_plus
id|size
)paren
OG
id|hd-&gt;part
(braket
id|disk_minor
)braket
dot
id|nr_sects
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;LDM Partition exceeds physical disk. &quot;
l_string|&quot;Aborting.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|add_gd_partition
c_func
(paren
id|hd
comma
id|minor
comma
id|start
comma
id|size
)paren
suffix:semicolon
id|ldm_debug
c_func
(paren
l_string|&quot;Created partition successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * parse_privhead - parse the LDM database PRIVHEAD structure&n; * @buffer:&t;LDM database privhead structure loaded from the device&n; * @ph:&t;&t;in memory privhead structure to return parsed information in&n; *&n; * This parses the LDM database PRIVHEAD structure supplied in @buffer and&n; * sets up the in memory privhead structure @ph with the obtained information.&n; *&n; * Return 1 on succes and -1 on error, in which case @ph is undefined.&n; */
DECL|function|parse_privhead
r_static
r_int
id|parse_privhead
c_func
(paren
r_const
id|u8
op_star
id|buffer
comma
r_struct
id|privhead
op_star
id|ph
)paren
(brace
r_if
c_cond
(paren
id|MAGIC_PRIVHEAD
op_ne
id|BE64
c_func
(paren
id|buffer
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_ERR
l_string|&quot;Cannot find PRIVHEAD structure. LDM database &quot;
l_string|&quot;is corrupt. Aborting.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ph-&gt;ver_major
op_assign
id|BE16
c_func
(paren
id|buffer
op_plus
l_int|0x000C
)paren
suffix:semicolon
id|ph-&gt;ver_minor
op_assign
id|BE16
c_func
(paren
id|buffer
op_plus
l_int|0x000E
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ph-&gt;ver_major
op_ne
l_int|2
)paren
op_logical_or
(paren
id|ph-&gt;ver_minor
op_ne
l_int|11
)paren
)paren
(brace
id|printk
c_func
(paren
id|LDM_ERR
l_string|&quot;Expected PRIVHEAD version %d.%d, got %d.%d. &quot;
l_string|&quot;Aborting.&bslash;n&quot;
comma
l_int|2
comma
l_int|11
comma
id|ph-&gt;ver_major
comma
id|ph-&gt;ver_minor
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ph-&gt;config_start
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x012B
)paren
suffix:semicolon
id|ph-&gt;config_size
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x0133
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ph-&gt;config_size
op_ne
id|LDM_DB_SIZE
)paren
(brace
multiline_comment|/* 1 MiB in sectors. */
id|printk
c_func
(paren
id|LDM_ERR
l_string|&quot;Database should be %u bytes, claims to be %Lu &quot;
l_string|&quot;bytes. Aborting.&bslash;n&quot;
comma
id|LDM_DB_SIZE
comma
id|ph-&gt;config_size
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ph-&gt;logical_disk_start
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x011B
)paren
suffix:semicolon
id|ph-&gt;logical_disk_size
op_assign
id|BE64
c_func
(paren
id|buffer
op_plus
l_int|0x0123
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ph-&gt;logical_disk_size
op_logical_or
id|ph-&gt;logical_disk_start
op_plus
id|ph-&gt;logical_disk_size
OG
id|ph-&gt;config_start
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|ph-&gt;disk_id
comma
id|buffer
op_plus
l_int|0x0030
comma
r_sizeof
(paren
id|ph-&gt;disk_id
)paren
)paren
suffix:semicolon
id|ldm_debug
c_func
(paren
l_string|&quot;Parsed PRIVHEAD successfully.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; * create_db_partition - create a dedicated partition for our database&n; * @hd:&t;&t;gendisk structure in which to create partition&n; * @dev:&t;device of which to create partition&n; * @ph:&t;&t;@dev&squot;s LDM database private header&n; *&n; * Find the primary private header, locate the LDM database, then create a&n; * partition to wrap it.&n; *&n; * Return 1 on succes, 0 if device is not a dynamic disk and -1 on error.&n; */
DECL|function|create_db_partition
r_static
r_int
id|create_db_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_const
r_int
r_int
id|first_sector
comma
r_const
r_int
id|first_part_minor
comma
r_struct
id|privhead
op_star
id|ph
)paren
(brace
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|err
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|OFF_PRIVHEAD1
op_star
l_int|2
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
(brace
id|printk
c_func
(paren
id|LDM_CRIT
id|__FUNCTION__
l_string|&quot;(): Device read failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BE64
c_func
(paren
id|data
)paren
op_ne
id|MAGIC_PRIVHEAD
)paren
(brace
id|ldm_debug
c_func
(paren
l_string|&quot;Cannot find PRIVHEAD structure. Not a dynamic disk &quot;
l_string|&quot;or corrupt LDM database.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|err
op_assign
id|parse_privhead
c_func
(paren
id|data
comma
id|ph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|1
)paren
id|err
op_assign
id|create_partition
c_func
(paren
id|hd
comma
id|first_part_minor
comma
id|first_sector
op_plus
id|ph-&gt;config_start
comma
id|ph-&gt;config_size
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * validate_patition_table - check whether @dev is a dynamic disk&n; * @dev:&t;device to test&n; *&n; * Check whether @dev is a dynamic disk by looking for an MS-DOS-style partition&n; * table with one or more entries of type 0x42 (the former Secure File System&n; * (Landis) partition type, now recycled by Microsoft for dynamic disks) in it.&n; * If this succeeds we assume we have a dynamic disk, and not otherwise.&n; *&n; * Return 1 if @dev is a dynamic disk, 0 if not and -1 on error.&n; */
DECL|function|validate_partition_table
r_static
r_int
id|validate_partition_table
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
id|i
comma
id|nr_sfs
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
l_int|0
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|u16
op_star
)paren
(paren
id|data
op_plus
l_int|0x01FE
)paren
op_ne
id|cpu_to_le16
c_func
(paren
id|MSDOS_LABEL_MAGIC
)paren
)paren
(brace
id|ldm_debug
c_func
(paren
l_string|&quot;No MS-DOS partition found.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|no_msdos_partition
suffix:semicolon
)brace
id|nr_sfs
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|data
op_plus
l_int|0x01BE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|SYS_IND
c_func
(paren
id|p
op_plus
id|i
)paren
op_logical_or
id|SYS_IND
c_func
(paren
id|p
op_plus
id|i
)paren
op_eq
id|WIN2K_EXTENDED_PARTITION
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
op_plus
id|i
)paren
op_eq
id|WIN2K_DYNAMIC_PARTITION
)paren
(brace
id|nr_sfs
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_goto
id|not_dynamic_disk
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nr_sfs
)paren
r_goto
id|not_dynamic_disk
suffix:semicolon
id|ldm_debug
c_func
(paren
l_string|&quot;Parsed partition table successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|not_dynamic_disk
suffix:colon
singleline_comment|//&t;ldm_debug(&quot;Found basic MS-DOS partition, not a dynamic disk.&bslash;n&quot;);
id|no_msdos_partition
suffix:colon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ldm_partition - find out whether a device is a dynamic disk and handle it&n; * @hd:&t;&t;&t;gendisk structure in which to return the handled disk&n; * @dev:&t;&t;device we need to look at&n; * @first_sector:&t;first sector within the device&n; * @first_part_minor:&t;first minor number of partitions for the device&n; *&n; * Description:&n; *&n; * This determines whether the device @dev is a dynamic disk and if so creates&n; * the partitions necessary in the gendisk structure pointed to by @hd.&n; *&n; * We create a dummy device 1, which contains the LDM database, we skip&n; * devices 2-4 and then create each partition described by the LDM database&n; * in sequence as devices 5 and following. For example, if the device is hda,&n; * we would have: hda1: LDM database, hda2-4: nothing, hda5-following: the&n; * actual data containing partitions.&n; *&n; * Return values:&n; *&n; *&t; 1 if @dev is a dynamic disk and we handled it,&n; *&t; 0 if @dev is not a dynamic disk,&n; *&t;-1 if an error occured.&n; */
DECL|function|ldm_partition
r_int
id|ldm_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
r_int
id|first_sector
comma
r_int
id|first_part_minor
)paren
(brace
r_struct
id|privhead
op_star
id|ph
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|tocblock
op_star
id|toc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vmdb
op_star
id|vm
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ldmdisk
op_star
id|dk
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|db_first
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hd
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Check the partition table. */
id|err
op_assign
id|validate_partition_table
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ph
op_assign
(paren
r_struct
id|privhead
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ph
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|no_mem
suffix:semicolon
multiline_comment|/* Create the LDM database device. */
id|err
op_assign
id|create_db_partition
c_func
(paren
id|hd
comma
id|bdev
comma
id|first_sector
comma
id|first_part_minor
comma
id|ph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
id|db_first
op_assign
id|hd-&gt;part
(braket
id|first_part_minor
)braket
dot
id|start_sect
suffix:semicolon
multiline_comment|/* Check the backup privheads. */
id|err
op_assign
id|validate_privheads
c_func
(paren
id|bdev
comma
id|ph
comma
id|db_first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check the table of contents and its backups. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|toc
op_assign
(paren
r_struct
id|tocblock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|toc
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|no_mem
suffix:semicolon
id|err
op_assign
id|validate_tocblocks
c_func
(paren
id|bdev
comma
id|toc
comma
id|db_first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check the vmdb. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|vm
op_assign
(paren
r_struct
id|vmdb
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|vm
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|no_mem
suffix:semicolon
id|err
op_assign
id|validate_vmdb
c_func
(paren
id|bdev
comma
id|vm
comma
id|db_first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Find the object id for @dev in the LDM database. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dk
op_assign
(paren
r_struct
id|ldmdisk
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|dk
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|no_mem
suffix:semicolon
id|err
op_assign
id|get_disk_objid
c_func
(paren
id|bdev
comma
id|vm
comma
id|ph
comma
id|dk
comma
id|db_first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|1
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Finally, create the data partition devices. */
id|err
op_assign
id|create_data_partitions
c_func
(paren
id|hd
comma
id|first_sector
comma
id|first_part_minor
op_plus
id|LDM_FIRST_PART_OFFSET
comma
id|bdev
comma
id|vm
comma
id|ph
comma
id|dk
comma
id|db_first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|1
)paren
id|ldm_debug
c_func
(paren
l_string|&quot;Parsed LDM database successfully.&bslash;n&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|kfree
c_func
(paren
id|ph
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|toc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|vm
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dk
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|no_mem
suffix:colon
id|printk
c_func
(paren
id|LDM_CRIT
l_string|&quot;Not enough memory to allocate required buffers.&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
eof
