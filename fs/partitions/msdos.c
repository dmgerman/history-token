multiline_comment|/*&n; *  fs/partitions/msdos.c&n; *&n; *  Code extracted from drivers/block/genhd.c&n; *  Copyright (C) 1991-1998  Linus Torvalds&n; *&n; *  Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug&n; *  in the early extended-partition checks and added DM partitions&n; *&n; *  Support for DiskManager v6.0x added by Mark Lord,&n; *  with information provided by OnTrack.  This now works for linux fdisk&n; *  and LILO, as well as loadlin and bootln.  Note that disks other than&n; *  /dev/hda *must* have a &quot;DOS&quot; type 0x51 partition in the first slot (hda1).&n; *&n; *  More flexible handling of extended partitions - aeb, 950831&n; *&n; *  Check partition table on IDE disks for common CHS translations&n; *&n; *  Re-organised Feb 1998 Russell King&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;&t;&t;/* for invalidate_bdev() */
macro_line|#ifdef CONFIG_BLK_DEV_IDE
macro_line|#include &lt;linux/ide.h&gt;&t;/* IDE xlate */
macro_line|#elif defined(CONFIG_BLK_DEV_IDE_MODULE)
macro_line|#include &lt;linux/module.h&gt;
DECL|variable|ide_xlate_1024_hook
r_int
(paren
op_star
id|ide_xlate_1024_hook
)paren
(paren
id|kdev_t
comma
r_int
comma
r_int
comma
r_const
r_char
op_star
)paren
suffix:semicolon
DECL|variable|ide_xlate_1024_hook
id|EXPORT_SYMBOL
c_func
(paren
id|ide_xlate_1024_hook
)paren
suffix:semicolon
DECL|macro|ide_xlate_1024
mdefine_line|#define ide_xlate_1024 ide_xlate_1024_hook
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;check.h&quot;
macro_line|#include &quot;msdos.h&quot;
macro_line|#include &quot;efi.h&quot;
macro_line|#if CONFIG_BLK_DEV_MD
r_extern
r_void
id|md_autodetect_dev
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Many architectures don&squot;t like unaligned accesses, which is&n; * frequently the case with the nr_sects and start_sect partition&n; * table entries.&n; */
macro_line|#include &lt;asm/unaligned.h&gt;
DECL|macro|SYS_IND
mdefine_line|#define SYS_IND(p)&t;(get_unaligned(&amp;p-&gt;sys_ind))
DECL|macro|NR_SECTS
mdefine_line|#define NR_SECTS(p)&t;({ __typeof__(p-&gt;nr_sects) __a =&t;&bslash;&n;&t;&t;&t;&t;get_unaligned(&amp;p-&gt;nr_sects);&t;&bslash;&n;&t;&t;&t;&t;le32_to_cpu(__a); &bslash;&n;&t;&t;&t;})
DECL|macro|START_SECT
mdefine_line|#define START_SECT(p)&t;({ __typeof__(p-&gt;start_sect) __a =&t;&bslash;&n;&t;&t;&t;&t;get_unaligned(&amp;p-&gt;start_sect);&t;&bslash;&n;&t;&t;&t;&t;le32_to_cpu(__a); &bslash;&n;&t;&t;&t;})
DECL|function|is_extended_partition
r_static
r_inline
r_int
id|is_extended_partition
c_func
(paren
r_struct
id|partition
op_star
id|p
)paren
(brace
r_return
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DOS_EXTENDED_PARTITION
op_logical_or
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|WIN98_EXTENDED_PARTITION
op_logical_or
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|LINUX_EXTENDED_PARTITION
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * partition_name() formats the short partition name into the supplied&n; * buffer, and returns a pointer to that buffer.&n; * Used by several partition types which makes conditional inclusion messy,&n; * use __attribute__ ((unused)) instead.&n; */
r_static
r_char
id|__attribute__
(paren
(paren
id|unused
)paren
)paren
DECL|function|partition_name
op_star
id|partition_name
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_int
id|minor
comma
r_char
op_star
id|buf
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_FS
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;p%d&quot;
comma
(paren
id|minor
op_amp
(paren
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
macro_line|#else
r_return
id|disk_name
c_func
(paren
id|hd
comma
id|minor
comma
id|buf
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|macro|MSDOS_LABEL_MAGIC1
mdefine_line|#define MSDOS_LABEL_MAGIC1&t;0x55
DECL|macro|MSDOS_LABEL_MAGIC2
mdefine_line|#define MSDOS_LABEL_MAGIC2&t;0xAA
r_static
r_inline
r_int
DECL|function|msdos_magic_present
id|msdos_magic_present
c_func
(paren
r_int
r_char
op_star
id|p
)paren
(brace
r_return
(paren
id|p
(braket
l_int|0
)braket
op_eq
id|MSDOS_LABEL_MAGIC1
op_logical_and
id|p
(braket
l_int|1
)braket
op_eq
id|MSDOS_LABEL_MAGIC2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create devices for each logical partition in an extended partition.&n; * The logical partitions form a linked list, with each entry being&n; * a partition table with two entries.  The first entry&n; * is the real data partition (with a start relative to the partition&n; * table start).  The second is a pointer to the next logical partition&n; * (with a start relative to the entire extended partition).&n; * We do not create a Linux partition for the partition tables, but&n; * only for the actual data partitions.&n; */
DECL|function|extended_partition
r_static
r_void
id|extended_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
r_int
id|first_size
comma
r_int
op_star
id|current_minor
)paren
(brace
r_struct
id|partition
op_star
id|p
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
r_int
id|first_sector
comma
id|this_sector
comma
id|this_size
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|sector_size
op_assign
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
op_div
l_int|512
suffix:semicolon
r_int
id|loopct
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of links followed&n;&t;&t;&t;&t;   without finding a data partition */
r_int
id|i
suffix:semicolon
id|this_sector
op_assign
id|first_sector
op_assign
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
id|this_size
op_assign
id|first_size
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_increment
id|loopct
OG
l_int|100
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|this_sector
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msdos_magic_present
c_func
(paren
id|data
op_plus
l_int|510
)paren
)paren
r_goto
id|done
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|data
op_plus
l_int|0x1be
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Usually, the first entry is the real data partition,&n;&t;&t; * the 2nd entry is the next extended partition, or empty,&n;&t;&t; * and the 3rd and 4th entries are unused.&n;&t;&t; * However, DRDOS sometimes has the extended partition as&n;&t;&t; * the first entry (when the data partition is empty),&n;&t;&t; * and OS/2 seems to use all four entries.&n;&t;&t; */
multiline_comment|/* &n;&t;&t; * First process the data partition(s)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_int
r_int
id|offs
comma
id|size
comma
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NR_SECTS
c_func
(paren
id|p
)paren
op_logical_or
id|is_extended_partition
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check the 3rd and 4th entries -&n;&t;&t;&t;   these sometimes contain random garbage */
id|offs
op_assign
id|START_SECT
c_func
(paren
id|p
)paren
op_star
id|sector_size
suffix:semicolon
id|size
op_assign
id|NR_SECTS
c_func
(paren
id|p
)paren
op_star
id|sector_size
suffix:semicolon
id|next
op_assign
id|this_sector
op_plus
id|offs
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|offs
op_plus
id|size
OG
id|this_size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|next
OL
id|first_sector
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|next
op_plus
id|size
OG
id|first_sector
op_plus
id|first_size
)paren
r_continue
suffix:semicolon
)brace
id|add_gd_partition
c_func
(paren
id|hd
comma
op_star
id|current_minor
comma
id|next
comma
id|size
)paren
suffix:semicolon
macro_line|#if CONFIG_BLK_DEV_MD
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|LINUX_RAID_PARTITION
)paren
(brace
id|md_autodetect_dev
c_func
(paren
id|mk_kdev
c_func
(paren
id|hd-&gt;major
comma
op_star
id|current_minor
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
(paren
op_star
id|current_minor
)paren
op_increment
suffix:semicolon
id|loopct
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Next, process the (first) extended partition, if present.&n;&t;&t; * (So far, there seems to be no reason to make&n;&t;&t; *  extended_partition()  recursive and allow a tree&n;&t;&t; *  of extended partitions.)&n;&t;&t; * It should be a link to the next logical partition.&n;&t;&t; * Create a minor for this just long enough to get the next&n;&t;&t; * partition table.  The minor will be reused for the next&n;&t;&t; * data partition.&n;&t;&t; */
id|p
op_sub_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
id|NR_SECTS
c_func
(paren
id|p
)paren
op_logical_and
id|is_extended_partition
c_func
(paren
id|p
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|4
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* nothing left to do */
id|this_sector
op_assign
id|first_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
op_star
id|sector_size
suffix:semicolon
id|this_size
op_assign
id|NR_SECTS
c_func
(paren
id|p
)paren
op_star
id|sector_size
suffix:semicolon
id|minor
op_assign
op_star
id|current_minor
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
)brace
multiline_comment|/* james@bpgc.com: Solaris has a nasty indicator: 0x82 which also&n;   indicates linux swap.  Be careful before believing this is Solaris. */
r_static
r_void
DECL|function|solaris_x86_partition
id|solaris_x86_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
op_star
id|current_minor
)paren
(brace
macro_line|#ifdef CONFIG_SOLARIS_X86_PARTITION
r_int
id|offset
op_assign
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
r_struct
id|solaris_x86_vtoc
op_star
id|v
suffix:semicolon
r_struct
id|solaris_x86_slice
op_star
id|s
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
id|v
op_assign
(paren
r_struct
id|solaris_x86_vtoc
op_star
)paren
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|offset
op_plus
l_int|1
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|v
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|v-&gt;v_sanity
)paren
op_ne
id|SOLARIS_X86_VTOC_SANE
)paren
(brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %s: &lt;solaris:&quot;
comma
id|partition_name
c_func
(paren
id|hd
comma
id|minor
comma
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|v-&gt;v_version
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  cannot handle version %d vtoc&gt;&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|v-&gt;v_version
)paren
)paren
suffix:semicolon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOLARIS_X86_NUMSLICE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|s
op_assign
op_amp
id|v-&gt;v_slice
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;s_size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; [s%d]&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* solaris partitions are relative to current MS-DOS&n;&t;&t; * one but add_gd_partition starts relative to sector&n;&t;&t; * zero of the disk.  Therefore, must add the offset&n;&t;&t; * of the current partition */
id|add_gd_partition
c_func
(paren
id|hd
comma
op_star
id|current_minor
comma
id|le32_to_cpu
c_func
(paren
id|s-&gt;s_start
)paren
op_plus
id|offset
comma
id|le32_to_cpu
c_func
(paren
id|s-&gt;s_size
)paren
)paren
suffix:semicolon
(paren
op_star
id|current_minor
)paren
op_increment
suffix:semicolon
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &gt;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_BSD_DISKLABEL
multiline_comment|/* &n; * Create devices for BSD partitions listed in a disklabel, under a&n; * dos-like partition. See extended_partition() for more information.&n; */
DECL|function|do_bsd_partition
r_static
r_void
id|do_bsd_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
op_star
id|current_minor
comma
r_char
op_star
id|name
comma
r_int
id|max_partitions
)paren
(brace
r_int
id|offset
op_assign
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
r_struct
id|bsd_disklabel
op_star
id|l
suffix:semicolon
r_struct
id|bsd_partition
op_star
id|p
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
id|l
op_assign
(paren
r_struct
id|bsd_disklabel
op_star
)paren
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|offset
op_plus
l_int|1
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|l
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|l-&gt;d_magic
)paren
op_ne
id|BSD_DISKMAGIC
)paren
(brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %s: &lt;%s:&quot;
comma
id|partition_name
c_func
(paren
id|hd
comma
id|minor
comma
id|buf
)paren
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|l-&gt;d_npartitions
)paren
OL
id|max_partitions
)paren
id|max_partitions
op_assign
id|le16_to_cpu
c_func
(paren
id|l-&gt;d_npartitions
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|l-&gt;d_partitions
suffix:semicolon
id|p
op_minus
id|l-&gt;d_partitions
OL
id|max_partitions
suffix:semicolon
id|p
op_increment
)paren
(brace
r_int
id|bsd_start
comma
id|bsd_size
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_fstype
op_eq
id|BSD_FS_UNUSED
)paren
r_continue
suffix:semicolon
id|bsd_start
op_assign
id|le32_to_cpu
c_func
(paren
id|p-&gt;p_offset
)paren
suffix:semicolon
id|bsd_size
op_assign
id|le32_to_cpu
c_func
(paren
id|p-&gt;p_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_and_add_subpartition
c_func
(paren
id|hd
comma
id|minor
comma
op_star
id|current_minor
comma
id|bsd_start
comma
id|bsd_size
)paren
)paren
(paren
op_star
id|current_minor
)paren
op_increment
suffix:semicolon
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|bsd_partition
r_static
r_void
id|bsd_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
op_star
id|current_minor
)paren
(brace
macro_line|#ifdef CONFIG_BSD_DISKLABEL
id|do_bsd_partition
c_func
(paren
id|hd
comma
id|bdev
comma
id|minor
comma
id|current_minor
comma
l_string|&quot;bsd&quot;
comma
id|BSD_MAXPARTITIONS
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|netbsd_partition
r_static
r_void
id|netbsd_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
op_star
id|current_minor
)paren
(brace
macro_line|#ifdef CONFIG_BSD_DISKLABEL
id|do_bsd_partition
c_func
(paren
id|hd
comma
id|bdev
comma
id|minor
comma
id|current_minor
comma
l_string|&quot;netbsd&quot;
comma
id|BSD_MAXPARTITIONS
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|openbsd_partition
r_static
r_void
id|openbsd_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
op_star
id|current_minor
)paren
(brace
macro_line|#ifdef CONFIG_BSD_DISKLABEL
id|do_bsd_partition
c_func
(paren
id|hd
comma
id|bdev
comma
id|minor
comma
id|current_minor
comma
l_string|&quot;openbsd&quot;
comma
id|OPENBSD_MAXPARTITIONS
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Create devices for Unixware partitions listed in a disklabel, under a&n; * dos-like partition. See extended_partition() for more information.&n; */
DECL|function|unixware_partition
r_static
r_void
id|unixware_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
op_star
id|current_minor
)paren
(brace
macro_line|#ifdef CONFIG_UNIXWARE_DISKLABEL
r_int
id|offset
op_assign
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
r_struct
id|unixware_disklabel
op_star
id|l
suffix:semicolon
r_struct
id|unixware_slice
op_star
id|p
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
id|l
op_assign
(paren
r_struct
id|unixware_disklabel
op_star
)paren
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|offset
op_plus
l_int|29
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|l
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|l-&gt;d_magic
)paren
op_ne
id|UNIXWARE_DISKMAGIC
op_logical_or
id|le32_to_cpu
c_func
(paren
id|l-&gt;vtoc.v_magic
)paren
op_ne
id|UNIXWARE_DISKMAGIC2
)paren
(brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %s: &lt;unixware:&quot;
comma
id|partition_name
c_func
(paren
id|hd
comma
id|minor
comma
id|buf
)paren
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|l-&gt;vtoc.v_slice
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* I omit the 0th slice as it is the same as whole disk. */
r_while
c_loop
(paren
id|p
op_minus
op_amp
id|l-&gt;vtoc.v_slice
(braket
l_int|0
)braket
OL
id|UNIXWARE_NUMSLICE
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;s_label
op_ne
id|UNIXWARE_FS_UNUSED
)paren
(brace
id|add_gd_partition
c_func
(paren
id|hd
comma
op_star
id|current_minor
comma
id|START_SECT
c_func
(paren
id|p
)paren
comma
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
(paren
op_star
id|current_minor
)paren
op_increment
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &gt;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Minix 2.0.0/2.0.2 subpartition support.&n; * Anand Krishnamurthy &lt;anandk@wiproge.med.ge.com&gt;&n; * Rajeev V. Pillai    &lt;rajeevvp@yahoo.com&gt;&n; */
DECL|function|minix_partition
r_static
r_void
id|minix_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
id|minor
comma
r_int
op_star
id|current_minor
)paren
(brace
macro_line|#ifdef CONFIG_MINIX_SUBPARTITION
r_int
id|offset
op_assign
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
id|offset
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|data
op_plus
l_int|0x1be
)paren
suffix:semicolon
multiline_comment|/* The first sector of a Minix partition can have either&n;&t; * a secondary MBR describing its subpartitions, or&n;&t; * the normal boot sector. */
r_if
c_cond
(paren
id|msdos_magic_present
(paren
id|data
op_plus
l_int|510
)paren
op_logical_and
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|MINIX_PARTITION
)paren
(brace
multiline_comment|/* subpartition table present */
id|printk
c_func
(paren
l_string|&quot; %s: &lt;minix:&quot;
comma
id|partition_name
c_func
(paren
id|hd
comma
id|minor
comma
id|buf
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MINIX_NR_SUBPARTITIONS
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* add each partition in use */
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|MINIX_PARTITION
)paren
(brace
id|add_gd_partition
c_func
(paren
id|hd
comma
op_star
id|current_minor
comma
id|START_SECT
c_func
(paren
id|p
)paren
comma
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
(paren
op_star
id|current_minor
)paren
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; &gt;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_MINIX_SUBPARTITION */
)brace
r_static
r_struct
(brace
DECL|member|id
r_int
r_char
id|id
suffix:semicolon
DECL|member|parse
r_void
(paren
op_star
id|parse
)paren
(paren
r_struct
id|gendisk
op_star
comma
r_struct
id|block_device
op_star
comma
r_int
comma
r_int
op_star
)paren
suffix:semicolon
DECL|variable|subtypes
)brace
id|subtypes
(braket
)braket
op_assign
(brace
(brace
id|BSD_PARTITION
comma
id|bsd_partition
)brace
comma
(brace
id|NETBSD_PARTITION
comma
id|netbsd_partition
)brace
comma
(brace
id|OPENBSD_PARTITION
comma
id|openbsd_partition
)brace
comma
(brace
id|MINIX_PARTITION
comma
id|minix_partition
)brace
comma
(brace
id|UNIXWARE_PARTITION
comma
id|unixware_partition
)brace
comma
(brace
id|SOLARIS_X86_PARTITION
comma
id|solaris_x86_partition
)brace
comma
(brace
l_int|0
comma
l_int|NULL
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Look for various forms of IDE disk geometry translation&n; */
DECL|function|handle_ide_mess
r_static
r_int
id|handle_ide_mess
c_func
(paren
r_struct
id|block_device
op_star
id|bdev
)paren
(brace
macro_line|#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
id|Sector
id|sect
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|to_kdev_t
c_func
(paren
id|bdev-&gt;bd_dev
)paren
suffix:semicolon
r_int
r_int
id|sig
suffix:semicolon
r_int
id|heads
op_assign
l_int|0
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE_MODULE
r_if
c_cond
(paren
op_logical_neg
id|ide_xlate_1024
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * The i386 partition handling programs very often&n;&t; * make partitions end on cylinder boundaries.&n;&t; * There is no need to do so, and Linux fdisk doesnt always&n;&t; * do this, and Windows NT on Alpha doesnt do this either,&n;&t; * but still, this helps to guess #heads.&n;&t; */
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
l_int|0
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msdos_magic_present
c_func
(paren
id|data
op_plus
l_int|510
)paren
)paren
(brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sig
op_assign
id|le16_to_cpu
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|data
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|data
op_plus
l_int|0x1be
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|partition
op_star
id|q
op_assign
op_amp
id|p
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|NR_SECTS
c_func
(paren
id|q
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|q-&gt;sector
op_amp
l_int|63
)paren
op_eq
l_int|1
op_logical_and
(paren
id|q-&gt;end_sector
op_amp
l_int|63
)paren
op_eq
l_int|63
)paren
id|heads
op_assign
id|q-&gt;end_head
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|EZD_PARTITION
)paren
(brace
multiline_comment|/*&n;&t;&t; * Accesses to sector 0 must go to sector 1 instead.&n;&t;&t; */
r_if
c_cond
(paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
op_minus
l_int|1
comma
id|heads
comma
l_string|&quot; [EZD]&quot;
)paren
)paren
r_goto
id|reread
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DM6_PARTITION
)paren
(brace
multiline_comment|/*&n;&t;&t; * Everything on the disk is offset by 63 sectors,&n;&t;&t; * including a &quot;new&quot; MBR with its own partition table.&n;&t;&t; */
r_if
c_cond
(paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
l_int|1
comma
id|heads
comma
l_string|&quot; [DM6:DDO]&quot;
)paren
)paren
r_goto
id|reread
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sig
op_le
l_int|0x1ae
op_logical_and
id|data
(braket
id|sig
)braket
op_eq
l_int|0xAA
op_logical_and
id|data
(braket
id|sig
op_plus
l_int|1
)braket
op_eq
l_int|0x55
op_logical_and
(paren
id|data
(braket
id|sig
op_plus
l_int|2
)braket
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* DM6 signature in MBR, courtesy of OnTrack */
(paren
r_void
)paren
id|ide_xlate_1024
(paren
id|dev
comma
l_int|0
comma
id|heads
comma
l_string|&quot; [DM6:MBR]&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DM6_AUX1PARTITION
op_logical_or
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DM6_AUX3PARTITION
)paren
(brace
multiline_comment|/*&n;&t;&t; * DM6 on other than the first (boot) drive&n;&t;&t; */
(paren
r_void
)paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
l_int|0
comma
id|heads
comma
l_string|&quot; [DM6:AUX]&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
(paren
r_void
)paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
l_int|2
comma
id|heads
comma
l_string|&quot; [PTBL]&quot;
)paren
suffix:semicolon
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|reread
suffix:colon
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
multiline_comment|/* Flush the cache */
id|invalidate_bdev
c_func
(paren
id|bdev
comma
l_int|1
)paren
suffix:semicolon
id|truncate_inode_pages
c_func
(paren
id|bdev-&gt;bd_inode-&gt;i_mapping
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE) */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|msdos_partition
r_int
id|msdos_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_struct
id|block_device
op_star
id|bdev
comma
r_int
r_int
id|first_sector
comma
r_int
id|first_part_minor
)paren
(brace
r_int
id|i
comma
id|minor
op_assign
id|first_part_minor
suffix:semicolon
id|Sector
id|sect
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|sector_size
op_assign
id|bdev_hardsect_size
c_func
(paren
id|bdev
)paren
op_div
l_int|512
suffix:semicolon
r_int
id|current_minor
op_assign
id|first_part_minor
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|handle_ide_mess
c_func
(paren
id|bdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_le
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|data
op_assign
id|read_dev_sector
c_func
(paren
id|bdev
comma
l_int|0
comma
op_amp
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msdos_magic_present
c_func
(paren
id|data
op_plus
l_int|510
)paren
)paren
(brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|data
op_plus
l_int|0x1be
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_EFI_PARTITION
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
multiline_comment|/* If this is an EFI GPT disk, msdos should ignore it. */
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|EFI_PMBR_OSTYPE_EFI_GPT
)paren
(brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
id|data
op_plus
l_int|0x1be
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Look for partitions in two passes:&n;&t; * First find the primary and DOS-type extended partitions.&n;&t; * On the second pass look inside *BSD, Unixware and Solaris partitions.&n;&t; */
id|current_minor
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|4
suffix:semicolon
id|minor
op_increment
comma
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
id|add_gd_partition
c_func
(paren
id|hd
comma
id|minor
comma
id|first_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
op_star
id|sector_size
comma
id|NR_SECTS
c_func
(paren
id|p
)paren
op_star
id|sector_size
)paren
suffix:semicolon
macro_line|#if CONFIG_BLK_DEV_MD
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|LINUX_RAID_PARTITION
)paren
(brace
id|md_autodetect_dev
c_func
(paren
id|mk_kdev
c_func
(paren
id|hd-&gt;major
comma
id|minor
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|is_extended_partition
c_func
(paren
id|p
)paren
)paren
(brace
r_int
r_int
id|size
op_assign
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &lt;&quot;
)paren
suffix:semicolon
multiline_comment|/* prevent someone doing mkfs or mkswap on an&n;&t;&t;&t;   extended partition, but leave room for LILO */
r_if
c_cond
(paren
id|size
OG
l_int|2
)paren
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
l_int|2
suffix:semicolon
id|extended_partition
c_func
(paren
id|hd
comma
id|bdev
comma
id|minor
comma
id|size
comma
op_amp
id|current_minor
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *  Check for old-style Disk Manager partition table&n;&t; */
r_if
c_cond
(paren
id|msdos_magic_present
c_func
(paren
id|data
op_plus
l_int|0xfc
)paren
)paren
(brace
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
l_int|0x1be
op_plus
id|data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
comma
id|current_minor
op_increment
)paren
(brace
id|p
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|START_SECT
c_func
(paren
id|p
)paren
op_logical_and
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
)paren
r_continue
suffix:semicolon
id|add_gd_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|START_SECT
c_func
(paren
id|p
)paren
comma
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* second pass - output for each on a separate line */
id|minor
op_sub_assign
l_int|4
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
l_int|0x1be
op_plus
id|data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|4
suffix:semicolon
id|minor
op_increment
comma
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_int
r_char
id|id
op_assign
id|SYS_IND
c_func
(paren
id|p
)paren
suffix:semicolon
r_int
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|subtypes
(braket
id|n
)braket
dot
id|parse
op_logical_and
id|id
op_ne
id|subtypes
(braket
id|n
)braket
dot
id|id
suffix:semicolon
id|n
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subtypes
(braket
id|n
)braket
dot
id|parse
)paren
id|subtypes
(braket
id|n
)braket
dot
id|parse
c_func
(paren
id|hd
comma
id|bdev
comma
id|minor
comma
op_amp
id|current_minor
)paren
suffix:semicolon
)brace
id|put_dev_sector
c_func
(paren
id|sect
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
