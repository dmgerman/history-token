multiline_comment|/*&n; *  request.c&n; *&n; *  Copyright (C) 2001 by Urban Widmark&n; *&n; *  Please add a note about your changes to smbfs in the ChangeLog file.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/smb_fs.h&gt;
macro_line|#include &lt;linux/smbno.h&gt;
macro_line|#include &lt;linux/smb_mount.h&gt;
macro_line|#include &quot;smb_debug.h&quot;
macro_line|#include &quot;request.h&quot;
macro_line|#include &quot;proto.h&quot;
multiline_comment|/* #define SMB_SLAB_DEBUG&t;(SLAB_RED_ZONE | SLAB_POISON) */
DECL|macro|SMB_SLAB_DEBUG
mdefine_line|#define SMB_SLAB_DEBUG&t;0
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP(x) (((x)+3) &amp; ~3)
multiline_comment|/* cache for request structures */
DECL|variable|req_cachep
r_static
id|kmem_cache_t
op_star
id|req_cachep
suffix:semicolon
r_static
r_int
id|smb_request_send_req
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
suffix:semicolon
multiline_comment|/*&n;  /proc/slabinfo:&n;  name, active, num, objsize, active_slabs, num_slaps, #pages&n;*/
DECL|function|smb_init_request_cache
r_int
id|smb_init_request_cache
c_func
(paren
r_void
)paren
(brace
id|req_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;smb_request&quot;
comma
r_sizeof
(paren
r_struct
id|smb_request
)paren
comma
l_int|0
comma
id|SMB_SLAB_DEBUG
op_or
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|smb_destroy_request_cache
r_void
id|smb_destroy_request_cache
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|req_cachep
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;smb_destroy_request_cache: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate and initialise a request structure&n; */
DECL|function|smb_do_alloc_request
r_static
r_struct
id|smb_request
op_star
id|smb_do_alloc_request
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_int
id|bufsize
)paren
(brace
r_struct
id|smb_request
op_star
id|req
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
l_int|NULL
suffix:semicolon
id|req
op_assign
id|kmem_cache_alloc
c_func
(paren
id|req_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;allocating request: %p&bslash;n&quot;
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|bufsize
OG
l_int|0
)paren
(brace
id|buf
op_assign
id|smb_kmalloc
c_func
(paren
id|bufsize
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|req_cachep
comma
id|req
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|memset
c_func
(paren
id|req
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|smb_request
)paren
)paren
suffix:semicolon
id|req-&gt;rq_buffer
op_assign
id|buf
suffix:semicolon
id|req-&gt;rq_bufsize
op_assign
id|bufsize
suffix:semicolon
id|req-&gt;rq_server
op_assign
id|server
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|req-&gt;rq_wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|req-&gt;rq_queue
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|req-&gt;rq_count
comma
l_int|1
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|req
suffix:semicolon
)brace
DECL|function|smb_alloc_request
r_struct
id|smb_request
op_star
id|smb_alloc_request
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_int
id|bufsize
)paren
(brace
r_struct
id|smb_request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|server-&gt;nr_requests
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|server-&gt;nr_requests
)paren
op_le
id|MAX_REQUEST_HARD
)paren
(brace
id|req
op_assign
id|smb_do_alloc_request
c_func
(paren
id|server
comma
id|bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t;&t; * Try to free up at least one request in order to stay&n;&t;&t; * below the hard limit&n;&t;&t; */
r_if
c_cond
(paren
id|nfs_try_to_free_pages
c_func
(paren
id|server
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
op_logical_and
(paren
id|server-&gt;flags
op_amp
id|NFS_MOUNT_INTR
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
id|current-&gt;policy
op_assign
id|SCHED_YIELD
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* FIXME: we want something like nfs does above, but that&n;&t;&t;   requires changes to all callers and can wait. */
r_break
suffix:semicolon
macro_line|#endif
)brace
r_return
id|req
suffix:semicolon
)brace
DECL|function|smb_free_request
r_static
r_void
id|smb_free_request
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|req-&gt;rq_server-&gt;nr_requests
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_buffer
op_logical_and
op_logical_neg
(paren
id|req-&gt;rq_flags
op_amp
id|SMB_REQ_STATIC
)paren
)paren
id|smb_kfree
c_func
(paren
id|req-&gt;rq_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_trans2buffer
)paren
id|smb_kfree
c_func
(paren
id|req-&gt;rq_trans2buffer
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|req_cachep
comma
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * What prevents a rget to race with a rput? The count must never drop to zero&n; * while it is in use. Only rput if it is ok that it is free&squot;d.&n; */
DECL|function|smb_rget
r_static
r_void
id|smb_rget
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|req-&gt;rq_count
)paren
suffix:semicolon
)brace
DECL|function|smb_rput
r_void
id|smb_rput
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|req-&gt;rq_count
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;rq_queue
)paren
suffix:semicolon
id|smb_free_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* setup to receive the data part of the SMB */
DECL|function|smb_setup_bcc
r_static
r_int
id|smb_setup_bcc
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_rlen
op_assign
id|smb_len
c_func
(paren
id|req-&gt;rq_header
)paren
op_plus
l_int|4
op_minus
id|req-&gt;rq_bytes_recvd
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_rlen
OG
id|req-&gt;rq_bufsize
)paren
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;Packet too large %d &gt; %d&bslash;n&quot;
comma
id|req-&gt;rq_rlen
comma
id|req-&gt;rq_bufsize
)paren
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|req-&gt;rq_iov
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|req-&gt;rq_buffer
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|req-&gt;rq_rlen
suffix:semicolon
id|req-&gt;rq_iovlen
op_assign
l_int|1
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a &quot;normal&quot; request structure.&n; */
DECL|function|smb_setup_request
r_static
r_int
id|smb_setup_request
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_int
id|len
op_assign
id|smb_len
c_func
(paren
id|req-&gt;rq_header
)paren
op_plus
l_int|4
suffix:semicolon
id|req-&gt;rq_slen
op_assign
id|len
suffix:semicolon
multiline_comment|/* if we expect a data part in the reply we set the iov&squot;s to read it */
r_if
c_cond
(paren
id|req-&gt;rq_resp_bcc
)paren
id|req-&gt;rq_setup_read
op_assign
id|smb_setup_bcc
suffix:semicolon
multiline_comment|/* This tries to support re-using the same request */
id|req-&gt;rq_bytes_sent
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_rcls
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_err
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_errno
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_fragment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_trans2buffer
)paren
id|smb_kfree
c_func
(paren
id|req-&gt;rq_trans2buffer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Prepare a transaction2 request structure&n; */
DECL|function|smb_setup_trans2request
r_static
r_int
id|smb_setup_trans2request
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_struct
id|smb_sb_info
op_star
id|server
op_assign
id|req-&gt;rq_server
suffix:semicolon
r_int
id|mparam
comma
id|mdata
suffix:semicolon
r_static
r_int
r_char
id|padding
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* I know the following is very ugly, but I want to build the&n;&t;   smb packet as efficiently as possible. */
r_const
r_int
id|smb_parameters
op_assign
l_int|15
suffix:semicolon
r_const
r_int
id|header
op_assign
id|SMB_HEADER_LEN
op_plus
l_int|2
op_star
id|smb_parameters
op_plus
l_int|2
suffix:semicolon
r_const
r_int
id|oparam
op_assign
id|ROUND_UP
c_func
(paren
id|header
op_plus
l_int|3
)paren
suffix:semicolon
r_const
r_int
id|odata
op_assign
id|ROUND_UP
c_func
(paren
id|oparam
op_plus
id|req-&gt;rq_lparm
)paren
suffix:semicolon
r_const
r_int
id|bcc
op_assign
(paren
id|req-&gt;rq_data
ques
c_cond
id|odata
op_plus
id|req-&gt;rq_ldata
suffix:colon
id|oparam
op_plus
id|req-&gt;rq_lparm
)paren
op_minus
id|header
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bcc
op_plus
id|oparam
)paren
OG
id|server-&gt;opt.max_xmit
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|smb_setup_header
c_func
(paren
id|req
comma
id|SMBtrans2
comma
id|smb_parameters
comma
id|bcc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * max parameters + max data + max setup == bufsize to make NT4 happy&n;&t; * and not abort the transfer or split into multiple responses. It also&n;&t; * makes smbfs happy as handling packets larger than the buffer size&n;&t; * is extra work.&n;&t; *&n;&t; * OS/2 is probably going to hate me for this ...&n;&t; */
id|mparam
op_assign
id|SMB_TRANS2_MAX_PARAM
suffix:semicolon
id|mdata
op_assign
id|req-&gt;rq_bufsize
op_minus
id|mparam
suffix:semicolon
id|mdata
op_assign
id|server-&gt;opt.max_xmit
op_minus
id|mparam
op_minus
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|mdata
OL
l_int|1024
)paren
(brace
id|mdata
op_assign
l_int|1024
suffix:semicolon
id|mparam
op_assign
l_int|20
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* NT/win2k has ~4k max_xmit, so with this we request more than it wants&n;&t;   to return as one SMB. Useful for testing the fragmented trans2&n;&t;   handling. */
id|mdata
op_assign
l_int|8192
suffix:semicolon
macro_line|#endif
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_tpscnt
comma
id|req-&gt;rq_lparm
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_tdscnt
comma
id|req-&gt;rq_ldata
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_mprcnt
comma
id|mparam
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_mdrcnt
comma
id|mdata
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_msrcnt
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* max setup always 0 ? */
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_flags
comma
l_int|0
)paren
suffix:semicolon
id|DSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_timeout
comma
l_int|0
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_pscnt
comma
id|req-&gt;rq_lparm
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_psoff
comma
id|oparam
op_minus
l_int|4
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_dscnt
comma
id|req-&gt;rq_ldata
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_dsoff
comma
id|req-&gt;rq_data
ques
c_cond
id|odata
op_minus
l_int|4
suffix:colon
l_int|0
)paren
suffix:semicolon
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_suwcnt
)paren
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* setup count */
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_suwcnt
op_plus
l_int|1
)paren
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* reserved */
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_setup0
comma
id|req-&gt;rq_trans2_command
)paren
suffix:semicolon
id|req-&gt;rq_iovlen
op_assign
l_int|2
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
(paren
r_void
op_star
)paren
id|req-&gt;rq_header
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|oparam
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|1
)braket
dot
id|iov_base
op_assign
(paren
id|req-&gt;rq_parm
op_eq
l_int|NULL
)paren
ques
c_cond
id|padding
suffix:colon
id|req-&gt;rq_parm
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|1
)braket
dot
id|iov_len
op_assign
id|req-&gt;rq_lparm
suffix:semicolon
id|req-&gt;rq_slen
op_assign
id|oparam
op_plus
id|req-&gt;rq_lparm
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_data
)paren
(brace
id|req-&gt;rq_iovlen
op_add_assign
l_int|2
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|2
)braket
dot
id|iov_base
op_assign
id|padding
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|2
)braket
dot
id|iov_len
op_assign
id|odata
op_minus
id|oparam
op_minus
id|req-&gt;rq_lparm
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|3
)braket
dot
id|iov_base
op_assign
id|req-&gt;rq_data
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|3
)braket
dot
id|iov_len
op_assign
id|req-&gt;rq_ldata
suffix:semicolon
id|req-&gt;rq_slen
op_assign
id|odata
op_plus
id|req-&gt;rq_ldata
suffix:semicolon
)brace
multiline_comment|/* always a data part for trans2 replies */
id|req-&gt;rq_setup_read
op_assign
id|smb_setup_bcc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a request and tell smbiod to process it&n; */
DECL|function|smb_add_request
r_int
id|smb_add_request
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_int
id|timeleft
suffix:semicolon
r_struct
id|smb_sb_info
op_star
id|server
op_assign
id|req-&gt;rq_server
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|smb_setup_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_trans2_command
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;rq_buffer
op_eq
l_int|NULL
)paren
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;trans2 attempted without response buffer!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|result
op_assign
id|smb_setup_trans2request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
macro_line|#ifdef SMB_DEBUG_PACKET_SIZE
id|add_xmit_stats
c_func
(paren
id|req
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* add &squot;req&squot; to the queue of requests */
r_if
c_cond
(paren
id|smb_lock_server_interruptible
c_func
(paren
id|server
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
multiline_comment|/*&n;&t; * Try to send the request as the process. If that fails we queue the&n;&t; * request and let smbiod send it later.&n;&t; */
multiline_comment|/* FIXME: each server has a number on the maximum number of parallel&n;&t;   requests. 10, 50 or so. We should not allow more requests to be&n;&t;   active. */
r_if
c_cond
(paren
id|server-&gt;mid
OG
l_int|0xf000
)paren
id|server-&gt;mid
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_mid
op_assign
id|server-&gt;mid
op_increment
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_mid
comma
id|req-&gt;rq_mid
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;state
op_eq
id|CONN_VALID
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|server-&gt;xmitq
)paren
)paren
id|result
op_assign
id|smb_request_send_req
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* Connection lost? */
id|server-&gt;conn_error
op_assign
id|result
suffix:semicolon
id|server-&gt;state
op_assign
id|CONN_INVALID
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_ne
l_int|1
)paren
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;rq_queue
comma
op_amp
id|server-&gt;xmitq
)paren
suffix:semicolon
id|smb_rget
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;state
op_ne
id|CONN_VALID
)paren
id|smbiod_retry
c_func
(paren
id|server
)paren
suffix:semicolon
id|smb_unlock_server
c_func
(paren
id|server
)paren
suffix:semicolon
id|smbiod_wake_up
c_func
(paren
)paren
suffix:semicolon
id|timeleft
op_assign
id|wait_event_interruptible_timeout
c_func
(paren
id|req-&gt;rq_wait
comma
id|req-&gt;rq_flags
op_amp
id|SMB_REQ_RECEIVED
comma
l_int|30
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeleft
op_logical_or
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * On timeout or on interrupt we want to try and remove the&n;&t;&t; * request from the recvq/xmitq.&n;&t;&t; */
id|smb_lock_server
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|req-&gt;rq_flags
op_amp
id|SMB_REQ_RECEIVED
)paren
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;rq_queue
)paren
suffix:semicolon
id|smb_rput
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
id|smb_unlock_server
c_func
(paren
id|server
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|timeleft
)paren
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;request [%p, mid=%d] timed out!&bslash;n&quot;
comma
id|req
comma
id|req-&gt;rq_mid
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_com:  %02x&bslash;n&quot;
comma
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_com
)paren
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_rcls: %02x&bslash;n&quot;
comma
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_rcls
)paren
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_flg:  %02x&bslash;n&quot;
comma
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_flg
)paren
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_tid:  %04x&bslash;n&quot;
comma
id|WVAL
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_tid
)paren
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_pid:  %04x&bslash;n&quot;
comma
id|WVAL
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_pid
)paren
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_uid:  %04x&bslash;n&quot;
comma
id|WVAL
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_uid
)paren
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_mid:  %04x&bslash;n&quot;
comma
id|WVAL
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_mid
)paren
)paren
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;smb_wct:  %02x&bslash;n&quot;
comma
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_wct
)paren
)paren
suffix:semicolon
id|req-&gt;rq_rcls
op_assign
id|ERRSRV
suffix:semicolon
id|req-&gt;rq_err
op_assign
id|ERRtimeout
suffix:semicolon
multiline_comment|/* Just in case it was &quot;stuck&quot; */
id|smbiod_wake_up
c_func
(paren
)paren
suffix:semicolon
)brace
id|VERBOSE
c_func
(paren
l_string|&quot;woke up, rcls=%d&bslash;n&quot;
comma
id|req-&gt;rq_rcls
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_rcls
op_ne
l_int|0
)paren
id|req-&gt;rq_errno
op_assign
id|smb_errno
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
id|req-&gt;rq_errno
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
id|req-&gt;rq_errno
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a request and place it on the recvq if successfully sent.&n; * Must be called with the server lock held.&n; */
DECL|function|smb_request_send_req
r_static
r_int
id|smb_request_send_req
c_func
(paren
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_struct
id|smb_sb_info
op_star
id|server
op_assign
id|req-&gt;rq_server
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_bytes_sent
op_eq
l_int|0
)paren
(brace
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_tid
comma
id|server-&gt;opt.tid
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_pid
comma
l_int|1
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_uid
comma
id|server-&gt;opt.server_uid
)paren
suffix:semicolon
)brace
id|result
op_assign
id|smb_send_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_and
id|result
op_ne
op_minus
id|EAGAIN
)paren
r_goto
id|out
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|req-&gt;rq_flags
op_amp
id|SMB_REQ_TRANSMITTED
)paren
)paren
r_goto
id|out
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;rq_queue
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|req-&gt;rq_queue
comma
op_amp
id|server-&gt;recvq
)paren
suffix:semicolon
id|result
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Sends one request for this server. (smbiod)&n; * Must be called with the server lock held.&n; * Returns: &lt;0 on error&n; *           0 if no request could be completely sent&n; *           1 if all data for one request was sent&n; */
DECL|function|smb_request_send_server
r_int
id|smb_request_send_server
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_struct
id|smb_request
op_star
id|req
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;state
op_ne
id|CONN_VALID
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* dequeue first request, if any */
id|req
op_assign
l_int|NULL
suffix:semicolon
id|head
op_assign
id|server-&gt;xmitq.next
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
op_amp
id|server-&gt;xmitq
)paren
(brace
id|req
op_assign
id|list_entry
c_func
(paren
id|head
comma
r_struct
id|smb_request
comma
id|rq_queue
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|0
suffix:semicolon
id|result
op_assign
id|smb_request_send_req
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|server-&gt;conn_error
op_assign
id|result
suffix:semicolon
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;rq_queue
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req-&gt;rq_queue
comma
op_amp
id|server-&gt;xmitq
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to find a request matching this &quot;mid&quot;. Typically the first entry will&n; * be the matching one.&n; */
DECL|function|find_request
r_static
r_struct
id|smb_request
op_star
id|find_request
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_int
id|mid
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|smb_request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|server-&gt;recvq
)paren
(brace
id|req
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|smb_request
comma
id|rq_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_mid
op_eq
id|mid
)paren
(brace
r_break
suffix:semicolon
)brace
id|req
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
id|VERBOSE
c_func
(paren
l_string|&quot;received reply with mid %d but no request!&bslash;n&quot;
comma
id|WVAL
c_func
(paren
id|server-&gt;header
comma
id|smb_mid
)paren
)paren
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_DROP
suffix:semicolon
)brace
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * Called when we have read the smb header and believe this is a response.&n; */
DECL|function|smb_init_request
r_static
r_int
id|smb_init_request
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_int
id|hdrlen
comma
id|wct
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;rq_header
comma
id|server-&gt;header
comma
id|SMB_HEADER_LEN
)paren
suffix:semicolon
id|wct
op_assign
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_wct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wct
OG
l_int|20
)paren
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;wct too large, %d &gt; 20&bslash;n&quot;
comma
id|wct
)paren
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_DROP
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|req-&gt;rq_resp_wct
op_assign
id|wct
suffix:semicolon
id|hdrlen
op_assign
id|SMB_HEADER_LEN
op_plus
id|wct
op_star
l_int|2
op_plus
l_int|2
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;header length: %d   smb_wct: %2d&bslash;n&quot;
comma
id|hdrlen
comma
id|wct
)paren
suffix:semicolon
id|req-&gt;rq_bytes_recvd
op_assign
id|SMB_HEADER_LEN
suffix:semicolon
id|req-&gt;rq_rlen
op_assign
id|hdrlen
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
id|req-&gt;rq_header
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|hdrlen
suffix:semicolon
id|req-&gt;rq_iovlen
op_assign
l_int|1
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_PARAM
suffix:semicolon
macro_line|#ifdef SMB_DEBUG_PACKET_SIZE
id|add_recv_stats
c_func
(paren
id|smb_len
c_func
(paren
id|server-&gt;header
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reads the SMB parameters&n; */
DECL|function|smb_recv_param
r_static
r_int
id|smb_recv_param
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|smb_receive
c_func
(paren
id|server
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_bytes_recvd
OL
id|req-&gt;rq_rlen
)paren
r_return
l_int|0
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;result: %d   smb_bcc:  %04x&bslash;n&quot;
comma
id|result
comma
id|WVAL
c_func
(paren
id|req-&gt;rq_header
comma
id|SMB_HEADER_LEN
op_plus
(paren
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_wct
)paren
op_star
l_int|2
)paren
)paren
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_iov
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;rq_rlen
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_callback
)paren
id|req
op_member_access_from_pointer
id|rq_callback
c_func
(paren
id|req
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|req-&gt;rq_setup_read
)paren
id|result
op_assign
id|req
op_member_access_from_pointer
id|rq_setup_read
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|server-&gt;rstate
op_assign
id|SMB_RECV_DROP
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|server-&gt;rstate
op_assign
id|req-&gt;rq_rlen
OG
l_int|0
ques
c_cond
id|SMB_RECV_DATA
suffix:colon
id|SMB_RECV_END
suffix:semicolon
id|req-&gt;rq_bytes_recvd
op_assign
l_int|0
suffix:semicolon
singleline_comment|// recvd out of the iov
id|VERBOSE
c_func
(paren
l_string|&quot;rlen: %d&bslash;n&quot;
comma
id|req-&gt;rq_rlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_rlen
OL
l_int|0
)paren
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;Parameters read beyond end of packet!&bslash;n&quot;
)paren
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_END
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Reads the SMB data&n; */
DECL|function|smb_recv_data
r_static
r_int
id|smb_recv_data
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|smb_receive
c_func
(paren
id|server
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_bytes_recvd
OL
id|req-&gt;rq_rlen
)paren
r_goto
id|out
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_END
suffix:semicolon
id|out
suffix:colon
id|VERBOSE
c_func
(paren
l_string|&quot;result: %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Receive a transaction2 response&n; * Return: 0 if the response has been fully read&n; *         1 if there are further &quot;fragments&quot; to read&n; *        &lt;0 if there is an error&n; */
DECL|function|smb_recv_trans2
r_static
r_int
id|smb_recv_trans2
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_struct
id|smb_request
op_star
id|req
)paren
(brace
r_int
r_char
op_star
id|inbuf
suffix:semicolon
r_int
r_int
id|parm_disp
comma
id|parm_offset
comma
id|parm_count
comma
id|parm_tot
suffix:semicolon
r_int
r_int
id|data_disp
comma
id|data_offset
comma
id|data_count
comma
id|data_tot
suffix:semicolon
r_int
id|hdrlen
op_assign
id|SMB_HEADER_LEN
op_plus
id|req-&gt;rq_resp_wct
op_star
l_int|2
op_minus
l_int|2
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;handling trans2&bslash;n&quot;
)paren
suffix:semicolon
id|inbuf
op_assign
id|req-&gt;rq_header
suffix:semicolon
id|data_tot
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_tdrcnt
)paren
suffix:semicolon
id|parm_tot
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_tprcnt
)paren
suffix:semicolon
id|parm_disp
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_prdisp
)paren
suffix:semicolon
id|parm_offset
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_proff
)paren
suffix:semicolon
id|parm_count
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_prcnt
)paren
suffix:semicolon
id|data_disp
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_drdisp
)paren
suffix:semicolon
id|data_offset
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_droff
)paren
suffix:semicolon
id|data_count
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_drcnt
)paren
suffix:semicolon
multiline_comment|/* Modify offset for the split header/buffer we use */
r_if
c_cond
(paren
id|data_count
op_logical_or
id|data_offset
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|data_offset
OL
id|hdrlen
)paren
)paren
r_goto
id|out_bad_data
suffix:semicolon
r_else
id|data_offset
op_sub_assign
id|hdrlen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parm_count
op_logical_or
id|parm_offset
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|parm_offset
OL
id|hdrlen
)paren
)paren
r_goto
id|out_bad_parm
suffix:semicolon
r_else
id|parm_offset
op_sub_assign
id|hdrlen
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parm_count
op_eq
id|parm_tot
op_logical_and
id|data_count
op_eq
id|data_tot
)paren
(brace
multiline_comment|/*&n;&t;&t; * This packet has all the trans2 data.&n;&t;&t; *&n;&t;&t; * We setup the request so that this will be the common&n;&t;&t; * case. It may be a server error to not return a&n;&t;&t; * response that fits.&n;&t;&t; */
id|VERBOSE
c_func
(paren
l_string|&quot;single trans2 response  &quot;
l_string|&quot;dcnt=%u, pcnt=%u, doff=%u, poff=%u&bslash;n&quot;
comma
id|data_count
comma
id|parm_count
comma
id|data_offset
comma
id|parm_offset
)paren
suffix:semicolon
id|req-&gt;rq_ldata
op_assign
id|data_count
suffix:semicolon
id|req-&gt;rq_lparm
op_assign
id|parm_count
suffix:semicolon
id|req-&gt;rq_data
op_assign
id|req-&gt;rq_buffer
op_plus
id|data_offset
suffix:semicolon
id|req-&gt;rq_parm
op_assign
id|req-&gt;rq_buffer
op_plus
id|parm_offset
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|parm_offset
op_plus
id|parm_count
OG
id|req-&gt;rq_rlen
)paren
)paren
r_goto
id|out_bad_parm
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|data_offset
op_plus
id|data_count
OG
id|req-&gt;rq_rlen
)paren
)paren
r_goto
id|out_bad_data
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|VERBOSE
c_func
(paren
l_string|&quot;multi trans2 response  &quot;
l_string|&quot;frag=%d, dcnt=%u, pcnt=%u, doff=%u, poff=%u&bslash;n&quot;
comma
id|req-&gt;rq_fragment
comma
id|data_count
comma
id|parm_count
comma
id|data_offset
comma
id|parm_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;rq_fragment
)paren
(brace
r_int
id|buf_len
suffix:semicolon
multiline_comment|/* We got the first trans2 fragment */
id|req-&gt;rq_fragment
op_assign
l_int|1
suffix:semicolon
id|req-&gt;rq_total_data
op_assign
id|data_tot
suffix:semicolon
id|req-&gt;rq_total_parm
op_assign
id|parm_tot
suffix:semicolon
id|req-&gt;rq_ldata
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rq_lparm
op_assign
l_int|0
suffix:semicolon
id|buf_len
op_assign
id|data_tot
op_plus
id|parm_tot
suffix:semicolon
r_if
c_cond
(paren
id|buf_len
OG
id|SMB_MAX_PACKET_SIZE
)paren
r_goto
id|out_too_long
suffix:semicolon
id|req-&gt;rq_trans2bufsize
op_assign
id|buf_len
suffix:semicolon
id|req-&gt;rq_trans2buffer
op_assign
id|smb_kmalloc
c_func
(paren
id|buf_len
comma
id|GFP_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;rq_trans2buffer
)paren
r_goto
id|out_no_mem
suffix:semicolon
id|memset
c_func
(paren
id|req-&gt;rq_trans2buffer
comma
l_int|0
comma
id|buf_len
)paren
suffix:semicolon
id|req-&gt;rq_parm
op_assign
id|req-&gt;rq_trans2buffer
suffix:semicolon
id|req-&gt;rq_data
op_assign
id|req-&gt;rq_trans2buffer
op_plus
id|parm_tot
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|req-&gt;rq_total_data
OL
id|data_tot
op_logical_or
id|req-&gt;rq_total_parm
OL
id|parm_tot
)paren
)paren
r_goto
id|out_data_grew
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|parm_disp
op_plus
id|parm_count
OG
id|req-&gt;rq_total_parm
op_logical_or
id|parm_offset
op_plus
id|parm_count
OG
id|req-&gt;rq_rlen
)paren
)paren
r_goto
id|out_bad_parm
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|data_disp
op_plus
id|data_count
OG
id|req-&gt;rq_total_data
op_logical_or
id|data_offset
op_plus
id|data_count
OG
id|req-&gt;rq_rlen
)paren
)paren
r_goto
id|out_bad_data
suffix:semicolon
id|inbuf
op_assign
id|req-&gt;rq_buffer
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;rq_parm
op_plus
id|parm_disp
comma
id|inbuf
op_plus
id|parm_offset
comma
id|parm_count
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|req-&gt;rq_data
op_plus
id|data_disp
comma
id|inbuf
op_plus
id|data_offset
comma
id|data_count
)paren
suffix:semicolon
id|req-&gt;rq_ldata
op_add_assign
id|data_count
suffix:semicolon
id|req-&gt;rq_lparm
op_add_assign
id|parm_count
suffix:semicolon
multiline_comment|/*&n;&t; * Check whether we&squot;ve received all of the data. Note that&n;&t; * we use the packet totals -- total lengths might shrink!&n;&t; */
r_if
c_cond
(paren
id|req-&gt;rq_ldata
op_ge
id|data_tot
op_logical_and
id|req-&gt;rq_lparm
op_ge
id|parm_tot
)paren
(brace
id|req-&gt;rq_ldata
op_assign
id|data_tot
suffix:semicolon
id|req-&gt;rq_lparm
op_assign
id|parm_tot
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
id|out_too_long
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_trans2: data/param too long, data=%u, parm=%u&bslash;n&quot;
comma
id|data_tot
comma
id|parm_tot
)paren
suffix:semicolon
r_goto
id|out_EIO
suffix:semicolon
id|out_no_mem
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_trans2: couldn&squot;t allocate data area of %d bytes&bslash;n&quot;
comma
id|req-&gt;rq_trans2bufsize
)paren
suffix:semicolon
id|req-&gt;rq_errno
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|out_data_grew
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_trans2: data/params grew!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_EIO
suffix:semicolon
id|out_bad_parm
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_trans2: invalid parms, disp=%u, cnt=%u, tot=%u, ofs=%u&bslash;n&quot;
comma
id|parm_disp
comma
id|parm_count
comma
id|parm_tot
comma
id|parm_offset
)paren
suffix:semicolon
r_goto
id|out_EIO
suffix:semicolon
id|out_bad_data
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_trans2: invalid data, disp=%u, cnt=%u, tot=%u, ofs=%u&bslash;n&quot;
comma
id|data_disp
comma
id|data_count
comma
id|data_tot
comma
id|data_offset
)paren
suffix:semicolon
id|out_EIO
suffix:colon
id|req-&gt;rq_errno
op_assign
op_minus
id|EIO
suffix:semicolon
id|out
suffix:colon
r_return
id|req-&gt;rq_errno
suffix:semicolon
)brace
multiline_comment|/*&n; * State machine for receiving responses. We handle the fact that we can&squot;t&n; * read the full response in one try by having states telling us how much we&n; * have read.&n; *&n; * Must be called with the server lock held (only called from smbiod).&n; *&n; * Return: &lt;0 on error&n; */
DECL|function|smb_request_recv
r_int
id|smb_request_recv
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_struct
id|smb_request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|smb_recv_available
c_func
(paren
id|server
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|VERBOSE
c_func
(paren
l_string|&quot;state: %d&bslash;n&quot;
comma
id|server-&gt;rstate
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|server-&gt;rstate
)paren
(brace
r_case
id|SMB_RECV_DROP
suffix:colon
id|result
op_assign
id|smb_receive_drop
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;rstate
op_eq
id|SMB_RECV_DROP
)paren
r_break
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_START
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
id|SMB_RECV_START
suffix:colon
id|server-&gt;smb_read
op_assign
l_int|0
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_HEADER
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
id|SMB_RECV_HEADER
suffix:colon
id|result
op_assign
id|smb_receive_header
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;rstate
op_eq
id|SMB_RECV_HEADER
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
(paren
id|server-&gt;header
op_plus
id|smb_flg
)paren
op_amp
id|SMB_FLAGS_REPLY
)paren
)paren
(brace
id|server-&gt;rstate
op_assign
id|SMB_RECV_REQUEST
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|server-&gt;rstate
op_ne
id|SMB_RECV_HCOMPLETE
)paren
r_break
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
id|SMB_RECV_HCOMPLETE
suffix:colon
id|req
op_assign
id|find_request
c_func
(paren
id|server
comma
id|WVAL
c_func
(paren
id|server-&gt;header
comma
id|smb_mid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_break
suffix:semicolon
id|smb_init_request
c_func
(paren
id|server
comma
id|req
)paren
suffix:semicolon
id|req-&gt;rq_rcls
op_assign
op_star
(paren
id|req-&gt;rq_header
op_plus
id|smb_rcls
)paren
suffix:semicolon
id|req-&gt;rq_err
op_assign
id|WVAL
c_func
(paren
id|req-&gt;rq_header
comma
id|smb_err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;rstate
op_ne
id|SMB_RECV_PARAM
)paren
r_break
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
id|SMB_RECV_PARAM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
id|req
op_assign
id|find_request
c_func
(paren
id|server
comma
id|WVAL
c_func
(paren
id|server-&gt;header
comma
id|smb_mid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_break
suffix:semicolon
id|result
op_assign
id|smb_recv_param
c_func
(paren
id|server
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;rstate
op_ne
id|SMB_RECV_DATA
)paren
r_break
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
id|SMB_RECV_DATA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
id|req
op_assign
id|find_request
c_func
(paren
id|server
comma
id|WVAL
c_func
(paren
id|server-&gt;header
comma
id|smb_mid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_break
suffix:semicolon
id|result
op_assign
id|smb_recv_data
c_func
(paren
id|server
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_break
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* We should never be called with any of these states */
r_case
id|SMB_RECV_END
suffix:colon
r_case
id|SMB_RECV_REQUEST
suffix:colon
id|server-&gt;rstate
op_assign
id|SMB_RECV_END
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* We saw an error */
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|server-&gt;rstate
op_ne
id|SMB_RECV_END
)paren
r_return
l_int|0
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_trans2_command
op_logical_and
id|req-&gt;rq_rcls
op_eq
id|SUCCESS
)paren
id|result
op_assign
id|smb_recv_trans2
c_func
(paren
id|server
comma
id|req
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Response completely read. Drop any extra bytes sent by the server.&n;&t; * (Yes, servers sometimes add extra bytes to responses)&n;&t; */
id|VERBOSE
c_func
(paren
l_string|&quot;smb_len: %d   smb_read: %d&bslash;n&quot;
comma
id|server-&gt;smb_len
comma
id|server-&gt;smb_read
)paren
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;smb_read
OL
id|server-&gt;smb_len
)paren
id|smb_receive_drop
c_func
(paren
id|server
)paren
suffix:semicolon
id|server-&gt;rstate
op_assign
id|SMB_RECV_START
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|list_del_init
c_func
(paren
op_amp
id|req-&gt;rq_queue
)paren
suffix:semicolon
id|req-&gt;rq_flags
op_or_assign
id|SMB_REQ_RECEIVED
suffix:semicolon
id|smb_rput
c_func
(paren
id|req
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|req-&gt;rq_wait
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
