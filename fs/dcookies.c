multiline_comment|/*&n; * dcookies.c&n; *&n; * Copyright 2002 John Levon &lt;levon@movementarian.org&gt;&n; *&n; * Persistent cookie-path mappings. These are used by&n; * profilers to convert a per-task EIP value into something&n; * non-transitory that can be processed at a later date.&n; * This is done by locking the dentry/vfsmnt pair in the&n; * kernel until released by the tasks needing the persistent&n; * objects. The tag is simply an unsigned long that refers&n; * to the pair and can be looked up from userspace.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/list.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/dcookies.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* The dcookies are allocated from a kmem_cache and&n; * hashed onto a small number of lists. None of the&n; * code here is particularly performance critical&n; */
DECL|struct|dcookie_struct
r_struct
id|dcookie_struct
(brace
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|vfsmnt
r_struct
id|vfsmount
op_star
id|vfsmnt
suffix:semicolon
DECL|member|hash_list
r_struct
id|list_head
id|hash_list
suffix:semicolon
)brace
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|dcookie_users
)paren
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|dcookie_sem
)paren
suffix:semicolon
DECL|variable|dcookie_cache
r_static
id|kmem_cache_t
op_star
id|dcookie_cache
suffix:semicolon
DECL|variable|dcookie_hashtable
r_static
r_struct
id|list_head
op_star
id|dcookie_hashtable
suffix:semicolon
DECL|variable|hash_size
r_static
r_int
id|hash_size
suffix:semicolon
DECL|function|is_live
r_static
r_inline
r_int
id|is_live
c_func
(paren
r_void
)paren
(brace
r_return
op_logical_neg
(paren
id|list_empty
c_func
(paren
op_amp
id|dcookie_users
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The dentry is locked, its address will do for the cookie */
DECL|function|dcookie_value
r_static
r_inline
r_int
r_int
id|dcookie_value
c_func
(paren
r_struct
id|dcookie_struct
op_star
id|dcs
)paren
(brace
r_return
(paren
r_int
r_int
)paren
id|dcs-&gt;dentry
suffix:semicolon
)brace
DECL|function|dcookie_hash
r_static
r_int
id|dcookie_hash
c_func
(paren
r_int
r_int
id|dcookie
)paren
(brace
r_return
(paren
id|dcookie
op_rshift
id|L1_CACHE_SHIFT
)paren
op_amp
(paren
id|hash_size
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|find_dcookie
r_static
r_struct
id|dcookie_struct
op_star
id|find_dcookie
c_func
(paren
r_int
r_int
id|dcookie
)paren
(brace
r_struct
id|dcookie_struct
op_star
id|found
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dcookie_struct
op_star
id|dcs
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
id|list
op_assign
id|dcookie_hashtable
op_plus
id|dcookie_hash
c_func
(paren
id|dcookie
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|pos
comma
id|list
)paren
(brace
id|dcs
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|dcookie_struct
comma
id|hash_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dcookie_value
c_func
(paren
id|dcs
)paren
op_eq
id|dcookie
)paren
(brace
id|found
op_assign
id|dcs
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|found
suffix:semicolon
)brace
DECL|function|hash_dcookie
r_static
r_void
id|hash_dcookie
c_func
(paren
r_struct
id|dcookie_struct
op_star
id|dcs
)paren
(brace
r_struct
id|list_head
op_star
id|list
op_assign
id|dcookie_hashtable
op_plus
id|dcookie_hash
c_func
(paren
id|dcookie_value
c_func
(paren
id|dcs
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dcs-&gt;hash_list
comma
id|list
)paren
suffix:semicolon
)brace
DECL|function|alloc_dcookie
r_static
r_struct
id|dcookie_struct
op_star
id|alloc_dcookie
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
id|vfsmnt
)paren
(brace
r_struct
id|dcookie_struct
op_star
id|dcs
op_assign
id|kmem_cache_alloc
c_func
(paren
id|dcookie_cache
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dcs
)paren
r_return
l_int|NULL
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|vfsmnt-&gt;mnt_count
)paren
suffix:semicolon
id|dentry-&gt;d_cookie
op_assign
id|dcs
suffix:semicolon
id|dcs-&gt;dentry
op_assign
id|dentry
suffix:semicolon
id|dcs-&gt;vfsmnt
op_assign
id|vfsmnt
suffix:semicolon
id|hash_dcookie
c_func
(paren
id|dcs
)paren
suffix:semicolon
r_return
id|dcs
suffix:semicolon
)brace
multiline_comment|/* This is the main kernel-side routine that retrieves the cookie&n; * value for a dentry/vfsmnt pair.&n; */
DECL|function|get_dcookie
r_int
id|get_dcookie
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
id|vfsmnt
comma
r_int
r_int
op_star
id|cookie
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|dcookie_struct
op_star
id|dcs
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_live
c_func
(paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|dcs
op_assign
id|dentry-&gt;d_cookie
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dcs
)paren
id|dcs
op_assign
id|alloc_dcookie
c_func
(paren
id|dentry
comma
id|vfsmnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dcs
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
op_star
id|cookie
op_assign
id|dcookie_value
c_func
(paren
id|dcs
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* And here is where the userspace process can look up the cookie value&n; * to retrieve the path.&n; */
DECL|function|sys_lookup_dcookie
id|asmlinkage
r_int
id|sys_lookup_dcookie
c_func
(paren
id|u64
id|cookie64
comma
r_char
id|__user
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|cookie
op_assign
(paren
r_int
r_int
)paren
id|cookie64
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_char
op_star
id|kbuf
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
r_int
id|pathlen
suffix:semicolon
r_struct
id|dcookie_struct
op_star
id|dcs
suffix:semicolon
multiline_comment|/* we could leak path information to users&n;&t; * without dir read permission without this&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_live
c_func
(paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dcs
op_assign
id|find_dcookie
c_func
(paren
id|cookie
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|kbuf
op_assign
id|kmalloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kbuf
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* FIXME: (deleted) ? */
id|path
op_assign
id|d_path
c_func
(paren
id|dcs-&gt;dentry
comma
id|dcs-&gt;vfsmnt
comma
id|kbuf
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|path
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|path
)paren
suffix:semicolon
r_goto
id|out_free
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ERANGE
suffix:semicolon
id|pathlen
op_assign
id|kbuf
op_plus
id|PAGE_SIZE
op_minus
id|path
suffix:semicolon
r_if
c_cond
(paren
id|pathlen
op_le
id|len
)paren
(brace
id|err
op_assign
id|pathlen
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|path
comma
id|pathlen
)paren
)paren
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
id|out_free
suffix:colon
id|kfree
c_func
(paren
id|kbuf
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|dcookie_init
r_static
r_int
id|dcookie_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|d
suffix:semicolon
r_int
r_int
id|i
comma
id|hash_bits
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|dcookie_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;dcookie_cache&quot;
comma
r_sizeof
(paren
r_struct
id|dcookie_struct
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dcookie_cache
)paren
r_goto
id|out
suffix:semicolon
id|dcookie_hashtable
op_assign
id|kmalloc
c_func
(paren
id|PAGE_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dcookie_hashtable
)paren
r_goto
id|out_kmem
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Find the power-of-two list-heads that can fit into the allocation..&n;&t; * We don&squot;t guarantee that &quot;sizeof(struct list_head)&quot; is necessarily&n;&t; * a power-of-two.&n;&t; */
id|hash_size
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|list_head
)paren
suffix:semicolon
id|hash_bits
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|hash_bits
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hash_size
op_rshift
id|hash_bits
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|hash_bits
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; * Re-calculate the actual number of entries and the mask&n;&t; * from the number of bits we can fit.&n;&t; */
id|hash_size
op_assign
l_int|1UL
op_lshift
id|hash_bits
suffix:semicolon
multiline_comment|/* And initialize the newly allocated array */
id|d
op_assign
id|dcookie_hashtable
suffix:semicolon
id|i
op_assign
id|hash_size
suffix:semicolon
r_do
(brace
id|INIT_LIST_HEAD
c_func
(paren
id|d
)paren
suffix:semicolon
id|d
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_kmem
suffix:colon
id|kmem_cache_destroy
c_func
(paren
id|dcookie_cache
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|free_dcookie
r_static
r_void
id|free_dcookie
c_func
(paren
r_struct
id|dcookie_struct
op_star
id|dcs
)paren
(brace
id|dcs-&gt;dentry-&gt;d_cookie
op_assign
l_int|NULL
suffix:semicolon
id|dput
c_func
(paren
id|dcs-&gt;dentry
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|dcs-&gt;vfsmnt
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|dcookie_cache
comma
id|dcs
)paren
suffix:semicolon
)brace
DECL|function|dcookie_exit
r_static
r_void
id|dcookie_exit
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_struct
id|list_head
op_star
id|pos
suffix:semicolon
r_struct
id|list_head
op_star
id|pos2
suffix:semicolon
r_struct
id|dcookie_struct
op_star
id|dcs
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hash_size
suffix:semicolon
op_increment
id|i
)paren
(brace
id|list
op_assign
id|dcookie_hashtable
op_plus
id|i
suffix:semicolon
id|list_for_each_safe
c_func
(paren
id|pos
comma
id|pos2
comma
id|list
)paren
(brace
id|dcs
op_assign
id|list_entry
c_func
(paren
id|pos
comma
r_struct
id|dcookie_struct
comma
id|hash_list
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dcs-&gt;hash_list
)paren
suffix:semicolon
id|free_dcookie
c_func
(paren
id|dcs
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|dcookie_hashtable
)paren
suffix:semicolon
id|kmem_cache_destroy
c_func
(paren
id|dcookie_cache
)paren
suffix:semicolon
)brace
DECL|struct|dcookie_user
r_struct
id|dcookie_user
(brace
DECL|member|next
r_struct
id|list_head
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|function|dcookie_register
r_struct
id|dcookie_user
op_star
id|dcookie_register
c_func
(paren
r_void
)paren
(brace
r_struct
id|dcookie_user
op_star
id|user
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
id|user
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dcookie_user
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_live
c_func
(paren
)paren
op_logical_and
id|dcookie_init
c_func
(paren
)paren
)paren
r_goto
id|out_free
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|user-&gt;next
comma
op_amp
id|dcookie_users
)paren
suffix:semicolon
id|out
suffix:colon
id|up
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
r_return
id|user
suffix:semicolon
id|out_free
suffix:colon
id|kfree
c_func
(paren
id|user
)paren
suffix:semicolon
id|user
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|dcookie_unregister
r_void
id|dcookie_unregister
c_func
(paren
r_struct
id|dcookie_user
op_star
id|user
)paren
(brace
id|down
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|user-&gt;next
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|user
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_live
c_func
(paren
)paren
)paren
id|dcookie_exit
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dcookie_sem
)paren
suffix:semicolon
)brace
DECL|variable|dcookie_register
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dcookie_register
)paren
suffix:semicolon
DECL|variable|dcookie_unregister
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|dcookie_unregister
)paren
suffix:semicolon
DECL|variable|get_dcookie
id|EXPORT_SYMBOL_GPL
c_func
(paren
id|get_dcookie
)paren
suffix:semicolon
eof
