multiline_comment|/*&n; * lcnalloc.c - Cluster (de)allocation code.  Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2004 Anton Altaparmakov&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#ifdef NTFS_RW
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &quot;lcnalloc.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;bitmap.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;volume.h&quot;
macro_line|#include &quot;attrib.h&quot;
macro_line|#include &quot;malloc.h&quot;
macro_line|#include &quot;aops.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * ntfs_cluster_free_from_rl_nolock - free clusters from runlist&n; * @vol:&t;mounted ntfs volume on which to free the clusters&n; * @rl:&t;&t;runlist describing the clusters to free&n; *&n; * Free all the clusters described by the runlist @rl on the volume @vol.  In&n; * the case of an error being returned, at least some of the clusters were not&n; * freed.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Locking: - The volume lcn bitmap must be locked for writing on entry and is&n; *&t;      left locked on return.&n; */
DECL|function|ntfs_cluster_free_from_rl_nolock
r_int
id|ntfs_cluster_free_from_rl_nolock
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
id|runlist_element
op_star
id|rl
)paren
(brace
r_struct
id|inode
op_star
id|lcnbmp_vi
op_assign
id|vol-&gt;lcnbmp_ino
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|rl-&gt;length
suffix:semicolon
id|rl
op_increment
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|rl-&gt;lcn
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|ntfs_bitmap_clear_run
c_func
(paren
id|lcnbmp_vi
comma
id|rl-&gt;lcn
comma
id|rl-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_logical_and
(paren
op_logical_neg
id|ret
op_logical_or
id|ret
op_eq
id|ENOMEM
)paren
op_logical_and
id|ret
op_ne
id|err
)paren
)paren
id|ret
op_assign
id|err
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_cluster_alloc - allocate clusters on an ntfs volume&n; * @vol:&t;mounted ntfs volume on which to allocate the clusters&n; * @start_vcn:&t;vcn to use for the first allocated cluster&n; * @count:&t;number of clusters to allocate&n; * @start_lcn:&t;starting lcn at which to allocate the clusters (or -1 if none)&n; * @zone:&t;zone from which to allocate the clusters&n; *&n; * Allocate @count clusters preferably starting at cluster @start_lcn or at the&n; * current allocator position if @start_lcn is -1, on the mounted ntfs volume&n; * @vol. @zone is either DATA_ZONE for allocation of normal clusters or&n; * MFT_ZONE for allocation of clusters for the master file table, i.e. the&n; * $MFT/$DATA attribute.&n; *&n; * @start_vcn specifies the vcn of the first allocated cluster.  This makes&n; * merging the resulting runlist with the old runlist easier.&n; *&n; * You need to check the return value with IS_ERR().  If this is false, the&n; * function was successful and the return value is a runlist describing the&n; * allocated cluster(s).  If IS_ERR() is true, the function failed and&n; * PTR_ERR() gives you the error code.&n; *&n; * Notes on the allocation algorithm&n; * =================================&n; *&n; * There are two data zones.  First is the area between the end of the mft zone&n; * and the end of the volume, and second is the area between the start of the&n; * volume and the start of the mft zone.  On unmodified/standard NTFS 1.x&n; * volumes, the second data zone does not exist due to the mft zone being&n; * expanded to cover the start of the volume in order to reserve space for the&n; * mft bitmap attribute.&n; *&n; * This is not the prettiest function but the complexity stems from the need of&n; * implementing the mft vs data zoned approach and from the fact that we have&n; * access to the lcn bitmap in portions of up to 8192 bytes at a time, so we&n; * need to cope with crossing over boundaries of two buffers.  Further, the&n; * fact that the allocator allows for caller supplied hints as to the location&n; * of where allocation should begin and the fact that the allocator keeps track&n; * of where in the data zones the next natural allocation should occur,&n; * contribute to the complexity of the function.  But it should all be&n; * worthwhile, because this allocator should: 1) be a full implementation of&n; * the MFT zone approach used by Windows NT, 2) cause reduction in&n; * fragmentation, and 3) be speedy in allocations (the code is not optimized&n; * for speed, but the algorithm is, so further speed improvements are probably&n; * possible).&n; *&n; * FIXME: We should be monitoring cluster allocation and increment the MFT zone&n; * size dynamically but this is something for the future.  We will just cause&n; * heavier fragmentation by not doing it and I am not even sure Windows would&n; * grow the MFT zone dynamically, so it might even be correct not to do this.&n; * The overhead in doing dynamic MFT zone expansion would be very large and&n; * unlikely worth the effort. (AIA)&n; *&n; * TODO: I have added in double the required zone position pointer wrap around&n; * logic which can be optimized to having only one of the two logic sets.&n; * However, having the double logic will work fine, but if we have only one of&n; * the sets and we get it wrong somewhere, then we get into trouble, so&n; * removing the duplicate logic requires _very_ careful consideration of _all_&n; * possible code paths.  So at least for now, I am leaving the double logic -&n; * better safe than sorry... (AIA)&n; *&n; * Locking: - The volume lcn bitmap must be unlocked on entry and is unlocked&n; *&t;      on return.&n; *&t;    - This function takes the volume lcn bitmap lock for writing and&n; *&t;      modifies the bitmap contents.&n; */
DECL|function|ntfs_cluster_alloc
id|runlist_element
op_star
id|ntfs_cluster_alloc
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_const
id|VCN
id|start_vcn
comma
r_const
id|s64
id|count
comma
r_const
id|LCN
id|start_lcn
comma
r_const
id|NTFS_CLUSTER_ALLOCATION_ZONES
id|zone
)paren
(brace
id|LCN
id|zone_start
comma
id|zone_end
comma
id|bmp_pos
comma
id|bmp_initial_pos
comma
id|last_read_pos
comma
id|lcn
suffix:semicolon
id|LCN
id|prev_lcn
op_assign
l_int|0
comma
id|prev_run_len
op_assign
l_int|0
comma
id|mft_zone_size
suffix:semicolon
id|s64
id|clusters
suffix:semicolon
r_struct
id|inode
op_star
id|lcnbmp_vi
suffix:semicolon
id|runlist_element
op_star
id|rl
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
id|u8
op_star
id|buf
comma
op_star
id|byte
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|rlpos
comma
id|rlsize
comma
id|buf_size
suffix:semicolon
id|u8
id|pass
comma
id|done_zones
comma
id|search_zone
comma
id|need_writeback
op_assign
l_int|0
comma
id|bit
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for start_vcn 0x%llx, count 0x%llx, start_lcn &quot;
l_string|&quot;0x%llx, zone %s_ZONE.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|start_vcn
comma
(paren
r_int
r_int
r_int
)paren
id|count
comma
(paren
r_int
r_int
r_int
)paren
id|start_lcn
comma
id|zone
op_eq
id|MFT_ZONE
ques
c_cond
l_string|&quot;MFT&quot;
suffix:colon
l_string|&quot;DATA&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|vol
)paren
suffix:semicolon
id|lcnbmp_vi
op_assign
id|vol-&gt;lcnbmp_ino
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|lcnbmp_vi
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|start_vcn
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|count
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|start_lcn
OL
op_minus
l_int|1
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|zone
OL
id|FIRST_ZONE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|zone
OG
id|LAST_ZONE
)paren
suffix:semicolon
multiline_comment|/* Return empty runlist if @count == 0 */
singleline_comment|// FIXME: Do we want to just return NULL instead? (AIA)
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|rl
(braket
l_int|0
)braket
dot
id|vcn
op_assign
id|start_vcn
suffix:semicolon
id|rl
(braket
l_int|0
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rl
(braket
l_int|0
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
r_return
id|rl
suffix:semicolon
)brace
multiline_comment|/* Take the lcnbmp lock for writing. */
id|down_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If no specific @start_lcn was requested, use the current data zone&n;&t; * position, otherwise use the requested @start_lcn but make sure it&n;&t; * lies outside the mft zone.  Also set done_zones to 0 (no zones done)&n;&t; * and pass depending on whether we are starting inside a zone (1) or&n;&t; * at the beginning of a zone (2).  If requesting from the MFT_ZONE,&n;&t; * we either start at the current position within the mft zone or at&n;&t; * the specified position.  If the latter is out of bounds then we start&n;&t; * at the beginning of the MFT_ZONE.&n;&t; */
id|done_zones
op_assign
l_int|0
suffix:semicolon
id|pass
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * zone_start and zone_end are the current search range.  search_zone&n;&t; * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of&n;&t; * volume) and 4 for data zone 2 (start of volume till start of mft&n;&t; * zone).&n;&t; */
id|zone_start
op_assign
id|start_lcn
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|zone
op_eq
id|DATA_ZONE
)paren
id|zone_start
op_assign
id|vol-&gt;data1_zone_pos
suffix:semicolon
r_else
id|zone_start
op_assign
id|vol-&gt;mft_zone_pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone_start
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Zone starts at beginning of volume which means a&n;&t;&t;&t; * single pass is sufficient.&n;&t;&t;&t; */
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|zone
op_eq
id|DATA_ZONE
op_logical_and
id|zone_start
op_ge
id|vol-&gt;mft_zone_start
op_logical_and
id|zone_start
OL
id|vol-&gt;mft_zone_end
)paren
(brace
id|zone_start
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Starting at beginning of data1_zone which means a single&n;&t;&t; * pass in this zone is sufficient.&n;&t;&t; */
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|zone
op_eq
id|MFT_ZONE
op_logical_and
(paren
id|zone_start
OL
id|vol-&gt;mft_zone_start
op_logical_or
id|zone_start
op_ge
id|vol-&gt;mft_zone_end
)paren
)paren
(brace
id|zone_start
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|zone_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Starting at beginning of volume which means a single pass&n;&t;&t; * is sufficient.&n;&t;&t; */
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zone
op_eq
id|MFT_ZONE
)paren
(brace
id|zone_end
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|search_zone
op_assign
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/* if (zone == DATA_ZONE) */
(brace
multiline_comment|/* Skip searching the mft zone. */
id|done_zones
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|zone_end
op_assign
id|vol-&gt;nr_clusters
suffix:semicolon
id|search_zone
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|zone_end
op_assign
id|vol-&gt;mft_zone_start
suffix:semicolon
id|search_zone
op_assign
l_int|4
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * bmp_pos is the current bit position inside the bitmap.  We use&n;&t; * bmp_initial_pos to determine whether or not to do a zone switch.&n;&t; */
id|bmp_pos
op_assign
id|bmp_initial_pos
op_assign
id|zone_start
suffix:semicolon
multiline_comment|/* Loop until all clusters are allocated, i.e. clusters == 0. */
id|clusters
op_assign
id|count
suffix:semicolon
id|rlpos
op_assign
id|rlsize
op_assign
l_int|0
suffix:semicolon
id|mapping
op_assign
id|lcnbmp_vi-&gt;i_mapping
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Start of outer while loop: done_zones 0x%x, &quot;
l_string|&quot;search_zone %i, pass %i, zone_start 0x%llx, &quot;
l_string|&quot;zone_end 0x%llx, bmp_initial_pos 0x%llx, &quot;
l_string|&quot;bmp_pos 0x%llx, rlpos %i, rlsize %i.&quot;
comma
id|done_zones
comma
id|search_zone
comma
id|pass
comma
(paren
r_int
r_int
r_int
)paren
id|zone_start
comma
(paren
r_int
r_int
r_int
)paren
id|zone_end
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_initial_pos
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
comma
id|rlpos
comma
id|rlsize
)paren
suffix:semicolon
multiline_comment|/* Loop until we run out of free clusters. */
id|last_read_pos
op_assign
id|bmp_pos
op_rshift
l_int|3
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;last_read_pos 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|last_read_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_read_pos
OG
id|lcnbmp_vi-&gt;i_size
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;End of attribute reached.  &quot;
l_string|&quot;Skipping to zone_pass_done.&quot;
)paren
suffix:semicolon
r_goto
id|zone_pass_done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|need_writeback
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Marking page dirty.&quot;
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|need_writeback
op_assign
l_int|0
suffix:semicolon
)brace
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|page
op_assign
id|ntfs_map_page
c_func
(paren
id|mapping
comma
id|last_read_pos
op_rshift
id|PAGE_CACHE_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map page.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|buf_size
op_assign
id|last_read_pos
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|buf
op_assign
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|buf_size
suffix:semicolon
id|buf_size
op_assign
id|PAGE_CACHE_SIZE
op_minus
id|buf_size
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|last_read_pos
op_plus
id|buf_size
OG
id|lcnbmp_vi-&gt;i_size
)paren
)paren
id|buf_size
op_assign
id|lcnbmp_vi-&gt;i_size
op_minus
id|last_read_pos
suffix:semicolon
id|buf_size
op_lshift_assign
l_int|3
suffix:semicolon
id|lcn
op_assign
id|bmp_pos
op_amp
l_int|7
suffix:semicolon
id|bmp_pos
op_and_assign
op_complement
l_int|7
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before inner while loop: buf_size %i, lcn 0x%llx, &quot;
l_string|&quot;bmp_pos 0x%llx, need_writeback %i.&quot;
comma
id|buf_size
comma
(paren
r_int
r_int
r_int
)paren
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
comma
id|need_writeback
)paren
suffix:semicolon
r_while
c_loop
(paren
id|lcn
OL
id|buf_size
op_logical_and
id|lcn
op_plus
id|bmp_pos
OL
id|zone_end
)paren
(brace
id|byte
op_assign
id|buf
op_plus
(paren
id|lcn
op_rshift
l_int|3
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;In inner while loop: buf_size %i, &quot;
l_string|&quot;lcn 0x%llx, bmp_pos 0x%llx, &quot;
l_string|&quot;need_writeback %i, byte ofs 0x%x, &quot;
l_string|&quot;*byte 0x%x.&quot;
comma
id|buf_size
comma
(paren
r_int
r_int
r_int
)paren
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
comma
id|need_writeback
comma
(paren
r_int
r_int
)paren
(paren
id|lcn
op_rshift
l_int|3
)paren
comma
(paren
r_int
r_int
)paren
op_star
id|byte
)paren
suffix:semicolon
multiline_comment|/* Skip full bytes. */
r_if
c_cond
(paren
op_star
id|byte
op_eq
l_int|0xff
)paren
(brace
id|lcn
op_assign
(paren
id|lcn
op_plus
l_int|8
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Continuing while loop 1.&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|bit
op_assign
l_int|1
op_lshift
(paren
id|lcn
op_amp
l_int|7
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;bit %i.&quot;
comma
id|bit
)paren
suffix:semicolon
multiline_comment|/* If the bit is already set, go onto the next one. */
r_if
c_cond
(paren
op_star
id|byte
op_amp
id|bit
)paren
(brace
id|lcn
op_increment
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Continuing while loop 2.&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Allocate more memory if needed, including space for&n;&t;&t;&t; * the terminator element.&n;&t;&t;&t; * ntfs_malloc_nofs() operates on whole pages only.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|rlpos
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
op_star
id|rl
)paren
OG
id|rlsize
)paren
(brace
id|runlist_element
op_star
id|rl2
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reallocating memory.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;First free bit is at LCN &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
(paren
id|lcn
op_plus
id|bmp_pos
)paren
)paren
suffix:semicolon
id|rl2
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_plus
(paren
r_int
)paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl2
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to &quot;
l_string|&quot;allocate memory.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rl2
comma
id|rl
comma
id|rlsize
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|rl
op_assign
id|rl2
suffix:semicolon
id|rlsize
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reallocated memory, rlsize 0x%x.&quot;
comma
id|rlsize
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate the bitmap bit. */
op_star
id|byte
op_or_assign
id|bit
suffix:semicolon
multiline_comment|/* We need to write this bitmap page to disk. */
id|need_writeback
op_assign
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;*byte 0x%x, need_writeback is set.&quot;
comma
(paren
r_int
r_int
)paren
op_star
id|byte
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Coalesce with previous run if adjacent LCNs.&n;&t;&t;&t; * Otherwise, append a new run.&n;&t;&t;&t; */
id|ntfs_debug
c_func
(paren
l_string|&quot;Adding run (lcn 0x%llx, len 0x%llx), &quot;
l_string|&quot;prev_lcn 0x%llx, lcn 0x%llx, &quot;
l_string|&quot;bmp_pos 0x%llx, prev_run_len 0x%llx, &quot;
l_string|&quot;rlpos %i.&quot;
comma
(paren
r_int
r_int
r_int
)paren
(paren
id|lcn
op_plus
id|bmp_pos
)paren
comma
l_int|1ULL
comma
(paren
r_int
r_int
r_int
)paren
id|prev_lcn
comma
(paren
r_int
r_int
r_int
)paren
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
comma
(paren
r_int
r_int
r_int
)paren
id|prev_run_len
comma
id|rlpos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev_lcn
op_eq
id|lcn
op_plus
id|bmp_pos
op_minus
id|prev_run_len
op_logical_and
id|rlpos
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Coalescing to run (lcn 0x%llx, &quot;
l_string|&quot;len 0x%llx).&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
)paren
suffix:semicolon
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
op_assign
op_increment
id|prev_run_len
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Run now (lcn 0x%llx, len 0x%llx), &quot;
l_string|&quot;prev_run_len 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
comma
(paren
r_int
r_int
r_int
)paren
id|prev_run_len
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rlpos
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Adding new run, (previous &quot;
l_string|&quot;run lcn 0x%llx, &quot;
l_string|&quot;len 0x%llx).&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
)paren
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|prev_run_len
suffix:semicolon
)brace
r_else
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Adding new run, is first &quot;
l_string|&quot;run.&quot;
)paren
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|start_vcn
suffix:semicolon
)brace
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|prev_lcn
op_assign
id|lcn
op_plus
id|bmp_pos
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
id|prev_run_len
op_assign
l_int|1
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
multiline_comment|/* Done? */
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|clusters
)paren
(brace
id|LCN
id|tc
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Update the current zone position.  Positions&n;&t;&t;&t;&t; * of already scanned zones have been updated&n;&t;&t;&t;&t; * during the respective zone switches.&n;&t;&t;&t;&t; */
id|tc
op_assign
id|lcn
op_plus
id|bmp_pos
op_plus
l_int|1
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done. Updating current zone &quot;
l_string|&quot;position, tc 0x%llx, &quot;
l_string|&quot;search_zone %i.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|tc
comma
id|search_zone
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|search_zone
)paren
(brace
r_case
l_int|1
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|vol-&gt;mft_zone_pos
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;mft_zone_pos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|bmp_initial_pos
op_ge
id|vol-&gt;mft_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;mft_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_lcn
)paren
id|vol-&gt;mft_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;nr_clusters
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|bmp_initial_pos
op_ge
id|vol-&gt;data1_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data1_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_start
)paren
id|vol-&gt;data2_zone_pos
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bmp_initial_pos
op_ge
id|vol-&gt;data2_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data2_zone_pos
)paren
id|vol-&gt;data2_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Finished.  Going to out.&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|lcn
op_increment
suffix:semicolon
)brace
id|bmp_pos
op_add_assign
id|buf_size
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After inner while loop: buf_size 0x%x, lcn &quot;
l_string|&quot;0x%llx, bmp_pos 0x%llx, need_writeback %i.&quot;
comma
id|buf_size
comma
(paren
r_int
r_int
r_int
)paren
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
comma
id|need_writeback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bmp_pos
OL
id|zone_end
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Continuing outer while loop, &quot;
l_string|&quot;bmp_pos 0x%llx, zone_end 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
comma
(paren
r_int
r_int
r_int
)paren
id|zone_end
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|zone_pass_done
suffix:colon
multiline_comment|/* Finished with the current zone pass. */
id|ntfs_debug
c_func
(paren
l_string|&quot;At zone_pass_done, pass %i.&quot;
comma
id|pass
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pass
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Now do pass 2, scanning the first part of the zone&n;&t;&t;&t; * we omitted in pass 1.&n;&t;&t;&t; */
id|pass
op_assign
l_int|2
suffix:semicolon
id|zone_end
op_assign
id|zone_start
suffix:semicolon
r_switch
c_cond
(paren
id|search_zone
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* mft_zone */
id|zone_start
op_assign
id|vol-&gt;mft_zone_start
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* data1_zone */
id|zone_start
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* data2_zone */
id|zone_start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Sanity check. */
r_if
c_cond
(paren
id|zone_end
OL
id|zone_start
)paren
id|zone_end
op_assign
id|zone_start
suffix:semicolon
id|bmp_pos
op_assign
id|zone_start
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Continuing outer while loop, pass 2, &quot;
l_string|&quot;zone_start 0x%llx, zone_end 0x%llx, &quot;
l_string|&quot;bmp_pos 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|zone_start
comma
(paren
r_int
r_int
r_int
)paren
id|zone_end
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_pos
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* pass == 2 */
id|done_zones_check
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;At done_zones_check, search_zone %i, done_zones &quot;
l_string|&quot;before 0x%x, done_zones after 0x%x.&quot;
comma
id|search_zone
comma
id|done_zones
comma
id|done_zones
op_or
id|search_zone
)paren
suffix:semicolon
id|done_zones
op_or_assign
id|search_zone
suffix:semicolon
r_if
c_cond
(paren
id|done_zones
OL
l_int|7
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Switching zone.&quot;
)paren
suffix:semicolon
multiline_comment|/* Now switch to the next zone we haven&squot;t done yet. */
id|pass
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|search_zone
)paren
(brace
r_case
l_int|1
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Switching from mft zone to data1 &quot;
l_string|&quot;zone.&quot;
)paren
suffix:semicolon
multiline_comment|/* Update mft zone position. */
r_if
c_cond
(paren
id|rlpos
)paren
(brace
id|LCN
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
id|tc
op_assign
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
op_plus
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|vol-&gt;mft_zone_pos
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;mft_zone_pos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|bmp_initial_pos
op_ge
id|vol-&gt;mft_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;mft_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_lcn
)paren
id|vol-&gt;mft_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After checks, &quot;
l_string|&quot;vol-&gt;mft_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_pos
)paren
suffix:semicolon
)brace
multiline_comment|/* Switch from mft zone to data1 zone. */
id|switch_to_data1_zone
suffix:colon
id|search_zone
op_assign
l_int|2
suffix:semicolon
id|zone_start
op_assign
id|bmp_initial_pos
op_assign
id|vol-&gt;data1_zone_pos
suffix:semicolon
id|zone_end
op_assign
id|vol-&gt;nr_clusters
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_eq
id|vol-&gt;mft_zone_end
)paren
id|pass
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_ge
id|zone_end
)paren
(brace
id|vol-&gt;data1_zone_pos
op_assign
id|zone_start
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Switching from data1 zone to &quot;
l_string|&quot;data2 zone.&quot;
)paren
suffix:semicolon
multiline_comment|/* Update data1 zone position. */
r_if
c_cond
(paren
id|rlpos
)paren
(brace
id|LCN
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
id|tc
op_assign
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
op_plus
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;nr_clusters
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|bmp_initial_pos
op_ge
id|vol-&gt;data1_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data1_zone_pos
)paren
op_logical_and
id|tc
op_ge
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;data1_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After checks, &quot;
l_string|&quot;vol-&gt;data1_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
)brace
multiline_comment|/* Switch from data1 zone to data2 zone. */
id|search_zone
op_assign
l_int|4
suffix:semicolon
id|zone_start
op_assign
id|bmp_initial_pos
op_assign
id|vol-&gt;data2_zone_pos
suffix:semicolon
id|zone_end
op_assign
id|vol-&gt;mft_zone_start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|zone_start
)paren
id|pass
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_ge
id|zone_end
)paren
(brace
id|vol-&gt;data2_zone_pos
op_assign
id|zone_start
op_assign
id|bmp_initial_pos
op_assign
l_int|0
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Switching from data2 zone to &quot;
l_string|&quot;data1 zone.&quot;
)paren
suffix:semicolon
multiline_comment|/* Update data2 zone position. */
r_if
c_cond
(paren
id|rlpos
)paren
(brace
id|LCN
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Before checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
id|tc
op_assign
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|lcn
op_plus
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_ge
id|vol-&gt;mft_zone_start
)paren
id|vol-&gt;data2_zone_pos
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bmp_initial_pos
op_ge
id|vol-&gt;data2_zone_pos
op_logical_or
id|tc
OG
id|vol-&gt;data2_zone_pos
)paren
id|vol-&gt;data2_zone_pos
op_assign
id|tc
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After checks, &quot;
l_string|&quot;vol-&gt;data2_zone_pos &quot;
l_string|&quot;0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data2_zone_pos
)paren
suffix:semicolon
)brace
multiline_comment|/* Switch from data2 zone to data1 zone. */
r_goto
id|switch_to_data1_zone
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;After zone switch, search_zone %i, &quot;
l_string|&quot;pass %i, bmp_initial_pos 0x%llx, &quot;
l_string|&quot;zone_start 0x%llx, zone_end 0x%llx.&quot;
comma
id|search_zone
comma
id|pass
comma
(paren
r_int
r_int
r_int
)paren
id|bmp_initial_pos
comma
(paren
r_int
r_int
r_int
)paren
id|zone_start
comma
(paren
r_int
r_int
r_int
)paren
id|zone_end
)paren
suffix:semicolon
id|bmp_pos
op_assign
id|zone_start
suffix:semicolon
r_if
c_cond
(paren
id|zone_start
op_eq
id|zone_end
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Empty zone, going to &quot;
l_string|&quot;done_zones_check.&quot;
)paren
suffix:semicolon
multiline_comment|/* Empty zone. Don&squot;t bother searching it. */
r_goto
id|done_zones_check
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Continuing outer while loop.&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* done_zones == 7 */
id|ntfs_debug
c_func
(paren
l_string|&quot;All zones are finished.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * All zones are finished!  If DATA_ZONE, shrink mft zone.  If&n;&t;&t; * MFT_ZONE, we have really run out of space.&n;&t;&t; */
id|mft_zone_size
op_assign
id|vol-&gt;mft_zone_end
op_minus
id|vol-&gt;mft_zone_start
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;vol-&gt;mft_zone_start 0x%llx, vol-&gt;mft_zone_end &quot;
l_string|&quot;0x%llx, mft_zone_size 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_start
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_end
comma
(paren
r_int
r_int
r_int
)paren
id|mft_zone_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zone
op_eq
id|MFT_ZONE
op_logical_or
id|mft_zone_size
op_le
l_int|0
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;No free clusters left, going to out.&quot;
)paren
suffix:semicolon
multiline_comment|/* Really no more space left on device. */
id|err
op_assign
id|ENOSPC
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* zone == DATA_ZONE &amp;&amp; mft_zone_size &gt; 0 */
id|ntfs_debug
c_func
(paren
l_string|&quot;Shrinking mft zone.&quot;
)paren
suffix:semicolon
id|zone_end
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|mft_zone_size
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mft_zone_size
OG
l_int|0
)paren
id|vol-&gt;mft_zone_end
op_assign
id|vol-&gt;mft_zone_start
op_plus
id|mft_zone_size
suffix:semicolon
r_else
multiline_comment|/* mft zone and data2 zone no longer exist. */
id|vol-&gt;data2_zone_pos
op_assign
id|vol-&gt;mft_zone_start
op_assign
id|vol-&gt;mft_zone_end
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vol-&gt;mft_zone_pos
op_ge
id|vol-&gt;mft_zone_end
)paren
(brace
id|vol-&gt;mft_zone_pos
op_assign
id|vol-&gt;mft_lcn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol-&gt;mft_zone_end
)paren
id|vol-&gt;mft_zone_pos
op_assign
l_int|0
suffix:semicolon
)brace
id|bmp_pos
op_assign
id|zone_start
op_assign
id|bmp_initial_pos
op_assign
id|vol-&gt;data1_zone_pos
op_assign
id|vol-&gt;mft_zone_end
suffix:semicolon
id|search_zone
op_assign
l_int|2
suffix:semicolon
id|pass
op_assign
l_int|2
suffix:semicolon
id|done_zones
op_and_assign
op_complement
l_int|2
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;After shrinking mft zone, mft_zone_size 0x%llx, &quot;
l_string|&quot;vol-&gt;mft_zone_start 0x%llx, &quot;
l_string|&quot;vol-&gt;mft_zone_end 0x%llx, &quot;
l_string|&quot;vol-&gt;mft_zone_pos 0x%llx, search_zone 2, &quot;
l_string|&quot;pass 2, dones_zones 0x%x, zone_start 0x%llx, &quot;
l_string|&quot;zone_end 0x%llx, vol-&gt;data1_zone_pos 0x%llx, &quot;
l_string|&quot;continuing outer while loop.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|mft_zone_size
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_start
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_end
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;mft_zone_pos
comma
id|done_zones
comma
(paren
r_int
r_int
r_int
)paren
id|zone_start
comma
(paren
r_int
r_int
r_int
)paren
id|zone_end
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;After outer while loop.&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;At out.&quot;
)paren
suffix:semicolon
multiline_comment|/* Add runlist terminator element. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
)paren
)paren
(brace
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|rl
(braket
id|rlpos
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|page
op_logical_and
op_logical_neg
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|need_writeback
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Marking page dirty.&quot;
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_page_dirty
c_func
(paren
id|page
)paren
suffix:semicolon
id|need_writeback
op_assign
l_int|0
suffix:semicolon
)brace
id|ntfs_unmap_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|rl
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to allocate clusters, aborting &quot;
l_string|&quot;(error %i).&quot;
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rl
)paren
(brace
r_int
id|err2
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|ENOSPC
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;Not enough space to complete allocation, &quot;
l_string|&quot;err ENOSPC, first free lcn 0x%llx, &quot;
l_string|&quot;could allocate up to 0x%llx &quot;
l_string|&quot;clusters.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|rl
(braket
l_int|0
)braket
dot
id|lcn
comma
(paren
r_int
r_int
r_int
)paren
id|count
op_minus
id|clusters
)paren
suffix:semicolon
multiline_comment|/* Deallocate all allocated clusters. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Attempting rollback...&quot;
)paren
suffix:semicolon
id|err2
op_assign
id|ntfs_cluster_free_from_rl_nolock
c_func
(paren
id|vol
comma
id|rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err2
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to rollback (error %i).  &quot;
l_string|&quot;Leaving inconsistent metadata!  &quot;
l_string|&quot;Unmount and run chkdsk.&quot;
comma
id|err2
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
multiline_comment|/* Free the runlist. */
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_eq
id|ENOSPC
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;No space left at all, err = ENOSPC, &quot;
l_string|&quot;first free lcn = 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vol-&gt;data1_zone_pos
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * __ntfs_cluster_free - free clusters on an ntfs volume&n; * @vi:&t;&t;vfs inode whose runlist describes the clusters to free&n; * @start_vcn:&t;vcn in the runlist of @vi at which to start freeing clusters&n; * @count:&t;number of clusters to free or -1 for all clusters&n; * @is_rollback:&t;if TRUE this is a rollback operation&n; *&n; * Free @count clusters starting at the cluster @start_vcn in the runlist&n; * described by the vfs inode @vi.&n; *&n; * If @count is -1, all clusters from @start_vcn to the end of the runlist are&n; * deallocated.  Thus, to completely free all clusters in a runlist, use&n; * @start_vcn = 0 and @count = -1.&n; *&n; * @is_rollback should always be FALSE, it is for internal use to rollback&n; * errors.  You probably want to use ntfs_cluster_free() instead.&n; *&n; * Note, ntfs_cluster_free() does not modify the runlist at all, so the caller&n; * has to deal with it later.&n; *&n; * Return the number of deallocated clusters (not counting sparse ones) on&n; * success and -errno on error.&n; *&n; * Locking: - The runlist described by @vi must be unlocked on entry and is&n; *&t;      unlocked on return.&n; *&t;    - This function takes the runlist lock of @vi for reading and&n; *&t;      sometimes for writing and sometimes modifies the runlist.&n; *&t;    - The volume lcn bitmap must be unlocked on entry and is unlocked&n; *&t;      on return.&n; *&t;    - This function takes the volume lcn bitmap lock for writing and&n; *&t;      modifies the bitmap contents.&n; */
DECL|function|__ntfs_cluster_free
id|s64
id|__ntfs_cluster_free
c_func
(paren
r_struct
id|inode
op_star
id|vi
comma
r_const
id|VCN
id|start_vcn
comma
id|s64
id|count
comma
r_const
id|BOOL
id|is_rollback
)paren
(brace
id|s64
id|delta
comma
id|to_free
comma
id|total_freed
comma
id|real_freed
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
r_struct
id|inode
op_star
id|lcnbmp_vi
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|vi
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx, start_vcn 0x%llx, count &quot;
l_string|&quot;0x%llx.%s&quot;
comma
id|vi-&gt;i_ino
comma
(paren
r_int
r_int
r_int
)paren
id|start_vcn
comma
(paren
r_int
r_int
r_int
)paren
id|count
comma
id|is_rollback
ques
c_cond
l_string|&quot; (rollback)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|lcnbmp_vi
op_assign
id|vol-&gt;lcnbmp_ino
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|lcnbmp_vi
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|start_vcn
OL
l_int|0
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|count
OL
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the lcn bitmap for writing but only if not rolling back.  We&n;&t; * must hold the lock all the way including through rollback otherwise&n;&t; * rollback is not possible because once we have cleared a bit and&n;&t; * dropped the lock, anyone could have set the bit again, thus&n;&t; * allocating the cluster for another use.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|is_rollback
)paren
)paren
id|down_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|total_freed
op_assign
id|real_freed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This returns with ni-&gt;runlist locked for reading on success. */
id|rl
op_assign
id|ntfs_find_vcn
c_func
(paren
id|ni
comma
id|start_vcn
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_rollback
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find first runlist &quot;
l_string|&quot;element (error %li), aborting.&quot;
comma
id|PTR_ERR
c_func
(paren
id|rl
)paren
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rl-&gt;lcn
OL
id|LCN_HOLE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_rollback
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;First runlist element has &quot;
l_string|&quot;invalid lcn, aborting.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unl_err_out
suffix:semicolon
)brace
multiline_comment|/* Find the starting cluster inside the run that needs freeing. */
id|delta
op_assign
id|start_vcn
op_minus
id|rl-&gt;vcn
suffix:semicolon
multiline_comment|/* The number of clusters in this run that need freeing. */
id|to_free
op_assign
id|rl-&gt;length
op_minus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|0
op_logical_and
id|to_free
OG
id|count
)paren
id|to_free
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl-&gt;lcn
op_ge
l_int|0
)paren
)paren
(brace
multiline_comment|/* Do the actual freeing of the clusters in this run. */
id|err
op_assign
id|ntfs_bitmap_set_bits_in_run
c_func
(paren
id|lcnbmp_vi
comma
id|rl-&gt;lcn
op_plus
id|delta
comma
id|to_free
comma
id|likely
c_func
(paren
op_logical_neg
id|is_rollback
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_rollback
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to clear first run &quot;
l_string|&quot;(error %i), aborting.&quot;
comma
id|err
)paren
suffix:semicolon
r_goto
id|unl_err_out
suffix:semicolon
)brace
multiline_comment|/* We have freed @to_free real clusters. */
id|real_freed
op_assign
id|to_free
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Go to the next run and adjust the number of clusters left to free. */
op_increment
id|rl
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|0
)paren
id|count
op_sub_assign
id|to_free
suffix:semicolon
multiline_comment|/* Keep track of the total &quot;freed&quot; clusters, including sparse ones. */
id|total_freed
op_assign
id|to_free
suffix:semicolon
multiline_comment|/*&n;&t; * Loop over the remaining runs, using @count as a capping value, and&n;&t; * free them.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|rl-&gt;length
op_logical_and
id|count
op_ne
l_int|0
suffix:semicolon
op_increment
id|rl
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rl-&gt;lcn
OL
id|LCN_HOLE
)paren
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Attempt to map runlist, dropping runlist lock for&n;&t;&t;&t; * the duration.&n;&t;&t;&t; */
id|vcn
op_assign
id|rl-&gt;vcn
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_map_runlist
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_rollback
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map &quot;
l_string|&quot;runlist fragment.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
op_logical_or
id|err
op_eq
op_minus
id|ENOENT
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This returns with ni-&gt;runlist locked for reading on&n;&t;&t;&t; * success.&n;&t;&t;&t; */
id|rl
op_assign
id|ntfs_find_vcn
c_func
(paren
id|ni
comma
id|vcn
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_rollback
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to find &quot;
l_string|&quot;subsequent runlist &quot;
l_string|&quot;element.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rl-&gt;lcn
OL
id|LCN_HOLE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_rollback
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Runlist element &quot;
l_string|&quot;has invalid lcn &quot;
l_string|&quot;(0x%llx).&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|rl-&gt;lcn
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|unl_err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* The number of clusters in this run that need freeing. */
id|to_free
op_assign
id|rl-&gt;length
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|0
op_logical_and
id|to_free
OG
id|count
)paren
id|to_free
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl-&gt;lcn
op_ge
l_int|0
)paren
)paren
(brace
multiline_comment|/* Do the actual freeing of the clusters in the run. */
id|err
op_assign
id|ntfs_bitmap_set_bits_in_run
c_func
(paren
id|lcnbmp_vi
comma
id|rl-&gt;lcn
comma
id|to_free
comma
id|likely
c_func
(paren
op_logical_neg
id|is_rollback
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_rollback
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to clear &quot;
l_string|&quot;subsequent run.&quot;
)paren
suffix:semicolon
r_goto
id|unl_err_out
suffix:semicolon
)brace
multiline_comment|/* We have freed @to_free real clusters. */
id|real_freed
op_add_assign
id|to_free
suffix:semicolon
)brace
multiline_comment|/* Adjust the number of clusters left to free. */
r_if
c_cond
(paren
id|count
op_ge
l_int|0
)paren
id|count
op_sub_assign
id|to_free
suffix:semicolon
multiline_comment|/* Update the total done clusters. */
id|total_freed
op_add_assign
id|to_free
suffix:semicolon
)brace
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|is_rollback
)paren
)paren
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* We are done.  Return the number of actually freed clusters. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|real_freed
suffix:semicolon
id|unl_err_out
suffix:colon
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|is_rollback
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* If no real clusters were freed, no need to rollback. */
r_if
c_cond
(paren
op_logical_neg
id|real_freed
)paren
(brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attempt to rollback and if that succeeds just return the error code.&n;&t; * If rollback fails, set the volume errors flag, emit an error&n;&t; * message, and return the error code.&n;&t; */
id|delta
op_assign
id|__ntfs_cluster_free
c_func
(paren
id|vi
comma
id|start_vcn
comma
id|total_freed
comma
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to rollback (error %i).  Leaving &quot;
l_string|&quot;inconsistent metadata!  Unmount and run &quot;
l_string|&quot;chkdsk.&quot;
comma
(paren
r_int
)paren
id|delta
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|vol-&gt;lcnbmp_lock
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Aborting (error %i).&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
eof
