multiline_comment|/*&n; * mft.h - Defines for mft record handling in NTFS Linux kernel driver.&n; *&t;   Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#ifndef _LINUX_NTFS_MFT_H
DECL|macro|_LINUX_NTFS_MFT_H
mdefine_line|#define _LINUX_NTFS_MFT_H
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &quot;inode.h&quot;
r_extern
r_int
id|format_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
)paren
suffix:semicolon
r_extern
id|MFT_RECORD
op_star
id|map_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
suffix:semicolon
r_extern
r_void
id|unmap_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
suffix:semicolon
r_extern
id|MFT_RECORD
op_star
id|map_extent_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|base_ni
comma
id|MFT_REF
id|mref
comma
id|ntfs_inode
op_star
op_star
id|ntfs_ino
)paren
suffix:semicolon
DECL|function|unmap_extent_mft_record
r_static
r_inline
r_void
id|unmap_extent_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|unmap_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * flush_dcache_mft_record_page - flush_dcache_page() for mft records&n; * @ni:&t;&t;ntfs inode structure of mft record&n; *&n; * Call flush_dcache_page() for the page in which an mft record resides.&n; *&n; * This must be called every time an mft record is modified, just after the&n; * modification.&n; */
DECL|function|flush_dcache_mft_record_page
r_static
r_inline
r_void
id|flush_dcache_mft_record_page
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
id|flush_dcache_page
c_func
(paren
id|ni-&gt;page
)paren
suffix:semicolon
)brace
r_extern
r_void
id|__mark_mft_record_dirty
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
suffix:semicolon
multiline_comment|/**&n; * mark_mft_record_dirty - set the mft record and the page containing it dirty&n; * @ni:&t;&t;ntfs inode describing the mapped mft record&n; *&n; * Set the mapped (extent) mft record of the (base or extent) ntfs inode @ni,&n; * as well as the page containing the mft record, dirty.  Also, mark the base&n; * vfs inode dirty.  This ensures that any changes to the mft record are&n; * written out to disk.&n; *&n; * NOTE:  Do not do anything if the mft record is already marked dirty.&n; */
DECL|function|mark_mft_record_dirty
r_static
r_inline
r_void
id|mark_mft_record_dirty
c_func
(paren
id|ntfs_inode
op_star
id|ni
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|NInoTestSetDirty
c_func
(paren
id|ni
)paren
)paren
id|__mark_mft_record_dirty
c_func
(paren
id|ni
)paren
suffix:semicolon
)brace
r_extern
r_int
id|write_mft_record_nolock
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
suffix:semicolon
multiline_comment|/**&n; * write_mft_record - write out a mapped (extent) mft record&n; * @ni:&t;&t;ntfs inode describing the mapped (extent) mft record&n; * @m:&t;&t;mapped (extent) mft record to write&n; * @sync:&t;if true, wait for i/o completion&n; *&n; * This is just a wrapper for write_mft_record_nolock() (see mft.c), which&n; * locks the page for the duration of the write.  This ensures that there are&n; * no race conditions between writing the mft record via the dirty inode code&n; * paths and via the page cache write back code paths or between writing&n; * neighbouring mft records residing in the same page.&n; *&n; * Locking the page also serializes us against -&gt;readpage() if the page is not&n; * uptodate.&n; *&n; * On success, clean the mft record and return 0.  On error, leave the mft&n; * record dirty and return -errno.  The caller should call make_bad_inode() on&n; * the base inode to ensure no more access happens to this inode.  We do not do&n; * it here as the caller may want to finish writing other extent mft records&n; * first to minimize on-disk metadata inconsistencies.&n; */
DECL|function|write_mft_record
r_static
r_inline
r_int
id|write_mft_record
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|m
comma
r_int
id|sync
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|ni-&gt;page
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|page
)paren
suffix:semicolon
id|lock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
id|write_mft_record_nolock
c_func
(paren
id|ni
comma
id|m
comma
id|sync
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* NTFS_RW */
macro_line|#endif /* _LINUX_NTFS_MFT_H */
eof
