multiline_comment|/*  attr.c&n; *&n; *  Copyright (C) 1996-1999 Martin von L&#xfffd;wis&n; *  Copyright (C) 1996-1997 R&#xfffd;gis Duchesne&n; *  Copyright (C) 1998 Joseph Malicki&n; *  Copyright (C) 1999 Steve Dodd&n; *  Copyright (C) 2001 Anton Altaparmakov (AIA)&n; */
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;inode.h&quot;
multiline_comment|/* Look if an attribute already exists in the inode, and if not, create it. */
DECL|function|ntfs_new_attr
r_int
id|ntfs_new_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_void
op_star
id|name
comma
r_int
id|namelen
comma
r_int
op_star
id|pos
comma
r_int
op_star
id|found
comma
r_int
id|do_search
)paren
(brace
r_int
id|do_insert
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
id|min
c_func
(paren
id|namelen
comma
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|namelen
)paren
suffix:semicolon
r_int
id|s
op_assign
id|ntfs_uni_strncmp
c_func
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
comma
id|name
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_search
)paren
(brace
multiline_comment|/* We assume that each attribute can be uniquely &n;&t;&t;&t; * identified by inode number, attribute type and&n;&t;&t;&t; * attribute name. */
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_eq
id|type
op_logical_and
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|namelen
op_eq
id|namelen
op_logical_and
op_logical_neg
id|s
)paren
(brace
op_star
id|found
op_assign
l_int|1
suffix:semicolon
op_star
id|pos
op_assign
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Attributes are ordered by type, then by name. */
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
OG
id|type
op_logical_or
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_eq
id|type
op_logical_and
id|s
op_eq
l_int|1
)paren
)paren
(brace
id|do_insert
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Re-allocate space. */
r_if
c_cond
(paren
id|ino-&gt;attr_count
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
id|ntfs_attribute
op_star
r_new
suffix:semicolon
r_new
op_assign
(paren
id|ntfs_attribute
op_star
)paren
id|ntfs_malloc
c_func
(paren
(paren
id|ino-&gt;attr_count
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
id|ntfs_attribute
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;attrs
)paren
(brace
id|ntfs_memcpy
c_func
(paren
r_new
comma
id|ino-&gt;attrs
comma
id|ino-&gt;attr_count
op_star
r_sizeof
(paren
id|ntfs_attribute
)paren
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
)paren
suffix:semicolon
)brace
id|ino-&gt;attrs
op_assign
r_new
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_insert
)paren
id|ntfs_memmove
c_func
(paren
id|ino-&gt;attrs
op_plus
id|i
op_plus
l_int|1
comma
id|ino-&gt;attrs
op_plus
id|i
comma
(paren
id|ino-&gt;attr_count
op_minus
id|i
)paren
op_star
r_sizeof
(paren
id|ntfs_attribute
)paren
)paren
suffix:semicolon
id|ino-&gt;attr_count
op_increment
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|namelen
op_assign
id|namelen
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
op_assign
id|name
suffix:semicolon
op_star
id|pos
op_assign
id|i
suffix:semicolon
op_star
id|found
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_make_attr_resident
r_int
id|ntfs_make_attr_resident
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
)paren
(brace
r_int
id|size
op_assign
id|attr-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
multiline_comment|/* FIXME: read data, free clusters */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|attr-&gt;resident
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Store in the inode readable information about a run. */
DECL|function|ntfs_insert_run
r_void
id|ntfs_insert_run
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_int
id|cnum
comma
id|ntfs_cluster_t
id|cluster
comma
r_int
id|len
)paren
(brace
multiline_comment|/* (re-)allocate space if necessary. */
r_if
c_cond
(paren
id|attr-&gt;d.r.len
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
id|ntfs_runlist
op_star
r_new
suffix:semicolon
r_new
op_assign
id|ntfs_malloc
c_func
(paren
(paren
id|attr-&gt;d.r.len
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;d.r.runlist
)paren
(brace
id|ntfs_memcpy
c_func
(paren
r_new
comma
id|attr-&gt;d.r.runlist
comma
id|attr-&gt;d.r.len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|attr-&gt;d.r.runlist
)paren
suffix:semicolon
)brace
id|attr-&gt;d.r.runlist
op_assign
r_new
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;d.r.len
OG
id|cnum
)paren
id|ntfs_memmove
c_func
(paren
id|attr-&gt;d.r.runlist
op_plus
id|cnum
op_plus
l_int|1
comma
id|attr-&gt;d.r.runlist
op_plus
id|cnum
comma
(paren
id|attr-&gt;d.r.len
op_minus
id|cnum
)paren
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
id|attr-&gt;d.r.runlist
(braket
id|cnum
)braket
dot
id|cluster
op_assign
id|cluster
suffix:semicolon
id|attr-&gt;d.r.runlist
(braket
id|cnum
)braket
dot
id|len
op_assign
id|len
suffix:semicolon
id|attr-&gt;d.r.len
op_increment
suffix:semicolon
)brace
multiline_comment|/* Extends an attribute. Another run will be added if necessary, but we try to&n; * extend the last run in the runlist first.&n; * FIXME: what if there isn&squot;t enough contiguous space, we don&squot;t create&n; * multiple runs?&n; *&n; * *len: the desired new length of the attr (_not_ the amount to extend by)&n; */
DECL|function|ntfs_extend_attr
r_int
id|ntfs_extend_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
r_int
op_star
id|len
comma
r_int
id|flags
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
suffix:semicolon
r_int
id|rlen
suffix:semicolon
id|ntfs_cluster_t
id|cluster
suffix:semicolon
r_int
id|clen
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;compressed
op_logical_or
id|ino-&gt;record_count
OG
l_int|1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
id|error
op_assign
id|ntfs_make_attr_nonresident
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|len
op_le
id|attr-&gt;allocated
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Truely stupid things do sometimes happen. */
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
id|rlen
op_assign
id|attr-&gt;d.r.len
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rlen
op_ge
l_int|0
)paren
id|cluster
op_assign
id|rl
(braket
id|rlen
)braket
dot
id|cluster
op_plus
id|rl
(braket
id|rlen
)braket
dot
id|len
suffix:semicolon
r_else
multiline_comment|/* No preference for allocation space. */
id|cluster
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate the extra space we need, and round up to multiple of&n;&t; * cluster size to get number of new clusters needed */
id|clen
op_assign
(paren
(paren
op_star
id|len
op_minus
id|attr-&gt;allocated
)paren
op_plus
id|ino-&gt;vol-&gt;clustersize
op_minus
l_int|1
)paren
op_div
id|ino-&gt;vol-&gt;clustersize
suffix:semicolon
r_if
c_cond
(paren
id|clen
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: try to allocate smaller pieces */
id|error
op_assign
id|ntfs_allocate_clusters
c_func
(paren
id|ino-&gt;vol
comma
op_amp
id|cluster
comma
op_amp
id|clen
comma
id|flags
op_or
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|attr-&gt;allocated
op_add_assign
id|clen
op_star
id|ino-&gt;vol-&gt;clustersize
suffix:semicolon
op_star
id|len
op_assign
id|attr-&gt;allocated
suffix:semicolon
multiline_comment|/* Contiguous chunk. */
r_if
c_cond
(paren
id|rlen
op_ge
l_int|0
op_logical_and
id|cluster
op_eq
id|rl
(braket
id|rlen
)braket
dot
id|cluster
op_plus
id|rl
(braket
id|rlen
)braket
dot
id|len
)paren
(brace
id|rl
(braket
id|rlen
)braket
dot
id|len
op_add_assign
id|clen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ntfs_insert_run
c_func
(paren
id|attr
comma
id|rlen
op_plus
l_int|1
comma
id|cluster
comma
id|clen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_make_attr_nonresident
r_int
id|ntfs_make_attr_nonresident
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
)paren
(brace
r_void
op_star
id|data
op_assign
id|attr-&gt;d.data
suffix:semicolon
r_int
id|len
op_assign
id|attr-&gt;size
suffix:semicolon
r_int
id|error
comma
id|alen
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|attr-&gt;d.r.len
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;d.r.runlist
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;resident
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;allocated
op_assign
id|attr-&gt;initialized
op_assign
l_int|0
suffix:semicolon
id|alen
op_assign
id|len
suffix:semicolon
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|ino
comma
id|attr
comma
op_amp
id|alen
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: On error, restore old values. */
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|data
suffix:semicolon
id|io.size
op_assign
id|len
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
)brace
DECL|function|ntfs_attr_allnonresident
r_int
id|ntfs_attr_allnonresident
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|i
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|error
op_logical_and
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_ne
id|vol-&gt;at_security_descriptor
op_logical_and
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_ne
id|vol-&gt;at_data
)paren
r_continue
suffix:semicolon
id|error
op_assign
id|ntfs_make_attr_nonresident
c_func
(paren
id|ino
comma
id|ino-&gt;attrs
op_plus
id|i
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Resize the attribute to a newsize. */
DECL|function|ntfs_resize_attr
r_int
id|ntfs_resize_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
r_int
id|newsize
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|oldsize
op_assign
id|attr-&gt;size
suffix:semicolon
r_int
id|clustersize
op_assign
id|ino-&gt;vol-&gt;clustersize
suffix:semicolon
r_int
id|i
comma
id|count
comma
id|newlen
comma
id|newcount
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
suffix:semicolon
r_if
c_cond
(paren
id|newsize
op_eq
id|oldsize
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: Modifying compressed attributes not supported yet. */
r_if
c_cond
(paren
id|attr-&gt;compressed
)paren
multiline_comment|/* FIXME: Extending is easy: just insert sparse runs. */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
r_void
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|newsize
OG
id|ino-&gt;vol-&gt;mft_recordsize
)paren
(brace
id|error
op_assign
id|ntfs_make_attr_nonresident
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|ntfs_resize_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|newsize
)paren
suffix:semicolon
)brace
id|v
op_assign
id|attr-&gt;d.data
suffix:semicolon
r_if
c_cond
(paren
id|newsize
)paren
(brace
id|attr-&gt;d.data
op_assign
id|ntfs_malloc
c_func
(paren
id|newsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;d.data
)paren
(brace
id|ntfs_free
c_func
(paren
id|v
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsize
OG
id|oldsize
)paren
id|ntfs_bzero
c_func
(paren
(paren
r_char
op_star
)paren
id|attr-&gt;d.data
op_plus
id|oldsize
comma
id|newsize
op_minus
id|oldsize
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|attr-&gt;d.data
comma
id|v
comma
id|min
c_func
(paren
id|newsize
comma
id|oldsize
)paren
)paren
suffix:semicolon
)brace
r_else
id|attr-&gt;d.data
op_assign
l_int|0
suffix:semicolon
id|ntfs_free
c_func
(paren
id|v
)paren
suffix:semicolon
id|attr-&gt;size
op_assign
id|newsize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Non-resident attribute. */
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
r_if
c_cond
(paren
id|newsize
OL
id|oldsize
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|count
op_plus
id|rl
(braket
id|i
)braket
dot
id|len
)paren
op_star
id|clustersize
OG
id|newsize
)paren
r_break
suffix:semicolon
id|count
op_add_assign
(paren
r_int
)paren
id|rl
(braket
id|i
)braket
dot
id|len
suffix:semicolon
)brace
id|newlen
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Free unused clusters in current run, unless sparse. */
id|newcount
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
op_ne
id|MAX_CLUSTER_T
)paren
(brace
r_int
id|rounded
op_assign
id|newsize
op_minus
id|count
op_star
id|clustersize
suffix:semicolon
id|rounded
op_assign
(paren
id|rounded
op_plus
id|clustersize
op_minus
l_int|1
)paren
op_div
id|clustersize
suffix:semicolon
id|error
op_assign
id|ntfs_deallocate_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|rl
(braket
id|i
)braket
dot
id|cluster
op_plus
id|rounded
comma
(paren
r_int
)paren
id|rl
(braket
id|i
)braket
dot
id|len
op_minus
id|rounded
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: Incomplete operation. */
id|rl
(braket
id|i
)braket
dot
id|len
op_assign
id|rounded
suffix:semicolon
id|newcount
op_assign
id|count
op_plus
id|rounded
suffix:semicolon
)brace
multiline_comment|/* Free all other runs. */
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
op_ne
id|MAX_CLUSTER_T
)paren
(brace
id|error
op_assign
id|ntfs_deallocate_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|rl
(braket
id|i
)braket
dot
id|cluster
comma
(paren
r_int
)paren
id|rl
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: Incomplete &n;&t;&t;&t;&t;&t;&t;       * operation */
)brace
multiline_comment|/* FIXME: Free space for extra runs in memory? */
id|attr-&gt;d.r.len
op_assign
id|newlen
suffix:semicolon
)brace
r_else
(brace
id|newlen
op_assign
id|newsize
suffix:semicolon
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|ino
comma
id|attr
comma
op_amp
id|newlen
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: Incomplete operation. */
id|newcount
op_assign
id|newlen
op_div
id|clustersize
suffix:semicolon
)brace
multiline_comment|/* Fill in new sizes. */
id|attr-&gt;allocated
op_assign
id|newcount
op_star
id|clustersize
suffix:semicolon
id|attr-&gt;size
op_assign
id|newsize
suffix:semicolon
multiline_comment|/* attr-&gt;initialized does not change. */
r_if
c_cond
(paren
op_logical_neg
id|newsize
)paren
id|error
op_assign
id|ntfs_make_attr_resident
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ntfs_create_attr
r_int
id|ntfs_create_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|anum
comma
r_char
op_star
id|aname
comma
r_void
op_star
id|data
comma
r_int
id|dsize
comma
id|ntfs_attribute
op_star
op_star
id|rattr
)paren
(brace
r_void
op_star
id|name
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_int
id|found
comma
id|i
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
r_if
c_cond
(paren
id|dsize
OG
id|ino-&gt;vol-&gt;mft_recordsize
)paren
multiline_comment|/* FIXME: Non-resident attributes. */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|aname
)paren
(brace
id|namelen
op_assign
id|strlen
c_func
(paren
id|aname
)paren
suffix:semicolon
id|name
op_assign
id|ntfs_malloc
c_func
(paren
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_ascii2uni
c_func
(paren
id|name
comma
id|aname
comma
id|namelen
)paren
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
l_int|0
suffix:semicolon
id|namelen
op_assign
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_new_attr
c_func
(paren
id|ino
comma
id|anum
comma
id|name
comma
id|namelen
comma
op_amp
id|i
comma
op_amp
id|found
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|ntfs_free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
op_star
id|rattr
op_assign
id|attr
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
multiline_comment|/* Allocate a new number.&n;&t; * FIXME: Should this happen on inode writeback?&n;&t; * FIXME: Extension records not supported. */
id|error
op_assign
id|ntfs_allocate_attr_number
c_func
(paren
id|ino
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|attr-&gt;attrno
op_assign
id|i
suffix:semicolon
id|attr-&gt;resident
op_assign
l_int|1
suffix:semicolon
id|attr-&gt;compressed
op_assign
id|attr-&gt;cengine
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;size
op_assign
id|attr-&gt;allocated
op_assign
id|attr-&gt;initialized
op_assign
id|dsize
suffix:semicolon
multiline_comment|/* FIXME: INDEXED information should come from $AttrDef&n;&t; * Currently, only file names are indexed. As of NTFS v3.0 (Win2k),&n;&t; * this is no longer true. Different attributes can be indexed now. */
r_if
c_cond
(paren
id|anum
op_eq
id|ino-&gt;vol-&gt;at_file_name
)paren
(brace
id|attr-&gt;indexed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|attr-&gt;indexed
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;d.data
op_assign
id|ntfs_malloc
c_func
(paren
id|dsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;d.data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|attr-&gt;d.data
comma
id|data
comma
id|dsize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Non-resident attributes are stored in runs (intervals of clusters).&n; *&n; * This function stores in the inode readable information about a non-resident&n; * attribute. */
DECL|function|ntfs_process_runs
r_static
r_int
id|ntfs_process_runs
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|startvcn
comma
id|endvcn
suffix:semicolon
r_int
id|vcn
comma
id|cnum
suffix:semicolon
id|ntfs_cluster_t
id|cluster
suffix:semicolon
r_int
id|len
comma
id|ctype
suffix:semicolon
id|startvcn
op_assign
id|NTFS_GETU64
c_func
(paren
id|data
op_plus
l_int|0x10
)paren
suffix:semicolon
id|endvcn
op_assign
id|NTFS_GETU64
c_func
(paren
id|data
op_plus
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* Check whether this chunk really belongs to the end. */
r_for
c_loop
(paren
id|cnum
op_assign
l_int|0
comma
id|vcn
op_assign
l_int|0
suffix:semicolon
id|cnum
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|cnum
op_increment
)paren
id|vcn
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|cnum
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|vcn
op_ne
id|startvcn
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Problem with runlist in extended record&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|endvcn
)paren
(brace
id|endvcn
op_assign
id|NTFS_GETU64
c_func
(paren
id|data
op_plus
l_int|0x28
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Allocated length. */
id|endvcn
op_div_assign
id|ino-&gt;vol-&gt;clustersize
suffix:semicolon
)brace
id|data
op_assign
id|data
op_plus
id|NTFS_GETU16
c_func
(paren
id|data
op_plus
l_int|0x20
)paren
suffix:semicolon
id|cnum
op_assign
id|attr-&gt;d.r.len
suffix:semicolon
id|cluster
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|vcn
op_assign
id|startvcn
suffix:semicolon
id|vcn
op_le
id|endvcn
suffix:semicolon
id|vcn
op_add_assign
id|len
)paren
(brace
r_if
c_cond
(paren
id|ntfs_decompress_run
c_func
(paren
op_amp
id|data
comma
op_amp
id|len
comma
op_amp
id|cluster
comma
op_amp
id|ctype
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ctype
)paren
id|ntfs_insert_run
c_func
(paren
id|attr
comma
id|cnum
comma
op_minus
l_int|1
comma
id|len
)paren
suffix:semicolon
r_else
id|ntfs_insert_run
c_func
(paren
id|attr
comma
id|cnum
comma
id|cluster
comma
id|len
)paren
suffix:semicolon
id|cnum
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Insert the attribute starting at attr in the inode ino. */
DECL|function|ntfs_insert_attribute
r_int
id|ntfs_insert_attribute
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
r_char
op_star
id|attrdata
)paren
(brace
r_int
id|i
comma
id|found
suffix:semicolon
r_int
id|type
suffix:semicolon
r_int
r_int
op_star
id|name
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
r_int
id|error
suffix:semicolon
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|attrdata
)paren
suffix:semicolon
id|namelen
op_assign
id|NTFS_GETU8
c_func
(paren
id|attrdata
op_plus
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Read the attribute&squot;s name if it has one. */
r_if
c_cond
(paren
op_logical_neg
id|namelen
)paren
id|name
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/* 1 Unicode character fits in 2 bytes. */
id|name
op_assign
id|ntfs_malloc
c_func
(paren
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|name
comma
id|attrdata
op_plus
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|10
)paren
comma
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_new_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
comma
id|namelen
comma
op_amp
id|i
comma
op_amp
id|found
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|name
)paren
id|ntfs_free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* We can have in one inode two attributes with type 0x00000030 (File&n;&t; * Name) and without name. FIXME: We can have a lot more than two!&n;&t; * That is how hard links are implemented. (AIA) */
r_if
c_cond
(paren
id|found
op_logical_and
multiline_comment|/*FIXME*/
id|type
op_ne
id|ino-&gt;vol-&gt;at_file_name
)paren
(brace
id|ntfs_process_runs
c_func
(paren
id|ino
comma
id|ino-&gt;attrs
op_plus
id|i
comma
id|attrdata
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|found
)paren
(brace
multiline_comment|/* Don&squot;t understand the above, but I know it leaks memory below&n;&t;&t; * as it overwrites a found entry without freeing it. So here&n;&t;&t; * we call ntfs_new_attr again but this time ask it to always&n;&t;&t; * allocate a new entry. */
id|ntfs_new_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
comma
id|namelen
comma
op_amp
id|i
comma
op_amp
id|found
comma
l_int|0
)paren
suffix:semicolon
)brace
id|attr
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
id|attr-&gt;resident
op_assign
id|NTFS_GETU8
c_func
(paren
id|attrdata
op_plus
l_int|8
)paren
op_eq
l_int|0
suffix:semicolon
id|attr-&gt;compressed
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0xC
)paren
suffix:semicolon
id|attr-&gt;attrno
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0xE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
id|attr-&gt;size
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x10
)paren
suffix:semicolon
id|data
op_assign
id|attrdata
op_plus
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x14
)paren
suffix:semicolon
id|attr-&gt;d.data
op_assign
(paren
r_void
op_star
)paren
id|ntfs_malloc
c_func
(paren
id|attr-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;d.data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|attr-&gt;d.data
comma
id|data
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|attr-&gt;indexed
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x16
)paren
suffix:semicolon
)brace
r_else
(brace
id|attr-&gt;allocated
op_assign
id|NTFS_GETU32
c_func
(paren
id|attrdata
op_plus
l_int|0x28
)paren
suffix:semicolon
id|attr-&gt;size
op_assign
id|NTFS_GETU32
c_func
(paren
id|attrdata
op_plus
l_int|0x30
)paren
suffix:semicolon
id|attr-&gt;initialized
op_assign
id|NTFS_GETU32
c_func
(paren
id|attrdata
op_plus
l_int|0x38
)paren
suffix:semicolon
id|attr-&gt;cengine
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x22
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;compressed
)paren
id|attr-&gt;compsize
op_assign
id|NTFS_GETU32
c_func
(paren
id|attrdata
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.len
op_assign
l_int|0
suffix:semicolon
id|ntfs_process_runs
c_func
(paren
id|ino
comma
id|attr
comma
id|attrdata
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_read_zero
r_int
id|ntfs_read_zero
c_func
(paren
id|ntfs_io
op_star
id|dest
comma
r_int
id|size
)paren
(brace
r_char
op_star
id|sparse
op_assign
id|ntfs_calloc
c_func
(paren
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sparse
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|size
)paren
(brace
r_int
id|i
op_assign
id|min
c_func
(paren
id|size
comma
l_int|512
)paren
suffix:semicolon
id|dest
op_member_access_from_pointer
id|fn_put
c_func
(paren
id|dest
comma
id|sparse
comma
id|i
)paren
suffix:semicolon
id|size
op_sub_assign
id|i
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|sparse
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Process compressed attributes. */
DECL|function|ntfs_read_compressed
r_int
id|ntfs_read_compressed
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
r_int
id|offset
comma
id|ntfs_io
op_star
id|dest
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|clustersize
comma
id|l
suffix:semicolon
r_int
id|s_vcn
comma
id|rnum
comma
id|vcn
comma
id|len
comma
id|chunk
comma
id|got
comma
id|l1
comma
id|offs1
comma
id|copied
suffix:semicolon
id|ntfs_cluster_t
id|cluster
comma
id|cl1
suffix:semicolon
r_char
op_star
id|comp
op_assign
l_int|0
comma
op_star
id|comp1
suffix:semicolon
r_char
op_star
id|decomp
op_assign
l_int|0
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
suffix:semicolon
id|l
op_assign
id|dest-&gt;size
suffix:semicolon
id|clustersize
op_assign
id|ino-&gt;vol-&gt;clustersize
suffix:semicolon
multiline_comment|/* Starting cluster of potential chunk. There are three situations:&n;&t;   a) In a large uncompressible or sparse chunk, s_vcn is in the middle&n;&t;      of a run.&n;&t;   b) s_vcn is right on a run border.&n;&t;   c) When several runs make a chunk, s_vcn is before the chunks. */
id|s_vcn
op_assign
id|offset
op_div
id|clustersize
suffix:semicolon
multiline_comment|/* Round down to multiple of 16. */
id|s_vcn
op_and_assign
op_complement
l_int|15
suffix:semicolon
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
id|vcn
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|attr-&gt;d.r.len
op_logical_and
id|vcn
op_plus
id|rl-&gt;len
op_le
id|s_vcn
suffix:semicolon
id|rnum
op_increment
comma
id|rl
op_increment
)paren
id|vcn
op_add_assign
id|rl-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|rnum
op_eq
id|attr-&gt;d.r.len
)paren
(brace
multiline_comment|/* Beyond end of file. */
multiline_comment|/* FIXME: Check allocated / initialized. */
id|dest-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
l_int|0
suffix:semicolon
id|cluster
op_assign
id|rl-&gt;cluster
suffix:semicolon
id|len
op_assign
id|rl-&gt;len
suffix:semicolon
id|copied
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
id|chunk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cluster
op_eq
id|MAX_CLUSTER_T
)paren
(brace
multiline_comment|/* Sparse cluster. */
r_int
id|l1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_minus
(paren
id|s_vcn
op_minus
id|vcn
)paren
)paren
op_amp
l_int|15
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;Unexpected sparse chunk size.&quot;
)paren
suffix:semicolon
id|l1
op_assign
id|chunk
op_assign
id|min
c_func
(paren
(paren
id|vcn
op_plus
id|len
)paren
op_star
id|clustersize
op_minus
id|offset
comma
id|l
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|l1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
id|comp
op_assign
id|ntfs_malloc
c_func
(paren
l_int|16
op_star
id|clustersize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|got
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We might need to start in the middle of a run. */
id|cl1
op_assign
id|cluster
op_plus
id|s_vcn
op_minus
id|vcn
suffix:semicolon
id|comp1
op_assign
id|comp
suffix:semicolon
r_do
(brace
id|io.param
op_assign
id|comp1
suffix:semicolon
id|l1
op_assign
id|min
c_func
(paren
id|len
op_minus
id|max
c_func
(paren
id|s_vcn
op_minus
id|vcn
comma
l_int|0
)paren
comma
l_int|16
op_minus
id|got
)paren
suffix:semicolon
id|io.size
op_assign
id|l1
op_star
id|clustersize
suffix:semicolon
id|error
op_assign
id|ntfs_getput_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|cl1
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|l1
op_plus
id|max
c_func
(paren
id|s_vcn
op_minus
id|vcn
comma
l_int|0
)paren
op_eq
id|len
)paren
(brace
id|rnum
op_increment
suffix:semicolon
id|rl
op_increment
suffix:semicolon
id|vcn
op_add_assign
id|len
suffix:semicolon
id|cluster
op_assign
id|cl1
op_assign
id|rl-&gt;cluster
suffix:semicolon
id|len
op_assign
id|rl-&gt;len
suffix:semicolon
)brace
id|got
op_add_assign
id|l1
suffix:semicolon
id|comp1
op_add_assign
id|l1
op_star
id|clustersize
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cluster
op_ne
id|MAX_CLUSTER_T
op_logical_and
id|got
OL
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Until empty run. */
id|chunk
op_assign
l_int|16
op_star
id|clustersize
suffix:semicolon
r_if
c_cond
(paren
id|cluster
op_ne
id|MAX_CLUSTER_T
op_logical_or
id|got
op_eq
l_int|16
)paren
multiline_comment|/* Uncompressible */
id|comp1
op_assign
id|comp
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|decomp
)paren
(brace
id|decomp
op_assign
id|ntfs_malloc
c_func
(paren
l_int|16
op_star
id|clustersize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|decomp
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Make sure there are null bytes after the&n;&t;&t;&t;&t; * last block. */
op_star
(paren
id|ntfs_u32
op_star
)paren
id|comp1
op_assign
l_int|0
suffix:semicolon
id|ntfs_decompress
c_func
(paren
id|decomp
comma
id|comp
comma
id|chunk
)paren
suffix:semicolon
id|comp1
op_assign
id|decomp
suffix:semicolon
)brace
id|offs1
op_assign
id|offset
op_minus
id|s_vcn
op_star
id|clustersize
suffix:semicolon
id|chunk
op_assign
id|min
c_func
(paren
l_int|16
op_star
id|clustersize
op_minus
id|offs1
comma
id|chunk
)paren
suffix:semicolon
id|chunk
op_assign
id|min
c_func
(paren
id|l
comma
id|chunk
)paren
suffix:semicolon
id|dest
op_member_access_from_pointer
id|fn_put
c_func
(paren
id|dest
comma
id|comp1
op_plus
id|offs1
comma
id|chunk
)paren
suffix:semicolon
)brace
id|l
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
id|offset
op_add_assign
id|chunk
suffix:semicolon
id|s_vcn
op_assign
id|offset
op_div
id|clustersize
op_amp
op_complement
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|l
op_logical_and
id|offset
op_ge
(paren
(paren
id|vcn
op_plus
id|len
)paren
op_star
id|clustersize
)paren
)paren
(brace
id|rnum
op_increment
suffix:semicolon
id|rl
op_increment
suffix:semicolon
id|vcn
op_add_assign
id|len
suffix:semicolon
id|cluster
op_assign
id|rl-&gt;cluster
suffix:semicolon
id|len
op_assign
id|rl-&gt;len
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|comp
)paren
id|ntfs_free
c_func
(paren
id|comp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|decomp
)paren
id|ntfs_free
c_func
(paren
id|decomp
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ntfs_write_compressed
r_int
id|ntfs_write_compressed
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
r_int
id|offset
comma
id|ntfs_io
op_star
id|dest
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
eof
