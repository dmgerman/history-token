multiline_comment|/*&n; * attr.c&n; *&n; * Copyright (C) 1996-1999 Martin von L&#xfffd;wis&n; * Copyright (C) 1996-1997 R&#xfffd;gis Duchesne&n; * Copyright (C) 1998 Joseph Malicki&n; * Copyright (C) 1999 Steve Dodd&n; * Copyright (C) 2001 Anton Altaparmakov (AIA)&n; */
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ntfs_fs.h&gt;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;unistr.h&quot;
multiline_comment|/**&n; * ntfs_find_attr_in_mft_rec - find attribute in mft record&n; * @vol:&t;volume on which attr resides&n; * @m:&t;&t;mft record to search&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;ignore case if 1 or case sensitive if 0 (ignored if @name NULL)&n; * @instance:&t;instance number to find&n; *&n; * Only search the specified mft record and it ignores the presence of an&n; * attribute list attribute (unless it is the one being searched for,&n; * obviously, in which case it is returned).&n; */
DECL|function|ntfs_find_attr_in_mft_rec
id|ntfs_u8
op_star
id|ntfs_find_attr_in_mft_rec
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_u8
op_star
id|m
comma
id|__u32
id|type
comma
m_wchar_t
op_star
id|name
comma
id|__u32
id|name_len
comma
r_int
id|ic
comma
id|__u16
id|instance
)paren
(brace
id|ntfs_u8
op_star
id|a
suffix:semicolon
multiline_comment|/* Iterate over attributes in mft record @m. */
id|a
op_assign
id|m
op_plus
id|NTFS_GETU16
c_func
(paren
id|m
op_plus
l_int|20
)paren
suffix:semicolon
multiline_comment|/* attrs_offset */
r_for
c_loop
(paren
suffix:semicolon
id|a
op_ge
id|m
op_logical_and
id|a
op_le
id|m
op_plus
id|vol-&gt;mft_record_size
suffix:semicolon
id|a
op_add_assign
id|NTFS_GETU32
c_func
(paren
id|a
op_plus
l_int|4
multiline_comment|/* length */
)paren
)paren
(brace
multiline_comment|/* We catch $END with this more general check, too... */
r_if
c_cond
(paren
id|NTFS_GETU32
c_func
(paren
id|a
op_plus
l_int|0
multiline_comment|/* type */
)paren
OG
id|type
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NTFS_GETU32
c_func
(paren
id|a
op_plus
l_int|4
multiline_comment|/* length */
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|NTFS_GETU32
c_func
(paren
id|a
op_plus
l_int|0
multiline_comment|/* type */
)paren
op_ne
id|type
)paren
r_continue
suffix:semicolon
multiline_comment|/* If @name is present, compare the two names. */
r_if
c_cond
(paren
id|name
op_logical_and
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
id|name
comma
id|name_len
comma
(paren
m_wchar_t
op_star
)paren
(paren
id|a
op_plus
id|NTFS_GETU16
c_func
(paren
id|a
op_plus
l_int|10
multiline_comment|/* name_offset */
)paren
)paren
comma
id|a
(braket
l_int|9
)braket
multiline_comment|/* name_length */
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_length
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_length
comma
id|name
comma
id|name_len
comma
(paren
m_wchar_t
op_star
)paren
(paren
id|a
op_plus
id|NTFS_GETU16
c_func
(paren
id|a
op_plus
l_int|10
multiline_comment|/* name_offset */
)paren
)paren
comma
id|a
(braket
l_int|9
)braket
multiline_comment|/* name_length */
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @name collates before a-&gt;name, there is no&n;&t;&t;&t; * matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If the strings are not equal, continue search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_length
comma
id|name
comma
id|name_len
comma
(paren
m_wchar_t
op_star
)paren
(paren
id|a
op_plus
id|NTFS_GETU16
c_func
(paren
id|a
op_plus
l_int|10
multiline_comment|/* name_offset */
)paren
)paren
comma
id|a
(braket
l_int|9
)braket
multiline_comment|/* name_length */
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The names match or @name not present. Check instance number.&n;&t;&t; * and if it matches we have found the attribute and are done.&n;&t;&t; */
r_if
c_cond
(paren
id|instance
op_ne
id|NTFS_GETU16
c_func
(paren
id|a
op_plus
l_int|14
multiline_comment|/* instance */
)paren
)paren
r_continue
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_find_attr_in_mft_record: found: &quot;
l_string|&quot;attr type 0x%x, instance number = 0x%x.&bslash;n&quot;
comma
id|NTFS_GETU32
c_func
(paren
id|a
op_plus
l_int|0
)paren
comma
id|instance
)paren
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_find_attr_in_mft_record: mft record 0x%x is corrupt&quot;
l_string|&quot;. Run chkdsk.&bslash;n&quot;
comma
id|m
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Look if an attribute already exists in the inode, and if not, create it. */
DECL|function|ntfs_new_attr
r_int
id|ntfs_new_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
comma
r_void
op_star
id|name
comma
r_int
id|namelen
comma
r_void
op_star
id|value
comma
r_int
id|value_len
comma
r_int
op_star
id|pos
comma
r_int
op_star
id|found
)paren
(brace
r_int
id|do_insert
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|m
suffix:semicolon
id|ntfs_attribute
op_star
id|a
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|a
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OL
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
OG
id|type
)paren
(brace
id|do_insert
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If @name is present, compare the two names. */
r_if
c_cond
(paren
id|namelen
op_logical_and
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
(paren
m_wchar_t
op_star
)paren
id|name
comma
id|namelen
comma
id|a-&gt;name
comma
id|a-&gt;namelen
multiline_comment|/* name_length */
comma
l_int|1
multiline_comment|/* ignore case*/
comma
id|ino-&gt;vol-&gt;upcase
comma
id|ino-&gt;vol-&gt;upcase_length
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|ino-&gt;vol-&gt;upcase
comma
id|ino-&gt;vol-&gt;upcase_length
comma
id|a-&gt;name
comma
id|a-&gt;namelen
comma
(paren
m_wchar_t
op_star
)paren
id|name
comma
id|namelen
comma
l_int|1
multiline_comment|/* ignore case */
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
(brace
id|do_insert
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|ino-&gt;vol-&gt;upcase
comma
id|ino-&gt;vol-&gt;upcase_length
comma
id|a-&gt;name
comma
id|a-&gt;namelen
comma
(paren
m_wchar_t
op_star
)paren
id|name
comma
id|namelen
comma
l_int|0
multiline_comment|/* case sensitive */
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
(brace
id|do_insert
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Names are equal or no name was asked for. */
multiline_comment|/* If a value was specified compare the values. */
r_if
c_cond
(paren
id|value_len
op_logical_and
id|a-&gt;resident
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;resident
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_new_attr: Value specified but &quot;
l_string|&quot;attribute non-resident. Bug!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|m
op_assign
id|value_len
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
id|a-&gt;size
)paren
id|m
op_assign
id|a-&gt;size
suffix:semicolon
id|m
op_assign
id|memcmp
c_func
(paren
id|value
comma
id|a-&gt;d.data
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
OG
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|m
OL
l_int|0
)paren
(brace
id|do_insert
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Values match until min of value lengths. */
r_if
c_cond
(paren
id|value_len
OG
id|a-&gt;size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|value_len
OL
id|a-&gt;size
)paren
(brace
id|do_insert
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Full match! */
op_star
id|found
op_assign
l_int|1
suffix:semicolon
op_star
id|pos
op_assign
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Re-allocate space. */
r_if
c_cond
(paren
id|ino-&gt;attr_count
op_mod
l_int|8
op_eq
l_int|0
)paren
(brace
id|ntfs_attribute
op_star
r_new
suffix:semicolon
r_new
op_assign
(paren
id|ntfs_attribute
op_star
)paren
id|ntfs_malloc
c_func
(paren
(paren
id|ino-&gt;attr_count
op_plus
l_int|8
)paren
op_star
r_sizeof
(paren
id|ntfs_attribute
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|ino-&gt;attrs
)paren
(brace
id|ntfs_memcpy
c_func
(paren
r_new
comma
id|ino-&gt;attrs
comma
id|ino-&gt;attr_count
op_star
r_sizeof
(paren
id|ntfs_attribute
)paren
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|ino-&gt;attrs
)paren
suffix:semicolon
)brace
id|ino-&gt;attrs
op_assign
r_new
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_insert
)paren
id|ntfs_memmove
c_func
(paren
id|ino-&gt;attrs
op_plus
id|i
op_plus
l_int|1
comma
id|ino-&gt;attrs
op_plus
id|i
comma
(paren
id|ino-&gt;attr_count
op_minus
id|i
)paren
op_star
r_sizeof
(paren
id|ntfs_attribute
)paren
)paren
suffix:semicolon
id|ino-&gt;attr_count
op_increment
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|namelen
op_assign
id|namelen
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|name
op_assign
id|name
suffix:semicolon
op_star
id|pos
op_assign
id|i
suffix:semicolon
op_star
id|found
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_make_attr_resident
r_int
id|ntfs_make_attr_resident
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
)paren
(brace
id|__s64
id|size
op_assign
id|attr-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
multiline_comment|/* FIXME: read data, free clusters */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
id|attr-&gt;resident
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Store in the inode readable information about a run. */
DECL|function|ntfs_insert_run
r_int
id|ntfs_insert_run
c_func
(paren
id|ntfs_attribute
op_star
id|attr
comma
r_int
id|cnum
comma
id|ntfs_cluster_t
id|cluster
comma
r_int
id|len
)paren
(brace
multiline_comment|/* (re-)allocate space if necessary. */
r_if
c_cond
(paren
(paren
id|attr-&gt;d.r.len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
op_mod
id|PAGE_SIZE
op_eq
l_int|0
)paren
(brace
id|ntfs_runlist
op_star
r_new
suffix:semicolon
r_int
r_int
id|new_size
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_MALLOC
comma
l_string|&quot;ntfs_insert_run: re-allocating &quot;
l_string|&quot;space: old attr-&gt;d.r.len = 0x%x&bslash;n&quot;
comma
id|attr-&gt;d.r.len
)paren
suffix:semicolon
id|new_size
op_assign
id|attr-&gt;d.r.len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
op_plus
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_size
op_rshift
id|PAGE_SHIFT
)paren
OG
id|num_physpages
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_insert_run: attempted to allocate &quot;
l_string|&quot;more pages than num_physpages.&quot;
l_string|&quot;This might be a bug or a corrupt&quot;
l_string|&quot;file system.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_new
op_assign
id|ntfs_vmalloc
c_func
(paren
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_insert_run: ntfs_vmalloc(new_size = &quot;
l_string|&quot;0x%x) failed&bslash;n&quot;
comma
id|new_size
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;d.r.runlist
)paren
(brace
id|ntfs_memcpy
c_func
(paren
r_new
comma
id|attr-&gt;d.r.runlist
comma
id|attr-&gt;d.r.len
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
id|ntfs_vfree
c_func
(paren
id|attr-&gt;d.r.runlist
)paren
suffix:semicolon
)brace
id|attr-&gt;d.r.runlist
op_assign
r_new
suffix:semicolon
)brace
r_if
c_cond
(paren
id|attr-&gt;d.r.len
OG
id|cnum
)paren
id|ntfs_memmove
c_func
(paren
id|attr-&gt;d.r.runlist
op_plus
id|cnum
op_plus
l_int|1
comma
id|attr-&gt;d.r.runlist
op_plus
id|cnum
comma
(paren
id|attr-&gt;d.r.len
op_minus
id|cnum
)paren
op_star
r_sizeof
(paren
id|ntfs_runlist
)paren
)paren
suffix:semicolon
id|attr-&gt;d.r.runlist
(braket
id|cnum
)braket
dot
id|cluster
op_assign
id|cluster
suffix:semicolon
id|attr-&gt;d.r.runlist
(braket
id|cnum
)braket
dot
id|len
op_assign
id|len
suffix:semicolon
id|attr-&gt;d.r.len
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Extends an attribute. Another run will be added if necessary, but we try to&n; * extend the last run in the run list first.&n; * FIXME: what if there isn&squot;t enough contiguous space, we don&squot;t create&n; * multiple runs?&n; *&n; * *len: the desired new length of the attr (_not_ the amount to extend by)&n; */
DECL|function|ntfs_extend_attr
r_int
id|ntfs_extend_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
id|__s64
op_star
id|len
comma
r_int
id|flags
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
suffix:semicolon
r_int
id|rlen
suffix:semicolon
id|ntfs_cluster_t
id|cluster
suffix:semicolon
r_int
id|clen
suffix:semicolon
r_if
c_cond
(paren
(paren
id|attr-&gt;flags
op_amp
(paren
id|ATTR_IS_COMPRESSED
op_or
id|ATTR_IS_ENCRYPTED
)paren
)paren
op_logical_or
id|ino-&gt;record_count
OG
l_int|1
)paren
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
id|error
op_assign
id|ntfs_make_attr_nonresident
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|len
op_le
id|attr-&gt;allocated
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Truly stupid things do sometimes happen. */
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
id|rlen
op_assign
id|attr-&gt;d.r.len
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|rlen
op_ge
l_int|0
)paren
id|cluster
op_assign
id|rl
(braket
id|rlen
)braket
dot
id|cluster
op_plus
id|rl
(braket
id|rlen
)braket
dot
id|len
suffix:semicolon
r_else
multiline_comment|/* No preference for allocation space. */
id|cluster
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate the extra space we need, and round up to multiple of&n;&t; * cluster size to get number of new clusters needed */
id|clen
op_assign
(paren
(paren
op_star
id|len
op_minus
id|attr-&gt;allocated
)paren
op_plus
id|ino-&gt;vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_rshift
id|ino-&gt;vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
id|clen
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: try to allocate smaller pieces */
id|error
op_assign
id|ntfs_allocate_clusters
c_func
(paren
id|ino-&gt;vol
comma
op_amp
id|cluster
comma
op_amp
id|clen
comma
id|flags
op_or
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|attr-&gt;allocated
op_add_assign
(paren
id|__s64
)paren
id|clen
op_lshift
id|ino-&gt;vol-&gt;cluster_size_bits
suffix:semicolon
op_star
id|len
op_assign
id|attr-&gt;allocated
suffix:semicolon
multiline_comment|/* Contiguous chunk. */
r_if
c_cond
(paren
id|rlen
op_ge
l_int|0
op_logical_and
id|cluster
op_eq
id|rl
(braket
id|rlen
)braket
dot
id|cluster
op_plus
id|rl
(braket
id|rlen
)braket
dot
id|len
)paren
(brace
id|rl
(braket
id|rlen
)braket
dot
id|len
op_add_assign
id|clen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * FIXME: if ntfs_insert_run fails we need to deallocate the cluster&n;&t; * to revert to state before we were called...&n;&t; */
id|ntfs_insert_run
c_func
(paren
id|attr
comma
id|rlen
op_plus
l_int|1
comma
id|cluster
comma
id|clen
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_make_attr_nonresident
r_int
id|ntfs_make_attr_nonresident
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
)paren
(brace
r_void
op_star
id|data
op_assign
id|attr-&gt;d.data
suffix:semicolon
id|__s64
id|len
op_assign
id|attr-&gt;size
suffix:semicolon
r_int
id|error
suffix:semicolon
id|__s64
id|alen
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|attr-&gt;d.r.len
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;d.r.runlist
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;resident
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;allocated
op_assign
id|attr-&gt;initialized
op_assign
l_int|0
suffix:semicolon
id|alen
op_assign
id|len
suffix:semicolon
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|ino
comma
id|attr
comma
op_amp
id|alen
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: On error, restore old values. */
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|data
suffix:semicolon
id|io.size
op_assign
id|len
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
r_return
id|ntfs_readwrite_attr
c_func
(paren
id|ino
comma
id|attr
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
)brace
DECL|function|ntfs_attr_allnonresident
r_int
id|ntfs_attr_allnonresident
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
r_int
id|i
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|error
op_logical_and
id|i
OL
id|ino-&gt;attr_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_ne
id|vol-&gt;at_security_descriptor
op_logical_and
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|type
op_ne
id|vol-&gt;at_data
)paren
r_continue
suffix:semicolon
id|error
op_assign
id|ntfs_make_attr_nonresident
c_func
(paren
id|ino
comma
id|ino-&gt;attrs
op_plus
id|i
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Resize the attribute to a newsize. */
DECL|function|ntfs_resize_attr
r_int
id|ntfs_resize_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
id|__s64
id|newsize
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|__s64
id|oldsize
op_assign
id|attr-&gt;size
suffix:semicolon
r_int
id|clustersizebits
op_assign
id|ino-&gt;vol-&gt;cluster_size_bits
suffix:semicolon
r_int
id|i
comma
id|count
comma
id|newcount
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
suffix:semicolon
id|__s64
id|newlen
suffix:semicolon
r_if
c_cond
(paren
id|newsize
op_eq
id|oldsize
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: Modifying compressed attributes not supported yet. */
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
(paren
id|ATTR_IS_COMPRESSED
op_or
id|ATTR_IS_ENCRYPTED
)paren
)paren
multiline_comment|/* FIXME: Extending is easy: just insert sparse runs. */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
r_void
op_star
id|v
suffix:semicolon
r_if
c_cond
(paren
id|newsize
OG
id|ino-&gt;vol-&gt;mft_record_size
)paren
(brace
id|error
op_assign
id|ntfs_make_attr_nonresident
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
id|ntfs_resize_attr
c_func
(paren
id|ino
comma
id|attr
comma
id|newsize
)paren
suffix:semicolon
)brace
id|v
op_assign
id|attr-&gt;d.data
suffix:semicolon
r_if
c_cond
(paren
id|newsize
)paren
(brace
id|__s64
id|minsize
op_assign
id|newsize
suffix:semicolon
id|attr-&gt;d.data
op_assign
id|ntfs_malloc
c_func
(paren
id|newsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;d.data
)paren
(brace
id|ntfs_free
c_func
(paren
id|v
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newsize
OG
id|oldsize
)paren
(brace
id|minsize
op_assign
id|oldsize
suffix:semicolon
id|ntfs_bzero
c_func
(paren
(paren
r_char
op_star
)paren
id|attr-&gt;d.data
op_plus
id|oldsize
comma
id|newsize
op_minus
id|oldsize
)paren
suffix:semicolon
)brace
id|ntfs_memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|attr-&gt;d.data
comma
id|v
comma
id|minsize
)paren
suffix:semicolon
)brace
r_else
id|attr-&gt;d.data
op_assign
l_int|0
suffix:semicolon
id|ntfs_free
c_func
(paren
id|v
)paren
suffix:semicolon
id|attr-&gt;size
op_assign
id|newsize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Non-resident attribute. */
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
r_if
c_cond
(paren
id|newsize
OL
id|oldsize
)paren
(brace
multiline_comment|/*&n;&t;&t; * FIXME: We might be going awfully wrong for newsize = 0,&n;&t;&t; * possibly even leaking memory really badly. But considering&n;&t;&t; * in that case there is more breakage due to -ENOTSUP stuff&n;&t;&t; * further down the code path, who cares for the moment... (AIA)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|__s64
)paren
(paren
id|count
op_plus
id|rl
(braket
id|i
)braket
dot
id|len
)paren
op_lshift
id|clustersizebits
OG
id|newsize
)paren
r_break
suffix:semicolon
id|count
op_add_assign
(paren
r_int
)paren
id|rl
(braket
id|i
)braket
dot
id|len
suffix:semicolon
)brace
id|newlen
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Free unused clusters in current run, unless sparse. */
id|newcount
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
op_ne
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
(brace
r_int
id|rounded
op_assign
id|newsize
op_minus
(paren
(paren
id|__s64
)paren
id|count
op_lshift
id|clustersizebits
)paren
suffix:semicolon
id|rounded
op_assign
(paren
id|rounded
op_plus
id|ino-&gt;vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_rshift
id|clustersizebits
suffix:semicolon
id|error
op_assign
id|ntfs_deallocate_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|rl
(braket
id|i
)braket
dot
id|cluster
op_plus
id|rounded
comma
(paren
r_int
)paren
id|rl
(braket
id|i
)braket
dot
id|len
op_minus
id|rounded
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: Incomplete operation. */
id|rl
(braket
id|i
)braket
dot
id|len
op_assign
id|rounded
suffix:semicolon
id|newcount
op_assign
id|count
op_plus
id|rounded
suffix:semicolon
)brace
multiline_comment|/* Free all other runs. */
r_for
c_loop
(paren
id|i
op_increment
suffix:semicolon
id|i
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rl
(braket
id|i
)braket
dot
id|cluster
op_ne
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
(brace
id|error
op_assign
id|ntfs_deallocate_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|rl
(braket
id|i
)braket
dot
id|cluster
comma
(paren
r_int
)paren
id|rl
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: Incomplete &n;&t;&t;&t;&t;&t;&t;       * operation */
)brace
multiline_comment|/* FIXME: Free space for extra runs in memory? */
id|attr-&gt;d.r.len
op_assign
id|newlen
suffix:semicolon
)brace
r_else
(brace
id|newlen
op_assign
id|newsize
suffix:semicolon
id|error
op_assign
id|ntfs_extend_attr
c_func
(paren
id|ino
comma
id|attr
comma
op_amp
id|newlen
comma
id|ALLOC_REQUIRE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* FIXME: Incomplete operation. */
id|newcount
op_assign
id|newlen
op_rshift
id|clustersizebits
suffix:semicolon
)brace
multiline_comment|/* Fill in new sizes. */
id|attr-&gt;allocated
op_assign
(paren
id|__s64
)paren
id|newcount
op_lshift
id|clustersizebits
suffix:semicolon
id|attr-&gt;size
op_assign
id|newsize
suffix:semicolon
multiline_comment|/* attr-&gt;initialized does not change. */
r_if
c_cond
(paren
op_logical_neg
id|newsize
)paren
id|error
op_assign
id|ntfs_make_attr_resident
c_func
(paren
id|ino
comma
id|attr
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ntfs_create_attr
r_int
id|ntfs_create_attr
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|anum
comma
r_char
op_star
id|aname
comma
r_void
op_star
id|data
comma
r_int
id|dsize
comma
id|ntfs_attribute
op_star
op_star
id|rattr
)paren
(brace
r_void
op_star
id|name
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_int
id|found
comma
id|i
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
r_if
c_cond
(paren
id|dsize
OG
id|ino-&gt;vol-&gt;mft_record_size
)paren
multiline_comment|/* FIXME: Non-resident attributes. */
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_if
c_cond
(paren
id|aname
)paren
(brace
id|namelen
op_assign
id|strlen
c_func
(paren
id|aname
)paren
suffix:semicolon
id|name
op_assign
id|ntfs_malloc
c_func
(paren
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_ascii2uni
c_func
(paren
id|name
comma
id|aname
comma
id|namelen
)paren
suffix:semicolon
)brace
r_else
(brace
id|name
op_assign
l_int|0
suffix:semicolon
id|namelen
op_assign
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_new_attr
c_func
(paren
id|ino
comma
id|anum
comma
id|name
comma
id|namelen
comma
id|data
comma
id|dsize
comma
op_amp
id|i
comma
op_amp
id|found
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|found
)paren
(brace
id|ntfs_free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|error
suffix:colon
op_minus
id|EEXIST
suffix:semicolon
)brace
op_star
id|rattr
op_assign
id|attr
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
multiline_comment|/* Allocate a new number.&n;&t; * FIXME: Should this happen on inode writeback?&n;&t; * FIXME: Extension records not supported. */
id|error
op_assign
id|ntfs_allocate_attr_number
c_func
(paren
id|ino
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|attr-&gt;attrno
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;attrno
op_plus
l_int|1
op_ne
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
)paren
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;UH OH! attr-&gt;attrno (%i) != NTFS_GETU16(ino-&gt;attr &quot;
l_string|&quot;+ 0x28) (%i)&bslash;n&quot;
comma
id|attr-&gt;attrno
comma
id|NTFS_GETU16
c_func
(paren
id|ino-&gt;attr
op_plus
l_int|0x28
)paren
)paren
suffix:semicolon
id|attr-&gt;resident
op_assign
l_int|1
suffix:semicolon
id|attr-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;cengine
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;size
op_assign
id|attr-&gt;allocated
op_assign
id|attr-&gt;initialized
op_assign
id|dsize
suffix:semicolon
multiline_comment|/* FIXME: INDEXED information should come from $AttrDef&n;&t; * Currently, only file names are indexed. As of NTFS v3.0 (Win2k),&n;&t; * this is no longer true. Different attributes can be indexed now. */
r_if
c_cond
(paren
id|anum
op_eq
id|ino-&gt;vol-&gt;at_file_name
)paren
id|attr-&gt;indexed
op_assign
l_int|1
suffix:semicolon
r_else
id|attr-&gt;indexed
op_assign
l_int|0
suffix:semicolon
id|attr-&gt;d.data
op_assign
id|ntfs_malloc
c_func
(paren
id|dsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;d.data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|attr-&gt;d.data
comma
id|data
comma
id|dsize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Non-resident attributes are stored in runs (intervals of clusters).&n; *&n; * This function stores in the inode readable information about a non-resident&n; * attribute.&n; */
DECL|function|ntfs_process_runs
r_static
r_int
id|ntfs_process_runs
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|startvcn
comma
id|endvcn
suffix:semicolon
r_int
id|vcn
comma
id|cnum
suffix:semicolon
id|ntfs_cluster_t
id|cluster
suffix:semicolon
r_int
id|len
comma
id|ctype
suffix:semicolon
r_int
id|er
op_assign
l_int|0
suffix:semicolon
id|startvcn
op_assign
id|NTFS_GETS64
c_func
(paren
id|data
op_plus
l_int|0x10
)paren
suffix:semicolon
id|endvcn
op_assign
id|NTFS_GETS64
c_func
(paren
id|data
op_plus
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* Check whether this chunk really belongs to the end. Problem with&n;&t; * this: this functions can get called on the last extent first, before&n;&t; * it is called on the other extents in sequence. This happens when the&n;&t; * base mft record contains the last extent instead of the first one&n;&t; * and the first extent is stored, like any intermediate extents in&n;&t; * extension mft records. This would be difficult to allow the way the&n;&t; * run list is stored in memory. Thus we fix else where by causing the&n;&t; * attribute list attribute to be processed immediately when found. The&n;&t; * extents will then be processed starting with the first one. */
r_for
c_loop
(paren
id|cnum
op_assign
l_int|0
comma
id|vcn
op_assign
l_int|0
suffix:semicolon
id|cnum
OL
id|attr-&gt;d.r.len
suffix:semicolon
id|cnum
op_increment
)paren
id|vcn
op_add_assign
id|attr-&gt;d.r.runlist
(braket
id|cnum
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|vcn
op_ne
id|startvcn
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_process_runs: ino = 0x%x, &quot;
l_string|&quot;attr-&gt;type = 0x%x, startvcn = 0x%x, endvcn = 0x%x, &quot;
l_string|&quot;vcn = 0x%x, cnum = 0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|attr-&gt;type
comma
id|startvcn
comma
id|endvcn
comma
id|vcn
comma
id|cnum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vcn
OL
id|startvcn
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Problem with runlist in extended record&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Tried to insert an already inserted run list. */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|endvcn
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|startvcn
)paren
(brace
multiline_comment|/* Allocated length. */
id|endvcn
op_assign
id|NTFS_GETS64
c_func
(paren
id|data
op_plus
l_int|0x28
)paren
op_minus
l_int|1
suffix:semicolon
id|endvcn
op_rshift_assign
id|ino-&gt;vol-&gt;cluster_size_bits
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is an extent. Allocated length is not defined!&n;&t;&t;&t; * Extents must have an endvcn though so this is an&n;&t;&t;&t; * error. */
id|ntfs_error
c_func
(paren
l_string|&quot;Corrupt attribute extent. (endvcn is &quot;
l_string|&quot;missing)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|data
op_assign
id|data
op_plus
id|NTFS_GETU16
c_func
(paren
id|data
op_plus
l_int|0x20
)paren
suffix:semicolon
id|cnum
op_assign
id|attr-&gt;d.r.len
suffix:semicolon
id|cluster
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|vcn
op_assign
id|startvcn
suffix:semicolon
id|vcn
op_le
id|endvcn
suffix:semicolon
id|vcn
op_add_assign
id|len
)paren
(brace
r_if
c_cond
(paren
id|ntfs_decompress_run
c_func
(paren
op_amp
id|data
comma
op_amp
id|len
comma
op_amp
id|cluster
comma
op_amp
id|ctype
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_process_runs: &quot;
l_string|&quot;ntfs_decompress_run failed. i_number = 0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctype
)paren
id|er
op_assign
id|ntfs_insert_run
c_func
(paren
id|attr
comma
id|cnum
comma
op_minus
l_int|1
comma
id|len
)paren
suffix:semicolon
r_else
id|er
op_assign
id|ntfs_insert_run
c_func
(paren
id|attr
comma
id|cnum
comma
id|cluster
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|er
)paren
r_break
suffix:semicolon
id|cnum
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|er
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;ntfs_process_runs: ntfs_insert_run failed&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_process_runs: startvcn = 0x%x, vcn = 0x%x&quot;
l_string|&quot;, endvcn = 0x%x, cnum = %i&bslash;n&quot;
comma
id|startvcn
comma
id|vcn
comma
id|endvcn
comma
id|cnum
)paren
suffix:semicolon
r_return
id|er
suffix:semicolon
)brace
multiline_comment|/* Insert the attribute starting at attr in the inode ino. */
DECL|function|ntfs_insert_attribute
r_int
id|ntfs_insert_attribute
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
r_char
op_star
id|attrdata
)paren
(brace
r_int
id|i
comma
id|found
suffix:semicolon
r_int
id|type
suffix:semicolon
r_int
r_int
op_star
id|name
suffix:semicolon
r_int
id|namelen
suffix:semicolon
r_void
op_star
id|data
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
r_int
id|error
suffix:semicolon
id|type
op_assign
id|NTFS_GETU32
c_func
(paren
id|attrdata
)paren
suffix:semicolon
id|namelen
op_assign
id|NTFS_GETU8
c_func
(paren
id|attrdata
op_plus
l_int|9
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_insert_attribute: ino-&gt;i_number 0x%x, &quot;
l_string|&quot;attr type 0x%x&bslash;n&quot;
comma
id|ino-&gt;i_number
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* Read the attribute&squot;s name if it has one. */
r_if
c_cond
(paren
op_logical_neg
id|namelen
)paren
id|name
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/* 1 Unicode character fits in 2 bytes. */
id|name
op_assign
id|ntfs_malloc
c_func
(paren
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|name
comma
id|attrdata
op_plus
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|10
)paren
comma
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
)brace
multiline_comment|/* If resident look for value, too. */
r_if
c_cond
(paren
id|NTFS_GETU8
c_func
(paren
id|attrdata
op_plus
l_int|8
)paren
op_eq
l_int|0
)paren
id|error
op_assign
id|ntfs_new_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
comma
id|namelen
comma
id|attrdata
op_plus
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x14
)paren
comma
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x10
)paren
comma
op_amp
id|i
comma
op_amp
id|found
)paren
suffix:semicolon
r_else
id|error
op_assign
id|ntfs_new_attr
c_func
(paren
id|ino
comma
id|type
comma
id|name
comma
id|namelen
comma
l_int|NULL
comma
l_int|0
comma
op_amp
id|i
comma
op_amp
id|found
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_insert_attribute: ntfs_new_attr &quot;
l_string|&quot;failed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
id|ntfs_free
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
multiline_comment|/* It&squot;s already there, if not resident just process the runs. */
r_if
c_cond
(paren
op_logical_neg
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|resident
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_insert_attribute:&quot;
l_string|&quot; processing runs 1.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: Check error code! (AIA) */
id|ntfs_process_runs
c_func
(paren
id|ino
comma
id|ino-&gt;attrs
op_plus
id|i
comma
id|attrdata
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|attr
op_assign
id|ino-&gt;attrs
op_plus
id|i
suffix:semicolon
id|attr-&gt;resident
op_assign
id|NTFS_GETU8
c_func
(paren
id|attrdata
op_plus
l_int|8
)paren
op_eq
l_int|0
suffix:semicolon
id|attr-&gt;flags
op_assign
op_star
(paren
id|__u16
op_star
)paren
(paren
id|attrdata
op_plus
l_int|0xC
)paren
suffix:semicolon
id|attr-&gt;attrno
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0xE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;resident
)paren
(brace
id|attr-&gt;size
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x10
)paren
suffix:semicolon
id|data
op_assign
id|attrdata
op_plus
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x14
)paren
suffix:semicolon
id|attr-&gt;d.data
op_assign
(paren
r_void
op_star
)paren
id|ntfs_malloc
c_func
(paren
id|attr-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;d.data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|attr-&gt;d.data
comma
id|data
comma
id|attr-&gt;size
)paren
suffix:semicolon
id|attr-&gt;indexed
op_assign
id|NTFS_GETU8
c_func
(paren
id|attrdata
op_plus
l_int|0x16
)paren
suffix:semicolon
)brace
r_else
(brace
id|attr-&gt;allocated
op_assign
id|NTFS_GETS64
c_func
(paren
id|attrdata
op_plus
l_int|0x28
)paren
suffix:semicolon
id|attr-&gt;size
op_assign
id|NTFS_GETS64
c_func
(paren
id|attrdata
op_plus
l_int|0x30
)paren
suffix:semicolon
id|attr-&gt;initialized
op_assign
id|NTFS_GETS64
c_func
(paren
id|attrdata
op_plus
l_int|0x38
)paren
suffix:semicolon
id|attr-&gt;cengine
op_assign
id|NTFS_GETU16
c_func
(paren
id|attrdata
op_plus
l_int|0x22
)paren
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;flags
op_amp
id|ATTR_IS_COMPRESSED
)paren
id|attr-&gt;compsize
op_assign
id|NTFS_GETS64
c_func
(paren
id|attrdata
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_insert_attribute: &quot;
l_string|&quot;attr-&gt;allocated = 0x%Lx, attr-&gt;size = 0x%Lx, &quot;
l_string|&quot;attr-&gt;initialized = 0x%Lx&bslash;n&quot;
comma
id|attr-&gt;allocated
comma
id|attr-&gt;size
comma
id|attr-&gt;initialized
)paren
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.runlist
op_assign
l_int|0
suffix:semicolon
id|ino-&gt;attrs
(braket
id|i
)braket
dot
id|d.r.len
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_FILE3
comma
l_string|&quot;ntfs_insert_attribute: processing &quot;
l_string|&quot;runs 2.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: Check error code! (AIA) */
id|ntfs_process_runs
c_func
(paren
id|ino
comma
id|attr
comma
id|attrdata
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_read_zero
r_int
id|ntfs_read_zero
c_func
(paren
id|ntfs_io
op_star
id|dest
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|sparse
op_assign
id|ntfs_calloc
c_func
(paren
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sparse
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|i
op_assign
l_int|512
suffix:semicolon
r_while
c_loop
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
id|i
OG
id|size
)paren
id|i
op_assign
id|size
suffix:semicolon
id|dest
op_member_access_from_pointer
id|fn_put
c_func
(paren
id|dest
comma
id|sparse
comma
id|i
)paren
suffix:semicolon
id|size
op_sub_assign
id|i
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|sparse
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Process compressed attributes. */
DECL|function|ntfs_read_compressed
r_int
id|ntfs_read_compressed
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|dest
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|clustersizebits
suffix:semicolon
r_int
id|s_vcn
comma
id|rnum
comma
id|vcn
comma
id|got
comma
id|l1
suffix:semicolon
id|__s64
id|copied
comma
id|len
comma
id|chunk
comma
id|offs1
comma
id|l
comma
id|chunk2
suffix:semicolon
id|ntfs_cluster_t
id|cluster
comma
id|cl1
suffix:semicolon
r_char
op_star
id|comp
op_assign
l_int|0
comma
op_star
id|comp1
suffix:semicolon
r_char
op_star
id|decomp
op_assign
l_int|0
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_runlist
op_star
id|rl
suffix:semicolon
id|l
op_assign
id|dest-&gt;size
suffix:semicolon
id|clustersizebits
op_assign
id|ino-&gt;vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/* Starting cluster of potential chunk. There are three situations:&n;&t;   a) In a large uncompressible or sparse chunk, s_vcn is in the middle&n;&t;      of a run.&n;&t;   b) s_vcn is right on a run border.&n;&t;   c) When several runs make a chunk, s_vcn is before the chunks. */
id|s_vcn
op_assign
id|offset
op_rshift
id|clustersizebits
suffix:semicolon
multiline_comment|/* Round down to multiple of 16. */
id|s_vcn
op_and_assign
op_complement
l_int|15
suffix:semicolon
id|rl
op_assign
id|attr-&gt;d.r.runlist
suffix:semicolon
r_for
c_loop
(paren
id|rnum
op_assign
id|vcn
op_assign
l_int|0
suffix:semicolon
id|rnum
OL
id|attr-&gt;d.r.len
op_logical_and
id|vcn
op_plus
id|rl-&gt;len
op_le
id|s_vcn
suffix:semicolon
id|rnum
op_increment
comma
id|rl
op_increment
)paren
id|vcn
op_add_assign
id|rl-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|rnum
op_eq
id|attr-&gt;d.r.len
)paren
(brace
multiline_comment|/* Beyond end of file. */
multiline_comment|/* FIXME: Check allocated / initialized. */
id|dest-&gt;size
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|io.do_read
op_assign
l_int|1
suffix:semicolon
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
l_int|0
suffix:semicolon
id|cluster
op_assign
id|rl-&gt;cluster
suffix:semicolon
id|len
op_assign
id|rl-&gt;len
suffix:semicolon
id|copied
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|l
)paren
(brace
id|chunk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cluster
op_eq
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Sparse cluster. */
id|__s64
id|ll
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_minus
(paren
id|s_vcn
op_minus
id|vcn
)paren
)paren
op_amp
l_int|15
)paren
id|ntfs_error
c_func
(paren
l_string|&quot;Unexpected sparse chunk size.&quot;
)paren
suffix:semicolon
id|ll
op_assign
(paren
(paren
id|__s64
)paren
(paren
id|vcn
op_plus
id|len
)paren
op_lshift
id|clustersizebits
)paren
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|ll
OG
id|l
)paren
id|ll
op_assign
id|l
suffix:semicolon
id|chunk
op_assign
id|ll
suffix:semicolon
id|error
op_assign
id|ntfs_read_zero
c_func
(paren
id|dest
comma
id|ll
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dest-&gt;do_read
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
id|comp
op_assign
id|ntfs_malloc
c_func
(paren
l_int|16
op_lshift
id|clustersizebits
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|comp
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|got
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We might need to start in the middle of a run. */
id|cl1
op_assign
id|cluster
op_plus
id|s_vcn
op_minus
id|vcn
suffix:semicolon
id|comp1
op_assign
id|comp
suffix:semicolon
r_do
(brace
r_int
id|delta
suffix:semicolon
id|io.param
op_assign
id|comp1
suffix:semicolon
id|delta
op_assign
id|s_vcn
op_minus
id|vcn
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
l_int|0
suffix:semicolon
id|l1
op_assign
id|len
op_minus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|l1
OG
l_int|16
op_minus
id|got
)paren
id|l1
op_assign
l_int|16
op_minus
id|got
suffix:semicolon
id|io.size
op_assign
(paren
id|__s64
)paren
id|l1
op_lshift
id|clustersizebits
suffix:semicolon
id|error
op_assign
id|ntfs_getput_clusters
c_func
(paren
id|ino-&gt;vol
comma
id|cl1
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|l1
op_plus
id|delta
op_eq
id|len
)paren
(brace
id|rnum
op_increment
suffix:semicolon
id|rl
op_increment
suffix:semicolon
id|vcn
op_add_assign
id|len
suffix:semicolon
id|cluster
op_assign
id|cl1
op_assign
id|rl-&gt;cluster
suffix:semicolon
id|len
op_assign
id|rl-&gt;len
suffix:semicolon
)brace
id|got
op_add_assign
id|l1
suffix:semicolon
id|comp1
op_add_assign
(paren
id|__s64
)paren
id|l1
op_lshift
id|clustersizebits
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cluster
op_ne
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
op_logical_and
id|got
OL
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Until empty run. */
id|chunk
op_assign
l_int|16
op_lshift
id|clustersizebits
suffix:semicolon
r_if
c_cond
(paren
id|cluster
op_ne
(paren
id|ntfs_cluster_t
)paren
op_minus
l_int|1
op_logical_or
id|got
op_eq
l_int|16
)paren
multiline_comment|/* Uncompressible */
id|comp1
op_assign
id|comp
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|decomp
)paren
(brace
id|decomp
op_assign
id|ntfs_malloc
c_func
(paren
l_int|16
op_lshift
id|clustersizebits
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|decomp
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Make sure there are null bytes after the&n;&t;&t;&t;&t; * last block. */
op_star
(paren
id|ntfs_u32
op_star
)paren
id|comp1
op_assign
l_int|0
suffix:semicolon
id|ntfs_decompress
c_func
(paren
id|decomp
comma
id|comp
comma
id|chunk
)paren
suffix:semicolon
id|comp1
op_assign
id|decomp
suffix:semicolon
)brace
id|offs1
op_assign
id|offset
op_minus
(paren
(paren
id|__s64
)paren
id|s_vcn
op_lshift
id|clustersizebits
)paren
suffix:semicolon
id|chunk2
op_assign
(paren
l_int|16
op_lshift
id|clustersizebits
)paren
op_minus
id|offs1
suffix:semicolon
r_if
c_cond
(paren
id|chunk2
OG
id|l
)paren
id|chunk2
op_assign
id|l
suffix:semicolon
r_if
c_cond
(paren
id|chunk
OG
id|chunk2
)paren
id|chunk
op_assign
id|chunk2
suffix:semicolon
id|dest
op_member_access_from_pointer
id|fn_put
c_func
(paren
id|dest
comma
id|comp1
op_plus
id|offs1
comma
id|chunk
)paren
suffix:semicolon
)brace
id|l
op_sub_assign
id|chunk
suffix:semicolon
id|copied
op_add_assign
id|chunk
suffix:semicolon
id|offset
op_add_assign
id|chunk
suffix:semicolon
id|s_vcn
op_assign
(paren
id|offset
op_rshift
id|clustersizebits
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
r_if
c_cond
(paren
id|l
op_logical_and
id|offset
op_ge
(paren
(paren
id|__s64
)paren
(paren
id|vcn
op_plus
id|len
)paren
op_lshift
id|clustersizebits
)paren
)paren
(brace
id|rnum
op_increment
suffix:semicolon
id|rl
op_increment
suffix:semicolon
id|vcn
op_add_assign
id|len
suffix:semicolon
id|cluster
op_assign
id|rl-&gt;cluster
suffix:semicolon
id|len
op_assign
id|rl-&gt;len
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_if
c_cond
(paren
id|comp
)paren
id|ntfs_free
c_func
(paren
id|comp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|decomp
)paren
id|ntfs_free
c_func
(paren
id|decomp
)paren
suffix:semicolon
id|dest-&gt;size
op_assign
id|copied
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|ntfs_write_compressed
r_int
id|ntfs_write_compressed
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_attribute
op_star
id|attr
comma
id|__s64
id|offset
comma
id|ntfs_io
op_star
id|dest
)paren
(brace
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
eof
