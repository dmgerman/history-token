multiline_comment|/**&n; * attrib.c - NTFS attribute operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; * Copyright (C) 2002 Richard Russon.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/* Temporary helper functions -- might become macros */
multiline_comment|/**&n; * rl_mm - run_list memmove&n; *&n; * It is up to the caller to serialize access to the run list @base.&n; */
DECL|function|rl_mm
r_static
r_inline
r_void
id|rl_mm
c_func
(paren
id|run_list_element
op_star
id|base
comma
r_int
id|dst
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
(paren
id|dst
op_ne
id|src
)paren
op_logical_and
(paren
id|size
OG
l_int|0
)paren
)paren
id|memmove
(paren
id|base
op_plus
id|dst
comma
id|base
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * rl_mc - run_list memory copy&n; *&n; * It is up to the caller to serialize access to the run lists @dstbase and&n; * @srcbase.&n; */
DECL|function|rl_mc
r_static
r_inline
r_void
id|rl_mc
c_func
(paren
id|run_list_element
op_star
id|dstbase
comma
r_int
id|dst
comma
id|run_list_element
op_star
id|srcbase
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
id|memcpy
(paren
id|dstbase
op_plus
id|dst
comma
id|srcbase
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|dstbase
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_realloc - Reallocate memory for run_lists&n; * @orig:  The original memory allocation&n; * @old:   The number of run_lists in the original&n; * @new:   The number of run_lists we need space for&n; *&n; * As the run_lists grow, more memory will be required.  To prevent the&n; * kernel having to allocate and reallocate large numbers of small bits of&n; * memory, this function returns and entire page of memory.&n; *&n; * It is up to the caller to serialize access to the run list @orig.&n; *&n; * N.B.  If the new allocation doesn&squot;t require a different number of pages in&n; *       memory, the function will return the original pointer.&n; *&n; * Return: Pointer  The newly allocated, or recycled,  memory.&n; *&n; * Errors: -ENOMEM, Not enough memory to allocate run list array.&n; *         -EINVAL, Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_realloc
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_realloc
c_func
(paren
id|run_list_element
op_star
id|orig
comma
r_int
id|old
comma
r_int
r_new
)paren
(brace
id|run_list_element
op_star
id|nrl
suffix:semicolon
id|old
op_assign
id|PAGE_ALIGN
(paren
id|old
op_star
r_sizeof
(paren
op_star
id|orig
)paren
)paren
suffix:semicolon
r_new
op_assign
id|PAGE_ALIGN
(paren
r_new
op_star
r_sizeof
(paren
op_star
id|orig
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old
op_eq
r_new
)paren
r_return
id|orig
suffix:semicolon
id|nrl
op_assign
id|ntfs_malloc_nofs
(paren
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nrl
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|orig
)paren
(brace
id|memcpy
(paren
id|nrl
comma
id|orig
comma
id|min
(paren
id|old
comma
r_new
)paren
)paren
suffix:semicolon
id|ntfs_free
(paren
id|orig
)paren
suffix:semicolon
)brace
r_return
id|nrl
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_merge - Join together two run_lists&n; * @one:  The first run_list and destination&n; * @two:  The second run_list&n; *&n; * If possible merge together two run_lists.  For this, their VCNs and LCNs&n; * must be adjacent.&n; *&n; * It is up to the caller to serialize access to the run lists @one and @two.&n; *&n; * Return: TRUE   Success, the run_lists were merged&n; *         FALSE  Failure, the run_lists were not merged&n; */
DECL|function|ntfs_rl_merge
r_static
r_inline
id|BOOL
id|ntfs_rl_merge
c_func
(paren
id|run_list_element
op_star
id|one
comma
id|run_list_element
op_star
id|two
)paren
(brace
id|BUG_ON
(paren
op_logical_neg
id|one
op_logical_or
op_logical_neg
id|two
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|one-&gt;lcn
OL
l_int|0
)paren
op_logical_or
(paren
id|two-&gt;lcn
OL
l_int|0
)paren
)paren
multiline_comment|/* Are we merging holes? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|one-&gt;lcn
op_plus
id|one-&gt;length
)paren
op_ne
id|two-&gt;lcn
)paren
multiline_comment|/* Are the runs contiguous? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|one-&gt;vcn
op_plus
id|one-&gt;length
)paren
op_ne
id|two-&gt;vcn
)paren
multiline_comment|/* Are the runs misaligned? */
r_return
id|FALSE
suffix:semicolon
id|one-&gt;length
op_add_assign
id|two-&gt;length
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_append - Append a run_list after the given element&n; * @orig:   The original run_list to be worked on.&n; * @osize:  The number of elements in @orig (including end marker).&n; * @new:    The run_list to be inserted.&n; * @nsize:  The number of elements in @new (excluding end marker).&n; * @loc:    Append the new run_list after this element in @orig.&n; *&n; * Append a run_list after element @loc in @orig.  Merge the right end of&n; * the new run_list, if necessary.  Adjust the size of the hole before the&n; * appended run_list.&n; *&n; * It is up to the caller to serialize access to the run lists @orig and @new.&n; *&n; * Return: Pointer, The new, combined, run_list&n; *&n; * Errors: -ENOMEM, Not enough memory to allocate run list array.&n; *         -EINVAL, Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_append
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_append
c_func
(paren
id|run_list_element
op_star
id|orig
comma
r_int
id|osize
comma
id|run_list_element
op_star
r_new
comma
r_int
id|nsize
comma
r_int
id|loc
)paren
(brace
id|run_list_element
op_star
id|res
suffix:semicolon
id|BOOL
id|right
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|orig
op_logical_or
op_logical_neg
r_new
)paren
suffix:semicolon
multiline_comment|/* First, merge the right hand end, if necessary. */
id|right
op_assign
id|ntfs_rl_merge
(paren
r_new
op_plus
id|nsize
op_minus
l_int|1
comma
id|orig
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Space required: Orig size + New size, less one if we merged. */
id|res
op_assign
id|ntfs_rl_realloc
(paren
id|orig
comma
id|osize
comma
id|osize
op_plus
id|nsize
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|res
)paren
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* Move the tail of Orig out of the way, then copy in New. */
id|rl_mm
(paren
id|res
comma
id|loc
op_plus
l_int|1
op_plus
id|nsize
comma
id|loc
op_plus
l_int|1
op_plus
id|right
comma
id|osize
op_minus
id|loc
op_minus
l_int|1
op_minus
id|right
)paren
suffix:semicolon
id|rl_mc
(paren
id|res
comma
id|loc
op_plus
l_int|1
comma
r_new
comma
l_int|0
comma
id|nsize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the preceding hole. */
id|res
(braket
id|loc
)braket
dot
id|length
op_assign
id|res
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|res
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|res
(braket
id|loc
op_plus
id|nsize
op_plus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|res
(braket
id|loc
op_plus
id|nsize
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|res
(braket
id|loc
op_plus
id|nsize
)braket
dot
id|vcn
op_plus
id|res
(braket
id|loc
op_plus
id|nsize
)braket
dot
id|length
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_insert - Insert a run_list into another&n; * @orig:   The original run_list to be worked on.&n; * @osize:  The number of elements in @orig (including end marker).&n; * @new:    The run_list to be inserted.&n; * @nsize:  The number of elements in @new (excluding end marker).&n; * @loc:    Insert the new run_list before this element in @orig.&n; *&n; * Insert a run_list before element @loc in @orig.  Merge the left end of&n; * the new run_list, if necessary.  Adjust the size of the hole after the&n; * inserted run_list.&n; *&n; * It is up to the caller to serialize access to the run lists @orig and @new.&n; *&n; * Return: Pointer, The new, combined, run_list&n; *&n; * Errors: -ENOMEM, Not enough memory to allocate run list array.&n; *         -EINVAL, Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_insert
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_insert
c_func
(paren
id|run_list_element
op_star
id|orig
comma
r_int
id|osize
comma
id|run_list_element
op_star
r_new
comma
r_int
id|nsize
comma
r_int
id|loc
)paren
(brace
id|run_list_element
op_star
id|res
suffix:semicolon
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|disc
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Discontinuity */
id|BOOL
id|hole
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Following a hole */
id|BUG_ON
(paren
op_logical_neg
id|orig
op_logical_or
op_logical_neg
r_new
)paren
suffix:semicolon
multiline_comment|/* disc =&gt; Discontinuity between the end of Orig and the start of New.&n;&t; *         This means we might need to insert a hole.&n;&t; * hole =&gt; Orig ends with a hole or an unmapped region which we can&n;&t; *         extend to match the discontinuity. */
r_if
c_cond
(paren
id|loc
op_eq
l_int|0
)paren
(brace
id|disc
op_assign
(paren
r_new
(braket
l_int|0
)braket
dot
id|vcn
OG
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|left
op_assign
id|ntfs_rl_merge
(paren
id|orig
op_plus
id|loc
op_minus
l_int|1
comma
r_new
)paren
suffix:semicolon
id|disc
op_assign
(paren
r_new
(braket
l_int|0
)braket
dot
id|vcn
OG
(paren
id|orig
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|orig
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc
)paren
id|hole
op_assign
(paren
id|orig
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
)paren
suffix:semicolon
)brace
multiline_comment|/* Space required: Orig size + New size, less one if we merged,&n;&t; * plus one if there was a discontinuity, less one for a trailing hole */
id|res
op_assign
id|ntfs_rl_realloc
(paren
id|orig
comma
id|osize
comma
id|osize
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|res
)paren
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* Move the tail of Orig out of the way, then copy in New. */
id|rl_mm
(paren
id|res
comma
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
comma
id|loc
comma
id|osize
op_minus
id|loc
)paren
suffix:semicolon
id|rl_mc
(paren
id|res
comma
id|loc
op_plus
id|disc
op_minus
id|hole
comma
r_new
comma
id|left
comma
id|nsize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* Adjust the VCN of the last run ... */
r_if
c_cond
(paren
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)braket
dot
id|lcn
op_le
id|LCN_HOLE
)paren
(brace
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)braket
dot
id|vcn
op_assign
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
)brace
multiline_comment|/* ... and the length. */
r_if
c_cond
(paren
(paren
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
)paren
op_logical_or
(paren
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)braket
dot
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
)paren
(brace
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)braket
dot
id|length
op_assign
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)braket
dot
id|vcn
suffix:semicolon
)brace
multiline_comment|/* Writing beyond the end of the file and there&squot;s a discontinuity. */
r_if
c_cond
(paren
id|disc
)paren
(brace
r_if
c_cond
(paren
id|hole
)paren
(brace
id|res
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
op_assign
id|res
(braket
id|loc
)braket
dot
id|vcn
op_minus
id|res
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
(brace
id|res
(braket
id|loc
)braket
dot
id|vcn
op_assign
id|res
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|res
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|res
(braket
id|loc
)braket
dot
id|length
op_assign
id|res
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|res
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
)brace
r_else
(brace
id|res
(braket
id|loc
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|res
(braket
id|loc
)braket
dot
id|length
op_assign
id|res
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
id|res
(braket
id|loc
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
)braket
dot
id|vcn
op_assign
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_plus
id|disc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_replace - Overwrite a run_list element with another run_list&n; * @orig:   The original run_list to be worked on.&n; * @osize:  The number of elements in @orig (including end marker).&n; * @new:    The run_list to be inserted.&n; * @nsize:  The number of elements in @new (excluding end marker).&n; * @loc:    Index of run_list @orig to overwrite with @new.&n; *&n; * Replace the run_list at @loc with @new.  Merge the left and right ends of&n; * the inserted run_list, if necessary.&n; *&n; * It is up to the caller to serialize access to the run lists @orig and @new.&n; *&n; * Return: Pointer, The new, combined, run_list&n; *&n; * Errors: -ENOMEM, Not enough memory to allocate run list array.&n; *         -EINVAL, Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_replace
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_replace
c_func
(paren
id|run_list_element
op_star
id|orig
comma
r_int
id|osize
comma
id|run_list_element
op_star
r_new
comma
r_int
id|nsize
comma
r_int
id|loc
)paren
(brace
id|run_list_element
op_star
id|res
suffix:semicolon
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|right
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|orig
op_logical_or
op_logical_neg
r_new
)paren
suffix:semicolon
multiline_comment|/* First, merge the left and right ends, if necessary. */
id|right
op_assign
id|ntfs_rl_merge
(paren
r_new
op_plus
id|nsize
op_minus
l_int|1
comma
id|orig
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
id|left
op_assign
id|ntfs_rl_merge
(paren
id|orig
op_plus
id|loc
op_minus
l_int|1
comma
r_new
)paren
suffix:semicolon
multiline_comment|/* Allocate some space.  We&squot;ll need less if the left, right&n;&t; * or both ends were merged. */
id|res
op_assign
id|ntfs_rl_realloc
(paren
id|orig
comma
id|osize
comma
id|osize
op_plus
id|nsize
op_minus
id|left
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|res
)paren
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* Move the tail of Orig out of the way, then copy in New. */
id|rl_mm
(paren
id|res
comma
id|loc
op_plus
id|nsize
op_minus
id|left
comma
id|loc
op_plus
id|right
op_plus
l_int|1
comma
id|osize
op_minus
id|loc
op_minus
id|right
op_minus
l_int|1
)paren
suffix:semicolon
id|rl_mc
(paren
id|res
comma
id|loc
comma
r_new
comma
id|left
comma
id|nsize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
)braket
dot
id|vcn
op_assign
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|res
(braket
id|loc
op_plus
id|nsize
op_minus
id|left
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_split - Insert a run_list into the centre of a hole&n; * @orig:   The original run_list to be worked on.&n; * @osize:  The number of elements in @orig (including end marker).&n; * @new:    The run_list to be inserted.&n; * @nsize:  The number of elements in @new (excluding end marker).&n; * @loc:    Index of run_list in @orig to split with @new.&n; *&n; * Split the run_list at @loc into two and insert @new.  No merging of&n; * run_lists is necessary.  Adjust the size of the holes either side.&n; *&n; * It is up to the caller to serialize access to the run lists @orig and @new.&n; *&n; * Return: Pointer, The new, combined, run_list&n; *&n; * Errors: -ENOMEM, Not enough memory to allocate run list array.&n; *         -EINVAL, Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_split
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_split
c_func
(paren
id|run_list_element
op_star
id|orig
comma
r_int
id|osize
comma
id|run_list_element
op_star
r_new
comma
r_int
id|nsize
comma
r_int
id|loc
)paren
(brace
id|run_list_element
op_star
id|res
suffix:semicolon
id|BUG_ON
(paren
op_logical_neg
id|orig
op_logical_or
op_logical_neg
r_new
)paren
suffix:semicolon
multiline_comment|/* Space required: Orig size + New size + One new hole. */
id|res
op_assign
id|ntfs_rl_realloc
(paren
id|orig
comma
id|osize
comma
id|osize
op_plus
id|nsize
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
(paren
id|res
)paren
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/* Move the tail of Orig out of the way, then copy in New. */
id|rl_mm
(paren
id|res
comma
id|loc
op_plus
l_int|1
op_plus
id|nsize
comma
id|loc
comma
id|osize
op_minus
id|loc
)paren
suffix:semicolon
id|rl_mc
(paren
id|res
comma
id|loc
op_plus
l_int|1
comma
r_new
comma
l_int|0
comma
id|nsize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the holes either size of New. */
id|res
(braket
id|loc
)braket
dot
id|length
op_assign
id|res
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|res
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
id|res
(braket
id|loc
op_plus
id|nsize
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|res
(braket
id|loc
op_plus
id|nsize
)braket
dot
id|vcn
op_plus
id|res
(braket
id|loc
op_plus
id|nsize
)braket
dot
id|length
suffix:semicolon
id|res
(braket
id|loc
op_plus
id|nsize
op_plus
l_int|1
)braket
dot
id|length
op_assign
id|res
(braket
id|loc
op_plus
id|nsize
op_plus
l_int|2
)braket
dot
id|vcn
op_minus
id|res
(braket
id|loc
op_plus
id|nsize
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/**&n; * merge_run_lists - merge two run_lists into one&n; * @drl:  The original run_list.&n; * @srl:  The new run_list to be merge into @drl.&n; *&n; * First we sanity check the two run_lists to make sure that they are sensible&n; * and can be merged.  The @srl run_list must be either after the @drl run_list&n; * or completely within a hole in @drl.&n; *&n; * It is up to the caller to serialize access to the run lists @drl and @srl.&n; *&n; * Merging of run lists is necessary in two cases:&n; *   1. When attribute lists are used and a further extent is being mapped.&n; *   2. When new clusters are allocated to fill a hole or extend a file.&n; *&n; * There are four possible ways @srl can be merged.  It can be inserted at&n; * the beginning of a hole; split the hole in two; appended at the end of&n; * a hole; replace the whole hole.  It can also be appended to the end of&n; * the run_list, which is just a variant of the insert case.&n; *&n; * N.B.  Either, or both, of the input pointers may be freed if the function&n; *       is successful.  Only the returned pointer may be used.&n; *&n; *       If the function fails, neither of the input run_lists may be safe.&n; *&n; * Return: Pointer, The resultant merged run_list.&n; *&n; * Errors: -ENOMEM, Not enough memory to allocate run list array.&n; *         -EINVAL, Invalid parameters were passed in.&n; *         -ERANGE, The run_lists overlap and cannot be merged.&n; */
DECL|function|merge_run_lists
id|run_list_element
op_star
id|merge_run_lists
c_func
(paren
id|run_list_element
op_star
id|drl
comma
id|run_list_element
op_star
id|srl
)paren
(brace
id|run_list_element
op_star
id|nrl
suffix:semicolon
multiline_comment|/* New run list. */
r_int
id|di
comma
id|si
suffix:semicolon
multiline_comment|/* Current index into @[ds]rl. */
r_int
id|sstart
suffix:semicolon
multiline_comment|/* First index with lcn &gt; LCN_RL_NOT_MAPPED. */
r_int
id|dins
suffix:semicolon
multiline_comment|/* Index into @drl at which to insert @srl. */
r_int
id|dend
comma
id|send
suffix:semicolon
multiline_comment|/* Last index into @[ds]rl. */
r_int
id|dfinal
comma
id|sfinal
suffix:semicolon
multiline_comment|/* The last index into @[ds]rl with&n;&t;&t;&t;&t;   lcn &gt;= LCN_HOLE. */
r_int
id|marker
op_assign
l_int|0
suffix:semicolon
macro_line|#if 1
id|ntfs_debug
(paren
l_string|&quot;dst:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
(paren
id|drl
)paren
suffix:semicolon
id|ntfs_debug
(paren
l_string|&quot;src:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
(paren
id|srl
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for silly calling... */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|srl
)paren
)paren
r_return
id|drl
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
(paren
id|IS_ERR
(paren
id|srl
)paren
op_logical_or
id|IS_ERR
(paren
id|drl
)paren
)paren
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* Check for the case where the first mapping is being done now. */
r_if
c_cond
(paren
id|unlikely
(paren
op_logical_neg
id|drl
)paren
)paren
(brace
id|nrl
op_assign
id|srl
suffix:semicolon
multiline_comment|/* Complete the source run list if necessary. */
r_if
c_cond
(paren
id|unlikely
(paren
id|srl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
(brace
multiline_comment|/* Scan to the end of the source run list. */
r_for
c_loop
(paren
id|send
op_assign
l_int|0
suffix:semicolon
id|likely
(paren
id|srl
(braket
id|send
)braket
dot
id|length
)paren
suffix:semicolon
id|send
op_increment
)paren
suffix:semicolon
id|nrl
op_assign
id|ntfs_rl_realloc
(paren
id|srl
comma
id|send
comma
id|send
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nrl
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|rl_mm
(paren
id|nrl
comma
l_int|1
comma
l_int|0
comma
id|send
)paren
suffix:semicolon
id|nrl
(braket
l_int|0
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Add start element. */
id|nrl
(braket
l_int|0
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|nrl
(braket
l_int|0
)braket
dot
id|length
op_assign
id|nrl
(braket
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
r_goto
id|finished
suffix:semicolon
)brace
id|si
op_assign
id|di
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip the unmapped start element(s) in each run_list if present. */
r_while
c_loop
(paren
id|srl
(braket
id|si
)braket
dot
id|length
op_logical_and
id|srl
(braket
id|si
)braket
dot
id|lcn
OL
(paren
id|LCN
)paren
id|LCN_HOLE
)paren
id|si
op_increment
suffix:semicolon
multiline_comment|/* Can&squot;t have an entirely unmapped srl run_list. */
id|BUG_ON
(paren
op_logical_neg
id|srl
(braket
id|si
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/* Record the starting points. */
id|sstart
op_assign
id|si
suffix:semicolon
multiline_comment|/*&n;&t; * Skip forward in @drl until we reach the position where @srl needs to&n;&t; * be inserted. If we reach the end of @drl, @srl just needs to be&n;&t; * appended to @drl.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|drl
(braket
id|di
)braket
dot
id|length
suffix:semicolon
id|di
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|di
)braket
dot
id|length
)paren
OG
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
r_break
suffix:semicolon
)brace
id|dins
op_assign
id|di
suffix:semicolon
multiline_comment|/* Sanity check for illegal overlaps. */
r_if
c_cond
(paren
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|si
)braket
dot
id|vcn
)paren
op_logical_and
(paren
id|drl
(braket
id|di
)braket
dot
id|lcn
op_ge
l_int|0
)paren
op_logical_and
(paren
id|srl
(braket
id|si
)braket
dot
id|lcn
op_ge
l_int|0
)paren
)paren
(brace
id|ntfs_error
(paren
l_int|NULL
comma
l_string|&quot;Run lists overlap. Cannot merge! Returning &quot;
l_string|&quot;ERANGE.&quot;
)paren
suffix:semicolon
id|nrl
op_assign
id|ERR_PTR
(paren
op_minus
id|ERANGE
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* Scan to the end of both run lists in order to know their sizes. */
r_for
c_loop
(paren
id|send
op_assign
id|si
suffix:semicolon
id|srl
(braket
id|send
)braket
dot
id|length
suffix:semicolon
id|send
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dend
op_assign
id|di
suffix:semicolon
id|drl
(braket
id|dend
)braket
dot
id|length
suffix:semicolon
id|dend
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srl
(braket
id|send
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
(brace
id|marker
op_assign
id|send
suffix:semicolon
)brace
multiline_comment|/* Scan to the last element with lcn &gt;= LCN_HOLE. */
r_for
c_loop
(paren
id|sfinal
op_assign
id|send
suffix:semicolon
id|sfinal
op_ge
l_int|0
op_logical_and
id|srl
(braket
id|sfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|sfinal
op_decrement
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dfinal
op_assign
id|dend
suffix:semicolon
id|dfinal
op_ge
l_int|0
op_logical_and
id|drl
(braket
id|dfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|dfinal
op_decrement
)paren
suffix:semicolon
(brace
id|BOOL
id|start
suffix:semicolon
id|BOOL
id|finish
suffix:semicolon
r_int
id|ds
op_assign
id|dend
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Number of elements in drl &amp; srl */
r_int
id|ss
op_assign
id|sfinal
op_minus
id|sstart
op_plus
l_int|1
suffix:semicolon
id|start
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
OL
id|LCN_RL_NOT_MAPPED
)paren
op_logical_or
multiline_comment|/* End of file   */
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
)paren
suffix:semicolon
multiline_comment|/* Start of hole */
id|finish
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
op_ge
id|LCN_RL_NOT_MAPPED
)paren
op_logical_and
multiline_comment|/* End of file   */
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
)paren
op_le
multiline_comment|/* End of hole   */
(paren
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|length
)paren
)paren
)paren
suffix:semicolon
singleline_comment|//srl[send-1].vcn));
multiline_comment|/* Or we&squot;ll lose an end marker */
r_if
c_cond
(paren
id|start
op_logical_and
id|finish
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|length
op_eq
l_int|0
)paren
)paren
id|ss
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|marker
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
OG
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
)paren
)paren
id|finish
op_assign
id|FALSE
suffix:semicolon
macro_line|#if 0
id|ntfs_debug
c_func
(paren
l_string|&quot;dfinal = %i, dend = %i&quot;
comma
id|dfinal
comma
id|dend
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sstart = %i, sfinal = %i, send = %i&quot;
comma
id|sstart
comma
id|sfinal
comma
id|send
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;start = %i, finish = %i&quot;
comma
id|start
comma
id|finish
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;ds = %i, ss = %i, dins = %i&quot;
comma
id|ds
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|start
)paren
r_if
c_cond
(paren
id|finish
)paren
id|nrl
op_assign
id|ntfs_rl_replace
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|nrl
op_assign
id|ntfs_rl_insert
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|finish
)paren
id|nrl
op_assign
id|ntfs_rl_append
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|nrl
op_assign
id|ntfs_rl_split
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_if
c_cond
(paren
id|marker
)paren
(brace
r_for
c_loop
(paren
id|ds
op_assign
l_int|0
suffix:semicolon
id|nrl
(braket
id|ds
)braket
dot
id|lcn
suffix:semicolon
id|ds
op_increment
)paren
suffix:semicolon
id|nrl
op_assign
id|ntfs_rl_insert
(paren
id|nrl
comma
id|ds
op_plus
l_int|1
comma
id|srl
op_plus
id|marker
comma
l_int|1
comma
id|ds
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|likely
(paren
op_logical_neg
id|IS_ERR
(paren
id|nrl
)paren
)paren
)paren
(brace
multiline_comment|/* The merge was completed successfully. */
id|finished
suffix:colon
r_if
c_cond
(paren
id|nrl
op_ne
id|srl
)paren
id|ntfs_free
(paren
id|srl
)paren
suffix:semicolon
multiline_comment|/*ntfs_debug (&quot;Done.&quot;);*/
multiline_comment|/*ntfs_debug (&quot;Merged run list:&quot;);*/
macro_line|#if 1
id|ntfs_debug
(paren
l_string|&quot;res:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
(paren
id|nrl
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|ntfs_error
(paren
l_int|NULL
comma
l_string|&quot;Merge failed, returning error code %ld.&quot;
comma
op_minus
id|PTR_ERR
(paren
id|nrl
)paren
)paren
suffix:semicolon
)brace
m_exit
suffix:colon
r_return
id|nrl
suffix:semicolon
)brace
multiline_comment|/**&n; * decompress_mapping_pairs - convert mapping pairs array to run list&n; * @vol:&t;ntfs volume on which the attribute resides&n; * @attr:&t;attribute record whose mapping pairs array to decompress&n; * @run_list:&t;optional run list in which to insert @attr&squot;s run list&n; *&n; * Decompress the attribute @attr&squot;s mapping pairs array into a run_list and&n; * return the run list or -errno on error. If @run_list is not NULL then&n; * the mapping pairs array of @attr is decompressed and the run list inserted&n; * into the appropriate place in @run_list. If this is the case and the&n; * function returns success, the original pointer passed into @run_list is no&n; * longer valid.&n; *&n; * It is up to the caller to serialize access to the run list @old_rl.&n; *&n; * Check the return value for error with IS_ERR(ret_val). If this is FALSE,&n; * the function was successful, the return value is the new run list, and if&n; * an existing run list pointer was passed in, this is no longer valid.&n; * If IS_ERR(ret_val) returns true, there was an error, the return value is not&n; * a run_list pointer and the existing run list pointer if one was passed in&n; * has not been touched. In this case use PTR_ERR(ret_val) to obtain the error&n; * code. Following error codes are defined:&n; * &t;-ENOMEM&t;&t;Not enough memory to allocate run list array.&n; * &t;-EIO&t;&t;Corrupt run list.&n; * &t;-EINVAL&t;&t;Invalid parameters were passed in.&n; * &t;-ERANGE&t;&t;The two run lists overlap.&n; *&n; * FIXME: For now we take the conceptionally simplest approach of creating the&n; * new run list disregarding the already existing one and then splicing the&n; * two into one if that is possible (we check for overlap and discard the new&n; * run list if overlap present and return error).&n; */
DECL|function|decompress_mapping_pairs
id|run_list_element
op_star
id|decompress_mapping_pairs
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|ATTR_RECORD
op_star
id|attr
comma
id|run_list_element
op_star
id|old_rl
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
multiline_comment|/* Current vcn. */
id|LCN
id|lcn
suffix:semicolon
multiline_comment|/* Current lcn. */
id|s64
id|deltaxcn
suffix:semicolon
multiline_comment|/* Change in [vl]cn. */
id|run_list_element
op_star
id|rl
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The output run_list. */
id|run_list_element
op_star
id|rl2
suffix:semicolon
multiline_comment|/* Temporary run_list. */
id|u8
op_star
id|buf
suffix:semicolon
multiline_comment|/* Current position in mapping pairs array. */
id|u8
op_star
id|attr_end
suffix:semicolon
multiline_comment|/* End of attribute. */
r_int
id|rlsize
suffix:semicolon
multiline_comment|/* Size of run_list buffer. */
r_int
id|rlpos
suffix:semicolon
multiline_comment|/* Current run_list position. */
id|u8
id|b
suffix:semicolon
multiline_comment|/* Current byte offset in buf. */
macro_line|#ifdef DEBUG
multiline_comment|/* Make sure attr exists and is non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr
op_logical_or
op_logical_neg
id|attr-&gt;non_resident
op_logical_or
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
OL
(paren
id|VCN
)paren
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid arguments.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Start at vcn = lowest_vcn and lcn 0. */
id|vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
suffix:semicolon
id|lcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get start of the mapping pairs array. */
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le16_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|mapping_pairs_offset
)paren
)paren
suffix:semicolon
id|attr_end
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
template_param
id|attr_end
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* Current position in run_list array. */
id|rlpos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate first page. */
id|rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* Current run_list buffer size in bytes. */
id|rlsize
op_assign
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Insert unmapped starting element if necessary. */
r_if
c_cond
(paren
id|vcn
)paren
(brace
id|rl-&gt;vcn
op_assign
(paren
id|VCN
)paren
l_int|0
suffix:semicolon
id|rl-&gt;lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rl-&gt;length
op_assign
id|vcn
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buf
OL
id|attr_end
op_logical_and
op_star
id|buf
)paren
(brace
multiline_comment|/*&n;&t;&t; * Allocate more memory if needed, including space for the&n;&t;&t; * not-mapped and terminator elements. ntfs_malloc_nofs()&n;&t;&t; * operates on whole pages only.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|rlpos
op_plus
l_int|3
)paren
op_star
r_sizeof
(paren
op_star
id|old_rl
)paren
)paren
OG
id|rlsize
)paren
(brace
id|rl2
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_plus
(paren
r_int
)paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl2
)paren
)paren
(brace
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memmove
c_func
(paren
id|rl2
comma
id|rl
comma
id|rlsize
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|rl
op_assign
id|rl2
suffix:semicolon
id|rlsize
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* Enter the current vcn into the current run_list element. */
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|vcn
op_assign
id|vcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the change in vcn, i.e. the run length in clusters.&n;&t;&t; * Doing it this way ensures that we signextend negative values.&n;&t;&t; * A negative run length doesn&squot;t make any sense, but hey, I&n;&t;&t; * didn&squot;t make up the NTFS specs and Windows NT4 treats the run&n;&t;&t; * length as a signed value so that&squot;s how it is...&n;&t;&t; */
id|b
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|b
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The length entry is compulsory. */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Missing length entry in mapping &quot;
l_string|&quot;pairs array.&quot;
)paren
suffix:semicolon
id|deltaxcn
op_assign
(paren
id|s64
)paren
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Assume a negative length to indicate data corruption and&n;&t;&t; * hence clean-up and return NULL.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OL
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid length in mapping pairs &quot;
l_string|&quot;array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Enter the current run length into the current run_list&n;&t;&t; * element.&n;&t;&t; */
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|length
op_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/* Increment the current vcn by the current run length. */
id|vcn
op_add_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There might be no lcn change at all, as is the case for&n;&t;&t; * sparse clusters on NTFS 3.0+, in which case we set the lcn&n;&t;&t; * to LCN_HOLE.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|buf
op_amp
l_int|0xf0
)paren
)paren
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_HOLE
suffix:semicolon
r_else
(brace
multiline_comment|/* Get the lcn change which really can be negative. */
id|u8
id|b2
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
id|b
op_assign
id|b2
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
OG
id|b2
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
multiline_comment|/* Change the current lcn to it&squot;s new value. */
id|lcn
op_add_assign
id|deltaxcn
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t;&t;&t; * On NTFS 1.2-, apparently can have lcn == -1 to&n;&t;&t;&t; * indicate a hole. But we haven&squot;t verified ourselves&n;&t;&t;&t; * whether it is really the lcn or the deltaxcn that is&n;&t;&t;&t; * -1. So if either is found give us a message so we&n;&t;&t;&t; * can investigate it further!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn delta == -1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn == -1&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Check lcn is not below -1. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
OL
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid LCN &lt; -1 in &quot;
l_string|&quot;mapping pairs array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Enter the current lcn into the run_list element. */
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|lcn
op_assign
id|lcn
suffix:semicolon
)brace
multiline_comment|/* Get to the next run_list element. */
id|rlpos
op_increment
suffix:semicolon
multiline_comment|/* Increment the buffer position to the next mapping pair. */
id|buf
op_add_assign
(paren
op_star
id|buf
op_amp
l_int|0xf
)paren
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_ge
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
multiline_comment|/*&n;&t; * If there is a highest_vcn specified, it must be equal to the final&n;&t; * vcn in the run list - 1, or something has gone badly wrong.&n;&t; */
id|deltaxcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|highest_vcn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_logical_and
id|vcn
op_minus
l_int|1
op_ne
id|deltaxcn
)paren
)paren
(brace
id|mpa_err
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt mapping pairs array in &quot;
l_string|&quot;non-resident attribute.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Setup not mapped run_list element if this is the base extent. */
r_if
c_cond
(paren
op_logical_neg
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|lowest_vcn
)paren
)paren
(brace
id|VCN
id|max_cluster
suffix:semicolon
id|max_cluster
op_assign
(paren
id|sle64_to_cpu
c_func
(paren
id|attr
op_member_access_from_pointer
id|_ANR
c_func
(paren
id|allocated_size
)paren
)paren
op_plus
id|vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there is a difference between the highest_vcn and the&n;&t;&t; * highest cluster, the run list is either corrupt or, more&n;&t;&t; * likely, there are more extents following this one.&n;&t;&t; */
r_if
c_cond
(paren
id|deltaxcn
OL
op_decrement
id|max_cluster
)paren
(brace
singleline_comment|//RAR ntfs_debug(&quot;More extents to follow; deltaxcn = 0x%Lx, &quot;
singleline_comment|//RAR &quot;max_cluster = 0x%Lx&quot;,
singleline_comment|//RAR (long long)deltaxcn,
singleline_comment|//RAR (long long)max_cluster);
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|vcn
op_assign
id|vcn
suffix:semicolon
id|vcn
op_add_assign
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|length
op_assign
id|max_cluster
op_minus
id|deltaxcn
suffix:semicolon
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OG
id|max_cluster
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute. deltaxcn = &quot;
l_string|&quot;0x%Lx, max_cluster = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|deltaxcn
comma
(paren
r_int
r_int
)paren
id|max_cluster
)paren
suffix:semicolon
r_goto
id|mpa_err
suffix:semicolon
)brace
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
)brace
r_else
multiline_comment|/* Not the base extent. There may be more extents to follow. */
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Setup terminating run_list element. */
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|vcn
op_assign
id|vcn
suffix:semicolon
(paren
id|rl
op_plus
id|rlpos
)paren
op_member_access_from_pointer
id|length
op_assign
(paren
id|s64
)paren
l_int|0
suffix:semicolon
singleline_comment|//RAR ntfs_debug(&quot;Mapping pairs array successfully decompressed.&quot;);
singleline_comment|//RAR ntfs_debug_dump_runlist(rl);
multiline_comment|/* If no existing run list was specified, we are done. */
r_if
c_cond
(paren
op_logical_neg
id|old_rl
)paren
r_return
id|rl
suffix:semicolon
multiline_comment|/* Now combine the new and old run lists checking for overlaps. */
id|rl2
op_assign
id|merge_run_lists
c_func
(paren
id|old_rl
comma
id|rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|rl2
)paren
)paren
)paren
r_return
id|rl2
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to merge run lists.&quot;
)paren
suffix:semicolon
r_return
id|rl2
suffix:semicolon
id|io_error
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * map_run_list - map (a part of) a run list of an ntfs inode&n; * @ni:&t;&t;ntfs inode for which to map (part of) a run list &n; * @vcn:&t;map run list part containing this vcn&n; *&n; * Map the part of a run list containing the @vcn of an the ntfs inode @ni.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|map_run_list
r_int
id|map_run_list
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|VCN
id|vcn
)paren
(brace
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
r_const
id|uchar_t
op_star
id|name
suffix:semicolon
id|u32
id|name_len
suffix:semicolon
id|ATTR_TYPES
id|at
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping run list part containing vcn 0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
)paren
suffix:semicolon
multiline_comment|/* Map, pin and lock the mft record for reading. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
id|err
op_assign
id|get_attr_search_ctx
c_func
(paren
op_amp
id|ctx
comma
id|ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|unm_err_out
suffix:semicolon
multiline_comment|/* The attribute type is determined from the inode type. */
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_mode
)paren
)paren
(brace
id|at
op_assign
id|AT_INDEX_ALLOCATION
suffix:semicolon
id|name
op_assign
id|I30
suffix:semicolon
id|name_len
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|at
op_assign
id|AT_DATA
suffix:semicolon
id|name
op_assign
l_int|NULL
suffix:semicolon
id|name_len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find the attribute in the mft record. */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|at
comma
id|name
comma
id|name_len
comma
id|CASE_SENSITIVE
comma
id|vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Lock the run list. */
id|write_lock
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* Make sure someone else didn&squot;t do the work while we were spinning. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|vcn_to_lcn
c_func
(paren
id|ni-&gt;run_list.rl
comma
id|vcn
)paren
op_le
id|LCN_RL_NOT_MAPPED
)paren
)paren
(brace
id|run_list_element
op_star
id|rl
suffix:semicolon
multiline_comment|/* Decode the run list. */
id|rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|ni-&gt;vol
comma
id|ctx-&gt;attr
comma
id|ni-&gt;run_list.rl
)paren
suffix:semicolon
multiline_comment|/* Flag any errors or set the run list if successful. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
)paren
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
r_else
id|ni-&gt;run_list.rl
op_assign
id|rl
suffix:semicolon
)brace
multiline_comment|/* Unlock the run list. */
id|write_unlock
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
multiline_comment|/* Unlock, unpin and release the mft record. */
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
multiline_comment|/* If an error occured, return it. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * vcn_to_lcn - convert a vcn into a lcn given a run list&n; * @rl:&t;&t;run list to use for conversion&n; * @vcn:&t;vcn to convert&n; *&n; * Convert the virtual cluster number @vcn of an attribute into a logical&n; * cluster number (lcn) of a device using the run list @rl to map vcns to their&n; * corresponding lcns.&n; *&n; * It is up to the caller to serialize access to the run list @rl.&n; *&n; * Since lcns must be &gt;= 0, we use negative return values with special meaning:&n; *&n; * Return value&t;&t;&t;Meaning / Description&n; * ==================================================&n; *  -1 = LCN_HOLE&t;&t;Hole / not allocated on disk.&n; *  -2 = LCN_RL_NOT_MAPPED&t;This is part of the run list which has not been&n; *&t;&t;&t;&t;inserted into the run list yet.&n; *  -3 = LCN_ENOENT&t;&t;There is no such vcn in the data attribute.&n; *  -4 = LCN_EINVAL&t;&t;Input parameter error (if debug enabled).&n; */
DECL|function|vcn_to_lcn
id|LCN
id|vcn_to_lcn
c_func
(paren
r_const
id|run_list_element
op_star
id|rl
comma
r_const
id|VCN
id|vcn
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|vcn
OL
(paren
id|VCN
)paren
l_int|0
)paren
r_return
(paren
id|LCN
)paren
id|LCN_EINVAL
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If rl is NULL, assume that we have found an unmapped run list. The&n;&t; * caller can then attempt to map it and fail appropriately if&n;&t; * necessary.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Catch out of lower bounds vcn. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
r_return
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
id|i
op_plus
l_int|1
)braket
dot
id|vcn
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
op_ge
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
op_plus
(paren
id|vcn
op_minus
id|rl
(braket
id|i
)braket
dot
id|vcn
)paren
suffix:semicolon
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The terminator element is setup to the correct value, i.e. one of&n;&t; * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
OL
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
multiline_comment|/* Just in case... We could replace this with BUG() some day. */
r_return
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
)brace
multiline_comment|/**&n; * find_attr - find (next) attribute in mft record&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * You shouldn&squot;t need to call this function directly. Use lookup_attr() instead.&n; *&n; * find_attr() takes a search context @ctx as parameter and searches the mft&n; * record specified by @ctx-&gt;mrec, beginning at @ctx-&gt;attr, for an attribute of&n; * @type, optionally @name and @val. If found, find_attr() returns TRUE and&n; * @ctx-&gt;attr will point to the found attribute. If not found, find_attr()&n; * returns FALSE and @ctx-&gt;attr is undefined (i.e. do not rely on it not&n; * changing).&n; *&n; * If @ctx-&gt;is_first is TRUE, the search begins with @ctx-&gt;attr itself. If it&n; * is FALSE, the search begins after @ctx-&gt;attr.&n; *&n; * If @ic is IGNORE_CASE, the @name comparisson is not case sensitive and&n; * @ctx-&gt;ntfs_ino must be set to the ntfs inode to which the mft record&n; * @ctx-&gt;mrec belongs. This is so we can get at the ntfs volume and hence at&n; * the upcase table. If @ic is CASE_SENSITIVE, the comparison is case&n; * sensitive. When @name is present, @name_len is the @name length in Unicode&n; * characters.&n; *&n; * If @name is not present (NULL), we assume that the unnamed attribute is&n; * being searched for.&n; *&n; * Finally, the resident attribute value @val is looked for, if present. If @val&n; * is not present (NULL), @val_len is ignored.&n; *&n; * find_attr() only searches the specified mft record and it ignores the&n; * presence of an attribute list attribute (unless it is the one being searched&n; * for, obviously). If you need to take attribute lists into consideration, use&n; * lookup_attr() instead (see below). This also means that you cannot use&n; * find_attr() to search for extent records of non-resident attributes, as&n; * extents with lowest_vcn != 0 are usually described by the attribute list&n; * attribute only. - Note that it is possible that the first extent is only in&n; * the attribute list while the last extent is in the base mft record, so don&squot;t&n; * rely on being able to find the first extent in the base mft record.&n; *&n; * Warning: Never use @val when looking for attribute types which can be&n; *&t;    non-resident as this most likely will result in a crash!&n; */
DECL|function|find_attr
id|BOOL
id|find_attr
c_func
(paren
r_const
id|ATTR_TYPES
id|type
comma
r_const
id|uchar_t
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|attr_search_context
op_star
id|ctx
)paren
(brace
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|uchar_t
op_star
id|upcase
suffix:semicolon
id|u32
id|upcase_len
suffix:semicolon
r_if
c_cond
(paren
id|ic
op_eq
id|IGNORE_CASE
)paren
(brace
id|vol
op_assign
id|ctx-&gt;ntfs_ino-&gt;vol
suffix:semicolon
id|upcase
op_assign
id|vol-&gt;upcase
suffix:semicolon
id|upcase_len
op_assign
id|vol-&gt;upcase_len
suffix:semicolon
)brace
r_else
(brace
id|vol
op_assign
l_int|NULL
suffix:semicolon
id|upcase
op_assign
l_int|NULL
suffix:semicolon
id|upcase_len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Iterate over attributes in mft record starting at @ctx-&gt;attr, or the&n;&t; * attribute following that, if @ctx-&gt;is_first is TRUE.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;is_first
)paren
(brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;length
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|a
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_allocated
)paren
)paren
r_break
suffix:semicolon
id|ctx-&gt;attr
op_assign
id|a
suffix:semicolon
multiline_comment|/* We catch $END with this more general check, too... */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|a-&gt;type
)paren
OG
id|le32_to_cpu
c_func
(paren
id|type
)paren
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|a-&gt;length
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
op_ne
id|type
)paren
r_continue
suffix:semicolon
multiline_comment|/* &n;&t;&t; * If @name is present, compare the two names. If @name is&n;&t;&t; * missing, assume we want an unnamed attribute.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
multiline_comment|/* The search failed if the found attribute is named. */
r_if
c_cond
(paren
id|a-&gt;name_length
)paren
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
id|ic
comma
id|upcase
comma
id|upcase_len
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|upcase
comma
id|upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @name collates before a-&gt;name, there is no&n;&t;&t;&t; * matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* If the strings are not equal, continue search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|upcase
comma
id|upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The names match or @name not present and attribute is&n;&t;&t; * unnamed. If no @val specified, we have found the attribute&n;&t;&t; * and are done.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
r_return
id|TRUE
suffix:semicolon
multiline_comment|/* @val is present; compare values. */
r_else
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|memcmp
c_func
(paren
id|val
comma
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|min
c_func
(paren
id|val_len
comma
id|le32_to_cpu
c_func
(paren
id|a
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @val collates before the current attribute&squot;s&n;&t;&t;&t; * value, there is no matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
r_register
id|u32
id|avl
suffix:semicolon
id|avl
op_assign
id|le32_to_cpu
c_func
(paren
id|a
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val_len
op_eq
id|avl
)paren
r_return
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|val_len
OL
id|avl
)paren
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
)brace
)brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Inode is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * load_attribute_list - load an attribute list into memory&n; * @vol:&t;ntfs volume from which to read&n; * @rl:&t;&t;run list of the attribute list&n; * @al:&t;&t;destination buffer&n; * @size:&t;size of the destination buffer in bytes&n; *&n; * Walk the run list @rl and load all clusters from it copying them into the&n; * linear buffer @al. The maximum number of bytes copied to @al is @size bytes.&n; * Note, @size does not need to be a multiple of the cluster size.&n; *&n; * It is up to the caller to serialize access to the run list @rl.&n; *&n; * Return 0 on success or -errno on error.&n; */
DECL|function|load_attribute_list
r_int
id|load_attribute_list
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|run_list_element
op_star
id|rl
comma
id|u8
op_star
id|al
comma
r_const
id|s64
id|size
)paren
(brace
id|LCN
id|lcn
suffix:semicolon
id|u8
op_star
id|al_end
op_assign
id|al
op_plus
id|size
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_int
r_int
id|block_size
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
r_int
r_int
id|block
comma
id|max_block
suffix:semicolon
r_int
r_char
id|block_size_bits
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|vol
op_logical_or
op_logical_neg
id|rl
op_logical_or
op_logical_neg
id|al
op_logical_or
id|size
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read all clusters specified by the run list one run at a time. */
r_while
c_loop
(paren
id|rl-&gt;length
)paren
(brace
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|rl
comma
id|rl-&gt;vcn
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading vcn = 0x%Lx, lcn = 0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|rl-&gt;vcn
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
multiline_comment|/* The attribute list cannot be sparse. */
r_if
c_cond
(paren
id|lcn
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;vcn_to_lcn() failed. Cannot read &quot;
l_string|&quot;attribute list.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
suffix:semicolon
)brace
id|block
op_assign
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
suffix:semicolon
multiline_comment|/* Read the run from device in chunks of block_size bytes. */
id|max_block
op_assign
id|block
op_plus
(paren
id|rl-&gt;length
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;max_block = 0x%lx.&quot;
comma
id|max_block
)paren
suffix:semicolon
r_do
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading block = 0x%lx.&quot;
comma
id|block
)paren
suffix:semicolon
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|bread_err
suffix:semicolon
r_if
c_cond
(paren
id|al
op_plus
id|block_size
OG
id|al_end
)paren
r_goto
id|do_partial
suffix:semicolon
id|memcpy
c_func
(paren
id|al
comma
id|bh-&gt;b_data
comma
id|block_size
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|al
op_add_assign
id|block_size
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|block
OL
id|max_block
)paren
suffix:semicolon
id|rl
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|do_partial
suffix:colon
r_if
c_cond
(paren
id|al
OL
id|al_end
)paren
(brace
multiline_comment|/* Partial block. */
id|memcpy
c_func
(paren
id|al
comma
id|bh-&gt;b_data
comma
id|al_end
op_minus
id|al
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* If the final lcn is partial all is fine. */
r_if
c_cond
(paren
(paren
(paren
id|s64
)paren
(paren
id|block
op_minus
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
)paren
)paren
op_lshift
id|block_size_bits
op_rshift
id|vol-&gt;cluster_size_bits
)paren
op_eq
id|rl-&gt;length
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rl
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|length
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rl
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
op_logical_and
op_logical_neg
(paren
id|rl
op_plus
l_int|2
)paren
op_member_access_from_pointer
id|length
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Real overflow! */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list buffer overflow. Read attribute list &quot;
l_string|&quot;is truncated.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
id|bread_err
suffix:colon
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;sb_bread() failed. Cannot read attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/**&n; * find_external_attr - find an attribute in the attribute list of an ntfs inode&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @lowest_vcn:&t;lowest vcn to find (optional, non-resident attributes only)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * You shouldn&squot;t need to call this function directly. Use lookup_attr() instead.&n; *&n; * Find an attribute by searching the attribute list for the corresponding&n; * attribute list entry. Having found the entry, map the mft record for read&n; * if the attribute is in a different mft record/inode, find_attr the attribute&n; * in there and return it.&n; *&n; * On first search @ctx-&gt;ntfs_ino must be the base mft record and @ctx must&n; * have been obtained from a call to get_attr_search_ctx(). On subsequent calls&n; * @ctx-&gt;ntfs_ino can be any extent inode, too (@ctx-&gt;base_ntfs_ino is then the&n; * base inode).&n; *&n; * After finishing with the attribute/mft record you need to call&n; * release_attr_search_ctx() to cleanup the search context (unmapping any&n; * mapped inodes, etc).&n; *&n; * Return TRUE if the search was successful and FALSE if not. When TRUE,&n; * @ctx-&gt;attr is the found attribute and it is in mft record @ctx-&gt;mrec. When&n; * FALSE, @ctx-&gt;attr is the attribute which collates just after the attribute&n; * being searched for in the base ntfs inode, i.e. if one wants to add the&n; * attribute to the mft record this is the correct place to insert it into&n; * and if there is not enough space, the attribute should be placed in an&n; * extent mft record.&n; */
DECL|function|find_external_attr
r_static
id|BOOL
id|find_external_attr
c_func
(paren
r_const
id|ATTR_TYPES
id|type
comma
r_const
id|uchar_t
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|VCN
id|lowest_vcn
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|attr_search_context
op_star
id|ctx
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
comma
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|ATTR_LIST_ENTRY
op_star
id|al_entry
comma
op_star
id|next_al_entry
suffix:semicolon
id|u8
op_star
id|al_start
comma
op_star
id|al_end
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|uchar_t
op_star
id|al_name
suffix:semicolon
id|u32
id|al_name_len
suffix:semicolon
id|ni
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%Lx, type 0x%x.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|ni-&gt;mft_no
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_ni
)paren
(brace
multiline_comment|/* First call happens with the base mft record. */
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
id|ctx-&gt;base_mrec
op_assign
id|ctx-&gt;mrec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_eq
id|base_ni
)paren
id|ctx-&gt;base_attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|vol
op_assign
id|base_ni-&gt;vol
suffix:semicolon
id|al_start
op_assign
id|base_ni-&gt;attr_list
suffix:semicolon
id|al_end
op_assign
id|al_start
op_plus
id|base_ni-&gt;attr_list_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;al_entry
)paren
id|ctx-&gt;al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
id|al_start
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate over entries in attribute list starting at @ctx-&gt;al_entry,&n;&t; * or the entry following that, if @ctx-&gt;is_first is TRUE.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;is_first
)paren
(brace
id|al_entry
op_assign
id|ctx-&gt;al_entry
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
id|al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|al_entry
op_assign
id|next_al_entry
)paren
(brace
multiline_comment|/* Out of bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
template_param
id|al_end
)paren
r_break
suffix:semicolon
multiline_comment|/* Inode is corrupt. */
id|ctx-&gt;al_entry
op_assign
id|al_entry
suffix:semicolon
multiline_comment|/* Catch the end of the attribute list. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_eq
id|al_end
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|al_entry-&gt;length
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
l_int|6
OG
id|al_end
op_logical_or
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
OG
id|al_end
)paren
r_break
suffix:semicolon
id|next_al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|al_entry-&gt;type
)paren
OG
id|le32_to_cpu
c_func
(paren
id|type
)paren
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|al_entry-&gt;type
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If @name is present, compare the two names. If @name is&n;&t;&t; * missing, assume we want an unnamed attribute.&n;&t;&t; */
id|al_name_len
op_assign
id|al_entry-&gt;name_length
suffix:semicolon
id|al_name
op_assign
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|al_entry-&gt;name_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_if
c_cond
(paren
id|al_name_len
)paren
r_goto
id|not_found
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
id|al_name
comma
id|al_name_len
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
id|al_name
comma
id|al_name_len
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @name collates before al_name, there is no&n;&t;&t;&t; * matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_goto
id|not_found
suffix:semicolon
multiline_comment|/* If the strings are not equal, continue search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FIXME: Reverse engineering showed 0, IGNORE_CASE but&n;&t;&t;&t; * that is inconsistent with find_attr(). The subsequent&n;&t;&t;&t; * rc checks were also different. Perhaps I made a&n;&t;&t;&t; * mistake in one of the two. Need to recheck which is&n;&t;&t;&t; * correct or at least see what is going on... (AIA)&n;&t;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
id|al_name
comma
id|al_name_len
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The names match or @name not present and attribute is&n;&t;&t; * unnamed. Now check @lowest_vcn. Continue search if the&n;&t;&t; * next attribute list entry still fits @lowest_vcn. Otherwise&n;&t;&t; * we have reached the right one or the search has failed.&n;&t;&t; */
r_if
c_cond
(paren
id|lowest_vcn
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_ge
id|al_start
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
l_int|6
OL
id|al_end
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|next_al_entry-&gt;length
)paren
op_le
id|al_end
op_logical_and
id|sle64_to_cpu
c_func
(paren
id|next_al_entry-&gt;lowest_vcn
)paren
op_le
id|sle64_to_cpu
c_func
(paren
id|lowest_vcn
)paren
op_logical_and
id|next_al_entry-&gt;type
op_eq
id|al_entry-&gt;type
op_logical_and
id|next_al_entry-&gt;name_length
op_eq
id|al_name_len
op_logical_and
id|ntfs_are_names_equal
c_func
(paren
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
id|next_al_entry-&gt;name_offset
)paren
comma
id|next_al_entry-&gt;name_length
comma
id|al_name
comma
id|al_name_len
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_eq
id|ni-&gt;mft_no
)paren
(brace
r_if
c_cond
(paren
id|MSEQNO_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|ni-&gt;seq_no
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Found stale mft &quot;
l_string|&quot;reference in attribute list!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Mft references do not match. */
multiline_comment|/* If there is a mapped record unmap it first. */
r_if
c_cond
(paren
id|ni
op_ne
id|base_ni
)paren
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Do we want the base record back? */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_eq
id|base_ni-&gt;mft_no
)paren
(brace
id|ni
op_assign
id|ctx-&gt;ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ctx-&gt;mrec
op_assign
id|ctx-&gt;base_mrec
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We want an extent record. */
id|ctx-&gt;mrec
op_assign
id|map_extent_mft_record
c_func
(paren
id|base_ni
comma
id|al_entry-&gt;mft_reference
comma
op_amp
id|ni
)paren
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|ni
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ctx-&gt;mrec
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft &quot;
l_string|&quot;record, error code &quot;
l_string|&quot;%ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|ctx-&gt;mrec
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * ctx-&gt;vfs_ino, ctx-&gt;mrec, and ctx-&gt;attr now point to the&n;&t;&t; * mft record containing the attribute represented by the&n;&t;&t; * current al_entry.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * We could call into find_attr() to find the right attribute&n;&t;&t; * in this mft record but this would be less efficient and not&n;&t;&t; * quite accurate as find_attr() ignores the attribute instance&n;&t;&t; * numbers for example which become important when one plays&n;&t;&t; * with attribute lists. Also, because a proper match has been&n;&t;&t; * found in the attribute list entry above, the comparison can&n;&t;&t; * now be optimized. So it is worth re-implementing a&n;&t;&t; * simplified find_attr() here.&n;&t;&t; */
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Use a manual loop so we can still use break and continue&n;&t;&t; * with the same meanings as above.&n;&t;&t; */
id|do_next_attr_loop
suffix:colon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|a
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_allocated
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
op_eq
id|AT_END
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;length
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|al_entry-&gt;instance
op_ne
id|a-&gt;instance
)paren
r_goto
id|do_next_attr
suffix:semicolon
r_if
c_cond
(paren
id|al_entry-&gt;type
op_ne
id|a-&gt;type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;name_length
op_ne
id|al_name_len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
id|al_name
comma
id|al_name_len
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
r_continue
suffix:semicolon
)brace
id|ctx-&gt;attr
op_assign
id|a
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If no @val specified or @val specified and it matches, we&n;&t;&t; * have found it!&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|val
op_logical_or
(paren
op_logical_neg
id|a-&gt;non_resident
op_logical_and
id|le32_to_cpu
c_func
(paren
id|a
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
op_eq
id|val_len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|val
comma
id|val_len
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done, found.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|do_next_attr
suffix:colon
multiline_comment|/* Proceed to the next attribute in the current mft record. */
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
)paren
suffix:semicolon
r_goto
id|do_next_attr_loop
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Inode contains corrupt attribute list &quot;
l_string|&quot;attribute.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni
op_ne
id|base_ni
)paren
(brace
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ctx-&gt;mrec
op_assign
id|ctx-&gt;base_mrec
suffix:semicolon
id|ctx-&gt;attr
op_assign
id|ctx-&gt;base_attr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * FIXME: We absolutely have to return ERROR status instead of just&n;&t; * false or we will blow up or even worse cause corruption when we add&n;&t; * write support and we reach this code path!&n;&t; */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: FIXME: Hit unfinished error code path!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
id|not_found
suffix:colon
multiline_comment|/*&n;&t; * Seek to the end of the base mft record, i.e. when we return false,&n;&t; * ctx-&gt;mrec and ctx-&gt;attr indicate where the attribute should be&n;&t; * inserted into the attribute record.&n;&t; * And of course ctx-&gt;al_entry points to the end of the attribute&n;&t; * list inside NTFS_I(ctx-&gt;base_vfs_ino)-&gt;attr_list.&n;&t; *&n;&t; * FIXME: Do we really want to do this here? Think about it... (AIA)&n;&t; */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|find_attr
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done, not found.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * lookup_attr - find an attribute in an ntfs inode&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @lowest_vcn:&t;lowest vcn to find (optional, non-resident attributes only)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * Find an attribute in an ntfs inode. On first search @ctx-&gt;ntfs_ino must&n; * be the base mft record and @ctx must have been obtained from a call to&n; * get_attr_search_ctx().&n; *&n; * This function transparently handles attribute lists and @ctx is used to&n; * continue searches where they were left off at.&n; *&n; * After finishing with the attribute/mft record you need to call&n; * release_attr_search_ctx() to cleanup the search context (unmapping any&n; * mapped inodes, etc).&n; *&n; * Return TRUE if the search was successful and FALSE if not. When TRUE,&n; * @ctx-&gt;attr is the found attribute and it is in mft record @ctx-&gt;mrec. When&n; * FALSE, @ctx-&gt;attr is the attribute which collates just after the attribute&n; * being searched for, i.e. if one wants to add the attribute to the mft&n; * record this is the correct place to insert it into.&n; */
DECL|function|lookup_attr
id|BOOL
id|lookup_attr
c_func
(paren
r_const
id|ATTR_TYPES
id|type
comma
r_const
id|uchar_t
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|VCN
id|lowest_vcn
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|attr_search_context
op_star
id|ctx
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;base_ntfs_ino
)paren
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
suffix:semicolon
r_else
id|base_ni
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
multiline_comment|/* Sanity check, just for debugging really. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoAttrList
c_func
(paren
id|base_ni
)paren
)paren
r_return
id|find_attr
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
r_return
id|find_external_attr
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|lowest_vcn
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * init_attr_search_ctx - initialize an attribute search context&n; * @ctx:&t;attribute search context to initialize&n; * @ni:&t;&t;ntfs inode with which to initialize the search context&n; * @mrec:&t;mft record with which to initialize the search context&n; *&n; * Initialize the attribute search context @ctx with @ni and @mrec.&n; */
DECL|function|init_attr_search_ctx
r_static
r_inline
r_void
id|init_attr_search_ctx
c_func
(paren
id|attr_search_context
op_star
id|ctx
comma
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mrec
)paren
(brace
id|ctx-&gt;mrec
op_assign
id|mrec
suffix:semicolon
multiline_comment|/* Sanity checks are performed elsewhere. */
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|TRUE
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|ni
suffix:semicolon
id|ctx-&gt;al_entry
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_ntfs_ino
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_mrec
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_attr
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * reinit_attr_search_ctx - reinitialize an attribute search context&n; * @ctx:&t;attribute search context to reinitialize&n; *&n; * Reinitialize the attribute search context @ctx, unmapping an associated&n; * extent mft record if present, and initialize the search context again.&n; *&n; * This is used when a search for a new attribute is being started to reset&n; * the search context to the beginning.&n; */
DECL|function|reinit_attr_search_ctx
r_void
id|reinit_attr_search_ctx
c_func
(paren
id|attr_search_context
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|ctx-&gt;base_ntfs_ino
)paren
)paren
(brace
multiline_comment|/* No attribute list. */
id|ctx-&gt;is_first
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Sanity checks are performed elsewhere. */
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Attribute list. */
r_if
c_cond
(paren
id|ctx-&gt;ntfs_ino
op_ne
id|ctx-&gt;base_ntfs_ino
)paren
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|init_attr_search_ctx
c_func
(paren
id|ctx
comma
id|ctx-&gt;base_ntfs_ino
comma
id|ctx-&gt;base_mrec
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * get_attr_search_ctx - allocate and initialize a new attribute search context&n; * @ctx:&t;address of pointer in which to return the new search context&n; * @ni:&t;&t;ntfs inode with which to initialize the search context&n; * @mrec:&t;mft record with which to initialize the search context&n; *&n; * Allocate a new attribute search context, initialize it with @ni and @mrec,&n; * and return it in *@ctx. Return 0 on success or -ENOMEM if allocation failed.&n; */
DECL|function|get_attr_search_ctx
r_int
id|get_attr_search_ctx
c_func
(paren
id|attr_search_context
op_star
op_star
id|ctx
comma
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mrec
)paren
(brace
op_star
id|ctx
op_assign
id|kmem_cache_alloc
c_func
(paren
id|ntfs_attr_ctx_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
op_star
id|ctx
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|init_attr_search_ctx
c_func
(paren
op_star
id|ctx
comma
id|ni
comma
id|mrec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * put_attr_search_ctx - release an attribute search context&n; * @ctx:&t;attribute search context to free&n; *&n; * Release the attribute search context @ctx, unmapping an associated extent&n; * mft record if prseent.&n; */
DECL|function|put_attr_search_ctx
r_void
id|put_attr_search_ctx
c_func
(paren
id|attr_search_context
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;base_ntfs_ino
op_logical_and
id|ctx-&gt;ntfs_ino
op_ne
id|ctx-&gt;base_ntfs_ino
)paren
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_attr_ctx_cache
comma
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
