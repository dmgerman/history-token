multiline_comment|/**&n; * attrib.c - NTFS attribute operations. Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2003 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;ntfs.h&quot;
macro_line|#include &quot;dir.h&quot;
multiline_comment|/* Temporary helper functions -- might become macros */
multiline_comment|/**&n; * ntfs_rl_mm - run_list memmove&n; *&n; * It is up to the caller to serialize access to the run list @base.&n; */
DECL|function|ntfs_rl_mm
r_static
r_inline
r_void
id|ntfs_rl_mm
c_func
(paren
id|run_list_element
op_star
id|base
comma
r_int
id|dst
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
(paren
id|dst
op_ne
id|src
)paren
op_logical_and
(paren
id|size
OG
l_int|0
)paren
)paren
)paren
id|memmove
c_func
(paren
id|base
op_plus
id|dst
comma
id|base
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|base
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_mc - run_list memory copy&n; *&n; * It is up to the caller to serialize access to the run lists @dstbase and&n; * @srcbase.&n; */
DECL|function|ntfs_rl_mc
r_static
r_inline
r_void
id|ntfs_rl_mc
c_func
(paren
id|run_list_element
op_star
id|dstbase
comma
r_int
id|dst
comma
id|run_list_element
op_star
id|srcbase
comma
r_int
id|src
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|size
OG
l_int|0
)paren
)paren
id|memcpy
c_func
(paren
id|dstbase
op_plus
id|dst
comma
id|srcbase
op_plus
id|src
comma
id|size
op_star
r_sizeof
(paren
op_star
id|dstbase
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_realloc - Reallocate memory for run_lists&n; * @rl:&t;&t;original run list&n; * @old_size:&t;number of run list elements in the original run list @rl&n; * @new_size:&t;number of run list elements we need space for&n; *&n; * As the run_lists grow, more memory will be required.  To prevent the&n; * kernel having to allocate and reallocate large numbers of small bits of&n; * memory, this function returns and entire page of memory.&n; *&n; * It is up to the caller to serialize access to the run list @rl.&n; *&n; * N.B.  If the new allocation doesn&squot;t require a different number of pages in&n; *       memory, the function will return the original pointer.&n; *&n; * On success, return a pointer to the newly allocated, or recycled, memory.&n; * On error, return -errno. The following error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate run list array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_realloc
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_realloc
c_func
(paren
id|run_list_element
op_star
id|rl
comma
r_int
id|old_size
comma
r_int
id|new_size
)paren
(brace
id|run_list_element
op_star
id|new_rl
suffix:semicolon
id|old_size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|old_size
op_star
r_sizeof
(paren
op_star
id|rl
)paren
)paren
suffix:semicolon
id|new_size
op_assign
id|PAGE_ALIGN
c_func
(paren
id|new_size
op_star
r_sizeof
(paren
op_star
id|rl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_size
op_eq
id|new_size
)paren
r_return
id|rl
suffix:semicolon
id|new_rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|new_rl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|old_size
OG
id|new_size
)paren
)paren
id|old_size
op_assign
id|new_size
suffix:semicolon
id|memcpy
c_func
(paren
id|new_rl
comma
id|rl
comma
id|old_size
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
)brace
r_return
id|new_rl
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_are_rl_mergeable - test if two run lists can be joined together&n; * @dst:&t;original run list&n; * @src:&t;new run list to test for mergeability with @dst&n; *&n; * Test if two run lists can be joined together. For this, their VCNs and LCNs&n; * must be adjacent.&n; *&n; * It is up to the caller to serialize access to the run lists @dst and @src.&n; *&n; * Return: TRUE   Success, the run lists can be merged.&n; *         FALSE  Failure, the run lists cannot be merged.&n; */
DECL|function|ntfs_are_rl_mergeable
r_static
r_inline
id|BOOL
id|ntfs_are_rl_mergeable
c_func
(paren
id|run_list_element
op_star
id|dst
comma
id|run_list_element
op_star
id|src
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;lcn
OL
l_int|0
)paren
op_logical_or
(paren
id|src-&gt;lcn
OL
l_int|0
)paren
)paren
multiline_comment|/* Are we merging holes? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;lcn
op_plus
id|dst-&gt;length
)paren
op_ne
id|src-&gt;lcn
)paren
multiline_comment|/* Are the runs contiguous? */
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dst-&gt;vcn
op_plus
id|dst-&gt;length
)paren
op_ne
id|src-&gt;vcn
)paren
multiline_comment|/* Are the runs misaligned? */
r_return
id|FALSE
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/**&n; * __ntfs_rl_merge - merge two run lists without testing if they can be merged&n; * @dst:&t;original, destination run list&n; * @src:&t;new run list to merge with @dst&n; *&n; * Merge the two run lists, writing into the destination run list @dst. The&n; * caller must make sure the run lists can be merged or this will corrupt the&n; * destination run list.&n; *&n; * It is up to the caller to serialize access to the run lists @dst and @src.&n; */
DECL|function|__ntfs_rl_merge
r_static
r_inline
r_void
id|__ntfs_rl_merge
c_func
(paren
id|run_list_element
op_star
id|dst
comma
id|run_list_element
op_star
id|src
)paren
(brace
id|dst-&gt;length
op_add_assign
id|src-&gt;length
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_merge - test if two run lists can be joined together and merge them&n; * @dst:&t;original, destination run list&n; * @src:&t;new run list to merge with @dst&n; *&n; * Test if two run lists can be joined together. For this, their VCNs and LCNs&n; * must be adjacent. If they can be merged, perform the merge, writing into&n; * the destination run list @dst.&n; *&n; * It is up to the caller to serialize access to the run lists @dst and @src.&n; *&n; * Return: TRUE   Success, the run lists have been merged.&n; *         FALSE  Failure, the run lists cannot be merged and have not been&n; *&t;&t;  modified.&n; */
DECL|function|ntfs_rl_merge
r_static
r_inline
id|BOOL
id|ntfs_rl_merge
c_func
(paren
id|run_list_element
op_star
id|dst
comma
id|run_list_element
op_star
id|src
)paren
(brace
id|BOOL
id|merge
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
comma
id|src
)paren
suffix:semicolon
r_if
c_cond
(paren
id|merge
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
comma
id|src
)paren
suffix:semicolon
r_return
id|merge
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_append - append a run list after a given element&n; * @dst:&t;original run list to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;run list to be inserted into @dst&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;append the new run list @src after this element in @dst&n; *&n; * Append the run list @src after element @loc in @dst.  Merge the right end of&n; * the new run list, if necessary. Adjust the size of the hole before the&n; * appended run list.&n; *&n; * It is up to the caller to serialize access to the run lists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, run list. Note, both&n; * run lists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned run list&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both run lists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate run list array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_append
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_append
c_func
(paren
id|run_list_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|run_list_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|right
suffix:semicolon
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* First, check if the right hand end needs merging. */
id|right
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Space required: @dst size + @src size, less one if we merged. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original run lists.&n;&t; */
multiline_comment|/* First, merge the right hand end, if necessary. */
r_if
c_cond
(paren
id|right
)paren
id|__ntfs_rl_merge
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
id|magic
op_assign
id|loc
op_plus
id|ssize
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
op_plus
l_int|1
comma
id|loc
op_plus
l_int|1
op_plus
id|right
comma
id|dsize
op_minus
id|loc
op_minus
l_int|1
op_minus
id|right
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
comma
id|src
comma
l_int|0
comma
id|ssize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the preceding hole. */
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
)braket
dot
id|length
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_insert - insert a run list into another&n; * @dst:&t;original run list to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new run list to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;insert the new run list @src before this element in @dst&n; *&n; * Insert the run list @src before element @loc in the run list @dst. Merge the&n; * left end of the new run list, if necessary. Adjust the size of the hole&n; * after the inserted run list.&n; *&n; * It is up to the caller to serialize access to the run lists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, run list. Note, both&n; * run lists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned run list&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both run lists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate run list array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_insert
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_insert
c_func
(paren
id|run_list_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|run_list_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|disc
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Discontinuity */
id|BOOL
id|hole
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Following a hole */
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* disc =&gt; Discontinuity between the end of @dst and the start of @src.&n;&t; *         This means we might need to insert a hole.&n;&t; * hole =&gt; @dst ends with a hole or an unmapped region which we can&n;&t; *         extend to match the discontinuity. */
r_if
c_cond
(paren
id|loc
op_eq
l_int|0
)paren
id|disc
op_assign
(paren
id|src
(braket
l_int|0
)braket
dot
id|vcn
OG
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|s64
id|merged_length
suffix:semicolon
id|left
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
id|merged_length
op_assign
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
id|merged_length
op_add_assign
id|src-&gt;length
suffix:semicolon
id|disc
op_assign
(paren
id|src
(braket
l_int|0
)braket
dot
id|vcn
OG
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|merged_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|disc
)paren
id|hole
op_assign
(paren
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
)paren
suffix:semicolon
)brace
multiline_comment|/* Space required: @dst size + @src size, less one if we merged, plus&n;&t; * one if there was a discontinuity, less one for a trailing hole. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original run list.&n;&t; */
r_if
c_cond
(paren
id|left
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
id|magic
op_assign
id|loc
op_plus
id|ssize
op_minus
id|left
op_plus
id|disc
op_minus
id|hole
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
comma
id|loc
comma
id|dsize
op_minus
id|loc
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
id|disc
op_minus
id|hole
comma
id|src
comma
id|left
comma
id|ssize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* Adjust the VCN of the last run ... */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_le
id|LCN_HOLE
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
multiline_comment|/* ... and the length. */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_HOLE
op_logical_or
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
id|dst
(braket
id|magic
)braket
dot
id|length
op_assign
id|dst
(braket
id|magic
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|magic
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Writing beyond the end of the file and there&squot;s a discontinuity. */
r_if
c_cond
(paren
id|disc
)paren
(brace
r_if
c_cond
(paren
id|hole
)paren
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
(brace
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|loc
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
)brace
r_else
(brace
id|dst
(braket
id|loc
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
id|dst
(braket
id|loc
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
)brace
id|magic
op_add_assign
id|hole
suffix:semicolon
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_replace - overwrite a run_list element with another run list&n; * @dst:&t;original run list to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new run list to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;index in run list @dst to overwrite with @src&n; *&n; * Replace the run list element @dst at @loc with @src. Merge the left and&n; * right ends of the inserted run list, if necessary.&n; *&n; * It is up to the caller to serialize access to the run lists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, run list. Note, both&n; * run lists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned run list&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both run lists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate run list array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_replace
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_replace
c_func
(paren
id|run_list_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|run_list_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BOOL
id|left
op_assign
id|FALSE
suffix:semicolon
id|BOOL
id|right
suffix:semicolon
r_int
id|magic
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* First, merge the left and right ends, if necessary. */
id|right
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loc
OG
l_int|0
)paren
id|left
op_assign
id|ntfs_are_rl_mergeable
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* Allocate some space. We&squot;ll need less if the left, right, or both&n;&t; * ends were merged. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_minus
id|left
op_minus
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original run lists.&n;&t; */
r_if
c_cond
(paren
id|right
)paren
id|__ntfs_rl_merge
c_func
(paren
id|src
op_plus
id|ssize
op_minus
l_int|1
comma
id|dst
op_plus
id|loc
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|left
)paren
id|__ntfs_rl_merge
c_func
(paren
id|dst
op_plus
id|loc
op_minus
l_int|1
comma
id|src
)paren
suffix:semicolon
multiline_comment|/* FIXME: What does this mean? (AIA) */
id|magic
op_assign
id|loc
op_plus
id|ssize
op_minus
id|left
suffix:semicolon
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|magic
comma
id|loc
op_plus
id|right
op_plus
l_int|1
comma
id|dsize
op_minus
id|loc
op_minus
id|right
op_minus
l_int|1
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
comma
id|src
comma
id|left
comma
id|ssize
op_minus
id|left
)paren
suffix:semicolon
multiline_comment|/* We may have changed the length of the file, so fix the end marker */
r_if
c_cond
(paren
id|dst
(braket
id|magic
)braket
dot
id|lcn
op_eq
id|LCN_ENOENT
)paren
id|dst
(braket
id|magic
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|magic
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_rl_split - insert a run list into the centre of a hole&n; * @dst:&t;original run list to be worked on&n; * @dsize:&t;number of elements in @dst (including end marker)&n; * @src:&t;new run list to be inserted&n; * @ssize:&t;number of elements in @src (excluding end marker)&n; * @loc:&t;index in run list @dst at which to split and insert @src&n; *&n; * Split the run list @dst at @loc into two and insert @new in between the two&n; * fragments. No merging of run lists is necessary. Adjust the size of the&n; * holes either side.&n; *&n; * It is up to the caller to serialize access to the run lists @dst and @src.&n; *&n; * On success, return a pointer to the new, combined, run list. Note, both&n; * run lists @dst and @src are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned run list&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both run lists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate run list array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; */
DECL|function|ntfs_rl_split
r_static
r_inline
id|run_list_element
op_star
id|ntfs_rl_split
c_func
(paren
id|run_list_element
op_star
id|dst
comma
r_int
id|dsize
comma
id|run_list_element
op_star
id|src
comma
r_int
id|ssize
comma
r_int
id|loc
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|dst
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|src
)paren
suffix:semicolon
multiline_comment|/* Space required: @dst size + @src size + one new hole. */
id|dst
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|dst
comma
id|dsize
comma
id|dsize
op_plus
id|ssize
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dst
)paren
)paren
r_return
id|dst
suffix:semicolon
multiline_comment|/*&n;&t; * We are guaranteed to succeed from here so can start modifying the&n;&t; * original run lists.&n;&t; */
multiline_comment|/* Move the tail of @dst out of the way, then copy in @src. */
id|ntfs_rl_mm
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
op_plus
id|ssize
comma
id|loc
comma
id|dsize
op_minus
id|loc
)paren
suffix:semicolon
id|ntfs_rl_mc
c_func
(paren
id|dst
comma
id|loc
op_plus
l_int|1
comma
id|src
comma
l_int|0
comma
id|ssize
)paren
suffix:semicolon
multiline_comment|/* Adjust the size of the holes either size of @src. */
id|dst
(braket
id|loc
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
l_int|1
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
)braket
dot
id|vcn
suffix:semicolon
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|vcn
op_assign
id|dst
(braket
id|loc
op_plus
id|ssize
)braket
dot
id|vcn
op_plus
id|dst
(braket
id|loc
op_plus
id|ssize
)braket
dot
id|length
suffix:semicolon
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|length
op_assign
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|2
)braket
dot
id|vcn
op_minus
id|dst
(braket
id|loc
op_plus
id|ssize
op_plus
l_int|1
)braket
dot
id|vcn
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_merge_run_lists - merge two run_lists into one&n; * @drl:&t;original run list to be worked on&n; * @srl:&t;new run list to be merged into @drl&n; *&n; * First we sanity check the two run lists @srl and @drl to make sure that they&n; * are sensible and can be merged. The run list @srl must be either after the&n; * run list @drl or completely within a hole (or unmapped region) in @drl.&n; *&n; * It is up to the caller to serialize access to the run lists @drl and @srl.&n; *&n; * Merging of run lists is necessary in two cases:&n; *   1. When attribute lists are used and a further extent is being mapped.&n; *   2. When new clusters are allocated to fill a hole or extend a file.&n; *&n; * There are four possible ways @srl can be merged. It can:&n; *&t;- be inserted at the beginning of a hole,&n; *&t;- split the hole in two and be inserted between the two fragments,&n; *&t;- be appended at the end of a hole, or it can&n; *&t;- replace the whole hole.&n; * It can also be appended to the end of the run list, which is just a variant&n; * of the insert case.&n; *&n; * On success, return a pointer to the new, combined, run list. Note, both&n; * run lists @drl and @srl are deallocated before returning so you cannot use&n; * the pointers for anything any more. (Strictly speaking the returned run list&n; * may be the same as @dst but this is irrelevant.)&n; *&n; * On error, return -errno. Both run lists are left unmodified. The following&n; * error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate run list array.&n; *&t;-EINVAL&t;- Invalid parameters were passed in.&n; *&t;-ERANGE&t;- The run lists overlap and cannot be merged.&n; */
DECL|function|ntfs_merge_run_lists
id|run_list_element
op_star
id|ntfs_merge_run_lists
c_func
(paren
id|run_list_element
op_star
id|drl
comma
id|run_list_element
op_star
id|srl
)paren
(brace
r_int
id|di
comma
id|si
suffix:semicolon
multiline_comment|/* Current index into @[ds]rl. */
r_int
id|sstart
suffix:semicolon
multiline_comment|/* First index with lcn &gt; LCN_RL_NOT_MAPPED. */
r_int
id|dins
suffix:semicolon
multiline_comment|/* Index into @drl at which to insert @srl. */
r_int
id|dend
comma
id|send
suffix:semicolon
multiline_comment|/* Last index into @[ds]rl. */
r_int
id|dfinal
comma
id|sfinal
suffix:semicolon
multiline_comment|/* The last index into @[ds]rl with&n;&t;&t;&t;&t;   lcn &gt;= LCN_HOLE. */
r_int
id|marker
op_assign
l_int|0
suffix:semicolon
id|VCN
id|marker_vcn
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
id|ntfs_debug
c_func
(paren
l_string|&quot;dst:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|drl
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;src:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|srl
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for silly calling... */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|srl
)paren
)paren
r_return
id|drl
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|srl
)paren
op_logical_or
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* Check for the case where the first mapping is being done now. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|drl
)paren
)paren
(brace
id|drl
op_assign
id|srl
suffix:semicolon
multiline_comment|/* Complete the source run list if necessary. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|drl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
(brace
multiline_comment|/* Scan to the end of the source run list. */
r_for
c_loop
(paren
id|dend
op_assign
l_int|0
suffix:semicolon
id|likely
c_func
(paren
id|drl
(braket
id|dend
)braket
dot
id|length
)paren
suffix:semicolon
id|dend
op_increment
)paren
suffix:semicolon
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|dend
comma
id|dend
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
r_return
id|drl
suffix:semicolon
multiline_comment|/* Insert start element at the front of the run list. */
id|ntfs_rl_mm
c_func
(paren
id|drl
comma
l_int|1
comma
l_int|0
comma
id|dend
)paren
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|vcn
op_assign
l_int|0
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|drl
(braket
l_int|0
)braket
dot
id|length
op_assign
id|drl
(braket
l_int|1
)braket
dot
id|vcn
suffix:semicolon
)brace
r_goto
id|finished
suffix:semicolon
)brace
id|si
op_assign
id|di
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip any unmapped start element(s) in the source run_list. */
r_while
c_loop
(paren
id|srl
(braket
id|si
)braket
dot
id|length
op_logical_and
id|srl
(braket
id|si
)braket
dot
id|lcn
OL
(paren
id|LCN
)paren
id|LCN_HOLE
)paren
id|si
op_increment
suffix:semicolon
multiline_comment|/* Can&squot;t have an entirely unmapped source run list. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|srl
(braket
id|si
)braket
dot
id|length
)paren
suffix:semicolon
multiline_comment|/* Record the starting points. */
id|sstart
op_assign
id|si
suffix:semicolon
multiline_comment|/*&n;&t; * Skip forward in @drl until we reach the position where @srl needs to&n;&t; * be inserted. If we reach the end of @drl, @srl just needs to be&n;&t; * appended to @drl.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|drl
(braket
id|di
)braket
dot
id|length
suffix:semicolon
id|di
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|di
)braket
dot
id|length
OG
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
r_break
suffix:semicolon
)brace
id|dins
op_assign
id|di
suffix:semicolon
multiline_comment|/* Sanity check for illegal overlaps. */
r_if
c_cond
(paren
(paren
id|drl
(braket
id|di
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|si
)braket
dot
id|vcn
)paren
op_logical_and
(paren
id|drl
(braket
id|di
)braket
dot
id|lcn
op_ge
l_int|0
)paren
op_logical_and
(paren
id|srl
(braket
id|si
)braket
dot
id|lcn
op_ge
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Run lists overlap. Cannot merge!&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ERANGE
)paren
suffix:semicolon
)brace
multiline_comment|/* Scan to the end of both run lists in order to know their sizes. */
r_for
c_loop
(paren
id|send
op_assign
id|si
suffix:semicolon
id|srl
(braket
id|send
)braket
dot
id|length
suffix:semicolon
id|send
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dend
op_assign
id|di
suffix:semicolon
id|drl
(braket
id|dend
)braket
dot
id|length
suffix:semicolon
id|dend
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|srl
(braket
id|send
)braket
dot
id|lcn
op_eq
(paren
id|LCN
)paren
id|LCN_ENOENT
)paren
id|marker_vcn
op_assign
id|srl
(braket
id|marker
op_assign
id|send
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Scan to the last element with lcn &gt;= LCN_HOLE. */
r_for
c_loop
(paren
id|sfinal
op_assign
id|send
suffix:semicolon
id|sfinal
op_ge
l_int|0
op_logical_and
id|srl
(braket
id|sfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|sfinal
op_decrement
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dfinal
op_assign
id|dend
suffix:semicolon
id|dfinal
op_ge
l_int|0
op_logical_and
id|drl
(braket
id|dfinal
)braket
dot
id|lcn
OL
id|LCN_HOLE
suffix:semicolon
id|dfinal
op_decrement
)paren
suffix:semicolon
(brace
id|BOOL
id|start
suffix:semicolon
id|BOOL
id|finish
suffix:semicolon
r_int
id|ds
op_assign
id|dend
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Number of elements in drl &amp; srl */
r_int
id|ss
op_assign
id|sfinal
op_minus
id|sstart
op_plus
l_int|1
suffix:semicolon
id|start
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
OL
id|LCN_RL_NOT_MAPPED
)paren
op_logical_or
multiline_comment|/* End of file   */
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_eq
id|srl
(braket
id|sstart
)braket
dot
id|vcn
)paren
)paren
suffix:semicolon
multiline_comment|/* Start of hole */
id|finish
op_assign
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|lcn
op_ge
id|LCN_RL_NOT_MAPPED
)paren
op_logical_and
multiline_comment|/* End of file   */
(paren
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
)paren
op_le
multiline_comment|/* End of hole   */
(paren
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|length
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Or we&squot;ll lose an end marker */
r_if
c_cond
(paren
id|start
op_logical_and
id|finish
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|length
op_eq
l_int|0
)paren
)paren
id|ss
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|marker
op_logical_and
(paren
id|drl
(braket
id|dins
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|dins
)braket
dot
id|length
OG
id|srl
(braket
id|send
op_minus
l_int|1
)braket
dot
id|vcn
)paren
)paren
id|finish
op_assign
id|FALSE
suffix:semicolon
macro_line|#if 0
id|ntfs_debug
c_func
(paren
l_string|&quot;dfinal = %i, dend = %i&quot;
comma
id|dfinal
comma
id|dend
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;sstart = %i, sfinal = %i, send = %i&quot;
comma
id|sstart
comma
id|sfinal
comma
id|send
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;start = %i, finish = %i&quot;
comma
id|start
comma
id|finish
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;ds = %i, ss = %i, dins = %i&quot;
comma
id|ds
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|start
)paren
(brace
r_if
c_cond
(paren
id|finish
)paren
id|drl
op_assign
id|ntfs_rl_replace
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|drl
op_assign
id|ntfs_rl_insert
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|finish
)paren
id|drl
op_assign
id|ntfs_rl_append
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
r_else
id|drl
op_assign
id|ntfs_rl_split
c_func
(paren
id|drl
comma
id|ds
comma
id|srl
op_plus
id|sstart
comma
id|ss
comma
id|dins
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|drl
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Merge failed.&quot;
)paren
suffix:semicolon
r_return
id|drl
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|srl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|marker
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Triggering marker code.&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ds
op_assign
id|dend
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|length
suffix:semicolon
id|ds
op_increment
)paren
suffix:semicolon
multiline_comment|/* We only need to care if @srl ended after @drl. */
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_le
id|marker_vcn
)paren
(brace
r_int
id|slots
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_eq
id|marker_vcn
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Old marker = 0x%Lx, replacing with &quot;
l_string|&quot;LCN_ENOENT.&bslash;n&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
)paren
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We need to create an unmapped run list element in&n;&t;&t;&t; * @drl or extend an existing one before adding the&n;&t;&t;&t; * ENOENT terminator.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_eq
(paren
id|LCN
)paren
id|LCN_ENOENT
)paren
(brace
id|ds
op_decrement
suffix:semicolon
id|slots
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_ne
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
)paren
(brace
multiline_comment|/* Add an unmapped run list element. */
r_if
c_cond
(paren
op_logical_neg
id|slots
)paren
(brace
multiline_comment|/* FIXME/TODO: We need to have the&n;&t;&t;&t;&t;&t; * extra memory already! (AIA) */
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|ds
comma
id|ds
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drl
)paren
r_goto
id|critical_error
suffix:semicolon
id|slots
op_assign
l_int|2
suffix:semicolon
)brace
id|ds
op_increment
suffix:semicolon
multiline_comment|/* Need to set vcn if it isn&squot;t set already. */
r_if
c_cond
(paren
id|slots
op_ne
l_int|1
)paren
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_assign
id|drl
(braket
id|ds
op_minus
l_int|1
)braket
dot
id|vcn
op_plus
id|drl
(braket
id|ds
op_minus
l_int|1
)braket
dot
id|length
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* We now used up a slot. */
id|slots
op_decrement
suffix:semicolon
)brace
id|drl
(braket
id|ds
)braket
dot
id|length
op_assign
id|marker_vcn
op_minus
id|drl
(braket
id|ds
)braket
dot
id|vcn
suffix:semicolon
multiline_comment|/* Finally add the ENOENT terminator. */
id|ds
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|slots
)paren
(brace
multiline_comment|/* FIXME/TODO: We need to have the extra&n;&t;&t;&t;&t; * memory already! (AIA) */
id|drl
op_assign
id|ntfs_rl_realloc
c_func
(paren
id|drl
comma
id|ds
comma
id|ds
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drl
)paren
r_goto
id|critical_error
suffix:semicolon
)brace
id|drl
(braket
id|ds
)braket
dot
id|vcn
op_assign
id|marker_vcn
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
id|drl
(braket
id|ds
)braket
dot
id|length
op_assign
(paren
id|s64
)paren
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|finished
suffix:colon
multiline_comment|/* The merge was completed successfully. */
id|ntfs_debug
c_func
(paren
l_string|&quot;Merged run list:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|drl
)paren
suffix:semicolon
r_return
id|drl
suffix:semicolon
id|critical_error
suffix:colon
multiline_comment|/* Critical error! We cannot afford to fail here. */
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Critical error! Not enough memory.&quot;
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;NTFS: Cannot continue.&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * decompress_mapping_pairs - convert mapping pairs array to run list&n; * @vol:&t;ntfs volume on which the attribute resides&n; * @attr:&t;attribute record whose mapping pairs array to decompress&n; * @old_rl:&t;optional run list in which to insert @attr&squot;s run list&n; *&n; * It is up to the caller to serialize access to the run list @old_rl.&n; *&n; * Decompress the attribute @attr&squot;s mapping pairs array into a run list. On&n; * success, return the decompressed run list.&n; *&n; * If @old_rl is not NULL, decompressed run list is inserted into the&n; * appropriate place in @old_rl and the resultant, combined run list is&n; * returned. The original @old_rl is deallocated.&n; *&n; * On error, return -errno. @old_rl is left unmodified in that case.&n; *&n; * The following error codes are defined:&n; *&t;-ENOMEM&t;- Not enough memory to allocate run list array.&n; * &t;-EIO&t;- Corrupt run list.&n; * &t;-EINVAL&t;- Invalid parameters were passed in.&n; * &t;-ERANGE&t;- The two run lists overlap.&n; *&n; * FIXME: For now we take the conceptionally simplest approach of creating the&n; * new run list disregarding the already existing one and then splicing the&n; * two into one, if that is possible (we check for overlap and discard the new&n; * run list if overlap present before returning ERR_PTR(-ERANGE)).&n; */
DECL|function|decompress_mapping_pairs
id|run_list_element
op_star
id|decompress_mapping_pairs
c_func
(paren
r_const
id|ntfs_volume
op_star
id|vol
comma
r_const
id|ATTR_RECORD
op_star
id|attr
comma
id|run_list_element
op_star
id|old_rl
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
multiline_comment|/* Current vcn. */
id|LCN
id|lcn
suffix:semicolon
multiline_comment|/* Current lcn. */
id|s64
id|deltaxcn
suffix:semicolon
multiline_comment|/* Change in [vl]cn. */
id|run_list_element
op_star
id|rl
suffix:semicolon
multiline_comment|/* The output run list. */
id|u8
op_star
id|buf
suffix:semicolon
multiline_comment|/* Current position in mapping pairs array. */
id|u8
op_star
id|attr_end
suffix:semicolon
multiline_comment|/* End of attribute. */
r_int
id|rlsize
suffix:semicolon
multiline_comment|/* Size of run list buffer. */
id|u16
id|rlpos
suffix:semicolon
multiline_comment|/* Current run list position in units of&n;&t;&t;&t;&t;   run_list_elements. */
id|u8
id|b
suffix:semicolon
multiline_comment|/* Current byte offset in buf. */
macro_line|#ifdef DEBUG
multiline_comment|/* Make sure attr exists and is non-resident. */
r_if
c_cond
(paren
op_logical_neg
id|attr
op_logical_or
op_logical_neg
id|attr-&gt;non_resident
op_logical_or
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
OL
(paren
id|VCN
)paren
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid arguments.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Start at vcn = lowest_vcn and lcn 0. */
id|vcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.lowest_vcn
)paren
suffix:semicolon
id|lcn
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get start of the mapping pairs array. */
id|buf
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le16_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.mapping_pairs_offset
)paren
suffix:semicolon
id|attr_end
op_assign
(paren
id|u8
op_star
)paren
id|attr
op_plus
id|le32_to_cpu
c_func
(paren
id|attr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
template_param
id|attr_end
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/* Current position in run list array. */
id|rlpos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Allocate first page and set current run list size to one page. */
id|rl
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_assign
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* Insert unmapped starting element if necessary. */
r_if
c_cond
(paren
id|vcn
)paren
(brace
id|rl-&gt;vcn
op_assign
(paren
id|VCN
)paren
l_int|0
suffix:semicolon
id|rl-&gt;lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rl-&gt;length
op_assign
id|vcn
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buf
OL
id|attr_end
op_logical_and
op_star
id|buf
)paren
(brace
multiline_comment|/*&n;&t;&t; * Allocate more memory if needed, including space for the&n;&t;&t; * not-mapped and terminator elements. ntfs_malloc_nofs()&n;&t;&t; * operates on whole pages only.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|rlpos
op_plus
l_int|3
)paren
op_star
r_sizeof
(paren
op_star
id|old_rl
)paren
)paren
OG
id|rlsize
)paren
(brace
id|run_list_element
op_star
id|rl2
suffix:semicolon
id|rl2
op_assign
id|ntfs_malloc_nofs
c_func
(paren
id|rlsize
op_plus
(paren
r_int
)paren
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl2
)paren
)paren
(brace
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rl2
comma
id|rl
comma
id|rlsize
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|rl
op_assign
id|rl2
suffix:semicolon
id|rlsize
op_add_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* Enter the current vcn into the current run_list element. */
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the change in vcn, i.e. the run length in clusters.&n;&t;&t; * Doing it this way ensures that we signextend negative values.&n;&t;&t; * A negative run length doesn&squot;t make any sense, but hey, I&n;&t;&t; * didn&squot;t make up the NTFS specs and Windows NT4 treats the run&n;&t;&t; * length as a signed value so that&squot;s how it is...&n;&t;&t; */
id|b
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|b
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The length entry is compulsory. */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Missing length entry in mapping &quot;
l_string|&quot;pairs array.&quot;
)paren
suffix:semicolon
id|deltaxcn
op_assign
(paren
id|s64
)paren
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Assume a negative length to indicate data corruption and&n;&t;&t; * hence clean-up and return NULL.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OL
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid length in mapping pairs &quot;
l_string|&quot;array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Enter the current run length into the current run list&n;&t;&t; * element.&n;&t;&t; */
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/* Increment the current vcn by the current run length. */
id|vcn
op_add_assign
id|deltaxcn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There might be no lcn change at all, as is the case for&n;&t;&t; * sparse clusters on NTFS 3.0+, in which case we set the lcn&n;&t;&t; * to LCN_HOLE.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|buf
op_amp
l_int|0xf0
)paren
)paren
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_HOLE
suffix:semicolon
r_else
(brace
multiline_comment|/* Get the lcn change which really can be negative. */
id|u8
id|b2
op_assign
op_star
id|buf
op_amp
l_int|0xf
suffix:semicolon
id|b
op_assign
id|b2
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_plus
id|b
OG
id|attr_end
)paren
r_goto
id|io_error
suffix:semicolon
r_for
c_loop
(paren
id|deltaxcn
op_assign
(paren
id|s8
)paren
id|buf
(braket
id|b
op_decrement
)braket
suffix:semicolon
id|b
OG
id|b2
suffix:semicolon
id|b
op_decrement
)paren
id|deltaxcn
op_assign
(paren
id|deltaxcn
op_lshift
l_int|8
)paren
op_plus
id|buf
(braket
id|b
)braket
suffix:semicolon
multiline_comment|/* Change the current lcn to its new value. */
id|lcn
op_add_assign
id|deltaxcn
suffix:semicolon
macro_line|#ifdef DEBUG
multiline_comment|/*&n;&t;&t;&t; * On NTFS 1.2-, apparently can have lcn == -1 to&n;&t;&t;&t; * indicate a hole. But we haven&squot;t verified ourselves&n;&t;&t;&t; * whether it is really the lcn or the deltaxcn that is&n;&t;&t;&t; * -1. So if either is found give us a message so we&n;&t;&t;&t; * can investigate it further!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|vol-&gt;major_ver
OL
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn delta == -1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
op_eq
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;lcn == -1&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Check lcn is not below -1. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
OL
(paren
id|LCN
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Invalid LCN &lt; -1 in &quot;
l_string|&quot;mapping pairs array.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Enter the current lcn into the run_list element. */
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
id|lcn
suffix:semicolon
)brace
multiline_comment|/* Get to the next run_list element. */
id|rlpos
op_increment
suffix:semicolon
multiline_comment|/* Increment the buffer position to the next mapping pair. */
id|buf
op_add_assign
(paren
op_star
id|buf
op_amp
l_int|0xf
)paren
op_plus
(paren
(paren
op_star
id|buf
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buf
op_ge
id|attr_end
)paren
)paren
r_goto
id|io_error
suffix:semicolon
multiline_comment|/*&n;&t; * If there is a highest_vcn specified, it must be equal to the final&n;&t; * vcn in the run list - 1, or something has gone badly wrong.&n;&t; */
id|deltaxcn
op_assign
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.highest_vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
op_logical_and
id|vcn
op_minus
l_int|1
op_ne
id|deltaxcn
)paren
)paren
(brace
id|mpa_err
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt mapping pairs array in &quot;
l_string|&quot;non-resident attribute.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Setup not mapped run list element if this is the base extent. */
r_if
c_cond
(paren
op_logical_neg
id|attr-&gt;data.non_resident.lowest_vcn
)paren
(brace
id|VCN
id|max_cluster
suffix:semicolon
id|max_cluster
op_assign
(paren
id|sle64_to_cpu
c_func
(paren
id|attr-&gt;data.non_resident.allocated_size
)paren
op_plus
id|vol-&gt;cluster_size
op_minus
l_int|1
)paren
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there is a difference between the highest_vcn and the&n;&t;&t; * highest cluster, the run list is either corrupt or, more&n;&t;&t; * likely, there are more extents following this one.&n;&t;&t; */
r_if
c_cond
(paren
id|deltaxcn
OL
op_decrement
id|max_cluster
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;More extents to follow; deltaxcn = 0x%Lx, &quot;
l_string|&quot;max_cluster = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|deltaxcn
comma
(paren
r_int
r_int
)paren
id|max_cluster
)paren
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
id|vcn
op_add_assign
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
id|max_cluster
op_minus
id|deltaxcn
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
id|rlpos
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|deltaxcn
OG
id|max_cluster
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute. deltaxcn = &quot;
l_string|&quot;0x%Lx, max_cluster = 0x%Lx&quot;
comma
(paren
r_int
r_int
)paren
id|deltaxcn
comma
(paren
r_int
r_int
)paren
id|max_cluster
)paren
suffix:semicolon
r_goto
id|mpa_err
suffix:semicolon
)brace
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
)brace
r_else
multiline_comment|/* Not the base extent. There may be more extents to follow. */
id|rl
(braket
id|rlpos
)braket
dot
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Setup terminating run_list element. */
id|rl
(braket
id|rlpos
)braket
dot
id|vcn
op_assign
id|vcn
suffix:semicolon
id|rl
(braket
id|rlpos
)braket
dot
id|length
op_assign
(paren
id|s64
)paren
l_int|0
suffix:semicolon
multiline_comment|/* If no existing run list was specified, we are done. */
r_if
c_cond
(paren
op_logical_neg
id|old_rl
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping pairs array successfully decompressed:&quot;
)paren
suffix:semicolon
id|ntfs_debug_dump_runlist
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|rl
suffix:semicolon
)brace
multiline_comment|/* Now combine the new and old run lists checking for overlaps. */
id|old_rl
op_assign
id|ntfs_merge_run_lists
c_func
(paren
id|old_rl
comma
id|rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|old_rl
)paren
)paren
)paren
r_return
id|old_rl
suffix:semicolon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to merge run lists.&quot;
)paren
suffix:semicolon
r_return
id|old_rl
suffix:semicolon
id|io_error
suffix:colon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Corrupt attribute.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|ntfs_free
c_func
(paren
id|rl
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * map_run_list - map (a part of) a run list of an ntfs inode&n; * @ni:&t;&t;ntfs inode for which to map (part of) a run list &n; * @vcn:&t;map run list part containing this vcn&n; *&n; * Map the part of a run list containing the @vcn of an the ntfs inode @ni.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|map_run_list
r_int
id|map_run_list
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|VCN
id|vcn
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping run list part containing vcn 0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|base_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|IGNORE_CASE
comma
id|vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|down_write
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* Make sure someone else didn&squot;t do the work while we were sleeping. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|vcn_to_lcn
c_func
(paren
id|ni-&gt;run_list.rl
comma
id|vcn
)paren
op_le
id|LCN_RL_NOT_MAPPED
)paren
)paren
(brace
id|run_list_element
op_star
id|rl
suffix:semicolon
id|rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|ni-&gt;vol
comma
id|ctx-&gt;attr
comma
id|ni-&gt;run_list.rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
)paren
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
r_else
id|ni-&gt;run_list.rl
op_assign
id|rl
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * vcn_to_lcn - convert a vcn into a lcn given a run list&n; * @rl:&t;&t;run list to use for conversion&n; * @vcn:&t;vcn to convert&n; *&n; * Convert the virtual cluster number @vcn of an attribute into a logical&n; * cluster number (lcn) of a device using the run list @rl to map vcns to their&n; * corresponding lcns.&n; *&n; * It is up to the caller to serialize access to the run list @rl.&n; *&n; * Since lcns must be &gt;= 0, we use negative return values with special meaning:&n; *&n; * Return value&t;&t;&t;Meaning / Description&n; * ==================================================&n; *  -1 = LCN_HOLE&t;&t;Hole / not allocated on disk.&n; *  -2 = LCN_RL_NOT_MAPPED&t;This is part of the run list which has not been&n; *&t;&t;&t;&t;inserted into the run list yet.&n; *  -3 = LCN_ENOENT&t;&t;There is no such vcn in the attribute.&n; *  -4 = LCN_EINVAL&t;&t;Input parameter error (if debug enabled).&n; */
DECL|function|vcn_to_lcn
id|LCN
id|vcn_to_lcn
c_func
(paren
r_const
id|run_list_element
op_star
id|rl
comma
r_const
id|VCN
id|vcn
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|vcn
OL
(paren
id|VCN
)paren
l_int|0
)paren
r_return
(paren
id|LCN
)paren
id|LCN_EINVAL
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If rl is NULL, assume that we have found an unmapped run list. The&n;&t; * caller can then attempt to map it and fail appropriately if&n;&t; * necessary.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|rl
)paren
)paren
r_return
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Catch out of lower bounds vcn. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
r_return
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|length
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|vcn
OL
id|rl
(braket
id|i
op_plus
l_int|1
)braket
dot
id|vcn
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
op_ge
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
op_plus
(paren
id|vcn
op_minus
id|rl
(braket
id|i
)braket
dot
id|vcn
)paren
suffix:semicolon
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The terminator element is setup to the correct value, i.e. one of&n;&t; * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.&n;&t; */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
(braket
id|i
)braket
dot
id|lcn
OL
(paren
id|LCN
)paren
l_int|0
)paren
)paren
r_return
id|rl
(braket
id|i
)braket
dot
id|lcn
suffix:semicolon
multiline_comment|/* Just in case... We could replace this with BUG() some day. */
r_return
(paren
id|LCN
)paren
id|LCN_ENOENT
suffix:semicolon
)brace
multiline_comment|/**&n; * find_attr - find (next) attribute in mft record&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * You shouldn&squot;t need to call this function directly. Use lookup_attr() instead.&n; *&n; * find_attr() takes a search context @ctx as parameter and searches the mft&n; * record specified by @ctx-&gt;mrec, beginning at @ctx-&gt;attr, for an attribute of&n; * @type, optionally @name and @val. If found, find_attr() returns TRUE and&n; * @ctx-&gt;attr will point to the found attribute. If not found, find_attr()&n; * returns FALSE and @ctx-&gt;attr is undefined (i.e. do not rely on it not&n; * changing).&n; *&n; * If @ctx-&gt;is_first is TRUE, the search begins with @ctx-&gt;attr itself. If it&n; * is FALSE, the search begins after @ctx-&gt;attr.&n; *&n; * If @ic is IGNORE_CASE, the @name comparisson is not case sensitive and&n; * @ctx-&gt;ntfs_ino must be set to the ntfs inode to which the mft record&n; * @ctx-&gt;mrec belongs. This is so we can get at the ntfs volume and hence at&n; * the upcase table. If @ic is CASE_SENSITIVE, the comparison is case&n; * sensitive. When @name is present, @name_len is the @name length in Unicode&n; * characters.&n; *&n; * If @name is not present (NULL), we assume that the unnamed attribute is&n; * being searched for.&n; *&n; * Finally, the resident attribute value @val is looked for, if present. If @val&n; * is not present (NULL), @val_len is ignored.&n; *&n; * find_attr() only searches the specified mft record and it ignores the&n; * presence of an attribute list attribute (unless it is the one being searched&n; * for, obviously). If you need to take attribute lists into consideration, use&n; * lookup_attr() instead (see below). This also means that you cannot use&n; * find_attr() to search for extent records of non-resident attributes, as&n; * extents with lowest_vcn != 0 are usually described by the attribute list&n; * attribute only. - Note that it is possible that the first extent is only in&n; * the attribute list while the last extent is in the base mft record, so don&squot;t&n; * rely on being able to find the first extent in the base mft record.&n; *&n; * Warning: Never use @val when looking for attribute types which can be&n; *&t;    non-resident as this most likely will result in a crash!&n; */
DECL|function|find_attr
id|BOOL
id|find_attr
c_func
(paren
r_const
id|ATTR_TYPES
id|type
comma
r_const
id|uchar_t
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|attr_search_context
op_star
id|ctx
)paren
(brace
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|uchar_t
op_star
id|upcase
suffix:semicolon
id|u32
id|upcase_len
suffix:semicolon
r_if
c_cond
(paren
id|ic
op_eq
id|IGNORE_CASE
)paren
(brace
id|vol
op_assign
id|ctx-&gt;ntfs_ino-&gt;vol
suffix:semicolon
id|upcase
op_assign
id|vol-&gt;upcase
suffix:semicolon
id|upcase_len
op_assign
id|vol-&gt;upcase_len
suffix:semicolon
)brace
r_else
(brace
id|vol
op_assign
l_int|NULL
suffix:semicolon
id|upcase
op_assign
l_int|NULL
suffix:semicolon
id|upcase_len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Iterate over attributes in mft record starting at @ctx-&gt;attr, or the&n;&t; * attribute following that, if @ctx-&gt;is_first is TRUE.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;is_first
)paren
(brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;length
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|a
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_allocated
)paren
)paren
r_break
suffix:semicolon
id|ctx-&gt;attr
op_assign
id|a
suffix:semicolon
multiline_comment|/* We catch $END with this more general check, too... */
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|a-&gt;type
)paren
OG
id|le32_to_cpu
c_func
(paren
id|type
)paren
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|a-&gt;length
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
op_ne
id|type
)paren
r_continue
suffix:semicolon
multiline_comment|/* &n;&t;&t; * If @name is present, compare the two names. If @name is&n;&t;&t; * missing, assume we want an unnamed attribute.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
multiline_comment|/* The search failed if the found attribute is named. */
r_if
c_cond
(paren
id|a-&gt;name_length
)paren
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
id|ic
comma
id|upcase
comma
id|upcase_len
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|upcase
comma
id|upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @name collates before a-&gt;name, there is no&n;&t;&t;&t; * matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
id|FALSE
suffix:semicolon
multiline_comment|/* If the strings are not equal, continue search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|upcase
comma
id|upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The names match or @name not present and attribute is&n;&t;&t; * unnamed. If no @val specified, we have found the attribute&n;&t;&t; * and are done.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
r_return
id|TRUE
suffix:semicolon
multiline_comment|/* @val is present; compare values. */
r_else
(brace
id|u32
id|vl
suffix:semicolon
r_register
r_int
id|rc
suffix:semicolon
id|vl
op_assign
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vl
OG
id|val_len
)paren
id|vl
op_assign
id|val_len
suffix:semicolon
id|rc
op_assign
id|memcmp
c_func
(paren
id|val
comma
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_offset
)paren
comma
id|vl
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @val collates before the current attribute&squot;s&n;&t;&t;&t; * value, there is no matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
r_register
id|u32
id|avl
suffix:semicolon
id|avl
op_assign
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val_len
op_eq
id|avl
)paren
r_return
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|val_len
OL
id|avl
)paren
r_return
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|FALSE
suffix:semicolon
)brace
)brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Inode is corrupt. Run chkdsk.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * load_attribute_list - load an attribute list into memory&n; * @vol:&t;&t;ntfs volume from which to read&n; * @run_list:&t;&t;run list of the attribute list&n; * @al_start:&t;&t;destination buffer&n; * @size:&t;&t;size of the destination buffer in bytes&n; * @initialized_size:&t;initialized size of the attribute list&n; *&n; * Walk the run list @run_list and load all clusters from it copying them into&n; * the linear buffer @al. The maximum number of bytes copied to @al is @size&n; * bytes. Note, @size does not need to be a multiple of the cluster size. If&n; * @initialized_size is less than @size, the region in @al between&n; * @initialized_size and @size will be zeroed and not read from disk.&n; *&n; * Return 0 on success or -errno on error.&n; */
DECL|function|load_attribute_list
r_int
id|load_attribute_list
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|run_list
op_star
id|run_list
comma
id|u8
op_star
id|al_start
comma
r_const
id|s64
id|size
comma
r_const
id|s64
id|initialized_size
)paren
(brace
id|LCN
id|lcn
suffix:semicolon
id|u8
op_star
id|al
op_assign
id|al_start
suffix:semicolon
id|u8
op_star
id|al_end
op_assign
id|al
op_plus
id|initialized_size
suffix:semicolon
id|run_list_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
r_int
r_int
id|block_size
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
r_int
r_int
id|block
comma
id|max_block
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|block_size_bits
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol
op_logical_or
op_logical_neg
id|run_list
op_logical_or
op_logical_neg
id|al
op_logical_or
id|size
op_le
l_int|0
op_logical_or
id|initialized_size
template_param
id|size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialized_size
)paren
(brace
id|memset
c_func
(paren
id|al
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|down_read
c_func
(paren
op_amp
id|run_list-&gt;lock
)paren
suffix:semicolon
id|rl
op_assign
id|run_list-&gt;rl
suffix:semicolon
multiline_comment|/* Read all clusters specified by the run list one run at a time. */
r_while
c_loop
(paren
id|rl-&gt;length
)paren
(brace
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|rl
comma
id|rl-&gt;vcn
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading vcn = 0x%Lx, lcn = 0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|rl-&gt;vcn
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
multiline_comment|/* The attribute list cannot be sparse. */
r_if
c_cond
(paren
id|lcn
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;vcn_to_lcn() failed. Cannot read &quot;
l_string|&quot;attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|block
op_assign
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
suffix:semicolon
multiline_comment|/* Read the run from device in chunks of block_size bytes. */
id|max_block
op_assign
id|block
op_plus
(paren
id|rl-&gt;length
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;max_block = 0x%lx.&quot;
comma
id|max_block
)paren
suffix:semicolon
r_do
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading block = 0x%lx.&quot;
comma
id|block
)paren
suffix:semicolon
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;sb_bread() failed. Cannot &quot;
l_string|&quot;read attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|al
op_plus
id|block_size
op_ge
id|al_end
)paren
r_goto
id|do_final
suffix:semicolon
id|memcpy
c_func
(paren
id|al
comma
id|bh-&gt;b_data
comma
id|block_size
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|al
op_add_assign
id|block_size
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|block
OL
id|max_block
)paren
suffix:semicolon
id|rl
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|initialized_size
OL
id|size
)paren
(brace
id|initialize
suffix:colon
id|memset
c_func
(paren
id|al_start
op_plus
id|initialized_size
comma
l_int|0
comma
id|size
op_minus
id|initialized_size
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|up_read
c_func
(paren
op_amp
id|run_list-&gt;lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|do_final
suffix:colon
r_if
c_cond
(paren
id|al
OL
id|al_end
)paren
(brace
multiline_comment|/*&n;&t;&t; * Partial block.&n;&t;&t; *&n;&t;&t; * Note: The attribute list can be smaller than its allocation&n;&t;&t; * by multiple clusters.  This has been encountered by at least&n;&t;&t; * two people running Windows XP, thus we cannot do any&n;&t;&t; * truncation sanity checking here. (AIA)&n;&t;&t; */
id|memcpy
c_func
(paren
id|al
comma
id|bh-&gt;b_data
comma
id|al_end
op_minus
id|al
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initialized_size
OL
id|size
)paren
r_goto
id|initialize
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Real overflow! */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list buffer overflow. Read attribute list &quot;
l_string|&quot;is truncated.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/**&n; * find_external_attr - find an attribute in the attribute list of an ntfs inode&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @lowest_vcn:&t;lowest vcn to find (optional, non-resident attributes only)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * You shouldn&squot;t need to call this function directly. Use lookup_attr() instead.&n; *&n; * Find an attribute by searching the attribute list for the corresponding&n; * attribute list entry. Having found the entry, map the mft record for read&n; * if the attribute is in a different mft record/inode, find_attr the attribute&n; * in there and return it.&n; *&n; * On first search @ctx-&gt;ntfs_ino must be the base mft record and @ctx must&n; * have been obtained from a call to get_attr_search_ctx(). On subsequent calls&n; * @ctx-&gt;ntfs_ino can be any extent inode, too (@ctx-&gt;base_ntfs_ino is then the&n; * base inode).&n; *&n; * After finishing with the attribute/mft record you need to call&n; * release_attr_search_ctx() to cleanup the search context (unmapping any&n; * mapped inodes, etc).&n; *&n; * Return TRUE if the search was successful and FALSE if not. When TRUE,&n; * @ctx-&gt;attr is the found attribute and it is in mft record @ctx-&gt;mrec. When&n; * FALSE, @ctx-&gt;attr is the attribute which collates just after the attribute&n; * being searched for in the base ntfs inode, i.e. if one wants to add the&n; * attribute to the mft record this is the correct place to insert it into&n; * and if there is not enough space, the attribute should be placed in an&n; * extent mft record.&n; */
DECL|function|find_external_attr
r_static
id|BOOL
id|find_external_attr
c_func
(paren
r_const
id|ATTR_TYPES
id|type
comma
r_const
id|uchar_t
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|VCN
id|lowest_vcn
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|attr_search_context
op_star
id|ctx
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
comma
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|ATTR_LIST_ENTRY
op_star
id|al_entry
comma
op_star
id|next_al_entry
suffix:semicolon
id|u8
op_star
id|al_start
comma
op_star
id|al_end
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|uchar_t
op_star
id|al_name
suffix:semicolon
id|u32
id|al_name_len
suffix:semicolon
id|ni
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, type 0x%x.&quot;
comma
id|ni-&gt;mft_no
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_ni
)paren
(brace
multiline_comment|/* First call happens with the base mft record. */
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
id|ctx-&gt;base_mrec
op_assign
id|ctx-&gt;mrec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_eq
id|base_ni
)paren
id|ctx-&gt;base_attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|vol
op_assign
id|base_ni-&gt;vol
suffix:semicolon
id|al_start
op_assign
id|base_ni-&gt;attr_list
suffix:semicolon
id|al_end
op_assign
id|al_start
op_plus
id|base_ni-&gt;attr_list_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;al_entry
)paren
id|ctx-&gt;al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
id|al_start
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate over entries in attribute list starting at @ctx-&gt;al_entry,&n;&t; * or the entry following that, if @ctx-&gt;is_first is TRUE.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;is_first
)paren
(brace
id|al_entry
op_assign
id|ctx-&gt;al_entry
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
id|al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|al_entry
op_assign
id|next_al_entry
)paren
(brace
multiline_comment|/* Out of bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
template_param
id|al_end
)paren
r_break
suffix:semicolon
multiline_comment|/* Inode is corrupt. */
id|ctx-&gt;al_entry
op_assign
id|al_entry
suffix:semicolon
multiline_comment|/* Catch the end of the attribute list. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_eq
id|al_end
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|al_entry-&gt;length
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
l_int|6
OG
id|al_end
op_logical_or
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
OG
id|al_end
)paren
r_break
suffix:semicolon
id|next_al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|al_entry-&gt;type
)paren
OG
id|le32_to_cpu
c_func
(paren
id|type
)paren
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|al_entry-&gt;type
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If @name is present, compare the two names. If @name is&n;&t;&t; * missing, assume we want an unnamed attribute.&n;&t;&t; */
id|al_name_len
op_assign
id|al_entry-&gt;name_length
suffix:semicolon
id|al_name
op_assign
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|al_entry-&gt;name_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_if
c_cond
(paren
id|al_name_len
)paren
r_goto
id|not_found
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
id|al_name
comma
id|al_name_len
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
id|al_name
comma
id|al_name_len
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @name collates before al_name, there is no&n;&t;&t;&t; * matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_goto
id|not_found
suffix:semicolon
multiline_comment|/* If the strings are not equal, continue search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FIXME: Reverse engineering showed 0, IGNORE_CASE but&n;&t;&t;&t; * that is inconsistent with find_attr(). The subsequent&n;&t;&t;&t; * rc checks were also different. Perhaps I made a&n;&t;&t;&t; * mistake in one of the two. Need to recheck which is&n;&t;&t;&t; * correct or at least see what is going on... (AIA)&n;&t;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
id|al_name
comma
id|al_name_len
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The names match or @name not present and attribute is&n;&t;&t; * unnamed. Now check @lowest_vcn. Continue search if the&n;&t;&t; * next attribute list entry still fits @lowest_vcn. Otherwise&n;&t;&t; * we have reached the right one or the search has failed.&n;&t;&t; */
r_if
c_cond
(paren
id|lowest_vcn
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_ge
id|al_start
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
l_int|6
OL
id|al_end
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|next_al_entry-&gt;length
)paren
op_le
id|al_end
op_logical_and
id|sle64_to_cpu
c_func
(paren
id|next_al_entry-&gt;lowest_vcn
)paren
op_le
id|sle64_to_cpu
c_func
(paren
id|lowest_vcn
)paren
op_logical_and
id|next_al_entry-&gt;type
op_eq
id|al_entry-&gt;type
op_logical_and
id|next_al_entry-&gt;name_length
op_eq
id|al_name_len
op_logical_and
id|ntfs_are_names_equal
c_func
(paren
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
id|next_al_entry-&gt;name_offset
)paren
comma
id|next_al_entry-&gt;name_length
comma
id|al_name
comma
id|al_name_len
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_eq
id|ni-&gt;mft_no
)paren
(brace
r_if
c_cond
(paren
id|MSEQNO_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|ni-&gt;seq_no
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Found stale mft &quot;
l_string|&quot;reference in attribute list!&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Mft references do not match. */
multiline_comment|/* If there is a mapped record unmap it first. */
r_if
c_cond
(paren
id|ni
op_ne
id|base_ni
)paren
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Do we want the base record back? */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_eq
id|base_ni-&gt;mft_no
)paren
(brace
id|ni
op_assign
id|ctx-&gt;ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ctx-&gt;mrec
op_assign
id|ctx-&gt;base_mrec
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We want an extent record. */
id|ctx-&gt;mrec
op_assign
id|map_extent_mft_record
c_func
(paren
id|base_ni
comma
id|al_entry-&gt;mft_reference
comma
op_amp
id|ni
)paren
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|ni
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ctx-&gt;mrec
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map mft &quot;
l_string|&quot;record, error code &quot;
l_string|&quot;%ld.&quot;
comma
op_minus
id|PTR_ERR
c_func
(paren
id|ctx-&gt;mrec
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * ctx-&gt;vfs_ino, ctx-&gt;mrec, and ctx-&gt;attr now point to the&n;&t;&t; * mft record containing the attribute represented by the&n;&t;&t; * current al_entry.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * We could call into find_attr() to find the right attribute&n;&t;&t; * in this mft record but this would be less efficient and not&n;&t;&t; * quite accurate as find_attr() ignores the attribute instance&n;&t;&t; * numbers for example which become important when one plays&n;&t;&t; * with attribute lists. Also, because a proper match has been&n;&t;&t; * found in the attribute list entry above, the comparison can&n;&t;&t; * now be optimized. So it is worth re-implementing a&n;&t;&t; * simplified find_attr() here.&n;&t;&t; */
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Use a manual loop so we can still use break and continue&n;&t;&t; * with the same meanings as above.&n;&t;&t; */
id|do_next_attr_loop
suffix:colon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|a
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_allocated
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
op_eq
id|AT_END
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;length
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|al_entry-&gt;instance
op_ne
id|a-&gt;instance
)paren
r_goto
id|do_next_attr
suffix:semicolon
r_if
c_cond
(paren
id|al_entry-&gt;type
op_ne
id|a-&gt;type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;name_length
op_ne
id|al_name_len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
(paren
id|uchar_t
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
id|al_name
comma
id|al_name_len
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
r_continue
suffix:semicolon
)brace
id|ctx-&gt;attr
op_assign
id|a
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If no @val specified or @val specified and it matches, we&n;&t;&t; * have found it!&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|val
op_logical_or
(paren
op_logical_neg
id|a-&gt;non_resident
op_logical_and
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
op_eq
id|val_len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_offset
)paren
comma
id|val
comma
id|val_len
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done, found.&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|do_next_attr
suffix:colon
multiline_comment|/* Proceed to the next attribute in the current mft record. */
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
)paren
suffix:semicolon
r_goto
id|do_next_attr_loop
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
id|base_ni-&gt;vol-&gt;sb
comma
l_string|&quot;Inode contains corrupt attribute list &quot;
l_string|&quot;attribute.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ni
op_ne
id|base_ni
)paren
(brace
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ctx-&gt;mrec
op_assign
id|ctx-&gt;base_mrec
suffix:semicolon
id|ctx-&gt;attr
op_assign
id|ctx-&gt;base_attr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * FIXME: We absolutely have to return ERROR status instead of just&n;&t; * false or we will blow up or even worse cause corruption when we add&n;&t; * write support and we reach this code path!&n;&t; */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;NTFS: FIXME: Hit unfinished error code path!!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
id|not_found
suffix:colon
multiline_comment|/*&n;&t; * Seek to the end of the base mft record, i.e. when we return false,&n;&t; * ctx-&gt;mrec and ctx-&gt;attr indicate where the attribute should be&n;&t; * inserted into the attribute record.&n;&t; * And of course ctx-&gt;al_entry points to the end of the attribute&n;&t; * list inside NTFS_I(ctx-&gt;base_vfs_ino)-&gt;attr_list.&n;&t; *&n;&t; * FIXME: Do we really want to do this here? Think about it... (AIA)&n;&t; */
id|reinit_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|find_attr
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done, not found.&quot;
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/**&n; * lookup_attr - find an attribute in an ntfs inode&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @lowest_vcn:&t;lowest vcn to find (optional, non-resident attributes only)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * Find an attribute in an ntfs inode. On first search @ctx-&gt;ntfs_ino must&n; * be the base mft record and @ctx must have been obtained from a call to&n; * get_attr_search_ctx().&n; *&n; * This function transparently handles attribute lists and @ctx is used to&n; * continue searches where they were left off at.&n; *&n; * After finishing with the attribute/mft record you need to call&n; * release_attr_search_ctx() to cleanup the search context (unmapping any&n; * mapped inodes, etc).&n; *&n; * Return TRUE if the search was successful and FALSE if not. When TRUE,&n; * @ctx-&gt;attr is the found attribute and it is in mft record @ctx-&gt;mrec. When&n; * FALSE, @ctx-&gt;attr is the attribute which collates just after the attribute&n; * being searched for, i.e. if one wants to add the attribute to the mft&n; * record this is the correct place to insert it into.&n; */
DECL|function|lookup_attr
id|BOOL
id|lookup_attr
c_func
(paren
r_const
id|ATTR_TYPES
id|type
comma
r_const
id|uchar_t
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|VCN
id|lowest_vcn
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|attr_search_context
op_star
id|ctx
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;base_ntfs_ino
)paren
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
suffix:semicolon
r_else
id|base_ni
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
multiline_comment|/* Sanity check, just for debugging really. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoAttrList
c_func
(paren
id|base_ni
)paren
)paren
r_return
id|find_attr
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
r_return
id|find_external_attr
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|lowest_vcn
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * init_attr_search_ctx - initialize an attribute search context&n; * @ctx:&t;attribute search context to initialize&n; * @ni:&t;&t;ntfs inode with which to initialize the search context&n; * @mrec:&t;mft record with which to initialize the search context&n; *&n; * Initialize the attribute search context @ctx with @ni and @mrec.&n; */
DECL|function|init_attr_search_ctx
r_static
r_inline
r_void
id|init_attr_search_ctx
c_func
(paren
id|attr_search_context
op_star
id|ctx
comma
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mrec
)paren
(brace
id|ctx-&gt;mrec
op_assign
id|mrec
suffix:semicolon
multiline_comment|/* Sanity checks are performed elsewhere. */
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|TRUE
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|ni
suffix:semicolon
id|ctx-&gt;al_entry
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_ntfs_ino
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_mrec
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_attr
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * reinit_attr_search_ctx - reinitialize an attribute search context&n; * @ctx:&t;attribute search context to reinitialize&n; *&n; * Reinitialize the attribute search context @ctx, unmapping an associated&n; * extent mft record if present, and initialize the search context again.&n; *&n; * This is used when a search for a new attribute is being started to reset&n; * the search context to the beginning.&n; */
DECL|function|reinit_attr_search_ctx
r_void
id|reinit_attr_search_ctx
c_func
(paren
id|attr_search_context
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|ctx-&gt;base_ntfs_ino
)paren
)paren
(brace
multiline_comment|/* No attribute list. */
id|ctx-&gt;is_first
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Sanity checks are performed elsewhere. */
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Attribute list. */
r_if
c_cond
(paren
id|ctx-&gt;ntfs_ino
op_ne
id|ctx-&gt;base_ntfs_ino
)paren
id|unmap_extent_mft_record
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|init_attr_search_ctx
c_func
(paren
id|ctx
comma
id|ctx-&gt;base_ntfs_ino
comma
id|ctx-&gt;base_mrec
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * get_attr_search_ctx - allocate and initialize a new attribute search context&n; * @ni:&t;&t;ntfs inode with which to initialize the search context&n; * @mrec:&t;mft record with which to initialize the search context&n; *&n; * Allocate a new attribute search context, initialize it with @ni and @mrec,&n; * and return it. Return NULL if allocation failed.&n; */
DECL|function|get_attr_search_ctx
id|attr_search_context
op_star
id|get_attr_search_ctx
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mrec
)paren
(brace
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|ctx
op_assign
id|kmem_cache_alloc
c_func
(paren
id|ntfs_attr_ctx_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|init_attr_search_ctx
c_func
(paren
id|ctx
comma
id|ni
comma
id|mrec
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
)brace
multiline_comment|/**&n; * put_attr_search_ctx - release an attribute search context&n; * @ctx:&t;attribute search context to free&n; *&n; * Release the attribute search context @ctx, unmapping an associated extent&n; * mft record if present.&n; */
DECL|function|put_attr_search_ctx
r_void
id|put_attr_search_ctx
c_func
(paren
id|attr_search_context
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;base_ntfs_ino
op_logical_and
id|ctx-&gt;ntfs_ino
op_ne
id|ctx-&gt;base_ntfs_ino
)paren
id|unmap_extent_mft_record
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_attr_ctx_cache
comma
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
