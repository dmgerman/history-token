multiline_comment|/**&n; * attrib.c - NTFS attribute operations.  Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;ntfs.h&quot;
singleline_comment|//#include &quot;dir.h&quot;
multiline_comment|/**&n; * ntfs_map_runlist - map (a part of) a runlist of an ntfs inode&n; * @ni:&t;&t;ntfs inode for which to map (part of) a runlist&n; * @vcn:&t;map runlist part containing this vcn&n; *&n; * Map the part of a runlist containing the @vcn of the ntfs inode @ni.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Locking: - The runlist must be unlocked on entry and is unlocked on return.&n; *&t;    - This function takes the lock for writing and modifies the runlist.&n; */
DECL|function|ntfs_map_runlist
r_int
id|ntfs_map_runlist
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|VCN
id|vcn
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Mapping runlist part containing vcn 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|base_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
id|vcn
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|put_err_out
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
multiline_comment|/* Make sure someone else didn&squot;t do the work while we were sleeping. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|ntfs_vcn_to_lcn
c_func
(paren
id|ni-&gt;runlist.rl
comma
id|vcn
)paren
op_le
id|LCN_RL_NOT_MAPPED
)paren
)paren
(brace
id|runlist_element
op_star
id|rl
suffix:semicolon
id|rl
op_assign
id|decompress_mapping_pairs
c_func
(paren
id|ni-&gt;vol
comma
id|ctx-&gt;attr
comma
id|ni-&gt;runlist.rl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rl
)paren
)paren
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|rl
)paren
suffix:semicolon
r_else
id|ni-&gt;runlist.rl
op_assign
id|rl
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|put_err_out
suffix:colon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_find_vcn - find a vcn in the runlist described by an ntfs inode&n; * @ni:&t;&t;ntfs inode describing the runlist to search&n; * @vcn:&t;vcn to find&n; * @need_write:&t;if false, lock for reading and if true, lock for writing&n; *&n; * Find the virtual cluster number @vcn in the runlist described by the ntfs&n; * inode @ni and return the address of the runlist element containing the @vcn.&n; * The runlist is left locked and the caller has to unlock it.  If @need_write&n; * is true, the runlist is locked for writing and if @need_write is false, the&n; * runlist is locked for reading.  In the error case, the runlist is not left&n; * locked.&n; *&n; * Note you need to distinguish between the lcn of the returned runlist element&n; * being &gt;= 0 and LCN_HOLE.  In the later case you have to return zeroes on&n; * read and allocate clusters on write.&n; *&n; * Return the runlist element containing the @vcn on success and&n; * ERR_PTR(-errno) on error.  You need to test the return value with IS_ERR()&n; * to decide if the return is success or failure and PTR_ERR() to get to the&n; * error code if IS_ERR() is true.&n; *&n; * The possible error return codes are:&n; *&t;-ENOENT - No such vcn in the runlist, i.e. @vcn is out of bounds.&n; *&t;-ENOMEM - Not enough memory to map runlist.&n; *&t;-EIO&t;- Critical error (runlist/file is corrupt, i/o error, etc).&n; *&n; * Locking: - The runlist must be unlocked on entry.&n; *&t;    - On failing return, the runlist is unlocked.&n; *&t;    - On successful return, the runlist is locked.  If @need_write us&n; *&t;      true, it is locked for writing.  Otherwise is is locked for&n; *&t;      reading.&n; */
DECL|function|ntfs_find_vcn
id|runlist_element
op_star
id|ntfs_find_vcn
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
r_const
id|VCN
id|vcn
comma
r_const
id|BOOL
id|need_write
)paren
(brace
id|runlist_element
op_star
id|rl
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for i_ino 0x%lx, vcn 0x%llx, lock for %sing.&quot;
comma
id|ni-&gt;mft_no
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
op_logical_neg
id|need_write
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vcn
OL
l_int|0
)paren
suffix:semicolon
id|lock_retry_remap
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|need_write
)paren
id|down_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
r_else
id|down_write
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;runlist.rl
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_logical_and
id|vcn
op_ge
id|rl
(braket
l_int|0
)braket
dot
id|vcn
)paren
)paren
(brace
r_while
c_loop
(paren
id|likely
c_func
(paren
id|rl-&gt;length
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|vcn
OL
id|rl
(braket
l_int|1
)braket
dot
id|vcn
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl-&gt;lcn
op_ge
(paren
id|LCN
)paren
id|LCN_HOLE
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|rl
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|rl
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl-&gt;lcn
op_ne
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl-&gt;lcn
op_eq
(paren
id|LCN
)paren
id|LCN_ENOENT
)paren
)paren
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|need_write
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
r_else
id|up_write
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
op_logical_neg
id|is_retry
)paren
(brace
multiline_comment|/*&n;&t;&t; * The @vcn is in an unmapped region, map the runlist and&n;&t;&t; * retry.&n;&t;&t; */
id|err
op_assign
id|ntfs_map_runlist
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
r_goto
id|lock_retry_remap
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * -EINVAL and -ENOENT coming from a failed mapping attempt are&n;&t;&t; * equivalent to i/o errors for us as they should not happen in&n;&t;&t; * our code paths.&n;&t;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
op_logical_or
id|err
op_eq
op_minus
id|ENOENT
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Failed with error code %i.&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_find - find (next) attribute in mft record&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * You should not need to call this function directly.  Use ntfs_attr_lookup()&n; * instead.&n; *&n; * ntfs_attr_find() takes a search context @ctx as parameter and searches the&n; * mft record specified by @ctx-&gt;mrec, beginning at @ctx-&gt;attr, for an&n; * attribute of @type, optionally @name and @val.&n; *&n; * If the attribute is found, ntfs_attr_find() returns 0 and @ctx-&gt;attr will&n; * point to the found attribute.&n; *&n; * If the attribute is not found, ntfs_attr_find() returns -ENOENT and&n; * @ctx-&gt;attr will point to the attribute before which the attribute being&n; * searched for would need to be inserted if such an action were to be desired.&n; *&n; * On actual error, ntfs_attr_find() returns -EIO.  In this case @ctx-&gt;attr is&n; * undefined and in particular do not rely on it not changing.&n; *&n; * If @ctx-&gt;is_first is TRUE, the search begins with @ctx-&gt;attr itself.  If it&n; * is FALSE, the search begins after @ctx-&gt;attr.&n; *&n; * If @ic is IGNORE_CASE, the @name comparisson is not case sensitive and&n; * @ctx-&gt;ntfs_ino must be set to the ntfs inode to which the mft record&n; * @ctx-&gt;mrec belongs.  This is so we can get at the ntfs volume and hence at&n; * the upcase table.  If @ic is CASE_SENSITIVE, the comparison is case&n; * sensitive.  When @name is present, @name_len is the @name length in Unicode&n; * characters.&n; *&n; * If @name is not present (NULL), we assume that the unnamed attribute is&n; * being searched for.&n; *&n; * Finally, the resident attribute value @val is looked for, if present.  If&n; * @val is not present (NULL), @val_len is ignored.&n; *&n; * ntfs_attr_find() only searches the specified mft record and it ignores the&n; * presence of an attribute list attribute (unless it is the one being searched&n; * for, obviously).  If you need to take attribute lists into consideration,&n; * use ntfs_attr_lookup() instead (see below).  This also means that you cannot&n; * use ntfs_attr_find() to search for extent records of non-resident&n; * attributes, as extents with lowest_vcn != 0 are usually described by the&n; * attribute list attribute only. - Note that it is possible that the first&n; * extent is only in the attribute list while the last extent is in the base&n; * mft record, so do not rely on being able to find the first extent in the&n; * base mft record.&n; *&n; * Warning: Never use @val when looking for attribute types which can be&n; *&t;    non-resident as this most likely will result in a crash!&n; */
DECL|function|ntfs_attr_find
r_static
r_int
id|ntfs_attr_find
c_func
(paren
r_const
id|ATTR_TYPE
id|type
comma
r_const
id|ntfschar
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|ntfs_attr_search_ctx
op_star
id|ctx
)paren
(brace
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|ntfschar
op_star
id|upcase
suffix:semicolon
id|u32
id|upcase_len
suffix:semicolon
r_if
c_cond
(paren
id|ic
op_eq
id|IGNORE_CASE
)paren
(brace
id|vol
op_assign
id|ctx-&gt;ntfs_ino-&gt;vol
suffix:semicolon
id|upcase
op_assign
id|vol-&gt;upcase
suffix:semicolon
id|upcase_len
op_assign
id|vol-&gt;upcase_len
suffix:semicolon
)brace
r_else
(brace
id|vol
op_assign
l_int|NULL
suffix:semicolon
id|upcase
op_assign
l_int|NULL
suffix:semicolon
id|upcase_len
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Iterate over attributes in mft record starting at @ctx-&gt;attr, or the&n;&t; * attribute following that, if @ctx-&gt;is_first is TRUE.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;is_first
)paren
(brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;length
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|a
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_allocated
)paren
)paren
r_break
suffix:semicolon
id|ctx-&gt;attr
op_assign
id|a
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|a-&gt;type
)paren
OG
id|le32_to_cpu
c_func
(paren
id|type
)paren
op_logical_or
id|a-&gt;type
op_eq
id|AT_END
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|a-&gt;length
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
op_ne
id|type
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If @name is present, compare the two names.  If @name is&n;&t;&t; * missing, assume we want an unnamed attribute.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
multiline_comment|/* The search failed if the found attribute is named. */
r_if
c_cond
(paren
id|a-&gt;name_length
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|ntfschar
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
id|ic
comma
id|upcase
comma
id|upcase_len
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|ntfschar
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|upcase
comma
id|upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @name collates before a-&gt;name, there is no&n;&t;&t;&t; * matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* If the strings are not equal, continue search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
(paren
id|ntfschar
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|upcase
comma
id|upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The names match or @name not present and attribute is&n;&t;&t; * unnamed.  If no @val specified, we have found the attribute&n;&t;&t; * and are done.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|val
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* @val is present; compare values. */
r_else
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|memcmp
c_func
(paren
id|val
comma
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_offset
)paren
comma
id|min_t
c_func
(paren
id|u32
comma
id|val_len
comma
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @val collates before the current attribute&squot;s&n;&t;&t;&t; * value, there is no matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
r_register
id|u32
id|avl
suffix:semicolon
id|avl
op_assign
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val_len
op_eq
id|avl
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|val_len
OL
id|avl
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
id|ntfs_error
c_func
(paren
l_int|NULL
comma
l_string|&quot;Inode is corrupt.  Run chkdsk.&quot;
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/**&n; * load_attribute_list - load an attribute list into memory&n; * @vol:&t;&t;ntfs volume from which to read&n; * @runlist:&t;&t;runlist of the attribute list&n; * @al_start:&t;&t;destination buffer&n; * @size:&t;&t;size of the destination buffer in bytes&n; * @initialized_size:&t;initialized size of the attribute list&n; *&n; * Walk the runlist @runlist and load all clusters from it copying them into&n; * the linear buffer @al. The maximum number of bytes copied to @al is @size&n; * bytes. Note, @size does not need to be a multiple of the cluster size. If&n; * @initialized_size is less than @size, the region in @al between&n; * @initialized_size and @size will be zeroed and not read from disk.&n; *&n; * Return 0 on success or -errno on error.&n; */
DECL|function|load_attribute_list
r_int
id|load_attribute_list
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|runlist
op_star
id|runlist
comma
id|u8
op_star
id|al_start
comma
r_const
id|s64
id|size
comma
r_const
id|s64
id|initialized_size
)paren
(brace
id|LCN
id|lcn
suffix:semicolon
id|u8
op_star
id|al
op_assign
id|al_start
suffix:semicolon
id|u8
op_star
id|al_end
op_assign
id|al
op_plus
id|initialized_size
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_int
r_int
id|block_size
suffix:semicolon
r_int
r_int
id|block
comma
id|max_block
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|block_size_bits
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vol
op_logical_or
op_logical_neg
id|runlist
op_logical_or
op_logical_neg
id|al
op_logical_or
id|size
op_le
l_int|0
op_logical_or
id|initialized_size
template_param
id|size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialized_size
)paren
(brace
id|memset
c_func
(paren
id|al
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sb
op_assign
id|vol-&gt;sb
suffix:semicolon
id|block_size
op_assign
id|sb-&gt;s_blocksize
suffix:semicolon
id|block_size_bits
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|runlist-&gt;lock
)paren
suffix:semicolon
id|rl
op_assign
id|runlist-&gt;rl
suffix:semicolon
multiline_comment|/* Read all clusters specified by the runlist one run at a time. */
r_while
c_loop
(paren
id|rl-&gt;length
)paren
(brace
id|lcn
op_assign
id|ntfs_vcn_to_lcn
c_func
(paren
id|rl
comma
id|rl-&gt;vcn
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading vcn = 0x%llx, lcn = 0x%llx.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|rl-&gt;vcn
comma
(paren
r_int
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
multiline_comment|/* The attribute list cannot be sparse. */
r_if
c_cond
(paren
id|lcn
OL
l_int|0
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;ntfs_vcn_to_lcn() failed. Cannot read &quot;
l_string|&quot;attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|block
op_assign
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
suffix:semicolon
multiline_comment|/* Read the run from device in chunks of block_size bytes. */
id|max_block
op_assign
id|block
op_plus
(paren
id|rl-&gt;length
op_lshift
id|vol-&gt;cluster_size_bits
op_rshift
id|block_size_bits
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;max_block = 0x%lx.&quot;
comma
id|max_block
)paren
suffix:semicolon
r_do
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Reading block = 0x%lx.&quot;
comma
id|block
)paren
suffix:semicolon
id|bh
op_assign
id|sb_bread
c_func
(paren
id|sb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;sb_bread() failed. Cannot &quot;
l_string|&quot;read attribute list.&quot;
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|al
op_plus
id|block_size
op_ge
id|al_end
)paren
r_goto
id|do_final
suffix:semicolon
id|memcpy
c_func
(paren
id|al
comma
id|bh-&gt;b_data
comma
id|block_size
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|al
op_add_assign
id|block_size
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|block
OL
id|max_block
)paren
suffix:semicolon
id|rl
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|initialized_size
OL
id|size
)paren
(brace
id|initialize
suffix:colon
id|memset
c_func
(paren
id|al_start
op_plus
id|initialized_size
comma
l_int|0
comma
id|size
op_minus
id|initialized_size
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|up_read
c_func
(paren
op_amp
id|runlist-&gt;lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|do_final
suffix:colon
r_if
c_cond
(paren
id|al
OL
id|al_end
)paren
(brace
multiline_comment|/*&n;&t;&t; * Partial block.&n;&t;&t; *&n;&t;&t; * Note: The attribute list can be smaller than its allocation&n;&t;&t; * by multiple clusters.  This has been encountered by at least&n;&t;&t; * two people running Windows XP, thus we cannot do any&n;&t;&t; * truncation sanity checking here. (AIA)&n;&t;&t; */
id|memcpy
c_func
(paren
id|al
comma
id|bh-&gt;b_data
comma
id|al_end
op_minus
id|al
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|initialized_size
OL
id|size
)paren
r_goto
id|initialize
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Real overflow! */
id|ntfs_error
c_func
(paren
id|sb
comma
l_string|&quot;Attribute list buffer overflow. Read attribute list &quot;
l_string|&quot;is truncated.&quot;
)paren
suffix:semicolon
id|err_out
suffix:colon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_external_attr_find - find an attribute in the attribute list of an inode&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @lowest_vcn:&t;lowest vcn to find (optional, non-resident attributes only)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * You should not need to call this function directly.  Use ntfs_attr_lookup()&n; * instead.&n; *&n; * Find an attribute by searching the attribute list for the corresponding&n; * attribute list entry.  Having found the entry, map the mft record if the&n; * attribute is in a different mft record/inode, ntfs_attr_find() the attribute&n; * in there and return it.&n; *&n; * On first search @ctx-&gt;ntfs_ino must be the base mft record and @ctx must&n; * have been obtained from a call to ntfs_attr_get_search_ctx().  On subsequent&n; * calls @ctx-&gt;ntfs_ino can be any extent inode, too (@ctx-&gt;base_ntfs_ino is&n; * then the base inode).&n; *&n; * After finishing with the attribute/mft record you need to call&n; * ntfs_attr_put_search_ctx() to cleanup the search context (unmapping any&n; * mapped inodes, etc).&n; *&n; * If the attribute is found, ntfs_external_attr_find() returns 0 and&n; * @ctx-&gt;attr will point to the found attribute.  @ctx-&gt;mrec will point to the&n; * mft record in which @ctx-&gt;attr is located and @ctx-&gt;al_entry will point to&n; * the attribute list entry for the attribute.&n; *&n; * If the attribute is not found, ntfs_external_attr_find() returns -ENOENT and&n; * @ctx-&gt;attr will point to the attribute in the base mft record before which&n; * the attribute being searched for would need to be inserted if such an action&n; * were to be desired.  @ctx-&gt;mrec will point to the mft record in which&n; * @ctx-&gt;attr is located and @ctx-&gt;al_entry will point to the attribute list&n; * entry of the attribute before which the attribute being searched for would&n; * need to be inserted if such an action were to be desired.&n; *&n; * Thus to insert the not found attribute, one wants to add the attribute to&n; * @ctx-&gt;mrec (the base mft record) and if there is not enough space, the&n; * attribute should be placed in a newly allocated extent mft record.  The&n; * attribute list entry for the inserted attribute should be inserted in the&n; * attribute list attribute at @ctx-&gt;al_entry.&n; *&n; * On actual error, ntfs_external_attr_find() returns -EIO.  In this case&n; * @ctx-&gt;attr is undefined and in particular do not rely on it not changing.&n; */
DECL|function|ntfs_external_attr_find
r_static
r_int
id|ntfs_external_attr_find
c_func
(paren
r_const
id|ATTR_TYPE
id|type
comma
r_const
id|ntfschar
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|VCN
id|lowest_vcn
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|ntfs_attr_search_ctx
op_star
id|ctx
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
comma
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|ATTR_LIST_ENTRY
op_star
id|al_entry
comma
op_star
id|next_al_entry
suffix:semicolon
id|u8
op_star
id|al_start
comma
op_star
id|al_end
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|ntfschar
op_star
id|al_name
suffix:semicolon
id|u32
id|al_name_len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_static
r_const
r_char
op_star
id|es
op_assign
l_string|&quot; Unmount and run chkdsk.&quot;
suffix:semicolon
id|ni
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, type 0x%x.&quot;
comma
id|ni-&gt;mft_no
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|base_ni
)paren
(brace
multiline_comment|/* First call happens with the base mft record. */
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
id|ctx-&gt;base_mrec
op_assign
id|ctx-&gt;mrec
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_eq
id|base_ni
)paren
id|ctx-&gt;base_attr
op_assign
id|ctx-&gt;attr
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|AT_END
)paren
r_goto
id|not_found
suffix:semicolon
id|vol
op_assign
id|base_ni-&gt;vol
suffix:semicolon
id|al_start
op_assign
id|base_ni-&gt;attr_list
suffix:semicolon
id|al_end
op_assign
id|al_start
op_plus
id|base_ni-&gt;attr_list_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctx-&gt;al_entry
)paren
id|ctx-&gt;al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
id|al_start
suffix:semicolon
multiline_comment|/*&n;&t; * Iterate over entries in attribute list starting at @ctx-&gt;al_entry,&n;&t; * or the entry following that, if @ctx-&gt;is_first is TRUE.&n;&t; */
r_if
c_cond
(paren
id|ctx-&gt;is_first
)paren
(brace
id|al_entry
op_assign
id|ctx-&gt;al_entry
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
id|al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
id|al_entry
op_assign
id|next_al_entry
)paren
(brace
multiline_comment|/* Out of bounds check. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
template_param
id|al_end
)paren
r_break
suffix:semicolon
multiline_comment|/* Inode is corrupt. */
id|ctx-&gt;al_entry
op_assign
id|al_entry
suffix:semicolon
multiline_comment|/* Catch the end of the attribute list. */
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_eq
id|al_end
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|al_entry-&gt;length
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
l_int|6
OG
id|al_end
op_logical_or
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
OG
id|al_end
)paren
r_break
suffix:semicolon
id|next_al_entry
op_assign
(paren
id|ATTR_LIST_ENTRY
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|al_entry-&gt;length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|al_entry-&gt;type
)paren
OG
id|le32_to_cpu
c_func
(paren
id|type
)paren
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|al_entry-&gt;type
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If @name is present, compare the two names.  If @name is&n;&t;&t; * missing, assume we want an unnamed attribute.&n;&t;&t; */
id|al_name_len
op_assign
id|al_entry-&gt;name_length
suffix:semicolon
id|al_name
op_assign
(paren
id|ntfschar
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|al_entry
op_plus
id|al_entry-&gt;name_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
(brace
r_if
c_cond
(paren
id|al_name_len
)paren
r_goto
id|not_found
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
id|al_name
comma
id|al_name_len
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
(brace
r_register
r_int
id|rc
suffix:semicolon
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
id|al_name
comma
id|al_name_len
comma
l_int|1
comma
id|IGNORE_CASE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If @name collates before al_name, there is no&n;&t;&t;&t; * matching attribute.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_goto
id|not_found
suffix:semicolon
multiline_comment|/* If the strings are not equal, continue search. */
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * FIXME: Reverse engineering showed 0, IGNORE_CASE but&n;&t;&t;&t; * that is inconsistent with ntfs_attr_find().  The&n;&t;&t;&t; * subsequent rc checks were also different.  Perhaps I&n;&t;&t;&t; * made a mistake in one of the two.  Need to recheck&n;&t;&t;&t; * which is correct or at least see what is going on...&n;&t;&t;&t; * (AIA)&n;&t;&t;&t; */
id|rc
op_assign
id|ntfs_collate_names
c_func
(paren
id|name
comma
id|name_len
comma
id|al_name
comma
id|al_name_len
comma
l_int|1
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_goto
id|not_found
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The names match or @name not present and attribute is&n;&t;&t; * unnamed.  Now check @lowest_vcn.  Continue search if the&n;&t;&t; * next attribute list entry still fits @lowest_vcn.  Otherwise&n;&t;&t; * we have reached the right one or the search has failed.&n;&t;&t; */
r_if
c_cond
(paren
id|lowest_vcn
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_ge
id|al_start
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
l_int|6
OL
id|al_end
op_logical_and
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
id|le16_to_cpu
c_func
(paren
id|next_al_entry-&gt;length
)paren
op_le
id|al_end
op_logical_and
id|sle64_to_cpu
c_func
(paren
id|next_al_entry-&gt;lowest_vcn
)paren
op_le
id|lowest_vcn
op_logical_and
id|next_al_entry-&gt;type
op_eq
id|al_entry-&gt;type
op_logical_and
id|next_al_entry-&gt;name_length
op_eq
id|al_name_len
op_logical_and
id|ntfs_are_names_equal
c_func
(paren
(paren
id|ntfschar
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|next_al_entry
op_plus
id|next_al_entry-&gt;name_offset
)paren
comma
id|next_al_entry-&gt;name_length
comma
id|al_name
comma
id|al_name_len
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_eq
id|ni-&gt;mft_no
)paren
(brace
r_if
c_cond
(paren
id|MSEQNO_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_ne
id|ni-&gt;seq_no
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Found stale mft &quot;
l_string|&quot;reference in attribute list &quot;
l_string|&quot;of base inode 0x%lx.%s&quot;
comma
id|base_ni-&gt;mft_no
comma
id|es
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Mft references do not match. */
multiline_comment|/* If there is a mapped record unmap it first. */
r_if
c_cond
(paren
id|ni
op_ne
id|base_ni
)paren
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
multiline_comment|/* Do we want the base record back? */
r_if
c_cond
(paren
id|MREF_LE
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
op_eq
id|base_ni-&gt;mft_no
)paren
(brace
id|ni
op_assign
id|ctx-&gt;ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ctx-&gt;mrec
op_assign
id|ctx-&gt;base_mrec
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We want an extent record. */
id|ctx-&gt;mrec
op_assign
id|map_extent_mft_record
c_func
(paren
id|base_ni
comma
id|le64_to_cpu
c_func
(paren
id|al_entry-&gt;mft_reference
)paren
comma
op_amp
id|ni
)paren
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|ni
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ctx-&gt;mrec
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to map &quot;
l_string|&quot;extent mft record &quot;
l_string|&quot;0x%lx of base inode &quot;
l_string|&quot;0x%lx.%s&quot;
comma
id|MREF_LE
c_func
(paren
id|al_entry
op_member_access_from_pointer
id|mft_reference
)paren
comma
id|base_ni-&gt;mft_no
comma
id|es
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ctx-&gt;mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * ctx-&gt;vfs_ino, ctx-&gt;mrec, and ctx-&gt;attr now point to the&n;&t;&t; * mft record containing the attribute represented by the&n;&t;&t; * current al_entry.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * We could call into ntfs_attr_find() to find the right&n;&t;&t; * attribute in this mft record but this would be less&n;&t;&t; * efficient and not quite accurate as ntfs_attr_find() ignores&n;&t;&t; * the attribute instance numbers for example which become&n;&t;&t; * important when one plays with attribute lists.  Also,&n;&t;&t; * because a proper match has been found in the attribute list&n;&t;&t; * entry above, the comparison can now be optimized.  So it is&n;&t;&t; * worth re-implementing a simplified ntfs_attr_find() here.&n;&t;&t; */
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Use a manual loop so we can still use break and continue&n;&t;&t; * with the same meanings as above.&n;&t;&t; */
id|do_next_attr_loop
suffix:colon
r_if
c_cond
(paren
(paren
id|u8
op_star
)paren
id|a
template_param
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;bytes_allocated
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;type
op_eq
id|AT_END
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;length
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|al_entry-&gt;instance
op_ne
id|a-&gt;instance
)paren
r_goto
id|do_next_attr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the type and/or the name are mismatched between the&n;&t;&t; * attribute list entry and the attribute record, there is&n;&t;&t; * corruption so we break and return error EIO.&n;&t;&t; */
r_if
c_cond
(paren
id|al_entry-&gt;type
op_ne
id|a-&gt;type
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_are_names_equal
c_func
(paren
(paren
id|ntfschar
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;name_offset
)paren
)paren
comma
id|a-&gt;name_length
comma
id|al_name
comma
id|al_name_len
comma
id|CASE_SENSITIVE
comma
id|vol-&gt;upcase
comma
id|vol-&gt;upcase_len
)paren
)paren
r_break
suffix:semicolon
id|ctx-&gt;attr
op_assign
id|a
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If no @val specified or @val specified and it matches, we&n;&t;&t; * have found it!&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|val
op_logical_or
(paren
op_logical_neg
id|a-&gt;non_resident
op_logical_and
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
op_eq
id|val_len
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_offset
)paren
comma
id|val
comma
id|val_len
)paren
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done, found.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|do_next_attr
suffix:colon
multiline_comment|/* Proceed to the next attribute in the current mft record. */
id|a
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le32_to_cpu
c_func
(paren
id|a-&gt;length
)paren
)paren
suffix:semicolon
r_goto
id|do_next_attr_loop
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Base inode 0x%lx contains corrupt &quot;
l_string|&quot;attribute list attribute.%s&quot;
comma
id|base_ni-&gt;mft_no
comma
id|es
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ni
op_ne
id|base_ni
)paren
(brace
id|unmap_extent_mft_record
c_func
(paren
id|ni
)paren
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|base_ni
suffix:semicolon
id|ctx-&gt;mrec
op_assign
id|ctx-&gt;base_mrec
suffix:semicolon
id|ctx-&gt;attr
op_assign
id|ctx-&gt;base_attr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOMEM
)paren
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|not_found
suffix:colon
multiline_comment|/*&n;&t; * If we were looking for AT_END, we reset the search context @ctx and&n;&t; * use ntfs_attr_find() to seek to the end of the base mft record.&n;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|AT_END
)paren
(brace
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_return
id|ntfs_attr_find
c_func
(paren
id|AT_END
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The attribute was not found.  Before we return, we want to ensure&n;&t; * @ctx-&gt;mrec and @ctx-&gt;attr indicate the position at which the&n;&t; * attribute should be inserted in the base mft record.  Since we also&n;&t; * want to preserve @ctx-&gt;al_entry we cannot reinitialize the search&n;&t; * context using ntfs_attr_reinit_search_ctx() as this would set&n;&t; * @ctx-&gt;al_entry to NULL.  Thus we do the necessary bits manually (see&n;&t; * ntfs_attr_init_search_ctx() below).  Note, we _only_ preserve&n;&t; * @ctx-&gt;al_entry as the remaining fields (base_*) are identical to&n;&t; * their non base_ counterparts and we cannot set @ctx-&gt;base_attr&n;&t; * correctly yet as we do not know what @ctx-&gt;attr will be set to by&n;&t; * the call to ntfs_attr_find() below.&n;&t; */
id|ctx-&gt;mrec
op_assign
id|ctx-&gt;base_mrec
suffix:semicolon
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|TRUE
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|ctx-&gt;base_ntfs_ino
suffix:semicolon
id|ctx-&gt;base_ntfs_ino
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_mrec
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_attr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * In case there are multiple matches in the base mft record, need to&n;&t; * keep enumerating until we get an attribute not found response (or&n;&t; * another error), otherwise we would keep returning the same attribute&n;&t; * over and over again and all programs using us for enumeration would&n;&t; * lock up in a tight loop.&n;&t; */
r_do
(brace
id|err
op_assign
id|ntfs_attr_find
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|err
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done, not found.&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_lookup - find an attribute in an ntfs inode&n; * @type:&t;attribute type to find&n; * @name:&t;attribute name to find (optional, i.e. NULL means don&squot;t care)&n; * @name_len:&t;attribute name length (only needed if @name present)&n; * @ic:&t;&t;IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)&n; * @lowest_vcn:&t;lowest vcn to find (optional, non-resident attributes only)&n; * @val:&t;attribute value to find (optional, resident attributes only)&n; * @val_len:&t;attribute value length&n; * @ctx:&t;search context with mft record and attribute to search from&n; *&n; * Find an attribute in an ntfs inode.  On first search @ctx-&gt;ntfs_ino must&n; * be the base mft record and @ctx must have been obtained from a call to&n; * ntfs_attr_get_search_ctx().&n; *&n; * This function transparently handles attribute lists and @ctx is used to&n; * continue searches where they were left off at.&n; *&n; * After finishing with the attribute/mft record you need to call&n; * ntfs_attr_put_search_ctx() to cleanup the search context (unmapping any&n; * mapped inodes, etc).&n; *&n; * Return 0 if the search was successful and -errno if not.&n; *&n; * When 0, @ctx-&gt;attr is the found attribute and it is in mft record&n; * @ctx-&gt;mrec.  If an attribute list attribute is present, @ctx-&gt;al_entry is&n; * the attribute list entry of the found attribute.&n; *&n; * When -ENOENT, @ctx-&gt;attr is the attribute which collates just after the&n; * attribute being searched for, i.e. if one wants to add the attribute to the&n; * mft record this is the correct place to insert it into.  If an attribute&n; * list attribute is present, @ctx-&gt;al_entry is the attribute list entry which&n; * collates just after the attribute list entry of the attribute being searched&n; * for, i.e. if one wants to add the attribute to the mft record this is the&n; * correct place to insert its attribute list entry into.&n; *&n; * When -errno != -ENOENT, an error occured during the lookup.  @ctx-&gt;attr is&n; * then undefined and in particular you should not rely on it not changing.&n; */
DECL|function|ntfs_attr_lookup
r_int
id|ntfs_attr_lookup
c_func
(paren
r_const
id|ATTR_TYPE
id|type
comma
r_const
id|ntfschar
op_star
id|name
comma
r_const
id|u32
id|name_len
comma
r_const
id|IGNORE_CASE_BOOL
id|ic
comma
r_const
id|VCN
id|lowest_vcn
comma
r_const
id|u8
op_star
id|val
comma
r_const
id|u32
id|val_len
comma
id|ntfs_attr_search_ctx
op_star
id|ctx
)paren
(brace
id|ntfs_inode
op_star
id|base_ni
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx-&gt;base_ntfs_ino
)paren
id|base_ni
op_assign
id|ctx-&gt;base_ntfs_ino
suffix:semicolon
r_else
id|base_ni
op_assign
id|ctx-&gt;ntfs_ino
suffix:semicolon
multiline_comment|/* Sanity check, just for debugging really. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NInoAttrList
c_func
(paren
id|base_ni
)paren
op_logical_or
id|type
op_eq
id|AT_ATTRIBUTE_LIST
)paren
r_return
id|ntfs_attr_find
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
r_return
id|ntfs_external_attr_find
c_func
(paren
id|type
comma
id|name
comma
id|name_len
comma
id|ic
comma
id|lowest_vcn
comma
id|val
comma
id|val_len
comma
id|ctx
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_init_search_ctx - initialize an attribute search context&n; * @ctx:&t;attribute search context to initialize&n; * @ni:&t;&t;ntfs inode with which to initialize the search context&n; * @mrec:&t;mft record with which to initialize the search context&n; *&n; * Initialize the attribute search context @ctx with @ni and @mrec.&n; */
DECL|function|ntfs_attr_init_search_ctx
r_static
r_inline
r_void
id|ntfs_attr_init_search_ctx
c_func
(paren
id|ntfs_attr_search_ctx
op_star
id|ctx
comma
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mrec
)paren
(brace
id|ctx-&gt;mrec
op_assign
id|mrec
suffix:semicolon
multiline_comment|/* Sanity checks are performed elsewhere. */
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
id|ctx-&gt;is_first
op_assign
id|TRUE
suffix:semicolon
id|ctx-&gt;ntfs_ino
op_assign
id|ni
suffix:semicolon
id|ctx-&gt;al_entry
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_ntfs_ino
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_mrec
op_assign
l_int|NULL
suffix:semicolon
id|ctx-&gt;base_attr
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_reinit_search_ctx - reinitialize an attribute search context&n; * @ctx:&t;attribute search context to reinitialize&n; *&n; * Reinitialize the attribute search context @ctx, unmapping an associated&n; * extent mft record if present, and initialize the search context again.&n; *&n; * This is used when a search for a new attribute is being started to reset&n; * the search context to the beginning.&n; */
DECL|function|ntfs_attr_reinit_search_ctx
r_void
id|ntfs_attr_reinit_search_ctx
c_func
(paren
id|ntfs_attr_search_ctx
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|ctx-&gt;base_ntfs_ino
)paren
)paren
(brace
multiline_comment|/* No attribute list. */
id|ctx-&gt;is_first
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Sanity checks are performed elsewhere. */
id|ctx-&gt;attr
op_assign
(paren
id|ATTR_RECORD
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;mrec
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;mrec-&gt;attrs_offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This needs resetting due to ntfs_external_attr_find() which&n;&t;&t; * can leave it set despite having zeroed ctx-&gt;base_ntfs_ino.&n;&t;&t; */
id|ctx-&gt;al_entry
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Attribute list. */
r_if
c_cond
(paren
id|ctx-&gt;ntfs_ino
op_ne
id|ctx-&gt;base_ntfs_ino
)paren
id|unmap_extent_mft_record
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_init_search_ctx
c_func
(paren
id|ctx
comma
id|ctx-&gt;base_ntfs_ino
comma
id|ctx-&gt;base_mrec
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_get_search_ctx - allocate/initialize a new attribute search context&n; * @ni:&t;&t;ntfs inode with which to initialize the search context&n; * @mrec:&t;mft record with which to initialize the search context&n; *&n; * Allocate a new attribute search context, initialize it with @ni and @mrec,&n; * and return it. Return NULL if allocation failed.&n; */
DECL|function|ntfs_attr_get_search_ctx
id|ntfs_attr_search_ctx
op_star
id|ntfs_attr_get_search_ctx
c_func
(paren
id|ntfs_inode
op_star
id|ni
comma
id|MFT_RECORD
op_star
id|mrec
)paren
(brace
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|ctx
op_assign
id|kmem_cache_alloc
c_func
(paren
id|ntfs_attr_ctx_cache
comma
id|SLAB_NOFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_init_search_ctx
c_func
(paren
id|ctx
comma
id|ni
comma
id|mrec
)paren
suffix:semicolon
r_return
id|ctx
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_attr_put_search_ctx - release an attribute search context&n; * @ctx:&t;attribute search context to free&n; *&n; * Release the attribute search context @ctx, unmapping an associated extent&n; * mft record if present.&n; */
DECL|function|ntfs_attr_put_search_ctx
r_void
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ntfs_attr_search_ctx
op_star
id|ctx
)paren
(brace
r_if
c_cond
(paren
id|ctx-&gt;base_ntfs_ino
op_logical_and
id|ctx-&gt;ntfs_ino
op_ne
id|ctx-&gt;base_ntfs_ino
)paren
id|unmap_extent_mft_record
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|ntfs_attr_ctx_cache
comma
id|ctx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
