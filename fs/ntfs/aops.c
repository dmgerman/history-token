multiline_comment|/**&n; * aops.c - NTFS kernel address space operations and page cache handling.&n; * &t;    Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; * Copyright (c) 2002 Richard Russon.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * ntfs_end_buffer_async_read - async io completion for reading attributes&n; * @bh:&t;&t;buffer head on which io is completed&n; * @uptodate:&t;whether @bh is now uptodate or not&n; *&n; * Asynchronous I/O completion handler for reading pages belonging to the&n; * attribute address space of an inode. The inodes can either be files or&n; * directories or they can be fake inodes describing some attribute.&n; *&n; * If NInoMstProtected(), perform the post read mst fixups when all IO on the&n; * page has been completed and mark the page uptodate or set the error bit on&n; * the page. To determine the size of the records that need fixing up, we cheat&n; * a little bit by setting the index_block_size in ntfs_inode to the ntfs&n; * record size, and index_block_size_bits, to the log(base 2) of the ntfs&n; * record size.&n; */
DECL|function|ntfs_end_buffer_async_read
r_static
r_void
id|ntfs_end_buffer_async_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_int
id|page_uptodate
op_assign
l_int|1
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|uptodate
)paren
)paren
(brace
id|s64
id|file_ofs
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|file_ofs
op_assign
(paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Check for the current buffer head overflowing. */
r_if
c_cond
(paren
id|file_ofs
op_plus
id|bh-&gt;b_size
OG
id|ni-&gt;initialized_size
)paren
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
OL
id|ni-&gt;initialized_size
)paren
id|ofs
op_assign
id|ni-&gt;initialized_size
op_minus
id|file_ofs
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
id|memset
c_func
(paren
id|addr
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
op_plus
id|ofs
comma
l_int|0
comma
id|bh-&gt;b_size
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Buffer I/O error, logical block %Lu.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|clear_buffer_async_read
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
id|page_uptodate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_read
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|still_busy
suffix:semicolon
multiline_comment|/* Async buffers must be locked. */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If none of the buffers had errors then we can set the page uptodate,&n;&t; * but we first have to perform the post read mst fixups, if the&n;&t; * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|page_uptodate
op_logical_and
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
r_int
id|i
comma
id|recs
comma
id|nr_err
suffix:semicolon
id|u32
id|rec_size
suffix:semicolon
id|rec_size
op_assign
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
suffix:semicolon
id|recs
op_assign
id|PAGE_CACHE_SIZE
op_div
id|rec_size
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_err
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|recs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
(paren
id|addr
op_plus
id|i
op_star
id|rec_size
)paren
comma
id|rec_size
)paren
)paren
)paren
r_continue
suffix:semicolon
id|nr_err
op_increment
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;post_read_mst_fixup() failed, &quot;
l_string|&quot;corrupt %s record 0x%Lx. Run chkdsk.&quot;
comma
id|ni-&gt;mft_no
ques
c_cond
l_string|&quot;index&quot;
suffix:colon
l_string|&quot;mft&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
op_rshift
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
)paren
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|nr_err
op_logical_and
id|recs
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|page_uptodate
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Setting page error, &quot;
l_string|&quot;index 0x%lx.&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_block - fill a @page of an address space with data&n; * @page:&t;page cache page to fill with data&n; *&n; * Fill the page @page of the address space belonging to the @page-&gt;host inode.&n; * We read each buffer asynchronously and when all buffers are read in, our io&n; * completion handler ntfs_end_buffer_read_async(), if required, automatically&n; * applies the mst fixups to the page before finally marking it uptodate and&n; * unlocking it.&n; *&n; * We only enforce allocated_size limit because i_size is checked for in&n; * generic_file_read().&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Contains an adapted version of fs/buffer.c::block_read_full_page().&n; */
DECL|function|ntfs_read_block
r_static
r_int
id|ntfs_read_block
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|run_list_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
comma
id|zblock
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|vcn_ofs
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|blocksize_bits
op_assign
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bh
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|iblock
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|ni-&gt;allocated_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|zblock
op_assign
(paren
id|ni-&gt;initialized_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni-&gt;run_list.rl
op_logical_and
op_logical_neg
id|ni-&gt;mft_no
op_logical_and
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;NTFS: $MFT/$DATA run list has been unmapped! This is a &quot;
l_string|&quot;very serious bug! Cannot continue...&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Loop through all the buffers in the page. */
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|nr
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|bh-&gt;b_bdev
op_assign
id|vol-&gt;sb-&gt;s_bdev
suffix:semicolon
multiline_comment|/* Is the block within the allowed limits? */
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Convert iblock into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;run_list.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
(paren
id|LCN
)paren
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Only read initialized data blocks. */
r_if
c_cond
(paren
id|iblock
OL
id|zblock
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Fully non-initialized data block, zero it. */
r_goto
id|handle_zblock
suffix:semicolon
)brace
multiline_comment|/* It is a hole, need to zero it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
r_goto
id|handle_hole
suffix:semicolon
multiline_comment|/* If first try and run list unmapped, map and retry. */
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Attempt to map run list, dropping lock for&n;&t;&t;&t;&t; * the duration.&n;&t;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map_run_list
c_func
(paren
id|ni
comma
id|vcn
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Hard error, zero out region. */
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) failed &quot;
l_string|&quot;with error code 0x%Lx%s.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
comma
id|is_retry
ques
c_cond
l_string|&quot; even after retrying&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do something.
)brace
multiline_comment|/*&n;&t;&t; * Either iblock was outside lblock limits or vcn_to_lcn()&n;&t;&t; * returned error. Just zero that portion of the page and set&n;&t;&t; * the buffer uptodate.&n;&t;&t; */
id|handle_hole
suffix:colon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|clear_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
id|handle_zblock
suffix:colon
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* Check we have at least one buffer ready for i/o. */
r_if
c_cond
(paren
id|nr
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
suffix:semicolon
multiline_comment|/* Lock the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|ntfs_end_buffer_async_read
suffix:semicolon
id|set_buffer_async_read
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally, start i/o on the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|tbh
)paren
suffix:semicolon
r_else
id|ntfs_end_buffer_async_read
c_func
(paren
id|tbh
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No i/o was scheduled on any of the buffers. */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
multiline_comment|/* Signal synchronous i/o error. */
id|nr
op_assign
op_minus
id|EIO
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_readpage - fill a @page of a @file with data from the device&n; * @file:&t;open file to which the page @page belongs or NULL&n; * @page:&t;page cache page to fill with data&n; *&n; * For non-resident attributes, ntfs_readpage() fills the @page of the open&n; * file @file by calling the ntfs version of the generic block_read_full_page()&n; * function, ntfs_read_block(), which in turn creates and reads in the buffers&n; * associated with the page asynchronously.&n; *&n; * For resident attributes, OTOH, ntfs_readpage() fills @page by copying the&n; * data from the mft record (which at this stage is most likely in memory) and&n; * fills the remainder with zeroes. Thus, in this case, I/O is synchronous, as&n; * even if the mft record is not cached at this point in time, we need to wait&n; * for it to be read in before we can do the copy.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * WARNING: Do not make this function static! It is used by mft.c!&n; */
DECL|function|ntfs_readpage
r_int
id|ntfs_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|s64
id|attr_pos
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
id|u32
id|attr_len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can potentially happen because we clear PageUptodate() during&n;&t; * ntfs_writepage() of MstProtected() attributes.&n;&t; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed or&n;&t;&t; * encrypted.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
r_return
id|ntfs_read_compressed_block
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_read_block
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Attribute is resident, implying it is not compressed or encrypted. */
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni
op_member_access_from_pointer
id|_INE
c_func
(paren
id|base_ntfs_ino
)paren
suffix:semicolon
multiline_comment|/* Map, pin and lock the mft record. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|get_attr_search_ctx
c_func
(paren
id|base_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|IGNORE_CASE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|put_unm_err_out
suffix:semicolon
)brace
multiline_comment|/* Starting position of the page within the attribute value. */
id|attr_pos
op_assign
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* The total length of the attribute value. */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
id|addr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Copy over in bounds data, zeroing the remainder of the page. */
r_if
c_cond
(paren
id|attr_pos
OL
id|attr_len
)paren
(brace
id|u32
id|bytes
op_assign
id|attr_len
op_minus
id|attr_pos
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|PAGE_CACHE_SIZE
)paren
id|bytes
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bytes
OL
id|PAGE_CACHE_SIZE
)paren
id|memset
c_func
(paren
id|addr
op_plus
id|bytes
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|bytes
)paren
suffix:semicolon
multiline_comment|/* Copy the data to the page. */
id|memcpy
c_func
(paren
id|addr
comma
id|attr_pos
op_plus
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|bytes
)paren
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
id|addr
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_unm_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|err_out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_aops - general address space operations for inodes and attributes&n; */
DECL|variable|ntfs_aops
r_struct
id|address_space_operations
id|ntfs_aops
op_assign
(brace
dot
id|readpage
op_assign
id|ntfs_readpage
comma
multiline_comment|/* Fill page with data. */
dot
id|sync_page
op_assign
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
)brace
suffix:semicolon
eof
