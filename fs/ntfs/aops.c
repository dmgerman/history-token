multiline_comment|/*&n; * aops.c - NTFS kernel address space operations and page cache handling.&n; * &t;    Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001,2002 Anton Altaparmakov.&n; * Copyright (C) 2002 Richard Russon.&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be &n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty &n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS &n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &quot;ntfs.h&quot;
DECL|macro|MAX_BUF_PER_PAGE
mdefine_line|#define MAX_BUF_PER_PAGE (PAGE_CACHE_SIZE / 512)
multiline_comment|/*&n; * Async io completion handler for accessing files. Adapted from&n; * end_buffer_read_mst_async().&n; */
DECL|function|end_buffer_read_file_async
r_static
r_void
id|end_buffer_read_file_async
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|uptodate
)paren
)paren
(brace
id|s64
id|file_ofs
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
id|file_ofs
op_assign
(paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
op_plus
id|bh-&gt;b_size
OG
id|ni-&gt;initialized_size
)paren
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
OL
id|ni-&gt;initialized_size
)paren
id|ofs
op_assign
id|ni-&gt;initialized_size
op_minus
id|file_ofs
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
id|memset
c_func
(paren
id|addr
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
op_plus
id|ofs
comma
l_int|0
comma
id|bh-&gt;b_size
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
)brace
)brace
r_else
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|mark_buffer_async
c_func
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_async
c_func
(paren
id|tmp
)paren
)paren
r_goto
id|still_busy
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* NTFS version of block_read_full_page(). Adapted from ntfs_mst_readpage(). */
DECL|function|ntfs_file_read_block
r_static
r_int
id|ntfs_file_read_block
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|blocks
comma
id|vcn_ofs
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|blocksize_bits
op_assign
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|blocks
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|blocksize_bits
suffix:semicolon
id|iblock
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|ni-&gt;allocated_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni-&gt;mft_no
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;NTFS: Attempt to access $MFT! This is a &quot;
l_string|&quot;very serious bug! Denying access...&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Loop through all the buffers in the page. */
id|nr
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|BUG_ON
c_func
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_dev
suffix:semicolon
multiline_comment|/* Is the block within the allowed limits? */
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Convert iblock into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|retry_remap
suffix:colon
multiline_comment|/* Convert the vcn to the corresponding lcn. */
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|ni-&gt;run_list.rl
comma
id|vcn
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|bh-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* It is a hole, need to zero it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
r_goto
id|handle_hole
suffix:semicolon
multiline_comment|/* If first try and run list unmapped, map and retry. */
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map_run_list
c_func
(paren
id|ni
comma
id|vcn
)paren
)paren
r_goto
id|retry_remap
suffix:semicolon
)brace
multiline_comment|/* Hard error, zero out region. */
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) failed &quot;
l_string|&quot;with error code 0x%Lx%s.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
comma
id|is_retry
ques
c_cond
l_string|&quot; even after retrying&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do something.
)brace
multiline_comment|/*&n;&t;&t; * Either iblock was outside lblock limits or vcn_to_lcn()&n;&t;&t; * returned error. Just zero that portion of the page and set&n;&t;&t; * the buffer uptodate.&n;&t;&t; */
id|handle_hole
suffix:colon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|bh-&gt;b_state
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Check we have at least one buffer ready for i/o. */
r_if
c_cond
(paren
id|nr
)paren
(brace
multiline_comment|/* Lock the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_read_file_async
suffix:semicolon
id|mark_buffer_async
c_func
(paren
id|tbh
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally, start i/o on the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|arr
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No i/o was scheduled on any of the buffers. */
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
multiline_comment|/* Signal synchronous i/o error. */
id|nr
op_assign
op_minus
id|EIO
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_file_readpage - fill a @page of a @file with data from the device&n; * @file:&t;open file to which the page @page belongs or NULL&n; * @page:&t;page cache page to fill with data&n; *&n; * For non-resident attributes, ntfs_file_readpage() fills the @page of the open&n; * file @file by calling the generic block_read_full_page() function provided by&n; * the kernel which in turn invokes our ntfs_file_get_block() callback in order&n; * to create and read in the buffers associated with the page asynchronously.&n; *&n; * For resident attributes, OTOH, ntfs_file_readpage() fills @page by copying&n; * the data from the mft record (which at this stage is most likely in memory)&n; * and fills the remainder with zeroes. Thus, in this case I/O is synchronous,&n; * as even if the mft record is not cached at this point in time, we need to&n; * wait for it to be read in before we can do the copy.&n; *&n; * Return zero on success or -errno on error.&n; */
DECL|function|ntfs_file_readpage
r_static
r_int
id|ntfs_file_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|s64
id|attr_pos
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_char
op_star
id|addr
suffix:semicolon
id|attr_search_context
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
id|u32
id|attr_len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
multiline_comment|/* Is the unnamed $DATA attribute resident? */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|NI_NonResident
comma
op_amp
id|ni-&gt;state
)paren
)paren
(brace
multiline_comment|/* Attribute is not resident. */
multiline_comment|/* If the file is encrypted, we deny access, just like NT4. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|NI_Encrypted
comma
op_amp
id|ni-&gt;state
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_goto
id|unl_err_out
suffix:semicolon
)brace
multiline_comment|/* Compressed data stream. Handled in compress.c. */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|NI_Compressed
comma
op_amp
id|ni-&gt;state
)paren
)paren
r_return
id|ntfs_file_read_compressed_block
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_file_read_block
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Attribute is resident, implying it is not compressed or encrypted. */
multiline_comment|/* Map, pin and lock the mft record for reading. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
r_goto
id|unl_err_out
suffix:semicolon
)brace
id|err
op_assign
id|get_attr_search_ctx
c_func
(paren
op_amp
id|ctx
comma
id|ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|unm_unl_err_out
suffix:semicolon
multiline_comment|/* Find the data attribute in the mft record. */
r_if
c_cond
(paren
op_logical_neg
id|lookup_attr
c_func
(paren
id|AT_DATA
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|put_unm_unl_err_out
suffix:semicolon
)brace
multiline_comment|/* Starting position of the page within the attribute value. */
id|attr_pos
op_assign
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* The total length of the attribute value. */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_length
)paren
)paren
suffix:semicolon
id|addr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Copy over in bounds data, zeroing the remainder of the page. */
r_if
c_cond
(paren
id|attr_pos
OL
id|attr_len
)paren
(brace
id|u32
id|bytes
op_assign
id|attr_len
op_minus
id|attr_pos
suffix:semicolon
r_if
c_cond
(paren
id|bytes
OG
id|PAGE_CACHE_SIZE
)paren
id|bytes
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|bytes
OL
id|PAGE_CACHE_SIZE
)paren
id|memset
c_func
(paren
id|addr
op_plus
id|bytes
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|bytes
)paren
suffix:semicolon
multiline_comment|/* Copy the data to the page. */
id|memcpy
c_func
(paren
id|addr
comma
id|attr_pos
op_plus
(paren
r_char
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr
op_member_access_from_pointer
id|_ARA
c_func
(paren
id|value_offset
)paren
)paren
comma
id|bytes
)paren
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
id|addr
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|put_unm_unl_err_out
suffix:colon
id|put_attr_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_unl_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|READ
comma
id|ni
)paren
suffix:semicolon
id|unl_err_out
suffix:colon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Async io completion handler for accessing mft bitmap. Adapted from&n; * end_buffer_read_mst_async().&n; */
DECL|function|end_buffer_read_mftbmp_async
r_static
r_void
id|end_buffer_read_mftbmp_async
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|uptodate
)paren
)paren
(brace
id|s64
id|file_ofs
suffix:semicolon
multiline_comment|/* Host is the ntfs volume. Our mft bitmap access kludge... */
id|ntfs_volume
op_star
id|vol
op_assign
(paren
id|ntfs_volume
op_star
)paren
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|file_ofs
op_assign
(paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
op_plus
id|bh-&gt;b_size
OG
id|vol-&gt;mftbmp_initialized_size
)paren
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
OL
id|vol-&gt;mftbmp_initialized_size
)paren
id|ofs
op_assign
id|vol-&gt;mftbmp_initialized_size
op_minus
id|file_ofs
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
id|memset
c_func
(paren
id|addr
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
op_plus
id|ofs
comma
l_int|0
comma
id|bh-&gt;b_size
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
)brace
)brace
r_else
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|mark_buffer_async
c_func
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_async
c_func
(paren
id|tmp
)paren
)paren
r_goto
id|still_busy
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Readpage for accessing mft bitmap. Adapted from ntfs_mst_readpage(). */
DECL|function|ntfs_mftbmp_readpage
r_static
r_int
id|ntfs_mftbmp_readpage
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|blocks
comma
id|vcn_ofs
suffix:semicolon
r_int
id|nr
comma
id|i
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|blocksize
op_assign
id|vol-&gt;sb-&gt;s_blocksize
suffix:semicolon
id|blocksize_bits
op_assign
id|vol-&gt;sb-&gt;s_blocksize_bits
suffix:semicolon
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|blocks
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|blocksize_bits
suffix:semicolon
id|iblock
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|vol-&gt;mftbmp_allocated_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* Loop through all the buffers in the page. */
id|nr
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|BUG_ON
c_func
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|vol-&gt;mft_ino-&gt;i_dev
suffix:semicolon
multiline_comment|/* Is the block within the allowed limits? */
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
multiline_comment|/* Convert iblock into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
multiline_comment|/* Convert the vcn to the corresponding lcn. */
id|down_read
c_func
(paren
op_amp
id|vol-&gt;mftbmp_rl.lock
)paren
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|vol-&gt;mftbmp_rl.rl
comma
id|vcn
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|vol-&gt;mftbmp_rl.lock
)paren
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|bh-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lcn
op_ne
id|LCN_HOLE
)paren
(brace
multiline_comment|/* Hard error, zero out region. */
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) &quot;
l_string|&quot;failed with error code &quot;
l_string|&quot;0x%Lx.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do
singleline_comment|// something.
)brace
)brace
multiline_comment|/*&n;&t;&t; * Either iblock was outside lblock limits or vcn_to_lcn()&n;&t;&t; * returned error. Just zero that portion of the page and set&n;&t;&t; * the buffer uptodate.&n;&t;&t; */
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|bh-&gt;b_state
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Check we have at least one buffer ready for i/o. */
r_if
c_cond
(paren
id|nr
)paren
(brace
multiline_comment|/* Lock the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_read_mftbmp_async
suffix:semicolon
id|mark_buffer_async
c_func
(paren
id|tbh
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally, start i/o on the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|arr
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No i/o was scheduled on any of the buffers. */
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
multiline_comment|/* Signal synchronous i/o error. */
id|nr
op_assign
op_minus
id|EIO
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
multiline_comment|/**&n; * end_buffer_read_mst_async - async io completion for reading index records&n; * @bh:&t;&t;buffer head on which io is completed&n; * @uptodate:&t;whether @bh is now uptodate or not&n; *&n; * Asynchronous I/O completion handler for reading pages belonging to the&n; * index allocation attribute address space of directory inodes.&n; *&n; * Perform the post read mst fixups when all IO on the page has been completed&n; * and marks the page uptodate or sets the error bit on the page.&n; *&n; * Adapted from fs/buffer.c.&n; *&n; * NOTE: We use this function as async io completion handler for reading pages&n; * belonging to the mft data attribute address space, too as this saves&n; * duplicating an almost identical function. We do this by cheating a little&n; * bit in setting the index_block_size in the mft ntfs_inode to the mft record&n; * size of the volume (vol-&gt;mft_record_size), and index_block_size_bits to&n; * mft_record_size_bits, respectively.&n; */
DECL|function|end_buffer_read_mst_async
r_static
r_void
id|end_buffer_read_mst_async
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|uptodate
)paren
)paren
(brace
id|s64
id|file_ofs
suffix:semicolon
id|file_ofs
op_assign
(paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Check for the current buffer head overflowing. */
r_if
c_cond
(paren
id|file_ofs
op_plus
id|bh-&gt;b_size
OG
id|ni-&gt;initialized_size
)paren
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
OL
id|ni-&gt;initialized_size
)paren
id|ofs
op_assign
id|ni-&gt;initialized_size
op_minus
id|file_ofs
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
id|memset
c_func
(paren
id|addr
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
op_plus
id|ofs
comma
l_int|0
comma
id|bh-&gt;b_size
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
)brace
)brace
r_else
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|mark_buffer_async
c_func
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_async
c_func
(paren
id|tmp
)paren
)paren
r_goto
id|still_busy
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If none of the buffers had errors then we can set the page uptodate,&n;&t; * but we first have to perform the post read mst fixups.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
r_int
id|i
comma
id|recs
comma
id|nr_err
op_assign
l_int|0
suffix:semicolon
id|u32
id|rec_size
suffix:semicolon
id|rec_size
op_assign
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size
)paren
suffix:semicolon
id|recs
op_assign
id|PAGE_CACHE_SIZE
op_div
id|rec_size
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|recs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
(paren
id|addr
op_plus
id|i
op_star
id|rec_size
)paren
comma
id|rec_size
)paren
)paren
r_continue
suffix:semicolon
id|nr_err
op_increment
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;post_read_mst_fixup() failed, &quot;
l_string|&quot;corrupt %s record 0x%Lx. Run chkdsk.&quot;
comma
id|ni-&gt;mft_no
ques
c_cond
l_string|&quot;index&quot;
suffix:colon
l_string|&quot;mft&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
op_rshift
id|ni
op_member_access_from_pointer
id|_IDM
c_func
(paren
id|index_block_size_bits
)paren
)paren
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|nr_err
op_logical_and
id|recs
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
(brace
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Setting page error, index &quot;
l_string|&quot;0x%lx.&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_mst_readpage - fill a @page of the mft or a directory with data&n; * @file:&t;open file/directory to which the page @page belongs or NULL&n; * @page:&t;page cache page to fill with data&n; *&n; * Readpage method for the VFS address space operations.&n; *&n; * Fill the page @page of the $MFT or the open directory @dir. We read each&n; * buffer asynchronously and when all buffers are read in our io completion&n; * handler end_buffer_read_mst_async() automatically applies the mst fixups to&n; * the page before finally marking it uptodate and unlocking it.&n; *&n; * Contains an adapted version of fs/buffer.c::block_read_full_page().&n; *&n; * TODO:/FIXME: The current implementation is simple but wasteful as we perform&n; * actual i/o from disk for all data up to allocated size completely ignoring&n; * the fact that initialized size, and data size for that matter, may well be&n; * lower and hence there is no point in reading them in. We can just zero the&n; * page range, which is what is currently done in our async i/o completion&n; * handler anyway, once the read from disk completes. However, I am not sure how&n; * to setup the buffer heads in that case, so for now we do the pointless i/o.&n; * Any help with this would be appreciated...&n; */
DECL|function|ntfs_mst_readpage
r_int
id|ntfs_mst_readpage
c_func
(paren
r_struct
id|file
op_star
id|dir
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|blocks
comma
id|vcn_ofs
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|blocksize_bits
op_assign
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|blocks
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|blocksize_bits
suffix:semicolon
id|iblock
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|ni-&gt;allocated_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ni-&gt;run_list.rl
op_logical_and
op_logical_neg
id|ni-&gt;mft_no
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;NTFS: $MFT/$DATA run list has been unmapped! This is a &quot;
l_string|&quot;very serious bug! Cannot continue...&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Loop through all the buffers in the page. */
id|nr
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|BUG_ON
c_func
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_dev
suffix:semicolon
multiline_comment|/* Is the block within the allowed limits? */
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Convert iblock into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|retry_remap
suffix:colon
multiline_comment|/* Convert the vcn to the corresponding lcn. */
id|down_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
id|lcn
op_assign
id|vcn_to_lcn
c_func
(paren
id|ni-&gt;run_list.rl
comma
id|vcn
)paren
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|ni-&gt;run_list.lock
)paren
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|bh-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* It is a hole, need to zero it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
r_goto
id|handle_hole
suffix:semicolon
multiline_comment|/* If first try and run list unmapped, map and retry. */
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map_run_list
c_func
(paren
id|ni
comma
id|vcn
)paren
)paren
r_goto
id|retry_remap
suffix:semicolon
)brace
multiline_comment|/* Hard error, zero out region. */
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;vcn_to_lcn(vcn = 0x%Lx) failed &quot;
l_string|&quot;with error code 0x%Lx%s.&quot;
comma
(paren
r_int
r_int
)paren
id|vcn
comma
(paren
r_int
r_int
)paren
op_minus
id|lcn
comma
id|is_retry
ques
c_cond
l_string|&quot; even after retrying&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
singleline_comment|// FIXME: Depending on vol-&gt;on_errors, do something.
)brace
multiline_comment|/*&n;&t;&t; * Either iblock was outside lblock limits or vcn_to_lcn()&n;&t;&t; * returned error. Just zero that portion of the page and set&n;&t;&t; * the buffer uptodate.&n;&t;&t; */
id|handle_hole
suffix:colon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|bh-&gt;b_state
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Check we have at least one buffer ready for i/o. */
r_if
c_cond
(paren
id|nr
)paren
(brace
multiline_comment|/* Lock the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_read_mst_async
suffix:semicolon
id|mark_buffer_async
c_func
(paren
id|tbh
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally, start i/o on the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|arr
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No i/o was scheduled on any of the buffers. */
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
multiline_comment|/* Signal synchronous i/o error. */
id|nr
op_assign
op_minus
id|EIO
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
multiline_comment|/* Address space operations for accessing normal file data. */
DECL|variable|ntfs_file_aops
r_struct
id|address_space_operations
id|ntfs_file_aops
op_assign
(brace
id|writepage
suffix:colon
l_int|NULL
comma
multiline_comment|/* Write dirty page to disk. */
id|readpage
suffix:colon
id|ntfs_file_readpage
comma
multiline_comment|/* Fill page with data. */
id|sync_page
suffix:colon
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
id|prepare_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
id|commit_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
)brace
suffix:semicolon
DECL|typedef|readpage_t
r_typedef
r_int
id|readpage_t
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|page
op_star
)paren
suffix:semicolon
multiline_comment|/* Address space operations for accessing mftbmp. */
DECL|variable|ntfs_mftbmp_aops
r_struct
id|address_space_operations
id|ntfs_mftbmp_aops
op_assign
(brace
id|writepage
suffix:colon
l_int|NULL
comma
multiline_comment|/* Write dirty page to disk. */
id|readpage
suffix:colon
(paren
id|readpage_t
op_star
)paren
id|ntfs_mftbmp_readpage
comma
multiline_comment|/* Fill page with&n;&t;&t;&t;&t;&t;&t;&t;      data. */
id|sync_page
suffix:colon
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
id|prepare_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
id|commit_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
)brace
suffix:semicolon
multiline_comment|/*&n; * Address space operations for accessing normal directory data (i.e. index&n; * allocation attribute). We can&squot;t just use the same operations as for files&n; * because 1) the attribute is different and even more importantly 2) the index&n; * records have to be multi sector transfer deprotected (i.e. fixed-up).&n; */
DECL|variable|ntfs_dir_aops
r_struct
id|address_space_operations
id|ntfs_dir_aops
op_assign
(brace
id|writepage
suffix:colon
l_int|NULL
comma
multiline_comment|/* Write dirty page to disk. */
id|readpage
suffix:colon
id|ntfs_mst_readpage
comma
multiline_comment|/* Fill page with data. */
id|sync_page
suffix:colon
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
id|prepare_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
id|commit_write
suffix:colon
l_int|NULL
comma
multiline_comment|/* . */
)brace
suffix:semicolon
eof
