multiline_comment|/**&n; * aops.c - NTFS kernel address space operations and page cache handling.&n; *&t;    Part of the Linux-NTFS project.&n; *&n; * Copyright (c) 2001-2004 Anton Altaparmakov&n; * Copyright (c) 2002 Richard Russon&n; *&n; * This program/include file is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License as published&n; * by the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program/include file is distributed in the hope that it will be&n; * useful, but WITHOUT ANY WARRANTY; without even the implied warranty&n; * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program (in the main directory of the Linux-NTFS&n; * distribution in the file COPYING); if not, write to the Free Software&n; * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/buffer_head.h&gt;
macro_line|#include &lt;linux/writeback.h&gt;
macro_line|#include &quot;aops.h&quot;
macro_line|#include &quot;attrib.h&quot;
macro_line|#include &quot;debug.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;mft.h&quot;
macro_line|#include &quot;runlist.h&quot;
macro_line|#include &quot;types.h&quot;
macro_line|#include &quot;ntfs.h&quot;
multiline_comment|/**&n; * ntfs_end_buffer_async_read - async io completion for reading attributes&n; * @bh:&t;&t;buffer head on which io is completed&n; * @uptodate:&t;whether @bh is now uptodate or not&n; *&n; * Asynchronous I/O completion handler for reading pages belonging to the&n; * attribute address space of an inode.  The inodes can either be files or&n; * directories or they can be fake inodes describing some attribute.&n; *&n; * If NInoMstProtected(), perform the post read mst fixups when all IO on the&n; * page has been completed and mark the page uptodate or set the error bit on&n; * the page.  To determine the size of the records that need fixing up, we&n; * cheat a little bit by setting the index_block_size in ntfs_inode to the ntfs&n; * record size, and index_block_size_bits, to the log(base 2) of the ntfs&n; * record size.&n; */
DECL|function|ntfs_end_buffer_async_read
r_static
r_void
id|ntfs_end_buffer_async_read
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|DEFINE_SPINLOCK
c_func
(paren
id|page_uptodate_lock
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
r_int
id|page_uptodate
op_assign
l_int|1
suffix:semicolon
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|uptodate
)paren
)paren
(brace
id|s64
id|file_ofs
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|file_ofs
op_assign
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Check for the current buffer head overflowing. */
r_if
c_cond
(paren
id|file_ofs
op_plus
id|bh-&gt;b_size
OG
id|ni-&gt;initialized_size
)paren
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
id|ofs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file_ofs
OL
id|ni-&gt;initialized_size
)paren
id|ofs
op_assign
id|ni-&gt;initialized_size
op_minus
id|file_ofs
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
id|memset
c_func
(paren
id|addr
op_plus
id|bh_offset
c_func
(paren
id|bh
)paren
op_plus
id|ofs
comma
l_int|0
comma
id|bh-&gt;b_size
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|clear_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|ni-&gt;vol-&gt;sb
comma
l_string|&quot;Buffer I/O error, logical block %llu.&quot;
comma
(paren
r_int
r_int
r_int
)paren
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|clear_buffer_async_read
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
id|page_uptodate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_read
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
)paren
r_goto
id|still_busy
suffix:semicolon
multiline_comment|/* Async buffers must be locked. */
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If none of the buffers had errors then we can set the page uptodate,&n;&t; * but we first have to perform the post read mst fixups, if the&n;&t; * attribute is mst protected, i.e. if NInoMstProteced(ni) is true.&n;&t; * Note we ignore fixup errors as those are detected when&n;&t; * map_mft_record() is called which gives us per record granularity&n;&t; * rather than per page granularity.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
(brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|page_uptodate
op_logical_and
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|addr
suffix:semicolon
r_int
r_int
id|i
comma
id|recs
suffix:semicolon
id|u32
id|rec_size
suffix:semicolon
id|rec_size
op_assign
id|ni-&gt;itype.index.block_size
suffix:semicolon
id|recs
op_assign
id|PAGE_CACHE_SIZE
op_div
id|rec_size
suffix:semicolon
multiline_comment|/* Should have been verified before we got here... */
id|BUG_ON
c_func
(paren
op_logical_neg
id|recs
)paren
suffix:semicolon
id|addr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|recs
suffix:semicolon
id|i
op_increment
)paren
id|post_read_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
(paren
id|addr
op_plus
id|i
op_star
id|rec_size
)paren
comma
id|rec_size
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|addr
comma
id|KM_BIO_SRC_IRQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
op_logical_and
id|page_uptodate
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_read_block - fill a @page of an address space with data&n; * @page:&t;page cache page to fill with data&n; *&n; * Fill the page @page of the address space belonging to the @page-&gt;host inode.&n; * We read each buffer asynchronously and when all buffers are read in, our io&n; * completion handler ntfs_end_buffer_read_async(), if required, automatically&n; * applies the mst fixups to the page before finally marking it uptodate and&n; * unlocking it.&n; *&n; * We only enforce allocated_size limit because i_size is checked for in&n; * generic_file_read().&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Contains an adapted version of fs/buffer.c::block_read_full_page().&n; */
DECL|function|ntfs_read_block
r_static
r_int
id|ntfs_read_block
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
id|sector_t
id|iblock
comma
id|lblock
comma
id|zblock
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|vcn_ofs
suffix:semicolon
r_int
id|i
comma
id|nr
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
multiline_comment|/* $MFT/$DATA must have its complete runlist in memory at all times. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|ni-&gt;runlist.rl
op_logical_and
op_logical_neg
id|ni-&gt;mft_no
op_logical_and
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|blocksize_bits
op_assign
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bh
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|iblock
op_assign
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|ni-&gt;allocated_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|zblock
op_assign
(paren
id|ni-&gt;initialized_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* Loop through all the buffers in the page. */
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|nr
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|u8
op_star
id|kaddr
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|bh-&gt;b_bdev
op_assign
id|vol-&gt;sb-&gt;s_bdev
suffix:semicolon
multiline_comment|/* Is the block within the allowed limits? */
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Convert iblock into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|iblock
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;runlist.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|ntfs_rl_vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Only read initialized data blocks. */
r_if
c_cond
(paren
id|iblock
OL
id|zblock
)paren
(brace
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|bh
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Fully non-initialized data block, zero it. */
r_goto
id|handle_zblock
suffix:semicolon
)brace
multiline_comment|/* It is a hole, need to zero it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
r_goto
id|handle_hole
suffix:semicolon
multiline_comment|/* If first try and runlist unmapped, map and retry. */
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
r_int
id|err
suffix:semicolon
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Attempt to map runlist, dropping lock for&n;&t;&t;&t;&t; * the duration.&n;&t;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_map_runlist
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|lcn
op_assign
id|err
suffix:semicolon
)brace
multiline_comment|/* Hard error, zero out region. */
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to read from inode 0x%lx, &quot;
l_string|&quot;attribute type 0x%x, vcn 0x%llx, &quot;
l_string|&quot;offset 0x%x because its location on &quot;
l_string|&quot;disk could not be determined%s &quot;
l_string|&quot;(error code %lli).&quot;
comma
id|ni-&gt;mft_no
comma
id|ni-&gt;type
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|vcn_ofs
comma
id|is_retry
ques
c_cond
l_string|&quot; even after &quot;
l_string|&quot;retrying&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Either iblock was outside lblock limits or&n;&t;&t; * ntfs_rl_vcn_to_lcn() returned error.  Just zero that portion&n;&t;&t; * of the page and set the buffer uptodate.&n;&t;&t; */
id|handle_hole
suffix:colon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1UL
suffix:semicolon
id|clear_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
id|handle_zblock
suffix:colon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
multiline_comment|/* Check we have at least one buffer ready for i/o. */
r_if
c_cond
(paren
id|nr
)paren
(brace
r_struct
id|buffer_head
op_star
id|tbh
suffix:semicolon
multiline_comment|/* Lock the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|ntfs_end_buffer_async_read
suffix:semicolon
id|set_buffer_async_read
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Finally, start i/o on the buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|tbh
)paren
suffix:semicolon
r_else
id|ntfs_end_buffer_async_read
c_func
(paren
id|tbh
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No i/o was scheduled on any of the buffers. */
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
multiline_comment|/* Signal synchronous i/o error. */
id|nr
op_assign
op_minus
id|EIO
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_readpage - fill a @page of a @file with data from the device&n; * @file:&t;open file to which the page @page belongs or NULL&n; * @page:&t;page cache page to fill with data&n; *&n; * For non-resident attributes, ntfs_readpage() fills the @page of the open&n; * file @file by calling the ntfs version of the generic block_read_full_page()&n; * function, ntfs_read_block(), which in turn creates and reads in the buffers&n; * associated with the page asynchronously.&n; *&n; * For resident attributes, OTOH, ntfs_readpage() fills @page by copying the&n; * data from the mft record (which at this stage is most likely in memory) and&n; * fills the remainder with zeroes. Thus, in this case, I/O is synchronous, as&n; * even if the mft record is not cached at this point in time, we need to wait&n; * for it to be read in before we can do the copy.&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_readpage
r_static
r_int
id|ntfs_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|loff_t
id|i_size
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
id|u8
op_star
id|kaddr
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|mrec
suffix:semicolon
id|u32
id|attr_len
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This can potentially happen because we clear PageUptodate() during&n;&t; * ntfs_writepage() of MstProtected() attributes.&n;&t; */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|page-&gt;mapping-&gt;host
)paren
suffix:semicolon
multiline_comment|/* NInoNonResident() == NInoIndexAllocPresent() */
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed or&n;&t;&t; * encrypted.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
r_return
id|ntfs_read_compressed_block
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_read_block
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute is resident, implying it is not compressed or encrypted.&n;&t; * This also means the attribute is smaller than an mft record and&n;&t; * hence smaller than a page, so can simply zero out any pages with&n;&t; * index above 0.  We can also do this if the file size is 0.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|page-&gt;index
OG
l_int|0
op_logical_or
op_logical_neg
id|i_size_read
c_func
(paren
id|VFS_I
c_func
(paren
id|ni
)paren
)paren
)paren
)paren
(brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
multiline_comment|/* Map, pin, and lock the mft record. */
id|mrec
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|mrec
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|mrec
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|base_ni
comma
id|mrec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|unm_err_out
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|put_unm_err_out
suffix:semicolon
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
id|i_size
op_assign
id|i_size_read
c_func
(paren
id|VFS_I
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|attr_len
OG
id|i_size
)paren
)paren
id|attr_len
op_assign
id|i_size
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/* Copy the data to the page. */
id|memcpy
c_func
(paren
id|kaddr
comma
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
comma
id|attr_len
)paren
suffix:semicolon
multiline_comment|/* Zero the remainder of the page. */
id|memset
c_func
(paren
id|kaddr
op_plus
id|attr_len
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|attr_len
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|put_unm_err_out
suffix:colon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unm_err_out
suffix:colon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|done
suffix:colon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|err_out
suffix:colon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * ntfs_write_block - write a @page to the backing store&n; * @page:&t;page cache page to write out&n; * @wbc:&t;writeback control structure&n; *&n; * This function is for writing pages belonging to non-resident, non-mst&n; * protected attributes to their backing store.&n; *&n; * For a page with buffers, map and write the dirty buffers asynchronously&n; * under page writeback. For a page without buffers, create buffers for the&n; * page, then proceed as above.&n; *&n; * If a page doesn&squot;t have buffers the page dirty state is definitive. If a page&n; * does have buffers, the page dirty state is just a hint, and the buffer dirty&n; * state is definitive. (A hint which has rules: dirty buffers against a clean&n; * page is illegal. Other combinations are legal and need to be handled. In&n; * particular a dirty page containing clean buffers for example.)&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Based on ntfs_read_block() and __block_write_full_page().&n; */
DECL|function|ntfs_write_block
r_static
r_int
id|ntfs_write_block
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|sector_t
id|block
comma
id|dblock
comma
id|iblock
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|vcn_ofs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BOOL
id|need_end_writeback
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx.&quot;
comma
id|ni-&gt;mft_no
comma
id|ni-&gt;type
comma
id|page-&gt;index
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|blocksize_bits
op_assign
id|vi-&gt;i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
(paren
l_int|1
op_lshift
id|BH_Uptodate
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bh
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Error allocating page buffers. &quot;
l_string|&quot;Redirtying page so we try again later.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put the page back on mapping-&gt;dirty_pages, but leave its&n;&t;&t; * buffer&squot;s dirty state as-is.&n;&t;&t; */
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NOTE: Different naming scheme to ntfs_read_block()! */
multiline_comment|/* The first block in the page. */
id|block
op_assign
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
multiline_comment|/* The first out of bounds block for the data size. */
id|dblock
op_assign
(paren
id|vi-&gt;i_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* The last (fully or partially) initialized block. */
id|iblock
op_assign
id|ni-&gt;initialized_size
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/*&n;&t; * Be very careful.  We have no exclusion from __set_page_dirty_buffers&n;&t; * here, and the (potentially unmapped) buffers may become dirty at&n;&t; * any time.  If a buffer becomes dirty here after we&squot;ve inspected it&n;&t; * then we just miss that fact, and the page stays dirty.&n;&t; *&n;&t; * Buffers outside i_size may be dirtied by __set_page_dirty_buffers;&n;&t; * handle that here by just cleaning them.&n;&t; */
multiline_comment|/*&n;&t; * Loop through all the buffers in the page, mapping all the dirty&n;&t; * buffers to disk addresses and handling any aliases from the&n;&t; * underlying block device&squot;s mapping.&n;&t; */
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|block
op_ge
id|dblock
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Mapped buffers outside i_size will occur, because&n;&t;&t;&t; * this page can be outside i_size when there is a&n;&t;&t;&t; * truncate in progress. The contents of such buffers&n;&t;&t;&t; * were zeroed by ntfs_writepage().&n;&t;&t;&t; *&n;&t;&t;&t; * FIXME: What about the small race window where&n;&t;&t;&t; * ntfs_writepage() has not done any clearing because&n;&t;&t;&t; * the page was within i_size but before we get here,&n;&t;&t;&t; * vmtruncate() modifies i_size?&n;&t;&t;&t; */
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Clean buffers are not written out, so no need to map them. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Make sure we have enough initialized size. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|block
op_ge
id|iblock
)paren
op_logical_and
(paren
id|ni-&gt;initialized_size
OL
id|vi-&gt;i_size
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If this page is fully outside initialized size, zero&n;&t;&t;&t; * out all pages between the current initialized size&n;&t;&t;&t; * and the current page. Just use ntfs_readpage() to do&n;&t;&t;&t; * the zeroing transparently.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|block
OG
id|iblock
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// For each page do:
singleline_comment|// - read_cache_page()
singleline_comment|// Again for each page do:
singleline_comment|// - wait_on_page_locked()
singleline_comment|// - Check (PageUptodate(page) &amp;&amp;
singleline_comment|//&t;&t;&t;!PageError(page))
singleline_comment|// Update initialized size in the attribute and
singleline_comment|// in the inode.
singleline_comment|// Again, for each page do:
singleline_comment|//&t;__set_page_dirty_buffers();
singleline_comment|// page_cache_release()
singleline_comment|// We don&squot;t need to wait on the writes.
singleline_comment|// Update iblock.
)brace
multiline_comment|/*&n;&t;&t;&t; * The current page straddles initialized size. Zero&n;&t;&t;&t; * all non-uptodate buffers and set them uptodate (and&n;&t;&t;&t; * dirty?). Note, there aren&squot;t any non-uptodate buffers&n;&t;&t;&t; * if the page is uptodate.&n;&t;&t;&t; * FIXME: For an uptodate page, the buffers may need to&n;&t;&t;&t; * be written out because they were not initialized on&n;&t;&t;&t; * disk before.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// Zero any non-uptodate buffers up to i_size.
singleline_comment|// Set them uptodate and dirty.
)brace
singleline_comment|// TODO:
singleline_comment|// Update initialized size in the attribute and in the
singleline_comment|// inode (up to i_size).
singleline_comment|// Update iblock.
singleline_comment|// FIXME: This is inefficient. Try to batch the two
singleline_comment|// size changes to happen in one go.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing beyond initialized size &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// Do NOT set_buffer_new() BUT DO clear buffer range
singleline_comment|// outside write request range.
singleline_comment|// set_buffer_uptodate() on complete buffers as well as
singleline_comment|// set_buffer_dirty().
)brace
multiline_comment|/* No need to map buffers that are already mapped. */
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Unmapped, dirty buffer. Need to map it. */
id|bh-&gt;b_bdev
op_assign
id|vol-&gt;sb-&gt;s_bdev
suffix:semicolon
multiline_comment|/* Convert block into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|block
op_lshift
id|blocksize_bits
suffix:semicolon
id|vcn_ofs
op_assign
id|vcn
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|vcn
op_rshift_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;runlist.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|ntfs_rl_vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|lcn
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Setup buffer head to point to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* It is a hole, need to instantiate it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
(brace
singleline_comment|// TODO: Instantiate the hole.
singleline_comment|// clear_buffer_new(bh);
singleline_comment|// unmap_underlying_metadata(bh-&gt;b_bdev, bh-&gt;b_blocknr);
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing into sparse regions is &quot;
l_string|&quot;not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If first try and runlist unmapped, map and retry. */
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Attempt to map runlist, dropping lock for&n;&t;&t;&t; * the duration.&n;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_map_runlist
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|lcn
op_assign
id|err
suffix:semicolon
)brace
multiline_comment|/* Failed to map the buffer, even after retrying. */
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to write to inode 0x%lx, &quot;
l_string|&quot;attribute type 0x%x, vcn 0x%llx, offset 0x%x &quot;
l_string|&quot;because its location on disk could not be &quot;
l_string|&quot;determined%s (error code %lli).&quot;
comma
id|ni-&gt;mft_no
comma
id|ni-&gt;type
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|vcn_ofs
comma
id|is_retry
ques
c_cond
l_string|&quot; even after &quot;
l_string|&quot;retrying&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
multiline_comment|/* For the error case, need to reset bh to the beginning. */
id|bh
op_assign
id|head
suffix:semicolon
multiline_comment|/* Just an optimization, so -&gt;readpage() isn&squot;t called later. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
)paren
(brace
r_int
id|uptodate
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|uptodate
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uptodate
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup all mapped, dirty buffers for async write i/o. */
r_do
(brace
id|get_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
op_logical_and
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_clear_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|mark_buffer_async_write
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * For the error case. The buffer may have been set&n;&t;&t;&t; * dirty during attachment to a dirty page.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|err
op_ne
op_minus
id|ENOMEM
)paren
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
singleline_comment|// TODO: Remove the -EOPNOTSUPP check later on...
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_eq
op_minus
id|EOPNOTSUPP
)paren
)paren
id|err
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Error allocating memory. &quot;
l_string|&quot;Redirtying page so we try again &quot;
l_string|&quot;later.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Put the page back on mapping-&gt;dirty_pages, but&n;&t;&t;&t; * leave its buffer&squot;s dirty state as-is.&n;&t;&t;&t; */
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Keeps try_to_free_buffers() away. */
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Submit the prepared buffers for i/o. Note the page is unlocked,&n;&t; * and the async write i/o completion handler can end_page_writeback()&n;&t; * at any time after the *first* submit_bh(). So the buffers can then&n;&t; * disappear...&n;&t; */
id|need_end_writeback
op_assign
id|TRUE
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_async_write
c_func
(paren
id|bh
)paren
)paren
(brace
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|need_end_writeback
op_assign
id|FALSE
suffix:semicolon
)brace
id|put_bh
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* If no i/o was started, need to end_page_writeback(). */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|need_end_writeback
)paren
)paren
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_write_mst_block - write a @page to the backing store&n; * @page:&t;page cache page to write out&n; * @wbc:&t;writeback control structure&n; *&n; * This function is for writing pages belonging to non-resident, mst protected&n; * attributes to their backing store.  The only supported attributes are index&n; * allocation and $MFT/$DATA.  Both directory inodes and index inodes are&n; * supported for the index allocation case.&n; *&n; * The page must remain locked for the duration of the write because we apply&n; * the mst fixups, write, and then undo the fixups, so if we were to unlock the&n; * page before undoing the fixups, any other user of the page will see the&n; * page contents as corrupt.&n; *&n; * We clear the page uptodate flag for the duration of the function to ensure&n; * exclusion for the $MFT/$DATA case against someone mapping an mft record we&n; * are about to apply the mst fixups to.&n; *&n; * Return 0 on success and -errno on error.&n; *&n; * Based on ntfs_write_block(), ntfs_mft_writepage(), and&n; * write_mft_record_nolock().&n; */
DECL|function|ntfs_write_mst_block
r_static
r_int
id|ntfs_write_mst_block
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
id|sector_t
id|block
comma
id|dblock
comma
id|rec_block
suffix:semicolon
r_struct
id|inode
op_star
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|u8
op_star
id|kaddr
suffix:semicolon
r_int
r_char
id|bh_size_bits
op_assign
id|vi-&gt;i_blkbits
suffix:semicolon
r_int
r_int
id|bh_size
op_assign
l_int|1
op_lshift
id|bh_size_bits
suffix:semicolon
r_int
r_int
id|rec_size
op_assign
id|ni-&gt;itype.index.block_size
suffix:semicolon
id|ntfs_inode
op_star
id|locked_nis
(braket
id|PAGE_CACHE_SIZE
op_div
id|rec_size
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|tbh
comma
op_star
id|rec_start_bh
suffix:semicolon
r_int
id|max_bhs
op_assign
id|PAGE_CACHE_SIZE
op_div
id|bh_size
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhs
(braket
id|max_bhs
)braket
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_int
id|i
comma
id|nr_locked_nis
comma
id|nr_recs
comma
id|nr_bhs
comma
id|bhs_per_rec
comma
id|err
comma
id|err2
suffix:semicolon
r_int
id|rec_size_bits
suffix:semicolon
id|BOOL
id|sync
comma
id|is_mft
comma
id|page_is_dirty
comma
id|rec_is_dirty
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|is_mft
op_assign
(paren
id|S_ISREG
c_func
(paren
id|vi-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|vi-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE: ntfs_write_mst_block() would be called for $MFTMirr if a page&n;&t; * in its page cache were to be marked dirty.  However this should&n;&t; * never happen with the current driver and considering we do not&n;&t; * handle this case here we do want to BUG(), at least for now.&n;&t; */
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|is_mft
op_logical_or
id|S_ISDIR
c_func
(paren
id|vi-&gt;i_mode
)paren
op_logical_or
(paren
id|NInoAttr
c_func
(paren
id|ni
)paren
op_logical_and
id|ni-&gt;type
op_eq
id|AT_INDEX_ALLOCATION
)paren
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|max_bhs
)paren
suffix:semicolon
multiline_comment|/* Were we called for sync purposes? */
id|sync
op_assign
(paren
id|wbc-&gt;sync_mode
op_eq
id|WB_SYNC_ALL
)paren
suffix:semicolon
multiline_comment|/* Make sure we have mapped buffers. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bh
)paren
suffix:semicolon
id|rec_size_bits
op_assign
id|ni-&gt;itype.index.block_size_bits
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
(paren
id|PAGE_CACHE_SIZE
op_rshift
id|rec_size_bits
)paren
)paren
suffix:semicolon
id|bhs_per_rec
op_assign
id|rec_size
op_rshift
id|bh_size_bits
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|bhs_per_rec
)paren
suffix:semicolon
multiline_comment|/* The first block in the page. */
id|rec_block
op_assign
id|block
op_assign
(paren
id|sector_t
)paren
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|bh_size_bits
)paren
suffix:semicolon
multiline_comment|/* The first out of bounds block for the data size. */
id|dblock
op_assign
(paren
id|vi-&gt;i_size
op_plus
id|bh_size
op_minus
l_int|1
)paren
op_rshift
id|bh_size_bits
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
id|err2
op_assign
id|nr_bhs
op_assign
id|nr_recs
op_assign
id|nr_locked_nis
op_assign
l_int|0
suffix:semicolon
id|page_is_dirty
op_assign
id|rec_is_dirty
op_assign
id|FALSE
suffix:semicolon
id|rec_start_bh
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
id|BOOL
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
id|block
OL
id|rec_block
)paren
)paren
(brace
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|block
op_ge
id|dblock
)paren
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * This block is not the first one in the record.  We&n;&t;&t;&t; * ignore the buffer&squot;s dirty state because we could&n;&t;&t;&t; * have raced with a parallel mark_ntfs_record_dirty().&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rec_is_dirty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err2
)paren
)paren
(brace
r_if
c_cond
(paren
id|err2
op_ne
op_minus
id|ENOMEM
)paren
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (block == rec_block) */
(brace
id|BUG_ON
c_func
(paren
id|block
OG
id|rec_block
)paren
suffix:semicolon
multiline_comment|/* This block is the first one in the record. */
id|rec_block
op_add_assign
id|bhs_per_rec
suffix:semicolon
id|err2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|block
op_ge
id|dblock
)paren
)paren
(brace
id|clear_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Clean records are not written out. */
id|rec_is_dirty
op_assign
id|FALSE
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rec_is_dirty
op_assign
id|TRUE
suffix:semicolon
id|rec_start_bh
op_assign
id|bh
suffix:semicolon
)brace
multiline_comment|/* Need to map the buffer if it is not mapped already. */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
r_int
r_int
id|vcn_ofs
suffix:semicolon
multiline_comment|/* Obtain the vcn and offset of the current block. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|block
op_lshift
id|bh_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
id|vcn
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|vcn
op_rshift_assign
id|vol-&gt;cluster_size_bits
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;runlist.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|ntfs_rl_vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
multiline_comment|/* Successful remap. */
r_if
c_cond
(paren
id|likely
c_func
(paren
id|lcn
op_ge
l_int|0
)paren
)paren
(brace
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|bh_size_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Remap failed.  Retry to map the runlist once&n;&t;&t;&t;&t; * unless we are working on $MFT which always&n;&t;&t;&t;&t; * has the whole of its runlist in memory.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|is_mft
op_logical_and
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Attempt to map runlist, dropping&n;&t;&t;&t;&t;&t; * lock for the duration.&n;&t;&t;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|err2
op_assign
id|ntfs_map_runlist
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err2
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
r_if
c_cond
(paren
id|err2
op_eq
op_minus
id|ENOMEM
)paren
id|page_is_dirty
op_assign
id|TRUE
suffix:semicolon
id|lcn
op_assign
id|err2
suffix:semicolon
)brace
r_else
id|err2
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Hard error.  Abort writing this record. */
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_or
id|err
op_eq
op_minus
id|ENOMEM
)paren
id|err
op_assign
id|err2
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Cannot write ntfs record &quot;
l_string|&quot;0x%llx (inode 0x%lx, &quot;
l_string|&quot;attribute type 0x%x) because &quot;
l_string|&quot;its location on disk could &quot;
l_string|&quot;not be determined (error &quot;
l_string|&quot;code %lli).&quot;
comma
(paren
id|s64
)paren
id|block
op_lshift
id|bh_size_bits
op_rshift
id|vol-&gt;mft_record_size_bits
comma
id|ni-&gt;mft_no
comma
id|ni-&gt;type
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If this is not the first buffer, remove the&n;&t;&t;&t;&t; * buffers in this record from the list of&n;&t;&t;&t;&t; * buffers to write and clear their dirty bit&n;&t;&t;&t;&t; * if not error -ENOMEM.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|rec_start_bh
op_ne
id|bh
)paren
(brace
r_while
c_loop
(paren
id|bhs
(braket
op_decrement
id|nr_bhs
)braket
op_ne
id|rec_start_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err2
op_ne
op_minus
id|ENOMEM
)paren
(brace
r_do
(brace
id|clear_buffer_dirty
c_func
(paren
id|rec_start_bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|rec_start_bh
op_assign
id|rec_start_bh
op_member_access_from_pointer
id|b_this_page
)paren
op_ne
id|bh
)paren
suffix:semicolon
)brace
)brace
r_continue
suffix:semicolon
)brace
)brace
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|nr_bhs
op_ge
id|max_bhs
)paren
suffix:semicolon
id|bhs
(braket
id|nr_bhs
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|rl
)paren
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
multiline_comment|/* If there were no dirty buffers, we are done. */
r_if
c_cond
(paren
op_logical_neg
id|nr_bhs
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Map the page so we can access its contents. */
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Clear the page uptodate flag whilst the mst fixups are applied. */
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|ofs
suffix:semicolon
multiline_comment|/* Skip buffers which are not at the beginning of records. */
r_if
c_cond
(paren
id|i
op_mod
id|bhs_per_rec
)paren
r_continue
suffix:semicolon
id|tbh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
id|ofs
op_assign
id|bh_offset
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_mft
)paren
(brace
id|ntfs_inode
op_star
id|tni
suffix:semicolon
r_int
r_int
id|mft_no
suffix:semicolon
multiline_comment|/* Get the mft record number. */
id|mft_no
op_assign
(paren
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|ofs
)paren
op_rshift
id|rec_size_bits
suffix:semicolon
multiline_comment|/* Check whether to write this mft record. */
id|tni
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_may_write_mft_record
c_func
(paren
id|vol
comma
id|mft_no
comma
(paren
id|MFT_RECORD
op_star
)paren
(paren
id|kaddr
op_plus
id|ofs
)paren
comma
op_amp
id|tni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The record should not be written.  This&n;&t;&t;&t;&t; * means we need to redirty the page before&n;&t;&t;&t;&t; * returning.&n;&t;&t;&t;&t; */
id|page_is_dirty
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Remove the buffers in this mft record from&n;&t;&t;&t;&t; * the list of buffers to write.&n;&t;&t;&t;&t; */
r_do
(brace
id|bhs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
op_mod
id|bhs_per_rec
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * The record should be written.  If a locked ntfs&n;&t;&t;&t; * inode was returned, add it to the array of locked&n;&t;&t;&t; * ntfs inodes.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tni
)paren
id|locked_nis
(braket
id|nr_locked_nis
op_increment
)braket
op_assign
id|tni
suffix:semicolon
)brace
multiline_comment|/* Apply the mst protection fixups. */
id|err2
op_assign
id|pre_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
(paren
id|kaddr
op_plus
id|ofs
)paren
comma
id|rec_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err2
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_or
id|err
op_eq
op_minus
id|ENOMEM
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to apply mst fixups &quot;
l_string|&quot;(inode 0x%lx, attribute type 0x%x, &quot;
l_string|&quot;page index 0x%lx, page offset 0x%x)!&quot;
l_string|&quot;  Unmount and run chkdsk.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|ofs
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Mark all the buffers in this record clean as we do&n;&t;&t;&t; * not want to write corrupt data to disk.&n;&t;&t;&t; */
r_do
(brace
id|clear_buffer_dirty
c_func
(paren
id|bhs
(braket
id|i
)braket
)paren
suffix:semicolon
id|bhs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|i
op_mod
id|bhs_per_rec
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|nr_recs
op_increment
suffix:semicolon
)brace
multiline_comment|/* If no records are to be written out, we are done. */
r_if
c_cond
(paren
op_logical_neg
id|nr_recs
)paren
r_goto
id|unm_done
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Lock buffers and start synchronous write i/o on them. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbh
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|test_set_buffer_locked
c_func
(paren
id|tbh
)paren
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The buffer dirty state is now irrelevant, just clean it. */
id|clear_buffer_dirty
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
id|get_bh
c_func
(paren
id|tbh
)paren
suffix:semicolon
id|tbh-&gt;b_end_io
op_assign
id|end_buffer_write_sync
suffix:semicolon
id|submit_bh
c_func
(paren
id|WRITE
comma
id|tbh
)paren
suffix:semicolon
)brace
multiline_comment|/* Synchronize the mft mirror now if not @sync. */
r_if
c_cond
(paren
id|is_mft
op_logical_and
op_logical_neg
id|sync
)paren
r_goto
id|do_mirror
suffix:semicolon
id|do_wait
suffix:colon
multiline_comment|/* Wait on i/o completion of buffers. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tbh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbh
)paren
r_continue
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tbh
)paren
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;I/O error while writing ntfs &quot;
l_string|&quot;record buffer (inode 0x%lx, &quot;
l_string|&quot;attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, page offset 0x%lx)!  Unmount &quot;
l_string|&quot;and run chkdsk.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|bh_offset
c_func
(paren
id|tbh
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_or
id|err
op_eq
op_minus
id|ENOMEM
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Set the buffer uptodate so the page and buffer&n;&t;&t;&t; * states do not become out of sync.&n;&t;&t;&t; */
id|set_buffer_uptodate
c_func
(paren
id|tbh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If @sync, now synchronize the mft mirror. */
r_if
c_cond
(paren
id|is_mft
op_logical_and
id|sync
)paren
(brace
id|do_mirror
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|mft_no
suffix:semicolon
r_int
r_int
id|ofs
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Skip buffers which are not at the beginning of&n;&t;&t;&t; * records.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|i
op_mod
id|bhs_per_rec
)paren
r_continue
suffix:semicolon
id|tbh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Skip removed buffers (and hence records). */
r_if
c_cond
(paren
op_logical_neg
id|tbh
)paren
r_continue
suffix:semicolon
id|ofs
op_assign
id|bh_offset
c_func
(paren
id|tbh
)paren
suffix:semicolon
multiline_comment|/* Get the mft record number. */
id|mft_no
op_assign
(paren
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|ofs
)paren
op_rshift
id|rec_size_bits
suffix:semicolon
r_if
c_cond
(paren
id|mft_no
OL
id|vol-&gt;mftmirr_size
)paren
id|ntfs_sync_mft_mirror
c_func
(paren
id|vol
comma
id|mft_no
comma
(paren
id|MFT_RECORD
op_star
)paren
(paren
id|kaddr
op_plus
id|ofs
)paren
comma
id|sync
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sync
)paren
r_goto
id|do_wait
suffix:semicolon
)brace
multiline_comment|/* Remove the mst protection fixups again. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_bhs
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
id|bhs_per_rec
)paren
)paren
(brace
id|tbh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbh
)paren
r_continue
suffix:semicolon
id|post_write_mst_fixup
c_func
(paren
(paren
id|NTFS_RECORD
op_star
)paren
(paren
id|kaddr
op_plus
id|bh_offset
c_func
(paren
id|tbh
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|unm_done
suffix:colon
multiline_comment|/* Unlock any locked inodes. */
r_while
c_loop
(paren
id|nr_locked_nis
op_decrement
OG
l_int|0
)paren
(brace
id|ntfs_inode
op_star
id|tni
comma
op_star
id|base_tni
suffix:semicolon
id|tni
op_assign
id|locked_nis
(braket
id|nr_locked_nis
)braket
suffix:semicolon
multiline_comment|/* Get the base inode. */
id|down
c_func
(paren
op_amp
id|tni-&gt;extent_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tni-&gt;nr_extents
op_ge
l_int|0
)paren
id|base_tni
op_assign
id|tni
suffix:semicolon
r_else
(brace
id|base_tni
op_assign
id|tni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|base_tni
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tni-&gt;extent_lock
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Unlocking %s inode 0x%lx.&quot;
comma
id|tni
op_eq
id|base_tni
ques
c_cond
l_string|&quot;base&quot;
suffix:colon
l_string|&quot;extent&quot;
comma
id|tni-&gt;mft_no
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tni-&gt;mrec_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|tni-&gt;count
)paren
suffix:semicolon
id|iput
c_func
(paren
id|VFS_I
c_func
(paren
id|base_tni
)paren
)paren
suffix:semicolon
)brace
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
op_logical_and
id|err
op_ne
op_minus
id|ENOMEM
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Set page error if there is only one ntfs record in the page.&n;&t;&t; * Otherwise we would loose per-record granularity.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;itype.index.block_size
op_eq
id|PAGE_CACHE_SIZE
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page_is_dirty
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Page still contains one or more dirty ntfs &quot;
l_string|&quot;records.  Redirtying the page starting at &quot;
l_string|&quot;record 0x%lx.&quot;
comma
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|rec_size_bits
)paren
)paren
suffix:semicolon
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Keep the VM happy.  This must be done otherwise the&n;&t;&t; * radix-tree tag PAGECACHE_TAG_DIRTY remains set even though&n;&t;&t; * the page is clean.&n;&t;&t; */
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_writepage - write a @page to the backing store&n; * @page:&t;page cache page to write out&n; * @wbc:&t;writeback control structure&n; *&n; * This is called from the VM when it wants to have a dirty ntfs page cache&n; * page cleaned.  The VM has already locked the page and marked it clean.&n; *&n; * For non-resident attributes, ntfs_writepage() writes the @page by calling&n; * the ntfs version of the generic block_write_full_page() function,&n; * ntfs_write_block(), which in turn if necessary creates and writes the&n; * buffers associated with the page asynchronously.&n; *&n; * For resident attributes, OTOH, ntfs_writepage() writes the @page by copying&n; * the data to the mft record (which at this stage is most likely in memory).&n; * The mft record is then marked dirty and written out asynchronously via the&n; * vfs inode dirty code path for the inode the mft record belongs to or via the&n; * vm page dirty code path for the page the mft record is in.&n; *&n; * Based on ntfs_readpage() and fs/buffer.c::block_write_full_page().&n; *&n; * Return 0 on success and -errno on error.&n; */
DECL|function|ntfs_writepage
r_static
r_int
id|ntfs_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_struct
id|writeback_control
op_star
id|wbc
)paren
(brace
id|loff_t
id|i_size
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
comma
op_star
id|base_ni
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|u32
id|attr_len
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|i_size
op_assign
id|i_size_read
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* Is the page fully outside i_size? (truncate in progress) */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|page-&gt;index
op_ge
(paren
id|i_size
op_plus
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The page may have dirty, unmapped buffers.  Make them&n;&t;&t; * freeable here, so the page does not leak.&n;&t;&t; */
id|block_invalidatepage
c_func
(paren
id|page
comma
l_int|0
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Write outside i_size - truncated?&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
multiline_comment|/* NInoNonResident() == NInoIndexAllocPresent() */
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed, encrypted,&n;&t;&t; * and/or sparse.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Denying write access to encrypted &quot;
l_string|&quot;file.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// TODO: Implement and replace this check with
singleline_comment|// return ntfs_write_compressed_block(page);
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to compressed &quot;
l_string|&quot;files is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoSparse
c_func
(paren
id|ni
)paren
)paren
(brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to sparse files &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
multiline_comment|/* We have to zero every time due to mmap-at-end-of-file. */
r_if
c_cond
(paren
id|page-&gt;index
op_ge
(paren
id|i_size
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
multiline_comment|/* The page straddles i_size. */
r_int
r_int
id|ofs
op_assign
id|i_size
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|ofs
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|ofs
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle mst protected attributes. */
r_if
c_cond
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
r_return
id|ntfs_write_mst_block
c_func
(paren
id|page
comma
id|wbc
)paren
suffix:semicolon
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_write_block
c_func
(paren
id|page
comma
id|wbc
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute is resident, implying it is not compressed, encrypted,&n;&t; * sparse, or mst protected.  This also means the attribute is smaller&n;&t; * than an mft record and hence smaller than a page, so can simply&n;&t; * return error on any pages with index above 0.&n;&t; */
id|BUG_ON
c_func
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|page-&gt;index
OG
l_int|0
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;BUG()! page-&gt;index (0x%lx) &gt; 0.  &quot;
l_string|&quot;Aborting write.&quot;
comma
id|page-&gt;index
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
multiline_comment|/* Map, pin, and lock the mft record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/*&n;&t; * Keep the VM happy.  This must be done otherwise the radix-tree tag&n;&t; * PAGECACHE_TAG_DIRTY remains set even though the page is clean.&n;&t; */
id|BUG_ON
c_func
(paren
id|PageWriteback
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|set_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Here, we don&squot;t need to zero the out of bounds area everytime because&n;&t; * the below memcpy() already takes care of the mmap-at-end-of-file&n;&t; * requirements. If the file is converted to a non-resident one, then&n;&t; * the code path use is switched to the non-resident one where the&n;&t; * zeroing happens on each ntfs_writepage() invocation.&n;&t; *&n;&t; * The above also applies nicely when i_size is decreased.&n;&t; *&n;&t; * When i_size is increased, the memory between the old and new i_size&n;&t; * _must_ be zeroed (or overwritten with new data). Otherwise we will&n;&t; * expose data to userspace/disk which should never have been exposed.&n;&t; *&n;&t; * FIXME: Ensure that i_size increases do the zeroing/overwriting and&n;&t; * if we cannot guarantee that, then enable the zeroing below.  If the&n;&t; * zeroing below is enabled, we MUST move the unlock_page() from above&n;&t; * to after the kunmap_atomic(), i.e. just before the&n;&t; * end_page_writeback().&n;&t; * UPDATE: ntfs_prepare/commit_write() do the zeroing on i_size&n;&t; * increases for resident attributes so those are ok.&n;&t; * TODO: ntfs_truncate(), others?&n;&t; */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_length
)paren
suffix:semicolon
id|i_size
op_assign
id|i_size_read
c_func
(paren
id|VFS_I
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|attr_len
OG
id|i_size
)paren
)paren
(brace
multiline_comment|/* Zero out of bounds area in the mft record. */
id|memset
c_func
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
op_plus
id|i_size
comma
l_int|0
comma
id|attr_len
op_minus
id|i_size
)paren
suffix:semicolon
id|attr_len
op_assign
id|i_size
suffix:semicolon
)brace
multiline_comment|/* Copy the data from the page to the mft record. */
id|memcpy
c_func
(paren
(paren
id|u8
op_star
)paren
id|ctx-&gt;attr
op_plus
id|le16_to_cpu
c_func
(paren
id|ctx-&gt;attr-&gt;data.resident.value_offset
)paren
comma
id|kaddr
comma
id|attr_len
)paren
suffix:semicolon
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
multiline_comment|/* Zero out of bounds area in the page cache page. */
id|memset
c_func
(paren
id|kaddr
op_plus
id|attr_len
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|attr_len
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|end_page_writeback
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Mark the mft record dirty, so it gets written back. */
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Error allocating memory. Redirtying &quot;
l_string|&quot;page so we try again later.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Put the page back on mapping-&gt;dirty_pages, but leave its&n;&t;&t; * buffers&squot; dirty state as-is.&n;&t;&t; */
id|redirty_page_for_writepage
c_func
(paren
id|wbc
comma
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Resident attribute write failed with &quot;
l_string|&quot;error %i.  Setting page error flag.&quot;
comma
id|err
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_prepare_nonresident_write -&n; *&n; */
DECL|function|ntfs_prepare_nonresident_write
r_static
r_int
id|ntfs_prepare_nonresident_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|VCN
id|vcn
suffix:semicolon
id|LCN
id|lcn
suffix:semicolon
id|sector_t
id|block
comma
id|ablock
comma
id|iblock
suffix:semicolon
r_struct
id|inode
op_star
id|vi
suffix:semicolon
id|ntfs_inode
op_star
id|ni
suffix:semicolon
id|ntfs_volume
op_star
id|vol
suffix:semicolon
id|runlist_element
op_star
id|rl
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|wait
(braket
l_int|2
)braket
comma
op_star
op_star
id|wait_bh
op_assign
id|wait
suffix:semicolon
r_int
r_int
id|vcn_ofs
comma
id|block_start
comma
id|block_end
comma
id|blocksize
suffix:semicolon
r_int
id|err
suffix:semicolon
id|BOOL
id|is_retry
suffix:semicolon
r_int
r_char
id|blocksize_bits
suffix:semicolon
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|ni-&gt;mft_no
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
id|blocksize_bits
op_assign
id|vi-&gt;i_blkbits
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/*&n;&t; * create_empty_buffers() will create uptodate/dirty buffers if the&n;&t; * page is uptodate/dirty.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|0
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|bh
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* The first block in the page. */
id|block
op_assign
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|blocksize_bits
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The first out of bounds block for the allocated size. No need to&n;&t; * round up as allocated_size is in multiples of cluster size and the&n;&t; * minimum cluster size is 512 bytes, which is equal to the smallest&n;&t; * blocksize.&n;&t; */
id|ablock
op_assign
id|ni-&gt;allocated_size
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* The last (fully or partially) initialized block. */
id|iblock
op_assign
id|ni-&gt;initialized_size
op_rshift
id|blocksize_bits
suffix:semicolon
multiline_comment|/* Loop through all the buffers in the page. */
id|block_start
op_assign
l_int|0
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If buffer @bh is outside the write, just mark it uptodate&n;&t;&t; * if the page is uptodate and continue with the next buffer.&n;&t;&t; */
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * @bh is at least partially being written to.&n;&t;&t; * Make sure it is not marked as new.&n;&t;&t; */
singleline_comment|//if (buffer_new(bh))
singleline_comment|//&t;clear_buffer_new(bh);
r_if
c_cond
(paren
id|block
op_ge
id|ablock
)paren
(brace
singleline_comment|// TODO: block is above allocated_size, need to
singleline_comment|// allocate it. Best done in one go to accommodate not
singleline_comment|// only block but all above blocks up to and including:
singleline_comment|// ((page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) + to + blocksize
singleline_comment|// - 1) &gt;&gt; blobksize_bits. Obviously will need to round
singleline_comment|// up to next cluster boundary, too. This should be
singleline_comment|// done with a helper function, so it can be reused.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing beyond allocated size &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
singleline_comment|// Need to update ablock.
singleline_comment|// Need to set_buffer_new() on all block bhs that are
singleline_comment|// newly allocated.
)brace
multiline_comment|/*&n;&t;&t; * Now we have enough allocated size to fulfill the whole&n;&t;&t; * request, i.e. block &lt; ablock is true.&n;&t;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
(paren
id|block
op_ge
id|iblock
)paren
op_logical_and
(paren
id|ni-&gt;initialized_size
OL
id|vi-&gt;i_size
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If this page is fully outside initialized size, zero&n;&t;&t;&t; * out all pages between the current initialized size&n;&t;&t;&t; * and the current page. Just use ntfs_readpage() to do&n;&t;&t;&t; * the zeroing transparently.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|block
OG
id|iblock
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// For each page do:
singleline_comment|// - read_cache_page()
singleline_comment|// Again for each page do:
singleline_comment|// - wait_on_page_locked()
singleline_comment|// - Check (PageUptodate(page) &amp;&amp;
singleline_comment|//&t;&t;&t;!PageError(page))
singleline_comment|// Update initialized size in the attribute and
singleline_comment|// in the inode.
singleline_comment|// Again, for each page do:
singleline_comment|//&t;__set_page_dirty_buffers();
singleline_comment|// page_cache_release()
singleline_comment|// We don&squot;t need to wait on the writes.
singleline_comment|// Update iblock.
)brace
multiline_comment|/*&n;&t;&t;&t; * The current page straddles initialized size. Zero&n;&t;&t;&t; * all non-uptodate buffers and set them uptodate (and&n;&t;&t;&t; * dirty?). Note, there aren&squot;t any non-uptodate buffers&n;&t;&t;&t; * if the page is uptodate.&n;&t;&t;&t; * FIXME: For an uptodate page, the buffers may need to&n;&t;&t;&t; * be written out because they were not initialized on&n;&t;&t;&t; * disk before.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
singleline_comment|// TODO:
singleline_comment|// Zero any non-uptodate buffers up to i_size.
singleline_comment|// Set them uptodate and dirty.
)brace
singleline_comment|// TODO:
singleline_comment|// Update initialized size in the attribute and in the
singleline_comment|// inode (up to i_size).
singleline_comment|// Update iblock.
singleline_comment|// FIXME: This is inefficient. Try to batch the two
singleline_comment|// size changes to happen in one go.
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing beyond initialized size &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
singleline_comment|// Do NOT set_buffer_new() BUT DO clear buffer range
singleline_comment|// outside write request range.
singleline_comment|// set_buffer_uptodate() on complete buffers as well as
singleline_comment|// set_buffer_dirty().
)brace
multiline_comment|/* Need to map unmapped buffers. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Unmapped buffer. Need to map it. */
id|bh-&gt;b_bdev
op_assign
id|vol-&gt;sb-&gt;s_bdev
suffix:semicolon
multiline_comment|/* Convert block into corresponding vcn and offset. */
id|vcn
op_assign
(paren
id|VCN
)paren
id|block
op_lshift
id|blocksize_bits
op_rshift
id|vol-&gt;cluster_size_bits
suffix:semicolon
id|vcn_ofs
op_assign
(paren
(paren
id|VCN
)paren
id|block
op_lshift
id|blocksize_bits
)paren
op_amp
id|vol-&gt;cluster_size_mask
suffix:semicolon
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rl
)paren
(brace
id|lock_retry_remap
suffix:colon
id|down_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
id|ni-&gt;runlist.rl
suffix:semicolon
)brace
r_if
c_cond
(paren
id|likely
c_func
(paren
id|rl
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Seek to element containing target vcn. */
r_while
c_loop
(paren
id|rl-&gt;length
op_logical_and
id|rl
(braket
l_int|1
)braket
dot
id|vcn
op_le
id|vcn
)paren
id|rl
op_increment
suffix:semicolon
id|lcn
op_assign
id|ntfs_rl_vcn_to_lcn
c_func
(paren
id|rl
comma
id|vcn
)paren
suffix:semicolon
)brace
r_else
id|lcn
op_assign
id|LCN_RL_NOT_MAPPED
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|lcn
OL
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We extended the attribute allocation above.&n;&t;&t;&t;&t; * If we hit an ENOENT here it means that the&n;&t;&t;&t;&t; * allocation was insufficient which is a bug.&n;&t;&t;&t;&t; */
id|BUG_ON
c_func
(paren
id|lcn
op_eq
id|LCN_ENOENT
)paren
suffix:semicolon
multiline_comment|/* It is a hole, need to instantiate it. */
r_if
c_cond
(paren
id|lcn
op_eq
id|LCN_HOLE
)paren
(brace
singleline_comment|// TODO: Instantiate the hole.
singleline_comment|// clear_buffer_new(bh);
singleline_comment|// unmap_underlying_metadata(bh-&gt;b_bdev,
singleline_comment|//&t;&t;bh-&gt;b_blocknr);
singleline_comment|// For non-uptodate buffers, need to
singleline_comment|// zero out the region outside the
singleline_comment|// request in this bh or all bhs,
singleline_comment|// depending on what we implemented
singleline_comment|// above.
singleline_comment|// Need to flush_dcache_page().
singleline_comment|// Or could use set_buffer_new()
singleline_comment|// instead?
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Writing into &quot;
l_string|&quot;sparse regions is &quot;
l_string|&quot;not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|is_retry
op_logical_and
id|lcn
op_eq
id|LCN_RL_NOT_MAPPED
)paren
(brace
id|is_retry
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Attempt to map runlist, dropping&n;&t;&t;&t;&t;&t; * lock for the duration.&n;&t;&t;&t;&t;&t; */
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_map_runlist
c_func
(paren
id|ni
comma
id|vcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|err
)paren
)paren
r_goto
id|lock_retry_remap
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
id|lcn
op_assign
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Failed to map the buffer, even after&n;&t;&t;&t;&t; * retrying.&n;&t;&t;&t;&t; */
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Failed to write to inode &quot;
l_string|&quot;0x%lx, attribute type 0x%x, &quot;
l_string|&quot;vcn 0x%llx, offset 0x%x &quot;
l_string|&quot;because its location on disk &quot;
l_string|&quot;could not be determined%s &quot;
l_string|&quot;(error code %lli).&quot;
comma
id|ni-&gt;mft_no
comma
id|ni-&gt;type
comma
(paren
r_int
r_int
r_int
)paren
id|vcn
comma
id|vcn_ofs
comma
id|is_retry
ques
c_cond
l_string|&quot; even &quot;
l_string|&quot;after retrying&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
r_int
r_int
)paren
id|lcn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
multiline_comment|/* We now have a successful remap, i.e. lcn &gt;= 0. */
multiline_comment|/* Setup buffer head to correct block. */
id|bh-&gt;b_blocknr
op_assign
(paren
(paren
id|lcn
op_lshift
id|vol-&gt;cluster_size_bits
)paren
op_plus
id|vcn_ofs
)paren
op_rshift
id|blocksize_bits
suffix:semicolon
id|set_buffer_mapped
c_func
(paren
id|bh
)paren
suffix:semicolon
singleline_comment|// FIXME: Something analogous to this is needed for
singleline_comment|// each newly allocated block, i.e. BH_New.
singleline_comment|// FIXME: Might need to take this out of the
singleline_comment|// if (!buffer_mapped(bh)) {}, depending on how we
singleline_comment|// implement things during the allocated_size and
singleline_comment|// initialized_size extension code above.
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|unmap_underlying_metadata
c_func
(paren
id|bh-&gt;b_bdev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Page is _not_ uptodate, zero surrounding&n;&t;&t;&t;&t; * region. NOTE: This is how we decide if to&n;&t;&t;&t;&t; * zero or not!&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|block_end
OG
id|to
op_logical_or
id|block_start
OL
id|from
)paren
(brace
r_void
op_star
id|kaddr
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_end
OG
id|to
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|to
comma
l_int|0
comma
id|block_end
op_minus
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_start
OL
id|from
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|from
op_minus
id|block_start
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* @bh is mapped, set it uptodate if the page is uptodate. */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The page is not uptodate. The buffer is mapped. If it is not&n;&t;&t; * uptodate, and it is only partially being written to, we need&n;&t;&t; * to read the buffer in before the write, i.e. right now.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
(paren
id|block_start
template_param
id|to
)paren
)paren
(brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
op_star
id|wait_bh
op_increment
op_assign
id|bh
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|block
op_increment
comma
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Release the lock if we took it. */
r_if
c_cond
(paren
id|rl
)paren
(brace
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
id|rl
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* If we issued read requests, let them complete. */
r_while
c_loop
(paren
id|wait_bh
OG
id|wait
)paren
(brace
id|wait_on_buffer
c_func
(paren
op_star
op_decrement
id|wait_bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
op_star
id|wait_bh
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
multiline_comment|/*&n;&t; * Zero out any newly allocated blocks to avoid exposing stale data.&n;&t; * If BH_New is set, we know that the block was newly allocated in the&n;&t; * above loop.&n;&t; * FIXME: What about initialized_size increments? Have we done all the&n;&t; * required zeroing above? If not this error handling is broken, and&n;&t; * in particular the if (block_end &lt;= from) check is completely bogus.&n;&t; */
id|bh
op_assign
id|head
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|is_retry
op_assign
id|FALSE
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|block_start
op_ge
id|to
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
r_void
op_star
id|kaddr
suffix:semicolon
id|clear_buffer_new
c_func
(paren
id|bh
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|is_retry
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_retry
)paren
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rl
)paren
id|up_read
c_func
(paren
op_amp
id|ni-&gt;runlist.lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_prepare_write - prepare a page for receiving data&n; *&n; * This is called from generic_file_write() with i_sem held on the inode&n; * (@page-&gt;mapping-&gt;host).  The @page is locked but not kmap()ped.  The source&n; * data has not yet been copied into the @page.&n; *&n; * Need to extend the attribute/fill in holes if necessary, create blocks and&n; * make partially overwritten blocks uptodate,&n; *&n; * i_size is not to be modified yet.&n; *&n; * Return 0 on success or -errno on error.&n; *&n; * Should be using block_prepare_write() [support for sparse files] or&n; * cont_prepare_write() [no support for sparse files].  Cannot do that due to&n; * ntfs specifics but can look at them for implementation guidance.&n; *&n; * Note: In the range, @from is inclusive and @to is exclusive, i.e. @from is&n; * the first byte in the page that will be written to and @to is the first byte&n; * after the last byte that will be written to.&n; */
DECL|function|ntfs_prepare_write
r_static
r_int
id|ntfs_prepare_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|s64
id|new_size
suffix:semicolon
r_struct
id|inode
op_star
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ntfs_inode
op_star
id|base_ni
op_assign
l_int|NULL
comma
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ni-&gt;vol
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
op_assign
l_int|NULL
suffix:semicolon
id|MFT_RECORD
op_star
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|u8
op_star
id|kaddr
suffix:semicolon
id|u32
id|attr_len
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|from
OG
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|to
OG
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|from
OG
id|to
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|NInoMstProtected
c_func
(paren
id|ni
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If a previous ntfs_truncate() failed, repeat it and abort if it&n;&t; * fails again.&n;&t; */
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|NInoTruncateFailed
c_func
(paren
id|ni
)paren
)paren
)paren
(brace
id|down_write
c_func
(paren
op_amp
id|vi-&gt;i_alloc_sem
)paren
suffix:semicolon
id|err
op_assign
id|ntfs_truncate
c_func
(paren
id|vi
)paren
suffix:semicolon
id|up_write
c_func
(paren
op_amp
id|vi-&gt;i_alloc_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
id|NInoTruncateFailed
c_func
(paren
id|ni
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
)brace
multiline_comment|/* If the attribute is not resident, deal with it elsewhere. */
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Only unnamed $DATA attributes can be compressed, encrypted,&n;&t;&t; * and/or sparse.&n;&t;&t; */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* If file is encrypted, deny access, just like NT4. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Denying write access to encrypted &quot;
l_string|&quot;file.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// TODO: Implement and replace this check with
singleline_comment|// return ntfs_write_compressed_block(page);
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to compressed &quot;
l_string|&quot;files is not supported yet. &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
singleline_comment|// TODO: Implement and remove this check.
r_if
c_cond
(paren
id|NInoSparse
c_func
(paren
id|ni
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing to sparse files &quot;
l_string|&quot;is not supported yet. Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_prepare_nonresident_write
c_func
(paren
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute is resident, implying it is not compressed, encrypted, or&n;&t; * sparse.&n;&t; */
id|BUG_ON
c_func
(paren
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|new_size
op_assign
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
multiline_comment|/* If we do not need to resize the attribute allocation we are done. */
r_if
c_cond
(paren
id|new_size
op_le
id|vi-&gt;i_size
)paren
r_goto
id|done
suffix:semicolon
singleline_comment|// FIXME: We abort for now as this code is not safe.
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Changing the file size is not supported yet.  &quot;
l_string|&quot;Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
multiline_comment|/* Map, pin, and lock the (base) mft record. */
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
id|m
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|m
op_assign
id|ctx-&gt;mrec
suffix:semicolon
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/* The total length of the attribute value. */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|vi-&gt;i_size
op_ne
id|attr_len
)paren
suffix:semicolon
multiline_comment|/* Check if new size is allowed in $AttrDef. */
id|err
op_assign
id|ntfs_attr_size_bounds_check
c_func
(paren
id|vol
comma
id|ni-&gt;type
comma
id|new_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ERANGE
)paren
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Write would cause the inode &quot;
l_string|&quot;0x%lx to exceed the maximum size for &quot;
l_string|&quot;its attribute type (0x%x).  Aborting &quot;
l_string|&quot;write.&quot;
comma
id|vi-&gt;i_ino
comma
id|le32_to_cpu
c_func
(paren
id|ni-&gt;type
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Inode 0x%lx has unknown &quot;
l_string|&quot;attribute type 0x%x.  Aborting &quot;
l_string|&quot;write.&quot;
comma
id|vi-&gt;i_ino
comma
id|le32_to_cpu
c_func
(paren
id|ni-&gt;type
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_goto
id|err_out2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Extend the attribute record to be able to store the new attribute&n;&t; * size.&n;&t; */
r_if
c_cond
(paren
id|new_size
op_ge
id|vol-&gt;mft_record_size
op_logical_or
id|ntfs_attr_record_resize
c_func
(paren
id|m
comma
id|a
comma
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_offset
)paren
op_plus
id|new_size
)paren
)paren
(brace
multiline_comment|/* Not enough space in the mft record. */
id|ntfs_error
c_func
(paren
id|vol-&gt;sb
comma
l_string|&quot;Not enough space in the mft record for &quot;
l_string|&quot;the resized attribute value.  This is not &quot;
l_string|&quot;supported yet.  Aborting write.&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
r_goto
id|err_out2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have enough space in the mft record to fit the write.  This&n;&t; * implies the attribute is smaller than the mft record and hence the&n;&t; * attribute must be in a single page and hence page-&gt;index must be 0.&n;&t; */
id|BUG_ON
c_func
(paren
id|page-&gt;index
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the beginning of the write is past the old size, enlarge the&n;&t; * attribute value up to the beginning of the write and fill it with&n;&t; * zeroes.&n;&t; */
r_if
c_cond
(paren
id|from
OG
id|attr_len
)paren
(brace
id|memset
c_func
(paren
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_offset
)paren
op_plus
id|attr_len
comma
l_int|0
comma
id|from
op_minus
id|attr_len
)paren
suffix:semicolon
id|a-&gt;data.resident.value_length
op_assign
id|cpu_to_le32
c_func
(paren
id|from
)paren
suffix:semicolon
multiline_comment|/* Zero the corresponding area in the page as well. */
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|attr_len
comma
l_int|0
comma
id|from
op_minus
id|attr_len
)paren
suffix:semicolon
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Because resident attributes are handled by memcpy() to/from the&n;&t; * corresponding MFT record, and because this form of i/o is byte&n;&t; * aligned rather than block aligned, there is no need to bring the&n;&t; * page uptodate here as in the non-resident case where we need to&n;&t; * bring the buffers straddled by the write uptodate before&n;&t; * generic_file_write() does the copying from userspace.&n;&t; *&n;&t; * We thus defer the uptodate bringing of the page region outside the&n;&t; * region written to to ntfs_commit_write(), which makes the code&n;&t; * simpler and saves one atomic kmap which is good.&n;&t; */
id|done
suffix:colon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Error allocating memory required to &quot;
l_string|&quot;prepare the write.&quot;
)paren
suffix:semicolon
r_else
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Resident attribute prepare write failed &quot;
l_string|&quot;with error %i.&quot;
comma
id|err
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|vol
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
id|err_out2
suffix:colon
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_commit_nonresident_write -&n; *&n; */
DECL|function|ntfs_commit_nonresident_write
r_static
r_int
id|ntfs_commit_nonresident_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|s64
id|pos
op_assign
(paren
(paren
id|s64
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
r_struct
id|inode
op_star
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|block_start
comma
id|block_end
comma
id|blocksize
suffix:semicolon
id|BOOL
id|partial
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|vi-&gt;i_ino
comma
id|NTFS_I
c_func
(paren
id|vi
)paren
op_member_access_from_pointer
id|type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|blocksize
op_assign
l_int|1
op_lshift
id|vi-&gt;i_blkbits
suffix:semicolon
singleline_comment|// FIXME: We need a whole slew of special cases in here for compressed
singleline_comment|// files for example...
singleline_comment|// For now, we know ntfs_prepare_write() would have failed so we can&squot;t
singleline_comment|// get here in any of the cases which we have to special case, so we
singleline_comment|// are just a ripped off, unrolled generic_commit_write().
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|block_start
op_assign
l_int|0
suffix:semicolon
id|partial
op_assign
id|FALSE
suffix:semicolon
r_do
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|partial
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|block_start
op_assign
id|block_end
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a partial write which happened to make all buffers&n;&t; * uptodate then we can optimize away a bogus -&gt;readpage() for the next&n;&t; * read().  Here we &squot;discover&squot; whether the page went uptodate as a&n;&t; * result of this (potentially partial) write.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Not convinced about this at all.  See disparity comment above.  For&n;&t; * now we know ntfs_prepare_write() would have failed in the write&n;&t; * exceeds i_size case, so this will never trigger which is fine.&n;&t; */
r_if
c_cond
(paren
id|pos
OG
id|vi-&gt;i_size
)paren
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Writing beyond the existing file size is &quot;
l_string|&quot;not supported yet.  Sorry.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
singleline_comment|// vi-&gt;i_size = pos;
singleline_comment|// mark_inode_dirty(vi);
)brace
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * ntfs_commit_write - commit the received data&n; *&n; * This is called from generic_file_write() with i_sem held on the inode&n; * (@page-&gt;mapping-&gt;host).  The @page is locked but not kmap()ped.  The source&n; * data has already been copied into the @page.  ntfs_prepare_write() has been&n; * called before the data copied and it returned success so we can take the&n; * results of various BUG checks and some error handling for granted.&n; *&n; * Need to mark modified blocks dirty so they get written out later when&n; * ntfs_writepage() is invoked by the VM.&n; *&n; * Return 0 on success or -errno on error.&n; *&n; * Should be using generic_commit_write().  This marks buffers uptodate and&n; * dirty, sets the page uptodate if all buffers in the page are uptodate, and&n; * updates i_size if the end of io is beyond i_size.  In that case, it also&n; * marks the inode dirty.&n; *&n; * Cannot use generic_commit_write() due to ntfs specialities but can look at&n; * it for implementation guidance.&n; *&n; * If things have gone as outlined in ntfs_prepare_write(), then we do not&n; * need to do any page content modifications here at all, except in the write&n; * to resident attribute case, where we need to do the uptodate bringing here&n; * which we combine with the copying into the mft record which means we save&n; * one atomic kmap.&n; */
DECL|function|ntfs_commit_write
r_static
r_int
id|ntfs_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|vi
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|ntfs_inode
op_star
id|base_ni
comma
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|vi
)paren
suffix:semicolon
r_char
op_star
id|kaddr
comma
op_star
id|kattr
suffix:semicolon
id|ntfs_attr_search_ctx
op_star
id|ctx
suffix:semicolon
id|MFT_RECORD
op_star
id|m
suffix:semicolon
id|ATTR_RECORD
op_star
id|a
suffix:semicolon
id|u32
id|attr_len
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Entering for inode 0x%lx, attribute type 0x%x, page index &quot;
l_string|&quot;0x%lx, from = %u, to = %u.&quot;
comma
id|vi-&gt;i_ino
comma
id|ni-&gt;type
comma
id|page-&gt;index
comma
id|from
comma
id|to
)paren
suffix:semicolon
multiline_comment|/* If the attribute is not resident, deal with it elsewhere. */
r_if
c_cond
(paren
id|NInoNonResident
c_func
(paren
id|ni
)paren
)paren
(brace
multiline_comment|/* Only unnamed $DATA attributes can be compressed/encrypted. */
r_if
c_cond
(paren
id|ni-&gt;type
op_eq
id|AT_DATA
op_logical_and
op_logical_neg
id|ni-&gt;name_len
)paren
(brace
multiline_comment|/* Encrypted files need separate handling. */
r_if
c_cond
(paren
id|NInoEncrypted
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// We never get here at present!
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Compressed data streams are handled in compress.c. */
r_if
c_cond
(paren
id|NInoCompressed
c_func
(paren
id|ni
)paren
)paren
(brace
singleline_comment|// TODO: Implement this!
singleline_comment|// return ntfs_write_compressed_block(page);
singleline_comment|// We never get here at present!
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Normal data stream. */
r_return
id|ntfs_commit_nonresident_write
c_func
(paren
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attribute is resident, implying it is not compressed, encrypted, or&n;&t; * sparse.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|NInoAttr
c_func
(paren
id|ni
)paren
)paren
id|base_ni
op_assign
id|ni
suffix:semicolon
r_else
id|base_ni
op_assign
id|ni-&gt;ext.base_ntfs_ino
suffix:semicolon
multiline_comment|/* Map, pin, and lock the mft record. */
id|m
op_assign
id|map_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|m
)paren
)paren
(brace
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|m
)paren
suffix:semicolon
id|m
op_assign
l_int|NULL
suffix:semicolon
id|ctx
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|ctx
op_assign
id|ntfs_attr_get_search_ctx
c_func
(paren
id|base_ni
comma
id|m
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|ctx
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|err
op_assign
id|ntfs_attr_lookup
c_func
(paren
id|ni-&gt;type
comma
id|ni-&gt;name
comma
id|ni-&gt;name_len
comma
id|CASE_SENSITIVE
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|err
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOENT
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|a
op_assign
id|ctx-&gt;attr
suffix:semicolon
multiline_comment|/* The total length of the attribute value. */
id|attr_len
op_assign
id|le32_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_length
)paren
suffix:semicolon
id|BUG_ON
c_func
(paren
id|from
OG
id|attr_len
)paren
suffix:semicolon
id|kattr
op_assign
(paren
id|u8
op_star
)paren
id|a
op_plus
id|le16_to_cpu
c_func
(paren
id|a-&gt;data.resident.value_offset
)paren
suffix:semicolon
id|kaddr
op_assign
id|kmap_atomic
c_func
(paren
id|page
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/* Copy the received data from the page to the mft record. */
id|memcpy
c_func
(paren
id|kattr
op_plus
id|from
comma
id|kaddr
op_plus
id|from
comma
id|to
op_minus
id|from
)paren
suffix:semicolon
multiline_comment|/* Update the attribute length if necessary. */
r_if
c_cond
(paren
id|to
OG
id|attr_len
)paren
(brace
id|attr_len
op_assign
id|to
suffix:semicolon
id|a-&gt;data.resident.value_length
op_assign
id|cpu_to_le32
c_func
(paren
id|attr_len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the page is not uptodate, bring the out of bounds area(s)&n;&t; * uptodate by copying data from the mft record to the page.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
r_if
c_cond
(paren
id|from
OG
l_int|0
)paren
id|memcpy
c_func
(paren
id|kaddr
comma
id|kattr
comma
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to
OL
id|attr_len
)paren
id|memcpy
c_func
(paren
id|kaddr
op_plus
id|to
comma
id|kattr
op_plus
id|to
comma
id|attr_len
op_minus
id|to
)paren
suffix:semicolon
multiline_comment|/* Zero the region outside the end of the attribute value. */
r_if
c_cond
(paren
id|attr_len
OL
id|PAGE_CACHE_SIZE
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|attr_len
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|attr_len
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The probability of not having done any of the above is&n;&t;&t; * extremely small, so we just flush unconditionally.&n;&t;&t; */
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|kunmap_atomic
c_func
(paren
id|kaddr
comma
id|KM_USER0
)paren
suffix:semicolon
multiline_comment|/* Update i_size if necessary. */
r_if
c_cond
(paren
id|vi-&gt;i_size
OL
id|attr_len
)paren
(brace
id|ni-&gt;allocated_size
op_assign
id|ni-&gt;initialized_size
op_assign
id|attr_len
suffix:semicolon
id|i_size_write
c_func
(paren
id|vi
comma
id|attr_len
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark the mft record dirty, so it gets written back. */
id|flush_dcache_mft_record_page
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|mark_mft_record_dirty
c_func
(paren
id|ctx-&gt;ntfs_ino
)paren
suffix:semicolon
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
l_string|&quot;Done.&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOMEM
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Error allocating memory required to &quot;
l_string|&quot;commit the write.&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|ntfs_warning
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Page is uptodate, setting &quot;
l_string|&quot;dirty so the write will be retried &quot;
l_string|&quot;later on by the VM.&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Put the page on mapping-&gt;dirty_pages, but leave its&n;&t;&t;&t; * buffers&squot; dirty state as-is.&n;&t;&t;&t; */
id|__set_page_dirty_nobuffers
c_func
(paren
id|page
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Page is not uptodate.  Written &quot;
l_string|&quot;data has been lost.&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ntfs_error
c_func
(paren
id|vi-&gt;i_sb
comma
l_string|&quot;Resident attribute commit write failed &quot;
l_string|&quot;with error %i.&quot;
comma
id|err
)paren
suffix:semicolon
id|NVolSetErrors
c_func
(paren
id|ni-&gt;vol
)paren
suffix:semicolon
id|make_bad_inode
c_func
(paren
id|vi
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctx
)paren
id|ntfs_attr_put_search_ctx
c_func
(paren
id|ctx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m
)paren
id|unmap_mft_record
c_func
(paren
id|base_ni
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif&t;/* NTFS_RW */
multiline_comment|/**&n; * ntfs_aops - general address space operations for inodes and attributes&n; */
DECL|variable|ntfs_aops
r_struct
id|address_space_operations
id|ntfs_aops
op_assign
(brace
dot
id|readpage
op_assign
id|ntfs_readpage
comma
multiline_comment|/* Fill page with data. */
dot
id|sync_page
op_assign
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
macro_line|#ifdef NTFS_RW
dot
id|writepage
op_assign
id|ntfs_writepage
comma
multiline_comment|/* Write dirty page to disk. */
dot
id|prepare_write
op_assign
id|ntfs_prepare_write
comma
multiline_comment|/* Prepare page and buffers&n;&t;&t;&t;&t;&t;&t;   ready to receive data. */
dot
id|commit_write
op_assign
id|ntfs_commit_write
comma
multiline_comment|/* Commit received data. */
macro_line|#endif /* NTFS_RW */
)brace
suffix:semicolon
multiline_comment|/**&n; * ntfs_mst_aops - general address space operations for mst protecteed inodes&n; *&t;&t;   and attributes&n; */
DECL|variable|ntfs_mst_aops
r_struct
id|address_space_operations
id|ntfs_mst_aops
op_assign
(brace
dot
id|readpage
op_assign
id|ntfs_readpage
comma
multiline_comment|/* Fill page with data. */
dot
id|sync_page
op_assign
id|block_sync_page
comma
multiline_comment|/* Currently, just unplugs the&n;&t;&t;&t;&t;&t;&t;   disk request queue. */
macro_line|#ifdef NTFS_RW
dot
id|writepage
op_assign
id|ntfs_writepage
comma
multiline_comment|/* Write dirty page to disk. */
dot
id|set_page_dirty
op_assign
id|__set_page_dirty_nobuffers
comma
multiline_comment|/* Set the page dirty&n;&t;&t;&t;&t;&t;&t;   without touching the buffers&n;&t;&t;&t;&t;&t;&t;   belonging to the page. */
macro_line|#endif /* NTFS_RW */
)brace
suffix:semicolon
macro_line|#ifdef NTFS_RW
multiline_comment|/**&n; * mark_ntfs_record_dirty - mark an ntfs record dirty&n; * @page:&t;page containing the ntfs record to mark dirty&n; * @ofs:&t;byte offset within @page at which the ntfs record begins&n; *&n; * Set the buffers and the page in which the ntfs record is located dirty.&n; *&n; * The latter also marks the vfs inode the ntfs record belongs to dirty&n; * (I_DIRTY_PAGES only).&n; *&n; * If the page does not have buffers, we create them and set them uptodate.&n; * The page may not be locked which is why we need to handle the buffers under&n; * the mapping-&gt;private_lock.  Once the buffers are marked dirty we no longer&n; * need the lock since try_to_free_buffers() does not free dirty buffers.&n; */
DECL|function|mark_ntfs_record_dirty
r_void
id|mark_ntfs_record_dirty
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_const
r_int
r_int
id|ofs
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
id|ntfs_inode
op_star
id|ni
op_assign
id|NTFS_I
c_func
(paren
id|mapping-&gt;host
)paren
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|buffers_to_free
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|end
comma
id|bh_size
comma
id|bh_ofs
suffix:semicolon
id|BUG_ON
c_func
(paren
op_logical_neg
id|PageUptodate
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|end
op_assign
id|ofs
op_plus
id|ni-&gt;itype.index.block_size
suffix:semicolon
id|bh_size
op_assign
l_int|1
op_lshift
id|VFS_I
c_func
(paren
id|ni
)paren
op_member_access_from_pointer
id|i_blkbits
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
id|bh
op_assign
id|head
op_assign
id|alloc_page_buffers
c_func
(paren
id|page
comma
id|bh_size
comma
l_int|1
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|likely
c_func
(paren
op_logical_neg
id|page_has_buffers
c_func
(paren
id|page
)paren
)paren
)paren
(brace
r_struct
id|buffer_head
op_star
id|tail
suffix:semicolon
r_do
(brace
id|set_buffer_uptodate
c_func
(paren
id|bh
)paren
suffix:semicolon
id|tail
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
)paren
suffix:semicolon
id|tail-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|attach_page_buffers
c_func
(paren
id|page
comma
id|head
)paren
suffix:semicolon
)brace
r_else
id|buffers_to_free
op_assign
id|bh
suffix:semicolon
)brace
id|bh
op_assign
id|head
op_assign
id|page_buffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_do
(brace
id|bh_ofs
op_assign
id|bh_offset
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh_ofs
op_plus
id|bh_size
op_le
id|ofs
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|bh_ofs
op_ge
id|end
)paren
)paren
r_break
suffix:semicolon
id|set_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|mapping-&gt;private_lock
)paren
suffix:semicolon
id|__set_page_dirty_nobuffers
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlikely
c_func
(paren
id|buffers_to_free
)paren
)paren
(brace
r_do
(brace
id|bh
op_assign
id|buffers_to_free-&gt;b_this_page
suffix:semicolon
id|free_buffer_head
c_func
(paren
id|buffers_to_free
)paren
suffix:semicolon
id|buffers_to_free
op_assign
id|bh
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buffers_to_free
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* NTFS_RW */
eof
